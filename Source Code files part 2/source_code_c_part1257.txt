kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);

                    printf("[%03X]", NabtsFECBuffer[nNextRead].groupID );
                    nStatus = Driver.ReadData( NabtsFECBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
        
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "Syntax: TESTNAB [-s] [ substream1 [substream2] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\vbi\tests\testcc\testcc.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <wincon.h>
#include <conio.h>


#include <ccdecode.h>

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

#define CONCURRENT_READS    180 
#define READ_BUFFER_SIZE    2

/* Update statistics every n milliseconds (16ms is generally too fast) */
#define UPDATE_PERIOD       100

void
PrintStatistics( ICCDecode &Driver, int row, int column, BOOL bSavePosition)
{
HANDLE                                  hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
COORD                                   Pos = {(short)row, (short)column};
CONSOLE_SCREEN_BUFFER_INFO              SavedPos;
VBICODECFILTERING_STATISTICS_CC         Statistics;
VBICODECFILTERING_STATISTICS_CC_PIN     PinStatistics;
VBICODECFILTERING_SCANLINES             ScanlinesRequested, ScanlinesDiscovered;
VBICODECFILTERING_CC_SUBSTREAMS         VideoFieldsRequested, VideoFieldsDiscovered;

char    szBuffer[11][80];
if ( bSavePosition )
     GetConsoleScreenBufferInfo( hStdout, &SavedPos );
SetConsoleCursorPosition( hStdout, Pos );

if ( Driver.GetCodecStatistics( Statistics ) == 0 )
    {

    memset( &ScanlinesRequested, 0, sizeof(ScanlinesRequested) );
    memset( &ScanlinesDiscovered, 0, sizeof(ScanlinesDiscovered) );
    memset( &VideoFieldsRequested, 0, sizeof(VideoFieldsRequested) );
    memset( &VideoFieldsDiscovered, 0, sizeof(VideoFieldsDiscovered) );

    Driver.m_ScanlinesRequested.GetValue(&ScanlinesRequested);
    Driver.m_SubstreamsRequested.GetValue(&VideoFieldsRequested);
    Driver.m_ScanlinesDiscovered.GetValue(&ScanlinesDiscovered);
    Driver.m_SubstreamsDiscovered.GetValue(&VideoFieldsDiscovered);

    sprintf(szBuffer[0], "-----R:%08x:%08x----- CC Codec Statistics ------D:%08x:%08x-----",
            ScanlinesRequested.DwordBitArray[0], VideoFieldsRequested.SubstreamMask, 
            ScanlinesDiscovered.DwordBitArray[0], VideoFieldsDiscovered.SubstreamMask );
    sprintf(szBuffer[1], "InputSRBsProcessed: %u, OutputSRBsProcessed: %u, SRBsIgnored: %u",
            Statistics.Common.InputSRBsProcessed, Statistics.Common.OutputSRBsProcessed, Statistics.Common.SRBsIgnored );
    sprintf(szBuffer[2], "InputSRBsMissing: %u, OutputSRBsMissing: %u, OutputFailures: %u", 
            Statistics.Common.InputSRBsMissing, Statistics.Common.OutputSRBsMissing, Statistics.Common.OutputFailures );
    sprintf(szBuffer[3], "InternalErrors: %u, ExternalErrors: %u, InputDiscontinuities: %u",
            Statistics.Common.InternalErrors, Statistics.Common.ExternalErrors, Statistics.Common.InputDiscontinuities );
    sprintf(szBuffer[4], "DSPFailures: %u, TvTunerChanges: %u, VBIHeaderChanges: %u",
            Statistics.Common.DSPFailures, Statistics.Common.TvTunerChanges, Statistics.Common.VBIHeaderChanges );
    sprintf(szBuffer[5], "LineConfidenceAvg: %u, BytesOutput: %u",
            Statistics.Common.LineConfidenceAvg, Statistics.Common.BytesOutput );
    }

if ( Driver.GetPinStatistics( PinStatistics ) == 0 )
    {
    memset( &ScanlinesRequested, 0, sizeof(ScanlinesRequested) );
    memset( &ScanlinesDiscovered, 0, sizeof(ScanlinesDiscovered) );
    memset( &VideoFieldsRequested, 0, sizeof(VideoFieldsRequested) );
    memset( &VideoFieldsDiscovered, 0, sizeof(VideoFieldsDiscovered) );

    Driver.m_OutputPin.m_ScanlinesRequested.GetValue(&ScanlinesRequested);
    Driver.m_OutputPin.m_SubstreamsRequested.GetValue(&VideoFieldsRequested);
    Driver.m_OutputPin.m_ScanlinesDiscovered.GetValue(&ScanlinesDiscovered);
    Driver.m_OutputPin.m_SubstreamsDiscovered.GetValue(&VideoFieldsDiscovered);

    sprintf(szBuffer[6], "-----R:%08x:%08x------- CCPin Statistics -------D:%08x:%08x-----",
            ScanlinesRequested.DwordBitArray[0], VideoFieldsRequested.SubstreamMask, 
            ScanlinesDiscovered.DwordBitArray[0], VideoFieldsDiscovered.SubstreamMask );
    sprintf(szBuffer[7], "SRBsProcessed: %u, SRBsMissing: %u, SRBsIgnored: %u",
            PinStatistics.Common.SRBsProcessed, PinStatistics.Common.SRBsMissing, PinStatistics.Common.SRBsIgnored );
    sprintf(szBuffer[8], "InternalErrors: %u, ExternalErrors: %u, Discontinuities: %u",
            PinStatistics.Common.InternalErrors, PinStatistics.Common.ExternalErrors, PinStatistics.Common.Discontinuities );
    sprintf(szBuffer[9], "LineConfidenceAvg: %u, BytesOutput: %u", 
            PinStatistics.Common.LineConfidenceAvg, PinStatistics.Common.BytesOutput );
    sprintf(szBuffer[10], "===============================================================================");

    printf("%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n",
            szBuffer[0], szBuffer[1], szBuffer[2], szBuffer[3], szBuffer[4], 
            szBuffer[5], szBuffer[6], szBuffer[7], szBuffer[8], szBuffer[9],
            szBuffer[10] );

    }
if ( bSavePosition )
	SetConsoleCursorPosition( hStdout, SavedPos.dwCursorPosition );
}

void
interpret_Vchip(unsigned char *buf, int buflen)
{
	static int m_bGetVChip = FALSE;
	static int m_bGetCurrentOnEven = FALSE;
	//long lLevel = -1;
	unsigned char *bp, *ep;

    bp = buf;
	ep = &buf[buflen];
	while (bp < ep)
    {
		UCHAR ucData = *bp++;

		if ( m_bGetVChip )
		{
			// state is we are looking for vchip data
			if ( ucData & 0x40 )
			{
				UCHAR ucData2;
				
				if (bp >= ep)
					break;

				// it's a valid char, get the next one
				ucData2 = *bp++;		

				// we have a valid one, determine what it is
				if ( !(ucData & 0x08) )
				{
					// MPAA
					UCHAR ucMPAA = (ucData & 0x07);
					printf("\bVChip MPAA-" );
					switch ( ucMPAA )
					{
					case 0x00:
						printf("NONE");
						break;
					case 0x01:
						printf("G");
						break;
					case 0x02:
						printf("PG");
						break;
					case 0x03:
						printf("PG13");
						break;
					case 0x04:
						printf("R");
						break;
					case 0x05:
						printf("NC17");
						break;
					case 0x06:
						printf("X");
						break;
					case 0x07:
						printf("NOTRATED");
						break;

					}
					printf("\n");
				}
				else if ( !(ucData & 0x10 ) )
				{
						// TV Parental Guidelines
					if ( ucData2 & 0x40 )
					{
						UCHAR ucTVParental = (ucData2 & 0x07);
						printf("\bVChip TVP-" );

						switch ( ucTVParental )
						{
						case 0x00:
							printf("NONE");
							break;
						case 0x01:
							printf("Y");
							break;
						case 0x02:
							printf("Y7");
							break;
						case 0x03:
							printf("G");
							break;
						case 0x04:
							printf("PG");
							break;
						case 0x05:
							printf("TV14");
							break;
						case 0x06:
							printf("TVMA");
							break;
						case 0x07:
							printf("NONE");
							break;

						}

						// Now do the TV sub-codes:
						if (ucData & 0x20)
							printf(" D");
						if (ucData2 & 0x20) {
							printf(" ");
							if (0x02 == ucTVParental)
								printf("F");
							printf("V");
						}
						if (ucData2 & 0x10)
							printf(" S");
						if (ucData2 & 0x08)
							printf(" L");

						printf("\n");

					}
					else
					{
						printf("VChip NonUS- 0x%02x 0x%02x\n", ucData, ucData2 );
						// non-US system
					}


				}
				else
				{
					// it's not a valid vchip char
					m_bGetVChip = FALSE;
				}

			}
			else
			{
				// it's not a valid vchip char
				m_bGetVChip = FALSE;
			}

		}
		else if ( m_bGetCurrentOnEven )
		{
			// state is we have started Current Class
			if ( ucData == 0x05 )
			{
				m_bGetVChip = TRUE;
			}
			m_bGetCurrentOnEven = FALSE;

		}
		else
		{
			// state is something else
			if ( ucData == 0x01 || ucData == 0x02 )
			{
				m_bGetCurrentOnEven = TRUE;
			}

		}

    }	
}

int __cdecl
main( int argc, char *argv[] )
{
int	        nStatus = 0;
int         arg = 1; // Next unparsed command line parameter
const int   bDoVchip = arg < argc && strcmp(argv[arg],"-v") == 0 ? arg++ : 0;
const int   bStatistics = arg < argc && strcmp(argv[arg],"-s") == 0 ? arg++ : 0;
long        nLastUpdate = 0;
const int   nScanline = arg < argc ? atoi(argv[arg++]) : 21;  // Closed Captioning Scanline(21)
int         nSubstream = KS_CC_SUBSTREAM_ODD;
unsigned char	VchipBuffer[128], *vcp = VchipBuffer;
int				VchipBytes = 0;

if ( nScanline )
    {
    try {
        ICCDecode	Driver;
        if ( Driver.IsValid() )
            {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

            if ( bStatistics )
                PrintStatistics( Driver, 0, 0, FALSE );

            if ( (nStatus = Driver.ClearRequestedScanlines() ) == 0)
                {
                printf( "Starting decoding%s on line %d", bDoVchip? " [VCHIP mode]":"", nScanline ); // No newline, see below
                if ( (nStatus = Driver.AddRequestedScanline(nScanline) ) != 0)
                    {
                    fprintf( stderr, "\nFailed to AddRequestedScanlines(%d)=%d\n", nScanline, nStatus );
                    return nStatus;
                    }
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedScanlines()=%d\n", nStatus );
                return nStatus;
                }

            if ( ( nStatus = Driver.ClearRequestedVideoFields() ) == 0 )
                {
                do
                    {
                    if ( arg < argc )
                        if ( !(nSubstream = atoi( argv[arg] ) ) )
                            printf( "Invalid substream: '%s'\n", argv[arg] );
                    printf( ", Substream %d", nSubstream );
                    if ( ( nStatus = Driver.AddRequestedVideoField(nSubstream) ) != 0 )
                        {
                        fprintf( stderr, "\nFailed to AddRequestedVideoField(%d)=%d\n", nSubstream, nStatus );
                        return nStatus;
                        }
                    }
                while ( ++arg < argc );
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedVideoFields()=%d\n", nStatus );
                return nStatus;
                }

            printf("\n");

            int         nNextRead = 0;//, nNextCompleted = 0;
            DWORD       nBytes = 0;
            OVERLAPPED  Overlapped[CONCURRENT_READS] = {0};
            BYTE		ccdata[CONCURRENT_READS][READ_BUFFER_SIZE];

            for( nNextRead = 0; !nStatus && nNextRead < CONCURRENT_READS; nNextRead++ )
	            {
	            if ( !( Overlapped[nNextRead].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
                    {
                    nStatus = GetLastError();
                    break;
                    }
                nStatus = Driver.ReadData( ccdata[nNextRead], READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
                if ( !nStatus || nStatus == ERROR_IO_PENDING )
                    nStatus = 0;
                else
                    break;
	            }
            nNextRead = 0;

            while ( !nStatus && !_kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);
                    for(DWORD i=0; i<nBytes; i++ )
                        ccdata[nNextRead][i] &= 0x7F;
	                //printf( "CC Data #%d=%d:[%.*s]\n", nNextRead, nBytes, nBytes, ccdata[nNextRead] );
					if (bDoVchip)
					{
						unsigned int		i;

						for (i = 0; i < nBytes && vcp < &VchipBuffer[sizeof (VchipBuffer)]; ++i, ++VchipBytes)
							*vcp++ = ccdata[nNextRead][i];
						if (VchipBytes >= sizeof (VchipBuffer)) {
							printf(".");
							//printf( "interpret_Vchip([%.*s], %d)\n", VchipBytes, ccdata[nNextRead], VchipBytes );
							interpret_Vchip((unsigned char *)VchipBuffer, VchipBytes);
							vcp = VchipBuffer;
							VchipBytes = 0;
						}
					}
					else
	                    printf("%.*s", nBytes, ccdata[nNextRead]);
        
                    nStatus = Driver.ReadData( ccdata[nNextRead], READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }

                // Drain any chars pressed
                while ( _kbhit() )
                    _getch();
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "CC TESTAPP Syntax: TESTAPP [-v][-s] [scanline [substream1 [substream2] ] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\vbi\tests\testnab\testnab.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <windows.h>
#include <wincon.h>

#include <nabts.h>

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

#define CONCURRENT_READS    180 
#define READ_BUFFER_SIZE    sizeof(NABTSFEC_BUFFER)

/* Update statistics every n milliseconds (16ms is generally too fast) */
#define UPDATE_PERIOD       100

void
PrintStatistics( INabts &Driver, int row, int column, BOOL bSavePosition)
{
HANDLE                                  hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
COORD                                   Pos = {(short)row, (short)column};
CONSOLE_SCREEN_BUFFER_INFO              SavedPos;
VBICODECFILTERING_STATISTICS_NABTS      Statistics;
VBICODECFILTERING_STATISTICS_COMMON_PIN PinStatistics;

if ( Driver.GetCodecStatistics( Statistics ) == 0         
  && Driver.GetPinStatistics( PinStatistics ) == 0 )
    {
    char    szBuffer[13][80] = { 0 };
    if ( bSavePosition )
        GetConsoleScreenBufferInfo( hStdout, &SavedPos );

    SetConsoleCursorPosition( hStdout, Pos );
    
    sprintf(szBuffer[0], "-------------------------- NABTS Codec Statistics -----------------------------");
    sprintf(szBuffer[1], "InputSRBsProcessed: %u, OutputSRBsProcessed: %u, SRBsIgnored: %u",
            Statistics.Common.InputSRBsProcessed, Statistics.Common.OutputSRBsProcessed, Statistics.Common.SRBsIgnored );
    sprintf(szBuffer[2], "InputSRBsMissing: %u, OutputSRBsMissing: %u, OutputFailures: %u", 
            Statistics.Common.InputSRBsMissing, Statistics.Common.OutputSRBsMissing, Statistics.Common.OutputFailures );
    sprintf(szBuffer[3], "InternalErrors: %u, ExternalErrors: %u, InputDiscontinuities: %u",
            Statistics.Common.InternalErrors, Statistics.Common.ExternalErrors, Statistics.Common.InputDiscontinuities );
    sprintf(szBuffer[4], "DSPFailures: %u, TvTunerChanges: %u, VBIHeaderChanges: %u",
            Statistics.Common.DSPFailures, Statistics.Common.TvTunerChanges, Statistics.Common.VBIHeaderChanges );
    sprintf(szBuffer[5], "LineConfidenceAvg: %u, BytesOutput: %u, FECBundleBadLines: %u",
            Statistics.Common.LineConfidenceAvg, Statistics.Common.BytesOutput, Statistics.FECBundleBadLines );
    sprintf(szBuffer[6], "FECQueueOverflows: %u, FECCorrectedLines: %u, FECUncorrectableLines: %u",
            Statistics.FECQueueOverflows, Statistics.FECCorrectedLines, Statistics.FECUncorrectableLines );
    sprintf(szBuffer[7], "BundlesProcessed: %u, BundlesSent2IP: %u, FilteredLines: %u",
            Statistics.BundlesProcessed, Statistics.BundlesSent2IP, Statistics.FilteredLines );
    sprintf(szBuffer[8], "---------------------------- Raw Pin Statistics -------------------------------");
    sprintf(szBuffer[9], "SRBsProcessed: %u, SRBsMissing: %u, SRBsIgnored: %u",
            PinStatistics.SRBsProcessed, PinStatistics.SRBsMissing, PinStatistics.SRBsIgnored );
    sprintf(szBuffer[10], "InternalErrors: %u, ExternalErrors: %u, Discontinuities: %u",
            PinStatistics.InternalErrors, PinStatistics.ExternalErrors, PinStatistics.Discontinuities );
    sprintf(szBuffer[11], "LineConfidenceAvg: %u, BytesOutput: %u", 
            PinStatistics.LineConfidenceAvg, PinStatistics.BytesOutput );
    sprintf(szBuffer[12], "===============================================================================");

    printf("%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n",
            szBuffer[0], szBuffer[1], szBuffer[2], szBuffer[3], szBuffer[4], 
            szBuffer[5], szBuffer[6], szBuffer[7], szBuffer[8], szBuffer[9],
            szBuffer[10], szBuffer[11], szBuffer[12] );

    if ( bSavePosition )
        SetConsoleCursorPosition( hStdout, SavedPos.dwCursorPosition );
    }
}

int __cdecl
main( int argc, char *argv[] )
{
int	        nStatus = 0;
int         arg = 1; // Next unparsed command line parameter
const int   bStatistics = arg < argc && strcmp(argv[arg],"-s") == 0 ? arg++ : 0;
long        nLastUpdate = 0;
int         nScanline = 13;     // Scanlines can vary by station(This one is arbitrary)

if ( nScanline )
    {
    try {
        INabts	Driver;
        if ( Driver.IsValid() )
            {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

            if ( bStatistics )
                PrintStatistics( Driver, 0, 0, FALSE );

            if ( ( nStatus = Driver.ClearRequestedScanlines() ) == 0 )
                {
                do
                    {
                    if ( arg < argc )
                        if ( !(nScanline = atoi( argv[arg] ) ) )
                            printf( "Invalid scanline: '%s'\n", argv[arg] );
                    printf( "Scanline:%d ", nScanline );
                    if ( ( nStatus = Driver.AddRequestedScanline(nScanline) ) != 0 )
                        {
                        fprintf( stderr, "\nFailed to AddRequestedScanline(%d)=%d\n", nScanline, nStatus );
                        return nStatus;
                        }
                    }
                while ( ++arg < argc );
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedScanlines()=%d\n", nStatus );
                return nStatus;
                }

            printf("\n");

            int                 nNextRead = 0;
            DWORD               nBytes = 0;
            OVERLAPPED          Overlapped[CONCURRENT_READS] = {0};
            NABTS_BUFFER		NabtsBuffer[CONCURRENT_READS];

            for( nNextRead = 0; !nStatus && nNextRead < CONCURRENT_READS; nNextRead++ )
	            {
	            if ( !( Overlapped[nNextRead].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
                    {
                    nStatus = GetLastError();
                    break;
                    }
                nStatus = Driver.ReadData( NabtsBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );

                if ( !nStatus || nStatus == ERROR_IO_PENDING )
                    nStatus = 0;
                else
                    break;
                }
            nNextRead = 0;

            while ( !nStatus && !_kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);

                    printf("[%06X]", NabtsBuffer[nNextRead].ScanlinesRequested.DwordBitArray[0] );
                    nStatus = Driver.ReadData( NabtsBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
        
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "Syntax: TESTNAB [-s] [ scanline1 [scanline2] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oleds.inc ===
OLEDSLIB_W95=$(PROJECT_ROOT)\adsi\public\lib\win95

!IF "$(ADSI_NT40_BUILD)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_FOR_NT40 -DUSE_DS_VER
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\sources.inc ===
!IF "$(ADSI_NT40_BUILD)" == "1"
!INCLUDE ..\common\sources.40
!INCLUDE adsi40.mk
!ELSE IF "$(ADSI_PROFILE_BUILD)" == "1"
!INCLUDE ..\common\sources.prf
!ELSE
!INCLUDE ..\common\sources
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wmilib\wmilib.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmilib.c

Abstract:

    WMI library utility functions

    CONSIDER adding the following functionality to the library:
        * Dynamic instance names
        * Different instance names for different guids

Author:

    AlanWar

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "wdm.h"
#include "wmistr.h"
#include "wmilib.h"
#include "wmiguid.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


BOOLEAN
WmiLibpFindGuid(
    IN PWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, WmiLibpFindGuid)
#pragma alloc_text(PAGE, WmiSystemControl)


#endif


//
// Pool tag for WMILIB
#define WMILIBPOOLTAG 'LimW'

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Temporary entry point needed to initialize the class system dll.
    It doesn't do anything.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/
{
    return(STATUS_SUCCESS);
}

BOOLEAN
WmiLibpFindGuid(
    IN PWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmiSystemControl(
    IN PWMILIB_CONTEXT WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PSYSCTL_IRP_DISPOSITION IrpDisposition
    )
/*++

Routine Description:

    Dispatch helper routine for IRP_MJ_SYSTEM_CONTROL. This routine will
    determine if the irp passed contains a WMI request and if so process it
    by invoking the appropriate callback in the WMILIB structure.

    This routine may only be called at passive level

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    IrpDisposition - Returns a value that specifies how the irp was handled.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    PAGED_CODE();

    //
    // First ensure that the irp is a WMI irp
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) &&
		(minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // This is not a WMI irp
        *IrpDisposition = IrpNotWmi;
        return(STATUS_SUCCESS);
    }

    //
    // If the irp is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    if ( (irpStack->Parameters.WMI.ProviderId != (UINT_PTR)DeviceObject) ||
         (WmiLibInfo == NULL) )
    {
#if DBG
        if (WmiLibInfo == NULL)
        {
            KdPrint(("WMILIB: DeviceObject %X passed NULL WmiLibInfo\n",
                    DeviceObject));
        }
#endif
        *IrpDisposition = IrpForward;
        return(STATUS_SUCCESS);
    }

    //
    // The irp is a WMI irp targetted towards this device driver
    *IrpDisposition = IrpProcessed;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if ((minorFunction != IRP_MN_REGINFO) &&
		 (minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        ASSERT(WmiLibInfo->GuidList != NULL);
        if (WmiLibpFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (NT_SUCCESS(status) &&
            ((minorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (minorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)buffer)->InstanceIndex;

            if ( (((PWNODE_HEADER)buffer)->Flags) &
                                          WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                if ( instanceIndex >= instanceCount )
                {
                    status = STATUS_WMI_INSTANCE_NOT_FOUND;
                }
            } else {
                status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }

        //
        // If we couldn't find the guid or the instance name index is out
        // of range then return an error.
        if (! NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            *IrpDisposition = IrpNotCompleted;
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        case IRP_MN_REGINFO_EX:
        {
            ULONG guidCount;
            PWMIGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            UNICODE_STRING mofResourceName;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG mofResourceOffset;
            ULONG bufferNeeded;
            ULONG i;
            ULONG nameSize, nameOffset, nameFlags;
            ULONG_PTR nameInfo;
            UNICODE_STRING name;
            UNICODE_STRING nullUnicodeString;
			BOOLEAN addRefPDO;

            //
            // Make sure that the required parts of the WMILIB_INFO structure
            // are filled in.
            ASSERT(WmiLibInfo->QueryWmiRegInfo != NULL);

            name.Buffer = NULL;
            name.Length = 0;
            name.MaximumLength = 0;
	
            mofResourceName.Buffer = NULL;
            mofResourceName.Length = 0;
            mofResourceName.MaximumLength = 0;
	
            nameFlags = 0;
            status = WmiLibInfo->QueryWmiRegInfo(
                                                    DeviceObject,
                                                    &nameFlags,
                                                    &name,
                                                    &regPath,
                                                    &mofResourceName,
                                                    &pdo);

            if (NT_SUCCESS(status) &&
                (! (nameFlags &  WMIREG_FLAG_INSTANCE_PDO) &&
                (name.Buffer == NULL)))
            {
                //
                // if PDO flag not specified then an instance name must be
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

#if DBG
            if (nameFlags &  WMIREG_FLAG_INSTANCE_PDO)
            {
                ASSERT(pdo != NULL);
            }
#endif
            if (NT_SUCCESS(status))
            {
                ASSERT(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = sizeof(WMIREGINFO) +
                                      guidCount * sizeof(WMIREGGUIDW);

				addRefPDO = FALSE;
                if (nameFlags & WMIREG_FLAG_INSTANCE_PDO)
                {
                    nameSize = 0;
                    nameInfo = (UINT_PTR)pdo;
					if (minorFunction == IRP_MN_REGINFO_EX)
					{
						addRefPDO = TRUE;
					}
                } else {
                    nameFlags |= WMIREG_FLAG_INSTANCE_LIST;
                    nameSize = name.Length + sizeof(USHORT);
                    nameInfo = nameOffset;
                }

                nullUnicodeString.Buffer = NULL;
                nullUnicodeString.Length = 0;
                nullUnicodeString.MaximumLength = 0;
				
                if (regPath == NULL)
                {
                    //
                    // No registry path specified. This is a bad thing for
                    // the device to do, but is not fatal
#if DBG
                    KdPrint(("WMI: No registry path specified for device %x\n",
                             DeviceObject));
#endif
                    regPath = &nullUnicodeString;
                }
		
                mofResourceOffset = nameOffset + nameSize;

                registryPathOffset = mofResourceOffset +
                                     mofResourceName.Length + sizeof(USHORT);

                bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

                if (bufferNeeded <= bufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = registryPathOffset;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = *guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameInfo;
                        wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
						if (addRefPDO)
						{
							ObReferenceObject(pdo);
						}
                    }

                    if ( nameFlags &  WMIREG_FLAG_INSTANCE_LIST)
                    {
                        stringPtr = (PWCHAR)((PUCHAR)buffer + nameOffset);
                        *stringPtr++ = name.Length;
                        RtlCopyMemory(stringPtr,
                                  name.Buffer,
                                  name.Length);
                    }

                    stringPtr = (PWCHAR)((PUCHAR)buffer + mofResourceOffset);
                    *stringPtr++ = mofResourceName.Length;
                    RtlCopyMemory(stringPtr,
                                  mofResourceName.Buffer,
                                  mofResourceName.Length);

                    stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                    *stringPtr++ = regPath->Length;
                    RtlCopyMemory(stringPtr,
                              regPath->Buffer,
                              regPath->Length);
                } else {
                    *((PULONG)buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
				retSize = 0;
    	    }

            if (name.Buffer != NULL)
            {
                ExFreePool(name.Buffer);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            *IrpDisposition = IrpNotCompleted;
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;

            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);

            wnode = (PWNODE_ALL_DATA)buffer;

            if (bufferSize < sizeof(WNODE_ALL_DATA))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                ASSERT(FALSE);

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;

                break;
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= bufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = buffer + dataBlockOffset;
                bufferAvail = bufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             DeviceObject,
                                             Irp,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;

            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);
            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          DeviceObject,
                                          Irp,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          bufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = /*STATUS_WMI_READ_ONLY*/ STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }


            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = /*STATUS_WMI_READ_ONLY*/  STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         DeviceObject,
                                         Irp,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         bufferSize - wnode->DataBlockOffset,
                                         buffer + wnode->DataBlockOffset);

            } else {
                //
                // If method callback is not filled in then it must be error
                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventControl,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventControl,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockControl,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockControl,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            *IrpDisposition = IrpNotCompleted;
            break;
        }

    }

    return(status);
}

NTSTATUS
WmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    )
/*++

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

    This may be called at DPC level
Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    Status has the return status code for the IRP

    BufferUsed has the number of bytes needed by the device to return the
       data requested in any query. In the case that the buffer passed to
       the device is too small this has the number of bytes needed for the
       return data. If the buffer passed is large enough then this has the
       number of bytes actually used by the device.

    PriorityBoost is the value used for the IoCompleteRequest call.

Return Value:

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    UCHAR MinorFunction;
    PUCHAR buffer;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG bufferSize;

    minorFunction = irpStack->MinorFunction;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    switch(minorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((NT_SUCCESS(Status)) &&
                (bufferNeeded > irpStack->Parameters.WMI.BufferSize))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
	    
            if (! NT_SUCCESS(Status))
            {
                if (Status == STATUS_BUFFER_TOO_SMALL)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            for (i = instanceCount; i != 0; i--)
            {
                offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
            }

            for (i = 0; i < instanceCount; i++)
            {
                offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

                ASSERT(wnode->SizeDataBlock <= BufferUsed);

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = retSize;
    IoCompleteRequest(Irp, PriorityBoost);
    return(Status);
}

NTSTATUS
WmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    )
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    DeviceObject - Supplies a pointer to the device object for this event

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event

    EventData is the data that is fired with the events. This may be NULL
        if there is no data associated with the event


Return Value:

    status

--*/
{

    ULONG sizeNeeded;
    PWNODE_SINGLE_INSTANCE event;
    NTSTATUS status;

    if (EventData == NULL)
    {
        EventDataSize = 0;
    }

    sizeNeeded = sizeof(WNODE_SINGLE_INSTANCE) + EventDataSize;

    event = ExAllocatePoolWithTag(NonPagedPool, sizeNeeded, WMILIBPOOLTAG);
    if (event != NULL)
    {
        event->WnodeHeader.Guid = *Guid;
        event->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(DeviceObject);
        event->WnodeHeader.BufferSize = sizeNeeded;
        event->WnodeHeader.Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
        KeQuerySystemTime(&event->WnodeHeader.TimeStamp);

        event->InstanceIndex = InstanceIndex;
        event->SizeDataBlock = EventDataSize;
        event->DataBlockOffset = sizeof(WNODE_SINGLE_INSTANCE);
        if (EventData != NULL)
        {
            RtlCopyMemory( &event->VariableData, EventData, EventDataSize);
            ExFreePool(EventData);
        }

        status = IoWMIWriteEvent(event);
        if (! NT_SUCCESS(status))
        {
            ExFreePool(event);
        }
		
    } else {
        if (EventData != NULL)
        {
            ExFreePool(EventData);
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbgarg.c ===
/*++



Copyright (c) 1990 - 1994 Microsoft Corporation
All rights reserved

Module Name:

    dbgspl.c

Abstract:

    Debugging tools for Argus

Author:

    Krishna Ganugapati (KrishnaG) 28-December-1994

Revision History:
    KrishnaG:       Created: 28-December-1994


To do:

--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <ntsdexts.h>
#include "dbglocal.h"




typedef void (*PNTSD_OUTPUT_ROUTINE)(char *, ...);



//+---------------------------------------------------------------------------
//
//  Function:   DumpVtbl
//
//  Synopsis:   Dumps a vtbl to the debugger
//
//  Effects:    Given a pointer to a vtbl, output the name of the vtbl, and
//      its contents to the debugger.
//
//  Arguments:  [pvtbl] -- Address of vtbl
//      [pszCommand] -- Symbolic expression for pvtbl
//
//  History:    8-07-94   kevinro   Created
//                12-28-94  krishnaG  swiped from the Ole project
//
//----------------------------------------------------------------------------

BOOL
DumpVtbl(
   HANDLE hCurrentProcess,
   HANDLE hCurrentThread,
   DWORD dwCurrentPc,
   PNTSD_EXTENSION_APIS lpExtensionApis,
   LPSTR lpArgumentString,
   PVOID pvtbl
   )
{
   DWORD dwVtblOffset;
   char achNextSymbol[256];
   DWORD dwIndex;
   DWORD dwVtblEntry;

   if (pvtbl == 0)
   {
       // Can't handle objects at zero
       // ntsdPrintf("%s has a vtbl pointer of NULL\n", pszCommand);
       return 0;
   }

   if ((DWORD)pvtbl == 0xdededede)
   {
       // Can't handle objects at zero
       // ntsdPrintf("%s may be deleted memory. pvtbl==0xdededede\n",pszCommand);
       return 0;
   }

   //
   // This value points at the VTBL. Find a symbol for the VTBL
   //

   ntsdGetSymbol((LPVOID)pvtbl,(UCHAR *)achNextSymbol,(LPDWORD)&dwVtblOffset);

   //
   // If the dwVtblOffset is not zero, then we are pointing into the table.
   // This could mean multiple inheritance. We could be tricky, and try to
   // determine the vtbl by backing up here. Maybe later
   //

   if (dwVtblOffset != 0){

       ntsdPrintf("Closest Previous symbol is %s at 0x%x (offset -0x%x)\n",
          achNextSymbol,
          (DWORD)pvtbl - dwVtblOffset,
          dwVtblOffset);

       return 0;
   }
   ntsdPrintf("0x%08x -->\t %s\n",pvtbl,achNextSymbol);

   //
   // vtbl entries should always point at functions. Therefore, we should
   // always have a displacement of zero. To check for the end of the table
   // we will reevaluate the vtbl pointer. If the offset isn't what we
   // expected, then we are done.
   //


   for (dwIndex = 0 ; dwIndex < 4096 ; dwIndex += 4)
   {
       ntsdGetSymbol((LPVOID)((DWORD)pvtbl+dwIndex),
             (UCHAR *)achNextSymbol,
             (LPDWORD)&dwVtblOffset);

       if (dwVtblOffset != dwIndex){

        //
        // May have moved on to another vtable
        //

#if DBG
       ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
       ntsdPrintf("Moved to another table?\n");
#endif
            return 0;

       }

       movemem(
            (LPVOID)((DWORD)(pvtbl)+dwIndex),
            (PVOID)&dwVtblEntry,
            sizeof(dwVtblEntry)
            );

       //
       // If the function is at zero, then must be at end of table
       //

       if (dwVtblEntry == 0) {

#if DBG
       ntsdPrintf("dwVtblEntry is zero. Must be end of table\n");
       return 0;
#endif

       }

       // Now, determine the symbol for the entry in the vtbl

       ntsdGetSymbol((LPVOID)dwVtblEntry,
             (UCHAR *)achNextSymbol,
             (LPDWORD)&dwVtblOffset);

       // If it doesn't point to the start of a routine, then it
       // probably isn't part of the vtbl
       if (dwVtblOffset != 0)
       {
#if DBG
       ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
       ntsdPrintf("Doesn't point to function?\n");
#endif
       return 0;
       }

       ntsdPrintf("   0x%08x\t %s\n",dwVtblEntry,achNextSymbol);
   }
   ntsdPrintf("Wow, there were at least 1024 entries in the table!\n");

   return(TRUE);

}

void
vtbl(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
   PVOID pvtbl;

   //
   // Evalute the first pointer. This is a pointer to the table
   //

   pvtbl = (PVOID) ntsdGetExpr(lpArgumentString);

   DumpVtbl(
      hCurrentProcess,
      hCurrentThread,
      dwCurrentPc,
      lpExtensionApis,
      lpArgumentString,
      pvtbl
      );

}


BOOL dp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    DWORD   dwAddress = 0;
    BOOL    bThereAreOptions = TRUE;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        dwAddress = EvalValue(&lpArgumentString, EvalExpression, Print);
    }else {
        Print("Usage: !argexts.dp <addr of object>\n");
        return(TRUE);
    }

    //
    // Now dump out the object
    //

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbglocal.h ===
/*++

Copyright (c) 1990 - 1994  Microsoft Corporation

Module Name:

    dbglocal.h

Abstract:

    Header file for NetOle Debugger Extensions

Author:

    Krishna Ganugapati (KrishnaG) 11-December-1994

Revision History:


--*/


//
// Macro Land
// Note: if you use any of these macros within your code, you must have the
// following variables present and set to the appropriate value
//
// HANDLE               hCurrentProcess
// PNTSD_GET_EXPRESSION EvalExpression
//
//


#define move(dst, src)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, &dst, sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}


#define movestruct(src, dst, type)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sizeof(type), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movemem(src, dst, sz)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sz, NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define GetAddress(dst, src)\
try {\
    dst = EvalExpression(src);\
} except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src);\
    return(0);\
}


typedef void (*PNTSD_OUTPUT_ROUTINE)(char *, ...);

VOID
PrintData(
    PNTSD_OUTPUT_ROUTINE Print,
    LPSTR   TypeString,
    LPSTR   VarString,
    ...
);

BOOL
DbgDumpSecurityDescriptor(
            HANDLE hCurrentProcess,
            PNTSD_OUTPUT_ROUTINE Print,
            PISECURITY_DESCRIPTOR pSecurityDescriptor
            );

BOOL
DbgDumpSid(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  SidAddress
           );

BOOL
DbgDumpAcl(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  AclAddress
           );


VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String
    );


DWORD EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print);



#define ntsdPrintf      (lpExtensionApis->lpOutputRoutine)
#define ntsdGetSymbol       (lpExtensionApis->lpGetSymbolRoutine)
#define ntsdGetExpr         (lpExtensionApis->lpGetExpressionRoutine)
#define ntsdCheckC          (lpExtensionApis->lpCheckControlCRoutine)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbginit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   dbginit.c

Abstract:


Author:

    Krishna Ganugapati (KrishnaG) 12-Dec-1994

Revision History:

--*/
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <lm.h>
#include <stdlib.h>
#include <string.h>


HANDLE hInst;

BOOL
LibMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
)
{
    if (dwReason != DLL_PROCESS_ATTACH)
        return TRUE;

    hInst = hModule;

    return TRUE;

    UNREFERENCED_PARAMETER( lpRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbgmain.c ===
/*++

Copyright (c) 1990 - 1994  Microsoft Corporation
All rights reserved

Module Name:

    dbgmain.c

Abstract:

    This module provides all the NetOle/Argus Debugger extensions.
    The following extensions are supported:

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <ntsdexts.h>

#include <ctype.h>
#include "dbglocal.h"



DWORD   dwGlobalAddress = 32;
DWORD   dwGlobalCount =  48;

BOOL help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    Print("Windows NT Argus/NetOle Subsystem - debugging extensions\n");
    Print("help - prints this list of debugging commands\n");
    Print("vtbl [addr] - dumps out a v-table starting at [addr]\n");

    return(TRUE);

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbgsec.c ===
/*++



Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbgsec.c

Abstract:

    Argus debugging extensions. The routines here dump out Security Descriptors
    and allow you to examine them.


Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:
    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion routines)
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)


To do:


--*/

#define NOMINMAX
#define SECURITY_WIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <ntsdexts.h>

#include <windows.h>
#include <winspool.h>
#include <security.h>
#include <wchar.h>

#include "dbglocal.h"


#define NULL_TERMINATED 0
#define VERBOSE_ON      1
#define VERBOSE_OFF     0

#define         MAX_SDC_FLAGS           7

typedef struct _DBG_SED_CONTROL{
    unsigned short    Flag;
    LPSTR     String;
}DBG_SED_CONTROL, *PDBG_SED_CONTROL;

DBG_SED_CONTROL SDC_Table[] =

{
    0x0001, "SE_OWNER_DEFAULTED",

    0x0002, "SE_GROUP_DEFAULTED",

    0x0004, "SE_DACL_PRESENT",

    0x0008, "SE_DACL_DEFAULTED",

    0x0010, "SE_SACL_PRESENT",

    0x0020, "SE_SACL_DEFAULTED",

    0x8000, "SE_SELF_RELATIVE"

};

#define     MAX_ACE_FLAGS       6

typedef struct _DBG_ACE_FLAGS{
    UCHAR   Flags;
    LPSTR   String;
}DBG_ACE_FLAGS, *PDBG_ACE_FLAGS;


DBG_ACE_FLAGS AceFlagsTable[] =

{
    0x1, "OBJECT_INHERIT_ACE",

    0x2, "CONTAINER_INHERIT_ACE",

    0x4, "NO_PROPAGATE_INHERIT_ACE",

    0x8, "INHERIT_ONLY_ACE",

    0x40, "SUCCESSFUL_ACCESS_ACE_FLAG",

    0x80, "FAILED_ACCESS_ACE_FLAG"
};



typedef struct _ACCESSMASKTAB{
    DWORD   Flag;
    LPSTR   String;
}ACCESSMASKTAB, *PACCESSMASKTAB;


ACCESSMASKTAB AccessMaskTable[33] =

{
    0x00000001, "SERVER_ACCESS_ADMINSTER",

    0x00000002, "SERVER_ACCESS_ENUMERATE",

    0x00000004, "PRINTER_ACCESS_ADMINSTER",

    0x00000008, "PRINTER_ACCESS_USE",

    0x00000010, "JOB_ACCESS_ADMINISTER",

    0x00010000, "DELETE",

    0x00020000, "READ_CONTROL",

    0x00040000, "WRITE_DAC",

    0x00080000, "WRITE_OWNER",

    0x00100000, "SYNCHRONIZE",

    0x01000000, "ACCESS_SYSTEM_SECURITY",

    0x10000000, "GENERIC_ALL",

    0x20000000, "GENERIC_EXECUTE",

    0x40000000, "GENERIC_WRITE",

    0x80000000, "GENERIC_READ",

    0x0000FFFF, "SPECIFIC_RIGHTS_ALL",

    0x000F0000, "STANDARD_RIGHTS_REQUIRED <D-R/C-W/DAC-W/O>",

    0x001F0000, "STANDARD_RIGHTS_ALL  <D-R/C-W/DAC-W/O-S>",

    READ_CONTROL, "STANDARD_RIGHTS_READ <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_WRITE <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_EXECUTE <R/C>",

    SERVER_ALL_ACCESS, "SERVER_ALL_ACCESS <SRREQ-SAA-SAE>",

    SERVER_READ,    "SERVER_READ <SRR-SAE>",

    SERVER_WRITE, "SERVER_WRITE <SRW-SAA-SAE>",

    SERVER_EXECUTE, "SERVER_EXECUTE <SRE-SAE>",

    PRINTER_ALL_ACCESS, "PRINTER_ALL_ACCESS <SRREQ-PAA-PAU>",

    PRINTER_READ, "PRINTER_READ <SRR-PAU>",

    PRINTER_WRITE, "PRINTER_WRITE <SRW-PAU>",

    PRINTER_EXECUTE, "PRINTER_EXECUTE <SRE-PAU>",

    JOB_ALL_ACCESS, "JOB_ALL_ACCESS <SRREQ-JAA>",

    JOB_READ, "JOB_READ <SRR-JAA>",

    JOB_WRITE, "JOB_WRITE <SRW-JAA>",

    JOB_EXECUTE, "JOB_EXECUTE <SRE-JAA>"

};



BOOL
DbgDumpSecurityDescriptor(
            HANDLE hCurrentProcess,
            PNTSD_OUTPUT_ROUTINE Print,
            PISECURITY_DESCRIPTOR pSecurityDescriptor
            )
{
    BOOL    bSe_Self_Relative = FALSE;
    DWORD   i;
    DWORD   OwnerSidAddress, GroupSidAddress;
    DWORD   SaclAddress, DaclAddress;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    memset(&SecurityDescriptor, 0, sizeof(SECURITY_DESCRIPTOR));
    movestruct(pSecurityDescriptor, &SecurityDescriptor, SECURITY_DESCRIPTOR);

    (*Print)("SecurityDescriptor\n");

    bSe_Self_Relative = SecurityDescriptor.Control & SE_SELF_RELATIVE;
    if (bSe_Self_Relative) {
        (*Print)("This Security Descriptor is a Self-Relative Security Descriptor\n");
    }

    (*Print)("UCHAR         Revision        0x%x\n", SecurityDescriptor.Revision);
    (*Print)("UCHAR         Sbz1            0x%x\n", SecurityDescriptor.Sbz1);
    (*Print)("USHORT         Control        0x%x\n", SecurityDescriptor.Control);
    for (i = 0; i < MAX_SDC_FLAGS; i++ ) {
        if (SecurityDescriptor.Control & SDC_Table[i].Flag) {
            (*Print)("%s - ON  (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        } else {
            (*Print)("%s - OFF (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        }
    }

    //
    // Now dumping out the owner's sid
    //

    if (SecurityDescriptor.Owner == NULL) {
        (*Print)("PSID       Owner     null -- no owner sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID          Owner Offset   0x%.8x\n",SecurityDescriptor.Owner);
            OwnerSidAddress = (DWORD)pSecurityDescriptor + (DWORD)SecurityDescriptor.Owner;
        }else {
            OwnerSidAddress = (DWORD)SecurityDescriptor.Owner;
        }
        // (*Print)("PSID         Owner            0x%.8x\n", OwnerSidAddress);
    }
    (*Print)("The owner's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)OwnerSidAddress);
    (*Print)("\n\n");

    //
    // Now dumping out the group's sid

    if (SecurityDescriptor.Group == NULL) {
        (*Print)("PSID       Group    null -- no group sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID      Group Offset    0x%.8x\n", SecurityDescriptor.Group);
            GroupSidAddress = (DWORD)pSecurityDescriptor + (DWORD)SecurityDescriptor.Group;
        }else {
            GroupSidAddress = (DWORD)SecurityDescriptor.Group;
        }
        // (*Print)("PSID         Group            0x%.8x\n", GroupSidAddress);
    }
    (*Print)("The group's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)GroupSidAddress);
    (*Print)("\n");



    if (SecurityDescriptor.Sacl == NULL) {
        (*Print)("PACL       Sacl    null -- no sacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Sacl Offset %.8x\n", SecurityDescriptor.Sacl);
            SaclAddress = (DWORD)pSecurityDescriptor + (DWORD)SecurityDescriptor.Sacl;
        }else{
            SaclAddress = (DWORD)SecurityDescriptor.Sacl;

        }
        // (*Print)("PACL         Sacl            0x%.8x\n", SaclAddress);
    }

    if (SecurityDescriptor.Dacl == NULL) {
        (*Print)("PACL      Dacl    null -- no dacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Dacl Offset %.8x\n", SecurityDescriptor.Dacl);
            DaclAddress = (DWORD)pSecurityDescriptor + (DWORD)SecurityDescriptor.Dacl;
        }else {
            DaclAddress = (DWORD)SecurityDescriptor.Dacl;
        }

        (*Print)("PACL         Dacl            0x%.8x\n", DaclAddress);

        DbgDumpAcl(hCurrentProcess, Print,(PVOID)DaclAddress);
    }

}


BOOL
DbgDumpSid(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  SidAddress
           )
{
    BYTE    Sid[256];
    CHAR   SidString[256];
    SID_NAME_USE SidType = 1;

    // (*Print)("Size of a SID is %d\n", sizeof(SID));

    // movestruct(SidAddress, &Sid, SID);
    memset(Sid, 0,  256);
    movemem(SidAddress, Sid, 256);
    ConvertSidToAsciiString(Sid, SidString);
    (*Print)("PSID      %s\n", SidString);

}


BOOL
DbgDumpAceHeader(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID   AceHeaderAddress
    )
{
   ACE_HEADER AceHeader;
   DWORD i = 0;

   memset(&AceHeader, 0, sizeof(ACE_HEADER));
   movestruct(AceHeaderAddress, &AceHeader, ACE_HEADER);
   (*Print)("UCHAR      AceType         %.2x\n", AceHeader.AceType);
   switch (AceHeader.AceType) {
   case ACCESS_ALLOWED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_ALLOWED_ACE_TYPE\n");
       break;
   case ACCESS_DENIED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_DENIED_ACE_TYPE\n");
       break;
   case SYSTEM_AUDIT_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_AUDIT_ACE_TYPE\n");
       break;

   case SYSTEM_ALARM_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_ALARM_ACE_TYPE\n");
       break;
   }
   (*Print)("UCHAR      AceFlags        %.2x\n", AceHeader.AceFlags);

   for (i = 0; i < MAX_ACE_FLAGS; i++ ) {
       if (AceFlagsTable[i].Flags & AceHeader.AceFlags) {
           (*Print)("%s - ON (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }else {
           (*Print)("%s - OFF (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }
   }

   (*Print)("USHORT     AceSize         %d\n", AceHeader.AceSize);

}


BOOL
DbgDumpAcl(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  AclAddress
           )
{
    ACL         Acl;
    PVOID       AceAddress;
    ACE_HEADER  AceHeader;
    ACCESS_ALLOWED_ACE AccessAllowedAce;
    ACCESS_DENIED_ACE  AccessDeniedAce;
    SYSTEM_AUDIT_ACE   SystemAuditAce;
    SYSTEM_ALARM_ACE   SystemAlarmAce;
    DWORD   i;
    DWORD   SidAddress;

    // Pull the Acl across

    movestruct(AclAddress, &Acl, ACL);

    (*Print)("ACL\n");

    (*Print)("UCHAR     AclRevision     0x%x\n", Acl.AclRevision);
    (*Print)("UCHAR     Sbz1            0x%x\n", Acl.Sbz1);
    (*Print)("USHORT    AclSize         %d\n", Acl.AclSize);
    (*Print)("USHORT    AceCount        %d\n", Acl.AceCount);
    (*Print)("USHORT    Sz2             0x%x\n", Acl.Sbz2);

    AceAddress = (LPBYTE)AclAddress + sizeof(ACL);
    for (i = 0; i < Acl.AceCount; i++ ) {
        (*Print)("\nAce # %d: ",i);
        DbgDumpAceHeader(hCurrentProcess, Print, AceAddress);
        movestruct(AceAddress, &AceHeader, ACE_HEADER);

        switch (AceHeader.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            memset(&AccessAllowedAce, 0, sizeof(ACCESS_ALLOWED_ACE));
            movestruct(AceAddress, &AccessAllowedAce, ACCESS_ALLOWED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessAllowedAce.Mask);
            SidAddress = (DWORD)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            // (*Print)("The Address of the Sid is %.8x\n", SidAddress);
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            memset(&AccessDeniedAce, 0, sizeof(ACCESS_DENIED_ACE));
            movestruct(AceAddress, &AccessDeniedAce, ACCESS_DENIED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessDeniedAce.Mask);
            SidAddress = (DWORD)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            memset(&SystemAuditAce, 0, sizeof(SYSTEM_AUDIT_ACE));
            movestruct(AceAddress, &SystemAuditAce, SYSTEM_AUDIT_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAuditAce.Mask);
            SidAddress = (DWORD)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_ALARM_ACE_TYPE:
            memset(&SystemAlarmAce, 0, sizeof(SYSTEM_ALARM_ACE));
            movestruct(AceAddress, &SystemAlarmAce, SYSTEM_ALARM_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAlarmAce.Mask);
            SidAddress = (DWORD)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;
        }
        AceAddress = (PVOID)((DWORD)AceAddress +  AceHeader.AceSize);
        (*Print)("\n");
    }
}


BOOL
dsd(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   dwAddress = (DWORD)NULL;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        dwAddress = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (dwAddress == (DWORD)NULL) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSecurityDescriptor(
                hCurrentProcess,
                Print,
                (PISECURITY_DESCRIPTOR)dwAddress
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}




BOOL
dsid(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   dwAddress = (DWORD)NULL;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        dwAddress = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (dwAddress == (DWORD)NULL) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSid(
          hCurrentProcess,
          Print,
          (PVOID)dwAddress
          );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL
DbgDumpAccessMask(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     DWORD  AccessMask
           )
{
    DWORD i;
    for (i = 0; i < 33; i++) {
        if (AccessMask & AccessMaskTable[i].Flag) {
            (*Print)("%s\t\tON\n", AccessMaskTable[i].String);
        }else {
            (*Print)("%s\t\tOFF\n", AccessMaskTable[i].String);
        }
    }
    return TRUE;
}




BOOL
dam(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   AccessMask = (DWORD)NULL;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        AccessMask = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (AccessMask == (DWORD)NULL) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpAccessMask(
                hCurrentProcess,
                Print,
                AccessMask
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbgmem.c ===
/*++



Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbgsec.c

Abstract:

    Argus debugging extensions. The routines here dump out Security Descriptors
    and allow you to examine them.


Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:
    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)
    t-blakej	    Added:   1-July-1997 (added single-address dump, PID)


To do:


--*/

#define NOMINMAX
#define SECURITY_WIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <ntsdexts.h>

#include <windows.h>
#include <winspool.h>
#include <security.h>
#include <wchar.h>
#include <winldap.h>

#include "dbglocal.h"

#define NULL_TERMINATED 0


#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

typedef struct _ADS_LDP {
    LIST_ENTRY  List ;
    LPWSTR      Server ;
    ULONG       RefCount ;
    LUID        Luid ;
    DWORD       Flags ;
    LDAP        *LdapHandle ;
    PVOID       *pCredentials;
    DWORD       PortNumber;
    DWORD       TickCount ;
    PVOID       **ReferralEntries;
    DWORD       nReferralEntries;
} ADS_LDP, *PADS_LDP ;

ULONG
TranslateAddress (
    IN DWORD dwProcessId,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

void print_struct_ldap(
         HANDLE hCurrentProcess,
         HANDLE hCurrentThread,
         DWORD dwCurrentPc,
         PNTSD_EXTENSION_APIS lpExtensionApis,
         LDAP ldap_struct);

DWORD
SimpleAToI(LPSTR *lppStr)
{
    DWORD dwResult = 0;
    while (isspace(**lppStr)) (*lppStr)++;
    while (isdigit(**lppStr))
    {
	dwResult = dwResult * 10 + (**lppStr - '0');
	(*lppStr)++;
    }
    return dwResult;
}

BOOL
dmem(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   Address = (DWORD)NULL;
    DWORD   dwProcessId = 0;

    BOOL    bThereAreOptions = TRUE;
    BOOL    bDoOneAddress = FALSE;

    LIST_ENTRY ListEntry;
    LIST_ENTRY AdsMemHeader;
    ADSMEMTAG AdsMemTag;

    DWORD pEntry = 0;
    DWORD pTemp = 0;
    DWORD pMem = 0;
    CHAR szSymbolName[MAX_PATH];

    DWORD i = 0;



    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    dwProcessId =  GetCurrentProcessId();
    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
	//
	// Read symbols from the process whose PID is an arg to "p".
	//
        case 'p':
            lpArgumentString++;

	    // EvalValue uses hex, and I don't want to bother fiddling with
	    // it enough to make it do decimal.
            dwProcessId = SimpleAToI(&lpArgumentString);
            break;
	
	//
	// Dump the single address given as an arg to "a".
	//
	case 'a':
	    lpArgumentString++;

	    Address = EvalValue(&lpArgumentString, EvalExpression, Print);
	    bDoOneAddress = TRUE;
	    break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (!bDoOneAddress) {
	if (*lpArgumentString != 0) {
	    Address = EvalValue(&lpArgumentString, EvalExpression, Print);
	}

	// if we've got no address, then quit now - nothing we can do

	if (Address == (DWORD)NULL) {
	    Print("We have a Null address\n");
	    return(0);
	}


 	movestruct(Address, &AdsMemHeader, LIST_ENTRY);
	pEntry   = AdsMemHeader.Flink;


	while(pEntry != Address) {
	    movestruct(pEntry, &ListEntry, LIST_ENTRY);

	    pTemp = (BYTE*)pEntry;
	    pTemp = pTemp - sizeof(DWORD) - sizeof(DWORD)
		    - sizeof(DWORD) -
		    (sizeof(CHAR*) + sizeof(LPVOID))*( MAXDEPTH +1);

	    pMem  = (ADSMEMTAG*)pTemp;

	    movestruct(pMem, &AdsMemTag, ADSMEMTAG);

	    Print("[oleds] Memory leak!!! size = %ld\n", AdsMemTag.Size);

	    for (i = 0; i < AdsMemTag.uDepth; i++) {
		TranslateAddress(dwProcessId, AdsMemTag.pvBackTrace[i],
				 szSymbolName, 256);

		Print("%.8x %s\n", AdsMemTag.pvBackTrace[i], szSymbolName);
	    }
	    Print("\n");

	    pEntry = ListEntry.Flink;
	}
    }
    else {
	  TranslateAddress(dwProcessId, Address, szSymbolName, 256);
	  Print("%.8x %s\n", Address, szSymbolName);
    }

    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



//
// Give it the adsldpc!BindCache address and it will give
// the BindCache info.
//

BOOL
dcache(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   Address = (DWORD)NULL;
    DWORD   dwProcessId = 0;

    BOOL    bThereAreOptions = TRUE;
    BOOL    bDoOneAddress = FALSE;


    ADS_LDP    BindCacheEntry;

    ADS_LDP ads_ldp_struct;

    DWORD pEntry = 0;
    DWORD pTemp = 0;
    ADS_LDP  *pMem = NULL;
    CHAR szSymbolName[MAX_PATH];
    LDAP LDAPStruct;

    DWORD i = 0;
    WCHAR serverName[250];


    //DebugBreak();

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    dwProcessId =  GetCurrentProcessId();
    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
	//
	// Read symbols from the process whose PID is an arg to "p".
	//
        case 'p':
            lpArgumentString++;

	    // EvalValue uses hex, and I don't want to bother fiddling with
	    // it enough to make it do decimal.
            dwProcessId = SimpleAToI(&lpArgumentString);
            break;
	
	//
	// Dump the single address given as an arg to "a".
	//
	case 'a':
	    lpArgumentString++;

	    Address = EvalValue(&lpArgumentString, EvalExpression, Print);
	    bDoOneAddress = TRUE;
	    break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (!bDoOneAddress) {
       if (*lpArgumentString != 0) {
          Address = EvalValue(&lpArgumentString, EvalExpression, Print);
       }

       // if we've got no address, then quit now - nothing we can do

       if (Address == (DWORD)NULL) {
          Print("We have a Null address\n");
          return(0);
       }




       movestruct(Address, &BindCacheEntry, LIST_ENTRY);
       pEntry = BindCacheEntry.List.Flink;

       Print("Bind Cache Address passed is 0x%x\n", pEntry);

       while(pEntry != Address) {

          movestruct(pEntry, &BindCacheEntry, ADS_LDP);
          movemem(BindCacheEntry.Server, serverName, 250);
          // get the LDAP struct also now
          movestruct(BindCacheEntry.LdapHandle, &LDAPStruct, LDAP);

          Print("BindCache Information :\n");
          Print("        Server     : %S\n", serverName);
          Print("        RefCount   : %lu\n", BindCacheEntry.RefCount);
          Print("        LUID.High  : %ld\n", BindCacheEntry.Luid.HighPart);
          Print("        LUID.Low   : %ld\n", BindCacheEntry.Luid.LowPart);
          Print("        FLAGS      : %ld\n", BindCacheEntry.Flags);
          Print("        LDAPHandle :0x%X\n", BindCacheEntry.LdapHandle);
          print_struct_ldap(
                     hCurrentProcess,
                     hCurrentThread,
                     dwCurrentPc,
                     lpExtensionApis,
                     LDAPStruct);

          Print("        pCredenti  : 0x%X\n", BindCacheEntry.pCredentials);
          Print("        PortNo     : %ld\n", BindCacheEntry.PortNumber);
          Print("        Referrals  : %ld\n", BindCacheEntry.nReferralEntries);


          pEntry = BindCacheEntry.List.Flink;
       }
    }
    else {
       TranslateAddress(dwProcessId, Address, szSymbolName, 256);
       Print("%.8x %s\n", Address, szSymbolName);
    }

    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


void print_struct_ldap(
         HANDLE hCurrentProcess,
         HANDLE hCurrentThread,
         DWORD dwCurrentPc,
         PNTSD_EXTENSION_APIS lpExtensionApis,
         LDAP ldap_struct)
{
   PNTSD_OUTPUT_ROUTINE Print;
   UCHAR u_char_string[250];

   Print = lpExtensionApis->lpOutputRoutine;

   if (ldap_struct.ld_host) {
      movemem(ldap_struct.ld_host, u_char_string, 250);
      Print("           ld_host, address : 0x%X, string value: %s\n",
            ldap_struct.ld_host, u_char_string);
   }

   Print("           ld_version      : %lu\n", ldap_struct.ld_version);

   Print("           ld_lberoptions (UCHAR) : %c\n",
         ldap_struct.ld_lberoptions);
   Print("           ld_deref        : %lu\n", ldap_struct.ld_deref);
   Print("           ld_timelimit    : %lu\n", ldap_struct.ld_timelimit);
   Print("           ld_sizelimit    : %lu\n", ldap_struct.ld_sizelimit);
   Print("           ld_errno        : %lu\n", ldap_struct.ld_errno);

   if (ldap_struct.ld_matched) {
      movemem(ldap_struct.ld_matched, u_char_string, 250);
      Print("           ld_matched  address : 0x%X,  string value: %s\n",
            ldap_struct.ld_matched, u_char_string);
   }

   if (ldap_struct.ld_error) {
      movemem(ldap_struct.ld_error, u_char_string, 250);
      Print("           ld_error  address : 0x%X, string value: %s\n",
            ldap_struct.ld_error, u_char_string);
   }

   Print("           ld_msgid        : %lu\n", ldap_struct.ld_msgid);
   Print("           ld_cldaptries   : %lu\n", ldap_struct.ld_cldaptries);
   Print("           ld_cldaptimeout : %lu\n", ldap_struct.ld_cldaptimeout);
   Print("           ld_refhoplimit  : %lu\n", ldap_struct.ld_refhoplimit);
   Print("           ld_options      : %lu\n", ldap_struct.ld_options);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\dbgutil.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbgutil.c

Abstract:

    This module provides all the NetOle/Argus Debugger Extensions.

Author:

    Krishna Ganugapati (KrishnaG) 28-December-1994

Revision History:

--*/

#include <stdio.h>
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <ntsdexts.h>
#include "dbglocal.h"


DWORD EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print)
{
    LPSTR lpArgumentString;
    LPSTR lpAddress;
    DWORD dw;
    char ach[80];
    int cch;

    UNREFERENCED_PARAMETER(Print);
    lpArgumentString = *pptstr;

    while (isspace(*lpArgumentString))
        lpArgumentString++;

    lpAddress = lpArgumentString;
    while ((!isspace(*lpArgumentString)) && (*lpArgumentString != 0))
        lpArgumentString++;

    cch = lpArgumentString - lpAddress;
    if (cch > 79)
        cch = 79;

    strncpy(ach, lpAddress, cch);
//  Print("\"%s\"\n", lpAddress);
    dw = (DWORD)EvalExpression(lpAddress);

    *pptstr = lpArgumentString;
    return dw;
}


VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    UCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= '\0';
        return;
    }

    sprintf(Buffer, "S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    strcpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        sprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        strcat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        sprintf(Buffer, "%lu", Tmp);
        strcat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        sprintf(Buffer, "-%lu", *(GetSidSubAuthority(pSid, i)));
        strcat(String, Buffer);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\symhelp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.c

Abstract:



Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

--*/


#define _SYMHELP_SOURCE_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <symhelp.h>
#include <stdio.h>
#include <stdlib.h>

//
// Primitives to access symbolic debug information in an image file
//

typedef struct _RTL_SYMBOL_INFORMATION {
    ULONG Type;
    ULONG SectionNumber;
    ULONG Value;
    STRING Name;
} RTL_SYMBOL_INFORMATION, *PRTL_SYMBOL_INFORMATION;

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    );

typedef struct _PROCESS_DEBUG_INFORMATION {
    LIST_ENTRY List;
    HANDLE UniqueProcess;
    DWORD ImageBase;
    DWORD EndOfImage;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    UCHAR ImageFilePath[ MAX_PATH ];
} PROCESS_DEBUG_INFORMATION, *PPROCESS_DEBUG_INFORMATION;


PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilterRoutine;

RTL_CRITICAL_SECTION LoadedImageDebugInfoListCritSect;
LIST_ENTRY LoadedImageDebugInfoListHead;
LIST_ENTRY LoadedProcessDebugInfoListHead;

LPSTR SymbolSearchPath;

// This variable tracks how many times InitializeImageDebugInformation has been
//  called. Certain operations are performed only on the first call (as
//  NumInitCalls transitions from -1 to 0).
LONG NumInitCalls = -1;

LPSTR
GetEnvVariable(
    IN LPSTR VariableName
    )
{
    NTSTATUS Status;
    STRING Name, Value;
    UNICODE_STRING UnicodeName, UnicodeValue;

    RtlInitString( &Name, VariableName );
    RtlInitUnicodeString( &UnicodeValue, NULL );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof( UNICODE_NULL );
    UnicodeValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, TRUE );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Value.Buffer[ Value.Length ] = '\0';
    return Value.Buffer;
}

LPSTR
SetSymbolSearchPath( )
{
    ULONG Size, i, Attributes, NumberOfSymbolPaths;
    LPSTR s, SymbolPaths[ 4 ];

    if (SymbolSearchPath != NULL) {
        return SymbolSearchPath;
        }

    Size = 0;
    NumberOfSymbolPaths = 0;
    if (s = GetEnvVariable( "_NT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "_NT_ALT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "SystemRoot" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    SymbolPaths[ NumberOfSymbolPaths++ ] = ".";

    Size = 1;
    for (i=0; i<NumberOfSymbolPaths; i++) {
        Attributes = GetFileAttributes( SymbolPaths[ i ] );
        if ( Attributes != 0xffffffff && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Size += 1 + strlen( SymbolPaths[ i ] );
            }
        else {
            SymbolPaths[ i ] = NULL;
            }
        }

    SymbolSearchPath = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
    if (SymbolSearchPath == NULL) {
        return NULL;
        }
    *SymbolSearchPath = '\0';
    for (i=0; i<NumberOfSymbolPaths; i++) {
        if (s = SymbolPaths[ i ]) {
            if (*SymbolSearchPath != '\0') {
                strcat( SymbolSearchPath, ";" );
                }
            strcat( SymbolSearchPath, s );
            }
        }

    return SymbolSearchPath;
}

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead, LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPSTR ImageFilePath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    RTL_PROCESS_MODULES ModuleInfoBuffer;
    PRTL_PROCESS_MODULES ModuleInfo;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo1;
    ULONG RequiredLength, ModuleNumber;

    // Is this the first call?
    if ( InterlockedIncrement ( &NumInitCalls ) == 0 )
    {
        // Yes
        SetSymbolSearchPath();
        InitializeListHead( &LoadedImageDebugInfoListHead );
        InitializeListHead( &LoadedProcessDebugInfoListHead );
        RtlInitializeCriticalSection( &LoadedImageDebugInfoListCritSect );
    }

    // The filter routine can be superceded at any time.
    LoadSymbolsFilterRoutine = LoadSymbolsFilter;

    if (GetKernelSymbols) {
        ModuleInfo = &ModuleInfoBuffer;
        RequiredLength = sizeof( *ModuleInfo );
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           ModuleInfo,
                                           RequiredLength,
                                           &RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ModuleInfo = NULL;
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &ModuleInfo,
                                              0,
                                              &RequiredLength,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (NT_SUCCESS( Status )) {
                Status = NtQuerySystemInformation( SystemModuleInformation,
                                                   ModuleInfo,
                                                   RequiredLength,
                                                   &RequiredLength
                                                 );
                if (NT_SUCCESS( Status )) {
                    ModuleInfo1 = &ModuleInfo->Modules[ 0 ];
                    for (ModuleNumber=0; ModuleNumber<ModuleInfo->NumberOfModules; ModuleNumber++) {
                        if ((DWORD)(ModuleInfo1->ImageBase) & 0x80000000) {
                            if (ImageFilePath = strchr( ModuleInfo1->FullPathName, ':')) {
                                ImageFilePath -= 1;
                                }
                            else {
                                ImageFilePath = ModuleInfo1->FullPathName +
                                                strlen( ModuleInfo1->FullPathName );
                                while (ImageFilePath > ModuleInfo1->FullPathName) {
                                    if (ImageFilePath[ -1 ] == '\\') {
                                        break;
                                        }
                                    else {
                                        ImageFilePath -= 1;
                                        }
                                    }
                                }

                            AddImageDebugInformation( NULL,
                                                      ImageFilePath,
                                                      (DWORD)ModuleInfo1->ImageBase,
                                                      ModuleInfo1->ImageSize
                                                    );
                            }

                        ModuleInfo1++;
                        }
                    }

                NtFreeVirtualMemory( NtCurrentProcess(),
                                     &ModuleInfo,
                                     &RequiredLength,
                                     MEM_RELEASE
                                   );
                }
            }
        }

    if (TargetProcess == NULL) {

        // Load module information for this process.

        TargetProcess = GetCurrentProcess();
        }

    Status = NtQueryInformationProcess( TargetProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Peb = ProcessInformation.PebBaseAddress;

    if (NewProcess) {
        return TRUE;
        }

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &Peb->Ldr,
                                  &Ldr,
                                  sizeof( Ldr ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &LdrHead->Flink,
                                  &LdrNext,
                                  sizeof( LdrNext ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    while (LdrNext != LdrHead) {
        LdrEntry = CONTAINING_RECORD( LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntry,
                                      &LdrEntryData,
                                      sizeof( LdrEntryData ),
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        UnicodeString.Length = LdrEntryData.FullDllName.Length;
        UnicodeString.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        UnicodeString.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                UnicodeString.MaximumLength
                                              );
        if (!UnicodeString.Buffer) {
            return FALSE;
            }
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntryData.FullDllName.Buffer,
                                      UnicodeString.Buffer,
                                      UnicodeString.MaximumLength,
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
            return FALSE;
            }

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &UnicodeString,
                                      TRUE
                                    );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
        if (ImageFilePath = strchr( AnsiString.Buffer, ':')) {
            ImageFilePath -= 1;
            }
        else {
            ImageFilePath = AnsiString.Buffer;
            }

        AddImageDebugInformation( (HANDLE)ProcessInformation.UniqueProcessId,
                                  ImageFilePath,
                                  (DWORD)LdrEntryData.DllBase,
                                  LdrEntryData.SizeOfImage
                                );

        RtlFreeAnsiString( &AnsiString );

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    return TRUE;
}


BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;
    HANDLE FileHandle;
    UCHAR PathBuffer[ MAX_PATH ];

    FileHandle = FindExecutableImage( ImageFilePath, SymbolSearchPath, PathBuffer );
    if (FileHandle == NULL) {
        if (LoadSymbolsFilterRoutine != NULL) {
            (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                         ImageFilePath,
                                         ImageBase,
                                         ImageSize,
                                         LoadSymbolsPathNotFound
                                       );
            }

        return FALSE;
        }
    CloseHandle( FileHandle );
    if (LoadSymbolsFilterRoutine != NULL) {
        (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                     PathBuffer,
                                     ImageBase,
                                     ImageSize,
                                     LoadSymbolsDeferredLoad
                                   );
        }

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Head = &LoadedImageDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next, IMAGE_DEBUG_INFORMATION, List );
        if (DebugInfo->ImageBase == ImageBase &&
            !_stricmp( PathBuffer, DebugInfo->ImageFilePath )
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        DebugInfo = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            !_stricmp( PathBuffer, ProcessInfo->ImageFilePath )
           ) {
            return TRUE;
            }

        Next = Next->Flink;
        }

    ProcessInfo = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *ProcessInfo ) );
    if (ProcessInfo == NULL) {
        return FALSE;
        }
    ProcessInfo->ImageBase = ImageBase;
    ProcessInfo->EndOfImage = ImageBase + ImageSize;
    ProcessInfo->UniqueProcess = UniqueProcess;
    ProcessInfo->DebugInfo = DebugInfo;
    strcpy( ProcessInfo->ImageFilePath, PathBuffer );
    InsertTailList( &LoadedProcessDebugInfoListHead, &ProcessInfo->List );

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return TRUE;
}


BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            (!ARGUMENT_PRESENT( ImageFilePath ) ||
             !_stricmp( ImageFilePath, ProcessInfo->ImageFilePath )
            )
           ) {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnload
                                           );
                }

            Next = Next->Blink;
            RemoveEntryList( &ProcessInfo->List );
            RtlFreeHeap( RtlProcessHeap(), 0, ProcessInfo );
            if (ARGUMENT_PRESENT( ImageFilePath )) {
                break;
                }
            }

        Next = Next->Flink;
        }

    return TRUE;
}

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    if (Address & 0x80000000) {
        UniqueProcess = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            Address >= ProcessInfo->ImageBase &&
            Address < ProcessInfo->EndOfImage
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
        return NULL;
        }

    DebugInfo = ProcessInfo->DebugInfo;
    if (DebugInfo == NULL) {
        DebugInfo = MapDebugInformation( NULL, ProcessInfo->ImageFilePath, SymbolSearchPath, ProcessInfo->ImageBase );
        if (DebugInfo != NULL) {
            DebugInfo->ImageBase = ProcessInfo->ImageBase;
            ProcessInfo->DebugInfo = DebugInfo;
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsLoad
                                           );
                }

            InsertTailList( &LoadedImageDebugInfoListHead, &DebugInfo->List );
            }
        else {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnableToLoad
                                           );
                }
            }
        }

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return DebugInfo;
}


ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    NTSTATUS Status;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    RTL_SYMBOL_INFORMATION SymbolInformation;
    ULONG i, ModuleNameLength, Result, Offset;
    LPSTR s;

    DebugInfo = FindImageDebugInformation( UniqueProcess,
                                           Address
                                         );
    if (DebugInfo != NULL) {
        if (s = strchr( DebugInfo->ImageFileName, '.' )) {
            ModuleNameLength = s - DebugInfo->ImageFileName;
            }
        else {
            ModuleNameLength = strlen( DebugInfo->ImageFileName );
            }

        // [mikese] RtlLookupSymbolByAddress will fault if there is
        //  no COFF symbol information.
        if ( DebugInfo->CoffSymbols != NULL ) {
            Status = RtlLookupSymbolByAddress( (PVOID)DebugInfo->ImageBase,
                                       DebugInfo->CoffSymbols,
                                       (PVOID)Address,
                                       0x4000,
                                       &SymbolInformation,
                                       NULL
                                     );

            }
        else {
            Status = STATUS_UNSUCCESSFUL;
             }
        }
    else {
        ModuleNameLength = 0;
        Status = STATUS_UNSUCCESSFUL;
        }

    if (NT_SUCCESS( Status )) {
        s = SymbolInformation.Name.Buffer;
        i = 1;
        while (SymbolInformation.Name.Length > i &&
               isdigit( s[ SymbolInformation.Name.Length - i ] )
              ) {
            i += 1;
            }

        if (s[ SymbolInformation.Name.Length - i ] == '@') {
            SymbolInformation.Name.Length = (USHORT)(SymbolInformation.Name.Length - i);
            }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%Z",
                            ModuleNameLength,
                            DebugInfo->ImageFileName,
                            &SymbolInformation.Name
                          );
        Offset = Address - DebugInfo->ImageBase - SymbolInformation.Value;
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
            }
        }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                DebugInfo->ImageFileName,
                                Address
                              );
            }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }

    return Result;
}

ULONG
TranslateAddress (
    IN DWORD ProcessId,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength )
{
    ULONG Result = 0;
    ULONG Attempts = 0;
    HANDLE hProc = (HANDLE)NULL;
    static DWORD dwLastPid = 0;

    //
    // Get the debug information for this process.
    //
    if (dwLastPid != ProcessId)
    {
	hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
	if (hProc)
	{
	    InitializeImageDebugInformation(NULL, hProc, FALSE, FALSE);
	    dwLastPid = ProcessId;
	}
	else
	    // printf("Couldn't get process handle: 0x%08x\n", GetLastError());
	    Result = 1;
    }

    while ( Result == 0 )
    {
        Result = GetSymbolicNameForAddress ( (HANDLE)ProcessId, Address,
                                             Name, MaxNameLength );
        if ( Result == 0 )
        {
            if ( ++Attempts < 2 )
            {
                // Try reinitialising, to load any modules we missed
		//   on a previous occasion (or if we haven't initialized yet).
		InitializeImageDebugInformation(NULL, hProc, FALSE, FALSE);
            }
            else
            {
		// Apparently we are unable to do the right thing, so just
		//  return the address as hex.
                Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }
    }

    if (hProc)
	    CloseHandle(hProc);

    return Result;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    );

PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    );

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    )
/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within ClosenessLimit of the location,
    STATUS_ENTRYPOINT_NOT_FOUND is returned.

Arguments:

    ImageBase - Supplies the base address of the image containing
                Address

    MappedBase - Optional parameter, that if specified means the image
                 was mapped as a data file and the MappedBase gives the
                 location it was mapped.  If this parameter does not
                 point to an image file base, then it is assumed that
                 this is a pointer to the coff debug info.

    ClosenessLimit - Specifies the maximum distance that Address can be
                     from the value of a symbol to be considered
                     "found".  Symbol's whose value is further away then
                     this are not "found".

    SymbolInformation - Points to a structure that is filled in by
                        this routine if a symbol table entry is found.

    NextSymbolInformation - Optional parameter, that if specified, is
                            filled in with information about these
                            symbol whose value is the next address above
                            Address


Return Value:

    Status of operation.

--*/

{
    NTSTATUS Status;
    ULONG AddressOffset, i;
    PIMAGE_SYMBOL PreviousSymbolEntry;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    BOOLEAN SymbolFound;
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;

    DebugInfo = RtlpGetCoffDebugInfo( ImageBase, MappedBase );
    if (DebugInfo == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)
        ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);

    StringTable = (PUCHAR)
        ((ULONG)SymbolEntry + DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);


    //
    // Find the "header" symbol (skipping all the section names)
    //

    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        if (!strcmp( &SymbolEntry->N.ShortName[ 0 ], "header" )) {
            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
        }

    //
    // If no "header" symbol found, just start at the first symbol.
    //

    if (i >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
        i = 0;
        }

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

    AddressOffset = (ULONG)Address - (ULONG)ImageBase;
    SymbolFound = FALSE;
    for (; i < DebugInfo->NumberOfSymbols; i++) {

        //
        // Skip over any Auxilliary entries.
        //
        try {
            while (SymbolEntry->NumberOfAuxSymbols) {
                i = i + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)
                    ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL +
                     SymbolEntry->NumberOfAuxSymbols * IMAGE_SIZEOF_SYMBOL
                    );

                }

            RtlMoveMemory( &Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL );
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
            }

        //
        // If this symbol value is less than the value we are looking for.
        //

        if (Symbol.Value <= AddressOffset) {
            //
            // Then remember this symbol entry.
            //

            PreviousSymbolEntry = SymbolEntry;
            SymbolFound = TRUE;
            }
        else {
            //
            // All done looking if value of symbol is greater than
            // what we are looking for, as symbols are in address order
            //

            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)
            ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);

        }

    if (!SymbolFound || (AddressOffset - PreviousSymbolEntry->Value) > ClosenessLimit) {
        return STATUS_ENTRYPOINT_NOT_FOUND;
        }

    Status = RtlpCaptureSymbolInformation( PreviousSymbolEntry, StringTable, SymbolInformation );
    if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( NextSymbolInformation )) {
        Status = RtlpCaptureSymbolInformation( SymbolEntry, StringTable, NextSymbolInformation );
        }

    return Status;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    )
{
    USHORT MaximumLength;
    PCHAR s;

    SymbolInformation->SectionNumber = SymbolEntry->SectionNumber;
    SymbolInformation->Type = SymbolEntry->Type;
    SymbolInformation->Value = SymbolEntry->Value;

    if (SymbolEntry->N.Name.Short) {
        MaximumLength = 8;
        s = &SymbolEntry->N.ShortName[ 0 ];
        }

    else {
        MaximumLength = 64;
        s = &StringTable[ SymbolEntry->N.Name.Long ];
        }

#if i386
    if (*s == '_') {
        s++;
        MaximumLength--;
        }
#endif

    SymbolInformation->Name.Buffer = s;
    SymbolInformation->Name.Length = 0;
    while (*s && MaximumLength--) {
        SymbolInformation->Name.Length++;
        s++;
        }

    SymbolInformation->Name.MaximumLength = SymbolInformation->Name.Length;
    return( STATUS_SUCCESS );
}


PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugSize;
    ULONG NumberOfDebugDirectories;

    DosHeader = (PIMAGE_DOS_HEADER)MappedBase;
    if ( !DosHeader || DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {
        //
        // Locate debug section.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)(MappedBase == NULL ? ImageBase : MappedBase),
                                          (BOOLEAN)(MappedBase == NULL ? TRUE : FALSE),
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DebugSize
                                        );

        if (!DebugDirectory ||
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            ((DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)) != 0)) {
            return NULL;
        }
        //
        // point debug directory at coff debug directory
        //
        NumberOfDebugDirectories = DebugSize / sizeof(*DebugDirectory);

        while ( NumberOfDebugDirectories-- ) {
            if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_COFF ) {
                break;
            }
            DebugDirectory++;
        }

        if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_COFF ) {
            return NULL;
        }

        if (MappedBase == NULL) {
            if (DebugDirectory->AddressOfRawData == 0) {
                return(NULL);
            }
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) ImageBase + DebugDirectory->AddressOfRawData);
        } else {
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) MappedBase + DebugDirectory->PointerToRawData);
        }
    } else {
        DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)MappedBase;
    }
    return DebugInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\dbgexts\symhelp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.h

Abstract:

    Defines the interfaces to the SYMHELP dynamic link library.  Useful for programs
    that want to maintain a debug informaiton data base.

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

    Mike Seaman (mikese) 20-Jan-1995    Added TranslateAddress

--*/

#ifndef _SYMHELP_
#define _SYMHELP_

typedef enum _LOAD_SYMBOLS_FILTER_REASON {
    LoadSymbolsPathNotFound,
    LoadSymbolsDeferredLoad,
    LoadSymbolsLoad,
    LoadSymbolsUnload,
    LoadSymbolsUnableToLoad
} LOAD_SYMBOLS_FILTER_REASON;

typedef BOOL (*PLOAD_SYMBOLS_FILTER_ROUTINE)(
    HANDLE UniqueProcess,
    LPSTR ImageFilePath,
    DWORD ImageBase,
    DWORD ImageSize,
    LOAD_SYMBOLS_FILTER_REASON Reason
    );

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    );

BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    );

BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    );

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    );

ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

//
// The following function is essentially identical in operation to
//  GetSymbolicNameForAddress, except that it:
//
//  1. Operates only on the calling process.
//  2. Does not require any previous calls to AddImageDebugInformation et al.
//     That is, debug information for all currently loaded modules will
//     be added automatically.

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\deldsm\main.cpp ===
#include <windows.h>
#include <netcfgx.h>
#include <netcfgn.h>

#include <setupapi.h>
#include <devguid.h>
#include <tchar.h>
#include <stdio.h>

const WCHAR szComponentId[] = L"DSMIGRAT";
const WCHAR szName[] = L"deldsm.exe";
const WCHAR szClient[] = L"ms_nwclient";
const WCHAR szUnknown[] = L"Microsoft";
const WCHAR szDSM[] = L"dsmigrat";

HRESULT
HrFindAndRemoveComponent2(
    INetCfg*    pnc,
    const GUID* pguidClass,
    PCWSTR      pszComponentId,
    OBO_TOKEN*  pOboToken)
{
    // Get the component class object.
    //
    INetCfgClass* pncclass;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        // Find the component to remove.
        //
        INetCfgComponent* pnccRemove;
        hr = pncclass->FindComponent (pszComponentId, &pnccRemove);
        if (S_OK == hr)
        {
            INetCfgClassSetup* pncclasssetup;
            hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                        reinterpret_cast<void**>(&pncclasssetup));
            if (SUCCEEDED(hr))
            {
                hr = pncclasssetup->DeInstall (pnccRemove, pOboToken, NULL);

                //ReleaseObj (pncclasssetup);   
                pncclasssetup->Release();
            }

            //ReleaseObj (pnccRemove);
            pnccRemove->Release();
        }
        else if (S_FALSE == hr)
        {
            hr = S_OK;
        }

        //ReleaseObj (pncclass);
        pncclass->Release();
    }
    /*
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponent");
    */
    return hr;
}

HRESULT
HrRemoveComponentOboSoftware2 (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    PCWSTR     pszManufacturer,
    PCWSTR     pszProduct,
    PCWSTR     pszDisplayName)
{
    // Make an "on behalf of" token for the software.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = pszManufacturer;
    OboToken.pszwProduct      = pszProduct;
    OboToken.pszwDisplayName  = pszDisplayName;

    HRESULT hr = HrFindAndRemoveComponent2(pnc, &rguidClass, pszComponentId,
                    &OboToken);

    return hr;
}

HRESULT
HrCreateAndInitializeINetCfg2 (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    PCWSTR      pszClientDesc,
    PWSTR*      ppszClientDesc)
{
    //Assert (ppnc);

    // Initialize the output parameters.
    *ppnc = NULL;

    if (ppszClientDesc)
    {
        *ppszClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            *pfInitCom = FALSE;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetCfg,
                reinterpret_cast<void**>(&pnc));

        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, pszClientDesc,
                                               ppszClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    //AddRefObj (pnc);
                    pnc->AddRef();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            //ReleaseObj(pnclock);
            pnclock->Release();

            //ReleaseObj(pnc);
            pnc->Release();
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    return hr;
}

extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    INetCfg             *pnc = NULL;
    HRESULT             hr = S_OK;
    PWSTR               pszDesc = NULL;
    BOOL                fInitCom = TRUE;
    BOOL                fWriteLock = TRUE;

    hr = HrCreateAndInitializeINetCfg2(&fInitCom, 
                                      &pnc, 
                                      fWriteLock, 
                                      0,
                                      szName, 
                                      &pszDesc);
    if (FAILED(hr)) {
        goto error;
    }

    hr = HrRemoveComponentOboSoftware2(pnc,
                                      GUID_DEVCLASS_NETCLIENT,
                                      szClient,
                                      szUnknown,
                                      szDSM,
                                      szComponentId);
    if (FAILED(hr)) {
        goto error;
    }

    printf("DSMU's dependencies on GSNW and IPX have been removed.  To complete the uninstall, please delete the 'DSMigrat' directory under the directory 'Program Files'.\n");
error:
    if (FAILED(hr)) {
        printf("The uninstallation of Dsmigrat has failed with an error 0x%x\n",hr);
    }
    if (pnc)
        pnc->Release();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\deldsm\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

v#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\enum.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       enum.cxx
//
//  Contents:   Active Directory container enumeration
//
//
//  History:    03-20-96  KrishnaG   created
//              08-01-96  t-danal    add to oledscmd
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

#define DEFAULT_ACTION "obj"

//
// Dispatch Table Defs
//

#include "dispdef.hxx"

DEFEXEC(ExecEnumObjects);
DEFEXEC(ExecEnumJobs);
DEFEXEC(ExecEnumSessions);
DEFEXEC(ExecEnumResources);

DEFDISPTABLE(DispTable) = {
                           {DEFAULT_ACTION, NULL, ExecEnumObjects},
                           {"job", NULL, ExecEnumJobs},
                           {"ses", NULL, ExecEnumSessions},
                           {"res", NULL, ExecEnumResources}
                          };

DEFDISPSIZE(nDispTable, DispTable);

//
// Private defines
//

#define MAX_ADS_FILTERS   10
#define MAX_ADS_ENUM      100

//
// Imported functions
//

HRESULT
DumpObject(
    IADs * pADs
    );

HRESULT
GetTransientObjects(
    LPWSTR szContainer,
    LPWSTR szType,
    IADs **ppADs,
    IADsCollection **ppCollection
    );

//
// Local functions
//

HRESULT
EnumTransientObjects(
    LPWSTR szADsPath,
    LPWSTR szObjectType,
    BOOL fDump
    );

HRESULT
EnumObject(
    LPWSTR szLocation,
    LPWSTR * lppPathNames,
    DWORD dwPathNames
    ) ;

HRESULT
PrintLongFormat(
    IADs * pObject
    );

HRESULT
PrintShortFormat(
    IADs * pObject
    );

//
// Local function definitions
//


HRESULT
EnumTransientObjects(
    LPWSTR szADsPath,
    LPWSTR szObjectType,
    BOOL fDump
    )
{
    HRESULT hr;
    IADs * pADs = NULL;
    IADsCollection * pCollection = NULL;
    ULONG   ulGet;
    IEnumVARIANT *pIEnumVar;
    IADs * pChildADs = NULL;
    VARIANT aVariant;

    hr = GetTransientObjects(szADsPath,
                             szObjectType,
                             &pADs,
                             &pCollection);
    BAIL_ON_FAILURE(hr);

    //
    // printf("ADs Get objects succeeded \n");
    //

    pCollection->get__NewEnum((IUnknown **)&pIEnumVar);
    BAIL_ON_FAILURE(hr);

    hr  = pIEnumVar->Next( 1, &aVariant, &ulGet );

    while( ulGet && hr != S_FALSE )
    {
        hr = V_DISPATCH(&aVariant)->QueryInterface(IID_IADs,
                                                   (void**)&pChildADs);
        V_DISPATCH(&aVariant)->Release();

        if(pChildADs != NULL){
            hr = pADs->GetInfo();
            BAIL_ON_FAILURE(hr);

            if (fDump)
                printf("\n");
            hr = PrintShortFormat(pChildADs);
            BAIL_ON_FAILURE(hr);

            if (fDump) {
                hr = DumpObject(pChildADs);
                BAIL_ON_FAILURE(hr);

                //
                // printf("Dump objects succeeded \n");
                //
            }

            hr = pIEnumVar->Next( 1, &aVariant, &ulGet );
        }
    }
    hr = S_OK;
error:
    if(pADs)
        pADs->Release();
    if(pCollection)
        pCollection->Release();
    if (hr == S_FALSE)
        hr = S_OK;
    return(hr);
}

HRESULT
EnumObject(
    LPWSTR szLocation,
    LPWSTR * lppPathNames,
    DWORD dwPathNames
    )
{
    ULONG cElementFetched = 0L;
    IEnumVARIANT * pEnumVariant = NULL;
    VARIANT Variant, * pVarFilter = NULL, VariantArray[MAX_ADS_ENUM];

    HRESULT hr;
    VARIANT VarFilter;
    IADsContainer * pADsContainer =  NULL;
    DWORD dwObjects = 0, dwEnumCount = 0, i = 0;
    BOOL  fContinue = TRUE;


    VariantInit(&VarFilter);

    hr = ADsGetObject(
                szLocation,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsBuildVarArrayStr(
                lppPathNames,
                dwPathNames,
                &VarFilter
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsContainer->put_Filter(VarFilter);
    BAIL_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    BAIL_ON_FAILURE(hr);



    while (fContinue) {

        IADs *pObject ;

        hr = ADsEnumerateNext(
                    pEnumVariant,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
        }

        dwEnumCount++;

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;
            BSTR       bstrName ;

            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            BAIL_ON_FAILURE(hr);

            PrintLongFormat(pObject);

            pObject->Release();
            pDispatch->Release();
        }

        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);

        dwObjects += cElementFetched;

    }

    printf("Total Number of Objects enumerated is %d\n", dwObjects);

    VariantClear(&VarFilter);

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    return(S_OK);

error:

    VariantClear(&VarFilter);

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    return(hr);
}

HRESULT
PrintLongFormat(IADs * pObject)
{

    HRESULT hr = S_OK;
    BSTR bstrName = NULL;
    BSTR bstrClass = NULL;
    BSTR bstrSchema = NULL;

    hr = pObject->get_Name(&bstrName) ;
    BAIL_ON_FAILURE(hr);

    hr = pObject->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    hr = pObject->get_Schema(&bstrSchema);

    printf("\tObject: %ws\tSchema: %ws\n", bstrName, bstrSchema) ;
    SysFreeString(bstrName) ;

error:
    if (bstrClass) {
        SysFreeString(bstrClass);
    }
    if (bstrName) {
        SysFreeString(bstrName);
    }
    if (bstrSchema) {
        SysFreeString(bstrSchema);
    }
    return(hr);
}


HRESULT
PrintShortFormat(IADs * pObject)
{

    HRESULT hr = S_OK;
    BSTR bstrName = NULL;

    hr = pObject->get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    printf("\tObject: %ws\n", bstrName);
    SysFreeString(bstrName) ;

error:
    if (bstrName) {
        SysFreeString(bstrName);
    }
    return(hr);
}

//
// Exec function definitions
//

int
ExecEnum(char *szProgName, char *szAction, int argc, char * argv[])
{
    if (!argc) {
        PrintUsage(szProgName, szAction, DispTable, nDispTable);
        return(1);
    }

    char *szPrevActions = szAction;
    szAction = argv[0];
    argc--;
    argv++;

    if (DoHelp(szProgName,
               szPrevActions, szAction, NULL,
               DispTable, nDispTable,
               NULL))
        return 0;

    if (!IsValidAction(szAction, DispTable, nDispTable))
        szAction = DEFAULT_ACTION;

    return DispatchExec(DispTable, nDispTable,
                        szProgName,
                        szPrevActions, szAction,
                        argc, argv);
}

int
ExecEnumObjects(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszLocation = NULL ;
    LPWSTR pszTmp = NULL ;
    LPWSTR apszTypes[MAX_ADS_FILTERS] ;

    if ((argc < 1) || (argc > 3)) {
        PrintUsage(szProgName, szAction, "<path> [<type> [<other_args>]]");
        return(1) ;
    }

    int i = 0 ;
    BAIL_ON_NULL( pszLocation = AllocateUnicodeString(argv[0]));

    apszTypes[0] = NULL ;

    if (argc > 1) {
        LPWSTR pszComma ;

        BAIL_ON_NULL(pszTmp = AllocateUnicodeString(argv[1]));

        apszTypes[i] = pszTmp ;
        while (pszComma = wcschr(apszTypes[i++],L',')) {
            apszTypes[i] = pszComma + 1;
            *pszComma = 0 ;
        }
        apszTypes[i] = NULL ;
    }

    hr = EnumObject(
        pszLocation,
        apszTypes,
        i
        );

error:
    FreeUnicodeString(pszLocation) ;
    FreeUnicodeString(pszTmp) ;
    if (FAILED(hr))
        return(1);
    return(0) ;
}

int
ExecEnumJobs(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szPath = NULL;

    if (argc != 1) {
        PrintUsage(szProgName, szAction, "<conatiner>");
        return(1) ;
    }

    BAIL_ON_NULL(szPath = AllocateUnicodeString(argv[0]));

    hr = EnumTransientObjects(szPath,
                              L"Job",
                              TRUE);
error:
    FreeUnicodeString(szPath);
    if (FAILED(hr))
        return(1);
    return(0) ;
}

int
ExecEnumSessions(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szPath = NULL;

    if (argc != 1) {
        PrintUsage(szProgName, szAction, "<conatiner>");
        return(1) ;
    }

    BAIL_ON_NULL(szPath = AllocateUnicodeString(argv[0]));

    hr = EnumTransientObjects(szPath,
                              L"Session",
                              TRUE);
error:
    FreeUnicodeString(szPath);
    if (FAILED(hr))
        return(1);
    return(0) ;
}

int
ExecEnumResources(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szPath = NULL;

    if (argc != 1) {
        PrintUsage(szProgName, szAction, "<conatiner>");
        return(1) ;
    }

    BAIL_ON_NULL(szPath = AllocateUnicodeString(argv[0]));

    hr = EnumTransientObjects(szPath,
                              L"Resource",
                              TRUE);
error:
    FreeUnicodeString(szPath);
    if (FAILED(hr))
        return(1);
    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\defcont.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       defcont.cxx
//
//  Contents:   Active Directory Default Container
//
//  History:    05-21-96  RamV      created
//              08-02-96  t-danal   add to oledscmd
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

//
// Local functions
//

HRESULT
SetDefaultContainer(LPWSTR pszValue);

HRESULT
PrintDefaultContainer(VOID);

//
// Misc worker functions
//

HRESULT
SetDefaultContainer(
    LPWSTR pszValue
    )
{
    HRESULT hr = E_FAIL;
    IADsNamespaces *pNamespaces = NULL;
    BSTR bstrValue = NULL;

    if (pszValue) {
        BAIL_ON_NULL(bstrValue = SysAllocString(pszValue));
    }
    else {
        bstrValue = NULL;
    }

    hr = ADsGetObject(L"@ADS!",
                        IID_IADsNamespaces,
                        (void **)&pNamespaces);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->put_DefaultContainer(bstrValue);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->SetInfo();

error:
    FREE_INTERFACE(pNamespaces);
    FREE_BSTR(bstrValue);
    return hr;
}
    
HRESULT
PrintDefaultContainer(
    )
{
    HRESULT hr;
    IADsNamespaces *pNamespaces = NULL;
    BSTR bstrValue = NULL;

    hr = ADsGetObject(L"@ADS!",
                        IID_IADsNamespaces,
                        (void **)&pNamespaces);
    BAIL_ON_FAILURE(hr);
            
    hr = pNamespaces->get_DefaultContainer(&bstrValue);
    BAIL_ON_FAILURE(hr);

    printf("Default Container = %ws\n", bstrValue);

error:
    FREE_INTERFACE(pNamespaces);
    FREE_BSTR(bstrValue);
    return hr;
}

//
// Exec function
//

int
ExecDefaultContainer(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszValue = NULL ;

    if (argc < 0 || argc > 1) {
        PrintUsage(szProgName, szAction, "[default container]");
        return(1);
    }

    if (argc == 1) {
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszValue, argv[0]);
        hr = SetDefaultContainer(pszValue);
    } else {
        hr = PrintDefaultContainer();
    }

error:
    FreeUnicodeString(pszValue);
    if (FAILED(hr))
        return(1);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\get.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       get.cxx
//
//  Contents:   Get Object
//
//  History:    04-23-96  KrishnaG  created
//              08-01-96  t-danal   add to oledscmd w/getrobj
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

//
// Local functions
//

HRESULT
GetObject(
    LPWSTR szLocation
    );

HRESULT
GetRelativeObject(
    LPWSTR szLocation,
    LPWSTR szClass,
    LPWSTR szName
    );

//
// Local function definitions
//

HRESULT
GetObject(
    LPWSTR szPath
    )
{
    HRESULT hr, hr_return;
    IADs * pADs = NULL;
    DWORD dwLastError;
    WCHAR szErrorBuf[MAX_PATH];
    WCHAR szNameBuf[MAX_PATH];

    hr = ADsGetObject(
                szPath,
                IID_IADs,
                (void **)&pADs
                );
    
    BAIL_ON_FAILURE(hr);
        
error:

  
    if(HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR)== hr){
        //
        // get extended error value
        //
        hr_return = ADsGetLastError( &dwLastError,
                                       szErrorBuf,
                                       MAX_PATH-1,
                                       szNameBuf,
                                       MAX_PATH -1 );

        if (SUCCEEDED(hr_return)){
            printf("%d:%ws in provider %ws\n", dwLastError, szErrorBuf, szNameBuf);
        }
    }
    

    if (SUCCEEDED(hr)) {
        printf("getobj: Successfully bound to object %ws\n",
                     szPath);
    }else {
        printf("getobj: Failed to bind to the object with error code %.8x\n",
                                    hr);
    }

    if (pADs){
        pADs->Release();
    }

    return(hr);
}

HRESULT
GetRelativeObject(
    LPWSTR szLocation,
    LPWSTR szClass,
    LPWSTR szName
    )
{
    HRESULT hr;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;

    hr = ADsGetObject(
                szLocation,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    BAIL_ON_FAILURE(hr);

    hr = pADsContainer->GetObject(
                szClass,
                szName,
                &pDispatch
                );
    BAIL_ON_FAILURE(hr);

error:
    if (SUCCEEDED(hr)) {
        printf("getrobj: Successfully bound to relative object "
               "%ws from container object %ws\n",
               szName, szLocation);
    }

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
}

HRESULT
GetTransientObjects(
    LPWSTR szContainer,
    LPWSTR szType,
    IADs **ppADs,
    IADsCollection **ppCollection
    )
{
    HRESULT hr;
    IADs * pADs = NULL;
    IADsCollection * pCollection = NULL;
    IADsPrintQueueOperations * pPrintQueueOperation = NULL;
    IADsFileServiceOperations * pFileServiceOperation = NULL;  

    if (ppADs)
        *ppADs = NULL;
    if (ppCollection)
        *ppCollection = NULL;

    hr = ADsGetObject(
                szContainer,
                IID_IADs,
                (void **)&pADs
                );
    BAIL_ON_FAILURE(hr);
 
    //
    // printf("ADs Get objects succeeded \n");
    //
     
    if (_wcsicmp(szType, L"Job") == 0){
        hr = pADs->QueryInterface(IID_IADsPrintQueueOperations,
                                    (void **)&pPrintQueueOperation );
        BAIL_ON_FAILURE(hr);

        hr = pPrintQueueOperation->PrintJobs(&pCollection);
        BAIL_ON_FAILURE(hr);
        pPrintQueueOperation -> Release();
        pPrintQueueOperation = NULL;

    } else if (_wcsicmp(szType, L"Session") == 0){
        hr = pADs->QueryInterface(IID_IADsFileServiceOperations,
                                    (void **)&pFileServiceOperation );
        BAIL_ON_FAILURE(hr);

        hr = pFileServiceOperation->Sessions(&pCollection);       
        BAIL_ON_FAILURE(hr);
        pFileServiceOperation -> Release();
        pFileServiceOperation = NULL;

    } else if (_wcsicmp(szType, L"Resource") == 0){
        hr = pADs->QueryInterface(IID_IADsFileServiceOperations,
                                    (void **)&pFileServiceOperation );
        BAIL_ON_FAILURE(hr);

        hr = pFileServiceOperation->Resources(&pCollection);       
        BAIL_ON_FAILURE(hr);
        pFileServiceOperation -> Release();
        pFileServiceOperation = NULL;

    } else {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (ppADs)
        *ppADs = pADs;
    if (ppCollection)
        *ppCollection = pCollection;
    return S_OK;

error:
    if (pADs)
        pADs->Release();
    if (pPrintQueueOperation)
        pPrintQueueOperation->Release();
    if (pFileServiceOperation)
        pFileServiceOperation->Release();
    return hr;
}

//
// Exec function definitions
//

int
ExecGet(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszContainer = NULL;
    LPWSTR pszClass = NULL;
    LPWSTR pszName = NULL;

    switch (argc) {
    case 1:
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszName, argv[0]);
        hr = GetObject(pszName);
        break;
    case 2:
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszContainer, argv[0]);
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszName, argv[1]);
        hr = GetRelativeObject(pszContainer, pszClass, pszName);
        break;
    case 3:
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszContainer, argv[0]);
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszClass, argv[1]);
        ALLOC_UNICODE_WITH_BAIL_ON_NULL(pszName, argv[2]);
        hr = GetRelativeObject(pszContainer, pszClass, pszName);
        break;
    default:
        PrintUsage(szProgName, szAction, 
                   "\n\t[ <ADsPath of Object> |"
                   "\n\t  <Container> <Object>  |"
                   "\n\t  <Container> <Class> <Object> ]");
        return(1);
    }
error:
    FreeUnicodeString(pszContainer);
    FreeUnicodeString(pszClass);
    FreeUnicodeString(pszName);
    if (FAILED(hr))
        return(1);
    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\dump.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dump.cxx
//
//  Contents:   Reads the schema for objects and dumps them
//
//  History:    07-09-96  ramv     created
//              08-05-96  t-danal  add to oledscmd
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"
#include "proputil.hxx"

//
// Local functions
//

HRESULT
ListProperties(
    LPWSTR szADsPath
    );

HRESULT 
DumpObject(
    IADs * pADs
    );

//
// Local function definitions
//

HRESULT
ListProperties(
    LPWSTR szADsPath
    )
{
    HRESULT hr;
    IADs * pADs = NULL;

    hr = ADsGetObject(
                szADsPath,
                IID_IADs,
                (void **)&pADs
                );
    BAIL_ON_FAILURE(hr);

    hr = DumpObject(pADs);

error:
    if (pADs)
        pADs->Release();
    return hr;
}

HRESULT 
DumpObject(
    IADs * pADs
    )
{
    HRESULT hr;
    IADs * pADsProp = NULL;
    VARIANT * pVariantArray = NULL;
    VARIANT varProperty;

    DWORD dwNumProperties = 0;
    BSTR bstrPropName = NULL;
    DWORD i = 0;
    IDispatch * pDispatch = NULL;

    hr = GetPropertyList(
                pADs,
                &pVariantArray,
                &dwNumProperties
                );
    BAIL_ON_FAILURE(hr);

    //
    // printf("GetPropertyList here\n");
    //

    hr = pADs->GetInfo();
    BAIL_ON_FAILURE(hr);

    //
    // printf("GetInfo succeeded \n");
    //

    for (i = 0; i < dwNumProperties; i++ ) {

        pDispatch = (pVariantArray + i)->pdispVal;
        hr = pDispatch->QueryInterface(
                            IID_IADs,
                            (void **)&pADsProp
                            );
        BAIL_ON_FAILURE(hr);

        pDispatch->Release(); // NEW

        hr = pADsProp->get_Name(&bstrPropName);
        pADsProp->Release(); // NEW
        BAIL_ON_FAILURE(hr);

        hr = pADs->Get(
                bstrPropName,
                &varProperty
                );

        PrintProperty(
            bstrPropName,
            hr,
            varProperty
            );

        //
        // printf("PrintProperty succeeded \n");
        //
    
        if (bstrPropName) {
            SysFreeString(bstrPropName);
        }
        
    }

error:
    free(pVariantArray);
    return(hr);
}

//
// Exec function definitions
//

int
ExecDump(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szADsPath = NULL;

    if (argc != 1) {
        PrintUsage(szProgName, szAction, "<ADsPath>");
        return 1;
    }

    szADsPath = AllocateUnicodeString(argv[0]);

    hr = ListProperties(
                szADsPath
                );

    FreeUnicodeString(szADsPath);
    if (FAILED(hr))
        return 1;
    return 0;
}

/*
int
ExecListTransient(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szADsPath = NULL;
    LPWSTR szObjectType = NULL;

    if (argc  != 2) {
        PrintUsage(szProgName, szAction, 
                   "<ADsPath> [ job | session | resource ]");
        return (1);
    }

    szADsPath = AllocateUnicodeString(argv[0]);
    szObjectType = AllocateUnicodeString(argv[1]);

    hr = EnumTransientObjects(
                szADsPath,
                szObjectType,
                TRUE
                );

error:
    FreeUnicodeString(szADsPath);
    FreeUnicodeString(szObjectType);
    if (FAILED(hr)) {
        printf("Enumerate transient objects failed\n");
        return(1);
    }
    printf("Enumerate transient objects succeeded\n");
    return(0);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\disptabl.cxx ===
#include "dispdef.hxx"
#include <stdio.h>

char *g_HelpTable[] = {"-?", "/?", "--help", "help"};
int g_nHelpTable = sizeof(g_HelpTable) / sizeof(char*);

//
// Add dispatch table entries below
//

DEFEXEC(ExecDefaultContainer);
DEFEXEC(ExecDump);
DEFEXEC(ExecEnum);
DEFEXEC(ExecGet);
DEFEXEC(ExecGroup);
DEFEXEC(ExecSession);
DEFEXEC(ExecShare);
DEFEXEC(ExecUser);

DISPENTRY g_DispTable[] = { 
                          {"default", NULL, ExecDefaultContainer},
                          {"dump", NULL, ExecDump},
                          {"enum", NULL, ExecEnum},
                          {"get", NULL, ExecGet},
                          {"group", NULL, ExecGroup},
                          {"session", NULL, ExecSession},
                          {"share", NULL, ExecShare},
                          {"user", NULL, ExecUser}
                        };

int g_nDispTable = sizeof(g_DispTable) / sizeof(DISPENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       main.cxx
//
//  Contents:   Main for oledscmd
//
//  History:    01-Aug-96  t-danal   created
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "disptabl.hxx"

//-------------------------------------------------------------------------
//
// Local functions declarations
//
//-------------------------------------------------------------------------

char *
GetProgName(
    char *progname
    );

void
PrintUsage(
    char *szProgName
    );

void
PrintHelp(
    char *szProgName,
    char *szAction
    );

void
StartUp(
    );

void
Exit(
    int code
    );


//-------------------------------------------------------------------------
//
// Local function definitions
//
//-------------------------------------------------------------------------

char *
GetProgName(
    char *progname
    )
{
    return progname;
}

void
PrintUsage(
    char *szProgName
    )
{
    int i;
    int n;
    if (g_nDispTable) {
        n = g_nDispTable - 1;
        printf("usage: %s [", szProgName);
        for (i = 0; i < n; i++)
            printf(" %s |", g_DispTable[i].action);
        printf(" %s ]\n", g_DispTable[i].action);
    }
    if (g_nHelpTable) {
        n = g_nHelpTable - 1;
        printf("for help, use: %s [ ", szProgName);
        for (i = 0; i < n; i++)
            printf(" %s |", g_HelpTable[i]);
        printf(" %s ]\n", g_HelpTable[i]);
    }
}

void
PrintHelp(
    char *szProgName,
    char *szAction
    )
{
    if (!szAction)
        printf("Help for %s goes here.", szProgName);
    else
        printf("%s: Could not find help for %s", szProgName, szAction);
}

void
MissingHelpText(
    char *szProgName,
    char *szAction
    )
{
    if (!szAction)
        printf("%s: Missing help text", szProgName);
    else
        printf("%s: Missing help text for %s", szProgName, szAction);
}


void
StartUp(
    )
{
    HRESULT hr;
    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        printf("CoInitialize failed\n");
        Exit(1);
    }
}

void
Exit(
    int code
    )
{
    CoUninitialize();
    exit(code);
}


//-------------------------------------------------------------------------
//
// Global function definitions
//
//-------------------------------------------------------------------------

void
PrintUsage(
    char *szProgName, 
    char *szActions, 
    char *extra
    )
{
    if (extra)
        printf("usage: %s %s %s\n", szProgName, szActions, extra);
    else
        printf("usage: %s %s\n", szProgName, szActions);
}

void
PrintUsage(
    char *szProgName, 
    char *szActions, 
    DISPENTRY *DispTable,
    int nDispTable
    )
{
    int i;
    int n;
    if (nDispTable) {
        n = nDispTable - 1;
        printf("usage: %s %s [", szProgName, szActions);
        for (i = 0; i < n; i++)
            printf(" %s |", DispTable[i].action);
        printf(" %s ]\n", DispTable[i].action);
    }
    if (g_nHelpTable) {
        n = g_nHelpTable - 1;
        printf("for help, use: %s %s [ ", szProgName, szActions);
        for (i = 0; i < n; i++)
            printf(" %s |", g_HelpTable[i]);
        printf(" %s ]\n", g_HelpTable[i]);
    }
}

BOOL
IsHelp(
    char *szAction
    )
{
    int i;
    for (i = 0; i < g_nHelpTable; i++)
        if (IsSameAction(szAction, g_HelpTable[i]))
            return TRUE;
    return FALSE;
}

BOOL
IsValidAction(
    char *szAction,
    DISPENTRY *DispTable,
    int nDispTable
    )
{
    int i;
    for (i = 0; i < nDispTable; i++)
        if (IsSameAction(szAction, DispTable[i].action))
            return TRUE;
    return FALSE;
}

BOOL
IsSameAction(
    char *action1,
    char *action2
    )
{
    if (action1 && action2)                                // neither is NULL
        return !_stricmp(action1, action2) ? TRUE : FALSE;
    else if (!action1 && !action2)                         // both are NULL
        return TRUE;
    else if (action1)                                      // action2 is NULL
        return !*action1 ? TRUE : FALSE;
    else                                                   // action1 is NULL
        return !*action2 ? TRUE : FALSE;
}

BOOL
DispatchHelp(
    DISPENTRY *DispTable,
    int nDispTable,
    char *szProgName, 
    char *szPrevActions,
    char *szAction
    )
{
    HELPFUNC help = NULL;
    BOOL found = FALSE;
    int i;

    for (i = 0; i < nDispTable; i++)
        if (IsSameAction(szAction, DispTable[i].action)) {
            help = DispTable[i].help;
            found = TRUE;
            break;
        }
    if (found) {
        char *szActions = AllocAction(szPrevActions, szAction);
        if (help)
            help(szProgName, szActions);
        else
            MissingHelpText(szProgName, szActions);
        FreeAction(szActions);
        return TRUE;
    }
    return FALSE;
}

int
DispatchExec(
    DISPENTRY *DispTable,
    int nDispTable,
    char *szProgName, 
    char *szPrevActions,
    char *szAction, 
    int argc, 
    char *argv[]
    )
{
    EXECFUNC exec = NULL;
    int i;

    for (i = 0; i < nDispTable; i++)
        if (IsSameAction(szAction, DispTable[i].action)) {
            exec = DispTable[i].exec;
            break;
        }
    if (exec) {
        char *szActions = AllocAction(szPrevActions, szAction);
        int status = exec(szProgName, szActions, argc, argv);
        FreeAction(szActions);
        return status;
    }
    PrintUsage(szProgName, szPrevActions, DispTable, nDispTable);
    return 1;
}

char *
AllocAction(
    char *action1,
    char *action2
    )
{
    char *str;
    int len;
    int len1 = action1?strlen(action1):0;
    int len2 = action2?strlen(action2):0;

    if (len1 && len2) {
        str = (char *) malloc((len1 + len2 + 2) * sizeof(char));
        strcpy(str, action1);
        strcpy(str + len1, " ");
        strcpy(str + len1 + 1, action2);
        return str;
    }
    if (len1) {
        str = (char*) malloc((len1 + 1) * sizeof(char));
        strcpy(str, action1);
        return str;
    }
    if (len2) {
        str = (char*) malloc((len2 + 1) * sizeof(char));
        strcpy(str, action2);
        return str;
    }
    return NULL;
}

void
FreeAction(
    char *action
    )
{
    if (action)
        free(action);
    return;
}

BOOL
DoHelp(
    char *szProgName,
    char *szPrevActions,
    char *szCurrentAction,
    char *szNextAction,
    DISPENTRY *DispTable,
    int nDispTable,
    HELPFUNC DefaultHelp
    )
{
    BOOL needhelp = FALSE;
    BOOL helped = FALSE;

    if (needhelp = IsHelp(szCurrentAction)) {
        if (szNextAction) {
            helped = DispatchHelp(DispTable, nDispTable,
                                  szProgName, 
                                  szPrevActions, szNextAction);
        } else if (DefaultHelp) {
            DefaultHelp(szProgName, szPrevActions);
            helped = TRUE;
        }
    } else if (needhelp = (szNextAction && 
                           IsHelp(szNextAction))) {
        helped = DispatchHelp(DispTable, nDispTable,
                              szProgName, 
                              szPrevActions, szCurrentAction);
    }
    if (needhelp && !helped) {
        char *action = AllocAction(szPrevActions, szCurrentAction);
        PrintHelp(szProgName, action);
        FreeAction(action);
    }
    return needhelp;
}




//-------------------------------------------------------------------------
//
// main
//
//-------------------------------------------------------------------------

INT __cdecl
main(int argc, char * argv[])
{
    HRESULT hr;
    int status;
    char* szAction;
    char* szProgName;

    StartUp();

    szProgName = GetProgName(argv[0]);

    if (argc < 2) {
        PrintUsage(szProgName);
        Exit(1);
    }

    szAction = argv[1];
    argc-=2;
    argv+=2;

    if (DoHelp(szProgName, NULL, szAction, NULL, 
               g_DispTable, g_nDispTable,
               PrintHelp))
        Exit(0);

    status = DispatchExec(g_DispTable, g_nDispTable,
                          szProgName, NULL, szAction, 
                          argc, argv);
    Exit(status);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\group.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       group.cxx
//
//  Contents:   Group membership
//
//  History:    08-06-96  t-danal   created from grpmem, grmemadd, grmemdel
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

//
// Dispatch Table Defs
//

#include "dispdef.hxx"

DEFEXEC(ExecGroupMembers);
DEFEXEC(ExecGroupAddMember);
DEFEXEC(ExecGroupDelMember);

DEFDISPTABLE(DispTable) = { 
                           {"mem", NULL, ExecGroupMembers},
                           {"add", NULL, ExecGroupAddMember},
                           {"del", NULL, ExecGroupDelMember}
                          };

DEFDISPSIZE(nDispTable, DispTable);

//
// Private defines
//

#define MAX_ADS_ENUM      100

//
// Local functions
//

HRESULT
GroupEnumObject(
    LPWSTR szLocation
    ) ;

HRESULT
GroupAddObject(
    LPWSTR szLocation,
    LPWSTR szPath
    );


HRESULT
GroupRemoverObject(
    LPWSTR szLocation,
    LPWSTR szPath
    );

//
// Local function definitions
//

HRESULT
GroupEnumObject(
    LPWSTR szLocation
    )
{
    HRESULT hr;
    IADsGroup * pADsGroup =  NULL;
    IADsMembers * pADsCollection = NULL;
    DWORD dwObjects = 0, i = 0;
    BOOL  fContinue = TRUE;
    BSTR bstrADsPath = NULL;

    ULONG cElementFetched = 0L;
    IEnumVARIANT * pEnumVariant = NULL;
    IUnknown * pUnknown = NULL;
    VARIANT VariantArray[MAX_ADS_ENUM];
    
    IADs *pObject = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrName = NULL;


    hr = ADsGetObject(
                szLocation,
                IID_IADsGroup,
                (void **)&pADsGroup
                );
    BAIL_ON_FAILURE(hr);

    hr = pADsGroup->Members(&pADsCollection);
    BAIL_ON_FAILURE(hr);

    hr = pADsCollection->get__NewEnum(&pUnknown);
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void **)&pEnumVariant);
    BAIL_ON_FAILURE(hr);

    hr = pADsGroup->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    printf("Group: %ws\n", bstrADsPath);
    FREE_BSTR(bstrADsPath);

    while (fContinue) {

        hr = ADsEnumerateNext(
                    pEnumVariant,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE)
            fContinue = FALSE;

        for (i = 0; i < cElementFetched; i++ ) {
            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            BAIL_ON_FAILURE(hr);

            hr = pObject->get_ADsPath(&bstrName) ;
            BAIL_ON_FAILURE(hr);

            printf("\tMember Object: %ws\n", bstrName);
            FREE_BSTR(bstrName);

            FREE_INTERFACE(pObject);
            FREE_INTERFACE(pDispatch);
        }

        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
        dwObjects += cElementFetched;
    }

    printf("Total Number of Objects enumerated is %d\n", dwObjects);
    hr = S_OK;
error:
    FREE_INTERFACE(pADsGroup);
    FREE_INTERFACE(pADsCollection);
    FREE_INTERFACE(pEnumVariant);
    FREE_INTERFACE(pUnknown);
    FREE_INTERFACE(pObject);
    FREE_INTERFACE(pDispatch);
    FREE_BSTR(bstrName);
    FREE_BSTR(bstrADsPath);
    return(hr);
}

HRESULT
GroupAddObject(
    LPWSTR szLocation,
    LPWSTR szPath
    )
{
    HRESULT hr;
    IADsGroup * pADsGroup =  NULL;

    hr = ADsGetObject(
                szLocation,
                IID_IADsGroup,
                (void **)&pADsGroup
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsGroup->Add(
                        szPath
                        );
    pADsGroup->Release();
    BAIL_ON_FAILURE(hr);

    printf("grmemadd: Successfully added %ws to %ws\n", szPath, szLocation);
    return(S_OK);
error:
    printf("grmemadd: Failed to add %ws to %ws\n", szPath, szLocation);
    return(hr);
}

HRESULT
GroupRemoveObject(
    LPWSTR szLocation,
    LPWSTR szPath
    )
{
    HRESULT hr;
    IADsGroup * pADsGroup =  NULL;

    hr = ADsGetObject(
                szLocation,
                IID_IADsGroup,
                (void **)&pADsGroup
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsGroup->Remove(
                        szPath
                        );
    pADsGroup->Release();
    BAIL_ON_FAILURE(hr);

    printf("grmemdel: Successfully removed %ws from %ws\n", 
           szPath, szLocation);
    return(S_OK);

error:
    printf("grmemdel: Failed to remove %ws from %ws\n", 
           szPath, szLocation);
    return(hr);
}


//
// Exec function definitions
//

int
ExecGroup(char *szProgName, char *szAction, int argc, char * argv[])
{
    if (!argc) {
        PrintUsage(szProgName, szAction, DispTable, nDispTable);
        return(1);
    }

    char *szPrevActions = szAction;
    szAction = argv[0];
    argc--;
    argv++;

    if (DoHelp(szProgName, 
               szPrevActions, szAction, NULL, 
               DispTable, nDispTable,
               NULL))
        return 0;

    return DispatchExec(DispTable, nDispTable,
                        szProgName,
                        szPrevActions, szAction,
                        argc, argv);
}

int
ExecGroupMembers(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszLocation = NULL ;

    if (argc != 1) {
        PrintUsage(szProgName, szAction, "<ADsPath of Group Object>");
        return(1);
    }

    pszLocation = AllocateUnicodeString(argv[0]);
    if (!pszLocation) {
        return(1);
    }

    hr = GroupEnumObject(
                pszLocation
                );

    FreeUnicodeString(pszLocation) ;
    if (FAILED(hr))
        return(1);
    return(0) ;
}

int
ExecGroupAddMember(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszLocation = NULL ;
    LPWSTR pszPath = NULL;

    if (argc != 2) {
        PrintUsage(szProgName, szAction,
                   "<Group Path> <Member Path>");
        return(0);
    }

    pszLocation = AllocateUnicodeString(argv[0]);
    if (!pszLocation) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pszPath = AllocateUnicodeString(argv[1]);
    if (!pszPath) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = GroupAddObject(
                pszLocation,
                pszPath
                );

error:
    FreeUnicodeString(pszLocation) ;
    FreeUnicodeString(pszPath);
    if (FAILED(hr))
        return(1);
    return(0) ;
}

int
ExecGroupDelMember(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR pszLocation = NULL ;
    LPWSTR pszPath = NULL;

    if (argc != 2) {
        PrintUsage(szProgName, szAction,
                   "<Group Path> <Member Path>");
        return(1);
    }

    pszLocation = AllocateUnicodeString(argv[0]);
    if (!pszLocation) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pszPath = AllocateUnicodeString(argv[1]);
    if (!pszPath) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = GroupRemoveObject(
                pszLocation,
                pszPath
                );

error:
    FreeUnicodeString(pszLocation) ;
    FreeUnicodeString(pszPath);
    if (FAILED(hr))
        return(1);
    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\proputil.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:      proputil.cxx
//
//  Contents:  Property Listing Utilities
//
//  History:   08-05-96  t-danal  created
//
//----------------------------------------------------------------------------

//
// ********* System Includes
//

#define UNICODE
#define _UNICODE
#define INC_OLE2
// #define _OLEAUT32_
// #define SECURITY_WIN32


#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// *********  Public ADs includes
//

#include <activeds.h>

#include "macro.hxx"
#include "proputil.hxx"

HRESULT
PrintVariant(
    VARIANT varPropData
    )
{
    HRESULT hr;
    BSTR bstrValue;

    switch (varPropData.vt) {
    case VT_I4:
        printf("\t%d", varPropData.lVal);
        break;
    case VT_BSTR:
        printf("\t%S", varPropData.bstrVal);
        break;

    case VT_BOOL:
        printf("\t%d", V_BOOL(&varPropData));
        break;

    case (VT_ARRAY | VT_VARIANT):
        PrintVariantArray(varPropData);
        break;

    case VT_DATE:
        hr = VarBstrFromDate(
                 varPropData.date,
                 LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &bstrValue
                 );
        printf("\t%S", bstrValue);
        break;

    default:
        printf("\tData type is %d\n", varPropData.vt);
        break;

    }
    printf("\n");
    return(S_OK);
}


HRESULT
PrintVariantArray(
    VARIANT var
    )
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    printf("\t");
    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        if (i < dwSUBound) {
            printf("%S, ", v.bstrVal);
        }else{
            printf("%S",v.bstrVal);
        }
    }
    return(S_OK);

error:
    return(hr);
}


HRESULT
PrintProperty(
    BSTR bstrPropName,
    HRESULT hRetVal,
    VARIANT varPropData
    )
{
    HRESULT hr = S_OK;

    switch (hRetVal) {
    case 0:
        printf("Property: %S", bstrPropName);
        PrintVariant(varPropData);
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:
        printf("Property: %S", bstrPropName);
        printf("\tProperty data could not be converted to variant\n");
        break;

    default:
        printf("Property: %S", bstrPropName);
        printf("\tProperty not available in cache\n");
        break;

    }
    return(hr);
}

HRESULT
GetPropertyList(
    IADs * pADs,
    VARIANT ** ppVariant,
    PDWORD pcElementFetched
    )
{
    HRESULT hr= S_OK;
    BSTR bstrSchemaPath = NULL;
    IADsContainer * pADsContainer = NULL;
    IEnumVARIANT * pEnumVariant = NULL;
    BOOL fContinue = TRUE;
    ULONG cthisElement = 0L;
    ULONG cElementFetched = 0L;
    LPBYTE pVariantArray = NULL;
    VARIANT varProperty;
    DWORD cb = 0;

    hr = pADs->get_Schema(&bstrSchemaPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
                bstrSchemaPath,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    BAIL_ON_FAILURE(hr);

    while (fContinue) {

        VariantInit(&varProperty);
        hr = ADsEnumerateNext(
                    pEnumVariant,
                    1,
                    &varProperty,
                    &cthisElement
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
            break;
        }

        pVariantArray = (LPBYTE)realloc(
                                        (void *)pVariantArray,
                                        cb + sizeof(VARIANT)
                                        );

        if (!pVariantArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(pVariantArray + cb, (LPBYTE)&varProperty, sizeof(VARIANT));
        cb += sizeof(VARIANT);

        cElementFetched += cthisElement;

    }

    *ppVariant = (LPVARIANT)pVariantArray;
    *pcElementFetched = cElementFetched;

error:
    if (bstrSchemaPath) {
        SysFreeString(bstrSchemaPath);
    }

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adsqry\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.1 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       main.cxx
//
//  Contents:   Main for adsqry
//
//
//----------------------------------------------------------------------------

#include "main.hxx"


#define MAX_SIZE 10


#define USE_OPENROWSET 0
//
// Globals representing the properties
//

DBPROPSET          rgDBPropSet[MAX_SIZE], rgCmdPropSet[MAX_SIZE];
DBPROP             rgDBProp[MAX_SIZE], rgCmdProp[MAX_SIZE];

ULONG              cDBPropSet, cCmdPropSet, cDBProp, cCmdProp;

LPWSTR pszCommandText;

LPWSTR pszSortAttrList = NULL;

#if USE_OPENROWSET
LPWSTR             pszTableName;
#endif

GUID               rguidDialect = DBGUID_DEFAULT;

DWORD cErr;


int __cdecl
main( int argc, char ** argv)
{

    HRESULT            hr;
    ULONG              i;
    DBCOUNTITEM        j;
    HROW             * phRows;

    WCHAR              pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    DWORD              dwError;

    OLECHAR          * szColNames = NULL;
    DBCOLUMNINFO     * prgColInfo = NULL;
    DBCOLUMNINFO     * rgInfo = NULL;
    WCHAR            * pStringBuffer = NULL;
    WCHAR            * pColInfoBuffer = NULL;

    IMalloc          * pIMalloc = NULL;
    IDBInitialize    * pIDBInit = NULL;
    IDBCreateSession * pIDBCS = NULL;
    IDBCreateCommand * pIDBCreateCommand = NULL;
    ICommandText     * pICommandText = NULL;
    ICommand         * pICommand = NULL;
    IRowset          * pIRowset = NULL;
    IAccessor        * pAccessor = NULL;
    IColumnsInfo     * pIColsInfo = NULL;
    DBORDINAL          cCol, nAttrs;
    DBCOUNTITEM        cRowsObtained;

    Data             * pMyData = NULL;
    DBBINDSTATUS     * pMyStatus = NULL;
    HACCESSOR          myAccessor = NULL;

    ICommandProperties * pICommandProperties;
    IDBProperties * pIDBProperties;

#if USE_OPENROWSET

    DBID               tableId;
    IOpenRowset      * pIOpenRowset;

#endif


    hr = ProcessArgs(argc, argv);
    BAIL_ON_FAILURE(hr);


    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        printf("CoInitialize failed\n");
        exit(1);
    }

    //
    // Instantiate a data source object for LDAP provider
    //
    hr = CoCreateInstance(
             CLSID_ADsDSOObject,
             0,
             CLSCTX_INPROC_SERVER,
             IID_IDBInitialize,
             (void **)&pIDBInit
             );
    if(FAILED(hr)) {
        printf("CoCreateInstance failed \n");
        goto error;
    }

    //
    // Initialize the Data Source
    //
    hr = pIDBInit->Initialize();
    if(FAILED(hr)) {
        printf("IDBIntialize::Initialize failed \n");
        goto error;
    }

    if (cDBPropSet) {
        pIDBInit->QueryInterface(
            IID_IDBProperties,
            (void**) &pIDBProperties);
        if(FAILED(hr)) {
            printf("QueryInterface for IDBProperties failed \n");
            goto error;
        }

        hr = pIDBProperties->SetProperties(
                 cDBPropSet,
                 rgDBPropSet);

        if(FAILED(hr)) {
            printf("IDBProperties->SetProperties failed \n");
            goto error;
        }

        FREE_INTERFACE(pIDBProperties);
    }

    pIDBInit->QueryInterface(
        IID_IDBCreateSession,
        (void**) &pIDBCS);
    if(FAILED(hr)) {
        printf("QueryInterface for IDBCreateSession failed \n");
        goto error;
    }

    FREE_INTERFACE(pIDBInit);

#if USE_OPENROWSET
    //
    // Create a session returning a pointer to its IOpenRowset interface
    //
    hr = pIDBCS->CreateSession(
             NULL,
             IID_IOpenRowset,
             (LPUNKNOWN*) &pIOpenRowset
             );
    if(FAILED(hr)) {
        printf("IDBCreateSession::CreateSession failed \n");
        goto error;
    }

    tableId.eKind = DBKIND_NAME;
    tableId.uName.pwszName = pszTableName;


    hr = pIOpenRowset->OpenRowset(
             NULL,
             &tableId,
             NULL,
             IID_IRowset,
             0,
             NULL,
             (LPUNKNOWN *)&pIRowset
             );
    BAIL_ON_FAILURE (hr);

    FREE_INTERFACE(pIOpenRowset);

    FREE_STRING(pszTableName);

#else

    //
    // Create a session returning a pointer to its CreateCommand interface
    //
    hr = pIDBCS->CreateSession(
             NULL,
             IID_IDBCreateCommand,
             (LPUNKNOWN*) &pIDBCreateCommand
             );
    if(FAILED(hr)) {
        printf("IDBCreateSession::CreateSession failed \n");
        goto error;
    }

    FREE_INTERFACE(pIDBCS);

    //
    //
    // Create a command from the session object
    //
    hr = pIDBCreateCommand->CreateCommand(
             NULL,
             IID_ICommandText,
             (LPUNKNOWN*) &pICommandText
             );

    if(FAILED(hr)) {
        printf(" IDBCreateCommand::CreateCommand failed\n");
        goto error;
    }

    FREE_INTERFACE(pIDBCreateCommand);

    //
    // Set the CommandText for the Query
    //
    hr = pICommandText->SetCommandText(
             rguidDialect,
             pszCommandText
             );

    if(FAILED(hr)) {
        printf("ICommandText::SetCommandText failed \n");
        goto error;
    }


    if (cCmdPropSet) {
        hr = pICommandText->QueryInterface(
                 IID_ICommandProperties,
                 (void**) &pICommandProperties);

        if(FAILED(hr)) {
            printf("QueryInterface for ICommandProperties failed \n");
            goto error;
        }

        hr = pICommandProperties->SetProperties(
                 cCmdPropSet,
                 rgCmdPropSet);

        if(FAILED(hr)) {
            printf("ICommandProperties:;SetProperties failed \n");
            goto error;
        }

        FREE_INTERFACE(pICommandProperties);
    }

    hr = pICommandText->QueryInterface(
             IID_ICommand,
             (void**) &pICommand);

    if(FAILED(hr)) {
        printf("QueryInterface for ICommand failed \n");
        goto error;
    }

    FREE_INTERFACE(pICommandText);

    //
    // Do the Query and get back a rowset
    //
    hr = pICommand->Execute(
             NULL,
             IID_IRowset,
             NULL,
             NULL,
             (LPUNKNOWN *)&pIRowset
             );
    if(FAILED(hr)) {
        printf("ICommand::Execute failed \n");
        goto error;
    }

    FREE_INTERFACE(pICommand);

#endif

    hr = pIRowset->QueryInterface(
             IID_IColumnsInfo,
             (void**) &pIColsInfo
             );
    if(FAILED(hr)) {
        printf("QueryInterface for IColumnsInfo failed \n");
        goto error;
    }

    hr = pIColsInfo->GetColumnInfo(
             &cCol,
             &prgColInfo,
             &szColNames
             );
    if(FAILED(hr)) {
        printf("IColumnsInfo::GetColumnInfo failed \n");
        goto error;
    }

    //
    // The no. of attributes is one less than the no. of columns because of
    // the Bookmark column
    //
    nAttrs = cCol - 1;


    pMyStatus = (DBBINDSTATUS *) LocalAlloc(
                                     LPTR,
                                     sizeof(DBBINDSTATUS) * nAttrs
                                     );
    BAIL_ON_NULL(pMyStatus);

    hr = CreateAccessorHelper(
             pIRowset,
             nAttrs,
             prgColInfo,
             &myAccessor,
             pMyStatus
             );
    if(FAILED(hr)) {
        printf("CreateAccessorHelper failed \n");
        goto error;
    }


    pMyData = (Data *) LocalAlloc(
                           LPTR,
                           sizeof(Data) * nAttrs
                           );
    if(!pMyData) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    //  Get the rows; 256 at a time
    //
    phRows = NULL;
    hr = pIRowset->GetNextRows(
             NULL,
             0,
             256,
             &cRowsObtained,
             &phRows
             );
    if(FAILED(hr)) {
        printf("IRowset::GetNextRows failed \n");
        goto error;
    }

    j = cRowsObtained;
    while (cRowsObtained) {
        for (i = 0; i < cRowsObtained; i++) {
            //
            // Get the data from each row
            //
            hr = pIRowset->GetData(
                     phRows[i],
                     myAccessor,
                     (void*)pMyData
                     );
            if(FAILED(hr)) {
                printf("IRowset::GetData failed \n");
                goto error;
            }

            PrintData(pMyData, nAttrs, prgColInfo);
        }

        pIRowset->ReleaseRows(
                      cRowsObtained,
                      phRows,
                      NULL,
                      NULL,
                      NULL
                      );

        //
        // Get the next 256 rows
        //

        hr = pIRowset->GetNextRows(
                 NULL,
                 0,
                 256,
                 &cRowsObtained,
                 &phRows
                 );
        if(FAILED(hr)) {
            printf("IRowset::GetNextRows failed \n");
            goto error;
        }
        j+=cRowsObtained;
    }


    printf("Rows printed = %d\n", j);

    FREE_STRING(pszCommandText);

    hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);
    
    //
    // Nothing much we can do at this point if this failed.
    //
    if (FAILED(hr)) {
        CoUninitialize();
        exit(0);
    }

    IMALLOC_FREE(pIMalloc, prgColInfo);
    IMALLOC_FREE(pIMalloc, szColNames);

    FREE_INTERFACE(pIMalloc);
    FREE_INTERFACE(pAccessor);
    FREE_INTERFACE(pIColsInfo);
    FREE_INTERFACE(pIRowset);

    LOCAL_FREE(pMyStatus);
    LOCAL_FREE(pMyData);

    //
    // Uninitialize OLE.
    //
    CoUninitialize();

    exit(0);

error:


    CoGetMalloc(MEMCTX_TASK, &pIMalloc);
    IMALLOC_FREE(pIMalloc, prgColInfo);
    IMALLOC_FREE(pIMalloc, szColNames);

    FREE_STRING(pszCommandText);

    FREE_INTERFACE(pIMalloc);
    FREE_INTERFACE(pIDBInit);
    FREE_INTERFACE(pIDBCS);
    FREE_INTERFACE(pIDBCreateCommand);
    FREE_INTERFACE(pICommandText);
    FREE_INTERFACE(pICommand);
    FREE_INTERFACE(pIRowset);
    FREE_INTERFACE(pIColsInfo);
    FREE_INTERFACE(pAccessor);

    LOCAL_FREE(pMyStatus);
    LOCAL_FREE(pMyData);

    printf("Errors stopped the Query; hr = %x", hr);

    if(hr == ERROR_EXTENDED_ERROR) {
        hr = ADsGetLastError(
                 &dwError,
                 pszErrorBuf,
                 MAX_PATH,
                 pszNameBuf,
                 MAX_PATH
                 );
    }

    if(SUCCEEDED(hr)) {
        wprintf(L"Error in %s; %s\n", pszNameBuf, pszErrorBuf);
    }

    exit(1);
    return(0);
}



//+---------------------------------------------------------------------------
//
//  Function:   ProcessArgs
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
ProcessArgs(
    int argc,
    char * argv[]
    )
{
    argc--;
    int currArg = 1;
    LPWSTR pTemp = NULL;
    char *pszCurrPref = NULL, *pszCurrPrefValue = NULL;

    LPWSTR pszSearchBase = NULL, pszSearchFilter = NULL, pszAttrList = NULL;
    LPWSTR pszUserName = NULL, pszPassword = NULL;
    DWORD dwAuthFlags;

    cCmdProp = cDBProp = 0;

    while (argc) {
        if (argv[currArg][0] != '/' && argv[currArg][0] != '-')
            BAIL_ON_FAILURE (E_FAIL);
        switch (argv[currArg][1]) {
        case 'b':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchBase = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            break;

        case 'f':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchFilter = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchFilter);
            break;

        case 'd':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            if (!_stricmp(argv[currArg], "sql"))
                rguidDialect = DBGUID_SQL;
            else if (!_stricmp(argv[currArg], "ldap"))
                rguidDialect = DBGUID_LDAPDialect;
            else if (!_stricmp(argv[currArg], "default"))
                rguidDialect = DBGUID_DEFAULT;
            else
                BAIL_ON_FAILURE (E_FAIL);

            break;

        case 'a':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszAttrList = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszAttrList);

            break;

        case 'u':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszUserName = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszUserName);
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszPassword = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszPassword);

            rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_USERID;
            rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED;
            rgDBProp[cDBProp].vValue.vt = VT_BSTR;
            V_BSTR (&rgDBProp[cDBProp].vValue) = SysAllocString(pszUserName);
            cDBProp++;


            rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_PASSWORD;
            rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED;
            rgDBProp[cDBProp].vValue.vt = VT_BSTR;
            V_BSTR (&rgDBProp[cDBProp].vValue) = SysAllocString(pszPassword);
            cDBProp++;

            break;

        case 'p':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue)
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "asynchronous")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_ASYNCHRONOUS;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "attrTypesOnly")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_ATTRIBTYPES_ONLY;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "SecureAuth")) {
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    dwAuthFlags |= ADS_SECURE_AUTHENTICATION;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    dwAuthFlags &= ~ADS_SECURE_AUTHENTICATION;
                else
                    BAIL_ON_FAILURE(E_FAIL);

                rgDBProp[cDBProp].dwPropertyID = DBPROP_AUTH_ENCRYPT_PASSWORD;
                rgDBProp[cDBProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgDBProp[cDBProp].vValue.vt = VT_BSTR;
                V_BSTR (&rgDBProp[cDBProp].vValue) = SysAllocString(pszPassword);
                cDBProp++;

            }
            else if (!_stricmp(pszCurrPref, "derefAliases")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_DEREF_ALIASES;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "timeOut")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_TIMEOUT;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                V_I4 (&rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "timeLimit")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_TIME_LIMIT;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                V_I4 (&rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "sizeLimit")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_SIZE_LIMIT;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                V_I4 (&rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "PageSize")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_PAGESIZE;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                V_I4 (&rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "PagedTimeLimit")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_PAGED_TIME_LIMIT;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                V_I4 (&rgCmdProp[cCmdProp].vValue) = atoi(pszCurrPrefValue);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "SearchScope")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_SEARCH_SCOPE;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                if (!_stricmp(pszCurrPrefValue, "Base" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_BASE;
                else if (!_stricmp(pszCurrPrefValue, "OneLevel" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_ONELEVEL;
                else if (!_stricmp(pszCurrPrefValue, "Subtree" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_SCOPE_SUBTREE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "ChaseReferrals")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_CHASE_REFERRALS;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_I4;
                if (!_stricmp(pszCurrPrefValue, "always" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_ALWAYS;
                else if (!_stricmp(pszCurrPrefValue, "never" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_NEVER;
                else if (!_stricmp(pszCurrPrefValue, "external" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_EXTERNAL;
                else if (!_stricmp(pszCurrPrefValue, "subordinate" ))
                    V_I4 (&rgCmdProp[cCmdProp].vValue) = ADS_CHASE_REFERRALS_SUBORDINATE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "cacheResults")) {
                rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_CACHE_RESULTS;
                rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
                rgCmdProp[cCmdProp].vValue.vt = VT_BOOL;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    V_BOOL (&rgCmdProp[cCmdProp].vValue) = VARIANT_FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
                cCmdProp++;
            }
            else if (!_stricmp(pszCurrPref, "sortOn")) {
                pszSortAttrList = AllocateUnicodeString(pszCurrPrefValue);
            }
            else
                BAIL_ON_FAILURE(E_FAIL);

            break;

        default:
            BAIL_ON_FAILURE(E_FAIL);
        }

        argc--;
        currArg++;
    }

    //
    // Check for Mandatory arguments;
    //

    if (!pszSearchBase || !pszSearchFilter || !pszAttrList)
        BAIL_ON_FAILURE(E_FAIL);

#if USE_OPENROWSET

    pszTableName = AllocADsStr(
                       pszSearchBase
                       );
    BAIL_ON_NULL(E_FAIL);

#endif

    if (IsEqualGUID(rguidDialect, DBGUID_SQL) ) {

        // if sorting is specified, add to the command text itself
        //
        DWORD sortAttrLen = pszSortAttrList ?
                          wcslen(L" ORDER BY ") + wcslen(pszSortAttrList) : 0;

        pszCommandText = (LPWSTR) AllocADsMem(
                                      (wcslen(pszSearchBase) +
                                      wcslen(pszSearchFilter) +
                                      wcslen(pszAttrList) +
                                      wcslen(L"''") +
                                      wcslen(L"SELECT ") +
                                      wcslen(L" FROM ") +
                                      wcslen(L" WHERE ") +
                                      sortAttrLen +
                                      1) * sizeof(WCHAR)
                                      );
        BAIL_ON_NULL(E_FAIL);

        wcscpy(pszCommandText, L"SELECT ");
        wcscat(pszCommandText, pszAttrList);
        wcscat(pszCommandText, L" FROM '");
        wcscat(pszCommandText, pszSearchBase);
        wcscat(pszCommandText, L"' WHERE ");
        wcscat(pszCommandText, pszSearchFilter);

        if (pszSortAttrList) {
            wcscat(pszCommandText, L" ORDER BY ");
            wcscat(pszCommandText, pszSortAttrList);
        }

    } else {

        pszCommandText = (LPWSTR) AllocADsMem(
                                      (wcslen(pszSearchBase) +
                                      wcslen(pszSearchFilter) +
                                      wcslen(pszAttrList) +
                                      5) * sizeof(WCHAR)
                                      );
        BAIL_ON_NULL(E_FAIL);

        wcscpy(pszCommandText, L"<");
        wcscat(pszCommandText, pszSearchBase);
        wcscat(pszCommandText, L">;");
        wcscat(pszCommandText, pszSearchFilter);
        wcscat(pszCommandText, L";");
        wcscat(pszCommandText, pszAttrList);

        if (pszSortAttrList) {

            // if sorting is specified, add as a command property

            rgCmdProp[cCmdProp].dwPropertyID = ADSIPROP_SORT_ON;
            rgCmdProp[cCmdProp].dwOptions = DBPROPOPTIONS_REQUIRED;
            rgCmdProp[cCmdProp].vValue.vt = VT_BSTR;
            V_BSTR (&rgCmdProp[cCmdProp].vValue) = AllocateUnicodeString(pszCurrPrefValue);
            cCmdProp++;

        }

    }


    if (cDBProp > 0) {
        cDBPropSet = 1;
        rgDBPropSet[0].rgProperties    = rgDBProp;
        rgDBPropSet[0].cProperties     = cDBProp;
        rgDBPropSet[0].guidPropertySet = DBPROPSET_DBINIT;
    }

    if (cCmdProp > 0) {
        cCmdPropSet = 1;
        rgCmdPropSet[0].rgProperties    = rgCmdProp;
        rgCmdPropSet[0].cProperties     = cCmdProp;
        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH;
    }

    FreeUnicodeString(pszSearchBase) ;
    FreeUnicodeString(pszSearchFilter) ;
    FreeUnicodeString(pszAttrList) ;

    return (S_OK);

error:

    FreeUnicodeString(pszSearchBase) ;
    FreeUnicodeString(pszSearchFilter) ;
    FreeUnicodeString(pszAttrList) ;

    PrintUsage();
    return E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//
//----------------------------------------------------------------------------

//
// ********* System Includes
//

#define UNICODE
#define _UNICODE
#define INC_OLE2

#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// ********* Local Includes
//

#include "sconv.hxx"

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\session.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:      session.cxx
//
//  Contents:  Active Directory Session manipulation
//
//  History:   05-07-96  RamV     Created
//             08-05-96  t-danal  Add to oledscmd
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

//
// Dispatch Table Defs
//

#include "dispdef.hxx"

DEFEXEC(ExecSessionDel);

DEFDISPTABLE(DispTable) = {
                           {"del", NULL, ExecSessionDel}
                          };

DEFDISPSIZE(nDispTable, DispTable);

//
// Local functions
//

HRESULT
DeleteSession(
    LPWSTR szParentContainer,
    LPWSTR szSessionName
    );

//
// Local function definitions
//

HRESULT
DeleteSession(
    LPWSTR szParentContainer,
    LPWSTR szSessionName
    )
{
    HRESULT hr;
    IADsFileServiceOperations * pADsParent = NULL;
    IUnknown * pUnknown = NULL;
    IADs * pADs = NULL;
    IADsCollection *pCollection = NULL;

    hr = ADsGetObject(
                szParentContainer,
                IID_IADsFileServiceOperations,
                (void **)&pADsParent
                );
    BAIL_ON_FAILURE(hr);

    hr = pADsParent->Sessions(&pCollection);
    BAIL_ON_FAILURE(hr);

    hr = pCollection->Remove(szSessionName);
    BAIL_ON_FAILURE(hr);

error:
    if (pADsParent) {
        pADsParent->Release();
    }
    if (pCollection) {
        pCollection->Release();
    }
    return(hr);
}


//
// Exec function definitions
//

int
ExecSession(char *szProgName, char *szAction, int argc, char * argv[])
{
    if (!argc) {
        PrintUsage(szProgName, szAction, DispTable, nDispTable);
        return(1);
    }

    char *szPrevActions = szAction;
    szAction = argv[0];
    argc--;
    argv++;

    if (DoHelp(szProgName,
               szPrevActions, szAction, NULL,
               DispTable, nDispTable,
               NULL))
        return 0;

    return DispatchExec(DispTable, nDispTable,
                        szProgName,
                        szPrevActions, szAction,
                        argc, argv);
}

int
ExecSessionDel(
    char *szProgName,
    char *szAction,
    int argc,
    char * argv[]
    )
{
    HRESULT hr;
    LPWSTR szParentContainer = NULL;
    LPWSTR szSessionName = NULL;

    if (argc  != 2) {
        PrintUsage(szProgName,
                   szAction,
                   "<Container> <SessionName>");
        return(1);
    }

    szParentContainer = AllocateUnicodeString(
                        argv[0]
                        );
    szSessionName = AllocateUnicodeString(
                        argv[1]
                        );

    hr = DeleteSession(
            szParentContainer,
            szSessionName
            );

    FreeUnicodeString(szSessionName);
    FreeUnicodeString(szParentContainer);
    if (FAILED(hr)) {
        printf("DeleteSession failed with error code %x\n", hr);
        return(1);
    }
    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\csearch\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------

//
// System Includes
//
#define INC_OLE2
#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// Public OleDs includes
//


//
// Private defines
//

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                goto error;   \
        }

#include "activeds.h"
#include "main.hxx"
#include "adsi.h"

//
// Globals representing the parameters
//

LPWSTR pszSearchBase, pszSearchFilter, pszAttrNames[10], pszAttrList;
DWORD dwNumberAttributes = -1;


//
// Preferences
//
BOOL fASynchronous=FALSE, fDerefAliases=FALSE, fAttrsOnly=FALSE;
DWORD fSizeLimit, fTimeLimit, dwTimeOut, dwPageSize, dwSearchScope;

ADS_SEARCHPREF_INFO pSearchPref[10];
DWORD dwCurrPref = 0;

LPWSTR pszUserName=NULL, pszPassword=NULL;
DWORD dwAuthFlags=0;
DWORD cErr=0;


char *prefNameLookup[] =
    {
    "ADS_SEARCHPREF_ASYNCHRONOUS",
    "ADS_SEARCHPREF_DEREF_ALIASES",
    "ADS_SEARCHPREF_SIZE_LIMIT",
    "ADS_SEARCHPREF_TIME_LIMIT",
    "ADS_SEARCHPREF_ATTRIBTYPES_ONLY",
    "ADS_SEARCHPREF_SEARCH_SCOPE",
    "ADS_SEARCHPREF_TIMEOUT",
    "ADS_SEARCHPREF_PAGESIZE",
    "ADS_SEARCHPREF_PAGED_TIME_LIMIT",
    "ADS_SEARCHPREF_CHASE_REFERRALS"
    };

HRESULT
ConvertTrusteeToSid(
    LPWSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    );









//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//----------------------------------------------------------------------------
INT __cdecl
main(int argc, char * argv[])
{

    HRESULT hr=S_OK;
    HANDLE handle = NULL;

    ADS_SEARCH_HANDLE hSearchHandle=NULL;
    ADS_SEARCH_COLUMN Column;
    DWORD nRows = 0, i;
    LPWSTR pszColumnName = NULL;

    LPWSTR pszDest = NULL;
    LPBYTE pSid = NULL;
    DWORD dwSize = 0;

#if 0       // Enable if you want to test binary values in filters and send
            // pszBinaryFilter instead of pszSearchFilter in ExecuteSearch

    WCHAR pszBinaryFilter[256] = L"objectSid=";

    LPWSTR pszDest = NULL;

    BYTE column[100] = {
                    0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x15, 0x00,
                    0x00, 0x00, 0x59, 0x51, 0xb8, 0x17, 0x66, 0x72, 0x5d, 0x25,
                    0x64, 0x63, 0x3b, 0x0b, 0x29, 0x99, 0x21, 0x00 };

    hr = ADsEncodeBinaryData (
       column,
       28,
       &pszDest
       );

    wcscat( pszBinaryFilter, pszDest );

    FreeADsMem( pszDest );

#endif


    //
    // Sets the global variables with the parameters
    //
    hr = ProcessArgs(argc, argv);
    BAIL_ON_FAILURE(hr);

    hr = ADSIOpenDSObject(
                pszSearchBase,
                pszUserName,
                pszPassword,
                dwAuthFlags,
                &handle
                );
    BAIL_ON_FAILURE(hr);

    if (dwCurrPref) {
        hr = ADSISetSearchPreference(
                 handle,
                 pSearchPref,
                 dwCurrPref
                 );
        BAIL_ON_FAILURE(hr);

        if (hr != S_OK) {
            for (i=0; i<dwCurrPref; i++) {
                if (pSearchPref[i].dwStatus != ADS_STATUS_S_OK) {
                    printf(
                        "Error in setting the preference %s: status = %d\n",
                           prefNameLookup[pSearchPref[i].dwSearchPref],
                           pSearchPref[i].dwStatus
                           );
                    cErr++;
                }
            }

        }
    }

    hr = ADSIExecuteSearch(
             handle,
             pszSearchFilter,
             pszAttrNames,
             dwNumberAttributes,
             &hSearchHandle
              );
    BAIL_ON_FAILURE(hr);

    hr = ADSIGetNextRow(
             handle,
             hSearchHandle
             );
    BAIL_ON_FAILURE(hr);

    while (hr != S_ADS_NOMORE_ROWS) {
        nRows++;

        if (dwNumberAttributes == -1) {
            hr = ADSIGetNextColumnName(
                     handle,
                     hSearchHandle,
                     &pszColumnName
                     );
            BAIL_ON_FAILURE(hr);

            while (hr != S_ADS_NOMORE_COLUMNS) {
                hr = ADSIGetColumn(
                         handle,
                         hSearchHandle,
                         pszColumnName,
                         &Column
                         );

                if (FAILED(hr)  && hr != E_ADS_COLUMN_NOT_SET)
                    goto error;

                if (SUCCEEDED(hr)) {
                    PrintColumn(&Column, pszColumnName);
                    ADSIFreeColumn(
                        handle,
                        &Column
                        );
                }

                FreeADsMem(pszColumnName);
                hr = ADSIGetNextColumnName(
                         handle,
                         hSearchHandle,
                         &pszColumnName
                         );
                BAIL_ON_FAILURE(hr);
            }
            printf("\n");
        }
        else {
            for (int i=0; i<dwNumberAttributes; i++) {
                hr = ADSIGetColumn(
                         handle,
                         hSearchHandle,
                         pszAttrNames[i],
                         &Column
                         );

                if (hr == E_ADS_COLUMN_NOT_SET)
                    continue;

                BAIL_ON_FAILURE(hr);

                PrintColumn(&Column, pszAttrNames[i]);

                ADSIFreeColumn(
                    handle,
                    &Column
                    );
            }
        printf("\n");
        }

        hr = ADSIGetNextRow(
                 handle,
                 hSearchHandle
                 );
        BAIL_ON_FAILURE(hr);
    }

    wprintf (L"Total Rows: %d\n", nRows);

    if (cErr) {
        wprintf (L"%d warning(s) ignored", cErr);
    }

    if (hSearchHandle)
        ADSICloseSearchHandle(
                       handle,
                       hSearchHandle
                       );

    if ( handle )
        ADSICloseDSObject( handle );

    FREE_UNICODE_STRING(pszSearchBase) ;
    FREE_UNICODE_STRING(pszSearchFilter) ;
    FREE_UNICODE_STRING(pszAttrList) ;

    return(0) ;

error:

    if (hSearchHandle)
        ADSICloseSearchHandle(
            handle,
            hSearchHandle
            );

    if ( handle )
        ADSICloseDSObject( handle );

    FREE_UNICODE_STRING(pszSearchBase) ;
    FREE_UNICODE_STRING(pszSearchFilter) ;
    FREE_UNICODE_STRING(pszAttrList) ;
    FREE_UNICODE_STRING(pszUserName) ;
    FREE_UNICODE_STRING(pszPassword) ;

    wprintf (L"Error! hr = 0x%x\n", hr);
    return(1) ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessArgs
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
ProcessArgs(
    int argc,
    char * argv[]
    )
{
    argc--;
    int currArg = 1;
    LPWSTR pTemp;
    char *pszCurrPref, *pszCurrPrefValue;

    while (argc) {
        if (argv[currArg][0] != '/' && argv[currArg][0] != '-')
            BAIL_ON_FAILURE (E_FAIL);
        switch (argv[currArg][1]) {
        case 'b':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchBase = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            break;

        case 'f':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchFilter = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchFilter);
            break;

        case 'a':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszAttrList = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszAttrList);

            dwNumberAttributes = 0;
            pTemp = wcstok(pszAttrList, L",");
            pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
            dwNumberAttributes++;

            while (pTemp) {
                pTemp = wcstok(NULL, L",");
                pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
                dwNumberAttributes++;
            }
            dwNumberAttributes--;
            break;

        case 'u':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszUserName = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszPassword = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            break;

        case 't':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue)
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "SecureAuth")) {
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    dwAuthFlags |= ADS_SECURE_AUTHENTICATION;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    dwAuthFlags &= ~ADS_SECURE_AUTHENTICATION;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "UseEncrypt")) {
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    dwAuthFlags |= ADS_USE_ENCRYPTION;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    dwAuthFlags &= ~ADS_USE_ENCRYPTION;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else
                BAIL_ON_FAILURE(E_FAIL);
            break;


        case 'p':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue)
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "asynchronous")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "attrTypesOnly")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "derefAliases")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_DEREF_ALWAYS;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_DEREF_NEVER;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "timeOut")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_TIMEOUT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "timeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_TIME_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "sizeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "PageSize")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "PagedTimeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "SearchScope")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                if (!_stricmp(pszCurrPrefValue, "Base" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_BASE;
                else if (!_stricmp(pszCurrPrefValue, "OneLevel" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_ONELEVEL;
                else if (!_stricmp(pszCurrPrefValue, "Subtree" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_SUBTREE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "ChaseReferrals")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else
                BAIL_ON_FAILURE(E_FAIL);

            dwCurrPref++;
            break;

        default:
            BAIL_ON_FAILURE(E_FAIL);
        }

        argc--;
        currArg++;
    }

    //
    // Check for Mandatory arguments;
    //

    if (!pszSearchBase || !pszSearchFilter)
        BAIL_ON_FAILURE(E_FAIL);

    if (dwNumberAttributes == 0) {
        //
        // Get all the attributes
        //
        dwNumberAttributes = -1;
    }

    return (S_OK);

error:

    PrintUsage();
    return E_FAIL;

}


LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}



HRESULT
ConvertTrusteeToSid(
    LPWSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;

    dwSidSize = sizeof(Sid);

    dwRet = LookupAccountNameW(
                NULL,
                bstrTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {

        hr  = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\varconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  varconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//
//----------------------------------------------------------------------------

//
// ********* System Includes
//

#define UNICODE
#define _UNICODE
#define INC_OLE2

#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// ********* Local Includes
//

#include "varconv.hxx"

HRESULT
PackString2Variant(
    LPWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;

    if (!lpszData || !*lpszData) {
        return(E_FAIL);
    }

    if (!pvData) {
        return(E_FAIL);
    }

    bstrData = SysAllocString(lpszData);

    if (!bstrData) {
        return(E_FAIL);
    }

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    return(S_OK);
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }


    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    return(S_OK);
}


HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    pvData->vt = VT_BOOL;
    V_BOOL(pvData) = (VARIANT_BOOL) fData;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\share.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       share.cxx
//
//  Contents:   Active Directory Share manipulation
//
//  History:    08-06-96  t-danal   created for oledscmd from addfsh, delfsh
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"
#include "varconv.hxx"

#define MAX_ADS_ENUM      100

//
// Dispatch Table Defs
//

#include "dispdef.hxx"

DEFEXEC(ExecShareAdd);
DEFEXEC(ExecShareDel);

DEFDISPTABLE(DispTable) = {
                          {"add", NULL, ExecShareAdd},
                          {"del", NULL, ExecShareDel}
                        };

DEFDISPSIZE(nDispTable, DispTable);

//
// Static globals
//

static LPWSTR gpszDescription = NULL;
static LPWSTR gpszPath = NULL;
static LONG glMaxUserCount;

//
// Local functions
//

HRESULT
SetFileShareProperties(
    IADs *
    );

HRESULT
AddFileShare(
    LPWSTR szParentContainer,
    LPWSTR szFileShareName
    );

HRESULT
DeleteFileShare(
    LPWSTR szParentContainer,
    LPWSTR szFileShareName
    );

//
// Local functions definitions
//

HRESULT
SetFileShareProperties(IADs *pADs)
{
    HRESULT hr = S_OK;
    IADsFileShare *pFileShare = NULL;
    BSTR bstrDescription = NULL;
    BSTR bstrPath = NULL;
    VARIANT var;

    hr = pADs->QueryInterface(IID_IADsFileShare,
                                (void **)&pFileShare);

    BAIL_ON_FAILURE(hr);


    bstrDescription = SysAllocString(gpszDescription);

    VariantInit(&var);
    PackString2Variant(gpszDescription, &var);

    hr = pFileShare->Put(L"Description", var);
    VariantClear(&var);

    VariantInit(&var);
    PackString2Variant(gpszDescription, &var);

    hr = pFileShare->Put(L"Description", var);
    VariantClear(&var);
    BAIL_ON_FAILURE(hr);

    VariantInit(&var);
    PackDWORD2Variant(glMaxUserCount, &var);

    hr = pFileShare->Put(L"MaxUserCount", var);
    VariantClear(&var);
    BAIL_ON_FAILURE(hr);

    VariantInit(&var);
    PackString2Variant(gpszPath, &var);
    hr = pFileShare->Put(L"Path", var);
    VariantClear(&var);
    BAIL_ON_FAILURE(hr);

    hr = S_OK;
error:
    if(pFileShare)
        pFileShare->Release();
    SysFreeString(bstrPath);
    SysFreeString(bstrDescription);
    return(hr);
}

HRESULT
AddFileShare(
    LPWSTR szParentContainer,
    LPWSTR szFileShareName
    )
{
    HRESULT hr;
    IADsContainer * pADsParent = NULL;
    IDispatch * pDispatch = NULL;
    IADs * pADs = NULL;

    hr = ADsGetObject(
                szParentContainer,
                IID_IADsContainer,
                (void **)&pADsParent
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsParent->Create(L"fileshare",
                              szFileShareName,
                              &pDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pDispatch->QueryInterface(
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);

    //
    // set mandatory properties
    //
    hr = SetFileShareProperties(pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:
    if (pADsParent) {
        pADsParent->Release();
    }

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pADs) {
        pADs->Release();
    }

    return(hr);
}

HRESULT
DeleteFileShare(
    LPWSTR szParentContainer,
    LPWSTR szFileShareName
    )
{
    HRESULT hr;
    IADsContainer * pADsParent = NULL;
    IUnknown * pUnknown = NULL;
    IADs * pADs = NULL;

    hr = ADsGetObject(
                szParentContainer,
                IID_IADsContainer,
                (void **)&pADsParent
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsParent->Delete(L"FileShare",
                              szFileShareName);

        if(SUCCEEDED(hr)){
            printf("File Share successfully deleted\n");
        } else {
                printf("Failed to delete file share\n");
        }

    BAIL_ON_FAILURE(hr);

error:
    if (pADsParent) {
        pADsParent->Release();
    }
    if (pUnknown) {
        pUnknown->Release();
    }
    if (pADs) {
        pADs->Release();
    }
    return(hr);
}


//
// Exec function definitions
//

int
ExecShare(char *szProgName, char *szAction, int argc, char * argv[])
{
    if (!argc) {
        PrintUsage(szProgName, szAction, DispTable, nDispTable);
        return(1);
    }

    char *szPrevActions = szAction;
    szAction = argv[0];
    argc--;
    argv++;

    if (DoHelp(szProgName,
               szPrevActions, szAction, NULL,
               DispTable, nDispTable,
               NULL))
        return 0;

    return DispatchExec(DispTable, nDispTable,
                        szProgName,
                        szPrevActions, szAction,
                        argc, argv);
}

int
ExecShareAdd(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szParentContainer = NULL;
    LPWSTR szFileShareName = NULL;

    if (argc  != 5) {
        PrintUsage(szProgName, szAction,
                   "<ParentContainer> <ShareName> <description> "
                   "<maxusercount> <path>");
        return(1);
    }

    szParentContainer = AllocateUnicodeString(argv[0]);
    szFileShareName = AllocateUnicodeString(argv[1]);
    gpszDescription = AllocateUnicodeString(argv[2]);
    glMaxUserCount = atol(argv[3]);
    gpszPath = AllocateUnicodeString(argv[4]);

    hr = AddFileShare(
            szParentContainer,
            szFileShareName
            );

    FreeUnicodeString(szFileShareName);
    FreeUnicodeString(szParentContainer);
    FreeUnicodeString(gpszPath);
    FreeUnicodeString(gpszDescription);

    if (FAILED(hr)) {
        printf("AddFileShare failed with error code %x\n", hr);
        return(1);
    }
    printf("Successfully added fileshare \n");
    return(0);
}

int
ExecShareDel(char *szProgName, char *szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szParentContainer = NULL;
    LPWSTR szFileShareName = NULL;

    if (argc  != 2) {
        PrintUsage(szProgName, szAction,
                   "<ADs ParentContainer> <FileShareName>");
        return(1);
    }

    szParentContainer = AllocateUnicodeString(argv[0]);
    szFileShareName = AllocateUnicodeString(argv[1]);

    hr = DeleteFileShare(
            szParentContainer,
            szFileShareName
            );

    FreeUnicodeString(szFileShareName);
    FreeUnicodeString(szParentContainer);

    if (FAILED(hr)) {
        printf("DeleteFileShare failed with error code %x\n", hr);
        return(1);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adsqry\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.1 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  util.cxx
//
//  Contents:  Ansi to Unicode conversions and misc helper functions
//
//----------------------------------------------------------------------------//------------------------------------------------------------------------------

#include "main.hxx"

void
PrintUsage(
    void
    )
{

    printf("\nUsage: adsqry /b <baseObject> /f <search_filter> /a <attrlist> [/p <preference=value>] ");
    printf(" [/u <UserName> <Password>] /d <dialect> \n");
    printf("\n   where:\n" );
    printf("   baseObject     = ADsPath of the base of the search\n");
    printf("   search_filter  = search filter string in LDAP format\n" );
    printf("   attrlist       = list of the attributes to display\n" );
    printf("   dialect is one of \"ldap\", \"sql\", or \"default\"\n");
    printf("   preference could be one of:\n");
    printf("   Asynchronous, AttrTypesOnly, DerefAliases, SizeLimit, TimeLimit, sortOn \n");
    printf("   TimeOut, PageSize, SearchScope, CacheResults, SecureAuth and EncryptPassword\n");
    printf("   value is yes/no for a Boolean and the respective integer for integers\n");
    printf("   list of comma separated attributes for sortOn\n");
    printf("   scope is one of \"Base\", \"OneLevel\", or \"Subtree\"\n");

    printf("\nFor Example: adsqry /b \"LDAP://ntdsdc0/DC=COM/");
    printf("DC=MICROSOFT/DC=NTDEV\"  /f \"(objectClass=Group)\" /a \"ADsPath, name, description\" ");
    printf(" /u \"CN=NTDEV,CN=Users,DC=NTDEV,DC=MICROSOFT,DC=COM,O=INTERNET\" \"NTDEV\" \n");

    printf("\nFor Example: adsqry /b \"LDAP://ntdsdc0/DC=COM/");
    printf("DC=MICROSOFT/DC=NTDEV\"  /f \"objectClass='Group'\" /a \"ADsPath, name, description\" ");
    printf(" /d sql /u \"CN=NTDEV,CN=Users,DC=NTDEV,DC=MICROSOFT,DC=COM,O=INTERNET\" \"NTDEV\" \n");

}


//
// Form the bindings array to specify the way the provider has to put the
// data in consumer's buffers; Create the Accessor from the bindings
//
HRESULT
CreateAccessorHelper(
    IRowset *pIRowset,
    DBORDINAL nAttrs,
    DBCOLUMNINFO *prgColInfo,
    HACCESSOR *phAccessor,
    DBBINDSTATUS *pBindStatus
    )
{

    DBBINDING *prgBindings = NULL;
    HRESULT hr;
    ULONG i;
    IAccessor *pIAccessor = NULL;

    if(!phAccessor || !pBindStatus)
        return(E_INVALIDARG);

    prgBindings = (DBBINDING *) LocalAlloc(
                                   LPTR,
                                   sizeof(DBBINDING) * nAttrs
                                   );
    BAIL_ON_NULL(prgBindings);

    //
    // Set up rest of the attributes
    //
    for (i=0; i < nAttrs; i++) {
        prgBindings[i].iOrdinal = i+1;
        prgBindings[i].wType= prgColInfo[i+1].wType;
        if (prgBindings[i].wType == DBTYPE_DATE || prgBindings[i].wType == DBTYPE_I8)
            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue2);
        else
            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue);
        prgBindings[i].obLength= sizeof(Data)*i + offsetof(Data, obLength);
        prgBindings[i].obStatus= sizeof(Data)*i + offsetof(Data, status);
        prgBindings[i].dwPart= DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS;

        if(prgBindings[i].wType & DBTYPE_BYREF)
            prgBindings[i].dwMemOwner= DBMEMOWNER_PROVIDEROWNED;
        else
            prgBindings[i].dwMemOwner= DBMEMOWNER_CLIENTOWNED;

        prgBindings[i].dwFlags= 0;
    }


    hr= pIRowset->QueryInterface(
           IID_IAccessor,
           (void**) &pIAccessor
           );
    BAIL_ON_FAILURE(hr);

    //
    // With the bindings create the accessor
    //
    hr = pIAccessor->CreateAccessor(
             DBACCESSOR_ROWDATA,
             nAttrs,
             prgBindings,
             0,
             phAccessor,
             pBindStatus
             );

    pIAccessor->Release();
    LOCAL_FREE(prgBindings);

    return(hr);

error:
    LOCAL_FREE(prgBindings);

    return(hr);

}

//
// Print the data depending on its type.
//

void
PrintData(
    Data *prgData,
    DBORDINAL nAttrs,
    DBCOLUMNINFO *prgColInfo
    )
{

    ULONG i, j;
    HRESULT hr;

    for (i=0; i < nAttrs; i++) {

        if(prgData[i].status == DBSTATUS_S_OK) {

            switch(prgColInfo[i+1].wType) {
                case DBTYPE_I4:
                    wprintf(
                        L"%s = %d \n",
                        prgColInfo[i+1].pwszName,
                        (DWORD_PTR) prgData[i].obValue
                        );
                    break;

                case DBTYPE_I8:
                    wprintf(
                        L"%s = %I64d \n",
                        prgColInfo[i+1].pwszName,
                        *((__int64 *) &prgData[i].obValue2)
                        );
                    break;

                case DBTYPE_BOOL:
                    wprintf(
                        L"%s = %s \n",
                        prgColInfo[i+1].pwszName,
                        *((VARIANT_BOOL *) &(prgData[i].obValue)) == VARIANT_TRUE ?
                        L"TRUE" : L"FALSE"
                        );
                    break;

                case DBTYPE_STR | DBTYPE_BYREF:
                    wprintf(
                        L"%s = ",
                        prgColInfo[i+1].pwszName
                        );
                    printf(
                        "%s \n",
                        (char *)prgData[i].obValue
                        );
                    break;

                case DBTYPE_BYTES | DBTYPE_BYREF:
                    wprintf(
                        L"%s = ",
                        prgColInfo[i+1].pwszName
                        );
                    for (j=0; j<prgData[i].obLength; j++) {
                        printf(
                            "%x",
                            ((BYTE *)prgData[i].obValue)[j]
                            );
                    }
                    printf("\n");
                    break;

                case DBTYPE_WSTR | DBTYPE_BYREF:
                    wprintf(
                        L"%s = %s \n",
                        prgColInfo[i+1].pwszName,
                        (WCHAR *) prgData[i].obValue
                        );
                    break;

                case DBTYPE_DATE:
                    SYSTEMTIME UTCTime;
                    hr = VariantTimeToSystemTime(
                                        prgData[i].obValue2,
                                        &UTCTime);
                    BAIL_ON_FAILURE(hr);
                    wprintf(L"%s = %d %d %d",
                            prgColInfo[i+1].pwszName,
                            UTCTime.wYear,
                            UTCTime.wMonth,
                            UTCTime.wDay);
                    break;

                case DBTYPE_VARIANT | DBTYPE_BYREF:
                    wprintf(
                        L"%s = ",
                        prgColInfo[i+1].pwszName
                        );

                    ULONG dwSLBound;
                    ULONG dwSUBound;
                    VARIANT *pVarArray;
                    VARIANT *pVariant;

                    pVarArray = NULL;

                    pVariant = (VARIANT*) prgData[i].obValue;

                    if (pVariant->vt == VT_DISPATCH) {
                        IDispatch *pDispatch = NULL;
                        IADsLargeInteger *pLargeInteger = NULL;
                        LARGE_INTEGER LargeInteger;

                        pDispatch = V_DISPATCH(pVariant);
                        hr = pDispatch->QueryInterface(
                                                 IID_IADsLargeInteger,
                                                 (void **)&pLargeInteger
                                                 );
                        BAIL_ON_FAILURE(hr);

                        hr = pLargeInteger->get_HighPart((LONG*)&LargeInteger.HighPart);
                        BAIL_ON_FAILURE(hr);

                        hr = pLargeInteger->get_LowPart((LONG*)&LargeInteger.LowPart);
                        BAIL_ON_FAILURE(hr);
                        wprintf(
                            L"High:%ld, low:%ld",
                            LargeInteger.HighPart,
                            LargeInteger.LowPart
                            );
                        break;
                    }
                    else {

                        if( !(pVariant->vt  == (VT_ARRAY | VT_VARIANT)))
                            BAIL_ON_FAILURE(hr = E_FAIL);


                        hr = SafeArrayGetLBound(V_ARRAY(pVariant),
                                                1,
                                                (long FAR *) &dwSLBound );
                        BAIL_ON_FAILURE(hr);

                        hr = SafeArrayGetUBound(V_ARRAY(pVariant),
                                                1,
                                                (long FAR *) &dwSUBound );
                        BAIL_ON_FAILURE(hr);

                        hr = SafeArrayAccessData( V_ARRAY(pVariant),
                                                  (void **) &pVarArray );
                        BAIL_ON_FAILURE(hr);

                        for (j=dwSLBound; j<=dwSUBound; j++) {
                            switch((pVarArray[j]).vt) {
                            case VT_DATE:
                                SYSTEMTIME UTCTime;
                                hr = VariantTimeToSystemTime(
                                                    V_DATE(pVarArray+j),
                                                    &UTCTime
                                                    );
                                BAIL_ON_FAILURE(hr);
                                wprintf(L"%d %d %d #",
                                        UTCTime.wYear,
                                        UTCTime.wMonth,
                                        UTCTime.wDay);
                                break;
                            case VT_BSTR:
                                wprintf(
                                    L"%s  #  ",
                                    V_BSTR(pVarArray+j)
                                    );
                                break;
                            case VT_I4:
                                wprintf(
                                    L"%d #  ",
                                    V_I4(pVarArray+j)
                                    );
                                break;
                            case VT_BOOL:
                                wprintf(
                                    L"%s  #  ",
                                    V_BOOL(pVarArray+j) == VARIANT_TRUE ?
                                    L"TRUE" : L"FALSE"
                                    );
                                break;
    #if 0
                            case VT_I8:
                                wprintf(
                                    L"%I64d #  ",
                                    V_I8(pVarArray+j)
                                    );
                                break;
    #endif

                            default:
                                wprintf(
                                    L"Unsupported  #  \n"
                                    );
                            }
                        }
                        printf("\n");

                        SafeArrayUnaccessData( V_ARRAY(pVariant) );

                        break;
                    }

                default:
                    wprintf(
                        L"Unsupported type for attribute %s\n",
                        prgColInfo[i+1].pwszName
                        );
                    break;
            }
        }

    }

    if(nAttrs != 0)
        wprintf(L"\n");

    return;

error:
    wprintf(
        L"Error in Printing data for %s\n",
        prgColInfo[i+1].pwszName
        );
    return;

}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\adscmd\user.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       user.cxx
//
//  Contents:   User operations
//
//  History:    08-06-96  t-danal   created for oledscmd from chgpass, setpass
//
//----------------------------------------------------------------------------

#include "main.hxx"
#include "macro.hxx"
#include "sconv.hxx"

//
// Dispatch Table Defs
//

#include "dispdef.hxx"

DEFEXEC(ExecUserChgPass);
DEFEXEC(ExecUserSetPass);
DEFEXEC(ExecUserGroups);

DEFDISPTABLE(DispTable) = { 
                           {"chgpass", NULL, ExecUserChgPass},
                           {"setpass", NULL, ExecUserSetPass},
                           {"groups", NULL, ExecUserGroups}
                          };

DEFDISPSIZE(nDispTable, DispTable);

//
// Private defines
//

#define MAX_ADS_ENUM      100

//
// Local functions
//

HRESULT
ChangePassword(
    LPWSTR szUserName,
    LPWSTR szOldPassword,
    LPWSTR szNewPassword
    );

HRESULT
SetPassword(
    LPWSTR szUserName,
    LPWSTR szNewPassword
    );

HRESULT
SetPassword(
    LPWSTR szUserName,
    LPWSTR szNewPassword
    );

//
// Local function definitions
//

HRESULT
ChangePassword(
    LPWSTR szUserName,
    LPWSTR szOldPassword,
    LPWSTR szNewPassword
    )
{
    HRESULT hr;
    IADsUser * pADsUser = NULL;

    hr = ADsGetObject(
                szUserName,
                IID_IADsUser,
                (void **)&pADsUser
                );
    BAIL_ON_FAILURE(hr);

    hr = pADsUser->ChangePassword(
                    szOldPassword,
                    szNewPassword
                    );
    pADsUser->Release();
    BAIL_ON_FAILURE(hr);

    printf("Successfully changed password\n");
    return(S_OK);
error:
    printf("Failed to change password\n");
    return(hr);
}

HRESULT
SetPassword(
    LPWSTR szUserName,
    LPWSTR szNewPassword
    )
{
    HRESULT hr;
    IADsUser * pADsUser = NULL;

    hr = ADsGetObject(
                szUserName,
                IID_IADsUser,
                (void **)&pADsUser
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsUser->SetPassword(
                    szNewPassword
                    );
    pADsUser->Release();
    BAIL_ON_FAILURE(hr);

    printf("Successfully set password\n");
    return(S_OK);
error:
    printf("Failed to set password\n");
    return(hr);
}

HRESULT
EnumUserGroups(
    LPWSTR szLocation
    )
{
    HRESULT hr;

    IADsUser* pUser =  NULL;
    IADsMembers* pGroups = NULL;
    IEnumVARIANT* penum = NULL;
    IUnknown * pUnk = NULL;

    DWORD dwObjects = 0, i = 0;
    BOOL  fContinue = TRUE;

    ULONG cElementFetched = 0L;
    VARIANT VariantArray[MAX_ADS_ENUM];
    
    IADs *pObject = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrName = NULL;


    hr = ADsGetObject(
                szLocation,
                IID_IADsUser,
                (void **)&pUser
                );
    BAIL_ON_FAILURE(hr);

    hr = pUser->Groups(&pGroups);
    BAIL_ON_FAILURE(hr);

    hr = pGroups->get__NewEnum(&pUnk);
    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IEnumVARIANT, (void **)&penum);
    BAIL_ON_FAILURE(hr);

    hr = pUser->get_ADsPath(&bstrName);
    BAIL_ON_FAILURE(hr);
    printf("User: %ws\n", bstrName);
    FREE_BSTR(bstrName);

    while (fContinue) {

        hr = ADsEnumerateNext(
                    penum,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE)
            fContinue = FALSE;

        for (i = 0; i < cElementFetched; i++ ) {
            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            BAIL_ON_FAILURE(hr);

            hr = pObject->get_ADsPath(&bstrName) ;
            BAIL_ON_FAILURE(hr);

            printf("\tIs in Group: %ws\n", bstrName);
            FREE_BSTR(bstrName);

            FREE_INTERFACE(pObject);
            FREE_INTERFACE(pDispatch);
        }

        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
        dwObjects += cElementFetched;
    }

    printf("Total Number of Objects enumerated is %d\n", dwObjects);
    hr = S_OK;
error:
    FREE_INTERFACE(pUser);
    FREE_INTERFACE(pGroups);
    FREE_INTERFACE(penum);
    FREE_INTERFACE(pUnk);
    FREE_INTERFACE(pObject);
    FREE_INTERFACE(pDispatch);
    FREE_BSTR(bstrName);
    return(hr);
}

//
// Exec function definitions
//

int
ExecUser(char *szProgName, char *szAction, int argc, char * argv[])
{
    if (!argc) {
        PrintUsage(szProgName, szAction, DispTable, nDispTable);
        return(1);
    }

    char *szPrevActions = szAction;
    szAction = argv[0];
    argc--;
    argv++;

    if (DoHelp(szProgName, 
               szPrevActions, szAction, NULL, 
               DispTable, nDispTable,
               NULL))
        return 0;

    return DispatchExec(DispTable, nDispTable,
                        szProgName,
                        szPrevActions, szAction,
                        argc, argv);
}

int
ExecUserChgPass(char* szProgName, char* szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szUserName = NULL;
    LPWSTR szOldPassword = NULL;
    LPWSTR szNewPassword = NULL;

    if (argc  != 3) {
        PrintUsage(szProgName, szAction, 
                   "<ADsPath> <Old Password> <New Password>");
        return(0);
    }

    szUserName    = AllocateUnicodeString(argv[0]);
    szOldPassword = AllocateUnicodeString(argv[1]);
    szNewPassword = AllocateUnicodeString(argv[2]);

    hr = ChangePassword(
                szUserName,
                szOldPassword,
                szNewPassword
                );

    FreeUnicodeString(szUserName);
    FreeUnicodeString(szOldPassword);
    FreeUnicodeString(szNewPassword);
    if (FAILED(hr)) {
        printf("ChangePassword failed with error code %x\n", hr);
        return(1);
    }
    return(0);
}

ExecUserSetPass(char* szProgName, char* szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szUserName = NULL;
    LPWSTR szNewPassword = NULL;


    if (argc  != 2) {
        PrintUsage(szProgName, szAction, "<ADsPath> <New Password>");
        return(0);
    }

    szUserName = AllocateUnicodeString(argv[0]);
    szNewPassword = AllocateUnicodeString(argv[1]);

    hr = SetPassword(
                szUserName,
                szNewPassword
                );

    FreeUnicodeString(szUserName);
    FreeUnicodeString(szNewPassword);
    if (FAILED(hr)) {
        printf("ChangePassword failed with error code %x\n", hr);
        return 1;
    }
    return 0;
}

ExecUserGroups(char* szProgName, char* szAction, int argc, char * argv[])
{
    HRESULT hr;
    LPWSTR szUserName = NULL;

    if (argc  != 1) {
        PrintUsage(szProgName, szAction, "<ADs User Path>");
        return(0);
    }

    szUserName = AllocateUnicodeString(argv[0]);

    hr = EnumUserGroups(szUserName);

    FreeUnicodeString(szUserName);
    if (FAILED(hr)) {
        printf("Something failed with error code %x\n", hr);
        return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\sqltest\sqltest.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    test1.cxx

Abstract:

    Main program to test the lexer


Author:

    Shankara Shastry [ShankSh]    08-Jul-1996

++*/

#include <stdio.h>
#include "lexer.hxx"
#include "sconv.hxx"
#include "sqltree.hxx"
#include "sqlparse.hxx"

static WCHAR *DisplayName[] = {
             L"TOKEN_ERROR            ",
             L"TOKEN_EQ               ",
             L"TOKEN_STAR             ",
             L"TOKEN_LPARAN           ",
             L"TOKEN_RPARAN           ",
             L"TOKEN_INTEGER_LITERAL  ",
             L"TOKEN_REAL_LITERAL     ",
             L"TOKEN_STRING_LITERAL   ",
             L"TOKEN_USER_DEFINED_NAME",
             L"TOKEN_COMMA            ",
             L"TOKEN_LT               ",
             L"TOKEN_GT               ",
             L"TOKEN_LE               ",
             L"TOKEN_GE               ",
             L"TOKEN_NE               ",
             L"TOKEN_SELECT           ",
             L"TOKEN_ALL              ",
             L"TOKEN_FROM             ",
             L"TOKEN_WHERE            ",
             L"TOKEN_BOOLEAN_LITERAL  ",
             L"TOKEN_AND              ",
             L"TOKEN_OR               ",
             L"TOKEN_NOT              ",
             L"TOKEN_END              ",
     };


DECLARE_INFOLEVEL(ADs)


int
_cdecl main(
    int argc,
    char **argv
    )
{
    HRESULT status = NO_ERROR;
    LPWSTR pszPattern;

    // Check the arguments.
    //

    if ( argc != 3 )
    {
        wprintf( L"\nUsage: lt <pattern> \n" );
        wprintf( L"\n       where: pattern is the string where the tokens have to be recognised\n" );
        return -1;
    }

    if(!(pszPattern = AllocateUnicodeString(argv[2]))) {
        fprintf (stderr, "Not enough memory\n");
        return (-1);
    }

    if (strcmp((LPSTR)argv[1],(LPSTR)"1") == 0) {
        CLexer samplePattern(pszPattern);
        LPWSTR lexeme;
        DWORD token;
    
        wprintf(L"Token\t\tLexeme\n\n");
        samplePattern.GetNextToken(&lexeme, &token);
    
        while (token != TOKEN_END && token != TOKEN_ERROR) {
            wprintf(L"%s\t%s\n", DisplayName[token - TOKEN_START], lexeme);
            samplePattern.GetNextToken(&lexeme, &token);
        }
    
        if(token == TOKEN_ERROR)
            wprintf(L"%s\n", DisplayName[token - TOKEN_START]);
    }
    else {
        LPWSTR szLocation;
        LPWSTR szLDAPQuery;
        LPWSTR szSelect;
        LPWSTR szOrder;
        
        status = SQLParse(
                 pszPattern,
                 &szLocation,
                 &szLDAPQuery,
                 &szSelect,
                 &szOrder);
        if (status != S_OK) {
            wprintf (L"Error in Parsing: %x\n", status);
            exit(-1);
        }

        wprintf(L"%s;%s;%s\n",szLocation, szLDAPQuery, szSelect);
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\search\lextest.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    test1.cxx

Abstract:

    Main program to test the lexer


Author:

    Shankara Shastry [ShankSh]    08-Jul-1996

++*/

#include <stdio.h>
#include "lexer.hxx"
#include "sconv.hxx"

static WCHAR *DisplayName[] = {
             L"TOKEN_ERROR   ",
             L"TOKEN_LPARAN   ",
             L"TOKEN_RPARAN   ",
             L"TOKEN_OR       ",
             L"TOKEN_AND      ",
             L"TOKEN_NOT      ",
             L"TOKEN_APPORX_EQ",
             L"TOKEN_EQ       ",
             L"TOKEN_LE       ",
             L"TOKEN_GE       ",
             L"TOKEN_PRESENT  ",
             L"TOKEN_ATTRTYPE ",
             L"TOKEN_ATTRVAL  ",
             L"TOKEN_END      ",
             L"TOKEN_STAR     "
     };


DECLARE_INFOLEVEL(OleDs)


int
_cdecl main(
    int argc,
    char **argv
    )
{
    HRESULT status = NO_ERROR;
    LPWSTR pszPattern;

    // Check the arguments.
    //

    if ( argc != 2 )
    {
        wprintf( L"\nUsage: lt <pattern> \n" );
        wprintf( L"\n       where: pattern is the string where the tokens have to be recognised\n" );
        return -1;
    }

    if(!(pszPattern = AllocateUnicodeString(argv[1]))) {
        fprintf (stderr, "Not enough memory\n");
        return (-1);
    }

    CLexer samplePattern(pszPattern);
    LPWSTR lexeme;
    DWORD token;

    wprintf(L"Token\t\tLexeme\n\n");
    samplePattern.GetNextToken(&lexeme, &token);

    while (token != TOKEN_END && token != TOKEN_ERROR) {
        wprintf(L"%s\t%s\n", DisplayName[token - TOKEN_START], lexeme);
        samplePattern.GetNextToken(&lexeme, &token);
    }

    if(token == TOKEN_ERROR)
        wprintf(L"%s\n", DisplayName[token - TOKEN_START]);


    FreeUnicodeString(pszPattern);

    return (0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\dssrch\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------

//
// System Includes
//

#define INC_OLE2
#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// Public OleDs includes
//


//
// Private defines
//

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                goto error;   \
        }

#include "activeds.h"
#include "main.hxx"

//
// Globals representing the parameters
//

LPWSTR pszSearchBase, pszSearchFilter, pszAttrNames[10], pszAttrList;
DWORD dwNumberAttributes = (DWORD) -1, dwMaxRows = (DWORD) -1;


//
// Preferences
//
BOOL fASynchronous=FALSE, fDerefAliases=FALSE, fAttrsOnly=FALSE;
DWORD fSizeLimit, fTimeLimit, dwTimeOut, dwPageSize, dwSearchScope;

ADS_SEARCHPREF_INFO pSearchPref[10];
ADS_SORTKEY pSortKey[10];
DWORD dwCurrPref = 0;

LPWSTR pszUserName=NULL, pszPassword=NULL;
DWORD dwAuthFlags=0;
DWORD cErr=0;

char *prefNameLookup[] =
    {
    "ADS_SEARCHPREF_ASYNCHRONOUS",
    "ADS_SEARCHPREF_DEREF_ALIASES",
    "ADS_SEARCHPREF_SIZE_LIMIT",
    "ADS_SEARCHPREF_TIME_LIMIT",
    "ADS_SEARCHPREF_ATTRIBTYPES_ONLY",
    "ADS_SEARCHPREF_SEARCH_SCOPE",
    "ADS_SEARCHPREF_TIMEOUT",
    "ADS_SEARCHPREF_PAGESIZE",
    "ADS_SEARCHPREF_PAGED_TIME_LIMIT",
    "ADS_SEARCHPREF_CHASE_REFERRALS"
    "ADS_SEARCHPREF_CACHE_RESULTS"
    };


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//----------------------------------------------------------------------------
INT __cdecl
main(int argc, char * argv[])
{


    HRESULT hr=S_OK;
    IDirectorySearch *pDSSearch=NULL;
    ADS_SEARCH_HANDLE hSearchHandle=NULL;
    ADS_SEARCH_COLUMN Column;
    DWORD nRows = 0, i;
    LPWSTR pszColumnName = NULL;

#if 0       // Enable if you want to test binary values in filters and send
            // pszBinaryFilter instead of pszSearchFilter in ExecuteSearch

    WCHAR pszBinaryFilter[256] = L"objectSid=";

    LPWSTR pszDest = NULL;

    BYTE column[100] = {
                    0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x15, 0x00,
                    0x00, 0x00, 0x59, 0x51, 0xb8, 0x17, 0x66, 0x72, 0x5d, 0x25,
                    0x64, 0x63, 0x3b, 0x0b, 0x29, 0x99, 0x21, 0x00 };

    hr = ADsEncodeBinaryData (
       column,
       28,
       &pszDest
       );

    wcscat( pszBinaryFilter, pszDest );

    FreeADsMem( pszDest );

#endif


    //
    // Sets the global variables with the parameters
    //
    hr = ProcessArgs(argc, argv);
    BAIL_ON_FAILURE(hr);

    hr = CoInitialize(NULL);

    if (FAILED(hr)) {
        printf("CoInitialize failed\n") ;
        return(1) ;
    }

    hr = ADsOpenObject(
        pszSearchBase,
        pszUserName,
        pszPassword,
        dwAuthFlags,
        IID_IDirectorySearch,
        (void **)&pDSSearch
        );

#if 0 // If you want to go with the default credentials

    hr = ADsGetObject(
                pszSearchBase,
                IID_IDirectorySearch,
                (void **)&pDSSearch
                );

#endif

    BAIL_ON_FAILURE(hr);

    if (dwCurrPref) {
        hr = pDSSearch->SetSearchPreference(
                 pSearchPref,
                 dwCurrPref
                 );
        BAIL_ON_FAILURE(hr);

        if (hr != S_OK) {
            for (i=0; i<dwCurrPref; i++) {
                if (pSearchPref[i].dwStatus != ADS_STATUS_S_OK) {
                    printf(
                        "Error in setting the preference %s: status = %d\n",
                           prefNameLookup[pSearchPref[i].dwSearchPref],
                           pSearchPref[i].dwStatus
                           );
                    cErr++;
                }
            }

        }
    }

    hr = pDSSearch->ExecuteSearch(
             pszSearchFilter,
             pszAttrNames,
             dwNumberAttributes,
             &hSearchHandle
              );
    BAIL_ON_FAILURE(hr);

    hr = pDSSearch->GetNextRow(
             hSearchHandle
             );
    BAIL_ON_FAILURE(hr);

    while (hr != S_ADS_NOMORE_ROWS && nRows < dwMaxRows) {
        nRows++;

        if (dwNumberAttributes == (DWORD) -1) {
            hr = pDSSearch->GetNextColumnName(
                     hSearchHandle,
                     &pszColumnName
                     );
            BAIL_ON_FAILURE(hr);

            while (hr != S_ADS_NOMORE_COLUMNS) {
                hr = pDSSearch->GetColumn(
                         hSearchHandle,
                         pszColumnName,
                         &Column
                         );

                if (FAILED(hr)  && hr != E_ADS_COLUMN_NOT_SET)
                    goto error;

                if (SUCCEEDED(hr)) {
                    PrintColumn(&Column, pszColumnName);
                    pDSSearch->FreeColumn(&Column);
                }

                FreeADsMem(pszColumnName);
                hr = pDSSearch->GetNextColumnName(
                         hSearchHandle,
                         &pszColumnName
                         );
                BAIL_ON_FAILURE(hr);
            }
            printf("\n");
        }
        else {
            for (DWORD i=0; i<dwNumberAttributes; i++) {
                hr = pDSSearch->GetColumn(
                         hSearchHandle,
                         pszAttrNames[i],
                         &Column
                         );

                if (hr == E_ADS_COLUMN_NOT_SET)
                    continue;

                BAIL_ON_FAILURE(hr);

                PrintColumn(&Column, pszAttrNames[i]);

                pDSSearch->FreeColumn(&Column);
            }
        printf("\n");
        }

        hr = pDSSearch->GetNextRow(
                 hSearchHandle
                 );
        BAIL_ON_FAILURE(hr);
    }

    wprintf (L"Total Rows: %d\n", nRows);

    if (cErr) {
        wprintf (L"%d warning(s) ignored", cErr);
    }

    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    FREE_INTERFACE(pDSSearch);

    FREE_UNICODE_STRING(pszSearchBase) ;
    FREE_UNICODE_STRING(pszSearchFilter) ;
    FREE_UNICODE_STRING(pszAttrList) ;

    CoUninitialize();

    return(0) ;

error:

    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    FREE_INTERFACE(pDSSearch);

    FREE_UNICODE_STRING(pszSearchBase) ;
    FREE_UNICODE_STRING(pszSearchFilter) ;
    FREE_UNICODE_STRING(pszAttrList) ;
    FREE_UNICODE_STRING(pszUserName) ;
    FREE_UNICODE_STRING(pszPassword) ;

    wprintf (L"Error! hr = 0x%x\n", hr);
    return(1) ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessArgs
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
ProcessArgs(
    int argc,
    char * argv[]
    )
{
    argc--;
    int currArg = 1;
    LPWSTR pTemp;
    char *pszCurrPref, *pszCurrPrefValue;

    char *pszAttr;
    DWORD nAttr=0;

    while (argc) {
        if (argv[currArg][0] != '/' && argv[currArg][0] != '-')
            BAIL_ON_FAILURE (E_FAIL);
        switch (argv[currArg][1]) {
        case 'b':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchBase = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            break;

        case 'f':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszSearchFilter = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchFilter);
            break;

        case 'a':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszAttrList = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszAttrList);

            dwNumberAttributes = 0;
            pTemp = wcstok(pszAttrList, L",");
            pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
            dwNumberAttributes++;

            while (pTemp) {
                pTemp = wcstok(NULL, L",");
                pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
                dwNumberAttributes++;
            }
            dwNumberAttributes--;
            break;

        case 'u':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszUserName = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszPassword = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszSearchBase);
            break;

        case 't':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue)
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "SecureAuth")) {
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    dwAuthFlags |= ADS_SECURE_AUTHENTICATION;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    dwAuthFlags &= ~ADS_SECURE_AUTHENTICATION;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "UseEncrypt")) {
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    dwAuthFlags |= ADS_USE_ENCRYPTION;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    dwAuthFlags &= ~ADS_USE_ENCRYPTION;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else
                BAIL_ON_FAILURE(E_FAIL);
            break;

        case 'p':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue)
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "asynchronous")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "attrTypesOnly")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "derefAliases")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_DEREF_ALWAYS;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_DEREF_NEVER;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "timeOut")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_TIMEOUT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "timeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_TIME_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "sizeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "PageSize")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "PagedTimeLimit")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[dwCurrPref].vValue.Integer = atoi(pszCurrPrefValue);
            }
            else if (!_stricmp(pszCurrPref, "SearchScope")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                if (!_stricmp(pszCurrPrefValue, "Base" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_BASE;
                else if (!_stricmp(pszCurrPrefValue, "OneLevel" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_ONELEVEL;
                else if (!_stricmp(pszCurrPrefValue, "Subtree" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_SCOPE_SUBTREE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "ChaseReferrals")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_INTEGER;
                if (!_stricmp(pszCurrPrefValue, "always" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_CHASE_REFERRALS_ALWAYS;
                else if (!_stricmp(pszCurrPrefValue, "never" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;
                else if (!_stricmp(pszCurrPrefValue, "external" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
                else if (!_stricmp(pszCurrPrefValue, "subordinate" ))
                    pSearchPref[dwCurrPref].vValue.Integer = ADS_CHASE_REFERRALS_SUBORDINATE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "SortOn")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_SORT_ON;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_PROV_SPECIFIC;

                pszAttr = strtok(pszCurrPrefValue, ",");

                for (nAttr=0; pszAttr && nAttr < 10; nAttr++) {

                    pSortKey[nAttr].pszAttrType = AllocateUnicodeString(pszAttr);
                    pSortKey[nAttr].pszReserved = NULL;
                    pSortKey[nAttr].fReverseorder = 0;

                    pszAttr = strtok(NULL, ",");
                }
                if (nAttr == 0 && nAttr >= 10) {
                    BAIL_ON_FAILURE(E_FAIL);
                }

                pSearchPref[dwCurrPref].vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * nAttr;
                pSearchPref[dwCurrPref].vValue.ProviderSpecific.lpValue = (LPBYTE) pSortKey;
            }
            else if (!_stricmp(pszCurrPref, "cacheResults")) {
                pSearchPref[dwCurrPref].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
                pSearchPref[dwCurrPref].vValue.dwType = ADSTYPE_BOOLEAN;
                if (!_stricmp(pszCurrPrefValue, "yes" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = TRUE;
                else if (!_stricmp(pszCurrPrefValue, "no" ))
                    pSearchPref[dwCurrPref].vValue.Boolean = FALSE;
                else
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else
                BAIL_ON_FAILURE(E_FAIL);

            dwCurrPref++;
            break;

        case 'n':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            dwMaxRows = atoi(argv[currArg]);
            break;

       default:
            BAIL_ON_FAILURE(E_FAIL);
        }

        argc--;
        currArg++;
    }

    //
    // Check for Mandatory arguments;
    //

    if (!pszSearchBase || !pszSearchFilter)
        BAIL_ON_FAILURE(E_FAIL);

    if (dwNumberAttributes == 0) {
        //
        // Get all the attributes
        //
        dwNumberAttributes = (DWORD) -1;
    }

    return (S_OK);
error:

    PrintUsage();
    return E_FAIL;

}


LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\drtutils\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------

//
// ********* System Includes
//

#define UNICODE
#define _UNICODE
#define INC_OLE2
// #define _OLEAUT32_
// #define SECURITY_WIN32


#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// *********  Public ADs includes
//

#include "sconv.hxx"

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\csearch\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.1 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  util.cxx
//
//  Contents:  Ansi to Unicode conversions and misc helper functions
//
//----------------------------------------------------------------------------//------------------------------------------------------------------------------

//
// System Includes
//

#define INC_OLE2
#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// Public OleDs includes
//


//
// Private defines
//

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                goto error;   \
        }

#include "activeds.h"
#include "main.hxx"
#include "adsi.h"

void
PrintUsage(
    void
    )
{

    printf("\nUsage: csearch /b <baseObject> /f <search_filter> /a <attrlist> [/p <preference=value>] ");
    printf(" [/u <UserName> <Password>] [/t <flagName>=<value> \n");
    printf("\n   where:\n" );
    printf("   baseObject     = ADsPath of the base of the search\n");
    printf("   search_filter  = search filter string in LDAP format\n" );
    printf("   attrlist       = list of the attributes to display\n" );
    printf("   preference could be one of:\n");
    printf("   Asynchronous, AttrTypesOnly, DerefAliases, SizeLimit, TimeLimit,\n");
    printf("   TimeOut, PageSize, SearchScope, SecureAuth and EncryptPassword\n");
    printf("   flagName could be one of:\n");
    printf("   SecureAuth or UseEncrypt\n");

    printf("   value is yes/no for a Boolean and the respective integer for integers\n");
    printf("   scope is one of \"Base\", \"OneLevel\", or \"Subtree\"\n");

    printf("\nFor Example: csearch /b \"LDAP://ntdsdc0/O=Internet/DC=COM/");
    printf("DC=MICROSOFT/DC=NTDEV\"  /f \"objectClass=Group\" /a \"ADsPath, name, description\" ");
    printf(" /u \"CN=NTDS,CN=Users,DC=NTDEV,DC=MICROSOFT,DC=COM,O=INTERNET\" \"\" \n");

}


//
// Print the data depending on its type.
//

void
PrintColumn(
    PADS_SEARCH_COLUMN pColumn, 
    LPWSTR pszColumnName
    )
{

    ULONG i, j, k;

    if (!pColumn) {
        return;
    }

    wprintf(
        L"%s = ",
        pszColumnName
        );

    for (k=0; k < pColumn->dwNumValues; k++) {
        if (k > 0) 
            wprintf(L"#  ");

        switch(pColumn->dwADsType) {
        case ADSTYPE_DN_STRING         :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].DNString
                );
            break;
        case ADSTYPE_CASE_EXACT_STRING :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].CaseExactString
                );
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].CaseIgnoreString
                );
            break;
        case ADSTYPE_PRINTABLE_STRING  :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].PrintableString
                );
            break;
        case ADSTYPE_NUMERIC_STRING    :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].NumericString
                );
            break;

        case ADSTYPE_OBJECT_CLASS    :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].ClassName
                );
            break;
    
        case ADSTYPE_BOOLEAN           :
            wprintf(
                L"%s  ",
                (DWORD) pColumn->pADsValues[k].Boolean ? 
                L"TRUE" : L"FALSE"
                );
            break;
    
        case ADSTYPE_INTEGER           :
            wprintf(
                L"%d  ",
                (DWORD) pColumn->pADsValues[k].Integer 
                );
            break;
    
        case ADSTYPE_OCTET_STRING      :
            for (j=0; j<pColumn->pADsValues[k].OctetString.dwLength; j++) {
                printf(
                    "%02x",
                    ((BYTE *)pColumn->pADsValues[k].OctetString.lpValue)[j]
                    );
            }
            break;
    
        case ADSTYPE_LARGE_INTEGER     :
            wprintf(
                L"%I64d  ",
                pColumn->pADsValues[k].LargeInteger 
                );
            break;
    
        case ADSTYPE_UTC_TIME          :
            wprintf(
                L"(date value) "
                );
            break;
        case ADSTYPE_PROV_SPECIFIC     :
            wprintf(
                L"(provider specific value) "
                );
            break;
    
        }
    }

    printf("\n");
}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\dsschema\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.1 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  util.cxx
//
//  Contents:  Ansi to Unicode conversions and misc helper functions
//
//----------------------------------------------------------------------------//------------------------------------------------------------------------------

#include "main.hxx"

static WCHAR *MapSyntaxToStr[]  = {
    L"ADS_INVALID_TYPE      ",
    L"ADS_DN_STRING         ",
    L"ADS_CASE_EXACT_STRING ",
    L"ADS_CASE_IGNORE_STRING",
    L"ADS_PRINTABLE_STRING  ",
    L"ADS_NUMERIC_STRING    ",
    L"ADS_BOOLEAN           ",
    L"ADS_INTEGER           ",
    L"ADS_OCTET_STRING      ",
    L"ADS_UTC_TIME          ",
    L"ADS_LARGE_INTEGER     ",
    L"ADS_PROV_SPECIFIC     ",
    L"ADS_OBJECT_CLASS      "
};


void
PrintUsage(
    void
    )
{
    printf("\nUsage: dsschema /b <TreeName> /a <attrlist> /u <UserName> <Password>");
    printf("   attrlist       = list of the attributes to get the info for \n" );
    printf("\nFor Example: dsschema /b NDS://ntmarst /a  \"ADsPath, cn, description\" ");
    printf(" /u admin.ms ntmarst\n");
}


//
// Print the data depending on its type.
//

void
PrintAttrDefinition(
    PADS_ATTR_DEF pAttrDefiniton, 
    DWORD dwNumAttributes
    )
{

    ULONG i, j, k;

    for (k=0; k < dwNumAttributes; k++) {
        wprintf( L"Attribute %s\n", (DWORD) pAttrDefiniton[k].pszAttrName );
        wprintf (L"Syntax = %s\n", MapSyntaxToStr[pAttrDefiniton[k].dwADsType]);
        wprintf (L"Min Range = %d\n", pAttrDefiniton[k].dwMinRange);
        wprintf (L"Max Range = %d\n", pAttrDefiniton[k].dwMaxRange);
        wprintf (L"MultiValued %s\n", pAttrDefiniton[k].fMultiValued ? L"Yes" : L"No");
        wprintf (L"\n");
    }

    printf("\n");
}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\dsschema\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------

//
// System Includes
//

#define INC_OLE2
#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>

//
// Public OleDs includes
//


//
// Private defines
//

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                goto error;   \
        }

#include "activeds.h"
#include "main.hxx"

// 
// Globals representing the parameters
//

LPWSTR pszTreeName, pszAttrList, pszAttrNames[10];
DWORD dwNumberAttributes = -1;



LPWSTR pszUserName=NULL, pszPassword=NULL;
DWORD dwAuthFlags=0;


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//----------------------------------------------------------------------------
INT _CRTAPI1
main(int argc, char * argv[])
{

    HRESULT hr=S_OK;
    IDirectorySchemaMgmt *pDSSchemaMgmt=NULL;

    DWORD dwAttributesReturned;
    PADS_ATTR_DEF pAttrDefinition;

    //
    // Sets the global variables with the parameters
    //
    hr = ProcessArgs(argc, argv);
    BAIL_ON_FAILURE(hr);

    hr = CoInitialize(NULL);

    if (FAILED(hr)) {
        printf("CoInitialize failed\n") ;
        return(1) ;
    }

    hr = ADsOpenObject(
        pszTreeName,
        pszUserName,
        pszPassword,
        dwAuthFlags,
        IID_IDirectorySchemaMgmt,
        (void **)&pDSSchemaMgmt
        );

    BAIL_ON_FAILURE(hr);

    pDSSchemaMgmt->EnumAttributes(
         pszAttrNames,
         dwNumberAttributes,
         &pAttrDefinition, 
         &dwAttributesReturned
         );
    BAIL_ON_FAILURE(hr);

    PrintAttrDefinition(
        pAttrDefinition, 
        dwAttributesReturned
        );

    if (pAttrDefinition) 
        FreeADsMem(pAttrDefinition);

    FREE_INTERFACE(pDSSchemaMgmt);
    FREE_UNICODE_STRING(pszAttrList) ;

    CoUninitialize();

    return(0) ;

error:

    FREE_INTERFACE(pDSSchemaMgmt);

    FREE_UNICODE_STRING(pszAttrList) ;
    FREE_UNICODE_STRING(pszUserName) ;
    FREE_UNICODE_STRING(pszPassword) ;

    wprintf (L"Error! hr = 0x%x\n", hr);
    return(1) ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessArgs
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT 
ProcessArgs(
    int argc,
    char * argv[]
    )
{
    argc--;
    int currArg = 1;
    LPWSTR pTemp;
    char *pszCurrPref, *pszCurrPrefValue;

    while (argc) {
        if (argv[currArg][0] != '/' && argv[currArg][0] != '-') 
            BAIL_ON_FAILURE (E_FAIL);
        switch (argv[currArg][1]) {
        case 'b':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszTreeName = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszTreeName);
            break;

        case 'a':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE(E_FAIL);

            pszAttrList = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszAttrList);

            if (wcslen(pszAttrList) == 0) 
                break;

            dwNumberAttributes = 0;
            pTemp = wcstok(pszAttrList, L",");
            pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
            dwNumberAttributes++;

            while (pTemp) {
                pTemp = wcstok(NULL, L",");
                pszAttrNames[dwNumberAttributes] = RemoveWhiteSpaces(pTemp);
                dwNumberAttributes++;
            } 
            dwNumberAttributes--;
            break;

        case 'u':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszUserName = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszUserName);
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);
            pszPassword = AllocateUnicodeString(argv[currArg]);
            BAIL_ON_NULL(pszPassword);
            break;

        case 't':
            argc--;
            currArg++;
            if (argc <= 0)
                BAIL_ON_FAILURE (E_FAIL);

            pszCurrPref = strtok(argv[currArg], "=");
            pszCurrPrefValue = strtok(NULL, "=");
            if (!pszCurrPref || !pszCurrPrefValue) 
                BAIL_ON_FAILURE(E_FAIL);

            if (!_stricmp(pszCurrPref, "SecureAuth")) {
                if (!_stricmp(pszCurrPrefValue, "yes" )) 
                    dwAuthFlags |= ADS_SECURE_AUTHENTICATION;
                else if (!_stricmp(pszCurrPrefValue, "no" )) 
                    dwAuthFlags &= ~ADS_SECURE_AUTHENTICATION;
                else 
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else if (!_stricmp(pszCurrPref, "UseEncrypt")) {
                if (!_stricmp(pszCurrPrefValue, "yes" )) 
                    dwAuthFlags |= ADS_USE_ENCRYPTION;
                else if (!_stricmp(pszCurrPrefValue, "no" )) 
                    dwAuthFlags &= ~ADS_USE_ENCRYPTION;
                else 
                    BAIL_ON_FAILURE(E_FAIL);
            }
            else 
                BAIL_ON_FAILURE(E_FAIL);
            break;


        default: 
            BAIL_ON_FAILURE(E_FAIL);
        }

        argc--;
        currArg++;
    }

    if (!pszTreeName) {
        BAIL_ON_FAILURE(E_FAIL);
    }

    if (dwNumberAttributes == 0) {
        //
        // Get all the attributes
        //
        dwNumberAttributes = -1;
    }

    return (S_OK);

error:

    PrintUsage();
    return E_FAIL;
    
}


LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\drt\dssrch\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.1 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  util.cxx
//
//  Contents:  Ansi to Unicode conversions and misc helper functions
//
//----------------------------------------------------------------------------//------------------------------------------------------------------------------

#include "main.hxx"




void
PrintUsage(
    void
    )
{
    printf("\nUsage: dssrch /b <baseObject> /f <search_filter> [/f <attrlist>] [/p <preference>=value>] ");
    printf(" [/u <UserName> <Password>] [/t <flagName>=<value> \n");
    printf("\n   where:\n" );
    printf("   baseObject     = ADsPath of the base of the search\n");
    printf("   search_filter  = search filter string in LDAP format\n" );
    printf("   attrlist       = list of the attributes to display\n" );
    printf("   preference could be one of:\n");
    printf("   Asynchronous, AttrTypesOnly, DerefAliases, SizeLimit, TimeLimit,\n");
    printf("   TimeOut, PageSize, SearchScope, SortOn, CacheResults\n");
    printf("   flagName could be one of:\n");
    printf("   SecureAuth or UseEncrypt\n");
    printf("   value is yes/no for a Boolean and the respective integer for integers\n");
    printf("   scope is one of \"Base\", \"OneLevel\", or \"Subtree\"\n");

    printf("\nFor Example: dssrch /b NDS://ntmarst/ms /f \"(object Class=*)\" ");
    printf(" /a  \"ADsPath, name, description\" /p searchScope=onelevel /p searchscope=onelevel\n\n OR \n");

    printf("\n dssrch /b \"LDAP://O=Internet/DC=COM/");
    printf("DC=MICROSOFT/DC=NTDEV\"  /f \"(objectClass=*)\"  /a \"ADsPath, name, usnchanged\" ");
    printf(" /u \"CN=NTDS,CN=Users,DC=NTDEV,DC=MICROSOFT,DC=COM,O=INTERNET\" \"\" ");
    printf("/p searchScope=onelevel /t secureauth=yes /p SortOn=name /p CacheResults=no\n");

}


//
// Print the data depending on its type.
//

void
PrintColumn(
    PADS_SEARCH_COLUMN pColumn,
    LPWSTR pszColumnName
    )
{

    ULONG i, j, k;

    if (!pColumn) {
        return;
    }

    wprintf(
        L"%s = ",
        pszColumnName
        );

    for (k=0; k < pColumn->dwNumValues; k++) {
        if (k > 0)
            wprintf(L"#  ");

        switch(pColumn->dwADsType) {
        case ADSTYPE_DN_STRING         :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].DNString
                );
            break;
        case ADSTYPE_CASE_EXACT_STRING :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].CaseExactString
                );
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].CaseIgnoreString
                );
            break;
        case ADSTYPE_PRINTABLE_STRING  :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].PrintableString
                );
            break;
        case ADSTYPE_NUMERIC_STRING    :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].NumericString
                );
            break;

        case ADSTYPE_OBJECT_CLASS    :
            wprintf(
                L"%s  ",
                (LPWSTR) pColumn->pADsValues[k].ClassName
                );
            break;

        case ADSTYPE_BOOLEAN           :
            wprintf(
                L"%s  ",
                (DWORD) pColumn->pADsValues[k].Boolean ?
                L"TRUE" : L"FALSE"
                );
            break;

        case ADSTYPE_INTEGER           :
            wprintf(
                L"%d  ",
                (DWORD) pColumn->pADsValues[k].Integer
                );
            break;

        case ADSTYPE_OCTET_STRING      :
            for (j=0; j<pColumn->pADsValues[k].OctetString.dwLength; j++) {
                printf(
                    "%02x",
                    ((BYTE *)pColumn->pADsValues[k].OctetString.lpValue)[j]
                    );
            }
            break;

        case ADSTYPE_LARGE_INTEGER     :
            wprintf(
                L"%I64d  ",
                pColumn->pADsValues[k].LargeInteger
                );
            break;

        case ADSTYPE_UTC_TIME          :
            // convert system time to printable time
            {
                SYSTEMTIME *pst = &(pColumn->pADsValues[k].UTCTime);
                // use am/pm semantics, match output from US version of dir /4
                WORD wHour = (pst->wHour > (WORD)12) ?
                    (pst->wHour - (WORD)12) :
                    pst->wHour;

                wprintf(
                    L"%02d/%02d/%04d  %02d:%02d%c  ",
                    pst->wMonth, pst->wDay, pst->wYear,
                    wHour, pst->wMinute, (wHour == pst->wHour) ? L'a' : L'p'
                );
            }
            break;
        case ADSTYPE_PROV_SPECIFIC     :
            wprintf(
                L"(provider specific value) "
                );
            break;

        }
    }

    printf("\n");
}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//              in commnot
//
//  History:    28-Oct-92   IsaacHe     Created
//
//----------------------------------------------------------------------------

#ifndef _CAIHEAP_H_
#define _CAIHEAP_H_

//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26                 // depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
        DWORD   sum;            // checksum of stack backtrace
        void *fTrace[ DEPTHTRACE ];     // stack backtrace
        DWORD   count;          // # of un-freed allocs from this place
        size_t  bytes;          // # of un-freed bytes from this place
        struct AllocArena *paa; // points back to the beginning...
        struct {
                DWORD   count;  // # of allocs from this place
                size_t  bytes;  // # of bytes from this place
        } total;
        union {
                struct HeapAllocRec *next; // next bucket in the hash list
                void *ImageBase;        // base addr of containing module
        } u;
};

struct AllocArena {

        char Signature [ sizeof(HEAPSIG) ];
        char comment[ 32 ];
        CRITICAL_SECTION csExclusive;   // ensures single writer

        struct {
                int KeepStackTrace:1;   // are stack records being kept?
        } flags;

        ULONG cAllocs;                  // # of non zero Alloc calls
        ULONG czAllocs;                 // # of Alloc calls w/zero count
        ULONG cFrees;                   // # of Free calls
        ULONG cReAllocs;                // # of realloc calls
        ULONG cMissed;                  // # of missed stack backtraces
        ULONG cRecords;                 // index of next free AllocRec entry
        ULONG cBytesNow;                // # of bytes currently allocated
        ULONG cBytesTotal;              // # of bytes ever allocated
        ULONG cTotalRecords;            // Total # of AllocRecs
        ULONG cPaths;                   // # of distinct allocation paths

        struct {
                ULONG total[ 32 ];      // total number of allocations
                ULONG now[ 32 ];        // current # of simul allocs
                ULONG simul[ 32 ];      // highest # of simul allocs
        } Histogram;

        struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
        struct HeapAllocRec FAR *p;
        size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
                        size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );

#endif  // ifndef _CAIHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\dswarn.h ===
#include <warning.h>

#pragma warning (disable: 4101 4201 4100 4244 4245 4706 4786 4267 4701 4115 4509 4214 4057 4127 4189 4702)

#pragma warning (disable:  4514 4512 4663)

/**************************************************************************

DESCRIPTION OF WARNINGS THAT ARE DISABLED

4101  unreferenced local variable

*4201  nonstandard extension: nameless struct or union

*4214  non standard extension: bit field types other than int

*4115  named type definition in paranthesis -- does not like THSTATE

*4127  conditional expression is a constant

4100  ureferenced formal parameter

*4189  local variable is initialized but not referenced 

*4057 slightly different base types -- char * and unsigned char *

4244 conversion from into to char --loss of data -- I saw a few of these and disabled in an effort to get the code to compile -- need further investigation.

4245 conversion from long to unsigned long -- signed/unsigned mismatch

*4509 non standard extension used -- uses SEH and has destructor

4706 assignment within a conditional expression

4702  *unreacheable code

*4701  var used before initializing

4786  identifier truncated to 255 chars in debug information

4267  Signal to noise ratio of this warning is pretty poor -- too many 
      '=' conversion from size_t to unsigned long, possible loss of data
      The problem is that size_t in 64 bit is defined as a 64 bit int,
      while ulong is still a 32 bit int. In practice most places this is
      used -- e.g sizeof operator, or string len etc the value will fit 
      in a 32 bit ULONG

4514 unreferenced inline function has been removed

4512 assignment operator could not be generated

4663 C++ language change: to explicitly specialize class template 'identifier' use the following syntax

VALID WARNINGS ENCOUNTERED 

( 4267, 4701, 4702 and 4706 can also be included in
this list if desired )

4306 TypeCast -- conversion from unsigned short to unsigned short *

4305 Typecase -- truncation from unsigned short * to unsigned short

4312 TypeCase -- Conversion from unsigned long to void * __ptr64 of greater size



****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPCWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR,
   ADSTYPE_UNKNOWN,
   ADSTYPE_DN_WITH_BINARY,
   ADSTYPE_DN_WITH_STRING
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

//
// ADSTYPE_UNKNOWN was added to the end to be save and not break anyone.
// If further types are added, this will be in the middle which is not
// the best position but nonethesless functional.
//


typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;

typedef struct
{
    DWORD dwLength;
    LPBYTE lpBinaryValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_BINARY, *PADS_DN_WITH_BINARY;

typedef struct
{
    LPWSTR pszStringValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_STRING, *PADS_DN_WITH_STRING;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
      PADS_DN_WITH_BINARY               pDNWithBinary;
      PADS_DN_WITH_STRING               pDNWithString;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;

typedef enum {
    ADS_SECURE_AUTHENTICATION = 0x00000001,
    ADS_USE_ENCRYPTION        = 0x00000002,
    ADS_USE_SSL               = 0x00000002,
    ADS_READONLY_SERVER       = 0x00000004,
    ADS_PROMPT_CREDENTIALS    = 0x00000008,
    ADS_NO_AUTHENTICATION     = 0x00000010,
    ADS_FAST_BIND             = 0x00000020,
    ADS_USE_SIGNING           = 0x00000040,
    ADS_USE_SEALING           = 0x00000080,
    ADS_USE_DELEGATION        = 0x00000100,
    ADS_SERVER_BIND           = 0x00000200,
    ADS_AUTH_RESERVED         = 0x80000000
} ADS_AUTHENTICATION_ENUM;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;

// Some more useful enums moved from other places
typedef enum {

    ADSIPROP_ASYNCHRONOUS       =   0x00000000,
    ADSIPROP_DEREF_ALIASES      =   0x00000001,
    ADSIPROP_SIZE_LIMIT         =   0x00000002,
    ADSIPROP_TIME_LIMIT         =   0x00000003,
    ADSIPROP_ATTRIBTYPES_ONLY   =   0x00000004,
    ADSIPROP_SEARCH_SCOPE       =   0x00000005,
    ADSIPROP_TIMEOUT            =   0x00000006,
    ADSIPROP_PAGESIZE           =   0x00000007,
    ADSIPROP_PAGED_TIME_LIMIT   =   0x00000008,
    ADSIPROP_CHASE_REFERRALS    =   0x00000009,
    ADSIPROP_SORT_ON            =   0x0000000a,
    ADSIPROP_CACHE_RESULTS      =   0x0000000b,
    ADSIPROP_ADSIFLAG           =   0x0000000c

} ADS_PREFERENCES_ENUM;


typedef enum {

    ADSI_DIALECT_LDAP     =  0x00000000,
    ADSI_DIALECT_SQL      =  0x00000001

} ADSI_DIALECT_ENUM;

//
// Values for ChaseReferral Option.
typedef enum {

    ADS_CHASE_REFERRALS_NEVER         =  0x00000000,
    ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020,
    ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040,
    ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL)
} ADS_CHASE_REFERRALS_ENUM;

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS,
   ADS_SEARCHPREF_DIRSYNC,
   ADS_SEARCHPREF_TOMBSTONE,
   ADS_SEARCHPREF_VLV,
   ADS_SEARCHPREF_ATTRIBUTE_QUERY,
   ADS_SEARCHPREF_SECURITY_MASK

} ADS_SEARCHPREF_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


const LPWSTR ADS_DIRSYNC_COOKIE=L"fc8cb04d-311d-406c-8cb9-1ae8b843b418";
const LPWSTR ADS_VLV_RESPONSE  =L"fc8cb04d-311d-406c-8cb9-1ae8b843b419";

typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;


typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_class_def {
    LPWSTR pszClassName;
    DWORD  dwMandatoryAttrs;
    LPWSTR *ppszMandatoryAttrs;
    DWORD optionalAttrs;
    LPWSTR **ppszOptionalAttrs;
    DWORD dwNamingAttrs;
    LPWSTR **ppszNamingAttrs;
    DWORD dwSuperClasses;
    LPWSTR **ppszSuperClasses;
    BOOL fIsContainer;
}ADS_CLASS_DEF, *PADS_CLASS_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


typedef struct _ads_vlv {

    DWORD dwBeforeCount;
    DWORD dwAfterCount;
    DWORD dwOffset;
    DWORD dwContentCount;
    LPWSTR pszTarget;
    DWORD  dwContextIDLength;
    LPBYTE lpContextID;
} ADS_VLV, *PADS_VLV;

//
// Valid dispids for extension.
//
// - Max 24 bits.
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed.
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate
//

const int ADS_EXT_INITCREDENTIALS       = 1 ;
const int ADS_EXT_INITIALIZE_COMPLETE   = 2 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

VOID
ADsFreeThreadErrorRecords(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\umi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __umi_h__
#define __umi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUmiPropList_FWD_DEFINED__
#define __IUmiPropList_FWD_DEFINED__
typedef interface IUmiPropList IUmiPropList;
#endif 	/* __IUmiPropList_FWD_DEFINED__ */


#ifndef __IUmiBaseObject_FWD_DEFINED__
#define __IUmiBaseObject_FWD_DEFINED__
typedef interface IUmiBaseObject IUmiBaseObject;
#endif 	/* __IUmiBaseObject_FWD_DEFINED__ */


#ifndef __IUmiObject_FWD_DEFINED__
#define __IUmiObject_FWD_DEFINED__
typedef interface IUmiObject IUmiObject;
#endif 	/* __IUmiObject_FWD_DEFINED__ */


#ifndef __IUmiConnection_FWD_DEFINED__
#define __IUmiConnection_FWD_DEFINED__
typedef interface IUmiConnection IUmiConnection;
#endif 	/* __IUmiConnection_FWD_DEFINED__ */


#ifndef __IUmiContainer_FWD_DEFINED__
#define __IUmiContainer_FWD_DEFINED__
typedef interface IUmiContainer IUmiContainer;
#endif 	/* __IUmiContainer_FWD_DEFINED__ */


#ifndef __IUmiCursor_FWD_DEFINED__
#define __IUmiCursor_FWD_DEFINED__
typedef interface IUmiCursor IUmiCursor;
#endif 	/* __IUmiCursor_FWD_DEFINED__ */


#ifndef __IUmiObjectSink_FWD_DEFINED__
#define __IUmiObjectSink_FWD_DEFINED__
typedef interface IUmiObjectSink IUmiObjectSink;
#endif 	/* __IUmiObjectSink_FWD_DEFINED__ */


#ifndef __IUmiURLKeyList_FWD_DEFINED__
#define __IUmiURLKeyList_FWD_DEFINED__
typedef interface IUmiURLKeyList IUmiURLKeyList;
#endif 	/* __IUmiURLKeyList_FWD_DEFINED__ */


#ifndef __IUmiURL_FWD_DEFINED__
#define __IUmiURL_FWD_DEFINED__
typedef interface IUmiURL IUmiURL;
#endif 	/* __IUmiURL_FWD_DEFINED__ */


#ifndef __IUmiQuery_FWD_DEFINED__
#define __IUmiQuery_FWD_DEFINED__
typedef interface IUmiQuery IUmiQuery;
#endif 	/* __IUmiQuery_FWD_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_FWD_DEFINED__
#define __IUmiCustomInterfaceFactory_FWD_DEFINED__
typedef interface IUmiCustomInterfaceFactory IUmiCustomInterfaceFactory;
#endif 	/* __IUmiCustomInterfaceFactory_FWD_DEFINED__ */


#ifndef __UmiDefURL_FWD_DEFINED__
#define __UmiDefURL_FWD_DEFINED__

#ifdef __cplusplus
typedef class UmiDefURL UmiDefURL;
#else
typedef struct UmiDefURL UmiDefURL;
#endif /* __cplusplus */

#endif 	/* __UmiDefURL_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __UMI_V6_LIBRARY_DEFINED__
#define __UMI_V6_LIBRARY_DEFINED__

/* library UMI_V6 */
/* [uuid] */ 












typedef 
enum tag_UMI_TYPE_ENUMERATION
    {	UMI_TYPE_NULL	= 0,
	UMI_TYPE_I1	= 1,
	UMI_TYPE_I2	= 2,
	UMI_TYPE_I4	= 3,
	UMI_TYPE_I8	= 4,
	UMI_TYPE_UI1	= 5,
	UMI_TYPE_UI2	= 6,
	UMI_TYPE_UI4	= 7,
	UMI_TYPE_UI8	= 8,
	UMI_TYPE_R4	= 9,
	UMI_TYPE_R8	= 10,
	UMI_TYPE_FILETIME	= 12,
	UMI_TYPE_SYSTEMTIME	= 13,
	UMI_TYPE_BOOL	= 14,
	UMI_TYPE_IDISPATCH	= 15,
	UMI_TYPE_IUNKNOWN	= 16,
	UMI_TYPE_VARIANT	= 17,
	UMI_TYPE_LPWSTR	= 20,
	UMI_TYPE_OCTETSTRING	= 21,
	UMI_TYPE_UMIARRAY	= 22,
	UMI_TYPE_DISCOVERY	= 23,
	UMI_TYPE_UNDEFINED	= 24,
	UMI_TYPE_DEFAULT	= 25,
	UMI_TYPE_ARRAY_FLAG	= 0x2000
    } 	UMI_TYPE_ENUMERATION;

typedef ULONG UMI_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0001
    {	UMI_GENUS_CLASS	= 1,
	UMI_GENUS_INSTANCE	= 2
    } 	UMI_GENUS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0002
    {	UMI_DONT_COMMIT_SECURITY_DESCRIPTOR	= 0x10
    } 	UMI_COMMIT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0003
    {	UMI_FLAG_GETPROPS_ALL	= 1,
	UMI_FLAG_GETPROPS_SCHEMA	= 0x2,
	UMI_MASK_GETPROPS_PROP	= 0xff,
	UMI_FLAG_GETPROPS_NAMES	= 0x100,
	UMI_MASK_GETPROPS_EXT	= 0x100
    } 	UMI_GETPROPS_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0004
    {	UMI_FLAG_OWNER_SECURITY_INFORMATION	= 0x1,
	UMI_FLAG_GROUP_SECURITY_INFORMATION	= 0x2,
	UMI_FLAG_DACL_SECURITY_INFORMATION	= 0x4,
	UMI_FLAG_SACL_SECURITY_INFORMATION	= 0x8,
	UMI_SECURITY_MASK	= 0xf,
	UMI_FLAG_PROVIDER_CACHE	= 0x10,
	UMI_FLAG_PROPERTY_ORIGIN	= 0x20
    } 	UMI_GET_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0005
    {	UMI_FLAG_REFRESH_ALL	= 0,
	UMI_FLAG_REFRESH_PARTIAL	= 1
    } 	UMI_REFRESH_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0006
    {	UMI_OPERATION_NONE	= 0,
	UMI_OPERATION_APPEND	= 1,
	UMI_OPERATION_UPDATE	= 2,
	UMI_OPERATION_EMPTY	= 3,
	UMI_OPERATION_INSERT_AT	= 4,
	UMI_OPERATION_REMOVE_AT	= 5,
	UMI_OPERATION_DELETE_AT	= 6,
	UMI_OPERATION_DELETE_FIRST_MATCH	= 7,
	UMI_OPERATION_DELETE_ALL_MATCHES	= 8,
	UMI_OPERATION_RESTORE_DEFAULT	= 9
    } 	UMI_PROP_INSTRUCTION;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0007
    {	UMI_OPERATION_INSTANCE	= 0x1000,
	UMI_OPERATION_CLASS	= 0x2000
    } 	UMI_OPERATION_PATH;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0008
    {	UMIPATH_CREATE_AS_NATIVE	= 0x8000,
	UMIPATH_CREATE_AS_EITHER	= 0x4000,
	UMIPATH_CREATE_ACCEPT_RELATIVE	= 0x4
    } 	tag_UMI_PATH_CREATE_FLAG;

typedef 
enum tag_WMI_PATH_STATUS_FLAG
    {	UMIPATH_INFO_NATIVE_STRING	= 0x1,
	UMIPATH_INFO_RELATIVE_PATH	= 0x2,
	UMIPATH_INFO_INSTANCE_PATH	= 0x4,
	UMIPATH_INFO_CLASS_PATH	= 0x8,
	UMIPATH_INFO_SINGLETON_PATH	= 0x10
    } 	tag_UMI_PATH_STATUS_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0009
    {	UMI_S_NO_ERROR	= 0,
	UMI_E_CONNECTION_FAILURE	= 0x80041001,
	UMI_E_TIMED_OUT	= 0x80041002,
	UMI_E_TYPE_MISMATCH	= 0x80041003,
	UMI_E_NOT_FOUND	= 0x80041004,
	UMI_E_INVALID_FLAGS	= 0x80041005,
	UMI_E_UNSUPPORTED_FLAGS	= 0x80041006,
	UMI_E_SYNCHRONIZATION_REQUIRED	= 0x80041007,
	UMI_E_UNSUPPORTED_OPERATION	= 0x80041008,
	UMI_E_TRANSACTION_FAILURE	= 0x80041009,
	UMI_E_UNBOUND_OBJECT	= 0x8004100a
    } 	UMI_STATUS;

typedef struct tag_UMI_OCTET_STRING
    {
    ULONG uLength;
    byte __RPC_FAR *lpValue;
    } 	UMI_OCTET_STRING;

typedef struct tag_UMI_OCTET_STRING __RPC_FAR *PUMI_OCTET_STRING;

typedef struct tag_UMI_COM_OBJECT
    {
    IID __RPC_FAR *priid;
    LPVOID pInterface;
    } 	UMI_COM_OBJECT;

typedef struct tag_UMI_COM_OBJECT __RPC_FAR *PUMI_COM_OBJECT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_umi_0000_0010
    {
    CHAR cValue[ 1 ];
    UCHAR ucValue[ 1 ];
    WCHAR wcValue[ 1 ];
    WORD wValue[ 1 ];
    DWORD dwValue[ 1 ];
    LONG lValue[ 1 ];
    ULONG uValue[ 1 ];
    BYTE byteValue[ 1 ];
    BOOL bValue[ 1 ];
    LPWSTR pszStrValue[ 1 ];
    FILETIME fileTimeValue[ 1 ];
    SYSTEMTIME sysTimeValue[ 1 ];
    double dblValue[ 1 ];
    unsigned __int64 uValue64[ 1 ];
    __int64 nValue64[ 1 ];
    UMI_OCTET_STRING octetStr[ 1 ];
    UMI_COM_OBJECT comObject[ 1 ];
    } 	UMI_VALUE;

typedef union __MIDL___MIDL_itf_umi_0000_0010 __RPC_FAR *PUMI_VALUE;

typedef /* [public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0011
    {
    UMI_TYPE uType;
    ULONG uCount;
    ULONG uOperationType;
    LPWSTR pszPropertyName;
    UMI_VALUE __RPC_FAR *pUmiValue;
    } 	UMI_PROPERTY;

typedef struct __MIDL___MIDL_itf_umi_0000_0011 __RPC_FAR *PUMI_PROPERTY;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0012
    {
    ULONG uCount;
    UMI_PROPERTY __RPC_FAR *pPropArray;
    } 	UMI_PROPERTY_VALUES;

typedef struct __MIDL___MIDL_itf_umi_0000_0012 __RPC_FAR *PUMI_PROPERTY_VALUES;


EXTERN_C const IID LIBID_UMI_V6;

#ifndef __IUmiPropList_INTERFACE_DEFINED__
#define __IUmiPropList_INTERFACE_DEFINED__

/* interface IUmiPropList */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiPropList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7b-d9db-11d3-a11f-00105a1f515a")
    IUmiPropList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            ULONG uReserved,
            LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiPropListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiPropList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiPropList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiPropList __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        END_INTERFACE
    } IUmiPropListVtbl;

    interface IUmiPropList
    {
        CONST_VTBL struct IUmiPropListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiPropList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiPropList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiPropList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiPropList_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiPropList_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiPropList_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiPropList_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiPropList_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiPropList_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiPropList_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiPropList_Put_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Get_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAt_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [out] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_GetAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAs_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCoercionType,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_GetAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_FreeMemory_Proxy( 
    IUmiPropList __RPC_FAR * This,
    ULONG uReserved,
    LPVOID pMem);


void __RPC_STUB IUmiPropList_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Delete_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiPropList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_GetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_PutProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutFrom_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [in] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_PutFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiPropList_INTERFACE_DEFINED__ */


#ifndef __IUmiBaseObject_INTERFACE_DEFINED__
#define __IUmiBaseObject_INTERFACE_DEFINED__

/* interface IUmiBaseObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7c-d9db-11d3-a11f-00105a1f515a")
    IUmiBaseObject : public IUmiPropList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiBaseObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        END_INTERFACE
    } IUmiBaseObjectVtbl;

    interface IUmiBaseObject
    {
        CONST_VTBL struct IUmiBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiBaseObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiBaseObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiBaseObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiBaseObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiBaseObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiBaseObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiBaseObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiBaseObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiBaseObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetLastStatus_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);


void __RPC_STUB IUmiBaseObject_GetLastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetInterfacePropList_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);


void __RPC_STUB IUmiBaseObject_GetInterfacePropList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiBaseObject_INTERFACE_DEFINED__ */


#ifndef __IUmiObject_INTERFACE_DEFINED__
#define __IUmiObject_INTERFACE_DEFINED__

/* interface IUmiObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee23-64a4-11d3-a0da-00105a1f515a")
    IUmiObject : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IUmiObjectVtbl;

    interface IUmiObject
    {
        CONST_VTBL struct IUmiObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiObject_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiObject_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiObject_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiObject_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObject_Clone_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_CopyTo_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Refresh_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uNameCount,
    /* [in] */ LPWSTR __RPC_FAR *pszNames);


void __RPC_STUB IUmiObject_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Commit_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiObject_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObject_INTERFACE_DEFINED__ */


#ifndef __IUmiConnection_INTERFACE_DEFINED__
#define __IUmiConnection_INTERFACE_DEFINED__

/* interface IUmiConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee20-64a4-11d3-a0da-00105a1f515a")
    IUmiConnection : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiConnection __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        END_INTERFACE
    } IUmiConnectionVtbl;

    interface IUmiConnection
    {
        CONST_VTBL struct IUmiConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiConnection_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiConnection_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiConnection_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiConnection_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiConnection_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiConnection_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiConnection_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiConnection_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiConnection_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiConnection_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiConnection_Open_Proxy( 
    IUmiConnection __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiConnection_INTERFACE_DEFINED__ */


#ifndef __IUmiContainer_INTERFACE_DEFINED__
#define __IUmiContainer_INTERFACE_DEFINED__

/* interface IUmiContainer */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee21-64a4-11d3-a0da-00105a1f515a")
    IUmiContainer : public IUmiObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiContainer __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEnum )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);
        
        END_INTERFACE
    } IUmiContainerVtbl;

    interface IUmiContainer
    {
        CONST_VTBL struct IUmiContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiContainer_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiContainer_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiContainer_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiContainer_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiContainer_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiContainer_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiContainer_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiContainer_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiContainer_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiContainer_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiContainer_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiContainer_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiContainer_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)


#define IUmiContainer_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#define IUmiContainer_PutObject(This,uFlags,TargetIID,pObj)	\
    (This)->lpVtbl -> PutObject(This,uFlags,TargetIID,pObj)

#define IUmiContainer_DeleteObject(This,pURL,uFlags)	\
    (This)->lpVtbl -> DeleteObject(This,pURL,uFlags)

#define IUmiContainer_Create(This,pURL,uFlags,pNewObj)	\
    (This)->lpVtbl -> Create(This,pURL,uFlags,pNewObj)

#define IUmiContainer_Move(This,uFlags,pOldURL,pNewURL)	\
    (This)->lpVtbl -> Move(This,uFlags,pOldURL,pNewURL)

#define IUmiContainer_CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)	\
    (This)->lpVtbl -> CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)

#define IUmiContainer_ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)	\
    (This)->lpVtbl -> ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiContainer_Open_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiContainer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_PutObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out][in] */ void __RPC_FAR *pObj);


void __RPC_STUB IUmiContainer_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_DeleteObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [optional][in] */ ULONG uFlags);


void __RPC_STUB IUmiContainer_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Create_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);


void __RPC_STUB IUmiContainer_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Move_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pOldURL,
    /* [in] */ IUmiURL __RPC_FAR *pNewURL);


void __RPC_STUB IUmiContainer_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_CreateEnum_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);


void __RPC_STUB IUmiContainer_CreateEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_ExecQuery_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiQuery __RPC_FAR *pQuery,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IUmiContainer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiContainer_INTERFACE_DEFINED__ */


#ifndef __IUmiCursor_INTERFACE_DEFINED__
#define __IUmiCursor_INTERFACE_DEFINED__

/* interface IUmiCursor */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCursor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee26-64a4-11d3-a0da-00105a1f515a")
    IUmiCursor : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIID( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG __RPC_FAR *puNumObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Previous( 
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCursorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiCursor __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIID )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IUmiCursor __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puNumObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj);
        
        END_INTERFACE
    } IUmiCursorVtbl;

    interface IUmiCursor
    {
        CONST_VTBL struct IUmiCursorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCursor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCursor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCursor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCursor_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiCursor_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiCursor_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiCursor_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiCursor_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiCursor_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiCursor_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiCursor_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiCursor_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiCursor_SetIID(This,riid)	\
    (This)->lpVtbl -> SetIID(This,riid)

#define IUmiCursor_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IUmiCursor_Next(This,uNumRequested,puNumReturned,pObjects)	\
    (This)->lpVtbl -> Next(This,uNumRequested,puNumReturned,pObjects)

#define IUmiCursor_Count(This,puNumObjects)	\
    (This)->lpVtbl -> Count(This,puNumObjects)

#define IUmiCursor_Previous(This,uFlags,pObj)	\
    (This)->lpVtbl -> Previous(This,uFlags,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCursor_SetIID_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB IUmiCursor_SetIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Reset_Proxy( 
    IUmiCursor __RPC_FAR * This);


void __RPC_STUB IUmiCursor_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Next_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uNumRequested,
    /* [out] */ ULONG __RPC_FAR *puNumReturned,
    /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);


void __RPC_STUB IUmiCursor_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Count_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puNumObjects);


void __RPC_STUB IUmiCursor_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Previous_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pObj);


void __RPC_STUB IUmiCursor_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCursor_INTERFACE_DEFINED__ */


#ifndef __IUmiObjectSink_INTERFACE_DEFINED__
#define __IUmiObjectSink_INTERFACE_DEFINED__

/* interface IUmiObjectSink */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee24-64a4-11d3-a0da-00105a1f515a")
    IUmiObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResult )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        END_INTERFACE
    } IUmiObjectSinkVtbl;

    interface IUmiObjectSink
    {
        CONST_VTBL struct IUmiObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObjectSink_Put(This,lNumObjects,ppObjects)	\
    (This)->lpVtbl -> Put(This,lNumObjects,ppObjects)

#define IUmiObjectSink_SetResult(This,hResStatus,uFlags,pObject)	\
    (This)->lpVtbl -> SetResult(This,hResStatus,uFlags,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObjectSink_Put_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ LONG lNumObjects,
    /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);


void __RPC_STUB IUmiObjectSink_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObjectSink_SetResult_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ HRESULT hResStatus,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IUmiObjectSink_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObjectSink_INTERFACE_DEFINED__ */


#ifndef __IUmiURLKeyList_INTERFACE_DEFINED__
#define __IUmiURLKeyList_INTERFACE_DEFINED__

/* interface IUmiURLKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IUmiURLKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cf779c98-4739-4fd4-a415-da937a599f2f")
    IUmiURLKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeysInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeysInfo )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        END_INTERFACE
    } IUmiURLKeyListVtbl;

    interface IUmiURLKeyList
    {
        CONST_VTBL struct IUmiURLKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURLKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURLKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURLKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURLKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IUmiURLKeyList_SetKey(This,pszName,pszValue)	\
    (This)->lpVtbl -> SetKey(This,pszName,pszValue)

#define IUmiURLKeyList_GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)

#define IUmiURLKeyList_RemoveKey(This,pszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,pszName,uFlags)

#define IUmiURLKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IUmiURLKeyList_GetKeysInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetKeysInfo(This,uRequestedInfo,puResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetCount_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IUmiURLKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_SetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [string][in] */ LPCWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
    /* [in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
    /* [in] */ LPWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveAllKeys_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKeysInfo_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURLKeyList_GetKeysInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURLKeyList_INTERFACE_DEFINED__ */


#ifndef __IUmiURL_INTERFACE_DEFINED__
#define __IUmiURL_INTERFACE_DEFINED__

/* interface IUmiURL */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7d-d9db-11d3-a11f-00105a1f515a")
    IUmiURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocator( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveComponent( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllComponents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLeafName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLeafPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathInfo )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentCount )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentFromText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentAsText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllComponents )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IUmiURLVtbl;

    interface IUmiURL
    {
        CONST_VTBL struct IUmiURLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURL_Set(This,lFlags,pszText)	\
    (This)->lpVtbl -> Set(This,lFlags,pszText)

#define IUmiURL_Get(This,lFlags,puBufSize,pszDest)	\
    (This)->lpVtbl -> Get(This,lFlags,puBufSize,pszDest)

#define IUmiURL_GetPathInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetPathInfo(This,uRequestedInfo,puResponse)

#define IUmiURL_SetLocator(This,Name)	\
    (This)->lpVtbl -> SetLocator(This,Name)

#define IUmiURL_GetLocator(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetLocator(This,puNameBufLength,pName)

#define IUmiURL_SetRootNamespace(This,Name)	\
    (This)->lpVtbl -> SetRootNamespace(This,Name)

#define IUmiURL_GetRootNamespace(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetRootNamespace(This,puNameBufLength,pName)

#define IUmiURL_GetComponentCount(This,puCount)	\
    (This)->lpVtbl -> GetComponentCount(This,puCount)

#define IUmiURL_SetComponent(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetComponent(This,uIndex,pszClass)

#define IUmiURL_SetComponentFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetComponentFromText(This,uIndex,pszText)

#define IUmiURL_GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IUmiURL_GetComponentAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetComponentAsText(This,uIndex,puTextBufSize,pszText)

#define IUmiURL_RemoveComponent(This,uIndex)	\
    (This)->lpVtbl -> RemoveComponent(This,uIndex)

#define IUmiURL_RemoveAllComponents(This)	\
    (This)->lpVtbl -> RemoveAllComponents(This)

#define IUmiURL_SetLeafName(This,Name)	\
    (This)->lpVtbl -> SetLeafName(This,Name)

#define IUmiURL_GetLeafName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetLeafName(This,puBuffLength,pszName)

#define IUmiURL_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IUmiURL_CreateLeafPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateLeafPart(This,lFlags,Name)

#define IUmiURL_DeleteLeafPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteLeafPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURL_Set_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiURL_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_Get_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBufSize,
    /* [string][in] */ LPWSTR pszDest);


void __RPC_STUB IUmiURL_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetPathInfo_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURL_GetPathInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentCount_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IUmiURL_GetComponentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IUmiURL_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponentFromText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_SetComponentFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IUmiURL_GetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentAsText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_GetComponentAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IUmiURL_RemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveAllComponents_Proxy( 
    IUmiURL __RPC_FAR * This);


void __RPC_STUB IUmiURL_RemoveAllComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IUmiURL_GetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetKeyList_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IUmiURL_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_CreateLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_CreateLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_DeleteLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IUmiURL_DeleteLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURL_INTERFACE_DEFINED__ */


#ifndef __IUmiQuery_INTERFACE_DEFINED__
#define __IUmiQuery_INTERFACE_DEFINED__

/* interface IUmiQuery */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7e-d9db-11d3-a11f-00105a1f515a")
    IUmiQuery : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiQuery __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuery )( 
            IUmiQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf);
        
        END_INTERFACE
    } IUmiQueryVtbl;

    interface IUmiQuery
    {
        CONST_VTBL struct IUmiQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiQuery_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiQuery_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiQuery_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiQuery_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiQuery_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiQuery_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiQuery_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiQuery_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiQuery_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiQuery_Set(This,pszLanguage,uFlags,pszText)	\
    (This)->lpVtbl -> Set(This,pszLanguage,uFlags,pszText)

#define IUmiQuery_GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)	\
    (This)->lpVtbl -> GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiQuery_Set_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLanguage,
    /* [in] */ ULONG uFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiQuery_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiQuery_GetQuery_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
    /* [out][in] */ LPWSTR pszLangBuf,
    /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
    /* [out][in] */ LPWSTR pszQueryTextBuf);


void __RPC_STUB IUmiQuery_GetQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiQuery_INTERFACE_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__
#define __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__

/* interface IUmiCustomInterfaceFactory */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCustomInterfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14CD599E-2BE7-4c6f-B95B-B150DCD93585")
    IUmiCustomInterfaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForIID( 
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectByCLSID( 
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForNames( 
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCustomInterfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForIID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectByCLSID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForNames )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        END_INTERFACE
    } IUmiCustomInterfaceFactoryVtbl;

    interface IUmiCustomInterfaceFactory
    {
        CONST_VTBL struct IUmiCustomInterfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCustomInterfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCustomInterfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCustomInterfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCustomInterfaceFactory_GetCLSIDForIID(This,riid,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForIID(This,riid,lFlags,pCLSID)

#define IUmiCustomInterfaceFactory_GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)	\
    (This)->lpVtbl -> GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)

#define IUmiCustomInterfaceFactory_GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForIID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetObjectByCLSID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ CLSID clsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IUmiCustomInterfaceFactory_GetObjectByCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForNames_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_UmiDefURL;

#ifdef __cplusplus

class DECLSPEC_UUID("d4b21cc2-f2a5-453e-8459-b27f362cb0e0")
UmiDefURL;
#endif
#endif /* __UMI_V6_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cconcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cconnect.hxx
//
//  Contents: Class factory for the LDAP Connection Object.
//
//            CLDAPConnectionCF::CreateInstance.
//
//  History:    03-12-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Function:   CLDAPConnectionCF::CreateInstance
//
// Synopsis:   Standard CreateInstance implementation.
//
// Arguments:  pUnkOuter     ---- standard outer IUnknown ptr.
//             iid           ---- interface requested.
//             ppv           ---- output ptr for created object.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPConnectionCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;
    CLDAPConObject * pConObject;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLDAPConObject::CreateConnectionObject(&pConObject);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pConObject) {
        hr = pConObject->QueryInterface(iid, ppv);
        pConObject->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "ldap.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include ".\iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct Def
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

PTYPEINFO_TABLE gpAggregatorTypeInfoTable = NULL;
LONG glnLDAPObjCount = 0;
LONG glnLDAPTypesOfInfo = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}


CAggregatorDispMgr::CAggregatorDispMgr(CCredentials &Credentials)
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _Credentials = Credentials;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;

        pTypeInfo->Release();

        InterlockedDecrement(&glnLDAPObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnLDAPObjCount == glnLDAPTypesOfInfo) {
        //
        // We need to clean up the list
        //
        AggregatorFreeTypeInfoTable();

        glnLDAPObjCount = glnLDAPTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();
}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                (PDWORD)(rgdispid + dw)))) {
                    hr = DISP_E_UNKNOWNNAME;
                    rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregatorDynamicDispidInvoke(
                        _pPropertyCache,
                        _Credentials,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregatorDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    CCredentials &Credentials,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid, pvarResult, Credentials);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // All ADSI property put requests take only one
        // argument/value (multi-valued attributes take
        // an array of multiple values, but the array
        // itself is still only a single argument)
        // --> multiple arguments = bad parameters
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
AggregatorFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregatorAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregatorLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();
    pTypeInfo = ::AggregatorFindTypeInfo(gpAggregatorTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();

        hr = AggregatorLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpAggregatorTypeInfoTable = ::AggregatorAddTypeInfo(
                                          gpAggregatorTypeInfoTable,
                                          iid,
                                          pTypeInfo
                                          );

        if (!gpAggregatorTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnLDAPTypesOfInfo);

        InterlockedIncrement(&glnLDAPObjCount);


    }
    pTypeInfo->AddRef();

    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnLDAPObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregatorFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregatorTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpAggregatorTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnLDAPObjCount == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cconnect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cconnect.cxx
//
//  Contents: LDAP Connection object - this object implements the 
//        IUmiConnection interface.
//
//  Functions: TBD.
//
//  History:    03-03-00    AjayR  Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::CLDAPConObject
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPConObject::CLDAPConObject():
    _pPropMgr(NULL),
    _fConnected(FALSE),
    _pLdapHandle(NULL),
    _ulErrorStatus(0)
{
}


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::~CLDAPConObject
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPConObject::~CLDAPConObject()
{
    delete _pPropMgr;
    //
    // Close the handle if needed - this will deref and free if appropriate.
    //
    if (_pLdapHandle) {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::CreateConnectionObject
//
// Synopsis:   Static allocation routine for connection object.
//
// Arguments:  CLDAPConObject * --- contains new connection object
//             PADSLDP          --- ldap handle defaulted NULL.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CLDAPConObject ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPConObject::CreateConnectionObject(
    CLDAPConObject FAR * FAR * ppConnectionObject,
    PADSLDP pLdapHandle // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPConObject FAR * pConObj = NULL;
    CPropertyManager FAR * pIntfPropMgr = NULL;

    pConObj = new CLDAPConObject();

    if (!pConObj) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    //
    // Add a ref to the ldap handle if one was passed in.
    //
    if (pLdapHandle) {
        pConObj->_pLdapHandle = pLdapHandle;
        pConObj->_fConnected = TRUE;
        LdapCacheAddRef(pConObj->_pLdapHandle);
    }

    hr = CPropertyManager::CreatePropertyManager(
             (IUmiConnection *) pConObj,
             NULL, // outer unk
             NULL, // credentials
             IntfPropsConnection,
             &pIntfPropMgr
             );

    BAIL_ON_FAILURE(hr);

    pConObj->_pPropMgr = pIntfPropMgr;
    *ppConnectionObject = pConObj;

    RRETURN(S_OK);
error:

    //
    // If we get here, we likely could not create the property manager.
    //
    if (pConObj) {
        delete pConObj;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPConObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiConnection)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else {
        *ppv = NULL;
        SetLastStatus(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}



//
// IUmiConnection methods.
//

//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::Open
//
// Synopsis:   Opens a connection to the server (either implicityly 
//          specified in the url or explicitly in the interface 
//          properties. If there is already an underlyng ldap connection,
//          subsequent open operations will fail if they do not use the same
//          underlying connection.
//          
// Arguments:  pUrl      - IUmiUrl object pointing to object to be fetched.
//             uFlags    - Flags for the operation (currently on 0).
//             TargetIID - IID requested on the target object.
//             ppvRes    - ptr to return the target object.
//
// Returns:    HRESULT   - S_OK or any failure error code.
//
// Modifies:   The status of the object and underlying ldap handle ptr.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPConObject::Open(
    IUmiURL *pURL,
    ULONG uFlags,
    REFIID TargetIID,
    void ** ppvRes
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszUrl = NULL;
    IUnknown *pUnk = NULL;
    IADsObjOptPrivate * pPrivOpt = NULL;
    PADSLDP pLdapTmpHandle = NULL;
    //
    // Default values for credentials.
    //
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    LPWSTR pszLdapPath = NULL;
    DWORD dwFlags = 0;
    BOOL fFlag;
        
    SetLastStatus(0);

    if (!ppvRes || !pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    *ppvRes = NULL;
    //
    // UrlToLDAPPath can handle both native and umi paths.
    //
    hr = UrlToLDAPPath(
             pURL,
             &pszLdapPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // Prepare the credentials if applicable.
    //
    if (!_pCredentials) {
        //
        // Get the params from the property mgr.
        //
        hr = _pPropMgr->GetStringProperty(L"__UserId", &pszUserName);
        
        if (hr == E_OUTOFMEMORY) {
            BAIL_ON_FAILURE(hr);
        }

        hr = _pPropMgr->GetStringProperty(L"__Password", &pszPassword);
        
        if (hr == E_OUTOFMEMORY) {
            BAIL_ON_FAILURE(hr);
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__SECURE_AUTHENTICATION",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_SECURE_AUTHENTICATION;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__NO_AUTHENTICATION",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_NO_AUTHENTICATION;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_READONLY_SERVER",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_READONLY_SERVER;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_PROMPT_CREDENTIALS",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_PROMPT_CREDENTIALS;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_SERVER_BIND",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_SERVER_BIND;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_FAST_BIND",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_FAST_BIND;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_USE_SIGNING",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_USE_SIGNING;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_USE_SEALING",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_USE_SEALING;
        }

//        hr = _pPropMgr->GetLongProperty(L"__USE_ENCRYPTION", &lVal);
//        BAIL_ON_FAILURE(hr);
//        Spec needs to be resolved before we can do this.


        //
        // Always do this as this is what tells us we are in UMI mode.
        //
        dwFlags |= ADS_AUTH_RESERVED;

        _pCredentials = new CCredentials(
                                pszUserName,
                                pszPassword,
                                dwFlags
                                );

        if (!_pCredentials) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    
    //

    // In the future we might want to add some sanity check before 
    // making this call. That might save some network traffic in the
    // rare cases. 
    // Note that currently, we always get the object and then we compare
    // the handles to see if we have inded got an object on the same
    // connection (and fail appropriately if not).
    //
    hr = ::GetObject(
               pszLdapPath,
               *_pCredentials,
               (LPVOID *) &pUnk
               ) ;
    BAIL_ON_FAILURE(hr);

    //
    // By default we get back IADs, so we need to QI for intf.
    //
    hr = pUnk->QueryInterface(TargetIID, ppvRes);
    BAIL_ON_FAILURE(hr);

    //
    // At this point copy over the handle if applicable. If the handle is
    // already set, then we need to make sure we are using the same
    // connection.
    // If do not get the handle for whatever reason, we will use the 
    // defaulted NULL value and in that case we wont save the handle or
    // compare the value.
    //
    hr = pUnk->QueryInterface(IID_IADsObjOptPrivate, (LPVOID *) &pPrivOpt);
    if (SUCCEEDED(hr)) {
        //
        // If we succeeded then we want to try and compare handles.
        //
        hr = pPrivOpt->GetOption(
                 LDP_CACHE_ENTRY,
                 (void*) &pLdapTmpHandle
                 );

    }

    //
    // Reset hr just in case the above failed.
    //
    hr = S_OK;
    
    if (_fConnected) {
        //
        // Verify that the handles are the same.
        //
        if (_pLdapHandle 
            && pLdapTmpHandle
            && (_pLdapHandle != pLdapTmpHandle)) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
    } 
    else {
        //
        // New connection.
        //
        if (pLdapTmpHandle) {
            _pLdapHandle = pLdapTmpHandle;
            _fConnected = TRUE;
            LdapCacheAddRef(_pLdapHandle);
        }
        
    }

error:

    //
    // Release the ref in all cases. If QI failed that will del the obj.
    //
    if (pUnk) {
        pUnk->Release();
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }
    
    if (FAILED(hr)) {
        //
        // Update the error status.
        //
        SetLastStatus(hr);

        hr = MapHrToUmiError(hr);
         
        if (*ppvRes) {
            //  
            // We got the object but a subsequent operation failed.
            //
            *ppvRes = NULL;
            pUnk->Release();
        }
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }
    
    if (pszLdapPath) {
        FreeADsMem(pszLdapPath);
    }
    
    RRETURN(hr);
}

//
// IUmiBaseObject methods.
//
STDMETHODIMP
CLDAPConObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (pStatusObj) {
        *pStatusObj = NULL;
    }
    
    if (puSpecificStatus) {
        *puSpecificStatus = 0;
    }
    else {
        RRETURN(E_INVALIDARG);
    }
    
    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }
    
    *puSpecificStatus = _ulErrorStatus;
    
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPConObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    RRETURN(_pPropMgr->QueryInterface(IID_IUmiPropList, (void **) pPropList));
}


//
// Methods defined on the proplist interface - none are implemented.
// All the properties need to be set on the interface property list.
//


STDMETHODIMP
CLDAPConObject::Put(
    IN LPCWSTR pszName,
    IN ULONG   uFlags,
    IN UMI_PROPERTY_VALUES *pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::Get(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::GetAt(
    IN  LPCWSTR pszName,
    IN  ULONG   uFlags,
    IN  ULONG   uBufferLength,
    OUT LPVOID  pExisitingMem
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPConObject::Delete(
    IN  LPCWSTR pszName,
    IN  ULONG ulFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPConObject::GetAs(
    IN     LPCWSTR pszName,
    IN     ULONG uFlags,
    IN     ULONG uCoercionType,
    IN OUT UMI_PROPERTY_VALUES **pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::FreeMemory(
    ULONG  uReserved,
    LPVOID pMem
    )
{
    if (pMem) {
        //
        // At this time this has to be a pUmiProperty. Ideally we should
        // tag this in some way so that we can check to make sure.
        //
        RRETURN(FreeUmiPropertyValues((UMI_PROPERTY_VALUES *)pMem));
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CLDAPConObject::GetProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProps
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT 
CLDAPConObject::PutProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    IN UMI_PROPERTY_VALUES *pProps
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::PutFrom(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    IN  ULONG uBufferLength,
    IN  LPVOID pExistingMem
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cdsobj.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    );

HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    );

LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD  *DestOffsets,
    LPBYTE pEnd
    );

HRESULT
CLDAPGenObject::SetObjectAttributes(
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsSetObjectAttributes( _pLdapHandle,
                                 _pszLDAPServer,
                                 _pszLDAPDn,
                                 _Credentials,
                                 _dwPort,
                                 _seInfo,
                                 pAttributeEntries,
                                 dwNumAttributes,
                                 pdwNumAttributesModified );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetObjectAttributes(
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetObjectAttributes( _pLdapHandle,
                                 _pszLDAPServer,
                                 _pszLDAPDn,
                                 _Credentials,
                                 _dwPort,
                                 _seInfo,
                                 pAttributeNames,
                                 dwNumberAttributes,
                                 ppAttributeEntries,
                                 pdwNumAttributesReturned );

    RRETURN(hr);

}

HRESULT
CLDAPGenObject::CreateDSObject(
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs *pADs = NULL;
    TCHAR szADsClassName[64];
    TCHAR szLDAPClassName[64];
    DWORD i;
    PADS_ATTR_INFO pThisAttribute;
    LDAP_SCHEMA_HANDLE hSchema = NULL;
    BOOL fSecDesc = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Check and see if security descriptor is one of the attributes.
    //
    for (i=0; (i < dwNumAttributes) && (fSecDesc == FALSE); i++) {
        pThisAttribute = pAttributeEntries + i;
        if (_tcsicmp(
                pThisAttribute->pszAttrName,
                 L"ntSecurityDescriptor")
            == 0)
        {
            fSecDesc = TRUE;
        }

    }

    if (fSecDesc) {
        //
        // Use the create extended method only if the control
        // is supported by the server
        //
        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        if (FAILED(hr) || (dwSecDescType != ADSI_LDAPC_SECDESC_NT)) {
            //
            // Do not use the control
            //
            fSecDesc = FALSE;
        }
    }


    //
    // Get the LDAP path of the object to create
    //
    hr = ADsCreateDSObjectExt(
             _pLdapHandle,
             _ADsPath,
             pszRDNName,
             pAttributeEntries,
             dwNumAttributes,
             _seInfo,
             fSecDesc
             );

    BAIL_ON_FAILURE(hr);

    if (ppObject) {
        for (i = 0; i < dwNumAttributes; i++) {
            pThisAttribute = pAttributeEntries + i;
            if ( _tcsicmp( pThisAttribute->pszAttrName,
                           TEXT("objectClass")) == 0 ) {
                _tcscpy( szLDAPClassName,
                         (LPTSTR)pThisAttribute->pADsValues->CaseIgnoreString);
                break;
            }
        }

        hr = CreateGenericObject(
                        _ADsPath,
                        pszRDNName,
                        szLDAPClassName,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs
                        );
        BAIL_ON_FAILURE(hr);

        hr = pADs->QueryInterface(
                          IID_IDispatch,
                          (void **)ppObject
                          );
        BAIL_ON_FAILURE(hr);

    }

error:

    if ( pADs ) {
        pADs->Release();
    }

    if ( hSchema ) {
        SchemaClose( &hSchema );
    }

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteDSObject(
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Get the LDAP path of the object to create
    //
    hr = ADsDeleteDSObject(
                _pLdapHandle,
                _ADsPath,
                pszRDNName
                );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetObjectInformation(
    THIS_ PADS_OBJECT_INFO  *ppObjInfo
    )
{
    HRESULT hr = S_OK;

    ADS_OBJECT_INFO ObjectInfo;
    PADS_OBJECT_INFO pObjectInfo = &ObjectInfo;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    BSTR bstrSchema = NULL;
    BSTR bstrClass = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = get_Schema( &bstrSchema );
    BAIL_ON_FAILURE(hr);

    hr = get_Class( &bstrClass );
    BAIL_ON_FAILURE(hr);

    pObjectInfo->pszRDN = _Name;
    pObjectInfo->pszObjectDN = _ADsPath;
    pObjectInfo->pszParentDN = _Parent;
    pObjectInfo->pszSchemaDN = bstrSchema;
    pObjectInfo->pszClassName = bstrClass;

    dwSize = ComputeObjectInfoSize(pObjectInfo);

    pBuffer = (LPBYTE)AllocADsMem(dwSize);
    if (!pBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = MarshallObjectInfo(
             pObjectInfo,
             pBuffer,
             pBuffer + dwSize
             );
    BAIL_ON_FAILURE(hr);

    *ppObjInfo = (PADS_OBJECT_INFO) pBuffer;

error:

    if ( bstrSchema )
        SysFreeString( bstrSchema );

    if ( bstrClass )
        SysFreeString( bstrClass );

    RRETURN(hr);
}

DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    )
{
    DWORD dwLen = 0;

    dwLen += (wcslen(pObjectInfo->pszRDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszObjectDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszParentDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszSchemaDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszClassName) + 1) * sizeof(WCHAR);

    dwLen += sizeof(ADS_OBJECT_INFO);

    return(dwLen);
}

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD ObjectInfoStrings[] =  {
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszRDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszObjectDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszParentDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszSchemaDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszClassName),
                             0xFFFFFFFF
                             };

HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(ADS_OBJECT_INFO)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;

    memset(SourceStrings, 0, sizeof(ADS_OBJECT_INFO));
    *pSourceStrings++ = pSrcObjectInfo->pszRDN;
    *pSourceStrings++ = pSrcObjectInfo->pszObjectDN;
    *pSourceStrings++ = pSrcObjectInfo->pszParentDN;
    *pSourceStrings++ = pSrcObjectInfo->pszSchemaDN;
    *pSourceStrings++ = pSrcObjectInfo->pszClassName;

    pEnd = PackStrings(
                SourceStrings,
                pDestObjectInfo,
                ObjectInfoStrings,
                pEnd
                );

    RRETURN(S_OK);
}

LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumns.cxx
//
//  Contents:  LDAP Enumerator Code
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPNamespaceEnum::Create(
    CLDAPNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials,
    LPTSTR pszNamespace
    )
{
    HRESULT hr = S_OK;
    CLDAPNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CLDAPNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
             var,
             &penumvariant->_pObjList
             );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    penumvariant->_pszNamespace = AllocADsStr(pszNamespace);
    if (!(penumvariant->_pszNamespace)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if( IsGCNamespace(pszNamespace) )
        penumvariant->_dwPort = (DWORD) USE_DEFAULT_GC_PORT;
    else
        penumvariant->_dwPort = (DWORD) USE_DEFAULT_LDAP_PORT;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::CLDAPNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPNamespaceEnum::CLDAPNamespaceEnum()
{
    _dwIndex = 0;
    _pObjList = NULL;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::~CLDAPNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPNamespaceEnum::~CLDAPNamespaceEnum()
{
    if (_pszNamespace)
        FreeADsMem(_pszNamespace);

    if ( _pObjList )
        delete _pObjList;
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if ( _dwIndex > 0 )  // only your default ds will be returned, one element
    {
        if (pcElementFetched)
            *pcElementFetched = 0;

        RRETURN(S_FALSE);
    }

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        if ( _dwIndex > 0 )  // only your default ds will be returned,
                             // i.e. one element only
        {
            hr = S_FALSE;
            break;
        }

        _dwIndex++;

        hr = GetTreeObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespaceEnum::GetTreeObject(
    IDispatch ** ppDispatch
    )
{
    DWORD err = NO_ERROR;
    HRESULT hr = S_OK;
    LPTSTR *aValuesNamingContext = NULL;
    LPTSTR *aValuesObjectClass = NULL;
    int nCountValues = 0;
    TCHAR *pszLDAPPathName = NULL;
    TCHAR szADsClassName[64];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    TCHAR *pszNewADsPath = NULL;
    TCHAR *pszLast = NULL;

    LPWSTR pszNamingContext = NULL;

    LPWSTR pszNewADsParent = NULL;
    LPWSTR pszNewADsCommonName = NULL;

    DWORD fVerify = FALSE;

    *ppDispatch = NULL;
    ADS_LDP *ld = NULL;

    BOOL fGCDefaulted = FALSE;

    //
    // Now send back the current object
    //

RetryGetDefaultServer:

    if ( err = GetDefaultServer(
                   _dwPort,
                   fVerify,
                   szDomainName,
                   szServerName,
                   TRUE) ){

        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Read the naming contexts
    //


    if (_dwPort == USE_DEFAULT_GC_PORT) {
        fGCDefaulted = TRUE;
        pszNamingContext = NULL;
    } else {
        pszNamingContext = TEXT(LDAP_OPATT_DEFAULT_NAMING_CONTEXT);
    }


    hr = LdapOpenObject2(
                szDomainName,
                szServerName,
                NULL,
                &ld,
                _Credentials,
                _dwPort
                );

    if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
         (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN)))
                    && !fVerify) {
        fVerify = TRUE;
        goto RetryGetDefaultServer ;
    }

    BAIL_ON_FAILURE(hr);

    if (!fGCDefaulted) {

        hr = LdapReadAttributeFast(
                ld,
                NULL,
                pszNamingContext,
                &aValuesNamingContext,
                &nCountValues
                );

        BAIL_ON_FAILURE(hr);

        if ( nCountValues == 0 ) {

            //
            // The hr will be modified at the end of the function to S_FALSE
            // in case of error

            BAIL_ON_FAILURE(hr = E_FAIL);

        }

        hr = BuildADsPathFromLDAPPath2(
                        FALSE,              //Server is present till DSSnapin Works
                        _pszNamespace,
                        szDomainName,
                        _dwPort,
                        fGCDefaulted ?
                            TEXT("") :
                            aValuesNamingContext[0],
                        &pszNewADsPath
                        );

    } else {
        //
        // In this case we want to force it to be GC://yourDomain
        // so that all searches will be truly global
        //

        hr = BuildADsPathFromLDAPPath2(
                 TRUE, // server is present
                 _pszNamespace,
                 szDomainName,
                 _dwPort,
                 TEXT(""),
                 &pszNewADsPath
                 );

    }

    BAIL_ON_FAILURE(hr);

    // this part is common to both code paths
    hr = BuildADsParentPath(
              pszNewADsPath,
              &pszNewADsParent,
              &pszNewADsCommonName
              );
    BAIL_ON_FAILURE(hr);

    nCountValues = 0;

    //
    // Read the object class of the path if necessary
    //

    if (!fGCDefaulted) {

        hr = LdapReadAttributeFast(
                 ld,
                 aValuesNamingContext[0],
                 L"objectClass",
                 &aValuesObjectClass,
                 &nCountValues
                 );

        BAIL_ON_FAILURE(hr);

    }

    if ( nCountValues == 0 && !fGCDefaulted)
    {
        // This object exists but does not contain objectClass attribute
        // which is required for all DS objects. Hence, ignore the object
        // and return error.

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Create the object
    //

    if (fGCDefaulted) {

        hr = CLDAPGenObject::CreateGenericObject(
                 pszNewADsParent,
                 pszNewADsCommonName,
                 L"top",
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IUnknown,
                 (void **) ppDispatch
                 );

    } else {
        //
        // Send all the classes so we can load all extensions
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 pszNewADsParent,
                 pszNewADsCommonName,
                 aValuesObjectClass,
                 nCountValues,
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **) ppDispatch
                 );
    }

    BAIL_ON_FAILURE(hr);

error:


    if ( aValuesNamingContext )
        LdapValueFree( aValuesNamingContext );

    if ( aValuesObjectClass )
        LdapValueFree( aValuesObjectClass );

    if ( pszNewADsPath )
        FreeADsStr( pszNewADsPath );

    if ( pszNewADsParent) {
       FreeADsStr(pszNewADsParent);
    }

    if (pszNewADsCommonName) {
       FreeADsStr(pszNewADsCommonName);
    }

    if ( ld ){
        LdapCloseObject( ld );
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cdssrch.cxx ===
//--------------LDAP----------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#include "stdio.h"
#pragma hdrstop

//
// Sets the appropriate search preferences.
//


HRESULT
CLDAPGenObject::SetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{

    HRESULT hr = S_OK;

    //
    // Need to initialize the searchprefs in case this fn
    // is being called for the 2nd time.
    //
    LdapInitializeSearchPreferences(&_SearchPref, TRUE);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsSetSearchPreference(
             pSearchPrefs,
             dwNumPrefs,
             &_SearchPref,
             _pszLDAPServer,
             _pszLDAPDn,
             _Credentials,
             _dwPort
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::ExecuteSearch(
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{

    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsExecuteSearch(
             _SearchPref,
             _ADsPath,
             _pszLDAPServer,
             _pszLDAPDn,
             pszSearchFilter,
             pAttributeNames,
             dwNumberAttributes,
             phSearchHandle
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::AbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{

    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsAbandonSearch(
             hSearchHandle
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::CloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsCloseSearchHandle(
             hSearchHandle
             );

    RRETURN(hr);

}


HRESULT
CLDAPGenObject::GetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetFirstRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetNextRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetPreviousRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetColumn(
             hSearchHandle,
             pszColumnName,
             _Credentials,
             _dwPort,
             pColumn
             );

    RRETURN(hr);
}



HRESULT
CLDAPGenObject::GetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetNextColumnName(
             hSearchHandle,
             ppszColumnName
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::FreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsFreeColumn(
             pColumn
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cdssch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CLDAPGenObject::EnumAttributes(
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;

    hr = ADsEnumAttributes(
             _pszLDAPServer,
             _pszLDAPDn,
             _Credentials,
             _dwPort,
             ppszAttrNames,
             dwNumAttributes,
             ppAttrDefinition,
             pdwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::CreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );
    RRETURN(hr);
}


HRESULT
CLDAPGenObject::WriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteAttributeDefinition(
             pszAttributeName
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::EnumClasses(
    LPWSTR * ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF * ppClassDefinition,
    DWORD * pdwNumClasses
    )
{
    HRESULT hr = S_OK;

    hr = ADsEnumClasses(
             ppszClassNames,
             dwNumClasses,
             ppClassDefinition,
             pdwNumClasses
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::CreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateClassDefinition(
             pszClassName,
             pClassDefinition
             );
    RRETURN(hr);
}


HRESULT
CLDAPGenObject::WriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF  pClassDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteClassDefinition(
             pszClassName,
             pClassDefinition
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteClassDefinition(
             pszClassName
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cgenobj.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//---------------------------------------- ------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#ifdef __cplusplus
extern "C"
#else
extern
#endif
HRESULT
AdsTypeToPropVariant2(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    VARIANT * pVariant,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    );

#ifdef __cplusplus
extern "C"
#else
extern
#endif
HRESULT
PropVariantToAdsType2(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    );

//
// Helper routine that handles setting the sticky server private
// option when the input is an array.
//
HRESULT
SetStickyServerWithDomain(
    PVARIANT pvProp
    );

//  Class CLDAPGenObject

DEFINE_IDispatch_ExtMgr_Implementation(CLDAPGenObject)
DEFINE_IADs_Shorter_Implementation(CLDAPGenObject)

//
// This is a useful function
//
HRESULT GetIntegerFromVariant(
    VARIANT* pvProp,
    DWORD* pdwValue
    );

typedef struct _classeshierarchylist {
    LPWSTR pszClassName;
    struct _classeshierarchylist *pNext;
} ClassesHierarchyList, *PClassesHierarchyList;


//
// Helper to Trace The Tree for a class
//
HRESULT
TraceTreeForClass(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PWCHAR **pppszNameArr,
    PLONG plnNumElements
    );

HRESULT
AddToClassesList(
    VARIANT vBstrVal,
    LPWSTR *ppszCurClass,
    PClassesHierarchyList *pClassListhead,
    PLONG plnNumItems
    );

CLDAPGenObject::CLDAPGenObject():
    _pExtMgr(NULL),
    _pPropertyCache( NULL ),
    _pDispMgr( NULL ),
    _pszLDAPServer(NULL),
    _pszLDAPDn(NULL),
    _pLdapHandle( NULL ),
    _dwOptReferral((DWORD) LDAP_CHASE_EXTERNAL_REFERRALS),
    _dwPageSize(99),
    _dwCorePropStatus(0),
    _fRangeRetrieval(FALSE)
{
    VariantInit(&_vFilter);
    VariantInit(&_vHints);

    _seInfo = OWNER_SECURITY_INFORMATION
              | GROUP_SECURITY_INFORMATION
              | DACL_SECURITY_INFORMATION;

    _fExplicitSecurityMask = FALSE;

    LdapInitializeSearchPreferences(&_SearchPref, TRUE);

    ENLIST_TRACKING(CLDAPGenObject);
}

//
// fClassDefaulted indicates if the class has been defaulted
// because of a fast bind flag or otherwise.
//
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR LdapClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj,
    BOOL fClassDefaulted,
    BOOL fNoQI // defaulted to FALSE
    )
{

    //
    // Call into the fully featured Create
    //
    LPWSTR pszClassNames[2];
    HRESULT hr = S_OK;
    PWCHAR *ppListOfNames;
    LONG lnNumNames = 0;

    pszClassNames[0] = LdapClassName;
    pszClassNames[1] = NULL;

    hr = TraceTreeForClass(
             Parent,
             CommonName,
             LdapClassName,
             Credentials,
             &ppListOfNames,
             &lnNumNames
             );

    if (FAILED(hr)) {
        //
        // Default to just the class name given
        //
        RRETURN(CreateGenericObject(
                    Parent,
                    CommonName,
                    pszClassNames,
                    1,
                    Credentials,
                    dwObjectState,
                    riid,
                    ppvObj,
                    fClassDefaulted,
                    fNoQI
                    )
                );
    }
    else {
        //
        // Create with all the classes specified
        //
        hr = CreateGenericObject(
                 Parent,
                 CommonName,
                 ppListOfNames,
                 lnNumNames,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj,
                 fClassDefaulted,
                 fNoQI
                 );

        for (long i = 0; i < lnNumNames; i++) {
            if (ppListOfNames[i]) {
                FreeADsStr(ppListOfNames[i]);
            }
        }

        if (ppListOfNames) {
            FreeADsMem(ppListOfNames);
        }

        RRETURN(hr);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CLDAPGenObject::CreateGenericObject
//
//  Synopsis:   Does all the work and actually creates the object.
//          Difference from the overlaoded member being that it accepts an
//          array of values for the class name so that it can load
//          extensions for all the classes in the inheritance hierarchy.
//
//  Arguments:
//
//-------------------------------------------------------------------------
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR LdapClassNames[],
    long lnNumClasses,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj,
    BOOL fClassDefaulted,
    BOOL fNoQI // will return cgenobject if set to TRUE, defaulted FALSE
    )
{
    CLDAPGenObject FAR * pGenObject = NULL;
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    LPWSTR pszBaseClassName = GET_BASE_CLASS(LdapClassNames, lnNumClasses);

    hr = AllocateGenObject(pszBaseClassName, Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGenObject->_pDispMgr);


    pGenObject->_Credentials = Credentials;


    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                pszBaseClassName,
                CLSID_LDAPGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pGenObject->_ADsPath,
             &pGenObject->_pszLDAPServer,
             &pGenObject->_pszLDAPDn,
             &pGenObject->_dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //
    hr = pGenObject->_pPropertyCache->SetObjInformation(
                                     &(pGenObject->_Credentials),
                                     pGenObject->_pszLDAPServer,
                                     pGenObject->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // Create and Load 3rd party extensions and the extension mgr.
    // This should be done after initilaization of core and generic object s.t
    // 1) an extension writer can access info on IADs (e.g _Parent) etc
    //    during extension creation, if he wants to.
    // 2) we shouldn't waste the effort to create and load extension
    //    objects if fialure in the aggregator's creation
    //

    hr = CADsExtMgr::CreateExtMgr(
                      (IADs *)pGenObject,
                      pGenObject->_pDispMgr,
                      LdapClassNames,
                      lnNumClasses,
                      &(pGenObject->_Credentials),
                      &pGenObject->_pExtMgr
                      );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGenObject->_pExtMgr);

    hr = LdapOpenObject(
                   pGenObject->_pszLDAPServer,
                   pGenObject->_pszLDAPDn,
                   &(pGenObject->_pLdapHandle),
                   pGenObject->_Credentials,
                   pGenObject->_dwPort
                   );

    BAIL_ON_FAILURE(hr);

    if (!fClassDefaulted) {
        //
        // Update the status to reflect we do not need to go
        // on the wire to get the class
        //
        pGenObject->_dwCorePropStatus |= LDAP_CLASS_VALID;
    }


    if (fNoQI) {
        *ppvObj = (void *) pGenObject;
    } 
    else if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // Call is from umi so we need to create the umi object.
        //
        hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
                 IntfPropsGeneric,
                 pGenObject->_pPropertyCache,
                 (IADs *) pGenObject,
                 (IADs *) pGenObject,
                 IID_IUnknown,
                 ppvObj,
                 &(pGenObject->_Credentials),
                 pGenObject->_dwPort,
                 pGenObject->_pszLDAPServer,
                 pGenObject->_pszLDAPDn,
                 pGenObject->_pLdapHandle,
                 pGenObject->_pExtMgr
                 );

        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    } else {
        //
        // Need the appropriate interface.
        //
        hr = pGenObject->QueryInterface(riid, ppvObj);
        BAIL_ON_FAILURE(hr);

        pGenObject->Release();
    }

    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pGenObject;
    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
// Function:   CLDAPGenObject::CreateGenericObject (static constructor), this
//          constructor is used by Umi Searches only.
//
// Synopsis:   This routine uses the other static constructor routines 
//          depending on the objectClass information available in the passed
//          in ldapMsg. The state of the newly created object reflects this
//          information. The newly created object is then prepopulated with
//          the attributes in the ldapMsg. The return value from this routine
//          is the newly created object (interface asked on this object).
//
// Arguments:  Parent       -  Path to the parent of the newly created object.
//             CommonName   -  Name of new object to create.
//             Credentials  -  Standard credentials object.
//             dwObjectState-  Bound/unbound (always bound in this case).
//             ldapHandle   -  Handle used in the deciphering search info.
//             pldapMsg     -  The Ldao msg with the attributes.
//             riid         -  IID requested on newly created object.
//             ppvObj       -  Return value.
//             
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   ppvObj contains newly created object with attributes.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    PADSLDP ldapHandle,
    LDAPMessage *pldapMsg,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    TCHAR **aValues = NULL;
    int   nCount;
    CLDAPGenObject *pGenObject = NULL;

    hr = LdapGetValues(
             ldapHandle,
             pldapMsg,
             L"objectClass",
             &aValues,
             &nCount
             );

    if (FAILED(hr) || !aValues) {
        //
        // We do not have the objectClass
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 Parent,
                 CommonName,
                 L"Top",
                 Credentials,
                 dwObjectState,
                 riid,
                 (void **) &pGenObject,
                 TRUE, // class is defaulted
                 TRUE // No QI
                 );

    } 
    else {
        //
        // We have the info we need for the constructor with class name
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 Parent,
                 CommonName,
                 aValues,
                 nCount,
                 Credentials,
                 dwObjectState,
                 riid,
                 (void **) &pGenObject,
                 FALSE, // objectClass is not defaulted
                 TRUE // No QI
                 );
    }

    BAIL_ON_FAILURE(hr);

    //
    // Now we need to prepopulate the object.
    //
    hr = pGenObject->_pPropertyCache->
             LDAPUnMarshallProperties2(
                 pGenObject->_pszLDAPServer,
                 pGenObject->_pLdapHandle,
                 pldapMsg,
                 FALSE, // this is not an explicit getinfo.
                 pGenObject->_Credentials,
                 &pGenObject->_fRangeRetrieval
                 );
    //
    // Should we really fail if we could not unmarshall properties ???
    ///
    BAIL_ON_FAILURE(hr);

    //
    // This call is always from UMI, so now we need to get the
    // outer umiObject and return that.
    //
    hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
               IntfPropsGeneric,
               pGenObject->_pPropertyCache,
               (IADs *) pGenObject,
               (IADs *) pGenObject,
               riid,
               ppvObj,
               &(pGenObject->_Credentials),
               pGenObject->_dwPort,
               pGenObject->_pszLDAPServer,
               pGenObject->_pszLDAPDn,
               pGenObject->_pLdapHandle,
               pGenObject->_pExtMgr
               );

    BAIL_ON_FAILURE(hr);

    //
    // Only thing remaining is to get a list of the attributes fetched
    // into this object. That way we wont go on the wire for them. This
    // can be done once the GetInfoEx related bug is fixed.
    //

error :

    if (pGenObject && FAILED(hr)) {
        delete pGenObject;
        *ppvObj = NULL;
    }

    //
    // Need to free the Ldap values in all cases.
    //
    if (aValues) {
        LdapValueFree(aValues);
        aValues = NULL;
    }

    RRETURN(hr);
}

CLDAPGenObject::~CLDAPGenObject( )
{

    //
    // last to be created - first to be unloaded
    //

    delete _pExtMgr;

    VariantClear(&_vFilter);
    VariantClear(&_vHints);

    if ( _pLdapHandle )
    {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }

    if (_pszLDAPServer) {
       FreeADsStr(_pszLDAPServer);
       _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
       FreeADsStr(_pszLDAPDn);
       _pszLDAPDn = NULL;
    }

    delete _pDispMgr;

    delete _pPropertyCache;

    //
    // Free the sort keys if applicable.
    //
    if (_SearchPref._pSortKeys) {
        for (DWORD dwCtr = 0; dwCtr < _SearchPref._nSortKeys; dwCtr++) {
            if (_SearchPref._pSortKeys[dwCtr].sk_attrtype)
                FreeADsStr(_SearchPref._pSortKeys[dwCtr].sk_attrtype);
        }
        FreeADsMem(_SearchPref._pSortKeys);
    }

    //
    // Free the VLV information if applicable
    //
    if (_SearchPref._pVLVInfo) {

        if (_SearchPref._pVLVInfo->ldvlv_attrvalue) {

            if (_SearchPref._pVLVInfo->ldvlv_attrvalue->bv_val) {
                FreeADsMem(_SearchPref._pVLVInfo->ldvlv_attrvalue->bv_val);
            }

            FreeADsMem(_SearchPref._pVLVInfo->ldvlv_attrvalue);
        }

        if (_SearchPref._pVLVInfo->ldvlv_context) {
        
            if (_SearchPref._pVLVInfo->ldvlv_context->bv_val) {
                FreeADsMem(_SearchPref._pVLVInfo->ldvlv_context->bv_val);
            }

            FreeADsMem(_SearchPref._pVLVInfo->ldvlv_context);
        }

        FreeADsMem(_SearchPref._pVLVInfo);
    }

    //
    // Free the attribute scoped query information if applicable
    //
    if (_SearchPref._pAttribScoped) {

        FreeADsStr(_SearchPref._pAttribScoped);
    }
}

STDMETHODIMP
CLDAPGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjectOptions))
    {
        *ppv = (IADsObjectOptions FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDeleteOps))
    {
        *ppv = (IADsDeleteOps FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjOptPrivate))
    {
        *ppv = (IADsObjOptPrivate *) this;
    }
    else if (_pExtMgr)
    {

            RRETURN(hr = _pExtMgr->QueryInterface(iid, ppv));

    }else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
HRESULT
CLDAPGenObject::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsPropertyList) ||
    IsEqualIID(riid, IID_IADsContainer) ||
#if 0
    IsEqualIID(riid, IID_IDirectoryObject) ||
    IsEqualIID(riid, IID_IDirectorySearch) ||
    IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
    IsEqualIID(riid, IID_IADsObjectOptions)) {

        RRETURN(S_OK);

    }
    else {

        RRETURN(S_FALSE);

    }
}

HRESULT
CLDAPGenObject::SetInfo()
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = LDAPSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::LDAPSetObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes=FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOL fModifyDone = FALSE;
    SECURITY_INFORMATION NewSeInfo=0;


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE) ((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    LDAPControl     ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    PLDAPControl    ServerControlsOnlyModify[2] =
                    {
                        &ModifyControl,
                        NULL
                    };

    PLDAPControl    ServerControlsAll[3] =
                    {
                        &SeInfoControl,
                        &ModifyControl,
                        NULL
                    };

    BOOL fServerIsAD = FALSE;


    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    //
    // Sometimes the call to Marshall might contain the SD but NewSeInfo
    // might not have been updated suitable because of failures not sever
    // enough to warrant failing the entire operation.
    //
    if (!_fExplicitSecurityMask 
        && fNTSecDes
        && (NewSeInfo != INVALID_SE_VALUE)
        ) {
        berValue[4] = (BYTE) ((ULONG)NewSeInfo);
    }

    //
    // Find out if server is AD.
    //
    hr = ReadServerSupportsIsADControl(
            _pszLDAPServer,
             &fServerIsAD,
             _Credentials,
             _dwPort
             );
    if (FAILED(hr)) {
        //
        // Assume it is not AD and continue, there is no
        // good reason for this to fail on AD.
        //
        fServerIsAD = FALSE;
    }

    if (fNTSecDes) {

        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapModifyExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         aMod,
                         fServerIsAD ?
                            (PLDAPControl *) &ServerControlsAll :
                            (PLDAPControl *) &ServerControls,
                         NULL
                         );

                fModifyDone = TRUE;


        } // SecDesc type == NT
    } // if modifySecDes

    if (!fModifyDone) {

        if (fServerIsAD) {
            //
            // Need to send the additional control that says it is
            // ok to clear the values on attributes that do not
            // have any values.
            //
            hr = LdapModifyExtS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     aMod,
                     (PLDAPControl *) &ServerControlsOnlyModify,
                     NULL
                     );
        }
        else {
            hr = LdapModifyS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     aMod
                     );
        }

    }

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearMarshalledProperties();
    _pPropertyCache->ClearAllPropertyFlags();
    
    _pPropertyCache->DeleteSavingEntry();


error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPGenObject::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    BOOL fNTSecDes= FALSE;
    BOOL fAddDone = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    SECURITY_INFORMATION SeInfo = _seInfo;
    SECURITY_INFORMATION NewSeInfo=0;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE) ((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VARIANT v;

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _SchemaClass;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if (!_fExplicitSecurityMask && NewSeInfo) {
        berValue[4] = (BYTE) ((ULONG)NewSeInfo);
    }
    
    if (fNTSecDes == TRUE) {
        //
        // If we support the SD control, then we use
        // the add ext method.
        //
        if (fNTSecDes) {


            hr = ReadSecurityDescriptorControlType(
                     _pszLDAPServer,
                     &dwSecDescType,
                     _Credentials,
                     _dwPort
                     );

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapAddExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         aMod,
                         (PLDAPControl *)&ServerControls,
                         NULL
                         );

                fAddDone = TRUE;

            } // SecDesc type == NT
        }
    } // if SecDesc needs to be sent.


    if (!fAddDone) {
        //
        // Call add s
        //
        hr = LdapAddS(
                 _pLdapHandle,
                 _pszLDAPDn,
                 aMod
                 );
    }

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::GetInfoEx(
    THIS_ VARIANT vProperties,
    long lnReserved
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    PWSTR *ppszStringArray = NULL;
    DWORD dwOptions = 0;
    int ldaperr = 0;
    DWORD dwCtr = 0;
    DWORD dwSecDescType = 0;
    BOOL fSearchDone = FALSE;


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    UNREFERENCED_PARAMETER(lnReserved);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSafeArrayToVariantArray(
             vProperties,
             &vVarArray,
             &dwNumVariants
             );
    // returns E_FAIL if vProperties is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToLDAPStringArray(
             vVarArray,
             &ppszStringArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    while ((dwCtr < dwNumVariants) && (dwSecDescType == 0)) {
        if (_wcsicmp(ppszStringArray[dwCtr], L"ntSecurityDescriptor") == 0) {
            dwSecDescType = 1;
        }

        dwCtr++;
    }

    //
    // Do not bother doing this if secdesc has not been
    // explicitly requested.
    //
    if (dwSecDescType) {

        //
        // If the server is V3, we want to use controls in case
        // the security descriptor has to be retrieved
        //
        ldaperr = ldap_get_option(
                        _pLdapHandle->LdapHandle,
                        LDAP_OPT_VERSION,
                        &dwOptions
                        );

        if (dwOptions == LDAP_VERSION3) {

            hr = ReadSecurityDescriptorControlType(
                     _pszLDAPServer,
                     &dwSecDescType,
                     _Credentials,
                     _dwPort
                     );

            BAIL_ON_FAILURE(hr);

            if (dwSecDescType == ADSI_LDAPC_SECDESC_NT) {

                hr = LdapSearchExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         LDAP_SCOPE_BASE,
                         TEXT("(objectClass=*)"),
                         ppszStringArray,
                         0,
                         (PLDAPControl *)&ServerControls,
                         NULL,
                         NULL,
                         10000,
                         &res
                         );

                fSearchDone = TRUE;
            }
        }
    } // sec desc requested


    //
    // At this point even if it is a vesion 3 DS, we might still
    // need to call the normal search routine as all version 3
    // DS's need not necessarily support controls - Ex: Exchange.
    //

    if (!fSearchDone) {

        hr = LdapSearchS(
                 _pLdapHandle,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 TEXT("(objectClass=*)"),
                 ppszStringArray,
                 0,
                 &res
                 );

        fSearchDone = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // This is an explicit GetInfo[Ex], but we don't want to flush the
    // property cache.  For example, if we have [A B C] in the cache, and
    // we request [C D E], we want to end up with [A B C D E] in the cache.
    //
    // But we do want to tell LDAPUnMarshallProperties that this is an
    // explicit call; using the same example, we want the server's value of
    // C in the cache after this call, not the old value.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties2(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            TRUE,   // fExplicit
                            _Credentials,
                            &_fRangeRetrieval
                            );
    BAIL_ON_FAILURE(hr);


    for(DWORD i = 0; i < dwNumVariants; i++) {
    	_pPropertyCache->AddSavingEntry(ppszStringArray[i]);
    }

error:
    if (res)
        LdapMsgFree(res);

    if (ppszStringArray) {
    for (DWORD i = 0; i < dwNumVariants; i++)
        if (ppszStringArray[i])
            FreeADsStr(ppszStringArray[i]);
        FreeADsMem(ppszStringArray);
    }

    if (vVarArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            VariantClear(vVarArray + dwCtr);
        }
        FreeADsMem(vVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::GetInfo()
{
    _fRangeRetrieval = FALSE;
    RRETURN(GetInfo(GETINFO_FLAG_EXPLICIT));
}

HRESULT
CLDAPGenObject::GetInfo(
    DWORD dwFlags
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;
    int ldaperr = 0;
    DWORD dwOptions = 0;
    DWORD dwSecDescType = 0;
    BOOL fSearchDone = FALSE;


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (dwFlags == GETINFO_FLAG_IMPLICIT_AS_NEEDED) {
        if (_pPropertyCache->getGetInfoFlag()) {
            //
            // We are done there is nothing to do.
            //
            goto error;
        }
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    if ( dwFlags == GETINFO_FLAG_EXPLICIT )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    // modified from LdapSearchS to LdapSearchExtS to get all attributes
    // including SecurityDescriptor by one call

    ldaperr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_VERSION,
                    &dwOptions
                    );

    if (dwOptions == LDAP_VERSION3) {

        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if (dwSecDescType == ADSI_LDAPC_SECDESC_NT) {

            hr = LdapSearchExtS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     LDAP_SCOPE_BASE,
                     TEXT("(objectClass=*)"),
                     NULL,  // modified to NULL for all attributes
                     0,
                     (PLDAPControl *)&ServerControls,
                     NULL,
                     NULL,
                     10000,
                     &res
                     );

            fSearchDone = TRUE;
        }
    }


    //
    // If the fSearchDone flags is not set, then the server
    // probably did not support the SecDesc control and we need to
    // just a search not extended.
    //
    if (!fSearchDone) {

        hr = LdapSearchS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

        fSearchDone = TRUE;

    }

    BAIL_ON_FAILURE(hr);

    hr = _pPropertyCache->LDAPUnMarshallProperties2(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            (dwFlags == GETINFO_FLAG_EXPLICIT) ?
                                TRUE : FALSE,
                            _Credentials,
                            &_fRangeRetrieval
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {

        LdapMsgFree( res );
    }

    if (_pPropertyCache) {
       Reset();
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_GUID(THIS_ BSTR FAR* retval)
{

    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    ULONG ulLength = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    WCHAR pszSmallStr[5];

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (_dwObjectState == ADS_OBJECT_UNBOUND) {
        RRETURN(E_ADS_OBJECT_UNBOUND);
    }

    if (!(_dwCorePropStatus & LDAP_GUID_VALID)) {

        //
        // Get the property from the server (implicit getinfo)
        // and update the property in the
        //
        hr = _pPropertyCache->getproperty(
                        L"objectGUID",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if ((ldapSrcObjects.dwCount == 0)
            || (ldapSrcObjects.dwCount > 1)) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        ulLength = LDAPOBJECT_BERVAL_LEN(ldapSrcObjects.pLdapObjects);

        pszTempStr = (LPWSTR) AllocADsMem((ulLength * 2 + 1) * sizeof(WCHAR));

        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (DWORD dwCtr = 0; dwCtr < ulLength; dwCtr++) {
            wsprintf(pszSmallStr, L"%02x", (BYTE) LDAPOBJECT_BERVAL_VAL(ldapSrcObjects.pLdapObjects)[dwCtr]);
            wcscat(pszTempStr, pszSmallStr);
        }

        wcscat(pszTempStr, L"\0");

        if (_ADsGuid) {
            ADsFreeString(_ADsGuid);
            _ADsGuid = NULL;
        }

        hr = ADsAllocString(pszTempStr, &_ADsGuid);

        if (SUCCEEDED(hr)) {
            _dwCorePropStatus |= LDAP_GUID_VALID;
        }
    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszTempStr) {
        FreeADsMem(pszTempStr);
    }

    if (SUCCEEDED(hr)) {
        RRETURN(get_CoreGUID(retval));
    }

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::get_Parent(BSTR * retval)
{

    HRESULT hr;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszADsParent = NULL;
    LPWSTR pszADsCommon = NULL;

    BOOL   fGCNameSpace = FALSE;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( (wcslen(_Name) > wcslen(L"<GUID=")) &&
         (_wcsnicmp(_Name, L"<GUID=", wcslen(L"<GUID=")) == 0)) {

        //
        // Replace the guid with the distinguishedName
        //

        //
        // Get the property from the server (implicit getinfo)
        //
        hr = _pPropertyCache->getproperty(
                        L"distinguishedName",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        pszTempStr = LDAPOBJECT_STRING(ldapSrcObjects.pLdapObjects);


        //
        // Break it down into parent name & common name portions
        //

        // _ADsPath could not be NULL 
        if(!_wcsnicmp(L"GC:", _ADsPath, wcslen(L"GC:")))
        {
            fGCNameSpace = TRUE;
        }
        

        hr = BuildADsPathFromLDAPPath2(
                                       (_pszLDAPServer ? TRUE : FALSE),
                                       fGCNameSpace ? L"GC:" : L"LDAP:",
                                       _pszLDAPServer,
                                       _dwPort,
                                       pszTempStr,
                                       &pszADsPath
                                       );
        BAIL_ON_FAILURE(hr);

        hr = BuildADsParentPath(pszADsPath,
                                &pszADsParent,
                                &pszADsCommon);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pszADsParent, retval);
        
    }
    else {

        hr = get_CoreParent(retval);

    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszADsPath)
        FreeADsMem(pszADsPath);

    if (pszADsParent)
        FreeADsMem(pszADsParent);

    if (pszADsCommon)
        FreeADsMem(pszADsCommon);


    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPGenObject::get_Name(BSTR * retval)
{
    HRESULT hr;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszADsParent = NULL;
    LPWSTR pszADsCommon = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( (wcslen(_Name) > wcslen(L"<WKGUID=")) &&
         (_wcsnicmp(_Name, L"<WKGUID=", wcslen(L"<WKGUID=")) == 0)) {

        //
        // Replace the name with the DN
        //
        hr = ADsAllocString(_pszLDAPDn, retval);

    }
    else if ( (wcslen(_Name) > wcslen(L"<GUID=")) && 
              (_wcsnicmp(_Name, L"<GUID=", wcslen(L"<GUID=")) == 0)) {

        //
        // Replace the guid with the distinguishedName
        //

        //
        // Get the property from the server (implicit getinfo)
        //
        hr = _pPropertyCache->getproperty(
                        L"distinguishedName",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        pszTempStr = LDAPOBJECT_STRING(ldapSrcObjects.pLdapObjects);


        //
        // Break it down into parent name & common name portions
        //
        hr = BuildADsPathFromLDAPPath2(
                                       (_pszLDAPServer ? TRUE : FALSE),
                                       L"LDAP:",           // does not matter, just a place holder
                                       _pszLDAPServer,
                                       _dwPort,   // doesn't matter
                                       pszTempStr,
                                       &pszADsPath
                                       );
        BAIL_ON_FAILURE(hr);

        hr = BuildADsParentPath(pszADsPath,
                                &pszADsParent,
                                &pszADsCommon);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pszADsCommon, retval);
        
    }
    else {
        hr = ADsAllocString(_Name, retval);
    }

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszADsPath)
        FreeADsMem(pszADsPath);

    if (pszADsParent)
        FreeADsMem(pszADsParent);

    if (pszADsCommon)
        FreeADsMem(pszADsCommon);


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_Class(THIS_ BSTR FAR* retval)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    ULONG ulNumVals = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    PLDAPOBJECT pLdapObject = NULL;
    LPWSTR pszTempStr = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Need to go on wire only if object is bound as in this
    // object is not being create now
    //
    if (!(_dwCorePropStatus & LDAP_CLASS_VALID)
        && _dwObjectState != ADS_OBJECT_UNBOUND) {

        //
        // Get the property from the server (implicit getinfo)
        // and update the property in the
        //
        hr = _pPropertyCache->getproperty(
                        L"objectClass",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }


        ulNumVals = ldapSrcObjects.dwCount;

        pLdapObject = ldapSrcObjects.pLdapObjects;
        //
        // Try and see if we need the first or the last value
        //
        if (_wcsicmp(LDAPOBJECT_STRING(pLdapObject + (ulNumVals - 1)),
                     L"Top")== 0) {

            pszTempStr = LDAPOBJECT_STRING(
                             pLdapObject + 0
                             );
        } else {

            pszTempStr = LDAPOBJECT_STRING(
                             pLdapObject + (ulNumVals - 1)
                             );

        }

        if (_SchemaClass) {
            ADsFreeString(_SchemaClass);
            _SchemaClass = NULL;
        }

        hr = ADsAllocString(pszTempStr, &_SchemaClass);

        if (SUCCEEDED(hr)) {
            _dwCorePropStatus |= LDAP_CLASS_VALID;
        }
    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );


    if (SUCCEEDED(hr)) {
        RRETURN(get_CoreADsClass(retval));
    }

    RRETURN(hr);

}


STDMETHODIMP
CLDAPGenObject::get_Schema(THIS_ BSTR FAR* retval)
{
    BSTR bstrTemp = NULL;

    //
    // We call the get_Class method because that will take care
    // of all the work we need to do in the event that we need
    // read the information from the server. It makes sense to do
    // that rather than repeat the code here.
    //
    HRESULT hr = get_Class(&bstrTemp);

    if (FAILED(hr)) {
        RRETURN(hr);
    }

    if (bstrTemp) {
        SysFreeString(bstrTemp);
    }

    RRETURN(get_CoreSchema(retval));
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPGenObject::get_Count(long FAR* retval)
{
    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantClear(&_vFilter);

    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vHints);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantClear(&_vHints);

    hr = VariantCopy(&_vHints, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    IADs *pADs = NULL;
    BSTR bstrClass = NULL;

    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;
    

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    //
    // Tack on the path component of the child
    // object being retrieved
    //
    hr = BuildADsPathFromParent(
             pszADsPath,
             RelativeName,
             &pszBuffer
             );
    BAIL_ON_FAILURE(hr);


    hr = ::GetObject(
                pszBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Check the class name only if we are not in umi land. In umi
    // land, we will fail the QI for the IID_IADs interface.
    //
    if(ClassName && !(_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)) {
        hr = (*ppObject)->QueryInterface(
                    IID_IADs,
                    (void **)&pADs
                    );
        BAIL_ON_FAILURE(hr);

        hr = pADs->get_Class(&bstrClass);

        BAIL_ON_FAILURE(hr);
    
#ifdef WIN95
        if (_wcsicmp( bstrClass, ClassName )) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrClass,
                -1,
                ClassName,
                -1
                ) != CSTR_EQUAL) {
#endif
            (*ppObject)->Release();
            *ppObject = NULL;
            BAIL_ON_FAILURE(hr=E_ADS_UNKNOWN_OBJECT);
        }
    }

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if ( pADs ) {
        pADs->Release();
    }

    if ( pszBuffer )
        FreeADsMem( pszBuffer );

    if ( bstrClass ) {
        SysFreeString( bstrClass );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = S_OK;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    *retval = NULL;

    hr = CLDAPGenObjectEnum::Create(
                (CLDAPGenObjectEnum **)&penum,
                _ADsPath,
                _pLdapHandle,
                this,
                _vFilter,
                _Credentials,
                _dwOptReferral,
                _dwPageSize
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    BOOL fValid = FALSE;

    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;


    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // No null or empty names for class or rdn.
    //
    if (!ClassName || !*ClassName
        || !RelativeName || !*RelativeName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    hr = CLDAPGenObject::CreateGenericObject(
                    pszADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **) ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;
    BSTR bstrAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    LPTSTR *aValues = NULL;
    int nCount = 0;
    DWORD dwPort = 0;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Check to see if the RelativeName is non empty
    //
    if (bstrRelativeName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    //
    // Tack on the path component of the child object to be
    // deleted
    //
    hr = BuildADsPath(
                pszADsPath,
                bstrRelativeName,
                &bstrAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Compare the class names only if one is given. Null
    // can be used to speed up the delete operation.
    //
    if (bstrClassName) {
        //
        //  Validate the class name first
        //
        hr = LdapReadAttribute(
                        pszLDAPServer,
                        pszLDAPDn,
                        TEXT("objectClass"),
                        &aValues,
                        &nCount,
                        _Credentials,
                        _dwPort
                        );
        BAIL_ON_FAILURE(hr);


        if ( nCount > 0 )
        {
            if ( _tcsicmp( bstrClassName, GET_BASE_CLASS( aValues, nCount) ) != 0 )
            {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    hr = LdapDeleteS(
             _pLdapHandle,
             pszLDAPDn
             );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if ( bstrAbsoluteName ) {
        ADsFreeString( bstrAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {

       FreeADsStr(pszLDAPDn);
    }

    if ( aValues ) {
        LdapValueFree( aValues );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

/*
    RRETURN(CopyObject( SourceName,
                        _ADsPath,
                        _pLdapHandle,
                        _pSchemaInfo,
                        NewName,
                        ppObject ) );

                        */
    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

STDMETHODIMP
CLDAPGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    LPWSTR pszLDAPServer= NULL;
    LPWSTR pszLDAPDn = NULL;
    
    BSTR bstrParent = NULL;
    BSTR bstrName = NULL;
    LPWSTR pszADsPath = NULL;

    HRESULT hr = S_OK;
    LPWSTR pszSrcParent= NULL;
    LPWSTR pszCN = NULL;
    LPWSTR pszRelativeName = NULL;
    BSTR bstrDestADsPath = NULL;
    LPWSTR pszDestLDAPServer = NULL;
    LPWSTR pszDestLDAPDn = NULL;
    LPWSTR pszLDAPServerTemp = NULL;
    LPWSTR pszLDAPSourceDnParent = NULL;
    DWORD dwPort = 0;
    LPBOOL lpBoolVal = NULL;

    // Variables need to conver wide char to ANSI format
    DWORD dwOptions = 0;
    int intErr = 0;
    LPSTR pANSIServer = NULL;
    DWORD dwDestLen = 0;
    PADSLDP pSourceLD = NULL;
    BOOL fTryXDom = FALSE;

    LPWSTR pszDestLDAPRelativeName = NULL;

    LDAPControl     RenExtInfoControl =
                    {
                        LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W,
                        {
                            0, NULL
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &RenExtInfoControl,
                        NULL
                    };

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Build the source paths of the object
    // being moved
    //
    hr = BuildADsParentPath(
             SourceName,
             &pszSrcParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             SourceName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (!pszSrcParent) {
        //
        // If we cannot get the parent, then we cannot move this object.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // We need the dn to the parent of the object being moved.
    //
    hr = BuildLDAPPathFromADsPath2(
             pszSrcParent,
             &pszLDAPServerTemp,
             &pszLDAPSourceDnParent,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);


    //
    // set the right value of relative distinguished name
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //
    if (NewName != NULL) {
        pszRelativeName = NewName;

    } else {
        pszRelativeName = pszCN;
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);

    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(
             bstrParent,
             bstrName,
             &pszADsPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // Build the destination ADsPath of the object being moved.
    //
    hr = BuildADsPath(
             pszADsPath,
             pszRelativeName,
             &bstrDestADsPath
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrDestADsPath,
             &pszDestLDAPServer,
             &pszDestLDAPDn,
             &dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // ADSI needs to escape /, but on server side, / is not a special character. So if someone passes
    // in rdn but has ADSI type escaping, we need to convert it to ldap type path, otherwise server will
    // reject this kind of rdn
    //
    hr = GetLDAPTypeName(
    	     pszRelativeName,
    	     &pszDestLDAPRelativeName
    	     );

    BAIL_ON_FAILURE(hr); 
    
    //
    // LdapModDNS uses ldap_modrdn2_s. This function is used to
    // rename the object not to really move it. If the path of this
    // container and the parentDN of the object being moved here are
    // not the same, we need to use ldapRenameExt instead.
    //
#ifdef WIN95
    if (!_wcsicmp(_pszLDAPDN, pszLDAPSourceDnParent)) {
#else
    if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        _pszLDAPDn,
                        -1,
                        pszLDAPSourceDnParent,
                        -1
                    ) == CSTR_EQUAL ) {
#endif

        //
        // They have the same parent, so we can use LdapModDnS.
        //
        hr = LdapModDnS(
                 _pLdapHandle,
                 pszLDAPDn,
                 pszDestLDAPRelativeName,
                 TRUE
                 );
    } 
    else {
        //
        // Since the object is not in this container, we need to use
        // the renameExt call.
        //
        hr = LdapRenameExtS(
                 _pLdapHandle,
                 pszLDAPDn,
                 pszDestLDAPRelativeName,
                 _pszLDAPDn,
                 TRUE,
                 NULL,
                 NULL
                 );
    }

    // if there was an error it maybe because the move should
    // be across the domains.
    if (FAILED(hr)) {

        intErr = ldap_get_option(
                      _pLdapHandle->LdapHandle,
                      LDAP_OPT_VERSION,
                      &dwOptions
                      );

        //
        // Only if server is V3 and if the server names are not
        // the same will we attempt the extended rename operation.
        // is there are a better way to decide ?
        //

        if (!pszDestLDAPServer) {
            //
            // This object does not have a server, we should
            // read it and then use that as the target server.
            //

            // If this call succeeds, it will copy the servername
            // to the ptr, even if it fails, there should not be problem
            // of memory leak
            //
            GetActualHostName(&pszDestLDAPServer);
            
        } // if !pszDestLDAPServer

        //
        // Try the XDom move only if we have no match on the server
        // names. Note that there is small chance that we will call
        // crossdom when both are serverless but that should be rare
        // as the ModDN call should have succeeded.
        // If the source server is NULL, LDAPOpenObject will handle
        // that case. The target can never be NULL for XDOm.
        //
        if (dwOptions == LDAP_VERSION3 && pszDestLDAPServer) {
            if (!pszLDAPServer) {
                //
                // One server is set the other is not.
                //
                fTryXDom = TRUE;
            }
#ifdef WIN95
            else if (_wcsicmp(pszLDAPServer, pszDestLDAPServer)) {
#else
            else if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        pszLDAPServer,
                        -1,
                        pszDestLDAPServer,
                        -1
                    ) != CSTR_EQUAL ) {
#endif
                //
                // Only if both the servers are different.
                //
                fTryXDom = TRUE;
            }
        }

        if (fTryXDom) {
            //
            // The move request has to go to the server that has
            // the object not the target server.
            //
            dwDestLen = _tcslen(pszDestLDAPServer);
            pANSIServer = (LPSTR)LocalAlloc(LPTR, dwDestLen * 2);

            if (!pANSIServer) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            intErr = LdapUnicodeToUTF8(
                         pszDestLDAPServer,
                         dwDestLen,
                         pANSIServer,
                         dwDestLen * 2
                         );

            /*
            intErr = WideCharToMultiByte(
                         CP_OEMCP,
                         WC_DEFAULTCHAR,
                         pszDestLDAPServer,
                         dwDestLen,
                         pANSIDestServer,
                         dwDestLen * 2,
                         NULL,
                         lpBoolVal
                         );
            */

            if (!intErr) {
                // note that there has to be a valid hr from the
                // previous LdapModDN call to be here.
                BAIL_ON_FAILURE(hr);
            }


            // Update the control information
            RenExtInfoControl.ldctl_value.bv_len = strlen(pANSIServer);
            RenExtInfoControl.ldctl_value.bv_val = pANSIServer;

            CCredentials Credentials = _Credentials;

            //
            // Add request delegation flag
            //
            Credentials.SetAuthFlags(
                            _Credentials.GetAuthFlags()
                            | ADS_USE_DELEGATION
                            );


            hr = LdapOpenObject(
                     pszLDAPServer,
                     pszLDAPDn,
                     &pSourceLD,
                     Credentials,
                     dwPort
                     );
            BAIL_ON_FAILURE(hr);


            hr = LdapRenameExtS(
                     pSourceLD,
                     pszLDAPDn,
                     pszDestLDAPRelativeName,
                     _pszLDAPDn,
                     TRUE,
                     ServerControls,
                     NULL
                     );

        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // We do not need to pass the class name - even if we do it
    // is not used
    //
    hr = GetObject(
            NULL,
            pszDestLDAPRelativeName,
            (IDispatch **)ppObject
            );


error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if(pszSrcParent){
        FreeADsStr(pszSrcParent);
    }

    if(pszCN){
        FreeADsStr(pszCN);
    }

    if(bstrDestADsPath){
        ADsFreeString(bstrDestADsPath );
    }

    if(pszDestLDAPServer){
        FreeADsStr(pszDestLDAPServer);
    }

    if(pszDestLDAPDn){
        FreeADsStr(pszDestLDAPDn);
    }


    if(pszLDAPServer){
        FreeADsStr(pszLDAPServer);
    }

    if(pszLDAPDn){
        FreeADsStr(pszLDAPDn);
    }

    if (pszLDAPServerTemp) {
        FreeADsStr(pszLDAPServerTemp);
    }

    if (pszLDAPSourceDnParent) {
        FreeADsStr(pszLDAPSourceDnParent);
    }

    if (pANSIServer) {
        LocalFree(pANSIServer);
    }

    if (pSourceLD) {
        LdapCloseObject(pSourceLD);
    }

    if (pszDestLDAPRelativeName) {
    	FreeADsStr(pszDestLDAPRelativeName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::AllocateGenObject(
    LPWSTR pszClassName,
    CCredentials &Credentials,
    CLDAPGenObject ** ppGenObject
    )
{
    CLDAPGenObject FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CLDAPGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsObjectOptions,
                           (IADsObjectOptions *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsDeleteOps,
                           (IADsDeleteOps *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *) pGenObject,
                        (IGetAttributeSyntax *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);


    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pGenObject;

    RRETURN_EXP_IF_ERR(hr);

}

//
// IADsObjOptPrivate methods, IADsObjectOptions are wrapped
// around this.
//

STDMETHODIMP
CLDAPGenObject::GetOption(
    DWORD dwOption,
    void *pValue
    )
{

    HRESULT hr = S_OK;
    CtxtHandle hCtxtHandle;
    DWORD dwErr = 0;
    ULONG ulFlags = 0;

    if (!pValue) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    switch( dwOption ) {

    case LDP_CACHE_ENTRY:
        *((PADSLDP *) pValue) = _pLdapHandle;
        break;

    case LDAP_HANDLE:
        *((LDAP **) pValue) = _pLdapHandle ? _pLdapHandle->LdapHandle : (LDAP *) NULL;
        break;

    case LDAP_SERVER:
    	//
    	// pValue here is expected to be a pointer to LPWSTR
    	//
        hr = GetActualHostName((LPWSTR *)pValue);
        break;

    case LDAP_DN:
        *((LPWSTR *) pValue) = _pszLDAPDn;
        break;

    case LDAP_CHASE_REFERRALS:
        *((DWORD *) pValue) = _dwOptReferral;
        break;

    case LDAP_PAGESIZE:
        *((DWORD *) pValue) = _dwPageSize;
        break;

    case LDAP_SECURITY_MASK:
        *((SECURITY_INFORMATION*) pValue) = _seInfo;
        break;

    case LDAP_MUTUAL_AUTH_STATUS:
        dwErr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_SECURITY_CONTEXT,
                    (void *) &hCtxtHandle
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

#if (!defined(WIN95))
        dwErr = QueryContextAttributesWrapper(
                    &hCtxtHandle,
                    SECPKG_ATTR_FLAGS,
                    (void *) &ulFlags
                    );
        if (dwErr) {
            if (dwErr == SEC_E_INVALID_HANDLE) {
                //
                // This will happen when SSL is used for certain.
                //
                hr = E_ADS_BAD_PARAMETER;
            } 
            else {
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            BAIL_ON_FAILURE(hr);
        }
#else
        ulFlags = 0;
#endif

        *((ULONG *) pValue) = ulFlags;
        break;

    case LDAP_MEMBER_HAS_RANGE :
        *((BOOL *) pValue) = _fRangeRetrieval;
        break;

    default:
        *((DWORD *) pValue) = 0;
        hr = E_ADS_BAD_PARAMETER;

    }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::SetOption(
    DWORD dwOption,
    void *pValue
    )
{

    HRESULT hr = S_OK;
    int ldaperr = 0;
    void *ldapOption = 0;

    switch (dwOption) {

    case LDAP_CHASE_REFERRALS:

        switch (*((DWORD *)pValue) ) {

        case ADS_CHASE_REFERRALS_NEVER:
            _dwOptReferral = (DWORD) (DWORD_PTR) LDAP_OPT_OFF;
            break;

        case ADS_CHASE_REFERRALS_SUBORDINATE:
            _dwOptReferral = LDAP_CHASE_SUBORDINATE_REFERRALS;
            break;

        case ADS_CHASE_REFERRALS_EXTERNAL:
            _dwOptReferral = LDAP_CHASE_EXTERNAL_REFERRALS;
            break;

        case ADS_CHASE_REFERRALS_ALWAYS:
            _dwOptReferral = (DWORD) (DWORD_PTR) LDAP_OPT_ON;
            break;

        default:
            RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
        }

        break;

    case LDAP_PAGESIZE:
        _dwPageSize = *((DWORD *)pValue);
        break;

    case LDAP_SECURITY_MASK:
        _seInfo = *((SECURITY_INFORMATION *) pValue);
        _fExplicitSecurityMask = TRUE;
        break;

    default:

        hr = E_ADS_BAD_PARAMETER;
        break;
    }

    RRETURN_EXP_IF_ERR( hr );

}


//
// IADsObjecOptions methods - wrapper around IADsObjOptPrivate
//

STDMETHODIMP
CLDAPGenObject::GetOption(
    THIS_ long lnControlCode,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerTemp = NULL;
    
    ULONG ulMutualAuth = 0;

    VariantInit(pvProp);

    switch (lnControlCode) {

    case ADS_OPTION_SERVERNAME:

        hr = GetOption(LDAP_SERVER, (void *) &pszServerTemp);
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_BSTR;

        hr = ADsAllocString(
                 pszServerTemp,
                 &(pvProp->bstrVal)
                 );
        break;

    case ADS_OPTION_SECURITY_MASK:
        //
        // No need to call GetOpion at least not now
        //
        pvProp->vt = VT_I4;
        pvProp->lVal = (ULONG) _seInfo;
        break;

    case ADS_OPTION_REFERRALS :
        pvProp->vt = VT_I4;

        switch (_dwOptReferral) {

        case ((DWORD) (DWORD_PTR)LDAP_OPT_OFF) :
            pvProp->lVal = ADS_CHASE_REFERRALS_NEVER;
            break;

        case LDAP_CHASE_SUBORDINATE_REFERRALS :
            pvProp->lVal = ADS_CHASE_REFERRALS_SUBORDINATE;
            break;

        case LDAP_CHASE_EXTERNAL_REFERRALS :
            pvProp->lVal = ADS_CHASE_REFERRALS_EXTERNAL;
            break;

        case ((DWORD) (DWORD_PTR)LDAP_OPT_ON) :
            pvProp->lVal = ADS_CHASE_REFERRALS_ALWAYS;
            break;

        default:
            pvProp->lVal = 0;
            hr = E_ADS_PROPERTY_INVALID;

        }

        break;

    case ADS_OPTION_PAGE_SIZE :
        pvProp->vt = VT_I4;
        pvProp->lVal = (ULONG) _dwPageSize;
        break;

    case ADS_OPTION_MUTUAL_AUTH_STATUS :
        hr = GetOption(LDAP_MUTUAL_AUTH_STATUS, (void *) &ulMutualAuth);
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_I4;
        pvProp->lVal = ulMutualAuth;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
    }

error :

	if (pszServerTemp) {
		FreeADsStr(pszServerTemp);
	}
	
    RRETURN(hr);
}

STDMETHODIMP
CLDAPGenObject::SetOption(
    THIS_ long lnControlCode,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwOptVal = 0;
    VARIANT *pvProp = NULL;

    //
    // To make sure we handle variant by refs correctly.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    switch (lnControlCode) {
    case ADS_OPTION_REFERRALS :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr))
            hr = SetOption(LDAP_CHASE_REFERRALS, (void *) &dwOptVal);

        break;

    case ADS_OPTION_PAGE_SIZE :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr))
            hr = SetOption(LDAP_PAGESIZE, (void *) &dwOptVal);

        break;

    case ADS_OPTION_SECURITY_MASK :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr)) {
            _seInfo = (SECURITY_INFORMATION) dwOptVal;
            _fExplicitSecurityMask = TRUE;
        }
         
        break;

    case ADS_PRIVATE_OPTION_SPECIFIC_SERVER :

        //
        // If it is just a VT_BSTR, then this is old.
        // If this is an array, then it should also 
        // have the domain information.
        //
        if (pvProp->vt == VT_BSTR) {

            if (gpszStickyDomainName) {
                FreeADsStr(gpszStickyDomainName);
                gpszStickyDomainName = NULL;
            }

            if (gpszStickyServerName) {
                FreeADsStr(gpszStickyServerName);
                gpszStickyServerName = NULL;
            }
            //
            // Set for LDAP layer
            //
            if (pvProp->bstrVal) {
                gpszStickyServerName = AllocADsStr(pvProp->bstrVal);

                if (!gpszStickyServerName) {
                    hr = E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr)) {
                hr = LdapcSetStickyServer(NULL, pvProp->bstrVal);
            }
        }
        else if ((pvProp->vt & VT_ARRAY)) {
            hr = SetStickyServerWithDomain(pvProp);
        }

        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
    }

    RRETURN(hr);
}


HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pvarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // Although no known automation controller passes
    // VT_VARIANT|VT_BYREF into get_/put_ function
    // as a reference to an array, we carry out the following
    // check for extra safety.
    //
    pvarData = &varData;
    if (V_VT(pvarData) == (VT_VARIANT|VT_BYREF)) {
    pvarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pvarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvarData) ==  (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pvarData,
                  &pVarArray,
                  &dwNumValues
                  );
        // returns E_FAIL if *pvarData is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                
        BAIL_ON_FAILURE(hr);

    } else {

        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}


HRESULT
ConvertVariantToLdapValues(
    VARIANT varData,
    LPWSTR szPropertyName,
    PDWORD pdwControlCode,
    LDAPOBJECTARRAY * pldapDestObjects,
    PDWORD pdwSyntaxId,
    LPWSTR pszServer,
    CCredentials* pCredentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;
    PVARIANT pVar = NULL;
    BOOL fNTDSType = TRUE;
    BOOL fGenTime = FALSE;
    DWORD dwServerSyntaxId = 0;


    if (V_VT(&varData) != VT_DISPATCH) {

        if (V_VT(&varData) != (VT_VARIANT | VT_BYREF)) {

            RRETURN (hr = DISP_E_TYPEMISMATCH);
        }
        else {

            pVar = V_VARIANTREF(&varData);

            if (pVar == NULL || V_VT(pVar) != VT_DISPATCH) {

                RRETURN (hr = DISP_E_TYPEMISMATCH);
            }
            else {
                pDispatch = V_DISPATCH(pVar);
            }
        }
    }
    else {
        pDispatch = V_DISPATCH(&varData);
    }


    VariantInit(&varValues);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        //
        // At this point it is probably cheaper to read the
        // server type and send the values to the conversion
        // routines than to check if this is a securityDescriptor
        // by walking the PropertyEntry and then looking at the variant.
        // There is a good chance that this information is already cached.
        //

        hr = ReadServerType(
                         pszServer,
                         pCredentials,
                         &fNTDSType
                         );
        BAIL_ON_FAILURE(hr);


        hr = PropVariantToAdsType2(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues,
                    pszServer,
                    pCredentials,
                    fNTDSType
                    );
        BAIL_ON_FAILURE(hr);

        if (dwAdsType == ADSTYPE_UTC_TIME) {
            //
            // See if this is a GenTime on the server
            //
            HRESULT hr;
            hr = LdapGetSyntaxOfAttributeOnServer(
                     pszServer,
                     szPropertyName,
                     &dwServerSyntaxId,
                     *pCredentials,
                     dwPort
                     );

            if (FAILED(hr)) {
                hr = S_OK;
            }
            else if (dwServerSyntaxId == LDAPTYPE_GENERALIZEDTIME) {
                fGenTime = TRUE;
            }
        }

        hr = AdsTypeToLdapTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    pldapDestObjects,
                    pdwSyntaxId,
                    fGenTime
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwControlCode = dwControlCode;

cleanup:

    if (bstrPropName) {
        ADsFreeString(bstrPropName);
    }

    if (pAdsValues) {
        AdsTypeFreeAdsObjects(
                pAdsValues,
                dwNumValues
                );
    }

    if (pVarArray) {

        FreeVariantArray(
                pVarArray,
                dwAdsValues
                );
    }

    if (pPropEntry) {

        pPropEntry->Release();
    }

    VariantClear(&varValues);

    RRETURN(hr);

error:

    LdapTypeFreeLdapObjects( pldapDestObjects );

    goto cleanup;

}


HRESULT
MapAdsTypeToLdapType(
    BSTR bstrPropName,
    DWORD dwAdsType,
    PDWORD pdwLdapType
    )
{
    RRETURN(S_OK);
}



HRESULT
ConvertLdapValuesToVariant(
    BSTR bstrPropName,
    LDAPOBJECTARRAY * pldapSrcObjects,
    DWORD dwLdapType,
    DWORD dwControlCode,
    PVARIANT pVarProp,
    LPWSTR pszServer,
    CCredentials* pCredentials
    )
{
    HRESULT hr = S_OK;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwNumValues = 0;
    DWORD dwAdsType = 0;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    BOOL fNTDS = TRUE;

    VariantInit(&varData);
    VariantClear(&varData);
    VariantInit(pVarProp);

    // pldaSrcObject should never be null
    ADsAssert(pldapSrcObjects);

    if (dwControlCode != ADS_PROPERTY_DELETE ) {

        hr = LdapTypeToAdsTypeCopyConstruct(
                 *pldapSrcObjects,
                 dwLdapType,
                 &pAdsValues,
                 &dwNumAdsValues,
                 &dwAdsType
                 );

        if (SUCCEEDED(hr)) {

            dwNumValues = pldapSrcObjects->dwCount;

            //
            // if the property is a security descriptor
            // we need to set the server type also
            //

            if (dwAdsType == ADSTYPE_NT_SECURITY_DESCRIPTOR) {

                hr = ReadServerType(
                         pszServer,
                         pCredentials,
                         &fNTDS
                         );
                BAIL_ON_FAILURE(hr);

                hr = AdsTypeToPropVariant2(
                         pAdsValues,
                         dwNumValues,
                         &varData,
                         pszServer,
                         pCredentials,
                         fNTDS
                         );

            } else {

                hr = AdsTypeToPropVariant(
                         pAdsValues,
                         dwNumValues,
                         &varData
                         );
            }

            BAIL_ON_FAILURE(hr);

        } else {

            // We could not convert the data type
            // This maybe because we have the invalid data type
            // so we will just return the variant data as null
            // and also set the data type to 0 or invalid in that case
            if (dwLdapType == LDAPTYPE_UNKNOWN) {
                dwAdsType = 0;
                hr = S_OK;
            } else {
                // since the datatpye was valid, we should
                // send this back to the user.
                BAIL_ON_FAILURE(hr);
            }

        }
    } else {

        dwAdsType = 0;

    }

    hr = CreatePropEntry(
            bstrPropName,
            dwAdsType,
            dwNumValues,
            dwControlCode,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pVarProp) = pDispatch;
    V_VT(pVarProp) = VT_DISPATCH;

error:

    VariantClear(&varData);

    if (pAdsValues) {
       AdsTypeFreeAdsObjects(
            pAdsValues,
            dwNumValues
            );
    }

    RRETURN(hr);
}


//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPGenObject::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CLDAPGenObject::DeleteObject(
    long lnFlags
    )
{
    HRESULT hr = S_OK;

    LDAPControl     SeInfoControlRecursDelete =
                    {
                        LDAP_SERVER_TREE_DELETE_OID_W,

                        { NULL, NULL},

                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControlRecursDelete,
                        NULL
                    };


    hr = LdapDeleteExtS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    (PLDAPControl *)&ServerControls,
                    NULL
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetActualHostName(
    LPWSTR * pValue
    )
{
    HRESULT hr = S_OK;

    DWORD dwLength = MAX_PATH;
    LPWSTR szHostName = NULL;
    int err = 0;

    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    //
    // We need to get at the actual object as we may have a
    // referral
    //
    hr = LdapSearchS(
             _pLdapHandle,
             _pszLDAPDn,
             LDAP_SCOPE_BASE,
             L"(objectClass=*)",
             Attributes,
             0,
             &pMsgResult
             );

    //
    // Only one entry should be returned
    //
    BAIL_ON_FAILURE(hr);

    hr = LdapFirstEntry(
             _pLdapHandle,
             pMsgResult,
             &pMsgEntry
             );
    BAIL_ON_FAILURE(hr);

    pLdapCurrent = pMsgResult->Connection;

    err = ldap_get_optionW(
              pLdapCurrent,
              LDAP_OPT_HOST_NAME,
              &szHostName
              );

    if (err != LDAP_SUCCESS || szHostName == NULL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // If we are here we need to copy the name and return

    *pValue = AllocADsStr(szHostName);
    if(!(*pValue)) {
    	hr = E_OUTOFMEMORY;
    	BAIL_ON_FAILURE(hr);
    }
    
    
error:

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    RRETURN(hr);
}

HRESULT
GetIntegerFromVariant(
    VARIANT* pvProp,
    DWORD* pdwVal)
{
    HRESULT hr = S_OK;

    *pdwVal = 0;

    if (pvProp->vt == VT_I4) {

        *pdwVal = pvProp->lVal;

    }
    else if(pvProp->vt == VT_I2) {

        *pdwVal = pvProp->iVal;

    } else
        hr = E_ADS_BAD_PARAMETER;

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   TraceTreeForClass
//
//  Synopsis: Traces the inheritance hierarchy for the class being crerated
//      and returns the list in the arg pppszNameArr. There are
//      *plnNumElements in this array. This can be used later while
//      creating the object so that all the extensions will be available.
//
//  Arguments:
//      Parent      - The ADsPath of the parent,
//      CommonName  - RDN of the object being created,
//      pszClassName- Class of the object being created,
//      Credentials - Credentials blob,
//      pppszNameArr- Return value - array of names of parent classes.
//      plnNumItems - Return value - number of elements in above array.
//
//-------------------------------------------------------------------------
HRESULT
TraceTreeForClass(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PWCHAR **pppszNameArr,
    PLONG plnNumElements
    )
{
    HRESULT hr = S_OK;
    IADsClass *pIADsClass = NULL;
    IUnknown *pUnk = NULL;

    PWCHAR *pszRetVal = NULL;
    WCHAR pszSchemaPathBase[MAX_PATH];
    WCHAR pszSchemaPath[MAX_PATH];
    LPWSTR pszServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    LPWSTR pszCurVal = NULL;
    DWORD dwPort = 0;
    VARIANT vBstrVal;
    CCredentials Creds = Credentials;
    long lnNumItems = 1;
    BOOL fDone = FALSE;

    PClassesHierarchyList pClassListHead = NULL;
    PClassesHierarchyList pClassListNode = NULL;

    //
    // We need to make sure that the ADS_AUTH_RESERVED flag is not set
    // in the credentials because that will result in us not getting the
    // IADsClass interface ptr we want.
    //
    Creds.SetAuthFlags(Creds.GetAuthFlags() & ~ADS_AUTH_RESERVED);


    VariantInit(&vBstrVal);

    //
    // Build The schema name
    //
    hr = BuildLDAPPathFromADsPath2(
             Parent,
             &pszServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (pszServer) {

        wsprintf(pszSchemaPathBase, L"LDAP://%s", pszServer);

    } else {
        wsprintf(pszSchemaPathBase, L"LDAP:/");
    }

    pszCurVal = AllocADsStr(pszClassName);

    if (!pszCurVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    while (!fDone && _wcsicmp(L"Top", pszCurVal)) {

        lnNumItems++;
        //
        // Add a new node to the list
        //
        pClassListNode = (PClassesHierarchyList)
                            AllocADsMem(sizeof(ClassesHierarchyList));
        if (!pClassListNode) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassListNode->pszClassName = AllocADsStr(pszCurVal);
        if (!pClassListNode->pszClassName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassListNode->pNext = pClassListHead;
        pClassListHead = pClassListNode;

        //
        // Check for the next class on the list
        //
        wsprintf(pszSchemaPath, L"%s", pszSchemaPathBase);
        wcscat(pszSchemaPath, L"/Schema/");
        wcscat(pszSchemaPath, pszCurVal);

        FreeADsStr(pszCurVal);
        pszCurVal = NULL;

        hr = GetObject(
                 pszSchemaPath,
                 Credentials,
                 (LPVOID *) &pUnk
                 );

        BAIL_ON_FAILURE(hr);

        hr = pUnk->QueryInterface(
                  IID_IADsClass,
                  (void **) &pIADsClass
                  );
        BAIL_ON_FAILURE(hr);

        //
        // Release the ref on the pUnk
        //
        pUnk->Release();
        pUnk = NULL;

        hr = pIADsClass->get_DerivedFrom(&vBstrVal);

        BAIL_ON_FAILURE(hr);

        //
        // Release the ptr as we no longer need it.
        //
        pIADsClass->Release();


        if (vBstrVal.vt == (VT_VARIANT | VT_ARRAY)) {
            //
            // Server has complete list of classes in schema
            //
            hr = AddToClassesList(
                     vBstrVal,
                     &pszCurVal,
                     &pClassListHead,
                     &lnNumItems
                     );
            BAIL_ON_FAILURE(hr);

            //
            // add one to the count for the value passed in
            //
            lnNumItems++;
            fDone = TRUE;
        }
        else if (vBstrVal.vt == VT_BSTR) {

            pszCurVal = AllocADsStr(vBstrVal.bstrVal);
            VariantClear(&vBstrVal);
            if (!pszCurVal) {
                hr = E_OUTOFMEMORY;
            }
        }
        else {
            hr = E_FAIL;
        }

        BAIL_ON_FAILURE(hr);

    }

    //
    // We now have the list as well as the number of items
    //
    pszRetVal = (PWCHAR *) AllocADsMem(sizeof(PWCHAR) * (lnNumItems + 1));

    if (!pszRetVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Do not move as we may call -- below
    //
    *plnNumElements = lnNumItems;

    pszRetVal[lnNumItems] = NULL;

    if (!fDone) {
        //
        // Add top to the list and set last to NULL
        // only if we did not hit addclasses fn.
        //
        pszRetVal[lnNumItems - 1] = AllocADsStr(L"Top");
        if (!pszRetVal[lnNumItems - 1]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        lnNumItems--;
    }

    while (pClassListHead && (lnNumItems > -1)) {

        pszRetVal[--lnNumItems] =
                AllocADsStr(pClassListHead->pszClassName);

        if (!pszRetVal[lnNumItems]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Free the entry and advance list
        //
        FreeADsStr(pClassListHead->pszClassName);
        pClassListNode = pClassListHead;
        pClassListHead = pClassListHead->pNext;
        FreeADsMem(pClassListNode);
        pClassListNode = NULL;
    }

    //
    // Put appropriate value in return arg.
    //
    *pppszNameArr = pszRetVal;

error:

    if (pszServer) {
        FreeADsStr(pszServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if (pszCurVal) {
        FreeADsStr(pszCurVal);
    }

    if (pUnk) {
        pUnk->Release();
    }
    //
    // Walk through and free the list if necessary
    //
    while (pClassListHead) {

        pClassListNode = pClassListHead;

        if (pClassListHead->pszClassName) {
            FreeADsStr(pClassListHead->pszClassName);
        }

        pClassListHead = pClassListHead->pNext;
        FreeADsMem(pClassListNode);
    }


    RRETURN(hr);
}

//
// Helper to get the values from the Variant and add to list
//
HRESULT
AddToClassesList(
    VARIANT vProps,
    LPWSTR *ppszCurClass,
    PClassesHierarchyList *ppClassListHead,
    PLONG  plnNumItems
    )
{
    HRESULT hr = S_OK;
    PClassesHierarchyList pClassNode = NULL;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0, i = 0;

    pvProp = &vProps;

    hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
    BAIL_ON_FAILURE(hr);

    //
    // Go through the array adding nodes.
    //
    for (i = 0; i < dwNumValues; i++) {

        pvProp = pVarArray + i;
        if (pvProp->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Alloc node to add
        //
        pClassNode = (PClassesHierarchyList)
                            AllocADsMem(sizeof(ClassesHierarchyList));

        if (!pClassNode) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNode->pszClassName = AllocADsStr(pvProp->bstrVal);
        if (!pClassNode->pszClassName) {
            //
            // Free pClassNode as we will let caller free the list
            // if we run out of memory.
            //
            FreeADsMem(pClassNode);
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNode->pNext = *ppClassListHead;
        *ppClassListHead  = pClassNode;
    } // end for

    *plnNumItems = dwNumValues;
error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


//
// Helper routine that handles setting the sticky server private
// option when the input is an array.
//
HRESULT
SetStickyServerWithDomain(
    PVARIANT pvProp
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvVarArray = NULL;
    DWORD dwNumVariants = 0;
    DWORD dwCtr = 0;
    LPWSTR *ppszStringArray = NULL;

    hr = ConvertSafeArrayToVariantArray(
             *pvProp,
             &pvVarArray,
             &dwNumVariants
             );

    // returns E_FAIL if vProperties is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
    BAIL_ON_FAILURE(hr);

    //
    // There have to be precisely 2 entries, one for domain
    // and the second for the serverName.
    //
    if (dwNumVariants != 2) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    hr = ConvertVariantArrayToLDAPStringArray(
             pvVarArray,
             &ppszStringArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    if (!ppszStringArray
        || !ppszStringArray[0]
        || !*(ppszStringArray[0])
        || !ppszStringArray[1]
        || !*(ppszStringArray[1])
        ) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (gpszStickyServerName) {
        FreeADsStr(gpszStickyServerName);
        gpszStickyServerName = NULL;
    }

    if (gpszStickyDomainName) {
        FreeADsStr(gpszStickyDomainName);
        gpszStickyDomainName = NULL;
    }

    gpszStickyServerName = AllocADsStr(ppszStringArray[1]);
    if (!gpszStickyServerName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    gpszStickyDomainName = AllocADsStr(ppszStringArray[0]);
    if (!gpszStickyDomainName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = LdapcSetStickyServer(
             gpszStickyDomainName,
             gpszStickyServerName
             );

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        //
        // Clear the global strings on failure.
        //
        if (gpszStickyServerName) {
            FreeADsStr(gpszStickyServerName);
            gpszStickyServerName = NULL;
        }

        if (gpszStickyDomainName) {
            FreeADsStr(gpszStickyDomainName);
            gpszStickyDomainName = NULL;
        }
    }

    //
    // Cleanup variant array and string array.
    //
    if (pvVarArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            VariantClear(pvVarArray + dwCtr);
        }
        FreeADsMem(pvVarArray);
    }

    if (ppszStringArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            if (ppszStringArray[dwCtr])
                FreeADsStr(ppszStringArray[dwCtr]);
        }
        FreeADsMem(ppszStringArray);
    }

    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumsch.cxx
//
//  Contents:  LDAP Schema Enumeration Code
//
//             CLDAPSchemaEnum::CLDAPSchemaEnum()
//             CLDAPSchemaEnum::CLDAPSchemaEnum
//             CLDAPSchemaEnum::EnumObjects
//             CLDAPSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPSchemaEnum::Create(
    CLDAPSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrServerPath,
    VARIANT vFilter,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CLDAPSchemaEnum FAR* penumvariant = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    *ppenumvariant = NULL;

    penumvariant = new CLDAPSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrServerPath, &penumvariant->_bstrServerPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(bstrADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = SchemaOpen(
             bstrServerPath,
             &(penumvariant->_hSchema),
             Credentials,
             pObjectInfo->PortNumber
             );
    BAIL_ON_FAILURE(hr);

    hr = SchemaGetObjectCount(
             penumvariant->_hSchema,
             &(penumvariant->_nNumOfClasses),
             &(penumvariant->_nNumOfProperties) );
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
             vFilter,
             &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CLDAPSchemaEnum::CLDAPSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrServerPath( NULL ),
      _hSchema( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _nNumOfClasses( 0 ),
      _nNumOfProperties( 0 )
{
}

CLDAPSchemaEnum::~CLDAPSchemaEnum()
{
    ADsFreeString( _bstrADsPath );
    ADsFreeString( _bstrServerPath );

    if ( _hSchema )
    {
        SchemaClose( &_hSchema );
    }

    if ( _pObjList != NULL )
    {
        delete _pObjList;
        _pObjList = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr;
    switch (ObjectType)
    {
        case LDAP_CLASS_ID:
            hr = EnumClasses(cElements, pvar, pcElementFetched);
            break;

        case LDAP_PROPERTY_ID:
            hr = EnumProperties(cElements, pvar, pcElementFetched);
            break;

        case LDAP_SYNTAX_ID:
            hr = EnumSyntaxObjects(cElements, pvar, pcElementFetched);
            break;

        default:
            hr = S_FALSE;

    }
    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    CLASSINFO *pClassInfo = NULL;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= _nNumOfClasses )
        goto error;

    hr = SchemaGetClassInfoByIndex(
             _hSchema,
             _dwCurrentEntry,
             &pClassInfo );
    BAIL_ON_FAILURE(hr); 

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {

        //
        // If we are in Umi land, then we cannot ask for dispatch.
        //
        hr = CLDAPClass::CreateClass(
                            _bstrADsPath,
                            _hSchema,
                            pClassInfo->pszName,
                            pClassInfo,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            (void **) ppDispatch
                            );
    } 
    else {
        
        hr = CLDAPClass::CreateClass(
                            _bstrADsPath,
                            _hSchema,
                            pClassInfo->pszName,
                            pClassInfo,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    }
    
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;


    RRETURN(S_OK);

error:


    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CLDAPSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PROPERTYINFO *pPropertyInfo = NULL;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= _nNumOfProperties )
        goto error;

    hr = SchemaGetPropertyInfoByIndex(
             _hSchema,
             _dwCurrentEntry,
             &pPropertyInfo );
    BAIL_ON_FAILURE(hr);

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // In Umi land ask for IID_IUnknown.
        //
        hr = CLDAPProperty::CreateProperty(
                    _bstrADsPath,
                    _hSchema,
                    pPropertyInfo->pszPropertyName,
                    pPropertyInfo,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    (void **)ppDispatch
                    );

    } 
    else {
        hr = CLDAPProperty::CreateProperty(
                    _bstrADsPath,
                    _hSchema,
                    pPropertyInfo->pszPropertyName,
                    pPropertyInfo,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );
    }

    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CLDAPSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cLDAPSyntax )
        goto error;

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // In Umi land ask for IID_IUnknown not dispatch.
        //
        hr = CLDAPSyntax::CreateSyntax(
                            _bstrADsPath,
                            &g_aLDAPSyntax[_dwCurrentEntry],
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            (void **)ppDispatch
                            );
    } 
    else {
        hr = CLDAPSyntax::CreateSyntax(
                            _bstrADsPath,
                            &g_aLDAPSyntax[_dwCurrentEntry],
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    }

    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cextmgr.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr(
    IUnknown FAR * pUnkOuter
    ):
    _pUnkOuter(pUnkOuter),
    _pClassEntry(NULL),
    _pDispMgr(NULL),
    _pCreds(NULL),
    _fExtensionsLoaded(FALSE)
{
}


//
// Static create to handle multiple classes
//
HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPWSTR pszClassNames[],
    long lnNumClasses,
    CCredentials *pCreds,
    CADsExtMgr ** ppExtMgr
    )
{
    long lnCtr = 0;
    long lnInc = 1;

    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr(pUnkOuter);
    if (!pExtMgr)
        RRETURN(E_OUTOFMEMORY);

    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;
    pExtMgr->_pCreds = pCreds;

    if (_tcsicmp(pszClassNames[lnNumClasses-1], TEXT("Top")) == 0)
         lnCtr = 0;
    else
         lnCtr = lnNumClasses - 1;

    lnInc = lnCtr ? -1 : 1;

    //
    // Read the list of extension object of the same class from registry
    //

    hr = ADSIGetExtensionList(
            pszClassNames[lnCtr],
            &(pExtMgr->_pClassEntry)
            );
    BAIL_ON_FAILURE(hr);

    lnCtr += lnInc;

    for (;
        (lnInc == -1) ? (lnCtr > -1) : (lnCtr < lnNumClasses);
        lnCtr += lnInc) {

        hr = ADSIAppendToExtensionList(
                 pszClassNames[lnCtr],
                 &(pExtMgr->_pClassEntry)
                 );

        BAIL_ON_FAILURE(hr);
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr, pCreds - we just keep pointers
    //

}

//
// Instantiate extension objects listed in _pClassEntry as aggregates of
// aggregator _pUnkOuter. Initialize extensions with <Credentials>.
//
// Max Load 127 extensions. Extensions > 127 are silently ignored.
//

HRESULT
CADsExtMgr::LoadExtensions(
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;


    //
    // Extensions (ext mgr) do(es) not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);


    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();


    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {

            //
            // Terminate loading extensions.
            //
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    _pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );


        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any.
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarPassword) = VT_BSTR;

                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName,
                        varPassword,
                        varAuthFlags
                        );

                //
                // Free them as they are reused
                //
                VariantClear(pvarUserName);
                VariantClear(pvarPassword);

            }

        } // end if CoCreateInstance() succeeded


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    VariantClear(pvarUserName);
    VariantClear(pvarPassword);
    VariantClear(pvarAuthFlags);

    if (fReturnError) {
        RRETURN(hr);        // fatal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}


HRESULT 
CADsExtMgr::LoadExtensionsIfReqd()
{
    HRESULT hr = S_OK;

    if(!_fExtensionsLoaded) {
        hr = LoadExtensions(*_pCreds);
        BAIL_ON_FAILURE(hr);
 
        hr = FinalInitializeExtensions(); // this call never fails
        BAIL_ON_FAILURE(hr);

        _fExtensionsLoaded = TRUE;
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {

                hr = LoadExtensionsIfReqd();
                if (FAILED(hr)) {
                    RRETURN(E_NOINTERFACE);
                }

                pUnknown = pExtensionEntry->pUnknown;


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        hr = LoadExtensionsIfReqd();
        if (FAILED(hr)) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    //
    // Not really neede but just in case.
    //
    hr = LoadExtensionsIfReqd();
    if (FAILED(hr)) {
        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet (client bug)
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ADsAssert(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}


//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-27-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{

    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT vDummy;

    VariantInit(&vDummy);

    //
    // Extensions (ext mgr) does not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);

    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            hr = (pExtEntry->pADsExt)->Operate(
                      ADS_EXT_INITIALIZE_COMPLETE,
                      vDummy,
                      vDummy,
                      vDummy
                      );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // We need to return S_OK here as otherwise just because
    // the final initialization of one extension failed - we
    // will hold up the entire lot.
    //
    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForIID  --- used in supporting ICustomInterfaceFactory
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. 
//             If the IID is one of the interfaces implemented by the 
//             extension manager, then the extension's CLSID is returned.
//
// Arguments:  riid      -   Interface ID for which we want to find the CLSID
//             lFlags    -   Reserved. Must be 0.
//             pCLSID    -   Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsExtMgr::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    HRESULT hr = S_OK;

    ADsAssert(!lFlags && pCLSID);

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, riid)) {
                *pCLSID = pExtensionEntry->ExtCLSID;
                RRETURN(S_OK);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = UMI_E_NOT_FOUND);
}

//+---------------------------------------------------------------------------
// Function:   GetObjectByCLSID --- Used for ICustomInterfaceFactory support.
//
// Synopsis:   Returns a pointer to a requested interface on the object
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown on return. The 
//             interface returned is a non-delegating interface on the object.
//
// Arguments:  clsid       -   CLSID of object on which interface 
//                           should be obtained
//             pUnkOuter   -  Aggregating outer unknown
//             riid        -  Interface requested
//             ppInterface -  Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CADsExtMgr::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppInterface
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;
    IUnknown *pPrevUnk = NULL, *pUnknown = NULL;

    ADsAssert(ppInterface && pUnkOuter);

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        if (IsEqualCLSID(pExtensionEntry->ExtCLSID, clsid)) {
           pPrevUnk = _pUnkOuter;

           _pUnkOuter = pUnkOuter;

           hr = LoadExtensionsIfReqd();
           if (FAILED(hr)) {
               _pUnkOuter = pPrevUnk;
               BAIL_ON_FAILURE(hr = E_FAIL);
           }

           pUnknown = pExtensionEntry->pUnknown; 

           if (!pUnknown) {

                BAIL_ON_FAILURE(hr = E_FAIL);
           }

           *ppInterface = pUnknown;
           pUnknown->AddRef();
           BAIL_ON_FAILURE(hr);

           RRETURN(S_OK);
       }

       pExtensionEntry = pExtensionEntry->pNext;
    }

    RRETURN(UMI_E_NOT_FOUND);

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForNames --- Used for ICustomInterfaceFactory support.
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:  rgszNames     -  Names to be mapped
//             cNames        -  Number of names to be mapped
//             lcid          -  Locale in which to interpret the names
//             rgDispId      -  Returns DISPID
//             lFlags        -  Reserved. Must be 0.
//             pCLSID        -  Returns CLSID of object which supports this
//                             property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CADsExtMgr::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;

    ADsAssert(pCLSID && !lFlags && rgszNames && rgDispId);

    if (!_pClassEntry) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    hr = LoadExtensionsIfReqd();
    if (FAILED(hr)) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    pExtension = _pClassEntry->pExtensionHead;

    while (pExtension) {
        if (pExtension->fDisp) {
            //
            // fDisp = TRUE indicates
            //  1)  extension supports pADsExt AND
            //  2)  either
            //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
            //      OR
            //      b) we don't know if a) is true or not yet
            //

            ADsAssert(pExtension->pADsExt);

            hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                     IID_NULL,
                     rgszNames,
                     cNames,
                     lcid,
                     rgDispId
                     );

            if (SUCCEEDED(hr)) {
                *pCLSID = pExtension->ExtCLSID;
                RRETURN(S_OK);
            }
            else if (hr == E_NOTIMPL) {
                //
                // extension object does not support the optional
                // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                // -> remember this in cache & try next extension object
                //
                pExtension->fDisp = FALSE;
            }
        } 

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(hr = DISP_E_UNKNOWNNAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  LDAP Object Enumeration Code
//
//              CLDAPGenObjectEnum::CLDAPGenObjectEnum()
//              CLDAPGenObjectEnum::CLDAPGenObjectEnum
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildLDAPFilterArray(
    VARIANT vFilter,
    LPTSTR  *ppszFilter
);

#define FILTER_BUFFER_LEN 256

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGenObjectEnum::Create(
    CLDAPGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    PADSLDP pLdapHandle,
    IADs *pADs,
    VARIANT vFilter,
    CCredentials& Credentials,
    DWORD dwOptReferral,
    DWORD dwPageSize
    )
{
    HRESULT hr = NOERROR;
    CLDAPGenObjectEnum FAR* penumvariant = NULL;
    TCHAR *pszLDAPServer = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    LPTSTR aStrings[2];
    DWORD dwPort = 0;
    WCHAR **aValues = NULL;
    int nCount = 0;
    DWORD totalCount = 0;
    DWORD dwcEntriesReturned = 0;


    PLDAPControl    pPagedControl = NULL;
    LDAPControl     referralControl =
                    {
                        LDAP_CONTROL_REFERRALS_W,
                        {
                            sizeof( DWORD ), (PCHAR) &dwOptReferral
                        },
                        TRUE
                    };

    PLDAPControl    clientControls[2] =
                    {
                        &referralControl,
                        NULL
                    };


    PLDAPControl    serverControls[2] = {NULL, NULL};
    PLDAPControl    *serverReturnedControls = NULL;

    penumvariant = new CLDAPGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    penumvariant->_dwOptReferral = dwOptReferral;
    penumvariant->_dwPageSize = dwPageSize;

    hr = BuildLDAPFilterArray(
                vFilter,
                &penumvariant->_pszFilter
                );

    if ( FAILED(hr) || !penumvariant->_pszFilter )  // this might happen when vFilter is empty
    {
        hr = S_OK;
        penumvariant->_pszFilter = AllocADsStr(TEXT("(objectClass=*)"));

        if ( penumvariant->_pszFilter == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    penumvariant->_Credentials = Credentials;

    hr = BuildLDAPPathFromADsPath2(
                ADsPath,
                &pszLDAPServer,
                &penumvariant->_pszLDAPDn,
                &dwPort
                );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pLdapHandle = pLdapHandle;

    // Need to AddRef since we are storing the ld that is owned by the object
    pADs->AddRef();
    penumvariant->_pADs = pADs;

    aStrings[0] = TEXT("objectClass");
    aStrings[1] = NULL;


    //
    // Check if paged search control is supported; if so, we will use it.
    //

    hr = ReadPagingSupportedAttr(
                 pszLDAPServer,
                 &penumvariant->_fPagedSearch,
                 Credentials,
                 dwPort
                 ) ;

    if (penumvariant->_fPagedSearch) {

        //
        // In this case we wont to use the ldap paging API
        // wrapper rather than use cookies directly.
        //
        hr = LdapSearchInitPage(
                 penumvariant->_pLdapHandle,
                 penumvariant->_pszLDAPDn,
                 LDAP_SCOPE_ONELEVEL,
                 penumvariant->_pszFilter,
                 aStrings,
                 0,
                 NULL,
                 clientControls,
                 0,
                 0,
                 NULL,
                 &penumvariant->_phPagedSearch
                 );

        if (FAILED(hr) || (penumvariant->_phPagedSearch == NULL)) {
            //
            // Some error in setting up the paged control, default to non
            // paged search.
            //
            penumvariant->_fPagedSearch = FALSE;
        }
    }

    if (!penumvariant->_fPagedSearch) {

        hr = LdapSearchExtS(
                 penumvariant->_pLdapHandle,
                 penumvariant->_pszLDAPDn,
                 LDAP_SCOPE_ONELEVEL,
                 penumvariant->_pszFilter,
                 aStrings,
                 0,
                 NULL,
                 clientControls,
                 NULL,
                 0,
                 &penumvariant->_res
                 );


        //
        // Error out only if there are no entries returned.
        //

        dwcEntriesReturned = LdapCountEntries(
                                 penumvariant->_pLdapHandle,
                                 penumvariant->_res
                                 );

        if (FAILED(hr) && !dwcEntriesReturned) {

            BAIL_ON_FAILURE(hr);
        }

    } // if not do the paged search case
    else {

        if (penumvariant->_fPagedSearch) {

            //
            // Get the first page full of results.
            //
            hr = LdapGetNextPageS(
                     penumvariant->_pLdapHandle,
                     penumvariant->_phPagedSearch,
                     NULL,
                     penumvariant->_dwPageSize,
                     &totalCount,
                     &penumvariant->_res
                     );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {

                penumvariant->_fLastPage = TRUE;
                goto error;

            } else if ((hr == HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED))
                       && totalCount != 0) {

                penumvariant->_fLastPage = TRUE;
                hr = S_OK;

            }

            BAIL_ON_FAILURE(hr);
        }
    } // the paged search case


error:

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer);

     if (pPagedControl) {
         LdapControlFree(pPagedControl);
     }

     if (serverReturnedControls) {
         LdapControlsFree(serverReturnedControls);
     }


    if (FAILED(hr) && !dwcEntriesReturned) {

        if (penumvariant)  delete penumvariant;

        *ppenumvariant = NULL;

    } else {

        //
        // entries successfully retrieved from server, return them
        // to client even if error and let client decide
        //

        *ppenumvariant = penumvariant;
    }


     RRETURN_EXP_IF_ERR(hr);
}


CLDAPGenObjectEnum::CLDAPGenObjectEnum():
    _ADsPath(NULL),
    _fAllEntriesReturned(FALSE),
    _fPagedSearch(FALSE),
    _fLastPage(FALSE),
    _dwOptReferral(LDAP_CHASE_EXTERNAL_REFERRALS),
    _pszFilter(NULL),
    _pszLDAPDn(NULL),
    _phPagedSearch(NULL)

{
    _pObjList = NULL;

    _pLdapHandle = NULL;
    _pADs = NULL;

    _res = NULL;
    _entry = NULL;
}


CLDAPGenObjectEnum::~CLDAPGenObjectEnum()
{
    if ( _res )
        LdapMsgFree( _res );

    if (_pszFilter) {
        FreeADsMem(_pszFilter);
    }

    if (_pszLDAPDn) {
        FreeADsMem(_pszLDAPDn);
    }

    if (_fPagedSearch) {
        LdapSearchAbandonPage(_pLdapHandle, _phPagedSearch);

    }

    if ( _pADs )
        _pADs->Release();

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    if ( _pObjList )
        delete _pObjList;

    _pLdapHandle = NULL;
    _phPagedSearch = NULL;

}

HRESULT
CLDAPGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;  
    BOOL fRepeat = FALSE;
    DWORD dwFailureCount = 0;
    DWORD dwPermitFailure = 1000;

    
    while (i < cElements) {

        hr = GetGenObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }
        else if (FAILED(hr)) {
            //
            // Got an error while retrieving the object, ignore the
            // error and continue with the next object.
            // If continuously getting error more than dwPermitFailure,
            // make the return value S_FALSE, leave the loop.            
            //            
            if (fRepeat) {
            	dwFailureCount++;
            	if(dwFailureCount > dwPermitFailure) {
            		hr = S_FALSE;
            		break;
            	}            	
            }
            else {
            	fRepeat = TRUE;
            	dwFailureCount = 1;
            }
            	                        
            hr = S_OK;
            continue;
        }
        

        if (fRepeat) {
        	fRepeat = FALSE;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    return(hr);
}


HRESULT
CLDAPGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszObjectName = NULL;
    TCHAR **aValues = NULL;
    int nCount = 0;
    DWORD totalCount = 0;
    TCHAR szADsClassName[64];
    LPWSTR aStrings[2] = {TEXT("objectClass"), NULL};

    DWORD  dwPort;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    LPWSTR pszADsPathParent = NULL;

    BOOL   fGCNameSpace = FALSE;


    PLDAPControl    pPagedControl = NULL;
    PLDAPControl    serverControls[2] = {NULL, NULL};
    PLDAPControl    *serverReturnedControls = NULL;

    LDAPControl     referralControl =
                    {
                        LDAP_CONTROL_REFERRALS_W,
                        {
                            sizeof( DWORD ), (PCHAR) &_dwOptReferral
                        },
                        TRUE
                    };

    PLDAPControl    clientControls[2] =
                    {
                        &referralControl,
                        NULL
                    };

    OBJECTINFO ObjectInfoLocal;

    memset(&ObjectInfoLocal, 0, sizeof(OBJECTINFO));

    *ppDispatch = NULL;

    if ( _fAllEntriesReturned )
    {
        hr = S_FALSE;
        goto error;
    }

    if ( _entry == NULL )
        hr = LdapFirstEntry( _pLdapHandle, _res, &_entry );
    else
       hr = LdapNextEntry( _pLdapHandle, _entry, &_entry );

   if (FAILED(hr) ) {

        _fAllEntriesReturned = TRUE;

        BAIL_ON_FAILURE(hr);
    }
    else if ( _entry == NULL ) {

        if (!_fPagedSearch || _fLastPage) { // reached the end of enumeration

            hr = S_FALSE;
            _fAllEntriesReturned = TRUE;
            goto error;
        }
        else {      // more pages are remaining
            //
            // release this page
            //
            if (_res) {
                LdapMsgFree(
                    _res
                    );
            }

            //
            // Get the next page of results
            //
            //
            // Get the first page full of results.
            //
            hr = LdapGetNextPageS(
                     _pLdapHandle,
                     _phPagedSearch,
                     NULL,
                     _dwPageSize,
                     &totalCount,
                     &_res
                     );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {

                     _fLastPage = TRUE;
                     hr = S_FALSE;
                     goto error;

                 }

            BAIL_ON_FAILURE(hr);

            hr = LdapFirstEntry(_pLdapHandle, _res, &_entry );

            if (FAILED(hr) ) {

                 _fAllEntriesReturned = TRUE;

                 BAIL_ON_FAILURE(hr);
            }
            else if ( (_entry == NULL)  ) {  // reached the end of enumeration

                 hr = S_FALSE;
                 _fAllEntriesReturned = TRUE;
                 goto error;
            }
        }
    }

    hr = LdapGetDn( _pLdapHandle, _entry, &pszObjectName );

    if (FAILED(hr) ) {
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapGetValues( _pLdapHandle, _entry, TEXT("objectClass"),
                              &aValues, &nCount );

    BAIL_ON_FAILURE(hr);

    if ( nCount == 0 )
    {
        // This object exists but does not contain objectClass attribute
        // which is required for all DS objects. Hence, ignore the object
        // and return error.

        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now send back the current object
    //

    {
        CLexer Lexer(pszObjectName);
        hr = InitObjectInfo(pszObjectName,
                            &ObjectInfoLocal);
        BAIL_ON_FAILURE(hr);


        Lexer.SetAtDisabler(TRUE);

        Lexer.SetFSlashDisabler(TRUE);

        hr = PathName(&Lexer,
                      &ObjectInfoLocal);
        BAIL_ON_FAILURE(hr);

        Lexer.SetFSlashDisabler(FALSE);

        if (ObjectInfoLocal.ComponentArray[0].szValue == NULL) {
            BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
        }
        DWORD len;

        len = wcslen(ObjectInfoLocal.ComponentArray[0].szComponent) +
              wcslen(ObjectInfoLocal.ComponentArray[0].szValue) +
          1;        // For equal to sign

        pszObjectName[len] = '\0';


        //
        // We form the ADsPath to the parent by taking the _ADsPath of this
        // object (which is the parent ADsPath), chopping off the DN portion,
        // and attaching the parent DN portion of the object retrieved.  This
        // is so that the enumerated child objects get a proper parent ADsPath
        // even if the parent object was bound using a GUID.
        //
        hr = BuildLDAPPathFromADsPath2(
                                       _ADsPath,
                                       &pszLDAPServer,
                                       &pszLDAPDn,
                                       &dwPort
                                       );
        BAIL_ON_FAILURE(hr);

        // _ADsPath could not be NULL 
        if(!_wcsnicmp(L"GC:", _ADsPath, wcslen(L"GC:")))
        {
            fGCNameSpace = TRUE;
        }

        if (ObjectInfoLocal.NumComponents > 1) {
            //
            // pszObjectName[0 ... len] = object name (e.g., "CN=child")
            // pszObjectName[len+1 ....] = parent name (e.g., "OU=parent, DC=....")
            //
            hr = BuildADsPathFromLDAPPath2(
                                           (pszLDAPServer ? TRUE : FALSE),
                                           fGCNameSpace ? L"GC:" : L"LDAP:",
                                           pszLDAPServer,
                                           dwPort,
                                           &(pszObjectName[len+1]),
                                           &pszADsPathParent
                                           );
        } 
        else {
            //
            // If the count is zero or less, then the objectName will
            // need to be created with a parent path of NULL. In this case
            // pszObjectName[len+1] is not necessarily valid. This is
            // espescially true when we have a defaultNamingContext
            // that is NULL or no defaultNamingContext with an object
            // directly underneath it (say dn is just o=testObject.
            //
            hr = BuildADsPathFromLDAPPath2(
                     (pszLDAPServer ? TRUE : FALSE),
                     fGCNameSpace ? L"GC:" : L"LDAP:",
                     pszLDAPServer,
                     dwPort,
                     NULL,
                     &pszADsPathParent
                     );

        }

        BAIL_ON_FAILURE(hr);
                                     
    }




    hr = CLDAPGenObject::CreateGenericObject(
                        pszADsPathParent,
                        pszObjectName,
                        aValues,
                        nCount,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **) ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

error:

    FreeObjectInfo(&ObjectInfoLocal);

    if ( pszObjectName )
        LdapMemFree( pszObjectName );

    if ( aValues )
        LdapValueFree( aValues );

    if (pPagedControl) {
        LdapControlFree(pPagedControl);
    }

    if (serverReturnedControls) {
        LdapControlsFree(serverReturnedControls);
    }

    if (pszADsPathParent) {
        FreeADsMem(pszADsPathParent);
    }

    if (pszLDAPServer) {
        FreeADsMem(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsMem(pszLDAPDn);
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
BuildLDAPFilterArray(
    VARIANT var,
    LPTSTR  *ppszFilter
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    LONG dwBracketCount = 0;
    DWORD dwFilterBufLen = 0;
    DWORD dwCurrentFilterLen = 0;
    LPTSTR pszFilter = NULL, pszTempFilter = NULL;

    *ppszFilter = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is at least one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwCurrentFilterLen = 0;
    dwFilterBufLen = FILTER_BUFFER_LEN;

    pszFilter = (LPTSTR) AllocADsMem( (dwFilterBufLen + 1) * sizeof(WCHAR));
    if ( pszFilter == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        BAIL_ON_FAILURE(hr);

        // The last length below is the string length of
        // "(| (objectClass=))" which is 18.
        //

        while ( dwCurrentFilterLen + _tcslen(V_BSTR(&v)) + 18  > dwFilterBufLen)
        {
            pszTempFilter = (LPTSTR) ReallocADsMem(
                            pszFilter,
                            (dwFilterBufLen + 1) * sizeof(WCHAR),
                            (dwFilterBufLen*2 + 1) * sizeof(WCHAR));
            if ( pszTempFilter == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            pszFilter = pszTempFilter;
            dwFilterBufLen *= 2;
        }

        if ( i == dwSUBound )
        {
            _tcscat( pszFilter, TEXT("(objectClass="));
        }
        else
        {
            dwBracketCount++;
            _tcscat( pszFilter, TEXT("(| (objectClass="));
        }

        _tcscat( pszFilter, V_BSTR(&v));
        _tcscat( pszFilter, TEXT(")"));
        dwCurrentFilterLen = _tcslen(pszFilter);

        VariantClear(&v);
    }

    for ( i = 0; i < dwBracketCount; i++ )
        _tcscat( pszFilter, TEXT(")"));

    *ppszFilter = pszFilter;

    RRETURN(S_OK);

error:

    VariantClear(&v);

    if ( pszFilter != NULL)
        FreeADsMem( pszFilter );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumvar.cxx
//
//  Contents:  LDAP Enumerator Code
//
//             CLDAPEnumVariant::Create
//             CLDAPEnumVariant::CLDAPEnumVariant
//             CLDAPEnumVariant::~CLDAPEnumVariant
//             CLDAPEnumVariant::QueryInterface
//             CLDAPEnumVariant::AddRef
//             CLDAPEnumVariant::Release
//             CLDAPEnumVariant::Next
//             CLDAPEnumVariant::Skip
//             CLDAPEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::CLDAPEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::~CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::~CLDAPEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}




#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}



#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                 \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)     \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteAttributeDefinition(                      \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                   \
STDMETHODIMP                                                      \
cls::EnumClasses(                                                     \
    LPWSTR * ppszClassNames,                                           \
    DWORD dwNumClasses,                                               \
    PADS_CLASS_DEF * ppClassDefinition,                                 \
    DWORD * pdwNumClasses                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumClasses(                                    \
              ppszClassNames,                                          \
              dwNumClasses,                                           \
              ppClassDefinition,                                       \
              pdwNumClasses                                           \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                           \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF pClassDefinition                                    \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateClassDefinition(                          \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                            \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF  pClassDefinition                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteClassDefinition(                           \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                           \
    LPWSTR pszClassName                                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteClassDefinition(                          \
              pszClassName                                            \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IADsObjectOptions_Implementation(cls)        \
STDMETHODIMP                                                          \
cls::GetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->GetOption(dwOption, pValue));         \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->SetOption(dwOption, pValue));          \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Namespace Object Class Factory Code
//
//             CLDAPNamespaceCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CLDAPNamespace::CreateNamespace(
                TEXT("ADs:"),
               TEXT("LDAP:"),
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\common.cxx ===
#include "ldap.hxx"
#pragma hdrstop


FILTERS Filters[] = { { USER_CLASS_NAME, LDAP_USER_ID},
                      { GROUP_CLASS_NAME, LDAP_GROUP_ID},
                      { PRINTER_CLASS_NAME, LDAP_PRINTER_ID},
                      { DOMAIN_CLASS_NAME, LDAP_DOMAIN_ID},
                      { COMPUTER_CLASS_NAME, LDAP_COMPUTER_ID},
                      { SERVICE_CLASS_NAME, LDAP_SERVICE_ID},
                      { FILESERVICE_CLASS_NAME, LDAP_FILESERVICE_ID},
                      { FILESHARE_CLASS_NAME, LDAP_FILESHARE_ID},
                      { CLASS_CLASS_NAME, LDAP_CLASS_ID},
                      { SYNTAX_CLASS_NAME, LDAP_SYNTAX_ID},
                      { PROPERTY_CLASS_NAME, LDAP_PROPERTY_ID},
                      { TEXT("Locality"), LDAP_LOCALITY_ID },
                      { TEXT("Organization"), LDAP_O_ID},
                      { TEXT("Organizational Unit"), LDAP_OU_ID},
                      { TEXT("organizationalUnit"), LDAP_OU_ID},
                      { TEXT("Country"), LDAP_COUNTRY_ID},
                      { TEXT("localGroup"), LDAP_GROUP_ID},
                      { TEXT("groupOfNames"), LDAP_GROUP_ID},
                      { TEXT("groupOfUniqueNames"), LDAP_GROUP_ID},
                      { TEXT("person"), LDAP_USER_ID},
                      { TEXT("organizationalPerson"), LDAP_USER_ID},
                      { TEXT("residentialPerson"), LDAP_USER_ID},
                      { TEXT("inetOrgPerson"), LDAP_USER_ID}

                    };

#define MAX_FILTERS (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;


HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    HRESULT hr = S_OK;
    TCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
MakeUncName(
    LPTSTR szSrcBuffer,
    LPTSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    _tcscpy(szTargBuffer, TEXT("\\\\"));
    _tcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamesp.cxx
//
//  Contents:  LDAP Namespace Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "LDAP.hxx"
#pragma hdrstop
#include <ntdsapi.h>

DEFINE_IDispatch_Implementation(CLDAPNamespace)
DEFINE_IADs_Implementation(CLDAPNamespace)
DEFINE_IADsPutGet_UnImplementation(CLDAPNamespace)

//  Class CLDAPNamespace

CLDAPNamespace::CLDAPNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CLDAPNamespace);

    _pObjectInfo = NULL;
}

HRESULT
CLDAPNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                NAMESPACE_CLASS_NAME,
                CLSID_LDAPNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // Umi Object is going to be the owner, so we need to
        // initilaize the umi object and return.
        //
        hr = ((CCoreADsObject*)pNamespace)->InitUmiObject(
                   IntfPropsSchema,
                   NULL,
                   (IADs *) pNamespace,
                   (IADs *) pNamespace,
                   riid,
                   ppvObj,
                   &(pNamespace->_Credentials)
                   );

        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    }
    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:
    *ppvObj = NULL;
    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CLDAPNamespace::~CLDAPNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CLDAPNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPNamespace::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
STDMETHODIMP
CLDAPNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPNamespace::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    DWORD dwBufferSize = 0;
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    dwBufferSize = ( _tcslen(_ADsPath) + _tcslen(RelativeName)
                     + 3  ) * sizeof(TCHAR);   // includes "//"

    pszBuffer = (LPTSTR) AllocADsMem( dwBufferSize );

    if ( pszBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy(pszBuffer, _ADsPath);
    _tcscat(pszBuffer, TEXT("//"));
    _tcscat(pszBuffer, RelativeName);

    hr = ::GetObject(
               pszBuffer,
               _Credentials,
               (LPVOID *)ppObject
               );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszBuffer )
        FreeADsStr( pszBuffer );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CLDAPNamespaceEnum::Create(
                (CLDAPNamespaceEnum **)&penum,
                 _vFilter,
                 _Credentials,
                 _ADsPath
                 );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CLDAPNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CLDAPNamespace ** ppNamespace
    )
{
    CLDAPNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CLDAPNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CLDAPNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials(lpszUserName, lpszPassword, lnReserved);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - The place where the parsed object is stored.
                  It assumes that this structure is valid and empty, and will
                  overwrite anything that is in there already.
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    LPWSTR szPath = NULL;
    
    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            hr = ADsObject(bstrADsPath, pObjInfo);
            BAIL_ON_FAILURE(hr);

            
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            hr = GetDisplayName(bstrADsPath, &szPath);
            BAIL_ON_FAILURE(hr);

            hr = InitObjectInfo(szPath,
                                pObjInfo);
            BAIL_ON_FAILURE(hr);

            CLexer Lexer(szPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            hr = GetDisplayName(bstrADsPath, &szPath);
            BAIL_ON_FAILURE(hr);

            CLexer Lexer(szPath);
        
            hr = InitObjectInfo(szPath, pObjInfo);
            BAIL_ON_FAILURE(hr);

            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->NamespaceName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->TreeName) {
        pObjectInfo->ServerName = AllocADsStr(pObjInfo->TreeName);
        if (!pObjectInfo->ServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->DisplayTreeName) {
        pObjectInfo->DisplayServerName = AllocADsStr(pObjInfo->DisplayTreeName);
        if (!pObjectInfo->DisplayServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = (pObjInfo->dwPathType == PATHTYPE_X500) ? 
                                ADS_PATHTYPE_LEAFFIRST : ADS_PATHTYPE_ROOTFIRST;

error:
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    FreeObjectInfo(pObjInfo);
    return (hr);
}

HRESULT
CLDAPNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;
    PWSTR pszPath = NULL;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            DWORD dwResult;
            DWORD dwSize = 0;

            pObjectInfoTarget->ComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        
            dwSize = wcslen(pObjectInfo->ComponentArray[NumComponents].szValue) + 1;
            pszPath = (PWSTR)AllocADsMem(dwSize * sizeof(WCHAR));
            if (pszPath == NULL) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            dwResult = DsUnquoteRdnValueWrapper(
                                wcslen(pObjectInfo->ComponentArray[NumComponents].szValue),
                                pObjectInfo->ComponentArray[NumComponents].szValue,
                                &dwSize,
                                pszPath);

            if (dwResult == NO_ERROR) {
                pszPath[dwSize] = NULL;
                pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szValue =
                    AllocADsStr(pszPath);
                if (pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szValue == NULL) {
                    pObjectInfoTarget->NumComponents = NumComponents;
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
            }
            if (pszPath) {
                FreeADsMem(pszPath);
                pszPath = NULL;
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);
    if (pszPath) {
        FreeADsMem(pszPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

void
CLDAPNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szValue);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CLDAPNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    DWORD dwEscapedMode
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    ASSERT(dwEscapedMode != ADS_ESCAPEDMODE_DEFAULT);
    if (dwEscapedMode == ADS_ESCAPEDMODE_OFF){
        pComponent = _pObjectInfo->ComponentArray;
    }
    else if (dwEscapedMode == ADS_ESCAPEDMODE_OFF_EX){
        pComponent = _pObjectInfo->ProvSpecComponentArray;
    }
    else if (dwEscapedMode == ADS_ESCAPEDMODE_ON) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
}


HRESULT 
CLDAPNamespace::SetComponents(
                            LPWSTR szReturn,
                            BOOLEAN bIsWindowsPath,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            DWORD dwEscapedMode
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    bIsWindowsPath - whether a windows path is to be returned
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    BOOL bReverse;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             dwEscapedMode);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             dwEscapedMode);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        bReverse = !bIsWindowsPath;
    }
    else {
        bReverse = bIsWindowsPath;
    }


    if (!bReverse) {
        dwLimit = _pObjectInfo->NumComponents;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwOtherLimit >= dwLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
            SetComponent(szReturn,
                         cComponents,
                         dwEscapedMode);
            if (cComponents != dwLimit - 1) {
                wcscat(szReturn,
                       chSeparator);
            }
        }
    }
    else {
        dwLimit = _pObjectInfo->NumComponents-1;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwLimit < dwOtherLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwLimit ; (long)cComponents >= dwOtherLimit; cComponents--) {
            SetComponent(szReturn,
                         cComponents,
                         dwEscapedMode);
            if (cComponents != dwOtherLimit) {
                wcscat(szReturn, chSeparator);
            }
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CLDAPNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
/*++

Routine Description:

    Given an objectinfo structure, and the settings required, this function
    assembles the path and returns it in pbstrADsPath

Arguments:

    pObjectInfo - the input object info structure
    dwFormatType- The format type passed in from Retrieve.
    dwFlag - the flag to be set
        ADS_CONSTRUCT_ESCAPED
        ADS_CONSTRUCT_NAMINGATTRIBUTE
    pbstrADsPath - the returned path


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    DWORD dwEscapedInternal;

    dwEscapedInternal = dwEscapedMode;
    if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
        dwEscapedInternal = ADS_ESCAPEDMODE_OFF;
    }


    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _fNamingAttribute = (BOOLEAN)(dwFlag & ADS_CONSTRUCT_NAMINGATTRIBUTE);
    _pObjectInfo = pObjectInfo; // useful in SetComponet() and SetComponents()

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                dwEscapedInternal = ADS_ESCAPEDMODE_ON;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (dwEscapedInternal == ADS_ESCAPEDMODE_ON) {
                    if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                        wcscat(szReturn,pObjectInfo->DisplayServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
                else {
                    if (pObjectInfo->ServerName && (*(pObjectInfo->ServerName))) {
                        wcscat(szReturn,pObjectInfo->ServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                dwEscapedInternal = ADS_ESCAPEDMODE_ON;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;    // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_X500) {
                if (dwEscapedInternal == ADS_ESCAPEDMODE_ON) {
                    if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                        wcscat(szReturn,pObjectInfo->DisplayServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
                else {
                    if (pObjectInfo->ServerName && (*(pObjectInfo->ServerName))) {
                        wcscat(szReturn,pObjectInfo->ServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
            }
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500_DN:
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500_PARENT:
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_PARENT,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
        break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrOutStr))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if (!bstrInStr) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = HelperEscapeRDN(bstrInStr, pbstrOutStr);

    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////
//      escape.cpp
//
//      routine to escape special characters in an RDN
//      
//      ASSUMPTIONS/RESTRICTIONS:
//      - we assume that the input string is un-escaped in any way
//      - we assume that the input string is a correctly attributed
//        RDN, and we directly copy everything up to and including
//        the first '='
//
//      HISTORY
//      3-dec-98                jimharr         Creation.
/////////////////////////////////////////////////////////////////////


static WCHAR specialChars[] =  L",=\r\n+<>#;\"\\/";

HRESULT
HelperEscapeRDN (
    IN BSTR bstrIn,
    OUT BSTR * pbstrOut
    )
{

  //
  // algorithm:
  //     create temporary buffer to hold escaped RDN
  //     skip up to first '=', to skip attributeType
  //     examine each character, if it needs escaping
  //        put a '\' in the dest.
  //     copy the character
  //     continue until done
  //
  //     alloc BSTR of correct size to return
  //     copy string, delete temp buffer
  //
  HRESULT hr = S_OK;
  WCHAR *pchSource = NULL;
  WCHAR *pchDest = NULL;
  WCHAR *pBuffer = NULL;
  WCHAR *pTmp;

  pBuffer = (WCHAR* ) AllocADsMem((wcslen(bstrIn) * 3 + 1) * sizeof(WCHAR));
  if (pBuffer == NULL)
    BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

  pchDest = pBuffer;
  pchSource = (WCHAR *)bstrIn;

  // copy up to the equals sign
  do {
    *pchDest = *pchSource;
    pchSource++;
    pchDest++;
  } while ((*pchSource != L'=') && (*pchSource != L'\0'));

  // if we didn't find an '=', bail
  if (*pchSource == L'\0') {
    BAIL_ON_FAILURE(hr=E_INVALIDARG);
  }

  // copy the '='
  *pchDest = *pchSource;
  pchSource++;
  pchDest++;

  //
  // If the first character after the '=' is a space, we'll escape it. 
  // According to LDAP, if the value starts with a space, it has to be escaped
  // or else it will be trimmed.
  //
  if (*pchSource == L' ') {
    *pchDest = L'\\';
    pchDest++;
    *pchDest = *pchSource;
    pchDest++;
    pchSource++;
  }

  while (*pchSource != L'\0') {

    //
    // If we have reached the last character and it is a space, we'll escape
    // it
    //
    if ( (*(pchSource+1) == L'\0') && 
         ((*pchSource) == L' ') ) {
        *pchDest = L'\\';
        pchDest++;
        *pchDest = *pchSource;
        pchDest++;
        break;
    }

    if (NeedsEscaping(*pchSource)) {
      *pchDest = L'\\';
      pchDest++;
    }
    pTmp = EscapedVersion(*pchSource);
    if (pTmp != NULL) {
      wcscpy (pchDest, pTmp);
      pchDest += wcslen(pTmp);
    } else {
      *pchDest = *pchSource;
      pchDest++;
    }
    pchSource++;
  }
  *pchDest = L'\0';

  *pbstrOut = SysAllocString (pBuffer);

error:

  if (pBuffer) {
      FreeADsMem(pBuffer);
  }
  return (hr);
}


BOOL
NeedsEscaping (WCHAR c)
{
  WCHAR * pSpecial = specialChars;

  while (*pSpecial != L'\0'){
    if (*pSpecial == c) return TRUE;
    pSpecial++;
  }
  return FALSE;
}

WCHAR *
EscapedVersion (WCHAR c)
{
  if (c == L'\r')
    return L"0D";
  if (c == L'\n')
    return L"0A";

  return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for LDAP
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      15-Jun-96   yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString1 = NULL;
    LPWSTR tempString2 = NULL;

    PPROPERTY pNewProperties = NULL;

    PDISPPROPERTY pDispNewProperty = NULL;
    PDISPPROPERTY pDispNewProperties = NULL;
    DWORD dwDispLoc = 0;


    //
    // Allocate the string first
    //
    tempString1 = AllocADsStr(szPropertyName);

    if (!tempString1)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    // Make a copy for the Dispatch Mgr Table.
    //

    tempString2 = AllocADsStr(szPropertyName);

    if (!tempString2)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _pProperties = pNewProperties;

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);


    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString1;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    //
    //  extend the property cache by adding a new property entry
    //

    //
    // Need to check if this property is already there in the
    // dispatch table - otherwise we are going to keep on growing
    // forever - AjayR 7-31-98.
    //

    hr = DispatchFindProperty(szPropertyName, &dwDispLoc);

    if (hr == S_OK) {
        // we do not need this string in this case
        if (tempString2) {
            FreeADsStr(tempString2);
            tempString2 = NULL;
        }
    } else {

        //
        // reset the hr otherwise we will return an
        // error incorrectly when there was none.
        //
        hr = S_OK;

        pDispNewProperties = (PDISPPROPERTY)ReallocADsMem(
                                    _pDispProperties,
                                    _cbDisp,
                                    _cbDisp + sizeof(DISPPROPERTY)
                                    );
        if (!pDispNewProperties) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        _pDispProperties = pDispNewProperties;

        pDispNewProperty = (PDISPPROPERTY)((LPBYTE)_pDispProperties + _cbDisp);


        //
        // Since the memory has already been allocated in tempString
        // just set the value/pointer now.
        //
        pDispNewProperty->szPropertyName = tempString2;

        //
        // Update the index
        //

        _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

    } // else clause - that is property not found in disp

    RRETURN(hr);
error:

    if (tempString1){
       FreeADsStr(tempString1);
    }

    if (tempString2) {
        FreeADsStr(tempString2);
    }


    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putpropertyext
//
//  Synopsis: Similar to put property only unlike update it will add
//       the property to the cahce if it is not already there ! 
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//  History 
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putpropertyext(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex;
    BOOL fFound = FALSE;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    //
    // If the property is not in the cache we need to add it
    // as updateproperty expects it to be in the cache.
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        hr = addproperty(
                 szPropertyName
                 );
    } 
    else {
        fFound = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // at this time we can call putproperty
    //
    if (fFound) {
        hr = putproperty(
                 dwIndex,
                 dwFlags,
                 dwSyntaxId,
                 ldapObjectArray
                 );
    } 
    else {
        hr = putproperty(
                 szPropertyName,
                 dwFlags,
                 dwSyntaxId,
                 ldapObjectArray
                 );
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray,
    BOOL   fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ( PROPERTY_FLAGS(pThisProperty) == PROPERTY_UPDATE ) {
            hr = S_OK;
            goto error;
        }
    }

    // Free the old values first
    LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;

    hr = LdapTypeCopyConstruct(
            ldapObjectArray,
            &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
            );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }

    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);

}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId,
    PDWORD pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;


    //
    // retrieve index of property in cache
    //

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    //
    // if property not already in cache, try get properties from svr
    //

    //
    // INDEX_EMPTY(???) ???
    //

    if ((hr == E_ADS_PROPERTY_NOT_FOUND || 
         (INDEX_EMPTY(dwIndex) && !PROP_DELETED(dwIndex))
        ) && 
        !_fGetInfoDone)
    {
        BOOL fResult = FindSavingEntry(szPropertyName);

        if(!fResult) {
            hr = _pCoreADsObject->GetInfo(FALSE);

            // workaround to avoid confusing callers of getproperty.
            if (hr == E_NOTIMPL) {
                hr = E_ADS_PROPERTY_NOT_FOUND;
            }
            BAIL_ON_FAILURE(hr);

            hr = findproperty(szPropertyName, &dwIndex);
        }
        else {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }
    BAIL_ON_FAILURE(hr);


    //
    // get property based on index in cache
    //

    hr = unboundgetproperty(
            dwIndex,
            pdwSyntaxId,
            pdwStatusFlag,
            pLdapObjectArray
            );

error:

   RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0L;

    hr = findproperty(szPropertyName, &dwIndex);
    if (SUCCEEDED(hr))
        hr = putproperty(dwIndex, dwFlags, dwSyntaxId, ldapObjectArray);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    DWORD  dwIndex,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;

    pThisProperty = _pProperties + dwIndex;

    // Free the old values first
    LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

    switch ( dwFlags ) {

    case PROPERTY_INIT:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        break;

    case PROPERTY_DELETE:
        PROPERTY_FLAGS(pThisProperty) = PROPERTY_DELETE;
        break;

    case PROPERTY_UPDATE:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = ldapObjectArray.dwCount?
                                        PROPERTY_UPDATE : PROPERTY_DELETE;
        break;


    case PROPERTY_DELETE_VALUE:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_DELETE_VALUE;

        break;



    case PROPERTY_ADD:
        hr = LdapTypeCopyConstruct(
                 ldapObjectArray,
                 &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                 );
        BAIL_ON_FAILURE(hr);

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_ADD;
        break;

    }

error:

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
CPropertyCache():
    _dwMaxProperties(0),
    _pProperties(NULL),
    _cb(0),
    _dwCurrentIndex(0),
    _pCoreADsObject(NULL),
    _pGetAttributeSyntax(NULL),
    _fGetInfoDone(FALSE),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0),
    _pCredentials(NULL),
    _pszServerName(NULL),
    _dwPort(0)
{
    InitializeListHead(&_ListSavingEntries);

}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;
    
    if (_pProperties) {

        for ( DWORD i = 0; i < _dwMaxProperties; i++ ) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));
        }

        FreeADsMem(_pProperties);
    }

    if (_pDispProperties) {

        for ( DWORD i = 0; i < _dwDispMaxProperties; i++ ) {

            pThisDispProperty = _pDispProperties + i;

            if (pThisDispProperty->szPropertyName) {
               FreeADsStr(pThisDispProperty->szPropertyName);
               pThisDispProperty->szPropertyName = NULL;
            }

        }

        FreeADsMem(_pDispProperties);
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
        _pszServerName = NULL;
    }

    DeleteSavingEntry();


    //
    // The property cache is deleted before the object is
    // so the object will handle freeing the credentials.
    // We just keep a pointer to the credentials.
    //
    if (_pCredentials) {
        _pCredentials = NULL;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearAllPropertyFlags
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearAllPropertyFlags(VOID)
{
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for ( DWORD i = 0; i < _dwMaxProperties; i++ ) {

            pThisProperty = _pProperties + i;
            PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        }
    }

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearPropertyFlag
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearPropertyFlag( LPWSTR szPropertyName )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearMarshalledProperties
//
//  Synopsis: Once the properties have been marshalled and
// the set has been done, the properties on the cache are no
// longer valid. This method must be called to keep the property
// cache in a coherrent state.
//       The method frees the 'dirty' entries, sets implicit get
// flag. If the dirty entries cannot be cleared, then the
// entire contents are flushed and they will be picked up at the
// next GetInfo call -- AjayR
//
//  Arguments: None.
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearMarshalledProperties()
{
    HRESULT hr = S_OK;
    DWORD dwIndx = 0;
    DWORD dwCtr = 0;
    DWORD dwChng = 0;
    PPROPERTY pNewProperties = NULL;
    PPROPERTY pThisProperty = NULL;
    PPROPERTY pNewCurProperty = NULL;
    DWORD dwNewProps = 0;


    //
    // Go through properties to see how many have changed
    //
    for (dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++ ) {
        pThisProperty = _pProperties + dwCtr;

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwChng++;
    }

    if (dwChng == 0) {
        RRETURN(S_OK);
    }

    //
    // Need to remove those entries which were changed
    //

    dwNewProps = _dwMaxProperties - dwChng;

    if (dwNewProps != 0) {
        pNewProperties = (PPROPERTY) AllocADsMem(
                                         dwNewProps * sizeof(PROPERTY)
                                         );

        if (!pNewProperties) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            // if this fails, then we cannot recover
            // effectively. What alternative is there ?
            // We do not want to flush the cache.
        }
    }

    for (dwCtr = 0, dwIndx = 0; dwCtr < _dwMaxProperties; dwCtr++ ) {

        pThisProperty = _pProperties + dwCtr;

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT) {
            //
            // delete the property
            //

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));

        } else {

            //
            // Sanity Check, should not hit this if Assert preferable
            //
            if (dwIndx > dwNewProps || dwIndx == dwNewProps) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            pNewCurProperty = pNewProperties + dwIndx;

            pNewCurProperty->szPropertyName = pThisProperty->szPropertyName;

            pNewCurProperty->ldapObjectArray =
                PROPERTY_LDAPOBJECTARRAY(pThisProperty);

            pNewCurProperty->dwFlags = pThisProperty->dwFlags;

            pNewCurProperty->dwSyntaxId = pThisProperty->dwSyntaxId;

            dwIndx++;
        }
    } // for, copying the old elements to new buffer

    _dwMaxProperties -= dwChng;

    _cb = dwNewProps * sizeof(PROPERTY);

    if (_pProperties)
        FreeADsMem(_pProperties);

    _pProperties = pNewProperties;


    // Need to set this flag to implicitly fetch properties
    // the next time somebody asks for a poperty not in the cache.
    _fGetInfoDone = FALSE;

    RRETURN(S_OK);

error:

    if (pNewProperties) {
        FreeADsMem(pNewProperties);
    }

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::SetPropertyFlag
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::SetPropertyFlag( LPWSTR szPropertyName, DWORD dwFlag )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        PROPERTY_FLAGS(pThisProperty) = dwFlag;
    }

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::IsPropertyUpdated
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
IsPropertyUpdated(
    LPWSTR szPropertyName,
    BOOL   *pfUpdated
    )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    *pfUpdated = FALSE;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        if ( PROPERTY_FLAGS(pThisProperty) == PROPERTY_UPDATE )
            *pfUpdated = TRUE;
    }

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::createpropertycache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    CCoreADsObject *pCoreADsObject,
    IGetAttributeSyntax *pGetAttributeSyntax,
    CPropertyCache **ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pGetAttributeSyntax = pGetAttributeSyntax;
    pPropertyCache->_fGetInfoDone = FALSE;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


HRESULT
CPropertyCache::SetObjInformation(
    CCredentials* pCredentials,
    LPWSTR pszServerName,
    DWORD dwPortNo
    )
{
    //
    // We need the credentials to be valid
    //
    if (!pCredentials) {
        ADsAssert(!"InvalidCredentials to prop cache");
    } else {
        _pCredentials = pCredentials;
    }

    //
    // This can be NULL, so it is better to allocate and dealloc
    // in destructor
    //
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
        _pszServerName = NULL;
    }

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);
        if (_pszServerName == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    _dwPort = dwPortNo;

    RRETURN(S_OK);
}
//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::flushpropertycache
//
//  Synopsis:   Flushes the property cache of all data.
//
//  The name <-> index mappings need to stay until the property cache is
//  destructed, because the indexes are also used as the DISPIDs of the
//  properties.  So this neither deallocates the names nor the array itself.
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropertycache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));
            PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        }

        FreeADsMem(_pProperties);

        _pProperties = NULL;
        _dwMaxProperties = 0;
        _cb = 0;

    }

    //
    // Reset the property cache
    //

    _dwCurrentIndex = 0;
    _fGetInfoDone = FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unmarshallproperty
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    PADSLDP pLdapHandle,
    LDAPMessage *entry,
    DWORD  dwSyntaxId,
    BOOL   fExplicit,
    BOOL * pfRangeRetrieval // defaulted to NULL
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapObjectArray;
    LPWSTR pszTemp = NULL;

    LDAPOBJECTARRAY_INIT(ldapObjectArray);

    //
    // If arg is valid default value to false.
    //
    if (pfRangeRetrieval) {
        *pfRangeRetrieval = FALSE;
    }

    hr = UnMarshallLDAPToLDAPSynID(
             szPropertyName,
             pLdapHandle,
             entry,
             dwSyntaxId,
             &ldapObjectArray
             );

    //
    // Need to look for ; as in members;range or value;binary
    // and strip the ; out before adding to cache.
    //
    if ((pszTemp = wcschr(szPropertyName, L';')) != NULL ) {
            *pszTemp = L'\0';
    }
    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    ldapObjectArray,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Put the ; back if we replaced it.
    //
    if (pszTemp) {

        //
        // Do we need to update the flag ?
        //
        if (pfRangeRetrieval) {
            //
            // See if this was members and update flag.
            //
            if (!_wcsicmp(L"member", szPropertyName)) {
                *pfRangeRetrieval = TRUE;
            }
        }

        *pszTemp = L';';

    }

    if ( ldapObjectArray.fIsString )
        LdapValueFree( (TCHAR **) ldapObjectArray.pLdapObjects );
    else
        LdapValueFreeLen( (struct berval **) ldapObjectArray.pLdapObjects );

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
LDAPUnMarshallProperties(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    void *ptr;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // Compute the number of attributes in the
    // read buffer.

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        DWORD dwSyntax = LDAPTYPE_UNKNOWN;

        LPWSTR pszADsPath;
        hr = _pCoreADsObject->get_CoreADsPath(&pszADsPath);
        BAIL_ON_FAILURE(hr);

        hr = ADsObject(pszADsPath, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        //
        // unmarshall this property into the
        // property cache.
        // LdapGetSyntax takes care of ; while looking up
        // the schema no need to handle at this level.
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszServerPath,
                 pszAttrName,
                 &dwSyntax,
                 Credentials,
                 pObjectInfo->PortNumber,
                 TRUE // fForce
                 );
        ADsFreeString(pszADsPath);

        if ( SUCCEEDED(hr) && (dwSyntax != LDAPTYPE_UNKNOWN))
        {
            if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) &&
                 (dwSyntax == LDAPTYPE_OCTETSTRING) )
            {
                dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
            }

            (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit
                       );
        }

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        //
        // If we cannot find the syntax, ignore the property and
        // continue with the next property
        //
        hr = S_OK;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    }

error:

    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}

////////////////////////////////////////////////////////////////////////
//
// Unmarshall attributes (& their values) in [ldapmsg] into cache.
// Syntaxes of attributes are read from schema on server [pszServerPath].
// If an attribute not in the schema (e.g. not in our default schema used
// in case of schemaless server), the attribute is unmarshalled as ldap
// binary data with type = LDAPTYPE_UNKWNON.
//
// [Credentials]
//      - used to access pszServerPath
//
// [pLdapHandle]
//      - handle assoc with [ldapmsg]
//      - used to retrive attributes and their values from [ldapmsg]
//
// [fExplicit]
//      - overwrite value of exiting attributes in cache iff = TRUE
//
// NOTE: This function modified LDAPUnMarshallProperties to allow
// unmarshalling of attributes not in the schema.
//
////////////////////////////////////////////////////////////////////////

HRESULT
CPropertyCache::
LDAPUnMarshallProperties2(
    IN LPWSTR   pszServerPath,
    IN PADSLDP pLdapHandle,
    IN LDAPMessage *ldapmsg,
    IN BOOL     fExplicit,
    IN CCredentials& Credentials,
    OUT BOOL * pfRangeRetrieval
    )
{

    HRESULT hr = S_OK;
    int nNumberOfEntries = 0L;
    LDAPMessage *entry = NULL;
    void *ptr = NULL;
    LPWSTR pszAttrName = NULL;
    DWORD dwSyntax = LDAPTYPE_UNKNOWN;
    LPWSTR pszADsPath = NULL;
    OBJECTINFO ObjectInfo;
    BOOL fRange = FALSE;
    memset(&ObjectInfo, 0, sizeof(OBJECTINFO));

    ADsAssert(pfRangeRetrieval);
    *pfRangeRetrieval = FALSE;

    if (!pLdapHandle || !ldapmsg)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // Compute the number of attributes in the read buffer.
    //

    nNumberOfEntries = LdapCountEntries(pLdapHandle, ldapmsg);

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);


    //
    // get port number to talk to server on which schema locate ???
    //

    hr = _pCoreADsObject->get_CoreADsPath(&pszADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(pszADsPath, &ObjectInfo);
    BAIL_ON_FAILURE(hr);


    //
    // Get first entry from ldapmsg first. Should be only one entry.
    //

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );
    BAIL_ON_FAILURE(hr);


    //
    // get first attribute's name
    //

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);


    while ( pszAttrName != NULL )
    {
        //
        // get syntax of attribute from schema on sever (may be cached);
        // continue to unmarshall the attribute even if it isn't in the
        // schema.
        //

        dwSyntax = LDAPTYPE_UNKNOWN;

        (VOID) LdapGetSyntaxOfAttributeOnServer(
                    pszServerPath,
                    pszAttrName,
                    &dwSyntax,
                    Credentials,
                    ObjectInfo.PortNumber,
                    TRUE // fForce
                    );


        //
        // There is currently no such syntax as "SecurityDescriptor" on
        // server, ADSI will unmarshall "OctetString" security descriptor
        // as as ntSecurityDescriptor
        //

        if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor"))
                &&   (dwSyntax == LDAPTYPE_OCTETSTRING)
           )
        {
               dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
        }

        //
        // unmarshall the property into cache, LDAPTYPE_UNWKNOWN
        // (dwSyntax) will be unmarshalled as binary data.
        //

        (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit,
                       fRange ? NULL : pfRangeRetrieval
                       );

        //
        // Small trick to make sure we do not loose the range
        // retrieval information for members attribute.
        //
        fRange = *pfRangeRetrieval;

        //
        // get next attribute
        //

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;
        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszADsPath)
        ADsFreeString(pszADsPath);

    FreeObjectInfo(&ObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}



HRESULT
CPropertyCache::
LDAPMarshallProperties(
    LDAPModW ***aMods,
    PBOOL pfNTSecDes,
    SECURITY_INFORMATION *pSeInfo
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD j = 0;
    PPROPERTY pThisProperty = NULL;
    int dwCount = 0;
    LDAPModW *aModsBuffer = NULL;
    LDAPOBJECTARRAY ldapObjectArray;
    
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fSecDesProp = FALSE;

    *pSeInfo = INVALID_SE_VALUE;
    *pfNTSecDes = FALSE;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwCount++;
    }

    if ( dwCount == 0 )  // Nothing to change
    {
        *aMods = NULL;
        RRETURN(S_OK);
    }

    *aMods = (LDAPModW **) AllocADsMem((dwCount+1) * sizeof(LDAPModW *));

    if ( *aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwCount * sizeof(LDAPModW));

    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, j = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == PROPERTY_INIT ) {

            continue;
        }


        if (!_wcsicmp(PROPERTY_NAME(pThisProperty),L"ntSecurityDescriptor")) {
            *pfNTSecDes = TRUE;
            fSecDesProp = TRUE;
        } else {
            fSecDesProp = FALSE;
        }

        ldapObjectArray = PROPERTY_LDAPOBJECTARRAY(pThisProperty);

        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type   = PROPERTY_NAME(pThisProperty);

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[j].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[j].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[j].mod_op = LDAP_MOD_BVALUES;
            if (fSecDesProp) {
                pSecurityDescriptor = LDAPOBJECT_BERVAL_VAL(ldapObjectArray.pLdapObjects);

                if ( GetSecurityDescriptorOwner(
                                pSecurityDescriptor,
                                &pOwnerSid,
                                &fOwnerDefaulted
                                )
                            &&
                     
                     GetSecurityDescriptorGroup(
                                pSecurityDescriptor,
                                &pGroupSid,
                                &fGroupDefaulted
                                    )
                            &&

                     GetSecurityDescriptorDacl(
                                pSecurityDescriptor,
                                &DaclPresent,
                                &pDacl,
                                &fDaclDefaulted
                                )
                            &&
                     
                     GetSecurityDescriptorSacl(
                                pSecurityDescriptor,
                                &SaclPresent,
                                &pSacl,
                                &fSaclDefaulted
                                )
                   ) {
                    //
                    // All the calls succeeded, so we should reset to 0
                    // instead of the invalid value.
                    //
                    *pSeInfo = 0;

                    if (!fOwnerDefaulted) {
                        *pSeInfo = *pSeInfo | OWNER_SECURITY_INFORMATION;
                    }

                    if (!fGroupDefaulted) {
                        *pSeInfo = *pSeInfo | GROUP_SECURITY_INFORMATION;
                    }

                    //
                    // If the DACL is present we need to send DACL bit.
                    // 
                    if (DaclPresent) {
                        *pSeInfo = *pSeInfo | DACL_SECURITY_INFORMATION;
                    }

                    //
                    // If SACL present then we set the SACL bit.
                    if (SaclPresent) {
                        *pSeInfo = *pSeInfo | SACL_SECURITY_INFORMATION;
                    }

                }

            }
        }

        switch( PROPERTY_FLAGS(pThisProperty))
        {
            case PROPERTY_UPDATE:
                aModsBuffer[j].mod_op |= LDAP_MOD_REPLACE;
                break;

            case PROPERTY_ADD:
                aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
                break;

            case PROPERTY_DELETE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;


            case PROPERTY_DELETE_VALUE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;

        }

        j++;

    }


    RRETURN(hr);

error:

    FreeADsMem( aModsBuffer );
    FreeADsMem( *aMods );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CPropertyCache::
LDAPMarshallProperties2(
    LDAPModW ***aMods,
    DWORD *pdwNumOfMods
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD j = 0;
    PPROPERTY pThisProperty = NULL;
    int dwCount = 0;
    LDAPModW *aModsBuffer = NULL;
    LDAPOBJECTARRAY ldapObjectArray;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwCount++;
    }

    if ( dwCount == 0 )  // Nothing to change
        RRETURN(S_OK);

    if ( *aMods == NULL )
    {
        *aMods = (LDAPModW **) AllocADsMem((dwCount+1) * sizeof(LDAPModW *));

        if ( *aMods == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem( dwCount * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( *aMods );
            *aMods = NULL;
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        LDAPModW **aModsTemp = NULL;

        aModsTemp = (LDAPModW **) AllocADsMem(
                        (*pdwNumOfMods+ dwCount + 1) * sizeof(LDAPModW *));

        if ( aModsTemp == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem(
                          (*pdwNumOfMods + dwCount) * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( aModsTemp );
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy( aModsBuffer, **aMods, *pdwNumOfMods * sizeof(LDAPModW));
        FreeADsMem( **aMods );
        FreeADsMem( *aMods );

        *aMods = aModsTemp;

        for ( j = 0; j < *pdwNumOfMods; j++ )
        {
            (*aMods)[j] = &aModsBuffer[j];
        }
    }

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == PROPERTY_INIT ) {

            continue;
        }

        ldapObjectArray = PROPERTY_LDAPOBJECTARRAY(pThisProperty);

        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type   = PROPERTY_NAME(pThisProperty);

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[j].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[j].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[j].mod_op = LDAP_MOD_BVALUES;
        }

        switch( PROPERTY_FLAGS(pThisProperty))
        {
            case PROPERTY_UPDATE:
                aModsBuffer[j].mod_op |= LDAP_MOD_REPLACE;
                break;

            case PROPERTY_ADD:
                aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
                break;

            case PROPERTY_DELETE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;
        }

        j++;

    }

    *pdwNumOfMods += dwCount;

error:

    RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unboundgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;


    //
    // get index of property in cache
    //

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);


    //
    // get property based on index in cache
    //

    hr = unboundgetproperty(
            dwIndex,
            pdwSyntaxId,
            pdwStatusFlag,
            pLdapObjectArray
            );

error:

   RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unboundgetproperty
//
//  Synopsis: Note that this version takes the index of the element to
//      fetch. It also returns the control code of the item in the cache.
//
//
//  Arguments:  [dwIndex]           --  Index of the property to retrieve.
//              [pdwSytnaxId]       --  SyntaxId of the data.
//              [pdwStatusFlag]     --  Status of this property in cache.
//              [pLdapObjectArray]  --  Array of ldapObjects returned.
//
//  NOTE: [dwIndex] is invalid -> E_ADS_PROPERTY_NOT_FOUND//E_FAIL ???
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD pdwSyntaxId,
    PDWORD pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;


    if (!index_valid(dwIndex))
        RRETURN(E_ADS_PROPERTY_NOT_FOUND);

    pThisProperty = _pProperties + dwIndex;


    // Status flag has to be valid if we found the property
    *pdwStatusFlag = PROPERTY_FLAGS(pThisProperty);


    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        //
        // property has non-empty values
        //

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);

        hr = LdapTypeCopyConstruct(
                PROPERTY_LDAPOBJECTARRAY(pThisProperty),
                pLdapObjectArray
                );
        BAIL_ON_FAILURE(hr);

    }else {

        //
        // property has empty values: E.g. status flag indicate delete
        // operation (or empty values allowed on non-ntds ldap server?)
        //

        pLdapObjectArray->pLdapObjects = NULL;
        pLdapObjectArray->dwCount = 0;
        *pdwSyntaxId = LDAPTYPE_UNKNOWN;
        //hr = E_FAIL;
    }

error:

   RRETURN(hr);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if ( newIndex > _dwMaxProperties )
        RRETURN_EXP_IF_ERR(E_FAIL);

    _dwCurrentIndex = newIndex;
    RRETURN(S_OK);

}

HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    ADsAssert(pdwMaxProperties);    // function private -> use assertion

    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
       return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}


LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}



HRESULT
CPropertyCache::
LDAPUnMarshallPropertyAs(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    LPWSTR szPropertyName,
    DWORD dwSyntaxId,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    void *ptr;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        DWORD dwSyntax = LDAPTYPE_UNKNOWN;

        LPWSTR pszADsPath;
        hr = _pCoreADsObject->get_CoreADsPath(&pszADsPath);
        BAIL_ON_FAILURE(hr);

        hr = ADsObject(pszADsPath, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        //
        // unmarshall this property into the
        // property cache
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszServerPath,
                 pszAttrName,
                 &dwSyntax,
                 Credentials,
                 pObjectInfo->PortNumber
                 );
        ADsFreeString(pszADsPath);

        if ( SUCCEEDED(hr) && (dwSyntax != LDAPTYPE_UNKNOWN))
        {
            if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) &&
                 (dwSyntax == LDAPTYPE_OCTETSTRING) )
            {
                dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
            }

            (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit
                       );
        }else {

            if (!_wcsicmp(pszAttrName, szPropertyName)) {

                (VOID) unmarshallproperty(
                           pszAttrName,
                           pLdapHandle,
                           entry,
                           dwSyntaxId,
                           fExplicit
                           );

            }


        }

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        //
        // If we cannot find the syntax, ignore the property and
        // continue with the next property
        //
        hr = S_OK;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    }

error:

    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}



HRESULT
CPropertyCache::
LDAPUnMarshallPropertiesAs(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    DWORD dwSyntaxId,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    void *ptr;

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        (VOID) unmarshallproperty(
                   pszAttrName,
                   pLdapHandle,
                   entry,
                   dwSyntaxId,
                   fExplicit
                   );

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      FreeADsStr(pThisProperty->szPropertyName);
      LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );
      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Need to reset the current index too just in case.
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   FreeADsStr(pThisProperty->szPropertyName);
   LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);

   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}

//
// For dynamic dispid's.
//

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::locateproperty
//
//  Synopsis:   Finds a property in the cache by name.
//
//  This differs from findproperty() in return code; this returns no ADSI
//  errors, since it's going to a VB interface.
//
//  If the property is not found in the cache, this uses the IDirectoryObject
//  interface of the containing object to get the attributes of the object.
//  If GetObjectAttributes doesn't return any information about the property,
//  this method returns DISP_E_UNKNOWNNAME.
//
//  Arguments:  [szPropertyName]        -- Name of the property.
//              [pdwIndex]              -- Index in the array of properties.
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::locateproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    HRESULT hr = findproperty(szPropertyName, pdwIndex);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        DWORD dwLdapSyntaxId = 0;
        PPROPERTY pProperty = NULL;

        hr = _pGetAttributeSyntax->GetAttributeSyntax(
            szPropertyName,
            &dwLdapSyntaxId
            );
        BAIL_ON_FAILURE(hr);

        hr = addproperty(szPropertyName);
        BAIL_ON_FAILURE(hr);

        hr = findproperty(szPropertyName, pdwIndex);
        BAIL_ON_FAILURE(hr);

        pProperty = _pProperties + *pdwIndex;
        PROPERTY_SYNTAX(pProperty) = dwLdapSyntaxId;
        PROPERTY_FLAGS(pProperty) = PROPERTY_INIT;
        PROPERTY_LDAPOBJECTARRAY(pProperty).dwCount = 0;
        PROPERTY_LDAPOBJECTARRAY(pProperty).pLdapObjects = NULL;
    }

error:
    //
    // Automation return code would be DISP_E_UNKNOWNNAME.
    // ADSI return code would be E_ADS_PROPERTY_NOT_FOUND (like findproperty.)
    //
    if (FAILED(hr))
        hr = E_ADS_PROPERTY_NOT_FOUND;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:   Get the values of a property from the cache.
//              The values are returned as a VARIANT.
//
//  Arguments:  [dwIndex]               -- Index of property to retrieve
//              [pVarResult]            -- Data returned as a VARIANT
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::getproperty(
    DWORD dwIndex,
    PDWORD dwStatusFlag,
    VARIANT *pVarResult,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY LdapObjectArray;

    LDAPOBJECTARRAY_INIT(LdapObjectArray);

    //
    // This should not return E_ADS_PROPERTY_NOT_FOUND in this case.
    // We have an index, which should indicate that we have an array entry.
    // If we weren't dealing with VB, I'd be tempted to make this an Assert.
    //
    if (!index_valid(dwIndex))
        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

    if (INDEX_EMPTY(dwIndex) && 
        !PROP_DELETED(dwIndex) && 
        !_fGetInfoDone)
    {
        hr = _pCoreADsObject->GetInfo(FALSE);

        // workaround to avoid confusing callers of getproperty.
        if (hr == E_NOTIMPL)
            hr = DISP_E_MEMBERNOTFOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = unboundgetproperty(
             dwIndex,
             &dwSyntaxId,
             dwStatusFlag,
             &LdapObjectArray
             );

    // For backward compatibility
    if (!LdapObjectArray.pLdapObjects && SUCCEEDED(hr)) {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        if (LdapObjectArray.dwCount == 1) {
            hr = LdapTypeToVarTypeCopy(
                NULL,
                Credentials,
                LdapObjectArray.pLdapObjects,
                dwSyntaxId,
                pVarResult);
        }
        else {
            hr = LdapTypeToVarTypeCopyConstruct(
                NULL,
                Credentials,
                LdapObjectArray,
                dwSyntaxId,
                pVarResult);
        }
    }
    else
    {
        //
        // unboundgetproperty() returns E_FAIL on failure.
        // But getproperty() should return E_ADS_PROPERTY_NOT_FOUND.
        //
        if (hr == E_FAIL)
            hr = E_ADS_PROPERTY_NOT_FOUND;

        //
        // A proper Automation return value would be
        //   hr = DISP_E_MEMBERNOTFOUND;
        //
        ADsAssert(pVarResult);
        V_VT(pVarResult) = VT_ERROR;
    }

error:
    LdapTypeFreeLdapObjects(&LdapObjectArray);

    RRETURN(hr);
}


//
//
// This is here just so that we can compile, no one should be
// calling this
//
//  - The comment above and within the function is INCORRECT.
//  - At present, this function is called and works with known bug.
//    This function should NOT be a wrap around of getproperty with
//    3 param. The [dwIndex] in this function should have a DIFFERENT
//    meaning than the index in the cache.
//  - Please LEAVE this for irenef to fix before beta2.
//

HRESULT
CPropertyCache::getproperty(
    DWORD dwIndex,
    VARIANT *pVarResult,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;

    // Ideally we need to get rid of this but this would mean that
    // we need to change the cdispmgr code and the IPropertyCache
    // interface.
    hr = getproperty(
             dwIndex,
             &dwStatus,
             pVarResult,
             Credentials
             );

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:   Updates a property in the property cache.
//              The property is specified by its index in the array of
//              properties (which is also its DISPID), and the new value
//              is given by a VARIANT.
//
//  Arguments:  [dwIndex]               -- Index of the property.
//              [varValue]              -- Value of the property.
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::putproperty(
    DWORD dwIndex,
    VARIANT vValue
    )
{
    HRESULT hr;
    LDAPOBJECTARRAY LdapObjectArray;
    DWORD dwLdapType;

    LDAPOBJECTARRAY_INIT(LdapObjectArray);

    VARIANT *pvValue = &vValue, *pvArray = NULL;
    DWORD dwNumValues = 1;

    //
    // This should not return E_ADS_PROPERTY_NOT_FOUND in this case.
    // We have an index, which should indicate that we have an array entry.
    // If we weren't dealing with VB, I'd be tempted to make this an Assert.
    //
    if (!index_valid(dwIndex))
        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);


    //
    // If we get a safe array of variants, convert it to a regular array
    // of variants, so we can pass the first one to GetLdapSyntaxFromVariant.
    // We assume that all the elements of the array are of the same type
    //
    if (V_VT(pvValue) == (VT_VARIANT|VT_ARRAY))
    {
        hr = ConvertSafeArrayToVariantArray(vValue, &pvArray, &dwNumValues);
        BAIL_ON_FAILURE(hr);
        pvValue = pvArray;
    }

    //
    // - dwLdapType in cache can be LDAPTYPE_UNKNOWN.
    // - for consistency btw this function and Put/PutEx, will
    //   get type from input VARIANT and overwrite existing type in
    //   cache if any
    //

    ADsAssert(_pCredentials);

    hr = GetLdapSyntaxFromVariant(
             pvValue,
             &dwLdapType,
             _pszServerName,
             (_pProperties+dwIndex)->szPropertyName,
             *_pCredentials,
             _dwPort
             );

    BAIL_ON_FAILURE(hr);

    hr = VarTypeToLdapTypeCopyConstruct(
        _pszServerName,
        *_pCredentials,
        dwLdapType,
        pvValue,
        dwNumValues,
        &LdapObjectArray
        );
    BAIL_ON_FAILURE(hr);

    hr = putproperty(dwIndex, PROPERTY_UPDATE, dwLdapType, LdapObjectArray);
    BAIL_ON_FAILURE(hr);

error:
    // if (hr == E_ADS_CANT_CONVERT_DATATYPE)
    //     hr = DISP_E_TYPEMISMATCH;

    LdapTypeFreeLdapObjects(&LdapObjectArray);

    if (pvArray) {

        for (DWORD i=0; i < dwNumValues; i++) {
            VariantClear(pvArray + i);
        }

        FreeADsMem(pvArray);
    }

    RRETURN(hr);
}


//
// This method is called by _pCoreADsObject->GetInfo().  It signifies
// exactly that the property cache has been filled with all the data
// the server has, i.e. that a GetInfo() has been done.  When this is
// set, further implicit calls to GetInfo are skipped.  This flag is
// cleared only by "flushpropertycache".
//
void
CPropertyCache::setGetInfoFlag()
{
    _fGetInfoDone = TRUE;
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;
    PDISPPROPERTY pThisDispProperty = NULL;

    for (i = 0; i < _dwDispMaxProperties; i++) {

        pThisDispProperty = _pDispProperties + i;

        if (!_wcsicmp(pThisDispProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }

    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);

}

//+---------------------------------------------------------------------------
// Function:   CPropertyCache::GetPropertyNames.
//
// Synopsis:   Gets a list of the names of the properties in this object.
//
// Arguments:  ppUmiPropVals    -   Contains the return value.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyCache::GetPropertyNames(
    UMI_PROPERTY_VALUES **ppUmiPropVals
    )
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProps = NULL;
    PPROPERTY pNextProperty = NULL;
    DWORD dwCtr = 0;

    ADsAssert(ppUmiPropVals);

    //
    // Always have only 1 value.
    //
    pUmiPropVals = (PUMI_PROPERTY_VALUES) 
                       AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!_dwMaxProperties) {
        //
        // No properties, we need to special case this.
        //
        *ppUmiPropVals = pUmiPropVals;
        RRETURN(S_OK);
    }

    pUmiProps = (PUMI_PROPERTY) AllocADsMem(
                    _dwMaxProperties * sizeof(UMI_PROPERTY)
                    );

    if (!pUmiProps) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    
    for(dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
        pNextProperty = _pProperties + dwCtr;

        pUmiProps[dwCtr].pszPropertyName =
            (LPWSTR) AllocADsStr(pNextProperty->szPropertyName);
        if(pUmiProps[dwCtr].pszPropertyName == NULL) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pUmiProps[dwCtr].uCount = 0;
        //
        // Put correct operation type
        //
        hr = ConvertLdapCodeToUmiPropCode(
                 pNextProperty->dwFlags,
                 pUmiProps[dwCtr].uOperationType
                 );
        //
        // Verify that this is the right thing to do.
        // 
        pUmiProps[dwCtr].uType = UMI_TYPE_NULL;
    }

    pUmiPropVals->uCount = _dwMaxProperties;
    pUmiPropVals->pPropArray = pUmiProps;

    *ppUmiPropVals = pUmiPropVals;

    RRETURN(S_OK);

error:

    if(pUmiProps != NULL) {
        for(dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
            if(pUmiProps[dwCtr].pszPropertyName != NULL) {
                FreeADsStr(pUmiProps[dwCtr].pszPropertyName);
            }
        }
        FreeADsMem(pUmiProps);
    }

    if (pUmiProps) {
        FreeADsMem(pUmiPropVals);
    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
AddSavingEntry(
    LPWSTR propertyName
    )
{
    HRESULT hr = S_OK;
    PSAVINGENTRY tempEntry = NULL;
    BOOL fResult = FALSE;

    fResult = FindSavingEntry(propertyName);

    if(!fResult) {
    	tempEntry = new SAVINGENTRY;
        if(!tempEntry) {
            hr = E_OUTOFMEMORY;
    	    BAIL_ON_FAILURE(hr);
        }
    
        tempEntry->entryData = AllocADsStr(propertyName);
        if(!(tempEntry->entryData)) {
            hr = E_OUTOFMEMORY;
            delete tempEntry;
         	
            BAIL_ON_FAILURE(hr);
        }
    
        InsertTailList( &_ListSavingEntries, &tempEntry->ListEntry );
    }
    
error:

	return hr;	
    
}

BOOL
CPropertyCache::
FindSavingEntry(
    LPWSTR propertyName
    )
{
    PLIST_ENTRY listEntry = NULL;
    PSAVINGENTRY EntryInfo = NULL;
    BOOL fResult = FALSE;

    listEntry = _ListSavingEntries.Flink;
    while (listEntry != &_ListSavingEntries) {
        EntryInfo = CONTAINING_RECORD( listEntry, SAVINGENTRY, ListEntry );
        if (!_wcsicmp(EntryInfo->entryData, propertyName)) {
            fResult = TRUE;
            break;
        }

        listEntry = listEntry->Flink;
    }

    return fResult;

}

HRESULT
CPropertyCache::
DeleteSavingEntry()
{
    PLIST_ENTRY pEntry;
    PSAVINGENTRY EntryInfo;

    while (!IsListEmpty (&_ListSavingEntries)) {
        pEntry = RemoveHeadList (&_ListSavingEntries);
        EntryInfo = CONTAINING_RECORD (pEntry, SAVINGENTRY, ListEntry);

        if(EntryInfo->entryData) {
            FreeADsStr(EntryInfo->entryData);
            EntryInfo->entryData = NULL;
        }

        delete EntryInfo;
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cpropmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cpropmgr.cxx
//
//  Contents: Property manager - object that implements/helps implement 
//        IUMIPropList functions.
//        The property manager needs to be initialized in one of 2 modes
//        1) PropertyCache mode in which case it uses the objects existing
//       to provide IUMIPropList support and
//        2) Interface property mode in which case ???    
//
//  Functions: TBD.
//
//  History:    02-07-00    AjayR  Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"


//
// These are global utility fucntions. Might be worth moving to a
// better location subsequently.
//

//+---------------------------------------------------------------------------
// Function:   FreeOneUmiProperty -- Global scope.
//
// Synopsis:   Walk through and free all information being pointed to
//          including the values.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT FreeOneUmiProperty(UMI_PROPERTY umiProperty)
{
    //
    // Free the name now if we can
    //
    if (umiProperty.pszPropertyName) {
        FreeADsStr(umiProperty.pszPropertyName);
        umiProperty.pszPropertyName = NULL;
    }

    if (!umiProperty.pUmiValue) {
        //
        // We are done if count is 0
        //
        if (umiProperty.uCount == 0) {
            RRETURN(S_OK);
        }
        else {
            RRETURN(E_ADS_BAD_PARAMETER);
        }
    }

    //
    // Must have valid umiValues at this point.
    //
    for (ULONG ulCtr = 0; ulCtr < umiProperty.uCount; ulCtr++) {

        switch (umiProperty.uType) {

        case  UMI_TYPE_LPWSTR:
            //
            // Go through and free each of the values.
            //
            if (umiProperty.pUmiValue->pszStrValue[ulCtr]) {
                FreeADsStr(umiProperty.pUmiValue->pszStrValue[ulCtr]);
                umiProperty.pUmiValue->pszStrValue[ulCtr] = NULL;
            }
            break;

        case UMI_TYPE_BOOL:
        case UMI_TYPE_I4:
        case UMI_TYPE_FILETIME:
        case UMI_TYPE_SYSTEMTIME:
        case UMI_TYPE_I8:
            //
            // In all these cases nothing much to free except the value array
            //
            break;

        case UMI_TYPE_OCTETSTRING:
            //
            // Go through and free each of the values.
            //
            if (umiProperty.pUmiValue->octetStr[ulCtr].lpValue) {
                FreeADsMem(umiProperty.pUmiValue->octetStr[ulCtr].lpValue);
                umiProperty.pUmiValue->octetStr[ulCtr].lpValue = NULL;
            }
            break;

        case UMI_TYPE_IUNKNOWN:
            //
            // Need to release the ptr and Free the riid.
            //
            UMI_COM_OBJECT ComObject;

            if (umiProperty.pUmiValue->comObject) {
                ComObject = umiProperty.pUmiValue->comObject[ulCtr];
                
                if (ComObject.pInterface) {
                    ((IUnknown*)ComObject.pInterface)->Release();
                    ComObject.pInterface = NULL;
                }

                if (ComObject.priid) {
                    FreeADsMem((void *)ComObject.priid);
                    ComObject.priid = NULL;
                }
            }

            break;

        default:
            //
            // UmiType that we do not know anything about ??
            //
            ADsAssert(!"Unknown umitype in free memory");
            RRETURN(E_ADS_BAD_PARAMETER);
            break;
        } // end of case
    } // end of for

    //
    // Free the array of values now
    //
    if (umiProperty.pUmiValue) {
        FreeADsMem( (void *)umiProperty.pUmiValue);
        umiProperty.pUmiValue = NULL;
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   FreeUmiPropertyValues -- Global scope.
//
// Synopsis:   Walk through and free all information being pointed to
//          including the values.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT FreeUmiPropertyValues(UMI_PROPERTY_VALUES *pUmiProps)
{
    HRESULT hr = S_OK;

    if (pUmiProps) {
        __try {
    
            //
            // Go through and free each property in the list
            //  
            for (ULONG ulCtr = 0; ulCtr < pUmiProps->uCount; ulCtr++) {

                hr = FreeOneUmiProperty(pUmiProps->pPropArray[ulCtr]);

            }

            //
            // Free the inner array.
            //
            if (pUmiProps->pPropArray) {
                FreeADsMem(pUmiProps->pPropArray);
            }

            //
            // Free the array itself.
            //
            FreeADsMem( (LPVOID) pUmiProps);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_INVALIDARG;
        }
    } 
    else {
        hr = E_INVALIDARG;
    }



    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertUmiPropCodeToLdapCode -- Global scope.
//
// Synopsis:   Convert the property code appropriately.
//
// Arguments:  umiFlags        -   the umiPropCode,
//             dwLdapOpCode&   -  byRef return value.
//
// Returns:    HRESULT - S_OK or E_ADS_BAD_PARAMETER
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT ConvertUmiPropCodeToLdapCode(ULONG umiFlags, DWORD& dwLdapOpCode)
{
    HRESULT hr = S_OK;

    switch (umiFlags) {
    
    case UMI_OPERATION_APPEND:
        dwLdapOpCode = PROPERTY_ADD;
        break;
    
    case UMI_OPERATION_UPDATE:
        dwLdapOpCode = PROPERTY_UPDATE;
        break;

    case UMI_OPERATION_EMPTY:
        dwLdapOpCode = PROPERTY_DELETE;
        break;
    
    case UMI_OPERATION_DELETE_ALL_MATCHES:
        dwLdapOpCode = PROPERTY_DELETE_VALUE;
        break;

    default:
        //
        // we do not handle these values.
        // UMI_OPERATION_INSERT_AT
        // UMI_OPERATION_REMOVE_AT
        // UMI_OPERATION_DELETE_AT
        // UMI_OPERATION_DELETE_FIRST_MATCH
        // UMI_OPERATION_DELETE_ALL_MATCHES
        //
        hr = UMI_E_UNSUPPORTED_OPERATION;
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertLdapCodeToUmiPropCode -- Global scope.
//
// Synopsis:   Convert the property code appropriately.
//
// Arguments:  dwLdapOpCode&   -  property cache operation code.
//             umiFlags&       -  byRef return value.
//
// Returns:    HRESULT - S_OK or E_ADS_BAD_PARAMETER
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT 
ConvertLdapCodeToUmiPropCode(
    DWORD dwLdapCode,
    ULONG &uUmiFlags
    )
{

    HRESULT hr = S_OK;

    switch (dwLdapCode) {
    
    case PROPERTY_ADD:
        uUmiFlags = UMI_OPERATION_APPEND;
        break;
    
    case PROPERTY_UPDATE: 
        uUmiFlags = UMI_OPERATION_UPDATE;
        break;

    case PROPERTY_DELETE:
        uUmiFlags = UMI_OPERATION_EMPTY;
        break;
    
    case PROPERTY_DELETE_VALUE:
        uUmiFlags = UMI_OPERATION_DELETE_ALL_MATCHES;
        break;

     
    case 0:
        //
        // special case values that are just in the cache.
        //
        uUmiFlags = 0;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
        break;
    }

    RRETURN(hr);
}

//****************************************************************************
//
//Internal helpers - restricted scope 
//
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   ConvertVariantLongToUmiProp.
//
// Synopsis:   Convert the variant to a corresponding UmiProp.
//
// Arguments:  vVariant        -  variant containg long val to convert.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertVariantLongToUmiProp(
    VARIANT vVariant,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    LONG *pLArray = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_I4;
    (*ppProp)->pPropArray[0].uCount = 1;
    pLArray = (LONG *) AllocADsMem(sizeof(LONG) * 1);

    if (!pLArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pLArray[0] = vVariant.lVal;
    

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pLArray;

error :

    if (FAILED(hr)) {
        if (pLArray) {
            FreeADsMem( (void*) pLArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

HRESULT
GetEmptyLPWSTRProp(UMI_PROPERTY_VALUES **ppProp)
{
    HRESULT hr = S_OK;
    
    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->uCount = 1;
    

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_LPWSTR;
    (*ppProp)->pPropArray[0].uCount = 0;
    
    (*ppProp)->pPropArray[0].pUmiValue = NULL;


error :

    if (FAILED(hr)) {
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   ConvertBSTRToUmiProp.
//
// Synopsis:   Convert the bstr to a corresponding UmiProp.
//
// Arguments:  bstrStringVal   -  String to convert to umi values.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertBSTRToUmiProp(
    BSTR bstrStringVal,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    LPWSTR * pszStrArray = NULL;
    LPWSTR pszTmpStr = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_LPWSTR;
    (*ppProp)->pPropArray[0].uCount = 1;
    pszStrArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 1);

    if (!pszStrArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the value is NULL, then we return an array with a NULL
    // value as the result.
    //
    if (bstrStringVal) {
        pszStrArray[0] = AllocADsStr(bstrStringVal);
    
        if (!pszStrArray[0]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pszStrArray;

error :

    if (FAILED(hr)) {
        if (pszStrArray) {
            FreeADsMem( (void*) pszStrArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertIUnkToUmiProp.
//
// Synopsis:   Convert the IUnk to a corresponding UmiProp.
//
// Arguments:  pUnk            -  IUnk ptr.
//             iid             -  iid of the ptr.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertIUnkToUmiProp(
    IUnknown * pUnk,
    IID iid,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    PUMI_COM_OBJECT pComObjArray = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_IUNKNOWN;
    (*ppProp)->pPropArray[0].uCount = 1;
    pComObjArray = (PUMI_COM_OBJECT) AllocADsMem(sizeof(UMI_COM_OBJECT) * 1);

    if (!pComObjArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = pUnk->QueryInterface(
                   iid,
                   (void **) &(pComObjArray[0].pInterface)
                   );
    BAIL_ON_FAILURE(hr);

    pComObjArray[0].priid = (IID *) AllocADsMem(sizeof(IID));
    if (!pComObjArray[0].priid) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pComObjArray[0].priid, &iid, sizeof(IID));

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pComObjArray;

error :

    if (FAILED(hr)) {
        if (pComObjArray) {
            if (pComObjArray[0].pInterface) {
                ((IUnknown *)pComObjArray[0].pInterface)->Release();
            }
            FreeADsMem( (void*) pComObjArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiRelUrl.
//
// Synopsis:   Gets the __RELURL property for the object. This routine
//          combines the IADs::get_Name and IADs::get_Class
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiRelUrl(
    IADs * pIADs,
    BSTR * bstrRetVal
    )
{
    HRESULT hr = S_OK;
    BSTR bstrName = NULL, bstrClass = NULL;
    LPWSTR pszTempVal = NULL;
    BOOL fSchemaObject = FALSE;

    hr = pIADs->get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    //
    // See if this is a schema object.
    //
    if (!_wcsicmp(bstrClass, L"Schema")
        || !_wcsicmp(bstrClass, L"Class")
        || !_wcsicmp(bstrClass, L"Property")
        )
         {
        LPWSTR pszTemp;
        //
        // If this is indeed a schema object then the name
        // wont have any = sign in it. Equal is not allowed
        // in the names of schema objects.
        //
        if ((pszTemp = wcschr(bstrName, L'=')) == NULL)
        fSchemaObject = TRUE;
    }

    //
    // Add 2 as we need 1 for the \0 and the other for the . 
    // in class.name
    //
    DWORD dwLen;
    dwLen = wcslen(bstrName) + wcslen(bstrClass) + 2;

    if (fSchemaObject) {
        //
        // Need to add space for .Name
        //
        dwLen = dwLen + 6;

    }

    pszTempVal = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));

    if (!pszTempVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!fSchemaObject) {
        wsprintf(pszTempVal, L"%s.%s", bstrClass, bstrName);
    } 
    else {
        wsprintf(pszTempVal, L"%s.Name=%s", bstrClass, bstrName);
    }

    hr = ADsAllocString(pszTempVal, bstrRetVal);

    BAIL_ON_FAILURE(hr);

error:

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }

    if (pszTempVal) {
        FreeADsStr(pszTempVal);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiSchemaContainerPath.
//
// Synopsis:   Gets the Umi path to the schema container for this object.
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *bstrRetVal points to the correct schema path.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiSchemaContainerPath(
    IADs * pIADs,
    BSTR * bstrRetVal
    )
{
    HRESULT hr = S_OK;
    BSTR bstrSchema = NULL;
    LPWSTR pszParent = NULL, pszCN = NULL, pszUmiSchema = NULL;

    //
    // First we need the path of the schema object itslef.
    //
    hr = pIADs->get_Schema(&bstrSchema);
    BAIL_ON_FAILURE(hr);

    //
    // Now we can build the path to the schema container from the path.
    //
    hr = BuildADsParentPath(
             bstrSchema,
             &pszParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsPathToUmiURL(pszParent, &pszUmiSchema);

    BAIL_ON_FAILURE(hr);
           
    hr = ADsAllocString(pszUmiSchema, bstrRetVal);

    BAIL_ON_FAILURE(hr);

error:

    if (bstrSchema) {
        SysFreeString(bstrSchema);
    }

    if (pszCN) {
        FreeADsStr(pszCN);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszUmiSchema) {
        FreeADsStr(pszUmiSchema);
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiDerivedFrom.
//
// Synopsis:   Gets the value of the class that the current class object
//          is derived from.
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *bstrRetVal points to the correct schema path.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiDerivedFrom(
    IADs * pIADs,
    BSTR * pbstrRetVal
    )
{
    HRESULT hr = S_OK;
    IADsClass *pClass = NULL;
    BSTR bstrName = NULL;
    VARIANT vVariant;

    VariantInit(&vVariant);
    *pbstrRetVal = NULL;

    hr = pIADs->get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // If the class is Top then we just return NULL.
    //
    if (_wcsicmp(bstrName, L"Top")) {
        //
        // Get the IADsClass interface, this is done because IADs::Get
        // will need to ask for different attributes based on the server.
        // IADsClass encapsulates this difference for us.
        //
        hr = pIADs->QueryInterface(IID_IADsClass, (void **) &pClass);
        if (FAILED(hr)) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    
        hr = pClass->get_DerivedFrom(&vVariant);
        BAIL_ON_FAILURE(hr);
    
        ADsAssert(vVariant.vt == VT_BSTR);
        hr = ADsAllocString(vVariant.bstrVal, pbstrRetVal);
    }
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vVariant);

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (pClass) {
        pClass->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperConvertNameToKey.
//
// Synopsis:   Converts the value of the BSTR (of the form cn=test) to cn
//          as required by UMI.
//
// Arguments:  bstrName     -  Value to get the key from.
//             pszUmiKey    -  Return value for the key.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pszUmiUrl points to the key.
//
//----------------------------------------------------------------------------
HRESULT
HelperConvertNameToKey(
    BSTR bstrName,
    LPWSTR * pszUmiUrl
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTemp = bstrName;
    BOOL fEqualFound = FALSE;
    DWORD dwCount = 0;

    ADsAssert(bstrName && pszTemp && *pszTemp);

    while (pszTemp 
           && *pszTemp
           && (!fEqualFound)
           ) {
        if (*pszTemp == L'=') {
            fEqualFound = TRUE;
        }
        dwCount++;
        pszTemp++;
    }

    if (!fEqualFound) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    *pszUmiUrl = (LPWSTR) AllocADsMem(dwCount * sizeof(WCHAR));
    if (!*pszUmiUrl) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcsncpy(*pszUmiUrl, bstrName, (dwCount-1));

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperUpdateSDFlags.
//
// Synopsis:   On put/get calls updates the security flags appropriately.
//
// Arguments:  pIADs       -  IADs pointer to use to update sd.
//             uFlags      -  Flags to use for getting SD.
//             pfUpdated   -  Return boolean value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   Underlying property cache and pfUpdated to TRUE if the
//          flags on the object had to be changed and FALSE otherwise.
//
//----------------------------------------------------------------------------
HRESULT
HelperUpdateSDFlags(
    IADs *pIADs,
    ULONG uFlags,
    BOOL *pfUpdated = NULL
    )
{
    HRESULT hr = S_OK;
    IADsObjOptPrivate *pPrivOpt = NULL;
    SECURITY_INFORMATION secInfo;

    ADsAssert(pIADs);

    if (pfUpdated) {
        *pfUpdated = FALSE;
    }

    //
    // Get the objOpt intf and make sure the flags are right.
    //
    hr = pIADs->QueryInterface(IID_IADsObjOptPrivate, (void **) &pPrivOpt);
    BAIL_ON_FAILURE(hr);

    hr = pPrivOpt->GetOption(
             LDAP_SECURITY_MASK,
             (void *) &secInfo
             );
    BAIL_ON_FAILURE(hr);

    if (secInfo != uFlags) {
        //
        // We need to update the security mask on the object.
        //
        hr = pPrivOpt->SetOption(
                 LDAP_SECURITY_MASK,
                 (void **) &uFlags
                 );
        BAIL_ON_FAILURE(hr);
        //
        // Need to let caller know that the flags have changed.
        //
        if (pfUpdated) {
            *pfUpdated  = TRUE;
        }
    }

error:

    if (pPrivOpt) {
        pPrivOpt->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetSDIntoCache.
//
// Synopsis:   Reads the sd into the property cache using the appropriate
//          flags as needed.
//
// Arguments:  pIADs       -  IADs pointer to use to update sd.
//             uFlags      -  Flags to use for getting SD.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT HelperGetSDIntoCache(
    IADs * pIADs,
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    BOOL fUpdated = FALSE;
    LPWSTR szSecDesc[] = {L"ntSecurityDescriptor"};

    VariantInit(&vVar);

    hr = HelperUpdateSDFlags(
             pIADs,
             (uFlags & UMI_SECURITY_MASK),
             &fUpdated
             );
    BAIL_ON_FAILURE(hr);

    if (fUpdated) {
        //  
        // Update just the SD by calling GetInfoEx.
        //
        hr = ADsBuildVarArrayStr(
                 szSecDesc,
                 1,
                 &vVar
                 );
        BAIL_ON_FAILURE(hr);

        hr = pIADs->GetInfoEx(vVar, 0);
        BAIL_ON_FAILURE(hr);
    }

error :

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetOrigin.
//
// Synopsis:   Gets the originating class for the property in question.
//
// Arguments:  pIADs       -  IADs pointer to backing object.
//             pszName     -  Name of the property whose origin is needed.
//             ppProp      -  Return value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetOrigin(
    IADs *pIADs,
    LPCWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    IADsUmiHelperPrivate *pHelper = NULL;
    BSTR bstrVal = NULL;

    hr = pIADs->QueryInterface(
             IID_IADsUmiHelperPrivate,
             (void **) &pHelper
             );
    if (FAILED(hr)) {
        //
        // This object does not support this property as it is not
        // a class object.
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    hr = pHelper->GetOriginHelper(
             pszName,
             &bstrVal
             );
    BAIL_ON_FAILURE(hr);

    hr = ConvertBSTRToUmiProp(
             bstrVal,
             ppProp
             );
error:
    if (bstrVal) {
        SysFreeString(bstrVal);
    }

    if (pHelper) {
        pHelper->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CopyUmiProperty.
//
// Synopsis:   Copy the input value into a newly allocated output buffer.
//          Note that since this is an internal routine assumptions are made
//          as to the data. Currently handles only UMI_TYPE_LPWSTR,
//          UMI_TYPE_I4 and UMI_TYPE_BOOL. If multivalued, we can only copy
//          strings (things like filter on enum can be multi-valued).
//
// Arguments:  umiProp         -  Umi property value to copy.
//             ppUmiProp       -  Return value for new umi property.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppUmiProp to point to valid UMI_PROPERTY.
//
//----------------------------------------------------------------------------
HRESULT
CopyUmiProperty(
    UMI_PROPERTY umiProp,
    PUMI_PROPERTY *ppUmiProp
    )
{
    HRESULT hr = S_OK;
    UMI_PROPERTY *pUmiPropLocal = NULL;
    ULONG ulUmiType = umiProp.uType;
    ULONG ulPropCount = umiProp.uCount;

    *ppUmiProp = NULL;

    //
    // Multi valued has to be string.
    //
    if ((ulPropCount > 1) && (ulUmiType != UMI_TYPE_LPWSTR)) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    pUmiPropLocal = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!pUmiPropLocal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pUmiPropLocal->pszPropertyName = AllocADsStr(umiProp.pszPropertyName);
    
    if (!pUmiPropLocal->pszPropertyName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pUmiPropLocal->uOperationType = umiProp.uOperationType;
    pUmiPropLocal->uType = umiProp.uType;

    switch (umiProp.uType) {
    
    case UMI_TYPE_LPWSTR :
        LPWSTR *pszTmpArray;
        pszTmpArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * ulPropCount);
        
        if (!pszTmpArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (DWORD dwCtr = 0; dwCtr < ulPropCount; dwCtr++) {
            pszTmpArray[dwCtr] = AllocADsStr(
                umiProp.pUmiValue->pszStrValue[dwCtr]
                );
            
            if (!pszTmpArray[dwCtr]) {
                //
                // NULL is allowed as a value only if it is the
                // only value being set.
                //
                if (ulPropCount != 1
                    || umiProp.pUmiValue->pszStrValue[dwCtr] 
                    ) {
                    //
                    // Cleanup and exit.
                    //
                    for (DWORD dwCtr2 = 0; dwCtr2 < dwCtr; dwCtr2++) {
                        if (pszTmpArray[dwCtr2]) {
                            FreeADsStr(pszTmpArray[dwCtr2]);
                            pszTmpArray[dwCtr2] = NULL;
                        }
                    }
                    FreeADsMem(pszTmpArray);
                    pszTmpArray = NULL;
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
            } // if alloc failed in middle of array.
        }
        
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pszTmpArray;
        break;

    case UMI_TYPE_I4:
        LONG *pLongArray;

        pLongArray = (LONG *) AllocADsMem(sizeof(LONG) * 1);
        if (!pLongArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pLongArray[0] = umiProp.pUmiValue->lValue[0];
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pLongArray;
        break;

    case UMI_TYPE_BOOL:
        BOOL *pBoolArray;

        pBoolArray = (BOOL *) AllocADsMem(sizeof(BOOL) * 1);
        if (!pBoolArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pBoolArray[0] = umiProp.pUmiValue->bValue[0];
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pBoolArray;
        break;

    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        break;

    }

    pUmiPropLocal->uCount = ulPropCount;
    *ppUmiProp = pUmiPropLocal;

    RRETURN(hr);

error:
    //
    // Cleanup cause we hit an error.
    //
    if (pUmiPropLocal) {
        FreeOneUmiProperty(*pUmiPropLocal);
        FreeADsMem( (void*) pUmiPropLocal);
    }

    RRETURN(hr);
}

//****************************************************************************
//
//CPropertyManager Methods.
//
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CPropertyManager
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CPropertyManager::CPropertyManager():
    _dwMaxProperties(0),
    _pPropCache(NULL),
    _pIntfProperties(NULL),
    _dwMaxLimit(0),
    _fPropCacheMode(TRUE),
    _pStaticPropData(NULL),
    _ulStatus(0),
    _pIADs(NULL),
    _pUnk(NULL),
    _pCreds(NULL),
    _pszServerName(NULL)
{
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::~CPropertyManager
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CPropertyManager::~CPropertyManager()
{
    //
    // Need to cleanup inftProps table
    // 
    if (_pIntfProperties) {
        DWORD dwCtr;
        for (dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
            //
            // Free each of the entries and their contents.
            //
            PINTF_PROPERTY pIntfProp = &(_pIntfProperties[dwCtr]);

            if (pIntfProp->pszPropertyName) {
                FreeADsStr(pIntfProp->pszPropertyName);
                pIntfProp->pszPropertyName = NULL;
            }

            if (pIntfProp->pUmiProperty) {
                FreeOneUmiProperty(*(pIntfProp->pUmiProperty));
                FreeADsMem(pIntfProp->pUmiProperty);
                pIntfProp->pUmiProperty = NULL;
            }
        }
        FreeADsMem(_pIntfProperties);
    }

    _pIntfProperties = NULL;

    //
    // The rest of the stuff is taken care of when the
    // destructor to the IADs obj is called. This object
    // itself will be released only in the destructor of the
    // IADs object is called.
    //
    _pPropCache = NULL;
    
    if (_pIADs) {
        _pIADs->Release();
    } 

    _pIADs = NULL;
    _dwMaxProperties = 0;

    //
    // Do not free as these are owned by the owning object.
    //
    _pszServerName = NULL;
    _pCreds = NULL;
    _pUnk = NULL;

}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CreatePropertyManager (overloaded)
//
// Synopsis:   Static allocation routine (property cache mode).
//
// Arguments:  IADs*             -  pointer to IADs implementor object.
//             pUnk              -  owning object unknown.
//             pPropCache        -  pointer to propertyCache used by object.
//             pCredentials      -  pointer to credentials.
//             pszServerName     -  pointer to servername.
//             ppPropertyManager -  return ptr for new prop mgr.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CPropertyManager ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::CreatePropertyManager(
    IADs *pADsObj,
    IUnknown *pUnk,
    CPropertyCache *pPropCache,
    CCredentials *pCredentials,
    LPWSTR pszServerName,
    CPropertyManager FAR * FAR * ppPropertyManager
    )
{
    CPropertyManager FAR * pPropMgr = NULL;

    pPropMgr = new CPropertyManager();

    if (!pPropMgr) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    if (pADsObj) {
        pADsObj->QueryInterface(IID_IADs, (void**) &(pPropMgr->_pIADs));
    }

    pPropMgr->_pUnk =  pUnk;
    pPropMgr->_pPropCache = pPropCache;
    pPropMgr->_fPropCacheMode = TRUE;
    pPropMgr->_pIntfProperties = NULL;
    pPropMgr->_pszServerName = pszServerName;
    pPropMgr->_pCreds = pCredentials;

    *ppPropertyManager = pPropMgr;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CreatePropertyManager (overloaded)
//
// Synopsis:   Static allocation routine (interface properties mode).
//
// Arguments:  pUnk              - pointer to owner (umi) object.
//             pIADs             - pointer to IADs implementor.
//             pCredentials      - pointer to credentials.
//             pTable            - property table.
//             ppPropertyManager - return value for new prop mgr.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CPropertyManager ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::CreatePropertyManager(
    IUnknown *pUnk,
    IUnknown *pIADs,
    CCredentials *pCredentials,
    INTF_PROP_DATA pTable[],
    CPropertyManager FAR * FAR * ppPropertyManager
    )
{
    CPropertyManager FAR * pPropMgr = NULL;

    pPropMgr = new CPropertyManager();

    if (!pPropMgr) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropMgr->_pUnk = pUnk;
    
    //
    // We can ignore any failures here.
    //
    if (pIADs) {
        pIADs->QueryInterface(IID_IADs, (void**) &(pPropMgr->_pIADs));
    }

    pPropMgr->_pPropCache = NULL;
    pPropMgr->_fPropCacheMode = FALSE;
    pPropMgr->_pIntfProperties = NULL;
    pPropMgr->_pCreds = pCredentials;
    pPropMgr->_pStaticPropData = pTable;

    *ppPropertyManager = pPropMgr;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyManager::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    SetLastStatus(0);
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiPropList FAR *) this;
    }
    else {
        *ppv = NULL;
        SetLastStatus(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}


//
// Methods defined on the proplist interface.
//

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Put (IUmiPropList support).
//
// Synopsis:   Sets the value for the attribute in the cache.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   PropertyCache or internal interface property list.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Put(
    IN LPCWSTR pszName,
    IN ULONG   uFlags,
    IN UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapDestObjects;
    DWORD dwOperationFlags = 0;
    BOOL fSecurityFlags = FALSE;
    IUmiObject *pUmiObj = NULL;
    BOOL fInternalPut = FALSE;

    SetLastStatus(0);

    //
    // Initialize so that we are not trying to free junk.
    //
    if (_fPropCacheMode) {
       LDAPOBJECTARRAY_INIT(ldapDestObjects);
    }

    //
    // Pre process and pull out the highest flag, all these
    // because we are not allowed to support Put with 0.
    //
    if (uFlags & 0x8000000) {
        uFlags &= 0x4000000;
        fInternalPut = TRUE;
    }

    if (uFlags > UMI_SECURITY_MASK) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }
    if (!pProp || !pszName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        fSecurityFlags = TRUE;
    }

    //
    // We support only putting one property at a time.
    //
    if (pProp->uCount != 1) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // Make sure that the data passed in is correct.
    //        
    if (!pProp->pPropArray
        || !pProp->pPropArray[0].pszPropertyName) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (_fPropCacheMode) {
        DWORD dwLdapSyntaxId = 1;

        if (fInternalPut
            && pProp->pPropArray[0].uOperationType == 0) {
            dwOperationFlags = 0;
        } 
        else {
            //
            // Verify that the operationType is something we support.
            //
            hr = ConvertUmiPropCodeToLdapCode(
                     pProp->pPropArray[0].uOperationType,
                     dwOperationFlags
                     );
            BAIL_ON_FAILURE(hr);
        }

        if (fSecurityFlags) {
            //
            // Only this ntSecurityDescriptor can use the security flags.
            //
            if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }
            hr = HelperUpdateSDFlags(
                     _pIADs,
                     uFlags & UMI_SECURITY_MASK
                     );
            BAIL_ON_FAILURE(hr);
        }

        //
        // In this case we need to convert data to ldap values and
        // store in cache.
        //
        hr = UmiTypeToLdapTypeCopy(
                 *pProp,
                 uFlags,
                 &ldapDestObjects,
                 dwLdapSyntaxId,  // byRef
                 _pCreds,
                 _pszServerName
                 );
        BAIL_ON_FAILURE(hr);

        //
        // PutpropertyExt will add to the cache if needed.
        //
        hr = _pPropCache->putpropertyext(
                 (LPWSTR)pszName,
                 dwOperationFlags,
                 dwLdapSyntaxId,
                 ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
               
    } 
    else {
        //
        // Local cache for interface properties. Verify property is 
        // legal and update the local information accordingly.
        //
        if (VerifyIfValidProperty(
                pProp->pPropArray[0].pszPropertyName,
                pProp->pPropArray[0]
                )
            ) {

            if (fSecurityFlags
                || !_wcsicmp(pszName, L"__SECURITY_DESCRIPTOR")
                ) {
                //
                // Make sure name is correct.
                //
                if (_wcsicmp(L"__SECURITY_DESCRIPTOR", pszName)) {
                    BAIL_ON_FAILURE(hr = E_FAIL);
                }
                //
                // We need turn around and call put on the owning object.
                // This means we need to package the UMI_PROPERTY_VALUES
                // accordingly.
                //
                UMI_PROPERTY pUmiProperty[] = {
                    pProp->pPropArray[0].uType,
                    pProp->pPropArray[0].uCount,
                    pProp->pPropArray[0].uOperationType,
                    L"ntSecurityDescriptor",
                    pProp->pPropArray[0].pUmiValue
                };

                UMI_PROPERTY_VALUES pUmiProp[] = {1, pUmiProperty};

                hr = _pUnk->QueryInterface(
                         IID_IUmiObject,
                         (void **) &pUmiObj
                         );
                BAIL_ON_FAILURE(hr);

                hr = pUmiObj->Put(
                         L"ntSecurityDescriptor",
                         uFlags,
                         pUmiProp
                         );
                BAIL_ON_FAILURE(hr);
            } 
            else {
                //
                // We need to update this value in our cache
                //
                hr = AddProperty(
                         pszName,
                         pProp->pPropArray[0]
                         );                
                BAIL_ON_FAILURE(hr);
            } 
        } // not valid property.
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

error :

    //
    // Free ldapDestObjects if applicable.
    //
    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects( &ldapDestObjects );
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Get (IUmiPropList support).
//
// Synopsis:   Gets the value for the attribute. This will read data 
//        from the server as needed.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the values of the attribute.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Get(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProp
    )
{
    HRESULT hr = S_OK;
    ULONG uUmiFlag;
    LDAPOBJECTARRAY ldapSrcObjects;
    BOOL fSecurityFlag = FALSE;
    BOOL fSchemaFlag   = FALSE;
    IADsObjOptPrivate *pPrivOpt = NULL;

    SetLastStatus(0);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (!pProp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    *pProp = NULL;
    //
    // Currently this is the highest flag we support.
    //
    if (uFlags > UMI_FLAG_PROPERTY_ORIGIN) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    } 
    else if (uFlags & UMI_SECURITY_MASK) {
        fSecurityFlag = TRUE;
    }
    else if (uFlags == UMI_FLAG_PROPERTY_ORIGIN) {
        fSchemaFlag = TRUE;
    }

    if (fSchemaFlag && fSecurityFlag) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    //
    // Name cannot be NULL.
    //
    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG)
    }

    //
    // If this is Property Manager is for server properties.
    //
    if (_fPropCacheMode) {

        DWORD dwSyntaxId;
        DWORD dwStatus;
        DWORD dwSecOptions;
    
        if (fSchemaFlag) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }
        
        if (fSecurityFlag) {
            if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
                //
                // Security flag used and attrib not securityDescriptor.
                //
                BAIL_ON_FAILURE(hr = E_FAIL);
            } 
            else {
                //
                // Valid flag we need to process the flags.
                //
                hr = HelperGetSDIntoCache(
                         _pIADs,
                         uFlags
                         );
                BAIL_ON_FAILURE(hr);
            }
        }
        
        //
        // Object maybe unbound, so we should return no such prop if
        // we get back E_ADS_OBJECT_UNBOUND.
        //
        hr = _pPropCache->getproperty(
                 (LPWSTR)pszName,
                 &dwSyntaxId,
                 &dwStatus,
                 &ldapSrcObjects
                 );
    
        if (hr == E_ADS_OBJECT_UNBOUND) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

        BAIL_ON_FAILURE(hr);

        hr = ConvertLdapCodeToUmiPropCode(dwStatus, uUmiFlag);
        BAIL_ON_FAILURE(hr);
    
        //
        // Return error if provider cache is not set and
        // the cache is dirty.
        //
        if (uUmiFlag && !(uFlags & UMI_FLAG_PROVIDER_CACHE)) {
            BAIL_ON_FAILURE(hr = UMI_E_SYNCHRONIZATION_REQUIRED);
        }

        //
        // At this point we might have ldapSrcObjects.pLdapObjects == NULL.
        // Typically that would be for property delete operations.
        //
        hr = LdapTypeToUmiTypeCopy(
                 ldapSrcObjects,
                 pProp,
                 dwStatus,
                 dwSyntaxId,
                 _pCreds,
                 _pszServerName,
                 uUmiFlag
                 );

    }
    else {
        //
        // Property Manager is for interface properties.
        //
        DWORD dwIndex;

        //
        // If the schema flag is set then we need to get the origin
        // and not the property itself.
        //
        if (fSchemaFlag) {
            hr = HelperGetOrigin(
                     _pIADs,
                     pszName,
                     pProp
                     );

        } 
        else {
            //
            // Make sure this property is valid.
            //
            hr = GetIndexInStaticTable(pszName, dwIndex); // dwIndex is byRef
            BAIL_ON_FAILURE(hr);

            hr = GetInterfaceProperty(
                     pszName,
                     uFlags,
                     pProp,
                     dwIndex
                     );
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // Stuff the name in the return value.
    //
    if (pProp && *pProp) {
        (*pProp)->pPropArray[0].pszPropertyName = AllocADsStr(pszName);

        if (!(*pProp)->pPropArray[0].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects(&ldapSrcObjects);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);

        if (pProp && *pProp) {
            this->FreeMemory(0, (void *) *pProp);
            *pProp = NULL;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetAt (IUmiPropList support).
//
// Synopsis:   Used to get the value by index ???
//
// Arguments:  Not implemented
//
//
// Returns:    E_NOTIMPL
//
// Modifies:   Not implemented
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetAt(
    IN  LPCWSTR pszName,
    IN  ULONG   uFlags,
    IN  ULONG   uBufferLength,
    OUT LPVOID  pExisitingMem
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetAs (IUmiPropList support).
//
// Synopsis:   Gets the value for the attribute in the specified format. 
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the values of the attribute.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetAs(
    IN     LPCWSTR pszName,
    IN     ULONG uFlags,
    IN     ULONG uCoercionType,
    IN OUT UMI_PROPERTY_VALUES **pProp
    )
{
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapSrcObjects;
    LDAPOBJECTARRAY ldapSrcObjectsTmp;
    LDAPOBJECTARRAY * pldapObjects = NULL;
    ULONG uUmiFlag;
    DWORD dwSyntaxId, dwStatus, dwRequestedSyntax;
    DWORD dwCachedSyntax, dwUserSyntax;


    SetLastStatus(0);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);
    LDAPOBJECTARRAY_INIT(ldapSrcObjectsTmp);

    if (!pszName || !pProp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Has to be in prop cache mode.
    //
    if (!_fPropCacheMode || !_pPropCache) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    if (uFlags > UMI_SECURITY_MASK) {
        BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        //
        // Make sure it is the SD they are interested in.
        //
        if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
        //
        // At this point we need to get the SD in the cache.
        //
        hr = HelperGetSDIntoCache(_pIADs, uFlags);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Object maybe unbound, so we should return no such prop if
    // we get back E_ADS_OBJECT_UNBOUND.
    //
    hr = _pPropCache->getproperty(
             (LPWSTR)pszName,
             &dwSyntaxId,
             &dwStatus,
             &ldapSrcObjects
             );

    if (hr == E_ADS_OBJECT_UNBOUND) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Get the appropriate umi code for the status.
    //
    hr = ConvertLdapCodeToUmiPropCode(dwStatus, uUmiFlag);
    BAIL_ON_FAILURE(hr);

    //
    // At this point we need to see if we can convert the data
    // to the format requested. This code is similar to that in
    // proplist.cxx GetPropertyItem but there appears to be no
    // easy way to avoid this duplication.
    //
    dwCachedSyntax = dwSyntaxId;

    //
    // Need to take the requested type to ADs types and from there to
    // ldap types.
    //
    hr = UmiTypeToLdapTypeEnum(uCoercionType, &dwUserSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // We can convert to any requested type only if it is unknown.
    //
    if (dwCachedSyntax == LDAPTYPE_UNKNOWN) {
        dwRequestedSyntax = dwUserSyntax;
    } 
    else if (dwCachedSyntax == dwUserSyntax) {
        //
        // Easy one !
        //
        dwRequestedSyntax = dwCachedSyntax;
    } 
    else {
        //
        // This means we already have a type. In this case the only
        // coercion we allows is SD to binary blob and vice-versa.
        //
        if ((dwCachedSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
            && (dwUserSyntax == LDAPTYPE_OCTETSTRING)
            ) {
            dwRequestedSyntax = dwUserSyntax;
        } 
        else if ((dwCachedSyntax == LDAPTYPE_OCTETSTRING)
              && (dwUserSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
              ) {
            dwRequestedSyntax = dwUserSyntax;
        }
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // If the data is in a state that needs conversion the fn will
    // take care - note that if the source is already in the correct
    // format then the HR will S_FALSE.
    //
    hr = LdapTypeBinaryToString(
             dwRequestedSyntax,
             &ldapSrcObjects,
             &ldapSrcObjectsTmp
             );
    BAIL_ON_FAILURE(hr);

    if (hr == S_OK) {
        pldapObjects = &ldapSrcObjectsTmp;
    } 
    else {
        //
        // We already have the data in the right format.
        //
        pldapObjects = &ldapSrcObjects;
        hr = S_OK;
    }

    //
    // Now that we have the correct data in pLdapObjects, we need
    // to convert that to Umi Properties.
    //
    hr = LdapTypeToUmiTypeCopy(
             *pldapObjects,
             pProp,
             dwStatus,
             dwRequestedSyntax,
             _pCreds,
             _pszServerName,
             uUmiFlag
             );
    BAIL_ON_FAILURE(hr);

    //
    // Stuff the name in the return value.
    //
    if (pProp) {
        (*pProp)->pPropArray[0].pszPropertyName = AllocADsStr(pszName);

        if (!(*pProp)->pPropArray[0].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects(&ldapSrcObjects);
        LdapTypeFreeLdapObjects(&ldapSrcObjectsTmp);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);

        if (pProp) {
            this->FreeMemory(0, (void *)*pProp);
            *pProp = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::FreeMemory (IUmiPropList support).
//
// Synopsis:   Free memory pointed to. Note that the pointer should have 
//        originally come from a Get/GetAs call.
//
// Arguments:  Ptr to data to be freed.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *pMem is of course freed.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::FreeMemory(
    ULONG  uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (uReserved) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (pMem) {
        //
        // At this time this has to be a pUmiProperty. Ideally we should
        // tag this in some way so that we can check to make sure.
        //
        hr = FreeUmiPropertyValues((UMI_PROPERTY_VALUES *)pMem);
    } 
    else {
        hr = E_INVALIDARG;
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}
        
//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Delete (IUmiPropList support).
//
// Synopsis:   Delete the named property from the cache.
//
// Arguments:  pszName   -   Name of property to delete.
//             uFlags    -   Standard flags parameter.
//
// Returns:    E_NOTIMPL.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Delete(
    IN LPCWSTR pszName,
    IN ULONG uFlags
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetProps (IUmiPropList support).
//
// Synopsis:   Gets the values for the attributes. This will read data 
//        from the server as needed.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the an array of values for the 
//        attributes. Note that there is no ordering specified
//        for the return values. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = S_OK;

    if ((uFlags != UMI_FLAG_GETPROPS_NAMES)
        && (uFlags != UMI_FLAG_GETPROPS_SCHEMA)
        ) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // Currently we support only getting the names of all the properties.
    //
    if (pszNames
        || uNameCount
        || !pProps
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    *pProps = NULL;

    if (_fPropCacheMode) {
        //
        // Only UMI_FLAG_GETPROPS_NAMES is valid in this case.
        //
        if (uFlags != UMI_FLAG_GETPROPS_NAMES) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }

        hr = _pPropCache->GetPropertyNames(pProps);
    } 
    else {
        //
        // Need to see what type of flag it is and extra check needed,
        // if this is UMI_FLAGS_GETPROPS_SCHEMA.
        //
        if (uFlags == UMI_FLAG_GETPROPS_SCHEMA) {
            LONG lVal;
            hr = GetLongProperty(L"__GENUS", &lVal);
            
            BAIL_ON_FAILURE(hr);

            if (lVal != UMI_GENUS_CLASS) {
                BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
            }

            hr = GetPropertyNamesSchema(pProps);
        } 
        else {
            //
            // Need to do get our static list.
            //
            hr = this->GetPropertyNames(pProps);
        }
    } // else for !propertyCacheMode.

error:

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::PutProps (IUmiPropList support).
//
// Synopsis:   Puts the value for the attributes in the cache.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Property cache for the object.
//
//---------------------------------------------------------------------------- 
HRESULT 
CPropertyManager::PutProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    IN UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = S_OK;
    
    //
    // When done - should get and put multiple work directly of the server ?
    // That would take care off problems like 5 can be put in the cache
    // but sixth cannot ...
    //
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::PutFrom (IUmiPropList support).
//
// Synopsis:   Clarify exactly what this is supposed to do ?
//
// Arguments:  self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Property cache for the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::PutFrom(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    IN  ULONG uBufferLength,
    IN  LPVOID pExistingMem
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}



//
// PropertyManager methods that are not part of the IUmiPropList interface.
//

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetLastStatus
//
// Synopsis:   Returns the error from the last operation on this object.
//          For now only the status code is supported.
//
// Arguments:  uFlags            -   Must be 0 for now.
//             puSpecificStatus  -   Status is returned in this value.
//             riid              -   IID requested on status obj.
//             pStatusObj        -   Must be NULL for now.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *puSpecificStatus with last status code.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (!puSpecificStatus || pStatusObj) {
        RRETURN(E_INVALIDARG);
    }

    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    *puSpecificStatus = _ulStatus;

    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::AddProperty.
//
// Synopsis:   Updates the value of the property to the interface 
//        property cache. This fn is called only in interface mode.
//        If necessary the property will be added to the cache. 
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Changes the internal property table.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::AddProperty(
    LPCWSTR szPropertyName,
    UMI_PROPERTY umiProperty
    )
{
    HRESULT hr = S_OK;
    DWORD dwIndex = (DWORD) -1;
    BOOL fAddedName = FALSE;

    //
    // Make sure we do not have property in the cache.
    //
    hr = FindProperty(szPropertyName, &dwIndex);

    if (FAILED(hr)) {
        //
        // We actually need to add this property in our list.
        //
        hr = AddToTable(szPropertyName, &dwIndex);

        fAddedName = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // At this point we can just dump the value into the cache.
    //
    hr = UpdateProperty(
             dwIndex,
             umiProperty
             );

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr) && fAddedName) {
        //
        // Do we delete the name from the cache.
        //
        DeleteProperty(dwIndex);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::UpdateProperty.
//
// Synopsis:   Updates the value of an interface property in the local cache.
//        The assumption is that this function is only called with from
//        AddProperty (or anywhere else where we have the correct index).
//       
// Arguments:  dwIndex - index in our table of the property to update
//             UMI_PROPERTY - the value to add to our table, note that
//             if the operation is delete we should remove the element
//             from our table (value returned if any will be default value
//             for subsequent get calls).
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::UpdateProperty(
    DWORD  dwIndex,
    UMI_PROPERTY umiProp
    )
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwFlags, dwCacheSyntaxId, dwNumElements;
    PUMI_PROPERTY pUmiProperty = NULL;


    if (!_pIntfProperties) {
        //
        // Should we check the index ? It is after all an internal
        // value, so it should not be wrong.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Only update and delete are really supported.
    //
    if ((umiProp.uOperationType != UMI_OPERATION_UPDATE)
        && (umiProp.uOperationType != UMI_OPERATION_DELETE_ALL_MATCHES)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (_pIntfProperties[dwIndex].pUmiProperty) {
        //
        // Free the current data in the table and set initial values.
        //
        hr = FreeOneUmiProperty(*(_pIntfProperties[dwIndex].pUmiProperty));
        BAIL_ON_FAILURE(hr);

        FreeADsMem(_pIntfProperties[dwIndex].pUmiProperty);

        _pIntfProperties[dwIndex].pUmiProperty = NULL;
        _pIntfProperties[dwIndex].dwFlags = 0;
        _pIntfProperties[dwIndex].dwSyntaxId = 0;
    }

    //
    // Copy the value to temp variable, so we can handle failures gracefully.
    //
    hr = CopyUmiProperty(
             umiProp,
             &pUmiProperty
             );
    BAIL_ON_FAILURE(hr);

    _pIntfProperties[dwIndex].pUmiProperty = pUmiProperty;

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::FindProperty.
//
// Synopsis:   Searches for the specified property in the local cache.
//       
// Arguments:  szPropertyName, name of property.
//         pdwIndex - pointer to DWORD with index in table. 
//
// Returns:    HRESULT - S_OK or E_ADS_PROPERTY_NOT_FOUND.
//
// Modifies:   *pdwIndex to.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::FindProperty(
    LPCWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD dwIndex;

    if (!_pIntfProperties) {
        RRETURN(E_ADS_PROPERTY_NOT_FOUND);
    }
    for (dwIndex = 0; dwIndex < _dwMaxProperties; dwIndex++) {
        if (_wcsicmp(
                _pIntfProperties[dwIndex].pszPropertyName,
                szPropertyName
                ) == 0) {
                *pdwIndex = dwIndex;
                RRETURN(S_OK);
        }
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::DeleteProperty.
//
// Synopsis:   Deletes the property specified from the cahce.
//       
// Arguments:  Index to element to delete.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::DeleteProperty(
    DWORD dwIndex
    )
{
    HRESULT hr = S_OK;
    INTF_PROPERTY* pIntfProp = NULL;

    if (_pIntfProperties && ((_dwMaxProperties-1) < dwIndex)) {
        //
        // Valid property in cache.
        //
        pIntfProp = _pIntfProperties + dwIndex;
        ADsAssert(pIntfProp);
    
        if (pIntfProp->pszPropertyName) {
            FreeADsStr(pIntfProp->pszPropertyName);
            pIntfProp->pszPropertyName = NULL;
        }
    
        //
        // Now Copy over the rest of the data here.
        //
        
    } 
    else {
        hr = E_FAIL;
    }

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
// Function:  CPropertyManager::FlushPropertyCache.
//
// Synopsis:  Clear all internal data in the property cache.
//       
// Arguments:  
//
// Returns:   N/A
//
// Modifies:  Underlying data in the cache is changed
//
//----------------------------------------------------------------------------        
VOID
CPropertyManager::flushpropertycache() 
{
    //
    // Free any data in our table
    if (_pIntfProperties) {
        for (DWORD dwCtr = 0; (dwCtr < _dwMaxProperties); dwCtr++) {
            INTF_PROPERTY *pIntfProp = (PINTF_PROPERTY)_pIntfProperties+ dwCtr;
            if (pIntfProp) {
                if (pIntfProp->pszPropertyName) {
                    FreeADsStr(pIntfProp->pszPropertyName);
                    pIntfProp->pszPropertyName = NULL;
                }
            }
        }
        //
        // Now free the array of pointers.
        //
        FreeADsMem((void *) _pIntfProperties);
        _pIntfProperties = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:  CPropertyManager::ClearAllPropertyFlags.
//
// Synopsis:  Resets all property flags to zero.
//       
// Arguments:  None.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed.
//
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::ClearAllPropertyFlags(
    VOID
    )
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetPropertyNames.
//
// Synopsis:  Returns list of names of interface properties available.  
//       
// Arguments:  out params only
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   ppStringsNames to point to valid array of strings.
//         pUlCount to point to number of strings in the array.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetPropertyNames(
    PUMI_PROPERTY_VALUES *pUmiProps
    )
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProperties = NULL;
    DWORD dwCtr, dwPropCount = 0;

    pUmiPropVals = (PUMI_PROPERTY_VALUES) AllocADsMem(
                       sizeof(UMI_PROPERTY_VALUES)
                       );

    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Need to count the properties.
    //
    while (_pStaticPropData[dwPropCount].pszPropertyName) {
        dwPropCount++;
    }
    
    if (!dwPropCount) {
        *pUmiProps = pUmiPropVals;
        RRETURN(S_OK);        
    }

    pUmiProperties = (PUMI_PROPERTY) AllocADsMem(
                         sizeof(UMI_PROPERTY) * dwPropCount
                         );

    if (!pUmiProperties) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Need to go through the table and alloc the values.
    //
    for (dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
        pUmiProperties[dwCtr].pszPropertyName = 
            AllocADsStr(_pStaticPropData[dwCtr].pszPropertyName);

        if (!pUmiProperties[dwCtr].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pUmiProperties[dwCtr].uType = UMI_TYPE_NULL;
    }

    pUmiPropVals->pPropArray = pUmiProperties;
    pUmiPropVals->uCount = dwPropCount;

    *pUmiProps = pUmiPropVals;

    RRETURN(S_OK);

error :

    if (pUmiProperties) {
        for (dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
            if (pUmiProperties[dwCtr].pszPropertyName) {
                FreeADsStr(pUmiProperties[dwCtr].pszPropertyName);
            }
        }
        FreeADsMem(pUmiProperties);
    }

    if (pUmiPropVals) {
        FreeADsMem(pUmiPropVals);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetPropertyNamesSchema
//
// Synopsis:  Returns list of the names and types of the properties this 
//          object can contain. Note that this method is valid only if the
//          underlying object is an instance of class Class (schema class).
//       
// Arguments:  out params only
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetPropertyNamesSchema(
    PUMI_PROPERTY_VALUES *pUmiProps
    )
{
    HRESULT hr = S_OK;
    IADsUmiHelperPrivate *pIADsUmiPriv = NULL;
    // Array of ptr to PROPERTYINFO
    PPROPERTYINFO *pPropArray = NULL;
    DWORD dwPropCount = 0;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProperties = NULL;

    //
    // Need a ptr to the helper routine.
    //
    hr = this->_pIADs->QueryInterface(
                           IID_IADsUmiHelperPrivate,
                           (void **) &pIADsUmiPriv
                           );

    if (hr == E_NOINTERFACE) {
        BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
    }

    hr = pIADsUmiPriv->GetPropertiesHelper(
                           (void**) &pPropArray,
                           &dwPropCount
                           );
    BAIL_ON_FAILURE(hr);

    //
    // Need to prepare the return values.
    //
    pUmiPropVals = (PUMI_PROPERTY_VALUES) AllocADsMem(
                       sizeof(UMI_PROPERTY_VALUES)
                       );

    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!dwPropCount) {
        *pUmiProps = pUmiPropVals;
        RRETURN(S_OK);        
    }

    pUmiProperties = (PUMI_PROPERTY) AllocADsMem(
                         sizeof(UMI_PROPERTY) * dwPropCount
                         );

    if (!pUmiProperties) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    for (DWORD dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
        DWORD dwSyntaxId = 0;
        pUmiProperties[dwCtr].pszPropertyName = 
            AllocADsStr(pPropArray[dwCtr]->pszPropertyName);

        if (!pUmiProperties[dwCtr].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Need to update the type with the type from the schema.
        //
        dwSyntaxId = LdapGetSyntaxIdOfAttribute(
                         pPropArray[dwCtr]->pszSyntax
                         );

        //
        // If we get dwSyntaxId == -1 we could not find the entry in
        // our table.
        //
        if (dwSyntaxId == -1) {
            pUmiProperties[dwCtr].uType = UMI_TYPE_UNDEFINED;
        } 
        else {
            hr = ConvertLdapSyntaxIdToUmiType(
                     dwSyntaxId,
                     (pUmiProperties[dwCtr].uType)
                     );
            if (FAILED(hr)) {
                hr = S_OK;
                //
                // Cannot do anything about this.
                //
                pUmiProperties[dwCtr].uType = UMI_TYPE_UNDEFINED;
            }

            //
            // If this property is multivalued.
            //
            if (!pPropArray[dwCtr]->fSingleValued) {
                pUmiProperties[dwCtr].uType |= UMI_TYPE_ARRAY_FLAG;
            }
        }
    } // for each property.

    pUmiPropVals->pPropArray = pUmiProperties;
    pUmiPropVals->uCount = dwPropCount;

    *pUmiProps = pUmiPropVals;

error:

    if (pIADsUmiPriv) {
        pIADsUmiPriv->Release();
    }

    //
    // Need to free the array not the elements which are ptrs into
    // the global parsed schema's we hold.
    //
    if (pPropArray) {
        FreeADsMem(pPropArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetInterfaceProperty
//
// Synopsis:  Gets the interface property from the owning object or the
//          default value and packages the value as an UMI_PROPERTY_VALUE.
//
// Arguments:  pszName       - name of property to get.
//             uFlags        - flags has to be zero for now.
//             ppProp        - value is returned in this ptr.
//             dwTableIndex  - index to entry in table describing this item.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   ppProp which will point to return value if the fn succeeds.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetInterfaceProperty(
    LPCWSTR pszName,
    ULONG   uFlags,
    UMI_PROPERTY_VALUES **ppProp,
    DWORD dwTableIndex
    )
{
    HRESULT hr;
    ULONG ulOperationAllowed = _pStaticPropData[dwTableIndex].ulOpCode;
    ULONG ulVal;
    LONG lGenus;
    LPWSTR pszStringVal = NULL;
    BSTR bstrRetVal = NULL, bstrTempVal = NULL;
    LPWSTR pszUmiUrl = NULL;
    IADsObjectOptions *pObjOpt = NULL;
    VARIANT vVariant;
    DWORD dwIndex;
    PUMI_PROPERTY pUmiPropLocal = NULL;
    IUnknown *pUnk = NULL;
    IUmiObject *pUmiObj = NULL;
    BOOL fUnkPtr = FALSE;
    BOOL fClassInstance = FALSE;

    VariantInit(&vVariant);

    if (!_pUnk) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
     
    //
    // If the property is READ/WRITE, we need to see if there is a value
    // in the propCache. If yes, return that. If not return the default
    // value.
    //
    if (ulOperationAllowed == OPERATION_CODE_READWRITE) {

        hr = FindProperty(pszName, &dwIndex);
        //
        // If it succeeded it was updated in the cache.
        //
        if (SUCCEEDED(hr)) {
            hr = CopyUmiProperty(
                     *(_pIntfProperties[dwIndex].pUmiProperty),
                     &pUmiPropLocal
                     );
            BAIL_ON_FAILURE(hr);

            //
            // We need to free the name of the first property cause
            // that is allocated again by the Get call.
            //
            if (pUmiPropLocal && pUmiPropLocal->pszPropertyName) {
                FreeADsStr(pUmiPropLocal->pszPropertyName);
                pUmiPropLocal->pszPropertyName = NULL;
            }

            //
            // Got the property need to package in umi property values.
            //
            *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(
                                                 sizeof(UMI_PROPERTY_VALUES)
                                                 );
            
            if (!*ppProp) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            (*ppProp)->pPropArray = pUmiPropLocal;
            (*ppProp)->uCount = 1;
            RRETURN(hr);
        } // value found in cache 
        else {
            //
            // Setting this should trigger a read of the default
            // value for this property.
            //
            ulOperationAllowed = OPERATION_CODE_READABLE;
        }
    }

    //
    // We need to check for the securityDescriptor as that needs
    // some special handling.
    //
    if (!_wcsicmp(pszName, L"__SECURITY_DESCRIPTOR")) {
        //
        // Need to read this from the actual object.
        //
        hr = _pUnk->QueryInterface(IID_IUmiObject, (void **) &pUmiObj);
        BAIL_ON_FAILURE(hr);

        hr = pUmiObj->GetAs(
                 L"ntSecurityDescriptor",
                 uFlags,
                 UMI_TYPE_OCTETSTRING,
                 ppProp
                 );
        if (SUCCEEDED(hr)) {
            //
            // Need to make sure that we do not set name twice.
            //
            if (*ppProp
                && (*ppProp)[0].pPropArray
                && (*ppProp)[0].pPropArray[0].pszPropertyName
                ) {
                FreeADsStr((*ppProp)[0].pPropArray[0].pszPropertyName);
                (*ppProp)[0].pPropArray[0].pszPropertyName = NULL;
            }
        }
        //
        // This seems the cleanest ...
        //
        goto error;
    }

    //
    // If the property is only readable, then get it from owning object.
    // If not get the value from cache or use defualt value as appropriate.
    //
    if (ulOperationAllowed == OPERATION_CODE_READABLE) {
        hr = GetLongProperty(L"__GENUS", &lGenus);
        if (FAILED(hr)) {
            //
            // There was no genus property = connection for example.
            //
            fClassInstance = FALSE;
        } 
        else if (lGenus == UMI_GENUS_CLASS) {
            fClassInstance = TRUE;
        }

        //
        // The value can be a string/long for now and it has to 
        // be either the default value or the value from the owning object.
        //
        switch (_pStaticPropData[dwTableIndex].ulDataType) {
            
        case UMI_TYPE_I4:
            //
            // Use default value from the static table.
            //
            vVariant.lVal = _pStaticPropData[dwTableIndex].umiVal.lValue[0];

            hr = ConvertVariantLongToUmiProp(vVariant, ppProp);
            break;
            
        case UMI_TYPE_BOOL:
            //
            // Use default value from table.
            //
            vVariant.lVal = _pStaticPropData[dwTableIndex].umiVal.bValue[0];
            hr = ConvertVariantLongToUmiProp(vVariant, ppProp);
            (*ppProp)[0].pPropArray[0].uType = UMI_TYPE_BOOL;
            break;

        case UMI_TYPE_LPWSTR:
            //
            // In this case it has to be NULL.
            //
            hr = GetEmptyLPWSTRProp(ppProp);
            break;

        case 9999:
            if (!_pIADs) {
                //
                // Nothing we can do here !
                //
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            if (!_wcsicmp(pszName, L"__Path")) {
                hr = _pIADs->get_ADsPath(&bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__Class")) {
                if (fClassInstance) {
                    //
                    // For classes, the class is the name,
                    // not "class" itself.
                    //
                    hr = _pIADs->get_Name(&bstrRetVal);
                } 
                else {
                    hr = _pIADs->get_Class(&bstrRetVal);
                }
            }
            else if (!_wcsicmp(pszName, L"__KEY")) {
                hr = _pIADs->get_Name(&bstrRetVal);
                BAIL_ON_FAILURE(hr);

                if (SUCCEEDED(hr)) {
                    hr = HelperConvertNameToKey(bstrRetVal, &pszUmiUrl);
                }
            }
            else if (!_wcsicmp(pszName, L"__GUID")) {
                hr = _pIADs->get_GUID(&bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__Parent")) {
                hr = _pIADs->get_Parent(&bstrRetVal);
                if (SUCCEEDED(hr)) {
                    hr = ADsPathToUmiURL(bstrRetVal, &pszUmiUrl);
                }
            }
            else if (!_wcsicmp(pszName, L"__Schema")) {
                hr = _pIADs->get_Schema(&bstrRetVal);
                //
                // Now need to bind to this object.
                //
                if (SUCCEEDED(hr)) {
                    hr = GetObject(
                             bstrRetVal,
                             *_pCreds,
                             (void **) &pUnk
                             );
                    BAIL_ON_FAILURE(hr);
                    fUnkPtr = TRUE;
                }
            }
            else if (!_wcsicmp(pszName, L"__URL")) {
                hr = _pIADs->get_ADsPath(&bstrTempVal);
                if (SUCCEEDED(hr)) {
                    hr = ADsPathToUmiURL(bstrTempVal, &pszUmiUrl);
                }
            } 
            else if (!_wcsicmp(pszName, L"__Name")) {
                if (fClassInstance) {
                    hr = _pIADs->get_Name(&bstrRetVal);
                } else {
                    hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal);
                }
            }
            else if (!_wcsicmp(pszName, L"__RELURL")) {
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal); 
            } 
            else if (!_wcsicmp(pszName, L"__RELPATH")) {
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal); 
            }
            else if (!_wcsicmp(pszName, L"__FULLRELURL")) {
                //
                // Same as __RELURL, __NAME and __RELPATH
                //
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__PADS_SCHEMA_CONTAINER_PATH")) {
                hr = HelperGetUmiSchemaContainerPath(_pIADs, &bstrRetVal);
            } 
            else if (!_wcsicmp(pszName, L"__SUPERCLASS")) {
                if (!fClassInstance) {
                    //
                    // Only supported if this is a class.
                    //
                    hr = E_FAIL;
                } 
                else {
                    hr = HelperGetUmiDerivedFrom(_pIADs, &bstrRetVal);
                }
            }
            else {
                hr = E_FAIL;
            }

            BAIL_ON_FAILURE(hr);

            //
            // If not schema then it has to be a string.
            //
            if (!fUnkPtr) {
                hr = ConvertBSTRToUmiProp(
                         pszUmiUrl ? pszUmiUrl:bstrRetVal,
                         ppProp
                     );
            } 
            else {
                hr = ConvertIUnkToUmiProp(
                         pUnk,
                         IID_IUmiObject,
                         ppProp
                         );
            }
            break;
            
        default:
            hr = E_FAIL;
        } // end of switch
        
        BAIL_ON_FAILURE(hr);
    } // opeartion code is READABLE.
    else {
        hr = E_FAIL;
    }

error:

    if (pObjOpt) {
        pObjOpt->Release();
    }

    VariantClear(&vVariant);
    
    if (bstrRetVal) {
        SysFreeString(bstrRetVal);
    }

    if (bstrTempVal) {
        SysFreeString(bstrTempVal);
    }

    if (pszUmiUrl) {
        FreeADsStr(pszUmiUrl);
    }

    if (pUnk) {
        pUnk->Release();
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::DeleteSDIfPresent    --- Helper method.
//
// Synopsis:  Helps remove the SD from the property cache so that we do not
//          set it when we Commit the changes.
//
// Arguments:  N/A.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::DeleteSDIfPresent()
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    if (!_fPropCacheMode) {
        //
        // Sanity check, should never be here.
        //
        RRETURN(S_OK);
    }

    if (!_pPropCache) {
        //
        // Want to delete SD when we do not have a cache - weird.
        //
        RRETURN(S_OK);
    }

    hr = _pPropCache->findproperty(L"ntSecurityDescriptor", &dwIndex);
    if (FAILED(hr)) {
       RRETURN(S_OK);
    } 
    else {
        //
        // Get rid of this from the cache.
        //
        _pPropCache->deleteproperty(dwIndex);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetIndexInStaticTable
//
// Synopsis:  Verifies that the named property can be found in the list of
//          valid properties and returns the index.
//       
// Arguments:  Self explanatory.
//
// Returns:    S_OK or E_ADS_PROPERTY_NOT_FOUND as appropriate.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetIndexInStaticTable(
    LPCWSTR pszName,
    DWORD &dwIndex
    )
{
    for (DWORD dwCtr = 0;
         _pStaticPropData[dwCtr].pszPropertyName;
         dwCtr++ ) {
        
        if (!_wcsicmp(
                 pszName,
                 _pStaticPropData[dwCtr].pszPropertyName
                 )) {
            dwIndex = dwCtr;
            RRETURN(S_OK);            
        }
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::VerifyIfValidProperty.
//
// Synopsis:  Makes sure that a valid interface property is being set. This
//          function is called internally if we know we are not in the
//          property cache mode. The internal static table pointer is used to
//          verify the property.
//       
// Arguments:  Self explanatory.
//
// Returns:    Bool - True or False as appropriate.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
BOOL
CPropertyManager::VerifyIfValidProperty(
    LPCWSTR pszPropertyName,
    UMI_PROPERTY umiProperty
    )
{
    DWORD dwIndex;
    //
    // if _pStaticPropData is NULL then there are no interface properties.
    // If the count is zero, then the only operation is delete.
    //
    if ((!_pStaticPropData)
        || ((umiProperty.uCount == 0) 
           && (umiProperty.uOperationType != UMI_OPERATION_DELETE_ALL_MATCHES)
            )
        )
         {
        return FALSE;
    }

    if (SUCCEEDED(GetIndexInStaticTable(
                   pszPropertyName,
                   dwIndex
                   ))
        ) {
        //
        // Verify type and if property can be changed.
        // If the types do not match we should still allow 9999 for
        // things like __SECURITY_DESCRIPTOR that can be changed.
        // If the attribute cannot be written, then the next part of 
        // the check will fail, so you still wont be able to write
        // things the __URL property.
        //
        if (((_pStaticPropData[dwIndex].ulDataType == umiProperty.uType)
              || (_pStaticPropData[dwIndex].ulDataType == 9999))
            && (_pStaticPropData[dwIndex].ulOpCode 
                != OPERATION_CODE_READABLE)
            ) {
            //
            // Need to make sure count is correct.
            //
            if ((umiProperty.uCount > 1)
                && (!_pStaticPropData[dwIndex].fMultiValued)
                ) {
                return FALSE;
            }
            return TRUE;
        }

    }

    //
    // Either we did not satisfy requirements or not found
    //
    return FALSE;
}

HRESULT
CPropertyManager::AddToTable(
    LPCWSTR pszPropertyName,
    PDWORD pdwIndex
    )
{
    HRESULT hr = S_OK;
    PINTF_PROPERTY pNewProperty = NULL;
    //
    // Check to see if the table is already there. If not create
    // the table with potential to store upto 10 entries. This should
    // suffice unless we have more properties. Set the current pointer
    // and current top appropriately.
    //
    if (!_pIntfProperties) {
        _pIntfProperties = (PINTF_PROPERTY) AllocADsMem(
            sizeof(INTF_PROPERTY) * MAX_PROPMGR_PROP_COUNT
            );

        if (!_pIntfProperties) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        _dwMaxProperties = 0;
        _dwMaxLimit      = MAX_PROPMGR_PROP_COUNT;
    }


    if ((_dwMaxProperties+1) < _dwMaxLimit) {
        //
        // We can add this property to the table.
        //
        DWORD dwTop;
        
        dwTop = _dwMaxProperties++;

        _pIntfProperties[dwTop].pszPropertyName = 
            AllocADsStr(pszPropertyName);

        if (!_pIntfProperties[dwTop].pszPropertyName) {
            //
            // Reset the count.
            //
            _dwMaxProperties--;
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pdwIndex = dwTop;
    } 
    else {
        //
        // We do not have space in the table - return an error.
        //
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetStringProperty.
//
// Synopsis: Retrieves the string property if one is set in the cache or 
//          returns NULL if the property is not in the cache. The assumption
//          here is that string properties are defaulted to NULL always.
//       
// Arguments:  Self explanatory.
//
// Returns:    S_OK, UMI_E_NOT_FOUND, E_FAIL.
//
// Modifies:   pszRetVal to point to the appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetStringProperty(
    LPCWSTR pszPropName,
    LPWSTR *ppszRetStrVal
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    if (FAILED(hr)) {
        //
        // Do we lookup the static table ? The table wont have strings in
        // it though cause the union assumes chars.
        //
        *ppszRetStrVal = NULL;
        RRETURN(S_OK);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a string.
    //
    if (pUmiProp->uType != UMI_TYPE_LPWSTR) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue
        && pUmiProp->pUmiValue->pszStrValue[0]) {

        *ppszRetStrVal = AllocADsStr(pUmiProp->pUmiValue->pszStrValue[0]);

        if (!*ppszRetStrVal) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetLongProperty   - Helper method.
//
// Synopsis: Retrieves the long property if one is set in the cache or 
//          returns the defaulted value if the property is not in the cache.
//
// Arguments:  pszPropName   ---   Name of property being retrieved.
//             plVal         ---   Ptr for return value.
//
// Returns:    S_OK, UMI_E_NOT_FOUND or E_FAIL.
//
// Modifies:   *plVal with appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetLongProperty(
    LPCWSTR pszPropName,
    LONG *plVal
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    *plVal = 0;

    if (FAILED(hr)) {
        //
        // We need to look for the property in the static table.
        //
        hr = GetIndexInStaticTable(pszPropName, dwIndex);
        if (SUCCEEDED(hr)
            && (_pStaticPropData[dwIndex].ulDataType == UMI_TYPE_I4)
            ) {
            //
            // Get the correct value from the table.
            //
            *plVal = _pStaticPropData[dwIndex].umiVal.lValue[0];

        } 
        else {
            hr = UMI_E_NOT_FOUND;
        }

        RRETURN(hr);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a long.
    //
    if (pUmiProp->uType != UMI_TYPE_I4) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue) {
        *plVal = pUmiProp->pUmiValue->lValue[0];
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetBoolProperty   - Helper method.
//
// Synopsis: Retrieves the bool property if one is set in the cache or 
//          returns the defaulted value if the property is not in the cache.
//
// Arguments:  pszPropName   ---   Name of property being retrieved.
//             pfFlag        ---   Ptr for return value.
//
// Returns:    S_OK, UMI_E_NOT_FOUND or E_FAIL.
//
// Modifies:   ofFlag with appropriate value of the property.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetBoolProperty(
    LPCWSTR pszPropName,
    BOOL *pfFlag
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    *pfFlag = FALSE;

    if (FAILED(hr)) {
        //
        // We need to look for the property in the static table.
        //
        hr = GetIndexInStaticTable(pszPropName, dwIndex);
        if (SUCCEEDED(hr)
            && (_pStaticPropData[dwIndex].ulDataType == UMI_TYPE_BOOL)
            ) {
            //
            // Get the correct value from the table.
            //
            *pfFlag = _pStaticPropData[dwIndex].umiVal.bValue[0];

        }
        else {
            hr = E_FAIL;
        }
        RRETURN(hr);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a long.
    //
    if (pUmiProp->uType != UMI_TYPE_BOOL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue) {
        *pfFlag = pUmiProp->pUmiValue->bValue[0];
    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR SchemaClass,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;

    //
    // Both should never be NULL, replacing the ADsAsserts with 
    // this check to make sure that we never get into this problem
    // on all builds.
    //
    if (!Parent || !Name) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( SchemaClass, &_SchemaClass);
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _SchemaClass(NULL),
                        _ADsGuid(NULL),
                        _pUnkOuter(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_SchemaClass) {
        ADsFreeString(_SchemaClass);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _SchemaClass == NULL || *_SchemaClass == 0 ) {
        hr = ADsAllocString(_ADsClass, retval);
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_SchemaClass, retval);  // report the actual class
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");


    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _SchemaClass == NULL || *_SchemaClass == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = BuildSchemaPath(
             _ADsPath,
             _SchemaClass,
             retval );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwFlags)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CCoreADsObject::GetInfo(
    THIS_ LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


//----------------------------------------------------------------------------
// Function:   InitUmiObject
//
// Synopsis:   Initializes UMI object.
//
// Arguments:
//
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of WinNT object
// pExtMgr      Pointer to extension manager object on WinNT object
// riid         Interface requested
// ppvObj       Returns pointer to interface 
//
// Returns:     S_OK if a UMI object is created and the interface is obtained. 
//              Error code otherwise 
//
// Modifies:    *ppvObj to return the UMI interface requested. 
//
//----------------------------------------------------------------------------
HRESULT 
CCoreADsObject::InitUmiObject(
    INTF_PROP_DATA intfProps[],
    CPropertyCache * pPropertyCache,
    IADs *pIADs,
    IUnknown *pUnkInner,
    REFIID riid,
    LPVOID *ppvObj,
    CCredentials *pCreds,
    DWORD dwPort, // defaulted to -1
    LPWSTR pszServerName, // defaulted to NULL
    LPWSTR pszLdapDn, // defaulted to NULL
    PADSLDP pLdapHandle, // defaulted to NULL,
    CADsExtMgr *pExtMgr // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPUmiObject *pUmiObject = NULL;

    if (!ppvObj) {
        RRETURN(E_INVALIDARG);
    }

    hr = CLDAPUmiObject::CreateLDAPUmiObject(
             intfProps,
             pPropertyCache,
             pUnkInner,
             this, // pCoreObj
             pIADs,
             pCreds,
             &pUmiObject,
             dwPort,
             pLdapHandle,
             pszServerName,
             pszLdapDn,
             pExtMgr
             );

    BAIL_ON_FAILURE(hr);

    //
    // Bump up reference count of pUnkInner. On any error after this point,
    // the UMI object's destructor will call Release() on pUnkInner and we
    // don't want this to delete the LDAP object.
    //
    pUnkInner->AddRef();

    hr = pUmiObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on umi object is now 2, reduce by one.
    //
    pUmiObject->Release();

    //
    // Restore ref count of inner unknown
    //
    pUnkInner->Release();

    RRETURN(S_OK);

error:

    if (pUmiObject) {
        delete pUmiObject;
    }

    RRETURN(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\copy.cxx ===
#include "ldap.hxx"
#pragma hdrstop


HRESULT
CopyObject(
    IN LPWSTR pszSrcADsPath,
    IN LPWSTR pszDestContainer,
    IN ADS_LDP   *ldDest,                 // LDAP handle of destination container
    IN SCHEMAINFO * pSchemaInfo,       // SCHEMAINFO for the dest container
    IN LPWSTR pszCommonName,           // optional
    OUT IUnknown ** ppObject
    )

{

    HRESULT hr = S_OK;
    WCHAR szLDAPSrcPath[MAX_PATH];
    WCHAR szLDAPDestContainer[MAX_PATH];
    ADS_LDP  *ldapSrc = NULL, *ldapDest = NULL;
    LDAPMessage *ldpSrcMsg =NULL;
    SCHEMAINFO *pDestSchemaInfo = NULL;
    WCHAR  **avalues;
    DWORD  nCount, nNumberOfEntries;
    WCHAR  szADsClass[MAX_PATH];
    WCHAR  szName[MAX_PATH];
    WCHAR  szParent[MAX_PATH];
    LPWSTR pszRelativeName = NULL;


    hr = BuildADsParentPath(
             pszSrcADsPath,
             szParent,
             szName
             );
    
    BAIL_ON_FAILURE(hr);

    hr = GetInfoFromSrcObject(
             pszSrcADsPath,
             szLDAPSrcPath,
             &ldapSrc,
             &ldpSrcMsg,
             &avalues,
             &nCount 
             );

    BAIL_ON_FAILURE(hr);

    if(ldDest){
        ldapDest = ldDest;
    }

    if(pSchemaInfo){
        pDestSchemaInfo = pSchemaInfo;
    }

    hr = CreateDestObjectCopy(
             pszDestContainer,
             avalues,
             nCount,
             ldapSrc,
             &ldapDest,
             ldpSrcMsg,
             &pDestSchemaInfo,
             pszCommonName,
             szLDAPDestContainer
             );

    BAIL_ON_FAILURE(hr);

    if (pszCommonName){
        pszRelativeName = pszCommonName;
    } else {
        pszRelativeName = szName;
    }

    hr = InstantiateCopiedObject( 
             pszDestContainer,
             avalues,
             nCount,
             pszRelativeName,
             ppObject 
             );


error:

    if (!pSchemaInfo && pDestSchemaInfo){
        pDestSchemaInfo ->Release();
    }


    if (!ldDest && ldapDest)
    {
        LdapCloseObject(ldapDest);
        ldapDest = NULL;
    }

 
    if (ldapSrc)
    {
        LdapCloseObject(ldapSrc);
        ldapSrc = NULL;
    }

    if(avalues){
        LdapValueFree(avalues);
    }
     

    if(ldpSrcMsg){
        LdapMsgFree( ldpSrcMsg);
    }

    RRETURN(hr);

}

HRESULT
GetInfoFromSrcObject(
    IN    LPWSTR pszSrcADsPath,
    OUT   LPWSTR szLDAPSrcPath,
    OUT   ADS_LDP ** pldapSrc,
    OUT   LDAPMessage **pldpSrcMsg,
    OUT   WCHAR ***pavalues, 
    OUT   DWORD  *pnCount
    )

{
    ADS_LDP  *ldapSrc = NULL;
    LDAPMessage *ldpSrcMsg =NULL;
    WCHAR  **avalues;
    DWORD  nCount, nNumberOfEntries;
    HRESULT hr = S_OK;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = BuildLDAPPathFromADsPath(
             pszSrcADsPath, 
             szLDAPSrcPath );

    BAIL_ON_FAILURE(hr);

    hr = LdapOpenObject(
                   szLDAPSrcPath,
                   &ldapSrc
                   );

    BAIL_ON_FAILURE(hr);

    hr = LdapSearchS(
                    ldapSrc,
                    GET_LDAPDN_FROM_PATH(szLDAPSrcPath), 
                    LDAP_SCOPE_BASE, 
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &ldpSrcMsg
                    );

    BAIL_ON_FAILURE(hr);

    //
    // get the object class of the source object. We need to do this so
    // that we can use the information so obtained to test whether there
    // is the same object class in the destination location
    //

    hr = ADsObject(pszSrcADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = LdapReadAttribute(
                       szLDAPSrcPath,
                       TEXT("objectClass"),
                       &avalues,
                       (int *)&nCount,
                       &ldapSrc, 
                       pObjectInfo->PortNumber
                       );

    BAIL_ON_FAILURE(hr);
    
    if ( nCount == 0 ){

        // This object exists but does not have an objectClass. We
        // can't do anything without the objectClass. Hence, return
        // bad path error.
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }


    // 
    // we have succeeded in getting all the information from the source
    // object. We need to validate to see if there is such an object in 
    // in the destination. 
    
    *pldapSrc = ldapSrc;
    *pldpSrcMsg = ldpSrcMsg;
    *pavalues = avalues;
    *pnCount  = nCount;

error:

    FreeObjectInfo(pObjectInfo);
    
    RRETURN(hr);


}


HRESULT
CreateDestObjectCopy(
    IN LPWSTR pszDestContainer,
    IN WCHAR **avalues,
    IN DWORD nCount,
    IN ADS_LDP *ldapSrc,
    IN OUT ADS_LDP **pldDest,
    IN LDAPMessage *ldpSrcMsg,
    IN OUT SCHEMAINFO **ppSchemaInfo,
    IN LPWSTR pszCommonName,
    OUT LPWSTR szLDAPDestContainer
    )

{
    ADS_LDP  *ldapDest = NULL;
    LDAPModW *aModsBuffer = NULL;
    LDAPMessage *ldpAttrMsg = NULL;
    SCHEMAINFO *pDestSchemaInfo = NULL;
    DWORD  nNumberOfEntries;
    HRESULT hr = S_OK;
    DWORD index = 0, dwCount = 0,nNumberOfValues, dwSyntax;
    VOID *ptr;
    LPWSTR pszAttrName = NULL;
    DWORD i= 0, j=0;
    PLDAPOBJECT *ppaValues = NULL;
    PLDAPOBJECT  paObjClass = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = BuildLDAPPathFromADsPath(
                 pszDestContainer, 
                 szLDAPDestContainer 
                 );
    
    BAIL_ON_FAILURE(hr);

    if (*pldDest){
        ldapDest = *pldDest;

    } else {

        hr = LdapOpenObject(
                            szLDAPDestContainer,
                            &ldapDest
                            );

        BAIL_ON_FAILURE(hr);

        *pldDest = ldapDest;
    }

    if(*ppSchemaInfo){
        pDestSchemaInfo = *ppSchemaInfo;
    } else {

        hr = ADsObject(pszDestContainer, pObjectInfo);
        BAIL_ON_FAILURE(hr);
    
        hr = LdapGetSchema( szLDAPDestContainer, 
                            ldapDest, 
                            &pDestSchemaInfo, 
                            pObjectInfo->PortNumber 
                            );
        BAIL_ON_FAILURE(hr);
        
        *ppSchemaInfo = pDestSchemaInfo;
    }
                   
    //
    // check to see if the object class of source exists in the naming
    // context of the destination
    //

    /*
    index = FindEntryInSearchTable( avalues[nCount -1],
                                    pDestSchemaInfo->aClassesSearchTable,
                                    2 * pDestSchemaInfo->nNumOfClasses ); 

    if ( index == -1 ) {

        // Cannot find the class name
        hr = E_ADS_BAD_PARAMETER; 
        BAIL_ON_FAILURE(hr); 
    }


    */

    //
    // Now we need to find the number of entries in the ldap message
    //

    hr = LdapFirstEntry( ldapSrc, ldpSrcMsg, &ldpAttrMsg );   

    BAIL_ON_FAILURE(hr);

    dwCount = 0;
    hr = LdapFirstAttribute(ldapSrc, ldpAttrMsg, &ptr, &pszAttrName);

    BAIL_ON_FAILURE(hr);
    
    do {
        dwCount++;
        hr = LdapNextAttribute( 
                       ldapSrc, 
                       ldpAttrMsg, 
                       ptr, 
                       &pszAttrName 
                       );

        if (pszAttrName) {
            FreeADsMem(pszAttrName);
        }
        if (FAILED(hr)){
            break;
        }


    } while(pszAttrName != NULL);

    
    aModsBuffer = (LDAPModW *) AllocADsMem((dwCount +1) * 
                                             sizeof(LDAPModW )); 

    
    if ( aModsBuffer == NULL ) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    //
    // memory has been allocated. we now need to scan the list again
    // and copy the entries from the LDAPMessage structure to the
    // LDAPModW structure
    //

    ppaValues= (PLDAPOBJECT *)AllocADsMem(dwCount * sizeof(PLDAPOBJECT));

    if (!ppaValues){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    paObjClass = (PLDAPOBJECT)AllocADsMem(sizeof(LDAPOBJECT));

    if (!ppaValues){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    
    hr = LdapFirstAttribute(ldapSrc, ldpAttrMsg, &ptr, &pszAttrName);

    BAIL_ON_FAILURE(hr);
    
    i=0;
    j = 0; 

    do {

        hr = LdapGetValuesLen( ldapSrc, ldpAttrMsg, pszAttrName, 
                                     &ppaValues[j], (int *)&nNumberOfValues );

        BAIL_ON_FAILURE(hr);

        dwSyntax = GetSyntaxOfAttribute( 
                       pszAttrName,
                       pDestSchemaInfo
                       );
        
        if (dwSyntax != LDAPTYPE_UNKNOWN ){

            if (wcscmp(pszAttrName, TEXT("distinguishedName"))== 0){
                hr = LdapNextAttribute( ldapSrc, 
                                              ldpAttrMsg, 
                                              ptr, 
                                              &pszAttrName );
        
                if (FAILED(hr)){
                    break;
                }
        
                j++;
                continue;
            }

            if (wcscmp(pszAttrName, TEXT("objectClass"))== 0){
                VARIANT v;
                V_VT(&v)= VT_BSTR;
                V_BSTR(&v)= avalues[nCount-1];


                hr = VarTypeToLdapTypeString( &v, paObjClass);
                BAIL_ON_FAILURE(hr);

                aModsBuffer[i].mod_bvalues = paObjClass;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
  

            } else {

                aModsBuffer[i].mod_type   = pszAttrName;
                aModsBuffer[i].mod_bvalues = ppaValues[j];
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
            }


            i++;

        }
        FreeADsMem( pszAttrName );

        hr = LdapNextAttribute( ldapSrc, ldpAttrMsg, ptr, &pszAttrName );
        
        if (FAILED(hr)){
            break;
        }
        
        j++;

    } while(pszAttrName != NULL);


    hr = LdapAddS(
                  ldapDest,
                  GET_LDAPDN_FROM_PATH(szLDAPDestContainer), 
                  &aModsBuffer
                  );

    BAIL_ON_FAILURE(hr);


error:

    FreeObjectInfo(pObjectInfo);

    for(j=0; j< dwCount; j++){
        if(ppaValues[j]){
            LdapValueFreeLen(ppaValues[j]);
        }
    }


    if(ldpAttrMsg){
        LdapMsgFree( ldpAttrMsg);
    }

    if(aModsBuffer){
        FreeADsMem(aModsBuffer);
    }

    if (pszAttrName) {
        FreeADsMem(pszAttrName);
    }
    
    if(ppaValues){
        FreeADsMem(ppaValues);
    }

    if(paObjClass){
        FreeADsMem(paObjClass);
    }

    RRETURN(hr);

}


HRESULT 
InstantiateCopiedObject(
    IN LPWSTR pszDestContainer,
    IN WCHAR ** avalues,
    IN DWORD nCount,
    IN LPWSTR pszRelativeName,
    OUT IUnknown ** ppObject
    )
{
    HRESULT hr = S_OK;
    IADs *pADs = NULL;
    WCHAR szADsClassName[MAX_PATH];

    MapLdapClassToADsClass( avalues, nCount, szADsClassName );

    hr = CLDAPGenObject::CreateGenericObject(
                    pszDestContainer,
                    pszRelativeName,
                    szADsClassName,
                    avalues[nCount-1],
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **) &pADs
                    );
    BAIL_ON_FAILURE(hr);

    //
    // InstantiateDerivedObject should add-ref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    szADsClassName,
                    IID_IUnknown,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {

        hr = pADs->QueryInterface(
                          IID_IUnknown,
                          (void **)ppObject
                          );
        BAIL_ON_FAILURE(hr);
    }

error:
    if(pADs){
        pADs->Release();
    }
    RRETURN(hr);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprov.cxx
//
//  Contents:  LDAP Provider Object Class Factory Code
//
//             CLDAPProvider
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPProvider

CLDAPProvider::CLDAPProvider()
{
    ENLIST_TRACKING(CLDAPProvider);
}

HRESULT
CLDAPProvider::Create(CLDAPProvider FAR * FAR * ppProvider)
{
    CLDAPProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CLDAPProvider();
    if (pProvider == NULL) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN_EXP_IF_ERR(hr);
}

CLDAPProvider::~CLDAPProvider( )
{

}

STDMETHODIMP
CLDAPProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CLDAPProvider::ParseDisplayName(IBindCtx* pbc, TCHAR* szDisplayName, ULONG* pchEaten, IMoniker** ppmk)
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProvider::ResolvePathName(IBindCtx* pbc,
                TCHAR* szDisplayName,
                ULONG* pchEaten,
                IMoniker** ppmk
                )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }
    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += _tcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\crootdse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPRootDSE


DEFINE_IDispatch_Implementation(CLDAPRootDSE)
DEFINE_IADs_Implementation(CLDAPRootDSE)

CLDAPRootDSE::CLDAPRootDSE():
    _pPropertyCache( NULL ),
    _pDispMgr( NULL ),
    _pszLDAPServer(NULL),
    _pszLDAPDn(NULL),
    _pLdapHandle( NULL )
{
    VariantInit(&_vFilter);
    VariantInit(&_vHints);

    ENLIST_TRACKING(CLDAPRootDSE);
}

HRESULT
CLDAPRootDSE::CreateRootDSE(
    BSTR Parent,
    BSTR CommonName,
    BSTR LdapClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPRootDSE FAR * pGenObject = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGenObject(Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                LdapClassName,
                CLSID_LDAPGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildLDAPPathFromADsPath2(
             pGenObject->_ADsPath,
             &pGenObject->_pszLDAPServer,
             &pGenObject->_pszLDAPDn,
             &pGenObject->_dwPort
             );

    BAIL_ON_FAILURE(hr);


    //
    // At this point update the info in the property cache
    //
    pGenObject->_pPropertyCache->SetObjInformation(
                                     &(pGenObject->_Credentials),
                                     pGenObject->_pszLDAPServer,
                                     pGenObject->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    hr = LdapOpenObject(
                   pGenObject->_pszLDAPServer,
                   NULL,
                   &(pGenObject->_pLdapHandle),
                   pGenObject->_Credentials,
                   pGenObject->_dwPort
                   );

    BAIL_ON_FAILURE(hr);

    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // From Umi so we need to return UMI Object not RootDSE.
        //
        hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
                   IntfPropsGeneric,
                   pGenObject->_pPropertyCache,
                   (IADs*) pGenObject,
                   (IADs*) pGenObject,
                   riid,
                   ppvObj,
                   &(pGenObject->_Credentials),
                   pGenObject->_dwPort,
                   pGenObject->_pszLDAPServer,
                   NULL,
                   pGenObject->_pLdapHandle
                   );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
                   
    }

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pGenObject;
    RRETURN_EXP_IF_ERR(hr);
}

CLDAPRootDSE::~CLDAPRootDSE( )
{
    VariantClear(&_vFilter);
    VariantClear(&_vHints);

    if ( _pLdapHandle )
    {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }

    if (_pszLDAPServer) {
       FreeADsStr(_pszLDAPServer);
       _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
       FreeADsStr(_pszLDAPDn);
       _pszLDAPDn = NULL;
    }

    delete _pDispMgr;

    delete _pPropertyCache;

}

STDMETHODIMP
CLDAPRootDSE::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjectOptions)) {
        *ppv = (IADsObjectOptions FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLDAPRootDSE::SetInfo()
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        //
        //  No concept of creating RootDSE objects
        //  Any DS must have a RootDSE object
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = LDAPSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPRootDSE::LDAPSetObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;


    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    hr = LdapModifyS(
             _pLdapHandle,
             NULL,
             aMod
             );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPRootDSE::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CLDAPRootDSE::GetInfo()
{
    RRETURN(GetInfo(GETINFO_FLAG_EXPLICIT));
}

HRESULT
CLDAPRootDSE::GetInfo(
    DWORD dwFlags
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = ADSTYPE_CASE_IGNORE_STRING;
    LDAPMessage *res = NULL;

    if (dwFlags == GETINFO_FLAG_IMPLICIT_AS_NEEDED) {
        if (_pPropertyCache->getGetInfoFlag()) {
            //
            // Nothing to do in this case.
            //
            RRETURN(S_OK);
        }
    }

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapSearchS(
                    _pLdapHandle,
                    NULL,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

    BAIL_ON_FAILURE(hr);

    if ( dwFlags == GETINFO_FLAG_EXPLICIT )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    hr = _pPropertyCache->LDAPUnMarshallPropertiesAs(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            dwSyntaxId,
                            (dwFlags == GETINFO_FLAG_EXPLICIT) ?
                                 TRUE :
                                 FALSE,    
                            _Credentials
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {

        LdapMsgFree( res );
    }


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CLDAPRootDSE::AllocateGenObject(
    CCredentials& Credentials,
    CLDAPRootDSE ** ppGenObject
    )
{
    CLDAPRootDSE FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CLDAPRootDSE();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsObjectOptions,
                           (IADsObjectOptions *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *) pGenObject,
                        (IGetAttributeSyntax *) pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pGenObject;

    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CLDAPRootDSE::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For some folks who have no clue what they are doing.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }
    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
    pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    vProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if vProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                    
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }
    else {
    
        //                                                                  
        // If this is a single VT_BYREF of a basic type, we dereference
        // it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
    
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }

        dwNumValues = 1;
    }

    //
    // check if the variant maps to the syntax of this property
    //

    hr = GetLdapSyntaxFromVariant(
             pvProp,
             &dwSyntaxId,
             _pszLDAPServer,
             bstrName,
             _Credentials,
             _dwPort
             );

    BAIL_ON_FAILURE(hr);


    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
                _pszLDAPServer,
                _Credentials,
                ldapSrcObjects,
                dwSyntaxId,
                pvProp
                );
    BAIL_ON_FAILURE(hr);

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch ( lnControlCode ) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = PROPERTY_ADD;
        break;


    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    if ( dwFlags != PROPERTY_DELETE )
    {
        //
        // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
        // We should dereference a VT_BYREF|VT_VARIANT once and see
        // what's inside.
        //
        pvProp = &vProp;
        if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
            pvProp = V_VARIANTREF(&vProp);
        }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;                     
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        //
        // check if the variant maps to the syntax of this property
        //

        hr = GetLdapSyntaxFromVariant(
                 pvProp,
                 &dwSyntaxId,
                 _pszLDAPServer,
                 bstrName,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    if (!plCount) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if (_pPropertyCache) {

        hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Next(
    THIS_ VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    IDispatch * pDispatch = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;
    LDAPOBJECTARRAY_INIT(ldapSrcObjects);


    if (!pVariant) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!_pPropertyCache->index_valid())
       RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // retreive the item with current idex; unboundgetproperty()
    // returns E_ADS_PROPERTY_NOT_FOUND if index out of bound
    //

    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwPropStatus,
                &ldapSrcObjects
                );
    BAIL_ON_FAILURE(hr);


    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);


    //
    // translate the LDAP objects to variants
    //

    hr = ConvertLdapValuesToVariant(
            _pPropertyCache->get_CurrentPropName(),
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the success of Skip().
    //

    Skip(1);

    LdapTypeFreeLdapObjects(&ldapSrcObjects);

    if (FAILED(hr)) {
        V_VT(pVariant) = VT_ERROR;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Skip(
    THIS_ long cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = _pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}


STDMETHODIMP
CLDAPRootDSE::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPRootDSE::ResetPropertyItem(THIS_ VARIANT varEntry)
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    switch (V_VT(&varEntry)) {

    case VT_BSTR:

        hr = _pPropertyCache->findproperty(
                            V_BSTR(&varEntry),
                            &dwIndex
                            );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:
        dwIndex = V_I4(&varEntry);
        break;


    case VT_I2:
        dwIndex = V_I2(&varEntry);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->deleteproperty(
                        dwIndex
                        );
error:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::GetPropertyItem(
    THIS_ BSTR bstrName,
    LONG lnType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwNumValues = 0;

    DWORD dwUserSyntaxId = 0;
    DWORD dwStatus = 0;
    DWORD dwCtrlCode = 0;



    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; do NOT retreive from server
    //

    hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);

    hr = ConvertLdapValuesToVariant(
            bstrName,
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::PutPropertyItem(
    THIS_ VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    DWORD dwControlCode = 0;
    LDAPOBJECTARRAY ldapDestObjects;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwSyntaxId = 0;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = ConvertVariantToLdapValues(
                varData,
                szPropertyName,
                &dwControlCode,
                &ldapDestObjects,
                &dwSyntaxId,
                _pszLDAPServer,
                &_Credentials,
                _dwPort
                );
    BAIL_ON_FAILURE(hr);

    switch ( dwControlCode ) {

    case ADS_PROPERTY_CLEAR:

        //
        // Clears an entire property
        //

        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:

        //
        // Updates the entire property
        //

        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        //
        // Appends a set of values to the property
        //

        break;

    case ADS_PROPERTY_DELETE:
        //
        // Delete a value(s) from the property

        break;


    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }



    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( szPropertyName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    szPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)

{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumValues = 0;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwStatus = 0;
    DWORD dwCtrlCode = 0;
    VARIANT *pvVar = &varIndex;
    LPWSTR szPropName = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        //
        // retrieve data object from cache; if one exists
        //

        if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

            hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

            // For backward compatibility -- nothing done, you
            // should be able to get an item marked as delete.

        } else {

            hr = _pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

            // For backward compatibility -- nothing done,
            // you should be able to get an item marked as delete.

        }

        BAIL_ON_FAILURE(hr);
        szPropName = V_BSTR(pvVar);

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;

    case VT_I4:


        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I4(pvVar),
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility -- nothing done, you
        // should be able to get an item marked as delte.

        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                         (DWORD)V_I4(pvVar)
                         );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;


    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility -- nothing done, you
        // should be able to get an item marked as delete.

        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                         (DWORD)V_I2(pvVar)
                         );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // translate the Ldap objects to variants
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);

    hr = ConvertLdapValuesToVariant(
            szPropName,
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::PurgePropertyList()
{
    _pPropertyCache->flushpropertycache();
    RRETURN(S_OK);
}



STDMETHODIMP
CLDAPRootDSE::GetInfo(
    LPWSTR szPropertyName,
    DWORD dwSyntaxId,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapSearchS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

    BAIL_ON_FAILURE(hr);

    if ( fExplicit )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    hr = _pPropertyCache->LDAPUnMarshallPropertiesAs(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            ADSTYPE_CASE_IGNORE_STRING,
                            fExplicit,
                            _Credentials
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();


error:

    if (res) {

        LdapMsgFree( res );
    }


    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPRootDSE::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );
    RRETURN_EXP_IF_ERR(hr);
}


//
// IADsObjecOptions methods
//

//
// Unlike the cgenobj GetOption implementation, this will support
// only a subset of the flags - mutual auth status being the only one.
//
STDMETHODIMP
CLDAPRootDSE::GetOption(
    THIS_ long lnControlCode,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    ULONG ulFlags = 0;
    CtxtHandle hCtxtHandle;
    DWORD dwErr = 0;

    VariantInit(pvProp);

    switch (lnControlCode) {

    case ADS_OPTION_MUTUAL_AUTH_STATUS :

        dwErr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_SECURITY_CONTEXT,
                    (void *) &hCtxtHandle
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

//DSCLIENT

#if (!defined(WIN95))

        dwErr = QueryContextAttributesWrapper(
                    &hCtxtHandle,
                    SECPKG_ATTR_FLAGS,
                    (void *) &ulFlags
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }
#else
        ulFlags = 0;
#endif
        pvProp->vt = VT_I4;
        pvProp->lVal = ulFlags;
        break;

    default:
        hr = E_NOTIMPL;
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CLDAPRootDSE::SetOption(
    THIS_ long lnControlCode,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwOptVal = 0;
    VARIANT *pvProp = NULL;

    //
    // To make sure we handle variant by refs correctly.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    switch (lnControlCode) {

    case ADS_PRIVATE_OPTION_KEEP_HANDLES :

        hr = LdapcKeepHandleAround(_pLdapHandle);
        break;

    default:
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprovcf.cxx
//
//  Contents:  LDAP Provider Object Class Factory Code
//
//             CLDAPProviderCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CLDAPProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLDAPProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  LDAP
//
//
//  History:   09-01-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#define NT_SCHEMA_CLASS_NAME     TEXT("classSchema")
#define NT_SCHEMA_PROPERTY_NAME  TEXT("attributeSchema")
#define BEGIN_FILTER TEXT("(& (lDAPDisplayName=")
#define END_FILTER TEXT(") (! (isdefunct=TRUE)))")

struct _syntaxmapping
{
    LPTSTR pszSyntax;
    LPTSTR pszOID;
    DWORD  dwOMSyntax;
} aSyntaxMap[] =
{
    { TEXT("Boolean"), TEXT("2.5.5.8"), 1 },
    { TEXT("Integer"), TEXT("2.5.5.9"), 2 },
    { TEXT("OctetString"), TEXT("2.5.5.10"), 4 },

    // The following are in ADS only
    { TEXT("Counter"), TEXT("2.5.5.9"), 2 },
    { TEXT("ADsPath"), TEXT("2.5.5.12"), 64 },
    { TEXT("EmailAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("FaxNumber"), TEXT("2.5.5.12"), 64 },
    { TEXT("Interval"), TEXT("2.5.5.9"), 2 },
    { TEXT("List"), TEXT("2.5.5.10"), 4 },
    { TEXT("NetAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("Path"), TEXT("2.5.5.12"), 64 },
    { TEXT("PhoneNumber"), TEXT("2.5.5.12"), 64 },
    { TEXT("PostalAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("SmallInterval"), TEXT("2.5.5.9"), 2 },
    { TEXT("String"), TEXT("2.5.5.12"), 64 },
    { TEXT("Time"), TEXT("2.5.5.11"), 23 },

    // The following are in NTDS only
    { TEXT("INTEGER8"), TEXT("2.5.5.16"), 65 },
    { TEXT("UTCTime"), TEXT("2.5.5.11"), 23 },
    { TEXT("DN"), TEXT("2.5.5.1"), 127 },
    { TEXT("OID"), TEXT("2.5.5.2"), 6 },
    { TEXT("DirectoryString"), TEXT("2.5.5.12"), 64 },
    { TEXT("PrintableString"), TEXT("2.5.5.5"), 19 },
    { TEXT("CaseIgnoreString"), TEXT("2.5.5.4"), 20 },
    { TEXT("NumericString"), TEXT("2.5.5.6"), 18 },
    { TEXT("IA5String"), TEXT("2.5.5.5"), 22 },
    { TEXT("PresentationAddresses"), TEXT("2.5.5.13"), 127 },
    { TEXT("ORName"), TEXT("2.5.5.7"), 127 },
    { TEXT("DNWithBinary"), TEXT("2.5.5.7"), 127},
    // needs additional information to distinguish from ORName
    { TEXT("AccessPointDN"), TEXT("2.5.5.14"), 127 },
    { TEXT("DNWithString"), TEXT("2.5.5.14"), 127 },
    // needs additional information to distinguish from AccessPointDN
    { TEXT("NTSecurityDescriptor"), TEXT("2.5.5.15"), 66},
    { TEXT("GeneralizedTime"), TEXT("2.5.5.11"), 24},
    { TEXT("Enumeration"), TEXT("2.5.5.9"), 10 },
    { TEXT("ReplicaLink"), TEXT("2.5.5.10"), 127 },
    { TEXT("Sid"), TEXT("2.5.5.17"), 4 },
    { TEXT("CaseExactString"), TEXT("2.5.5.3"), 27 }
};

struct _classmapping
{
    LPTSTR pszLdapClassName;
    LPTSTR pszADsClassName;
    const GUID *pCLSID;
    const GUID *pPrimaryInterfaceGUID;
} aClassMap[] =
{
  { TEXT("user"),  USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },  // NTDS
  { TEXT("group"),  GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },  // NTDS
  { TEXT("localGroup"),  GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },    // NTDS
//  { TEXT("computer"), COMPUTER_CLASS_NAME,
//  &CLSID_LDAPComputer, &IID_IADsComputer },  // NTDS
  { TEXT("printQueue"), PRINTER_CLASS_NAME,
    &CLSID_LDAPPrintQueue, &IID_IADsPrintQueue }, // NTDS

  { TEXT("country"), TEXT("Country"),
    &CLSID_LDAPCountry, &IID_IADs },
  { TEXT("locality"), TEXT("Locality"),
    &CLSID_LDAPLocality, &IID_IADsLocality },
  { TEXT("organization"), TEXT("Organization"),
    &CLSID_LDAPO, &IID_IADsO },
  { TEXT("organizationalUnit"), TEXT("Organizational Unit"),
    &CLSID_LDAPOU, &IID_IADsOU },
  { TEXT("domain"), DOMAIN_CLASS_NAME,
    &CLSID_LDAPDomain, &IID_IADsDomain },

  { TEXT("person"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },
  { TEXT("organizationalPerson"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },
  { TEXT("residentialPerson"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },

  { TEXT("groupOfNames"), GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },
  { TEXT("groupOfUniqueNames"), GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup }

  // { TEXT("alias"), TEXT("Alias") },
  // ..other classes in RFC 1788 new
};

SYNTAXINFO g_aLDAPSyntax[] =
{ {  TEXT("Boolean"),               VT_BOOL },
  {  TEXT("Counter"),               VT_I4 },
  {  TEXT("ADsPath"),               VT_BSTR },
  {  TEXT("EmailAddress"),          VT_BSTR },
  {  TEXT("FaxNumber"),             VT_BSTR },
  {  TEXT("Integer"),               VT_I4 },
  {  TEXT("Interval"),              VT_I4 },
  {  TEXT("List"),                  VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),            VT_BSTR },
  {  TEXT("OctetString"),           VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),                  VT_BSTR },
  {  TEXT("PhoneNumber"),           VT_BSTR },
  {  TEXT("PostalAddress"),         VT_BSTR },
  {  TEXT("SmallInterval"),         VT_I4 },
  {  TEXT("String"),                VT_BSTR },
  {  TEXT("Time"),                  VT_DATE },
  {  TEXT("Integer8"),              VT_DISPATCH },
  {  TEXT("UTCTime"),               VT_DATE },
  {  TEXT("DN"),                    VT_BSTR },
  {  TEXT("OID"),                   VT_BSTR },
  {  TEXT("DirectoryString"),       VT_BSTR },
  {  TEXT("PrintableString"),       VT_BSTR },
  {  TEXT("CaseIgnoreString"),      VT_BSTR },
  {  TEXT("NumericString"),         VT_BSTR },
  {  TEXT("IA5String"),             VT_BSTR },
  {  TEXT("PresentationAddresses"), VT_BSTR },
  {  TEXT("ORName"),                VT_BSTR },
  {  TEXT("DNWithBinary"),          VT_DISPATCH },
  {  TEXT("AccessPointDN"),         VT_BSTR },
  {  TEXT("DNWithString"),          VT_DISPATCH },
  {  TEXT("NTSecurityDescriptor"),  VT_DISPATCH },
  {  TEXT("ObjectSecurityDescriptor"), VT_DISPATCH },
  {  TEXT("PresentationAddress"), VT_BSTR },
  {  TEXT("GeneralizedTime"),       VT_DATE },
  //
  // We do not support these
  //  {  TEXT("Enumeration")},
  //  {  TEXT("ReplicaLink") },
  //  {  TEXT("Sid") },
  {  TEXT("CaseExactString"),       VT_BSTR}
};

struct _OIDToNamemapping
{
    LPTSTR pszAttributeTypeOID;
    LPTSTR pszFriendlyName;
} aOIDtoNameMap[] =
{
    { TEXT("1.2.840.113556.1.4.903"),        TEXT("DNWithBinary") },
    { TEXT("1.2.840.113556.1.4.904"),        TEXT("DNWithString") },
    // DnString also has the same OID as above
    { TEXT("1.2.840.113556.1.4.905"),        TEXT("CaseIgnoreString") },
    { TEXT("1.2.840.113556.1.4.906"),        TEXT("INTEGER8") },
    { TEXT("1.2.840.113556.1.4.907"),        TEXT("ObjectSecurityDescriptor") },
    // the type is ORName a type of string -> mapped to string.
    { TEXT("1.2.840.113556.1.4.1221"),       TEXT("ORName") },
    // the type is Undefined syntax in the server, so we are defaulting.
    { TEXT("1.2.840.113556.1.4.1222"),       TEXT("Undefined") },
    { TEXT("1.2.840.113556.1.4.1362"),       TEXT("CaseExactString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.10"), TEXT("CertificatePair") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.11"), TEXT("CountryString") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.12"), TEXT("DN") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.13"), TEXT("DataQualitySyntax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.14"), TEXT("DeliveryMethod") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.15"), TEXT("DirectoryString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.19"), TEXT("DSAQualitySyntax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.2"),  TEXT("AccessPointDN") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.21"), TEXT("EmhancedGuide") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.22"), TEXT("FacsimileTelephoneNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.23"), TEXT("Fax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.24"), TEXT("GeneralizedTime") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.25"), TEXT("Guide") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.26"), TEXT("IA5String") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.27"), TEXT("INTEGER") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.28"), TEXT("JPEG") },// not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.3"),  TEXT("AttributeTypeDescription") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.32"), TEXT("MailPreference") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.33"), TEXT("ORAddress") },  // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.34"), TEXT("NameAndOptionalUID") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.36"), TEXT("NumericString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.37"), TEXT("ObjectClassDescription") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.38"), TEXT("OID") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.39"), TEXT("OtherMailBox") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.4"),  TEXT("Audio") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.40"), TEXT("OctetString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.41"), TEXT("PostalAddress") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.43"), TEXT("PresentationAddress") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.44"), TEXT("PrintableString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.5"),  TEXT("OctetString") }, // not in ours we map to Octet
    { TEXT("1.3.6.1.4.1.1466.115.121.1.50"), TEXT("TelephoneNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.51"), TEXT("TeletexTerminalIdentifier") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.52"), TEXT("TelexNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.53"), TEXT("UTCTime") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.6"),  TEXT("BitString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.7"),  TEXT("Boolean") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.8"),  TEXT("Certificate") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.9"),  TEXT("CertificateList") },
};


DWORD g_cLDAPSyntax = (sizeof(g_aLDAPSyntax)/sizeof(g_aLDAPSyntax[0]));


typedef struct _classnamelist {

    LPTSTR pszClassName;
    _classnamelist *pNext;

} CLASSNAME_LIST, *PCLASSNAME_LIST;


BOOL
GetSyntaxOID(
    LPTSTR  pszSyntax,
    LPTSTR  *ppszOID,
    DWORD   *pdwOMSyntax
)
{
    for ( int i = 0; i < ARRAY_SIZE(aSyntaxMap); i++ )
    {
        if (_tcsicmp(pszSyntax, aSyntaxMap[i].pszSyntax) == 0 )
        {
            *ppszOID = aSyntaxMap[i].pszOID;
            *pdwOMSyntax = aSyntaxMap[i].dwOMSyntax;
            return TRUE;
        }
    }

    *ppszOID = NULL;
    return FALSE;
}


BOOL
GetFriendlyNameFromOID(
    LPTSTR  pszOID,
    LPTSTR  *ppszFriendlyName
)
{
    HRESULT hr = S_OK;

    for ( int i = 0; i < ARRAY_SIZE(aOIDtoNameMap); i++ )
    {
        if ( _tcsicmp( pszOID, aOIDtoNameMap[i].pszAttributeTypeOID ) == 0 )
        {
            hr = ADsAllocString(
                     aOIDtoNameMap[i].pszFriendlyName,
                      ppszFriendlyName
                     );

            if (SUCCEEDED(hr))
                return TRUE;
            else
                return FALSE;
        }
    }

    *ppszFriendlyName = NULL;
    return FALSE;
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
);

HRESULT
MakeVariantFromPropStringTable(
    int *propList,
    LDAP_SCHEMA_HANDLE hSchema,
    VARIANT *pvVariant
);

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT   varSafeArray,
    PVARIANT *ppVarArray,
    PDWORD    pdwNumVariants
);

/* No Longer needed
HRESULT
DeleteSchemaEntry(
    LPTSTR pszADsPath,
    LPTSTR pszRelativeName,
    LPTSTR pszClassName,
    LPTSTR pszSubSchemaSubEntry,
    CCredentials& Credentials
);
*/

HRESULT
BuildSchemaLDAPPathAndGetAttribute(
    IN  LPTSTR pszParent,
    IN  LPTSTR pszClass,
    IN  LPTSTR pszSubSchemaSubEntry,
    IN  BOOL   fNew,
    IN  CCredentials& Credentials,
    IN  LPTSTR pszAttribs[],
    OUT LPWSTR * ppszSchemaLDAPServer,
    OUT LPWSTR * ppszSchemaLDAPDn,
    IN OUT PADS_LDP *pLd,
    OUT LDAPMessage **ppRes
);

HRESULT
BuildSchemaLDAPPath(
    LPTSTR pszParent,
    LPTSTR pszClass,
    LPTSTR pszSubSchemaSubEntry,
    LPWSTR * ppszSchemaLDAPServer,
    LPWSTR * ppszSchemaLDAPDn,
    BOOL   fNew,
    ADS_LDP   **pld,
    CCredentials& Credentials
);

HRESULT
MakePropArrayFromVariant(
    VARIANT vProp,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pNumOfOids
);

HRESULT
MakePropArrayFromStringArray(
    LPTSTR *aValues,
    DWORD  nCount,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pNumOfOids
);

HRESULT
SchemaGetPrimaryInterface(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
);


STDMETHODIMP
makeUnionVariantFromLdapObjects(
    LDAPOBJECTARRAY ldapSrcObjects1,
    LDAPOBJECTARRAY ldapSrcObjects2,
    VARIANT FAR * pvPossSuperiors
    );

STDMETHODIMP
addStringIfAbsent(
    BSTR addString,
    BSTR *strArray,
    PDWORD dwArrIndx
    );

//
// This functions puts the named string property into the cache
// of the object as a CaseIgnoreString. It is meant for usage from
// umi to put the simulated name property on schema objects.
//
HRESULT
HelperPutStringPropertyInCache(
    LPWSTR pszName,
    LPWSTR pszStrProperty,
    CCredentials &Credentials,
    CPropertyCache *pPropCache
    )
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwIndex = 0;
    VARIANT varBstr;
    LDAPOBJECTARRAY ldapDestObjects;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);
    VariantInit(&varBstr);

    hr = ADsAllocString(pszStrProperty, &(varBstr.bstrVal));
    BAIL_ON_FAILURE(hr);

    varBstr.vt = VT_BSTR;
    //
    // Conver the variant to LDAP objects we can cache.
    //
    hr = VarTypeToLdapTypeCopyConstruct(
             NULL, //ServerName not needed here,
             Credentials,
             LDAPTYPE_CASEIGNORESTRING,
             &varBstr,
             1,
             &ldapDestObjects
             );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //
    hr = pPropCache->findproperty(
                         pszName,
                         &dwIndex
                         );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //
    if (FAILED(hr)) {
        hr = pPropCache->addproperty( pszName );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = pPropCache->putproperty(
             pszName,
             PROPERTY_INIT,
             LDAPTYPE_CASEIGNORESTRING,
             ldapDestObjects
             );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varBstr);
    LdapTypeFreeLdapObjects( &ldapDestObjects );

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Class CLDAPSchema
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPSchema)
DEFINE_IADs_Implementation(CLDAPSchema)

CLDAPSchema::CLDAPSchema()
    : _pDispMgr( NULL ),
      _pPropertyCache(NULL)
{
    VariantInit( &_vFilter );
    VariantInit( &_vHints );

    _szServerPath[0] = 0;

    ENLIST_TRACKING(CLDAPSchema);
}

CLDAPSchema::~CLDAPSchema()
{
    VariantClear( &_vFilter );
    VariantClear( &_vHints );

    delete _pDispMgr;
    delete _pPropertyCache;

}

HRESULT
CLDAPSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    LPTSTR pszServerPath,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateSchemaObject( &pSchema, Credentials );
    BAIL_ON_FAILURE(hr);

    _tcscpy( pSchema->_szServerPath, pszServerPath );

    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pSchema->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             CLSID_LDAPSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // See if we need to create the Umi object.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pSchema)->InitUmiObject(
                   IntfPropsSchema,
                   pSchema->_pPropertyCache,
                   (IADs*) pSchema,
                   (IADs*) pSchema,
                   riid,
                   ppvObj,
                   &(pSchema->_Credentials),
                   pSchema->_dwPort
                   );

        BAIL_ON_FAILURE(hr);


        hr = HelperPutStringPropertyInCache(
                 L"Name",
                 bstrName,
                 pSchema->_Credentials,
                 pSchema->_pPropertyCache
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);

    *ppvObj = NULL;
    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPSchema::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CLDAPSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetInfo(THIS)
{
    HRESULT hr;
    hr = LDAPRefreshSchema();
    RRETURN_EXP_IF_ERR(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPSchema::GetInfo(DWORD dwFlags)
{
    if (dwFlags == GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 

    //
    // All other cases we just say OK cause there is no way to go.
    //
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    DWORD nNumOfClasses;
    DWORD nNumOfProperties;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = LdapGetSchemaObjectCount(
             _szServerPath,
             &nNumOfClasses,
             &nNumOfProperties,
             _Credentials,
             _dwPort
             );

    if ( SUCCEEDED(hr))
        *retval = nNumOfClasses + nNumOfProperties + g_cLDAPSyntax;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    if ( !pVar )
        RRETURN(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    if ( !pVar )
        RRETURN(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vHints );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vHints);

    hr = VariantCopy( &_vHints, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    DWORD dwBufferSize = 0;
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwBufferSize = ( _tcslen(_ADsPath) + _tcslen(RelativeName)
                     + 2  ) * sizeof(TCHAR);   // includes "/"

    pszBuffer = (LPTSTR) AllocADsMem( dwBufferSize );

    if ( pszBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy(pszBuffer, _ADsPath);
    _tcscat(pszBuffer, TEXT("/"));
    _tcscat(pszBuffer, RelativeName);

    hr = ::GetObject(
                pszBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszBuffer )
        FreeADsMem( pszBuffer );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CLDAPSchemaEnum::Create( (CLDAPSchemaEnum **)&penum,
                                   _ADsPath,
                                   _szServerPath,
                                   _vFilter,
                                   _Credentials
                                   );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    HRESULT hr = S_OK;
    LDAP_SCHEMA_HANDLE hSchema = NULL;

    hr = SchemaOpen( _szServerPath, &hSchema, _Credentials, _dwPort );
    BAIL_ON_FAILURE(hr);

    //
    // We can only create "Class","Property" here, "Syntax" is read-only
    //


    if (  ( _tcsicmp( ClassName, CLASS_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, NT_SCHEMA_CLASS_NAME ) == 0 )
       )
    {
        //
        // Now, create the class
        //
        hr = CLDAPClass::CreateClass(
                         _ADsPath,
                         hSchema,
                         RelativeName,
                         NULL,
                         _Credentials,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else if (  ( _tcsicmp( ClassName, PROPERTY_CLASS_NAME ) == 0 )
            || ( _tcsicmp( ClassName, NT_SCHEMA_PROPERTY_NAME ) == 0 )
            )
    {
        hr = CLDAPProperty::CreateProperty(
                         _ADsPath,
                         hSchema,
                         RelativeName,
                         NULL,
                         _Credentials,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );

    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
    }

error:

    if ( hSchema )
        SchemaClose( &hSchema );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Delete(THIS_ BSTR bstrClassName, BSTR bstrRelativeName )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::CopyHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::MoveHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    LPTSTR pszSubSchemaSubEntry = NULL;
    LPTSTR pszSchemaRoot = NULL;

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    VariantInit( pvProp );

    // Temporary hack
    if ( _tcsicmp( bstrName, TEXT("NTSchemaPath")) == 0 )
    {
        hr = LdapGetSubSchemaSubEntryPath(
                 _szServerPath,
                 &pszSubSchemaSubEntry,
                 _Credentials,
                 _dwPort
                 );
        BAIL_ON_FAILURE(hr);

        if ( pszSubSchemaSubEntry == NULL )   // not NTDS server
        {
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
        }

        // the _tcschr is to get rid of "CN=Aggregate"
        pszSchemaRoot = _tcschr(pszSubSchemaSubEntry, TEXT(','));

        if ( pszSchemaRoot == NULL )   // not NTDS server
        {
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
        }

        hr = ADsAllocString( pszSchemaRoot + 1,
                             &(pvProp->bstrVal));
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_BSTR;
    }
    else 
    {
        hr = E_NOTIMPL;
    }

error:

    if ( pszSubSchemaSubEntry )
        FreeADsStr( pszSubSchemaSubEntry );

    if ( FAILED(hr))
        VariantClear( pvProp );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPSchema::AllocateSchemaObject(
    CLDAPSchema FAR * FAR * ppSchema,
    CCredentials& Credentials
    )
{
    CLDAPSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pSchema = new CLDAPSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pSchema,
                            (IGetAttributeSyntax *) pSchema,
                            &pPropertyCache
                            );
    BAIL_ON_FAILURE(hr);

    pSchema->_pPropertyCache = pPropertyCache;
    pSchema->_Credentials = Credentials;
    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;
    delete pPropertyCache;

    RRETURN(hr);

}

HRESULT
CLDAPSchema::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;

    //
    // Make the old schema obsolete.
    // We cannot delete the old schema since other objects might have
    // references to it.
    //

    hr = LdapMakeSchemaCacheObsolete(
             _szServerPath,
             _Credentials,
             _dwPort
             );

    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPSchema::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if ((_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)
        && !_wcsicmp(L"Name", szPropertyName)) {
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
    } 
    else {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Class CLDAPClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPClass)
DEFINE_IADs_Implementation(CLDAPClass)

CLDAPClass::CLDAPClass()
    : _pDispMgr( NULL ),
      _pPropertyCache( NULL ),
      _bstrCLSID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),
      _hSchema( NULL ),
      _pClassInfo( NULL ),
      _fNTDS( TRUE ),
      _pszLDAPServer(NULL),
      _pszLDAPDn(NULL),
      _ld( NULL ),
      _fLoadedInterfaceInfo(FALSE)
{
    ENLIST_TRACKING(CLDAPClass);
}

CLDAPClass::~CLDAPClass()
{
    delete _pDispMgr;

    delete _pPropertyCache;

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    if ( _hSchema ) {
        SchemaClose( &_hSchema );
        _hSchema = NULL;
    }

    if ( _pszLDAPServer ) {
        FreeADsStr( _pszLDAPServer );
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);

    }


    if ( _ld ) {
        LdapCloseObject( _ld );
        _ld = NULL;
    }

}

HRESULT      
CLDAPClass::CreateClass(
    BSTR   bstrParent,
    LDAP_SCHEMA_HANDLE hSchema,
    BSTR   bstrName,
    CLASSINFO *pClassInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BOOL fUmiCall = FALSE;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    VARIANT var;

    VariantInit(&var);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateClassObject(Credentials,  &pClass );
    BAIL_ON_FAILURE(hr);

    //
    // Some extra things need to be done if the call is from umi.
    //
    fUmiCall = Credentials.GetAuthFlags() & ADS_AUTH_RESERVED;

    pClass->_pClassInfo = pClassInfo;
    SchemaAddRef( hSchema );
    pClass->_hSchema = hSchema;

    if ( pClassInfo )  // an existing class
    {
    
        if ( pClassInfo->pszHelpFileName )
        {
            hr = ADsAllocString( pClassInfo->pszHelpFileName,
                                 &pClass->_bstrHelpFileName );
        }

        pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;

        hr = put_BSTR_Property( pClass, TEXT("governsID"), pClassInfo->pszOID);

        if ( SUCCEEDED(hr))
        {
            hr = put_LONG_Property( pClass, TEXT("objectClassCategory"),
                                    pClassInfo->dwType );
            BAIL_ON_FAILURE(hr);

            VariantInit( &var );
            hr = MakeVariantFromPropStringTable( pClassInfo->pOIDsMustContain,
                                                 pClass->_hSchema,
                                                 &var );
            BAIL_ON_FAILURE(hr);
            hr = put_VARIANT_Property( pClass, TEXT("mustContain"), var );
            BAIL_ON_FAILURE(hr);
            if (fUmiCall) {
                //
                // Need to add this to the cache as mandatoryProperties.
                //
                hr = put_VARIANT_Property(
                         pClass,
                         TEXT("mandatoryProperties"),
                         var
                         );
                BAIL_ON_FAILURE(hr);

                //
                // We also need a dummy property called Name.
                //
                hr = put_BSTR_Property(
                         pClass,
                         TEXT("Name"),
                         bstrName
                         );
                BAIL_ON_FAILURE(hr);
            }

            VariantClear( &var );

            hr = MakeVariantFromPropStringTable( pClassInfo->pOIDsMayContain,
                                                 pClass->_hSchema,
                                                 &var );
            BAIL_ON_FAILURE(hr);
            hr = put_VARIANT_Property( pClass, TEXT("mayContain"), var );
            BAIL_ON_FAILURE(hr);
            if (fUmiCall) {
                //
                // Again need to add as optionalProperties.
                //
                hr = put_VARIANT_Property(
                         pClass,
                         TEXT("optionalProperties"),
                         var
                         );
                BAIL_ON_FAILURE(hr);
            }

            VariantClear( &var );

            hr = MakeVariantFromStringArray( pClassInfo->pOIDsSuperiorClasses,
                                             &var );
            BAIL_ON_FAILURE(hr);

            hr = put_VARIANT_Property( pClass, TEXT("subClassOf"), var );
            BAIL_ON_FAILURE(hr);
            VariantClear( &var );

            hr = MakeVariantFromStringArray( pClassInfo->pOIDsAuxClasses,
                                             &var );
            BAIL_ON_FAILURE(hr);

            hr = put_VARIANT_Property( pClass, TEXT("auxiliaryClass"), var );
            BAIL_ON_FAILURE(hr);
            VariantClear( &var );

            pClass->_pPropertyCache->ClearAllPropertyFlags();

            pClass->_fNTDS = TRUE;
        }
        else
        {
            pClass->_fNTDS = FALSE;
        }
    }


    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pClass->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pClass->InitializeCoreObject(
             bstrParent,
             bstrName,
             CLASS_CLASS_NAME,
             CLSID_LDAPClass,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //

    pClass->_pPropertyCache->SetObjInformation(
                                     &(pClass->_Credentials),
                                     pClass->_pszLDAPServer,
                                     pClass->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // If this is a umi call we need to return umi object.
    //
    if (fUmiCall) {
        hr = ((CCoreADsObject*)pClass)->InitUmiObject(
                   IntfPropsSchema,
                   pClass->_pPropertyCache,
                   (IADs *) pClass,
                   (IADs *) pClass,
                   riid,
                   ppvObj,
                   &(pClass->_Credentials),
                   pClass->_dwPort,
                   pClass->_pszLDAPServer,
                   pClass->_pszLDAPDn
                   );
        
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pClass;

    VariantClear(&var);
    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUmiHelperPrivate)) {
        *ppv = (IADsUmiHelperPrivate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPClass::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CLDAPClass::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    BOOL fChanged = FALSE;

    if ( !_fNTDS )
        RRETURN(E_NOTIMPL);

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
    {
        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        fChanged = TRUE;

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }
    else
    {
        hr = LDAPSetObject( &fChanged );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Need to refresh the schema
    //

    if ( SUCCEEDED(hr) && fChanged )
        hr = LDAPRefreshSchema();

error:

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPSetObject( BOOL *pfChanged )
{
    HRESULT hr = S_OK;

    BOOL fUpdated = FALSE;
    BOOL fUpdateMustContain = FALSE;
    BOOL fUpdateMayContain = FALSE;

    VARIANT var;
    int *pOIDs = NULL;
    DWORD nNumOfOids = 0;

    LDAPModW **aMod = NULL;
    DWORD dwNumOfMods = 0;
    DWORD dwNumOfModsNeedFreeing = 0;

    *pfChanged = FALSE;

    hr = _pPropertyCache->IsPropertyUpdated( TEXT("mustContain"), &fUpdated);
    BAIL_ON_FAILURE(hr);

    if ( fUpdated )
    {
        VariantInit(&var);
        hr = get_VARIANT_Property( this, TEXT("mustContain"), &var );
        BAIL_ON_FAILURE(hr);

        hr = MakePropArrayFromVariant( var,
                                       (SCHEMAINFO *) _hSchema,
                                       &pOIDs,
                                       &nNumOfOids );
        BAIL_ON_FAILURE(hr);

        hr = FindModifications( pOIDs,
                                nNumOfOids,
                                TEXT("mustContain"),
                                &aMod,
                                &dwNumOfMods );
        BAIL_ON_FAILURE(hr);

        // This flag needs to be cleared temporarily so that
        // LDAPMarshallProperties2 below will not try to update
        // this property. We will reset the flag right later.

        hr = _pPropertyCache->ClearPropertyFlag( TEXT("mustContain"));
        BAIL_ON_FAILURE(hr);

        fUpdateMustContain = TRUE;

        VariantClear(&var);
        FreeADsMem( pOIDs );
        pOIDs = NULL;
    }

    hr = _pPropertyCache->IsPropertyUpdated( TEXT("mayContain"), &fUpdated);
    BAIL_ON_FAILURE(hr);

    if ( fUpdated )
    {
        VariantInit(&var);
        hr = get_VARIANT_Property( this, TEXT("mayContain"), &var );
        BAIL_ON_FAILURE(hr);

        hr = MakePropArrayFromVariant( var,
                                       (SCHEMAINFO *) _hSchema,
                                       &pOIDs,
                                       &nNumOfOids );
        BAIL_ON_FAILURE(hr);

        hr = FindModifications( pOIDs,
                                nNumOfOids,
                                TEXT("mayContain"),
                                &aMod,
                                &dwNumOfMods );
        BAIL_ON_FAILURE(hr);

        // This flag needs to be cleared temporarily so that
        // LDAPMarshallProperties2 below will not try to update
        // this property. We will reset the flag later on.

        hr = _pPropertyCache->ClearPropertyFlag( TEXT("mayContain"));
        BAIL_ON_FAILURE(hr);

        fUpdateMayContain = TRUE;

        VariantClear(&var);
        FreeADsMem( pOIDs );
        pOIDs = NULL;
    }

    dwNumOfModsNeedFreeing = dwNumOfMods;

    hr = _pPropertyCache->LDAPMarshallProperties2(
                            &aMod,
                            &dwNumOfMods
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    //
    // Reset the flags so that if LdapModifyS fails, they are still flagged
    // as needed to be updated.
    //
    if ( fUpdateMustContain )
    {
        hr = _pPropertyCache->SetPropertyFlag( TEXT("mustContain"),
                                               PROPERTY_UPDATE );
        BAIL_ON_FAILURE(hr);
    }

    if ( fUpdateMayContain )
    {
        hr = _pPropertyCache->SetPropertyFlag( TEXT("mayContain"),
                                               PROPERTY_UPDATE );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Send the request to the server
    //

    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pClassInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );


        BAIL_ON_FAILURE(hr);
    }

    hr = LdapModifyS(
                   _ld,
                   _pszLDAPDn,
                   aMod
                   );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

    *pfChanged = TRUE;

error:

    VariantClear(&var);

    if ( pOIDs )
        FreeADsMem( pOIDs );

    if (aMod) {

        for ( DWORD i = 0; i < dwNumOfModsNeedFreeing; i++ )
        {
            FreeADsMem((*aMod)[i].mod_values);
        }

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    VARIANT v;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;

    //
    // Get the LDAP path of the schema entry
    //
    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pClassInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = NT_SCHEMA_CLASS_NAME;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("cn"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("cn"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("lDAPDisplayName"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("lDAPDisplayName"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClassCategory"), &dwIndex)
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_I4;
        V_I4(&v) = CLASS_TYPE_STRUCTURAL;

        hr = Put( TEXT("objectClassCategory"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );

    BAIL_ON_FAILURE(hr);

    }

    hr = LdapAddS(
                    _ld,
                    _pszLDAPDn,
                    aMod
                    );

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;
    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    DWORD dwPort = 0;

    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             _Parent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Make the old schema obsolete so we will get the new schema next
    // time we asked for it.
    // We cannot delete the old schema since other objects might have
    // references to it.
    //
    hr = LdapMakeSchemaCacheObsolete(
             pszLDAPServer,
             _Credentials,
             _dwPort
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pszLDAPServer) {

        FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL fUmiCall = FALSE;

    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;

    VariantInit(&var);
    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
        RRETURN(E_ADS_OBJECT_UNBOUND);

    //
    // Update the umicall flag - we need to add items to prop cache
    // if the call is from Umi.
    //
    fUmiCall = _Credentials.GetAuthFlags() & ADS_AUTH_RESERVED;
    
    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             _Parent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);


    //
    // AjayR - 04-05-99 do not understand why this is done
    // I do not think you need to obsolete the cache on the
    // GetInfo for a class - for the schema container yes.
    //
    hr = LdapMakeSchemaCacheObsolete(
             pszLDAPServer,
             _Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Release the original schema info
    //
    SchemaClose( &_hSchema );

    //
    // Get the new schema info
    //
    hr = SchemaOpen(
                pszLDAPServer,
                &_hSchema,
                _Credentials,
                _dwPort             // IsGCNamespace(_Parent)
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find the new class info
    //

    hr = SchemaGetClassInfo(
             _hSchema,
             _Name,
             &_pClassInfo );

    BAIL_ON_FAILURE( hr );

    if ( _pClassInfo == NULL )
    {
        // Class name not found, set error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->flushpropertycache();

    hr = put_BSTR_Property( this, TEXT("governsID"), _pClassInfo->pszOID);
    BAIL_ON_FAILURE(hr);

    hr = put_LONG_Property( this, TEXT("objectClassCategory"),
                            _pClassInfo->dwType );
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMustContain,
                                         _hSchema, &var );
    BAIL_ON_FAILURE(hr);
    hr = put_VARIANT_Property( this, TEXT("mustContain"), var );
    BAIL_ON_FAILURE(hr);
    if (fUmiCall) {
        //
        // Add as mandatoryProperties to cache.
        //
        hr = put_VARIANT_Property( this, TEXT("mandatoryProperties"), var );
        BAIL_ON_FAILURE(hr);

        hr = put_BSTR_Property( this, TEXT("Name"), this->_Name);
        BAIL_ON_FAILURE(hr);
    }
    VariantClear( &var );

    hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMayContain,
                                         _hSchema, &var );
    BAIL_ON_FAILURE(hr);
    hr = put_VARIANT_Property( this, TEXT("mayContain"), var );
    BAIL_ON_FAILURE(hr);
    if (fUmiCall) {
        //
        // Add to the cache as optionalProperties.
        //
        hr = put_VARIANT_Property( this, TEXT("optionalProperties"), var );
        BAIL_ON_FAILURE(hr);
    }
    VariantClear( &var );

    hr = MakeVariantFromStringArray( _pClassInfo->pOIDsSuperiorClasses, &var );
    BAIL_ON_FAILURE(hr);

    hr = put_VARIANT_Property( this, TEXT("subClassOf"), var );
    BAIL_ON_FAILURE(hr);
    VariantClear( &var );

    hr = MakeVariantFromStringArray( _pClassInfo->pOIDsAuxClasses, &var );
    BAIL_ON_FAILURE(hr);

    hr = put_VARIANT_Property( this, TEXT("auxiliaryClass"), var );
    BAIL_ON_FAILURE(hr);
    VariantClear( &var );

    if (_fNTDS) {
        //
        // Read the extra NTDS specific schema properties.
        //
        hr = GetNTDSSchemaInfo(TRUE);
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->ClearAllPropertyFlags();
    _pPropertyCache->setGetInfoFlag();

error:

    if (pszLDAPServer) {
        FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    VariantClear(&var);

    RRETURN_EXP_IF_ERR(hr);   // All current information are in _pClassInfo
}

//
// This routine is called only when the server is AD.
//
HRESULT
CLDAPClass::GetNTDSSchemaInfo(
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        TEXT("displaySpecification"),
        TEXT("schemaIDGUID"),
        TEXT("possibleInferiors"),
        TEXT("rDNAttid"),
        TEXT("possSuperiors"),
        TEXT("systemPossSuperiors"),
        NULL
    };

    LDAPMessage *res = NULL;


    if (_pszLDAPDn == NULL) {
        //
        // Need to get the dn for this object and also 
        // the attributes we are interested in.
        //
        hr = BuildSchemaLDAPPathAndGetAttribute(
                 _Parent,
                 _Name,
                 ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                 _pClassInfo == NULL,
                 _Credentials,
                 aStrings,
                 &_pszLDAPServer,
                 &_pszLDAPDn,
                 &_ld,
                 &res
                 );

    }
    else {
        //
        // Looks like we just need the attributes in this case.
        //
        hr = LdapSearchS(
                 _ld,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 aStrings,
                 FALSE,
                 &res
                 );
    }
        
    BAIL_ON_FAILURE(hr);

    //
    // If we succeeded we should unmarshall properties into the cache.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties(
             _pszLDAPServer,
             _ld,
             res,
             fForce,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {
        LdapMsgFree(res);
    }

    RRETURN(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPClass::GetInfo(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    if (dwFlags ==  GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 
    else {
        //
        // Read NTDS info if this is not an implicit as needed call.
        // That is this just a regular implicit GetInfo.
        //
        if (_fNTDS
            && dwFlags != GETINFO_FLAG_IMPLICIT_AS_NEEDED
            ) {
            //
            // Read the extra NTDS specific schema properties.
            //
            hr = GetNTDSSchemaInfo(FALSE);
        }   
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPClass::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    if (FAILED(hr)) {
        //
        // Need to see if this is either mandatoryProperties or
        // OptionalProperties that we special case for Umi Objects.
        //
        if (!_wcsicmp(L"mandatoryProperties", bstrName)
            || !_wcsicmp(L"optionalProperties", bstrName)
            ) {
            dwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
            hr = S_OK;
        }
    }

    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                 
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    } else {

        //
        // If pvProp is a reference to a fundamental type, we
        // have to derefernce it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }
        dwNumValues = 1;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPClass::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
             _pszLDAPServer,
             _Credentials,
             ldapSrcObjects,
             dwSyntaxId,
             pvProp
             );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    if ( dwFlags != PROPERTY_DELETE )
    {

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) ==  (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;           
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

/* IADsClass methods */


HRESULT
CLDAPClass::LoadInterfaceInfo(void)
{
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    if ( _pClassInfo )  {
    
        GUID *pPrimaryInterfaceGUID = NULL;
        GUID *pCLSID = NULL;

        hr = SchemaGetPrimaryInterface( _hSchema,
                                        _Name,
                                        &pPrimaryInterfaceGUID,
                                        &pCLSID );

        if ( pPrimaryInterfaceGUID == NULL )
            pPrimaryInterfaceGUID = (GUID *) &IID_IADs;

        //
        // Set the primary interface string
        //

        hr = StringFromCLSID((REFCLSID)*(pPrimaryInterfaceGUID),
                             &bstrTmp );
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( bstrTmp,
                             &_bstrPrimaryInterface);
        BAIL_ON_FAILURE(hr);

        CoTaskMemFree(bstrTmp);
        bstrTmp = NULL;

        if ( pCLSID )
        {
            //
            // Set the CLSID string
            //

            hr = StringFromCLSID( (REFCLSID) *(pCLSID),
                                   &bstrTmp );
            BAIL_ON_FAILURE(hr);

            hr = ADsAllocString( bstrTmp,
                                   &_bstrCLSID );

            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }
    }

error:

    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;

    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if (!_fLoadedInterfaceInfo) {
        hr = LoadInterfaceInfo();
        BAIL_ON_FAILURE(hr);
        
        _fLoadedInterfaceInfo = TRUE;
    }
    
    hr = ADsAllocString(
                 _bstrPrimaryInterface? _bstrPrimaryInterface : TEXT(""),
                 pbstrGUID );

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;

    if ( !pbstrCLSID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if (!_fLoadedInterfaceInfo) {
        hr = LoadInterfaceInfo();
        BAIL_ON_FAILURE(hr);
        
        _fLoadedInterfaceInfo = TRUE;
    }

    hr = ADsAllocString( _bstrCLSID? _bstrCLSID: TEXT(""), pbstrCLSID );

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_OID( THIS_ BSTR FAR *retval )
{
    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;

    if ( _fNTDS )
    {
        GET_PROPERTY_BSTR( this, governsID );
    }
    else if ( _pClassInfo )
    {
        hr = ADsAllocString( _pClassInfo->pszOID?
                                   _pClassInfo->pszOID : TEXT(""), retval );
    RRETURN_EXP_IF_ERR(hr);
    }
    else
    {
        hr = ADsAllocString( TEXT(""), retval );
    RRETURN_EXP_IF_ERR(hr);
    }
}

STDMETHODIMP
CLDAPClass::put_OID( THIS_ BSTR bstrOID )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    HRESULT hr = put_BSTR_Property( this, TEXT("governsID"), bstrOID );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    long lClassType = CLASS_TYPE_STRUCTURAL;  // by default

    if ( _fNTDS )
    {
        hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                &lClassType );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pClassInfo )
    {
        lClassType = _pClassInfo->dwType;
    }

    *pfAbstract = lClassType == CLASS_TYPE_ABSTRACT ?
                      VARIANT_TRUE : VARIANT_FALSE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    long lClassType;
    HRESULT hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                    &lClassType );
    if ( SUCCEEDED(hr))
    {
        if (  ( fAbstract && lClassType == CLASS_TYPE_ABSTRACT )
           || ( !fAbstract && lClassType != CLASS_TYPE_ABSTRACT )
           )
        {
            RRETURN(S_OK);  // Nothing to set
        }
    }

    hr = put_LONG_Property( (IADs *) this,
                            TEXT("objectClassCategory"),
                            fAbstract? CLASS_TYPE_ABSTRACT
                                     : CLASS_TYPE_STRUCTURAL );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    long lClassType = CLASS_TYPE_STRUCTURAL;  // by default

    if ( _fNTDS )
    {
        hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                &lClassType );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pClassInfo )
    {
        lClassType = _pClassInfo->dwType;
    }

    *pfAuxiliary = lClassType == CLASS_TYPE_AUXILIARY ?
                       VARIANT_TRUE : VARIANT_FALSE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    long lClassType = CLASS_TYPE_STRUCTURAL;
    HRESULT hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                    &lClassType );
    if ( SUCCEEDED(hr))
    {
        if (  ( fAuxiliary && lClassType == CLASS_TYPE_AUXILIARY )
           || ( !fAuxiliary && lClassType != CLASS_TYPE_AUXILIARY )
           )
        {
            RRETURN(S_OK);  // Nothing to set
        }
    }

    hr = put_LONG_Property( (IADs *) this,
                            TEXT("objectClassCategory"),
                            fAuxiliary? CLASS_TYPE_AUXILIARY
                                      : CLASS_TYPE_STRUCTURAL );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_MandatoryProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, mustContain );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMustContain,
                                             _hSchema,
                                             retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("mustContain"),
                                       vMandatoryProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, mayContain );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMayContain,
                                             _hSchema,
                                             retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("mayContain"),
                                       vOptionalProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_NamingProperties( THIS_ VARIANT FAR *pvNamingProperties )
{
    HRESULT hr = S_OK;

    if ( !pvNamingProperties )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvNamingProperties );

    hr = get_VARIANT_Property( this, TEXT("rDNAttId"), pvNamingProperties );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    hr = get_NTDSProp_Helper( TEXT("rDNAttId"), pvNamingProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("rDNAttId"),
                                       vNamingProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_DerivedFrom( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, subClassOf );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromStringArray( _pClassInfo->pOIDsSuperiorClasses,
                                         retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("subClassOf"),
                                       vDerivedFrom );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, auxiliaryClass );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromStringArray( _pClassInfo->pOIDsAuxClasses,
                                         retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("auxiliaryClass"),
                                       vAuxDerivedFrom );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors)
{
    HRESULT hr = S_OK;
    VARIANT vSysPossSuperiors;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    // Boolean values used to indicate if the values exist
    BOOL fpossSuperiors = FALSE;
    BOOL fsysPossSuperiors = FALSE;

    // Used in case we need a union of the values
    LDAPOBJECTARRAY ldapSrcObjects1;
    LDAPOBJECTARRAY ldapSrcObjects2;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects1);
    LDAPOBJECTARRAY_INIT(ldapSrcObjects2);

    VariantInit(&vSysPossSuperiors);

    if ( !pvPossSuperiors )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvPossSuperiors );

    hr = get_VARIANT_Property( this, TEXT("possSuperiors"), pvPossSuperiors );

    if ( SUCCEEDED(hr) ){
        fpossSuperiors = TRUE;
    }

    hr = get_VARIANT_Property(
             this, TEXT("systemPossSuperiors"), &vSysPossSuperiors
             );
    if (SUCCEEDED(hr)) {
        fsysPossSuperiors = TRUE;
    }

    if (!fpossSuperiors) {
        hr = get_NTDSProp_Helper( TEXT("possSuperiors"), pvPossSuperiors );
        if (SUCCEEDED(hr)) {
            fpossSuperiors = TRUE;
        }
    }

    if (!fsysPossSuperiors) {
        hr = get_NTDSProp_Helper(
                 TEXT("systemPossSuperiors"), &vSysPossSuperiors
                 );
        if (SUCCEEDED(hr)) {
            fsysPossSuperiors = TRUE;
        }
    }

    // Now if both are true, we need to do a union
    if (fpossSuperiors && fsysPossSuperiors) {
        // need to do the union
        // it is easier for me to handle strings in the ldap format
        // than to handle them as variants as there are helpers available
        // for that already
        hr = _pPropertyCache->unboundgetproperty(
                                  L"possSuperiors",
                                  &dwSyntaxId,
                                  &dwStatus,
                                  &ldapSrcObjects1
                                  );

        // No compatibility -- below it resets hr

        if (hr == E_FAIL) {
            hr = S_OK;
        }

        BAIL_ON_FAILURE(hr);

        hr = _pPropertyCache->unboundgetproperty(
                                  L"systemPossSuperiors",
                                  &dwSyntaxId,
                                  &dwStatus,
                                  &ldapSrcObjects2
                                  );

        // No compatibility -- below it resets hr

        if (hr == E_FAIL) {
            hr = S_OK;
        }

        BAIL_ON_FAILURE(hr);

        // Clear them as we no longer need the data here
        VariantClear(pvPossSuperiors);
        VariantClear(&vSysPossSuperiors);

        hr = makeUnionVariantFromLdapObjects(
                 ldapSrcObjects1,
                 ldapSrcObjects2,
                 pvPossSuperiors
                 );

        BAIL_ON_FAILURE(hr);

    }
    else if (fpossSuperiors || fsysPossSuperiors) {
        // return the appropriate value in the variant
        if (fsysPossSuperiors) {
            hr = VariantCopy(pvPossSuperiors, &vSysPossSuperiors);
            VariantClear(&vSysPossSuperiors);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    LdapTypeFreeLdapObjects(&ldapSrcObjects1);
    LdapTypeFreeLdapObjects(&ldapSrcObjects2);

    // this will make sure we handle fall through correctly

    if (SUCCEEDED(hr)) {
        RRETURN(hr);
    }

    VariantClear(pvPossSuperiors);
    VariantClear(&vSysPossSuperiors);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors)
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("possSuperiors"),
                                       vPossSuperiors);

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Containment( THIS_ VARIANT *pvContainment )
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;

    if ( !pvContainment )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvContainment );

    //
    // This call will fetch possibleInferiors if necessary using
    // an implicit GetInfo. 
    //
    hr = GetEx(L"possibleInferiors", pvContainment);
   
    if (FAILED(hr) && 
        (hr == E_ADS_PROPERTY_NOT_FOUND)
        ) {
        //
        // In this case we need to return an empty array 
        //
        hr = MakeVariantFromStringArray(
                 aValues,
                 pvContainment
                 );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Containment( THIS_ VARIANT vContainment)
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{

    HRESULT hr = S_OK;
    VARIANT vVar;
    
    if (!pfContainer) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *pfContainer = VARIANT_FALSE;

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit(&vVar);

    //
    // We now cache possibleInferiors as part of a GetInfo call.
    //
    hr = GetEx(L"possibleInferiors", &vVar);

    if (SUCCEEDED(hr)) {
        //
        // Need to see if there were any values and not just NULL.
        //
        if (V_VT(&vVar) != (VT_VARIANT | VT_ARRAY)) {
            //
            // Not the expected result has
            //
            *pfContainer = VARIANT_FALSE;
        } 
        else {
            //
            // Need to see how many elements are there.
            //
            LONG lnLBound = 0, lnUBound = 0;

            hr = SafeArrayGetUBound(
                     V_ARRAY(&vVar),
                     1,
                     &lnUBound
                     );
            if (SUCCEEDED(hr)) {
                hr = SafeArrayGetLBound(
                         V_ARRAY(&vVar),
                         1,
                         &lnLBound
                         );
                if (SUCCEEDED(hr)) {
                    //
                    // Check the length and make sure it is not 0 vals.
                    //
                    if ((lnUBound - lnLBound) + 1) {
                        *pfContainer = VARIANT_TRUE;
                    }
                } 
                else {
                    //
                    // Default to not container in this case
                    //  
                    *pfContainer = VARIANT_FALSE;
                }
            }

            hr = S_OK;
        }

        // we need to release the memory in vVar
        VariantClear(&vVar);
        
    } 
    else if (FAILED(hr) 
             && (hr == E_ADS_PROPERTY_NOT_FOUND)
             ) {
        *pfContainer = VARIANT_FALSE;
        hr = S_OK;
    } 
    
    //
    // Anything other than these and we should return the
    // appropriate hr back.
    //

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    hr = ADsAllocString( _bstrHelpFileName?
                               _bstrHelpFileName: TEXT(""),
                               pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

#if 0
    RRETURN( ADsReAllocString( &_bstrHelpFileName,
                                 bstrHelpFile? bstrHelpFile: TEXT("") ));
#endif
}

STDMETHODIMP
CLDAPClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

#if 0
    _lHelpFileContext = lHelpContext;
    RRETURN(S_OK);
#endif
}

STDMETHODIMP
CLDAPClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPClass::AllocateClassObject(
    CCredentials& Credentials,
    CLDAPClass FAR * FAR * ppClass
    )
{

    CLDAPClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pClass = new CLDAPClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pClass,
                            (IGetAttributeSyntax *) pClass,
                            &pPropertyCache
                            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pClass->_Credentials = Credentials;
    pClass->_pDispMgr = pDispMgr;
    pClass->_pPropertyCache = pPropertyCache;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT CLDAPClass::FindModifications(
    int    *pOIDs,
    DWORD  nNumOfOids,
    LPTSTR pszPropName,
    LDAPModW ***aMods,
    DWORD  *pdwNumOfMods
    )
{
    HRESULT hr = S_OK;
    int *pOIDsOld = _tcsicmp(pszPropName, TEXT("mustContain")) == 0
                        ? _pClassInfo->pOIDsMustContain
                        : _pClassInfo->pOIDsMayContain;
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;

    BOOL fReadProperty = FALSE;
    int *pOIDsCurrent = NULL;
    DWORD nNumOfOidsCurrent = 0;
    BOOL fFound = FALSE;

    LPTSTR *aValuesAdd = NULL;
    DWORD nValuesAdd = 0;
    DWORD nValuesAddTotal = 10;
    LPTSTR *aValuesRemove = NULL;
    DWORD nValuesRemove = 0;
    DWORD nValuesRemoveTotal = 10;
    DWORD nIndex = 0;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        pszPropName,
        NULL
    };


    aValuesAdd = (LPTSTR *) AllocADsMem(sizeof(LPTSTR) * nValuesAddTotal );
    if ( aValuesAdd == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aValuesRemove = (LPTSTR *) AllocADsMem(sizeof(LPTSTR) * nValuesRemoveTotal);
    if ( aValuesRemove == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We need to find the differences between the properties that needs to be
    // set and the properties that is currently on the server.
    //

    while ((pOIDs[j] != -1) || (pOIDsOld[k] != -1))
    {
        if ( pOIDs[j] == pOIDsOld[k] )
        {
            // No changes here
            j++; k++;
        }
        else if (  ( pOIDsOld[k] == -1 )
                || ( ( pOIDs[j] != -1 ) && ( pOIDs[j] < pOIDsOld[k] ))
                )
        {
            //
            // A new property has been added.
            //
            if ( nValuesAdd == nValuesAddTotal )
            {
                aValuesAdd = (LPTSTR *) ReallocADsMem( aValuesAdd,
                                          sizeof(LPTSTR) * nValuesAddTotal,
                                          sizeof(LPTSTR) * nValuesAddTotal * 2 );
                if ( aValuesAdd == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                nValuesAddTotal *= 2;
            }

            nIndex = (((SCHEMAINFO *)_hSchema)->aPropertiesSearchTable[pOIDs[j]]).nIndex;

            aValuesAdd[nValuesAdd++] =
                (((SCHEMAINFO *)_hSchema)->aProperties[nIndex]).pszPropertyName;

            j++;
        }
        else  // ( pOIDs[j] == -1 || pOIDs[j] > pOIDsOld[k] )
        {
            // Some property has been removed, we need to read the current class
            // set of "mayContain" or "mustContain" to make sure we
            // aren't removing any "systemMustContain" or "systemMayContain"
            // and we are not trying to remove any parent classes
            // may/mustContain

            if ( !fReadProperty )
            {
                LPTSTR *aValues = NULL;
                int nCount = 0;

                if ( _pszLDAPDn == NULL )
                {
                    hr = BuildSchemaLDAPPathAndGetAttribute(
                             _Parent,
                             _Name,
                             ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                             _pClassInfo == NULL,
                             _Credentials,
                             aStrings,
                             &_pszLDAPServer,
                             &_pszLDAPDn,
                             &_ld,
                             &res
                             );
                    BAIL_ON_FAILURE(hr);

                    hr = LdapFirstEntry(
                                _ld,
                                res,
                                &e
                                );
                    BAIL_ON_FAILURE(hr);

                    hr = LdapGetValues(
                                _ld,
                                e,
                                pszPropName,
                                &aValues,
                                &nCount
                                );
                }

                else
                {
                    hr = LdapReadAttribute(
                               _pszLDAPServer,
                               _pszLDAPDn,
                               pszPropName,
                               &aValues,
                               &nCount,
                               _Credentials,
                               _dwPort
                               );
                }

                if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) )
                {
                    hr = S_OK;
                }
                BAIL_ON_FAILURE(hr);

                fReadProperty = TRUE;

                if ( nCount > 0 )
                {
                    hr = MakePropArrayFromStringArray( aValues,
                                                       nCount,
                                                       (SCHEMAINFO *) _hSchema,
                                                       &pOIDsCurrent,
                                                       &nNumOfOidsCurrent );
                    LdapValueFree( aValues );
                    BAIL_ON_FAILURE(hr);
                }
            }

            //
            // See if we can find the property that we want to remove from.
            // We don't need to reset i since both arrays are sorted.
            //
            for ( fFound = FALSE; i < nNumOfOidsCurrent; i++ )
            {
                 if ( pOIDsOld[k] == pOIDsCurrent[i] )
                 {
                     fFound = TRUE;
                     break;
                 }
                 else if ( pOIDsOld[k] < pOIDsCurrent[i] )
                 {
                     // Both arrays are sorted, so we can break here
                     break;
                 }
            }

            if ( nNumOfOidsCurrent == 0 || !fFound )
            {
                int err = NO_ERROR;

                // This property is not in "mustContain" or "mayContain",
                // so nothing can be removed

                hr = E_ADS_SCHEMA_VIOLATION;
                BAIL_ON_FAILURE(hr);
            }

            //
            // Modify the request to remove the property here
            //
            if ( nValuesRemove == nValuesRemoveTotal )
            {
                aValuesRemove = (LPTSTR *) ReallocADsMem( aValuesRemove,
                                     sizeof(LPTSTR) * nValuesRemoveTotal,
                                     sizeof(LPTSTR) * nValuesRemoveTotal * 2 );
                if ( aValuesRemove == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                nValuesRemoveTotal *= 2;
            }

            nIndex = (((SCHEMAINFO *)_hSchema)->aPropertiesSearchTable[pOIDsOld[k]]).nIndex;

            aValuesRemove[nValuesRemove++] =
                (((SCHEMAINFO *)_hSchema)->aProperties[nIndex]).pszPropertyName;

            k++;
        }
    }

    if ( nValuesAdd == 0 )
    {
        FreeADsMem( aValuesAdd );
        aValuesAdd = NULL;
    }

    if ( nValuesRemove == 0 )
    {
        FreeADsMem( aValuesRemove );
        aValuesRemove = NULL;
    }

    if ( aValuesAdd || aValuesRemove )
    {
        hr = AddModifyRequest(
                 aMods,
                 pdwNumOfMods,
                 pszPropName,
                 aValuesAdd,
                 aValuesRemove );
    }

error:

    if ( pOIDsCurrent )
        FreeADsMem( pOIDsCurrent );

    if (res)
        LdapMsgFree(res);

    if ( FAILED(hr))
    {
        if ( aValuesAdd )
            FreeADsMem( aValuesAdd );

        if ( aValuesRemove )
            FreeADsMem( aValuesRemove );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT CLDAPClass::AddModifyRequest(
    LDAPModW ***aMods,
    DWORD    *pdwNumOfMods,
    LPTSTR   pszPropName,
    LPTSTR   *aValuesAdd,
    LPTSTR   *aValuesRemove
    )
{
    HRESULT hr = S_OK;
    LDAPModW *aModsBuffer = NULL;
    DWORD j = 0;
    DWORD nCount = 0;

    if ( aValuesAdd != NULL )
        nCount++;

    if ( aValuesRemove != NULL )
        nCount++;

    if ( nCount == 0 )
        RRETURN(S_OK);

    if ( *aMods == NULL )
    {
        *aMods = (LDAPModW **) AllocADsMem( (nCount + 1) * sizeof(LDAPModW *));

        if ( *aMods == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem( nCount * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( *aMods );
            *aMods = NULL;
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        LDAPModW **aModsTemp = NULL;

        aModsTemp = (LDAPModW **) AllocADsMem(
                        (*pdwNumOfMods + nCount + 1) * sizeof(LDAPModW *));

        if ( aModsTemp == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem(
                          (*pdwNumOfMods + nCount) * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( aModsTemp );
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy( aModsBuffer, **aMods, *pdwNumOfMods * sizeof(LDAPModW));
        FreeADsMem( **aMods );
        FreeADsMem( *aMods );

        *aMods = aModsTemp;

        for ( j = 0; j < *pdwNumOfMods; j++ )
        {
            (*aMods)[j] = &aModsBuffer[j];
        }
    }

    if ( aValuesAdd )
    {
        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type = pszPropName;
        aModsBuffer[j].mod_values = aValuesAdd;
        aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
        j++;
    }

    if ( aValuesRemove )
    {
        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type = pszPropName;
        aModsBuffer[j].mod_values = aValuesRemove;
        aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
    }

    *pdwNumOfMods += nCount;

error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CLDAPClass::get_NTDSProp_Helper( THIS_ BSTR bstrName, VARIANT FAR *pvProp )
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;
    int nCount = 0;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR aStrings[3];
    
    aStrings[0] = TEXT("cn");
    aStrings[1] = bstrName;
    aStrings[2] = NULL;

    if ( _pClassInfo == NULL )  // new class
    {
        hr = MakeVariantFromStringArray( NULL,
                                         pvProp );
        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // If the dn is NULL we have not got the info so fetch it.
    //
    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPathAndGetAttribute(
                _Parent,
                _Name,
               ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                _pClassInfo == NULL,
                _Credentials,
                aStrings,
                &_pszLDAPServer,
                &_pszLDAPDn,
                &_ld,
                &res
                );
        BAIL_IF_ERROR(hr);

        hr = LdapFirstEntry(
                _ld,
                res,
                &e
                );
        BAIL_IF_ERROR(hr);

        hr = LdapGetValues(
                _ld,
                e,
                bstrName,
                &aValues,
                &nCount
                );
    }

    else
    {
        hr = LdapReadAttribute(
                    _pszLDAPServer,
                    _pszLDAPDn,
                    bstrName,
                    &aValues,
                    &nCount,
                    _Credentials,
                    _dwPort
                    );
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) )
    {
        hr = NO_ERROR;
    }
    BAIL_IF_ERROR(hr);

    hr = MakeVariantFromStringArray( aValues,
                                     pvProp );
    BAIL_IF_ERROR(hr);

    hr = put_VARIANT_Property( this, bstrName, *pvProp );
    BAIL_IF_ERROR(hr);

    hr = _pPropertyCache->ClearPropertyFlag( bstrName );
    BAIL_IF_ERROR(hr);

cleanup:

    if ( aValues )
        LdapValueFree( aValues );

    if (res)
        LdapMsgFree(res);

    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPClass::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );

    RRETURN_EXP_IF_ERR(hr);
}

/* IUmiHelperPrivate support. */

//+---------------------------------------------------------------------------
// Function:   CLDAPClass::GetPropertiesHelper
//
// Synopsis:   Returns an array of PPROPERTYINFO that points to the
//          property definitions this class can hold.
//
// Arguments:  ppProperties    -   Ret values for the property info.
//             pdwCount        -   Ret value for the number of properties.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppProperties and pdwCount appropriately.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPClass::GetPropertiesHelper(
    void **ppProperties,
    PDWORD pdwPropCount
    )
{
    HRESULT hr = S_OK;
    PPROPERTYINFO *pPropArray = NULL;
    DWORD dwPropCount = 0;
    DWORD dwCtr;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) _hSchema;

    //
    // Initialize out params to default values.
    //
    *pdwPropCount = 0;
    *ppProperties  = NULL;

    //
    // If there is no classInfo then we do not have any further processing
    // to do as there are no properties on this class.
    //
    if (!this->_pClassInfo) {
        RRETURN(E_FAIL);
    }
    
    //
    // We need to know how many entries are there in the list of properties.
    // The total is made up of both the mandatory and optional properties.
    // Note that we will adjust this value suitably as we process the array.
    // 
    dwPropCount = _pClassInfo->nNumOfMayContain 
                + _pClassInfo->nNumOfMustContain;                

    pPropArray = (PPROPERTYINFO *) AllocADsMem(
                     sizeof(PPROPERTY*) * dwPropCount
                     );
    if (!pPropArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Go through and get the info for the must contain.
    //
    for (
         dwCtr = 0;
         ((dwCtr < (_pClassInfo->nNumOfMustContain))
         && (_pClassInfo->pOIDsMustContain[dwCtr] != -1));
         dwCtr++) 
        {
        //
        // Assign the appropriate prop info ptrs from the may contain list.
        //
        pPropArray[dwCtr] = &(pSchemaInfo->aProperties[
                             (pSchemaInfo->aPropertiesSearchTable[
                              _pClassInfo->pOIDsMustContain[dwCtr]].nIndex
                              )]);
    }

    DWORD dwAdjust;
    
    //
    // We could have less than the number in the array if we hit -1, or
    // -1 could be pointing correctly to the last element !!!
    //
    if ((_pClassInfo->pOIDsMustContain[dwCtr] == -1)
        && (dwCtr < _pClassInfo->nNumOfMustContain)) {
        dwCtr++;
    }
    
    dwAdjust = dwCtr;

    //
    // Now get the may contain information.
    //
    for (
         dwCtr = 0;
         ((dwCtr < (_pClassInfo->nNumOfMayContain))
          && (_pClassInfo->pOIDsMayContain[dwCtr]) != -1);
         dwCtr++) 
         {
        DWORD dwTemp = dwCtr + dwAdjust;
        pPropArray[dwTemp] = &(pSchemaInfo->aProperties[
                               (pSchemaInfo->aPropertiesSearchTable[
                                _pClassInfo->pOIDsMayContain[dwCtr]].nIndex
                                )]);
    }

    *ppProperties = (void *) pPropArray;

    if ((_pClassInfo->pOIDsMayContain[dwCtr] == -1)
        && (dwCtr < _pClassInfo->nNumOfMustContain)) {
        *pdwPropCount = dwAdjust + dwCtr + 1;
    }
    else {
        *pdwPropCount = dwAdjust + dwCtr;
    }

error:

    if (FAILED(hr)) {
        if (pPropArray) {
            FreeADsMem(pPropArray);
        }
    }

    RRETURN(hr);
}

HRESULT 
IsPropertyInList(
    LPCWSTR pszName,
    VARIANT vProp,
    BOOL *pfInList
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvProp = &vProp;
    SAFEARRAY *pArray = V_ARRAY(pvProp);
    DWORD dwSLBound;
    DWORD dwSUBound;
    DWORD dwLength = 0;
    VARIANT vVar;

    VariantInit(&vVar);

    *pfInList = FALSE;

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);
    
    dwLength = dwSUBound - dwSLBound;

    //
    // If there are 0 elements in cannot be in the list.
    //
    if (!dwLength) {
        RRETURN(S_OK);
    }
    
    for (DWORD dwCtr = 0;
         (dwCtr <= dwLength) && (*pfInList != TRUE);
         dwCtr++)
         {
        //
        // Go through the array to see if we find the name in the list.
        //
        VariantClear(&vVar);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&dwCtr,
                                &vVar
                                );
        BAIL_ON_FAILURE(hr);

        if (V_VT(&vVar) != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        if (!_wcsicmp(pszName, vVar.bstrVal)) {
            *pfInList = TRUE;
        }
    }

error:

    VariantClear(&vVar);

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:   CLDAPClass::GetOriginHelper
//
// Synopsis:   Returns the name of the class this property originated on.
//
// Arguments:  pszName         -   Name of the property whose origin is needed.
//             pbstrOrigin     -   Return value - name of class.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pbstrOrigin on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPClass::GetOriginHelper(
    LPCWSTR pszName,
    BSTR *pbstrOrigin
    )
{
    HRESULT hr = S_OK;
    CCredentials cCreds = _Credentials;
    IUnknown *pUnk = NULL;
    IADsContainer *pContainer = NULL;
    BSTR bstrTemp = NULL;
    DWORD dwAuthFlags = cCreds.GetAuthFlags();
    BOOL fDone = FALSE;
    BOOL fInMustContain = FALSE;
    BOOL fInList = FALSE;
    IADsClass *pClass = NULL;
    IDispatch *pDispObj = NULL;
    BOOL fMustContain = FALSE;
    VARIANT vVar, vVarProps;

    VariantInit(&vVar);
    VariantInit(&vVarProps);

    //
    // If we are already at the top.
    //
    if (!_wcsicmp(_Name, L"top")) {
        hr = ADsAllocString(L"top", pbstrOrigin);
        RRETURN(hr);
    }

    //
    // We want to chase up either the mandatory or optional list and
    // not both. So we first update this flag.
    //
    hr = get_MandatoryProperties(&vVarProps);
    BAIL_ON_FAILURE(hr);

    hr = IsPropertyInList(pszName, vVarProps, &fInMustContain);
    BAIL_ON_FAILURE(hr)

    //
    // Mask out the reserved flags - we want to be in ADSI land now.
    //
    cCreds.SetAuthFlags(dwAuthFlags & ~(ADS_AUTH_RESERVED));

    //
    // This will be the default class name to return.
    //  
    hr = ADsAllocString(_Name, &bstrTemp);
    BAIL_ON_FAILURE(hr);
    //
    // Need to get hold of the schema container.
    //
    hr = GetObject(_Parent, cCreds, (void **)&pUnk);
    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IADsContainer, (void **) &pContainer);
    BAIL_ON_FAILURE(hr);

    while (!fDone) {
        //
        // Need to keep finding the derived from until we hit top
        // or we hit a class that does not support the attribute.
        //
        VariantClear(&vVar);
        VariantClear(&vVarProps);

        if (pDispObj) {
            pDispObj->Release();
            pDispObj = NULL;
        }

        if (!pClass) {
            //
            // Need to get the derived from for the current class.
            //
            hr = get_DerivedFrom(&vVar);
        } 
        else {
            hr = pClass->get_DerivedFrom(&vVar);
            pClass->Release();
            pClass = NULL;
        }

        //
        // Get the derived from classes object.
        //
        hr = pContainer->GetObject(
                 L"Class",
                 vVar.bstrVal,
                 &pDispObj
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDispObj->QueryInterface(
                 IID_IADsClass,
                 (void **) &pClass
                 );
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(vVar.bstrVal, L"top")) {
            fDone = TRUE;
        }

        if (fInMustContain) {
            hr = pClass->get_MandatoryProperties(&vVarProps);
        } 
        else {
            hr = pClass->get_OptionalProperties(&vVarProps);
        }
        BAIL_ON_FAILURE(hr);

        hr = IsPropertyInList(pszName, vVarProps, &fInList);
        BAIL_ON_FAILURE(hr);

        if (!fInList) {
            //
            // The value in temp is the correct class name
            //
            hr = ADsAllocString(bstrTemp, pbstrOrigin);
            BAIL_ON_FAILURE(hr);

            fDone = TRUE;
        }

        //
        // This will be true only if we found the item in top.
        //
        if (fInList && fDone) {
            hr = ADsAllocString(L"Top", pbstrOrigin);
            BAIL_ON_FAILURE(hr);
        }

        if (bstrTemp) {
            SysFreeString(bstrTemp);
            bstrTemp = NULL;
        }

        //
        // Need to get the current class name in bstrTemp.
        //
        hr = ADsAllocString(vVar.bstrVal, &bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    //
    // We will default to the current class.
    //
    if (!pbstrOrigin) {
        hr = ADsAllocString(_Name, pbstrOrigin);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (bstrTemp) {
        SysFreeString(bstrTemp);
    }

    VariantClear(&vVar);
    VariantClear(&vVarProps);
    
    if (pContainer) {
        pContainer->Release();
    }

    if (pUnk) {
        pUnk->Release();
    }

    if (pClass) {
        pClass->Release();
    }

    if (pDispObj) {
        pDispObj->Release();
    }

    RRETURN(hr);
}
/******************************************************************/
/*  Class CLDAPProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPProperty)
DEFINE_IADs_Implementation(CLDAPProperty)

CLDAPProperty::CLDAPProperty()
    : _pDispMgr( NULL ),
      _pPropertyCache( NULL ),
      _bstrSyntax( NULL ),
      _hSchema( NULL ),
      _pPropertyInfo( NULL ),
      _pszLDAPServer(NULL),
      _pszLDAPDn(NULL),
      _fNTDS( TRUE ),
      _ld( NULL )
{
    ENLIST_TRACKING(CLDAPProperty);
}

CLDAPProperty::~CLDAPProperty()
{
    delete _pDispMgr;

    delete _pPropertyCache;

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    if ( _hSchema ) {
        SchemaClose( &_hSchema );
        _hSchema = NULL;
    }


    if (_pszLDAPServer) {
        FreeADsStr(_pszLDAPServer);
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);
    }

    if ( _ld ) {
        LdapCloseObject( _ld );
        _ld = NULL;
    }
}

HRESULT
CLDAPProperty::CreateProperty(
    BSTR   bstrParent,
    LDAP_SCHEMA_HANDLE hSchema,
    BSTR   bstrName,
    PROPERTYINFO *pPropertyInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    BSTR bstrSyntax = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocatePropertyObject(Credentials, &pProperty );
    BAIL_ON_FAILURE(hr);

    pProperty->_pPropertyInfo = pPropertyInfo;

    SchemaAddRef( hSchema );
    pProperty->_hSchema = hSchema;

    if ( pPropertyInfo )
    {
        hr = put_BSTR_Property( pProperty, TEXT("attributeID"),
                                pPropertyInfo->pszOID);

        if ( SUCCEEDED(hr))
        {
            hr = put_VARIANT_BOOL_Property( pProperty, TEXT("isSingleValued"),
                                            (VARIANT_BOOL)pPropertyInfo->fSingleValued );
            BAIL_ON_FAILURE(hr);

            pProperty->_pPropertyCache->ClearAllPropertyFlags();

            pProperty->_fNTDS = TRUE;

        }
        else
        {
            pProperty->_fNTDS = FALSE;
        }
    }

    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pProperty->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrName,
             PROPERTY_CLASS_NAME,
             CLSID_LDAPProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //
    pProperty->_pPropertyCache->SetObjInformation(
                                     &(pProperty->_Credentials),
                                     pProperty->_pszLDAPServer,
                                     pProperty->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // Need to create the umi object if applicable.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pProperty)->InitUmiObject(
                   IntfPropsSchema,
                   pProperty->_pPropertyCache,
                   (IADs *) pProperty,
                   (IADs *) pProperty,
                   riid,
                   ppvObj,
                   &(pProperty->_Credentials),
                   pProperty->_dwPort,
                   pProperty->_pszLDAPServer,
                   pProperty->_pszLDAPDn
                   );
        BAIL_ON_FAILURE(hr);
        //
        // Need to put syntax in the cache.
        //
        if (pProperty->_pPropertyInfo->pszSyntax) {
            hr = GetFriendlyNameFromOID(
                    pProperty->_pPropertyInfo->pszSyntax,
                     &bstrSyntax
                    );
            if (FAILED(hr)) {
                //
                // ok if this failed.
                //
                hr = S_OK;
            } 
            else {
                hr = put_BSTR_Property( 
                         pProperty, TEXT("syntax"),
                         bstrSyntax
                         );
                SysFreeString(bstrSyntax);
                //
                // Not critical failure
                //
                hr = S_OK;
            }
        }
        //
        // Name is a simulated propert used for UMI.
        //
        hr = put_BSTR_Property(
                 pProperty,
                 TEXT("Name"),
                 bstrName
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    }

    //
    // Get the LDAP path of the schema entry
    //

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pProperty;

    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPProperty::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) |
    IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
/* IADs methods */

STDMETHODIMP
CLDAPProperty::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    BOOL fChanged = FALSE;

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
    {
        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        fChanged = TRUE;

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }
    else
    {
        hr = LDAPSetObject( &fChanged );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Need to refresh the schema
    //

    if ( SUCCEEDED(hr) && fChanged )
        hr = LDAPRefreshSchema();

error:

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPSetObject( BOOL *pfChanged )
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;

    *pfChanged = FALSE;

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    if ( _pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );
        BAIL_ON_FAILURE(hr);
    }

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );
    BAIL_ON_FAILURE(hr);
    }

    hr = LdapModifyS(
                   _ld,
                   _pszLDAPDn,
                   aMod
                   );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

    *pfChanged = TRUE;

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    VARIANT v;
    BOOL fNTSecDes= FALSE;
    SECURITY_INFORMATION NewSeInfo;

    //
    // Get the LDAP path of the schema entry
    //
    if ( (_pszLDAPServer == NULL) && (_pszLDAPDn == NULL))
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = NT_SCHEMA_PROPERTY_NAME;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("cn"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("cn"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("lDAPDisplayName"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("lDAPDisplayName"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );
    BAIL_ON_FAILURE(hr);
    }

    hr = LdapAddS(
                    _ld,
                    _pszLDAPDn,
                    aMod
                    );


    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;

    if (( _pszLDAPServer == NULL) && (_pszLDAPDn == NULL))
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Make the old schema obsolete and get the new schema
    // We cannot delete the old schema since other objects might have
    // references to it.
    //
    hr = LdapMakeSchemaCacheObsolete(
             _pszLDAPServer,
             _Credentials,
             _dwPort
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    BSTR bstrSyntax = NULL;

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    hr = LDAPRefreshSchema();
    BAIL_ON_FAILURE(hr);

    SchemaClose( &_hSchema );

    hr = SchemaOpen( _pszLDAPServer, &_hSchema, _Credentials, _dwPort );
    BAIL_ON_FAILURE(hr);

    //
    // Find the new property info in the new schemainfo
    //

    hr = SchemaGetPropertyInfo(
             _hSchema,
             _Name,
             &_pPropertyInfo );

    BAIL_ON_FAILURE( hr );

    if ( _pPropertyInfo == NULL )
    {
        // Property name not found, set error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->flushpropertycache();

    hr = put_BSTR_Property( this, TEXT("attributeID"),
                            _pPropertyInfo->pszOID);
    BAIL_ON_FAILURE(hr);

    if ( _bstrSyntax )
    {
        ADsFreeString( _bstrSyntax );
        _bstrSyntax = NULL;
    }

    hr = put_VARIANT_BOOL_Property( this, TEXT("isSingleValued"),
                                    (VARIANT_BOOL)_pPropertyInfo->fSingleValued );
    BAIL_ON_FAILURE(hr);

    //
    // If we are calling from Umi land then we need to set 
    // additional properties.
    //
    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        if (_pPropertyInfo->pszSyntax) {
            hr = GetFriendlyNameFromOID(
                     _pPropertyInfo->pszSyntax,
                     &bstrSyntax
                     );
            if (FAILED(hr)) {
                //
                // ok if this failed.
                //
                hr = S_OK;
            } 
            else {
                hr = put_BSTR_Property( 
                         this, TEXT("syntax"),
                         bstrSyntax
                         );
                SysFreeString(bstrSyntax);
                //
                // Not critical failure
                //
                hr = S_OK;
            }
        }
        //
        // Name is a simulated propert used for UMI.
        //
        hr = put_BSTR_Property(
                 this,
                 TEXT("Name"),
                 _Name
                 );
        BAIL_ON_FAILURE(hr);

    } // special props for Umi.

    if (_fNTDS) {
        hr = GetNTDSSchemaInfo(TRUE);
    }

    _pPropertyCache->ClearAllPropertyFlags();
    _pPropertyCache->setGetInfoFlag();

error:

    if (bstrSyntax) {
        SysFreeString(bstrSyntax);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPProperty::GetInfo(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (dwFlags ==  GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 
    else if (_fNTDS
             && dwFlags != GETINFO_FLAG_IMPLICIT_AS_NEEDED
             ) {
        //
        // Read the extra NTDS specific schema properties.
        //
        hr = GetNTDSSchemaInfo(FALSE);
    }
    
    //
    // Any other flags means nothing to do.
    //
    RRETURN(hr);
}

HRESULT
CLDAPProperty::GetNTDSSchemaInfo(
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        TEXT("schemaIDGUID"),
        TEXT("rangeUpper"),
        TEXT("rangeLower"),
        NULL
    };

    LDAPMessage *res = NULL;

    if (_pszLDAPDn == NULL) {
        //
        // Need to get the dn for this object and also 
        // the attributes we are interested in.
        //
        hr = BuildSchemaLDAPPathAndGetAttribute(
                 _Parent,
                 _Name,
                 ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                 _pPropertyInfo == NULL,
                 _Credentials,
                 aStrings,
                 &_pszLDAPServer,
                 &_pszLDAPDn,
                 &_ld,
                 &res
                 );
    }
    else {
        //
        // Looks like we just need the attributes in this case.
        //
        hr = LdapSearchS(
                 _ld,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 aStrings,
                 FALSE,
                 &res
                 );
    }
        
    BAIL_ON_FAILURE(hr);

    //
    // If we succeeded we should unmarshall properties into the cache.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties(
             _pszLDAPServer,
             _ld,
             res,
             fForce,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {
        LdapMsgFree(res);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPProperty::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );

    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    if (FAILED(hr)) {
        //
        // Need to see if this is syntax if so we special case
        // for Umi Objects.
        //
        if (!_wcsicmp(L"syntax", bstrName)) {
            dwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
            hr = S_OK;
        }
    }
    BAIL_ON_FAILURE(hr);


    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
    pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                        );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                    
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

    //
    // If pvProp is a reference to a fundamental type,
    // we have to dereference it once.
    //
    if (V_ISBYREF(pvProp)) {
        hr = VariantCopyInd(&vDefProp, pvProp);
        BAIL_ON_FAILURE(hr);
        pvProp = &vDefProp;
    }
        dwNumValues = 1;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
             _pszLDAPServer,
             _Credentials,
             ldapSrcObjects,
             dwSyntaxId,
             pvProp
             );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
       RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);

    }

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    if ( dwFlags != PROPERTY_DELETE )
    {

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;                      
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }


        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsProperty methods */


STDMETHODIMP
CLDAPProperty::get_OID( THIS_ BSTR FAR *retval )
{
    HRESULT hr;
    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( _fNTDS )
    {
        GET_PROPERTY_BSTR( this, attributeID );
    }
    else if ( _pPropertyInfo )
    {
        hr =  ADsAllocString( _pPropertyInfo->pszOID?
                                   _pPropertyInfo->pszOID : TEXT(""), retval);
    }
    else
    {
        hr = ADsAllocString( TEXT(""), retval );
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_OID( THIS_ BSTR bstrOID )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    HRESULT hr = put_BSTR_Property( this, TEXT("attributeID"), bstrOID );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_Syntax( THIS_ BSTR FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( _fNTDS )
    {

        if ( _bstrSyntax )  // New property or syntax has been reset
        {
            hr = ADsAllocString( _bstrSyntax, retval);

        } else if (_pPropertyInfo && !_pPropertyInfo->pszSyntax) {
            //
            // New property but syntax has not been set
            //
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }

    //
    // Need to return if hr or retVal as we have what we need
    //
    if (FAILED(hr) || _bstrSyntax) {

        RRETURN_EXP_IF_ERR(hr);
    }

    // If we have the syntax in _pPropertyInfo we need to
    // continue and see if we can get a friendly name to return.
    if ( _pPropertyInfo ) {

        if (_pPropertyInfo->pszSyntax) {

            if (!GetFriendlyNameFromOID(
                         _pPropertyInfo->pszSyntax, retval)
                 ) {

                    // in this case we want to set the retVal
                    // to the OID as we could not find a match
                    hr = ADsAllocString(_pPropertyInfo->pszSyntax, retval);

            }
        }

    } else {

        hr = ADsAllocString( TEXT(""), retval );

    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    LPTSTR pszOID;
    DWORD  dwOMSyntax;
    HRESULT hr = S_OK;


    BYTE btDNWithBinary[] = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x14, 0x01,
                              0x01, 0x01, 0x0B };


    BYTE btDNWithString[]      = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x14, 0x01,
                                   0x01, 0x01, 0x0C
                                   };


    if ( GetSyntaxOID( bstrSyntax, &pszOID, &dwOMSyntax))
    {
        hr = put_BSTR_Property( this, TEXT("attributeSyntax"),
                                pszOID );
        BAIL_ON_FAILURE(hr);

        hr = put_LONG_Property( this, TEXT("oMSyntax"),
                                dwOMSyntax );
        BAIL_ON_FAILURE(hr);

        if ( _bstrSyntax )
            ADsFreeString( _bstrSyntax );

        hr = ADsAllocString( bstrSyntax, &_bstrSyntax );
        BAIL_ON_FAILURE(hr);

        //
        // We need to handle the special case of DNWithBinary
        // and DNString
        //
        if (_wcsicmp(bstrSyntax, L"DNWithBinary") == 0) {
            //
            // Need to set additional byte attribute
            //
            hr = put_OCTETSTRING_Property(
                     this,
                     TEXT("omObjectClass"),
                     btDNWithBinary,
                     (sizeof(btDNWithBinary)/sizeof(btDNWithBinary[0]))
                     );

            BAIL_ON_FAILURE(hr);

        }
        else if (_wcsicmp(bstrSyntax, L"DNWithString") == 0) {
            //
            // Need to set omObjectClass here too
            //
            hr = put_OCTETSTRING_Property(
                     this,
                     TEXT("omObjectClass"),
                     btDNWithString,
                     (sizeof(btDNWithString)/sizeof(btDNWithString[0]))
                     );

            BAIL_ON_FAILURE(hr);

        }
    }
    else
    {
        // Unknown syntax
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

error:
    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    HRESULT hr = S_OK;

    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    hr = get_LONG_Property(this, TEXT("rangeUpper"), plMaxRange );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    if ( _pPropertyInfo == NULL )  // new class
    {
        hr = E_ADS_PROPERTY_NOT_SET;
        RRETURN_EXP_IF_ERR(hr);
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPProperty::put_MaxRange( THIS_ long lMaxRange )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_LONG_Property( this, TEXT("rangeUpper"),
                                    lMaxRange );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    HRESULT hr = S_OK;
    
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    hr = get_LONG_Property(this, TEXT("rangeLower"), plMinRange );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    if ( _pPropertyInfo == NULL )  // new class
    {
        hr = E_ADS_PROPERTY_NOT_SET;
        RRETURN_EXP_IF_ERR(hr);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_MinRange( THIS_ long lMinRange )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_LONG_Property( this, TEXT("rangeLower"),
                                    lMinRange );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    VARIANT_BOOL fSingleValued = FALSE;  // by default

    if ( _fNTDS )
    {
        hr = get_VARIANT_BOOL_Property( this, TEXT("isSingleValued"),
                                        &fSingleValued );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pPropertyInfo )
    {
        fSingleValued = (VARIANT_BOOL)_pPropertyInfo->fSingleValued;
    }

    *pfMultiValued = fSingleValued? VARIANT_FALSE : VARIANT_TRUE;

error:

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_BOOL_Property( (IADs *) this,
                                            TEXT("isSingleValued"),
                                            !fMultiValued );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPProperty::AllocatePropertyObject(
    CCredentials& Credentials,
    CLDAPProperty FAR * FAR * ppProperty
    )
{
    CLDAPProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pProperty = new CLDAPProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pProperty,
                            (IGetAttributeSyntax *) pProperty,
                            &pPropertyCache
                            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pProperty->_Credentials = Credentials;
    pProperty->_pDispMgr = pDispMgr;
    pProperty->_pPropertyCache = pPropertyCache;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPProperty::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
    _pszLDAPServer,
    szPropertyName,
    pdwSyntaxId,
    _Credentials,
    _dwPort
    );
    RRETURN_EXP_IF_ERR(hr);
}


/******************************************************************/
/*  Class CLDAPSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPSyntax)
DEFINE_IADs_Implementation(CLDAPSyntax)
DEFINE_IADsPutGet_UnImplementation(CLDAPSyntax)

CLDAPSyntax::CLDAPSyntax()
    : _pDispMgr( NULL ),
      _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CLDAPSyntax);
}

CLDAPSyntax::~CLDAPSyntax()
{
    delete _pDispMgr;
    delete _pPropertyCache;
}

HRESULT
CLDAPSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject(Credentials, &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->pszName,
             SYNTAX_CLASS_NAME,
             CLSID_LDAPSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    //
    // If the call is from umi we need to instantiate the umi object.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pSyntax)->InitUmiObject(
                   IntfPropsSchema,
                   pSyntax->_pPropertyCache,
                   (IADs *) pSyntax,
                   (IADs *) pSyntax,
                   riid,
                   ppvObj,
                   &(pSyntax->_Credentials)
                   );
        BAIL_ON_FAILURE(hr);

        //
        // Set the simulated Name property.
        //
        hr = HelperPutStringPropertyInCache(
                 L"Name",
                 pSyntaxInfo->pszName,
                 pSyntax->_Credentials,
                 pSyntax->_pPropertyCache
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPSyntax::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
/* IADs methods */

STDMETHODIMP
CLDAPSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPSyntax::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPSyntax::AllocateSyntaxObject(
    CCredentials& Credentials,
    CLDAPSyntax FAR * FAR * ppSyntax
    )
{
    CLDAPSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CLDAPSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pSyntax,
                            (IGetAttributeSyntax *) pSyntax,
                            &pPropertyCache
                            );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pPropertyCache = pPropertyCache;

    pSyntax->_Credentials = Credentials;
    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;
    delete pPropertyCache;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPSyntax::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if ((_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)
        && !_wcsicmp(L"Name", szPropertyName)) {
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
    } 
    else {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    if ( (bstrList != NULL) && (*bstrList != 0) )
    {
        long i = 0;
        long j = 0;
        long nCount = 0;

        while ( bstrList[nCount] )
            nCount++;

        if ( nCount == 1 )
        {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            hr = ADsAllocString( bstrList[0], &(V_BSTR(pvVariant)));
            RRETURN_EXP_IF_ERR(hr);
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        i = 0;
        while ( bstrList[i] )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( bstrList[i], &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            i++;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
MakeVariantFromPropStringTable(
    int *propList,
    LDAP_SCHEMA_HANDLE hSchema,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    DWORD nCount = 0;
    BSTR *aStrings = NULL;

    if ( propList != NULL )
    {
        while ( propList[nCount] != -1 )
            nCount++;
    }

    if ( nCount > 0 )
    {
        hr = SchemaGetStringsFromStringTable(
                 hSchema,
                 propList,
                 nCount,
                 &aStrings );

        if (FAILED(hr))
            RRETURN_EXP_IF_ERR(hr);
    }

    hr =  MakeVariantFromStringArray(
              aStrings,
              pvVariant );

    for ( DWORD i = 0; i < nCount; i ++ )
    {
        FreeADsStr( aStrings[i] );
    }

    if (aStrings)
    {
        FreeADsMem( aStrings );
    }

    RRETURN(hr);

}

/* No longer needed
HRESULT
DeleteSchemaEntry(
    LPTSTR szADsPath,
    LPTSTR szRelativeName,
    LPTSTR szClassName,
    LPTSTR szSubSchemaSubEntry,
    CCredentials& Credentials
)
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;


    TCHAR  *pszParentLDAPServer = NULL;
    LPWSTR pszParentLDAPDn = NULL;
    DWORD dwPort = 0;
    LPWSTR pszLDAPDn = NULL;
    LPTSTR *aValues = NULL;
    int nCount = 0;

    //
    // Need to distinguish between LDAP Display Name and ...
    //

    //
    // Get the LDAP server name
    //
    hr = BuildLDAPPathFromADsPath2(
                szADsPath,
                &pszParentLDAPServer,
                &pszParentLDAPDn,
                &dwPort
                );
    BAIL_ON_FAILURE(hr);

    if ( szSubSchemaSubEntry == NULL )  // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Get the name of the schema object
    //
    pszLDAPDn = (LPTSTR) AllocADsMem((_tcslen(szRelativeName )
                          + _tcslen( _tcschr(szSubSchemaSubEntry,TEXT(',')))
                           ) * sizeof(TCHAR));  // includes "\\"

    if ( pszLDAPDn == NULL ){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy( pszLDAPDn, szRelativeName );
    _tcscat( pszLDAPDn, _tcschr( szSubSchemaSubEntry, TEXT(',')) );

    if ( aValues )
    {
        LdapValueFree( aValues );
        aValues = NULL;
        nCount = 0;
    }

    //
    //  Validate the class name first
    //
    hr = LdapReadAttribute(
                    pszParentLDAPServer,
                    pszLDAPDn,
                    TEXT("objectClass"),
                    &aValues,
                    &nCount,
                    Credentials,
                    dwPort
                    );
    BAIL_ON_FAILURE(hr);

    if ( nCount > 0 )
    {
        if ( _tcsicmp( szClassName, GET_BASE_CLASS( aValues, nCount) ) != 0 )
        {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Class name has been verified, so delete the object
    //
    hr = LdapDeleteS(
                    ld,
                    pszLDAPDn
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pszParentLDAPServer) {
        FreeADsStr(pszParentLDAPServer);
    }

    if (pszParentLDAPDn) {
       FreeADsStr(pszParentLDAPDn);
    }
    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if ( aValues ) {
        LdapValueFree( aValues );
    }

    if ( ld ) {
        LdapCloseObject( ld );
    }

    RRETURN(hr);
}

*/


//
// ******** Important usage note **********
//  Users of this function must make sure that cn is part of
// the list of attributes passed in. This is a requirement and
// the array must contain a NULL string as the last element.
// ******** Important usage note **********
//
HRESULT
BuildSchemaLDAPPathAndGetAttribute(
    IN LPTSTR pszParent,
    IN LPTSTR pszName,
    IN LPTSTR pszSubSchemaSubEntry,
    IN BOOL fNew,
    IN CCredentials& Credentials,
    IN LPTSTR pszAttribs[],
    OUT LPWSTR * ppszSchemaLDAPServer,
    OUT LPWSTR * ppszSchemaLDAPDn,
    IN OUT PADS_LDP *ppLd,              // optional in,
    OUT PLDAPMessage *ppRes             // caller need to get first entry
)
{
    HRESULT hr = S_OK;
    LPTSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;
    BOOL  fOpenLd = FALSE;
    LPTSTR pszSchemaRoot = NULL;
    TCHAR szFilter[MAX_PATH] = BEGIN_FILTER;    // name on ldap svr
    LDAPMessage *pE = NULL;
    int nCount = 0;
    LPTSTR pszClassName = NULL;
    LPTSTR *aValues = NULL;
    int nNumberOfEntries = 0;


    if ( !ppszSchemaLDAPServer || !ppszSchemaLDAPDn || !ppLd || !ppRes)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }


    //
    //  Using pszSubSchemaSubEntry to test NTDS is no longer accurate.
    //  But the following codes are written to work for NTDS.
    //

    if ( pszSubSchemaSubEntry == NULL )   // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_IF_ERROR(hr);
    }


    //
    // Get the server name & port #
    //

    hr = BuildLDAPPathFromADsPath2(
             pszParent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_IF_ERROR(hr);


    //
    // Connect and bind to schema Root object (in NTDS only)
    //

    pszSchemaRoot = _tcschr(                    // strip CN=Aggregate
                        pszSubSchemaSubEntry,
                        TEXT(',')
                        );

    if ( *ppLd == NULL )
    {
        hr = LdapOpenObject(
                pszLDAPServer,
                pszSchemaRoot+1,    // go past ",", we've stripped CN=Aggregate
                ppLd,
                Credentials,
                dwPort
                );
        BAIL_IF_ERROR(hr);

        fOpenLd = TRUE;
    }


    //
    // Set Serach Filter to (& (lDAPDisplayName=<pszName>)
    //                         (! (isDefunct=TRUE) )
    //                      )
    //

     _tcscat( szFilter, pszName );
     _tcscat( szFilter, END_FILTER );

    //
    // Search for scheam pszName (class object) under schema root
    //

    hr = LdapSearchS(
            *ppLd,
            pszSchemaRoot+1,        // go past ",", we've stripped CN=Aggregate
            LDAP_SCOPE_ONELEVEL,
            szFilter,
            pszAttribs,
            0,
            ppRes
            );

    //
    // Confirm with anoopa & johnsona (ntds5) :
    //      If 1 out of the 2 attributes asked for is not on the svr,
    //      LdapSearchS (ldap_search_s) returns the 1 located and hr = S_OK
    //
    BAIL_IF_ERROR(hr);


    //
    // Only one active entry should be returned.
    // If more than one entry is returned, return E_ADS_SCHEMA_VIOLATION
    // Get cn to build schemalLDAPDn
    //

    nNumberOfEntries = LdapCountEntries( *ppLd, *ppRes );

    if ( nNumberOfEntries != 1 )
        RRETURN(E_ADS_SCHEMA_VIOLATION);

    if ( fNew)      // ? still keep this
    {
        pszClassName = pszName;
    }
    else
    {
        hr = LdapFirstEntry(
                *ppLd,
                *ppRes,
                &pE
                );
        BAIL_IF_ERROR(hr);

        hr = LdapGetValues(
                *ppLd,
                pE,
                L"cn",
                &aValues,
                &nCount
                );
        BAIL_IF_ERROR(hr);

        if (nCount == 0)
        {
            // use lDAPDisplayName as common name (cn) if cn not set on svr
            pszClassName = pszName;
        }
        else
        {
            pszClassName = aValues[0];
        }
    }

    if (pszLDAPServer!=NULL)
    {
        *ppszSchemaLDAPServer = (LPWSTR) AllocADsStr(
                                        pszLDAPServer
                                        );

        if (*ppszSchemaLDAPServer == NULL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }
    else    // pszLDAPServer allowed to be NULL
    {
        *ppszSchemaLDAPServer = NULL;
    }

    *ppszSchemaLDAPDn =  (LPWSTR) AllocADsMem(
                                        (_tcslen(L"CN=") +
                                         _tcslen(pszClassName) +
                                         _tcslen(pszSchemaRoot) + 1 ) *
                                         sizeof(TCHAR)
                                        );
    if ( *ppszSchemaLDAPDn == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( *ppszSchemaLDAPDn, L"CN=");
    _tcscat( *ppszSchemaLDAPDn, pszClassName );
    _tcscat( *ppszSchemaLDAPDn, pszSchemaRoot );


    //
    // clean up for both success and failure
    //

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsMem( pszLDAPDn );
    }

    if ( aValues )
        LdapValueFree( aValues );


    RRETURN(hr);


cleanup:

    //
    // clean up if failure only
    //
    if (fOpenLd==TRUE)  {
        LdapCloseObject(*ppLd);
        *ppLd= NULL;
    }

    if (*ppRes) {
        LdapMsgFree(*ppRes);
        *ppRes=NULL;
    }

    if (*ppszSchemaLDAPServer) {
        FreeADsStr(*ppszSchemaLDAPServer);
        *ppszSchemaLDAPServer=NULL;
    }

    if (*ppszSchemaLDAPDn) {
        FreeADsMem(*ppszSchemaLDAPDn);
        *ppszSchemaLDAPDn=NULL;
    }

    RRETURN(hr);
}


HRESULT
BuildSchemaLDAPPath(
    LPTSTR pszParent,
    LPTSTR pszName,
    LPTSTR pszSubSchemaSubEntry,
    LPWSTR * ppszSchemaLDAPServer,
    LPWSTR * ppszSchemaLDAPDn,
    BOOL   fNew,
    ADS_LDP   **pld,
    CCredentials& Credentials
)
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;
    LPTSTR *aValues2 = NULL;
    int nCount = 0;
    TCHAR szFilter[MAX_PATH] = TEXT("lDAPDisplayName=");
    LPTSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;

    LPTSTR pszSchemaRoot = NULL;
    LPTSTR pszClassName = NULL;

    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             pszParent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_IF_ERROR(hr);

    if ( pszSubSchemaSubEntry == NULL )   // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_IF_ERROR(hr);
    }

    // the _tcschr is to get rid of "CN=Aggregate"

    pszSchemaRoot = _tcschr(pszSubSchemaSubEntry, TEXT(','));

    if ( fNew )
    {
        pszClassName = pszName;
    }
    else
    {
        _tcscat( szFilter, pszName );
        aStrings[0] = TEXT("cn");
        aStrings[1] = NULL;

        if ( *pld == NULL )
        {
            hr = LdapOpenObject(
                pszLDAPServer,
                pszSchemaRoot  + 1,     // go past the , - we've stripped off "CN=Aggregate"
                pld,
                Credentials,
                dwPort
                );
        BAIL_IF_ERROR(hr);

        }

        hr = LdapSearchS(
                       *pld,
                       pszSchemaRoot + 1,
                       LDAP_SCOPE_ONELEVEL,
                       szFilter,
                       aStrings,
                       0,
                       &res
                       );

       // Only one entry should be returned

       if (FAILED(hr)
          || (FAILED(hr = LdapFirstEntry( *pld, res, &e )))
          || (FAILED(hr = LdapGetValues( *pld, e, aStrings[0], &aValues2, &nCount)))
          )
       {
           BAIL_IF_ERROR(hr);
       }

       if ( nCount == 0 )
           pszClassName = pszName;
       else
           pszClassName = aValues2[0];
    }


    *ppszSchemaLDAPServer = (LPWSTR)AllocADsStr(pszLDAPServer);
    //
    // pszLDAPServer might be NULL, in which case NULL is the
    // expected return value from the alloc.
    //
    if ( (*ppszSchemaLDAPServer == NULL) && pszLDAPServer) {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    *ppszSchemaLDAPDn =  (LPTSTR) AllocADsMem(
                                            (_tcslen(L"CN=") +
                                            _tcslen(pszClassName) +
                                            _tcslen(pszSchemaRoot) + 1 ) *
                                            sizeof(TCHAR));

    if ( *ppszSchemaLDAPDn == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }
    _tcscpy( *ppszSchemaLDAPDn, L"CN=");
    _tcscat( *ppszSchemaLDAPDn, pszClassName );
    _tcscat( *ppszSchemaLDAPDn, pszSchemaRoot );

cleanup:

    if ( aValues )
        LdapValueFree( aValues );

    if ( aValues2 )
        LdapValueFree( aValues2 );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsStr( pszLDAPDn);
    }

    if ( res )
        LdapMsgFree( res );

    RRETURN(hr);
}

HRESULT
MakePropArrayFromVariant(
    VARIANT vProp,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pnNumOfOids )
{
    HRESULT hr = S_OK;
    int nIndex;
    LONG dwSLBound;
    LONG dwSUBound;
    LONG i = 0;
    LONG j, k;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    *pnNumOfOids = 0;

    if ( !V_ISARRAY( &vProp))
    {
        // special case of one object (not an array)

        nIndex = FindSearchTableIndex( V_BSTR(&vProp),
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        if ( nIndex != -1 )
        {
            *pOIDs = (int *) AllocADsMem( sizeof(int) * 2);
            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            (*pOIDs)[nCurrent++] = nIndex;
            (*pOIDs)[nCurrent] = -1;
            *pnNumOfOids = 1;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // Here, we have an array of properties. We want to create an array of
    // indexes into the aPropertiesSearchTable
    //

    hr = SafeArrayGetLBound(V_ARRAY(&vProp),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&vProp),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    *pOIDs = (int *) AllocADsMem( sizeof(int) * (dwSUBound - dwSLBound + 2));
    if ( *pOIDs == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VARIANT v;

        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&vProp),
                                (long FAR *)&i,
                                &v
                                );
        BAIL_ON_FAILURE(hr);

        nIndex = FindSearchTableIndex( V_BSTR(&v),
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        VariantClear(&v);

        if ( nIndex != -1 )
        {
            (*pOIDs)[nCurrent++] = nIndex;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
            BAIL_ON_FAILURE(hr);
        }
    }

    (*pOIDs)[nCurrent] = -1;
    *pnNumOfOids = nCurrent;

    SortAndRemoveDuplicateOIDs( *pOIDs, pnNumOfOids );

error:

    if (FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);

}

HRESULT
MakePropArrayFromStringArray(
    LPTSTR *aValues,
    DWORD  nCount,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pnNumOfOids
)
{
    HRESULT hr = S_OK;
    int nIndex;
    DWORD i = 0;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    *pnNumOfOids = 0;

    //
    // Here, we have an array of properties. We want to create an array of
    // indexes into the aPropertiesSearchTable
    //

    *pOIDs = (int *) AllocADsMem( sizeof(int) * (nCount+1));
    if ( *pOIDs == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < nCount ; i++) {

        nIndex = FindSearchTableIndex( aValues[i],
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        if ( nIndex != -1 )
        {
            (*pOIDs)[nCurrent++] = nIndex;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
            BAIL_ON_FAILURE(hr);
        }
    }

    (*pOIDs)[nCurrent] = -1;
    *pnNumOfOids = nCurrent;

    qsort( *pOIDs, *pnNumOfOids, sizeof((*pOIDs)[0]), intcmp );

error:

    if (FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

/******************************************************************/
/*  Misc Schema functions
/******************************************************************/

BOOL
GetLdapClassPrimaryInterface(
    LPTSTR  pszLdapClass,
    GUID  **ppPrimaryInterfaceGUID,
    GUID  **ppCLSID
)
{
    for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
    {
        if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
        {
            *ppPrimaryInterfaceGUID = (GUID *) aClassMap[i].pPrimaryInterfaceGUID;
            *ppCLSID = (GUID *) aClassMap[i].pCLSID;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
GetPrimaryInterface(
    LPTSTR pszClassName,
    SCHEMAINFO *pSchemaInfo,
    PCLASSNAME_LIST pClassNames,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
)
{
    int i = 0;
    CLASSINFO *pClassInfo;
    LPTSTR pszName;
    DWORD index;

    PCLASSNAME_LIST pClass = NULL;
    PCLASSNAME_LIST pNextClass = NULL;
    BOOL fExitStatus = FALSE;

    if ( GetLdapClassPrimaryInterface( pszClassName,
                                       ppPrimaryInterfaceGUID,
                                       ppCLSID ))
    {
        return TRUE;
    }

    index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( index == ((DWORD) -1) )
        return FALSE;

    //
    // Recursively search the list of superiors and
    // aux classes.  To avoid loops, we maintain a list
    // of classes we have already reached.  If we are called
    // with a class on this list, we abort.
    //

    //
    // Make sure the current class isn't already on the list
    //
    if (pClassNames) {

        for (pNextClass = pClassNames;
             pNextClass != NULL;
             pNextClass = pNextClass->pNext)
        {

            if (_tcscmp(pNextClass->pszClassName, pszClassName) == 0)
            {
                // found match, bail
                fExitStatus = FALSE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

    //
    // Construct a node for the current class & add it to the list
    //
    pClass = static_cast<PCLASSNAME_LIST>(AllocADsMem(sizeof(CLASSNAME_LIST)));
    if (!pClass) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    pClass->pszClassName = static_cast<LPTSTR>(AllocADsMem((_tcslen(pszClassName)+1) * sizeof(TCHAR)));
    if (!pClass->pszClassName) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    _tcscpy(pClass->pszClassName, pszClassName);

    pClass->pNext = pClassNames;
    

    //
    // Perform the recursive search
    //
    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( GetPrimaryInterface( pszName, pSchemaInfo, pClass,
                                      ppPrimaryInterfaceGUID, ppCLSID )) 
            {
                fExitStatus = TRUE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

    if ( pClassInfo->pOIDsAuxClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsAuxClasses[i]);
              i++  )
        {
            if ( GetPrimaryInterface( pszName, pSchemaInfo, pClass,
                                      ppPrimaryInterfaceGUID, ppCLSID )) 
            {
                fExitStatus = TRUE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

error:

    //
    // Each level of recursion is responsible for freeing
    // its own corresponding node.
    //
    if (pClass) {

        if (pClass->pszClassName) {
            FreeADsMem(pClass->pszClassName);
        }
    
        FreeADsMem(pClass);
    }

    return fExitStatus;
}

HRESULT
SchemaGetPrimaryInterface(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    GetPrimaryInterface(
        pszClassName,
        pSchemaInfo,
        NULL,
        ppPrimaryInterfaceGUID,
        ppCLSID );

    RRETURN(hr);
}


BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
)
{
    *pszADsClass = 0;

    if ( nCount == 0 )
        return FALSE;

    if ( _tcsicmp( aLdapClasses[nCount-1], TEXT("Top")) == 0 )
    {
        for ( int j = 0; j < nCount; j++ )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[0] );
        return FALSE;

    }
    else
    {
        for ( int j = nCount-1; j >= 0; j-- )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[nCount-1] );
        return FALSE;
    }

}

BOOL
MapLdapClassToADsClass(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszADsClass
)
{
    LPTSTR aClasses[1];
    CLASSINFO *pClassInfo = NULL;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    *pszADsClass = 0;

    aClasses[0] = pszClassName;
    if ( MapLdapClassToADsClass( aClasses, 1, pszADsClass ))
        return TRUE;

    DWORD index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( index == ((DWORD) -1) )  // cannot find the class name in the schema
    {
        _tcscpy( pszADsClass, pszClassName );
        return FALSE;
    }

    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        LPTSTR pszName = NULL;
        for ( int i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( MapLdapClassToADsClass( pszName, pSchemaInfo, pszADsClass))
                return TRUE;
        }
    }

    _tcscpy( pszADsClass, pszClassName );
    return FALSE;
}

LPTSTR
MapADsClassToLdapClass(
    LPTSTR pszADsClass,
    LPTSTR pszLdapClass
)
{
    for ( int i=0; i < ARRAY_SIZE(aClassMap); i++ )
    {
        if ( _tcsicmp( pszADsClass, aClassMap[i].pszADsClassName ) == 0 )
        {
            _tcscpy( pszLdapClass, aClassMap[i].pszLdapClassName );
            return pszLdapClass;
        }
    }

    _tcscpy( pszLdapClass, pszADsClass );
    return pszLdapClass;
}


STDMETHODIMP
makeUnionVariantFromLdapObjects(
    LDAPOBJECTARRAY ldapSrcObjects1,
    LDAPOBJECTARRAY ldapSrcObjects2,
    VARIANT FAR * pvPossSuperiors
    )
{
    HRESULT hr = S_OK;
    BSTR *retVals = NULL;
    DWORD dwNumVals = 0;
    BSTR curString = NULL;
    DWORD dwMaxVals = 0;
    DWORD dwCtr = 0;
    DWORD dwArrIndx = 0;
    PLDAPOBJECT pLdapObject;

    dwMaxVals = ldapSrcObjects1.dwCount + ldapSrcObjects2.dwCount + 1;

    retVals = (BSTR *)AllocADsMem(dwMaxVals * sizeof(BSTR *));

    if (!retVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    for (dwCtr = 0; dwCtr < ldapSrcObjects1.dwCount; dwCtr++) {

        pLdapObject = ldapSrcObjects1.pLdapObjects + dwCtr;
        curString = LDAPOBJECT_STRING(pLdapObject);
        hr = addStringIfAbsent(curString, retVals, &dwArrIndx);
        BAIL_ON_FAILURE(hr);
    }


    for (dwCtr = 0; dwCtr < ldapSrcObjects2.dwCount; dwCtr++) {

        pLdapObject = ldapSrcObjects2.pLdapObjects + dwCtr;
        curString = LDAPOBJECT_STRING(pLdapObject);
        hr = addStringIfAbsent(curString, retVals, &dwArrIndx);
        BAIL_ON_FAILURE(hr);
    }

    // do the same for the second ldapobjectarray

    hr = MakeVariantFromStringArray(retVals, pvPossSuperiors);

error:
    // clean up the string array either way
    for (dwCtr=0; dwCtr < dwArrIndx; dwCtr++) {
        ADsFreeString(retVals[dwCtr]);
    }
    FreeADsMem(retVals);

    RRETURN(hr);
}

STDMETHODIMP
addStringIfAbsent(
    BSTR addString,
    BSTR *strArray,
    PDWORD dwArrIndx
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    BOOLEAN fFound = FALSE;

    for (dwCtr = 0; (dwCtr < *dwArrIndx) && !fFound; dwCtr ++) {
        if (!_wcsicmp(addString, strArray[dwCtr])) {
            fFound = TRUE;
        }
    }

    if (!fFound) {

        hr = ADsAllocString(
                 addString,
                 &strArray[*dwArrIndx]
                 );

        BAIL_ON_FAILURE(hr);

        (*dwArrIndx)++;

        strArray[*dwArrIndx] = NULL;
    }

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cquerycf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cquerycf.hxx
//
//  Contents: Class factory for the LDAP Query Object.
//
//            CLDAPQueryCF::CreateInstance.
//
//  History:    03-29-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQueryCF::CreateInstance
//
// Synopsis:   Standard CreateInstance implementation.
//
// Arguments:  pUnkOuter     ---- standard outer IUnknown ptr.
//             iid           ---- interface requested.
//             ppv           ---- output ptr for created object.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiLDAPQueryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CUmiLDAPQuery::CreateUmiLDAPQuery(iid, ppv);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umisrch.cxx
//
//  Contents:   This file contains the query object for the LDAP provider.
//          IUmiQuery is the interface supported by this object. The 
//          properties on the interface property list of this object are
//          mapped to the preferences you can set for IDirectorySearch.
//
//  History:    03-27-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::CUmiLDAPQuery --- Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiLDAPQuery::CUmiLDAPQuery():
    _pIntfPropMgr(NULL),
    _pszQueryText(NULL),
    _pszLanguage(NULL),
    _ulStatus(0)
{
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::~CUmiLDAPQuery --- Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiLDAPQuery::~CUmiLDAPQuery()
{
    if (_pIntfPropMgr) {
        delete _pIntfPropMgr;
    }

    if (_pszQueryText) {
        FreeADsStr(_pszQueryText);
    }

    if (_pszLanguage) {
        FreeADsStr(_pszLanguage);
    }
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::CreateUmiLDAPQuery --- STATIC constructor.
//
// Synopsis:   Static constructor.
//
// Arguments:  riid          -  Interface needed on new object.
//             ppObj         -  Return ptr for newly created object.
//
// Returns:    S_OK on success or any suitable error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiLDAPQuery::CreateUmiLDAPQuery(
    IID riid,
    void FAR* FAR* ppObj
    )
{
    HRESULT hr = S_OK;
    CUmiLDAPQuery *pQuery;
    CPropertyManager *pIntfPropMgr = NULL;

    if (!ppObj) {
        RRETURN(E_INVALIDARG);
    }

    pQuery = new CUmiLDAPQuery();
    if (!pQuery) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = CPropertyManager::CreatePropertyManager(
             (IUmiQuery *) pQuery,
             NULL, // IADs ptr
             NULL, // pCreds
             IntfPropsQuery,
             &pIntfPropMgr
             );
    BAIL_ON_FAILURE(hr);


    hr = pQuery->QueryInterface(riid, ppObj);
    BAIL_ON_FAILURE(hr)

    pQuery->Release();

    pQuery->_pIntfPropMgr = pIntfPropMgr;

    RRETURN(hr);

error :

    if (pQuery) {
        delete pQuery;
    }

    if (pIntfPropMgr) {
        delete pIntfPropMgr;
    }

    RRETURN(hr);
}

//
// IUnknown support - standard query interface method.
//
STDMETHODIMP
CUmiLDAPQuery::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiQuery)) {
        *ppv = (IUmiQuery FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}

//
// IUmiQuery methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::Set --- IUmiQuery support.
//
// Synopsis:   Sets the query string and language.
//
// Arguments:  pszLanguage   -  Language used to specify the query,
//                              only LDAP and SQL/WQL are supported.
//             uFlags        -  Flags, only 0 is allowed now.
//             pszText       -  Query text.
//
// Returns:    N/A.
//
// Modifies:   Internal query and language strings.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiLDAPQuery::Set(
    IN LPCWSTR pszLanguage,
    IN ULONG uFlags,
    IN LPCWSTR pszText
    )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);
    //
    // Validate params
    //
    if (!pszLanguage || !pszText) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (_wcsicmp(pszLanguage, L"LDAP")
        && _wcsicmp(pszLanguage, L"SQL")
        && _wcsicmp(pszLanguage, L"WQL")
        ) {
        //
        // We do not support this language.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Free exisitng stuff if needed.
    //
    if (_pszLanguage) {
        FreeADsStr(_pszLanguage);
        _pszLanguage = NULL;
    }

    if (_pszQueryText) {
        FreeADsStr(_pszQueryText);
    }

    _pszLanguage = AllocADsStr(pszLanguage);
    if (!_pszLanguage) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    _pszQueryText = AllocADsStr(pszText);
    if (!_pszQueryText) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetQuery --- IUmiQuery support.
//
// Synopsis:   Returns the query language and text in the user allocated
//          buffers provided.
//
// Arguments:  puLangBufSize     -  Size of buffer for language string.
//             pszLangBuf        -  The actual buffer.
//             puQyeryTextBufSiz -  Size of buffer for queyr text.
//             pszQueryTextBuf   -  Buffer for query text. 
//
// Returns:    S_OK on success or any appropriate error code.
//
// Modifies: pszLangBuf and pszQueryText on success. On failure, 
//          * puLangBufSize and *puQueryTextBufSize are updated with
//          the length of the buffers needed (length in bytes).
//
//----------------------------------------------------------------------------    
STDMETHODIMP 
CUmiLDAPQuery::GetQuery(
    IN OUT ULONG * puLangBufSize,
    IN OUT LPWSTR pszLangBuf,
    IN OUT ULONG * puQueryTextBufSize,
    IN OUT LPWSTR pszQueryTextBuf
        )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (!_pszLanguage || !_pszQueryText) {
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    if (!puLangBufSize || !puQueryTextBufSize) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if ((*puLangBufSize < ((wcslen(_pszLanguage) + 1) * sizeof(WCHAR)))
        || *puQueryTextBufSize < ((wcslen(_pszQueryText) + 1) * sizeof(WCHAR))
        ) {
        //
        // We really need an insufficient buffer error for this.
        //
        *puLangBufSize = (wcslen(_pszLanguage) + 1) * sizeof(WCHAR);
        *puQueryTextBufSize = (wcslen(_pszQueryText) + 1) * sizeof(WCHAR);
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY);
    }

    //
    // We have enough space in the provided buffers.
    //
    wcscpy(pszLangBuf, _pszLanguage);
    wcscpy(pszQueryTextBuf, _pszQueryText);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//
// IUmiBaseObject methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetLastStatus (IUmiBaseObject method).
//
// Synopsis:   Returns only numeric status code from the last operation.
//
// Arguments:  uFlags           -  Only 0 is supported for now.
//             puSpecificStatus -  Returns status/error code.
//             riid             -  Not used.
//             pStatusObj       -  NULL, not used currently.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *puSpecificStatus to return appropriate status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiLDAPQuery::GetLastStatus(
    IN  ULONG uFlags,
    OUT ULONG *puSpecificStatus,
    IN  REFIID riid,
    OUT LPVOID *pStatusObj
    )
{
    if (uFlags != 0) {
       RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!puSpecificStatus) {
        RRETURN(E_INVALIDARG);
    }

    if (pStatusObj) {
        //
        // Should we error out ?
        //
        *pStatusObj = NULL;
    }

    *puSpecificStatus = _ulStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetInterfacePropList (IUmiBaseObject method).
//
// Synopsis:   Returns a pointer to the interface property list for
//          cursor object.
//
// Arguments:  uFlags      -  Flags, only 0 is supported.
//             ppPropList  -  Return value.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList changed to IUmiPropList pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiLDAPQuery::GetInterfacePropList(
    IN  ULONG uFlags,
    OUT IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if (uFlags != 0) {
        SetLastStatus(hr);
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    //
    // QI will check for bad pointer so no need to check here.
    //
    hr = _pIntfPropMgr->QueryInterface(IID_IUmiPropList, (void **)pPropList);

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//
// Private/Protected Methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetLastStatus (internal private helper routine).
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus      -   Status to be set.
//
// Returns:    Nothing
//
// Modifies:   Internal member status variable.
//
//----------------------------------------------------------------------------
void
CUmiLDAPQuery::SetLastStatus(ULONG ulStatus)
{
    this->_ulStatus = ulStatus;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cumisrch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umisrch.cxx
//
//  Contents: This object wraps an IDirectorySearch and returns Umi objects
//          as a result of the search. The Umi objects returned are
//          pre-populated with the attributes received from the search.
//          This object is used by the cursor object to support the
//          IUmiCursor interface.
//            This file also contains the CQueryStack helper class that is
//          used by the SearcHelper to parse SQL queries.
//
//  History:    03-20-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// Helper functions.
//

//+---------------------------------------------------------------------------
// Function:   HelperGetAttributeList - helper routine.
//
// Synopsis:   Gets a list of attributes that can be used in an execute
//          search call from the wbem query information.
//
// Arguments:  pdwAttribCount    -   Returns the number of attributes.
//                                 -1 means all attributes.
//             pppszAttribArray  -   Return value for string array.
//             ulListSize        -   Size of list of wbem names.
//             pWbemNames        -   The list of parsed tokens.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pdwAttribCount to correct value and pppszAttribArray to 
//          array of strings containing the attribute list.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetAttributeList(
    PDWORD pdwAttribCount,
    LPWSTR ** pppszAttribArray,
    ULONG ulListSize,
    SWbemQueryQualifiedName **pWbemNames
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    SWbemQueryQualifiedName *pName = NULL;
    LPWSTR pszTmpString = NULL;

    //
    // There should at least be a * in the list.
    //
    ADsAssert(pWbemNames);

    *pppszAttribArray = NULL;
    *pdwAttribCount = (DWORD) -1;

    //
    // If the count is just one we need to see if this is just *.
    //
    if (ulListSize == 1) {
        pName = pWbemNames[0];
        if (pName->m_ppszNameList
            && pName->m_ppszNameList[0]
            ) {
            if (_wcsicmp(pName->m_ppszNameList[0], L"*")) {
                //
                // We need to retun NULL and -1 for count.
                //
                RRETURN(hr);
            }
        }
        else {
            //
            // This has to be a bad query cause either 
            // 1) the name list was empty - cannot have empty from clause,
            // 2) the name list had an empty string in it, or
            //
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY ???
        }
    }
    
    //
    // At this point we have a valid attribute list.
    //
    *pppszAttribArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * ulListSize);
    if (!*pppszAttribArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; dwCtr < ulListSize; dwCtr++) {
        pszTmpString = NULL;
        pName = pWbemNames[dwCtr];
        
        if (!pName || !pName->m_ppszNameList) {
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_BAD_QUERY ???
        }
        
        // 
        // ADSI does not expect more than one entry in each of the pName's.
        // so if some did user.Description then we just treat this as 
        // as description by using the last value always.
        //
        pszTmpString = AllocADsStr(
            pName->m_ppszNameList[pName->m_uNameListSize-1]
            );

        if (!pszTmpString) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        (*pppszAttribArray)[dwCtr] = pszTmpString;
    }

    *pdwAttribCount = ulListSize;

error:

    if (FAILED(hr)) {
        if (*pppszAttribArray) {
            for (dwCtr = 0; dwCtr < ulListSize; dwCtr++) {
                pszTmpString = (*pppszAttribArray)[dwCtr];
                if (pszTmpString) {
                    FreeADsStr(pszTmpString);
                }
            }
            FreeADsMem(*pppszAttribArray);
            *pppszAttribArray = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetFromList - helper routine.
//
// Synopsis:   Get a filter that represents the from list. For now this
//          will only return NULL. However we will need to spruce this fn
//          if we need to support a list of classes in here.
//
// Arguments:  ppszFromFilter    -   Return value for a filter corresponding
//                                to the From list.
//             pQuery            -   Wbem query object.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   *ppszFromFilter if From list is valid.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetFromList(
    LPWSTR *ppszFromFilter,
    SWbemRpnEncodedQuery *pQuery
    )
{
    HRESULT hr = E_FAIL;
    LPWSTR pszFilter = NULL;


    *ppszFromFilter = NULL;

    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_PATH) {
        //
        // This can only be . for now.
        //
        if (!_wcsicmp(L".", pQuery->m_pszOptionalFromPath)) {
            //
            // We are ok as long as there are no other pieces.
            //
            RRETURN(S_OK);
        } 
        else {
            RRETURN(E_FAIL); // UMI_E_NOT_SUPPORTED ???
        }
    }

    //
    // For now we are going to ignore pieces if there are any other
    // pieces in the from clause.
    //
    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_UNARY) {
        // hr = E_FAIL; UMI_E_NOT_SUPPORTED.
        hr = S_OK;
    }
    else if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_CLASS_LIST) {
        // hr = E_FAIL; UMI_E_NOT_SUPPORTED.
        //for (unsigned u = 0; u < pQuery->m_uFromListSize; u++)
        //{
        // printf("  Selected class = %S\n", pQuery->m_ppszFromList[u]);
        //}
        hr = S_OK;
    }
    else {
        //
        // The query does not have anything in the from clause.
        // This is an invalid query.
        //
        hr = E_FAIL; // UMI_E_NOT_SUPPORTED ???
    }

    RRETURN(hr);
}
 
//+---------------------------------------------------------------------------
// Function:   HelperGetSubExpressionFromOperands - helper routine.
//
// Synopsis:   Updates the result with the operands and the operator. This
//          routine munges the operators/operands around so that we can
//          support operands not supported by ldap directly.
//
// Arguments:  pszResult      -   Return value, allocated by caller.
//             pszOperand1    -   The attribute being tested.
//             pszOperand2    -   The value being tested against.
//             ulOperator     -   Inidcates the comparision type.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetSubExpressionFromOperands(
    LPWSTR pszResult,
    LPWSTR pszOperand1,
    LPWSTR pszOperand2,
    ULONG  ulOperator
    )
{
    HRESULT hr = S_OK;

    //
    // In all cases we will need to begin with "(".
    //
    wsprintf(pszResult, L"(");

    //
    // All these are easy to handle.
    //
    if ((ulOperator == WMIQ_RPN_OP_EQ)
        || (ulOperator == WMIQ_RPN_OP_LT)
        || (ulOperator == WMIQ_RPN_OP_GT)
        ) {
        wcscat(pszResult, pszOperand1);
    }

    switch (ulOperator) {
    
    case WMIQ_RPN_OP_EQ :
        wcscat(pszResult, L"=");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    case WMIQ_RPN_OP_LT :
        wcscat(pszResult, L"<");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    case WMIQ_RPN_OP_GT :
        wcscat(pszResult, L">");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    //
    // All these need some processing as ldap does not 
    // handle these directly.
    //
    case WMIQ_RPN_OP_NE :
        //
        // This needs to be (!(operand1=operand2)) so a != b becomes
        // (!(a=b))
        //
        wcscat(pszResult, L"!");
        wcscat(pszResult, L"(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L"=");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    case WMIQ_RPN_OP_GE :
        //
        // a >= b becomes (!(a<b))
        //
        wcscat(pszResult, L"!(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L"<");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    case WMIQ_RPN_OP_LE :
        //
        // a <= b becomes (!(a>b))
        //
        wcscat(pszResult, L"!(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L">");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    default:
        hr = E_FAIL; // UMI_E_UNSUPPORTED_QUERY.
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperProcessOperator - helper routine.
//
// Synopsis:   Pops 2 elements from the stack, applies the operator on them
//          and pushes the effective expression on to the stack.
//
// Arguments:  pStack        -   Valid stack which should have at least 2
//                             elements in the stack.
//             ulOperatorType-   Operator type corresponding to wbem enum.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperProcessSubExpression(
    CQueryStack *pStack,
    SWbemRpnQueryToken *pExpression
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszOperand1 = NULL;
    LPWSTR pszOperand2 = NULL;
    LPWSTR pszResult = NULL;
    ULONG ulShape = pExpression->m_uSubexpressionShape;
    DWORD dwTotalLen = 0;

    ADsAssert(pStack);

    //
    // As per what is supported we should not have a function.
    // However the query parses seems to always report functions so we
    // will ignore.
    //
    if (ulShape & WMIQ_RPN_LEFT_PROPERTY_NAME) {
        SWbemQueryQualifiedName *pName = pExpression->m_pLeftIdent;
        //
        // The identifier could be x.y.z in which case ADSI is only
        // interested in z
        //
        if (pName->m_ppszNameList[pName->m_uNameListSize-1]) {
            //
            // Alloc the name itself if the operand1 is not __CLASS.
            // If it is __CLASS we need to substitute with objectClass.
            //
            if (!_wcsicmp(
                     pName->m_ppszNameList[pName->m_uNameListSize-1],
                     L"__CLASS"
                     )
                ) {
                pszOperand1 = AllocADsStr(L"objectClass");
            } 
            else {
                //
                // Alloc whatever was passed in.
                //
                pszOperand1 = AllocADsStr(
                    pName->m_ppszNameList[pName->m_uNameListSize-1]
                    );
            }
            if (!pszOperand1) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            //
            // Something really wrong.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    } 
    else {
        //
        // We cannot handle this as there is no identifier on LHS.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // We should have the operand by now, need the value
    //
    switch (pExpression->m_uConstApparentType) {
    case VT_I4:
    case VT_UI4:
        //
        // We cannot possibly have more than 20 chars.
        //
        pszOperand2 = (LPWSTR) AllocADsMem(20 * sizeof(WCHAR));
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        if (pExpression->m_uConstApparentType == VT_I4) {
            _ltot(pExpression->m_Const.m_lLongVal, pszOperand2, 10 );
        }
        else {
            _ltot(pExpression->m_Const.m_uLongVal, pszOperand2, 10);
        }
        break;

    case VT_BOOL:
        //
        // Again 20 sounds good !
        //
        pszOperand2 = (LPWSTR) AllocADsMem(20 * sizeof(WCHAR));
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (pExpression->m_Const.m_bBoolVal )
            wcscpy(pszOperand2, L"TRUE");
        else
            wcscpy(pszOperand2, L"FALSE");
        break;

    case VT_LPWSTR:
        pszOperand2 = AllocADsStr(pExpression->m_Const.m_pszStrVal);
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        break;

    default:
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED.
        break;
    }

    //
    // At this point we can combine the 2 operands and operator.
    // Total size is size of strings + () + 2 for operator + 1 for \0.
    // Total additions = 5. This is for most cases.
    //
    dwTotalLen = wcslen(pszOperand1) + wcslen(pszOperand2) + 5;

    //
    // Operators <= >= and != need to be processed to be usable in ldap.
    // In these cases, we assume that twice the length is needed.
    //
    dwTotalLen *= 2;

    pszResult = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszResult) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = HelperGetSubExpressionFromOperands(
             pszResult,
             pszOperand1,
             pszOperand2,
             pExpression->m_uOperator
             );

    /*
    wsprintf(pszResult, L"(");
    wcscat(pszResult, pszOperand1);
    
    //
    // Need to add the opearator now.
    //
    switch (pExpression->m_uOperator) {

    case WMIQ_RPN_OP_EQ :
        wcscat(pszResult,L"=");
        break;

    case WMIQ_RPN_OP_NE :
        wcscat(pszResult, L"!=");
        break;

    case WMIQ_RPN_OP_GE :
        wcscat(pszResult, L">=");
        break;

    case WMIQ_RPN_OP_LE :
        wcscat(pszResult, L"<=");
        break;

    case WMIQ_RPN_OP_LT :
        wcscat(pszResult, L"<");
        break;

    case WMIQ_RPN_OP_GT :
        wcscat(pszResult, L">");
        break;

        
    case WMIQ_RPN_OP_UNDEFINED:
    case WMIQ_RPN_OP_LIKE :
    case WMIQ_RPN_OP_ISA  :
    case WMIQ_RPN_OP_ISNOTA  :
    default :
        //
        // All these mean we have a bad query.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
        break;
    }

    //
    // Now tag on operand2 and the closing ), and push result onto stack.
    //
    wcscat(pszResult, pszOperand2);
    wcscat(pszResult, L")");
    */

    hr = pStack->Push(pszResult, QUERY_STACK_ITEM_LITERAL);
    BAIL_ON_FAILURE(hr);
error:

    if (pszOperand1) {
        FreeADsStr(pszOperand1);
    }

    if (pszOperand2) {
        FreeADsStr(pszOperand2);
    }

    if (pszResult) {
        FreeADsStr(pszResult);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperProcessOperator - helper routine.
//
// Synopsis:   Pops 2 elements from the stack, applies the operator on them
//          and pushes the effective expression on to the stack.
//
// Arguments:  pStack        -   Valid stack which should have at least 2
//                             elements in the stack.
//             ulOperatorType-   Operator type corresponding to wbem enum.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperProcessOperator(
    CQueryStack *pStack,
    ULONG ulOperatorType
    )
{
    HRESULT hr;
    LPWSTR pszStr1 = NULL;
    LPWSTR pszStr2 = NULL;
    LPWSTR pszResult = NULL;
    DWORD dwNodeType;
    DWORD dwTotalLen = 0;

    ADsAssert(pStack);

    hr = pStack->Pop(
             &pszStr1,
             &dwNodeType
             );
    BAIL_ON_FAILURE(hr);

    //
    // String has to be valid and the node cannot be an operator.
    //
    if (!pszStr1 || !*pszStr1
        || (dwNodeType != QUERY_STACK_ITEM_LITERAL) 
        ) {
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
    }

    dwTotalLen += wcslen(pszStr1);
    
    //
    // Not has only one operand.
    //
    if (ulOperatorType != WMIQ_RPN_TOKEN_NOT) {
        hr = pStack->Pop(
                 &pszStr2,
                 &dwNodeType
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Sanity check.
        //
        if (!pszStr2 || !*pszStr2 
            || (dwNodeType != QUERY_STACK_ITEM_LITERAL)
            ) {
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
        }
        //
        // Need to add string2's length.
        //
        dwTotalLen += wcslen(pszStr2);
    }

    //
    // The resultant node needs to hold both strings and the operator
    // and the additional set of parentheses.
    // 4 = operator + () and one for \0.
    //
    dwTotalLen += 4;
    
    pszResult = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszResult) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszResult, L"(");
    switch (ulOperatorType) {
    
    case WMIQ_RPN_TOKEN_AND :
        wcscat(pszResult, L"&");
        break;

    case WMIQ_RPN_TOKEN_OR :
        wcscat(pszResult, L"|");
        break;

    case WMIQ_RPN_TOKEN_NOT :
        wcscat(pszResult, L"!");
        break;

    default:
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED.
    }

    //
    // At this point we need to tag on both the pre composed pieces
    // and the final closing parentheses.
    //
    wcscat(pszResult, pszStr1);
    
    //
    // Do not Tag on the second string only if operator is NOT.
    //
    if (ulOperatorType != WMIQ_RPN_TOKEN_NOT) {
        wcscat(pszResult, pszStr2);
    }

    wcscat(pszResult, L")");

    //
    // Need to push the result on to the stack as a literal.
    //
    hr = pStack->Push(
             pszResult,
             QUERY_STACK_ITEM_LITERAL
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pszStr1) {
        FreeADsStr(pszStr1);
    }

    if (pszStr2) {
        FreeADsStr(pszStr2);
    }

    if (pszResult) {
        FreeADsStr(pszResult);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetFilterFromWhereClause - helper routine.
//
// Synopsis:   Returns a filter corresponding to the elements specified in
//          the where clause.
//
// Arguments:  ppszFilter    -   Return value for a filter corresponding
//                             to the Where clause.
//             ulCount       -   Number of elements in the where clause.
//             pWhere        -   Pointer to the Wbem where clause.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   *ppszFilter if Where clause is valid.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetFilterFromWhereClause(
    LPWSTR *ppszFilter,
    ULONG ulCount,
    SWbemRpnQueryToken **pWhere
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr;
    CQueryStack *pStack = NULL;
    LPWSTR pszFilter = NULL;
    DWORD dwType;

    *ppszFilter = NULL;

    if (!ulCount) {
        //
        // In this case we will default to NULL.
        //
        RRETURN(hr);
    }

    pStack = new CQueryStack();
    if (!pStack) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Process the tokens in the where clause.
    //
    for (dwCtr = 0; dwCtr < ulCount; dwCtr++) {
        SWbemRpnQueryToken *pToken = pWhere[dwCtr];

        switch (pToken->m_uTokenType) {
            //
            // All these are operations.
            //
        case WMIQ_RPN_TOKEN_AND :
        case WMIQ_RPN_TOKEN_OR :
        case WMIQ_RPN_TOKEN_NOT :
            HelperProcessOperator(pStack, pToken->m_uTokenType);
            break;

        case WMIQ_RPN_TOKEN_EXPRESSION :
            HelperProcessSubExpression(pStack, pToken);
            break;

        default:
            //
            // We cannot handle the query.
            //
            hr = E_FAIL; // UMI_E_UNSUPPORTED_QUERY.
            break;
        }
        BAIL_ON_FAILURE(hr);
    }

    //
    // At this stack should have one element and that should be
    // the filter we use if things went right.
    //
    hr = pStack->Pop(
             &pszFilter,
             &dwType
             );
    BAIL_ON_FAILURE(hr);

    if (!pStack->IsEmpty()) {
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
    }

    *ppszFilter = pszFilter;

error:

    if (pStack) {
        delete pStack;
    }

    if (FAILED(hr) && pszFilter) {
        FreeADsStr(pszFilter);
    }

    RRETURN(hr);
}

HRESULT
HelperGetSortKey(
    SWbemRpnEncodedQuery *pRpn,
    PADS_SORTKEY * ppADsSortKey
    )
{
    HRESULT hr = S_OK;
    PADS_SORTKEY pSortKey = NULL;

    if (!pRpn->m_uOrderByListSize) {
        RRETURN(S_OK);
    }
    //
    // Allocate the sort key.
    //
    pSortKey = (PADS_SORTKEY) AllocADsMem(sizeof(ADS_SORTKEY));
    if (!pSortKey) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSortKey->pszAttrType = AllocADsStr(pRpn->m_ppszOrderByList[0]);
    if (!pSortKey->pszAttrType) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pRpn->m_uOrderDirectionEl[0]) {
        pSortKey->fReverseorder = TRUE;
    }

    RRETURN(S_OK);
error:

    if (pSortKey) {
        if (pSortKey->pszAttrType) {
            FreeADsStr(pSortKey->pszAttrType);
        }
        FreeADsMem(pSortKey);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::CUmiSearchHelper --- Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiSearchHelper::CUmiSearchHelper():
    _hSearchHandle(NULL),
    _pConnection(NULL),
    _pContainer(NULL),
    _pszADsPath(NULL),
    _pszLdapServer(NULL),
    _pszLdapDn(NULL),
    _pIID(NULL),
    _fSearchExecuted(FALSE),
    _fResetAllowed(TRUE)
{
    //
    // This is global scope helper routine that will not fail.
    // The boolean is the value for cache results.
    //
    LdapInitializeSearchPreferences(&_searchPrefs, FALSE);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::~CUmiSearchHelper --- Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiSearchHelper::~CUmiSearchHelper()
{
    if (_hSearchHandle) {
        ADsCloseSearchHandle(_hSearchHandle);
    }

    if (_pConnection) {
        _pConnection->Release();
    }

    if (_pContainer) {
        _pContainer->Release();
    }

    if (_pQuery) {
        _pQuery->Release();
    }

    if (_pszADsPath) {
        FreeADsStr(_pszADsPath);
    }

    if (_pszLdapServer) {
        FreeADsStr(_pszLdapServer);
    }

    if (_pszLdapDn) {
        FreeADsStr(_pszLdapDn);
    }

    if (_pCreds) {
        delete _pCreds;
    }

}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::CreateSearchHelper --- STATIC constructor.
//
// Synopsis:   Static constructor.
//
// Arguments:  pUmiQuery     -  Pointer to query object that.
//             pConnection   -  Connection to execute query on.
//             pUnk          -  Container on which the query is executed.
//             pSrchObj      -  New object is returned in this param.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::CreateSearchHelper(
    IUmiQuery *pUmiQuery,
    IUmiConnection *pConnection,
    IUnknown *pUnk,
    LPCWSTR pszADsPath,
    LPCWSTR pszLdapServer,
    LPCWSTR pszLdapDn,
    CCredentials cCredentials,
    DWORD dwPort,
    CUmiSearchHelper FAR* FAR * ppSrchObj
    )
{
    HRESULT hr = S_OK;
    CUmiSearchHelper FAR * pSearchHelper = NULL;
    
    //
    // Asserts are good enough as this is an internal routine.
    //
    ADsAssert(ppSrchObj);
    ADsAssert(pUmiQuery && pConnection && pUnk);

    pSearchHelper = new CUmiSearchHelper();
    if (!pSearchHelper) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSearchHelper->_pszADsPath = AllocADsStr(pszADsPath);
    if (!pSearchHelper->_pszADsPath) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // pszLdapDn can be null
    //
    if (pszLdapDn) {
        pSearchHelper->_pszLdapDn = AllocADsStr(pszLdapDn);
        if (!pSearchHelper->_pszLdapDn) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    
    //
    // the server can also be null.
    //
    if (pszLdapServer) {
        pSearchHelper->_pszLdapServer = AllocADsStr(pszLdapServer);
        if (!pSearchHelper->_pszLdapServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    pSearchHelper->_pCreds = new CCredentials(cCredentials);
    if (!pSearchHelper->_pCreds) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSearchHelper->_pConnection = pConnection;
    pConnection->AddRef();

    pSearchHelper->_pQuery = pUmiQuery;
    pUmiQuery->AddRef();

    pSearchHelper->_pContainer = pUnk;
    pUnk->AddRef();

    pSearchHelper->_dwPort = dwPort;

    *ppSrchObj = (CUmiSearchHelper FAR *)pSearchHelper;
    RRETURN(hr);

error :

    delete pSearchHelper;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::SetIID
//
// Synopsis:   Sets the IID requested on the returned objects.
//
// Arguments:  riid    -    The iid requested.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   _pIID the internal IID pointer.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::SetIID(REFIID riid)
{
    if (_pIID) {
        FreeADsMem(_pIID);
    }

    _pIID = (IID *) AllocADsMem(sizeof(IID));

    if (!_pIID) {
        RRETURN(E_OUTOFMEMORY);
    }

    memcpy(_pIID, &riid, sizeof(IID));

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Reset
//
// Synopsis:   Not implemented.
//
// Arguments:  None.
//
// Returns:    E_NOTIMPL.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Reset()
{
    //
    // We can potentially add support for this down the road.
    //
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Next
//
// Synopsis:   Return the next uNumRequested elements from the search.
//
// Arguments:  uNumRequested     -   number of objects/rows to fetch.
//             pNumReturned      -   number of objects/rows returned.
//             pObject           -   array of returned objects.
//
// Returns:    S_OK, S_FALSE or any appropriate error code.
//
// Modifies:   pNumReturned, pObjects and internal search handle state.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT hr = S_OK;
    IUnknown **pTempUnks = NULL;
    DWORD dwCtr = 0, dwIndex = 0;

    if (!puNumReturned || !ppObjects || (uNumRequested < 1)) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (!_fSearchExecuted) {
        hr = InitializeSearchContext();
        BAIL_ON_FAILURE(hr);
    }

    pTempUnks = (IUnknown **) AllocADsMem(sizeof(IUnknown*) * uNumRequested);
    
    if (!pTempUnks) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the requested number of objects one at a time until 
    // we hit S_FALSE or an error and then repackage to suitable
    // array as needed.
    //
    while ((dwCtr < uNumRequested) 
           && (hr != S_FALSE) ) {
        IUnknown *pUnk = NULL;
        hr = GetNextObject(&pUnk);
        //
        // This wont catch S_FALSE.
        //
        BAIL_ON_FAILURE(hr);
        
        //
        // Needed as if he get S_FALSE we will set the ptr and
        // increase the count incorrectly.
        //
        if (hr != S_FALSE) {
            pTempUnks[dwCtr] = pUnk;
            dwCtr++;
        }
    }

    //
    // At this point we have all the results we need or can get.
    //
    if (uNumRequested == dwCtr) {
        //
        // We can return tempObjects in this case.
        //
        *ppObjects = (void *)pTempUnks;
    } 
    else {
        //
        // Less than what had been requested.
        //
        IUnknown **pUnkCopy;
        
        pUnkCopy = (IUnknown **) AllocADsMem(sizeof(IUnknown *) * dwCtr);
        if (!pUnkCopy) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (dwIndex = 0; dwIndex < dwCtr; dwIndex++) {
            //
            // Just need to copy the ptrs over.
            //
            pUnkCopy[dwIndex] = pTempUnks[dwIndex];
        }

        //
        // Only return the number of entries we got back.
        //
        *ppObjects = (void *) pUnkCopy;

        FreeADsMem((void *)pTempUnks);
    }

    //
    // We are error free over here.
    //
    *puNumReturned = dwCtr;
    
    RRETURN(hr);

error:

    if (pTempUnks) {
        //
        // For will be executed only if we have valid count.
        //
        for (dwIndex = 0; dwIndex < dwCtr; dwIndex++) {
            pTempUnks[dwIndex]->Release();
        }

        FreeADsMem(pTempUnks);
    }

    *puNumReturned = 0;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Previous (E_NOTIMPL)
//
// Synopsis:   Return the previous object in the result set - Not implemented.
//
// Arguments:  uFlags            -   only flag supported is 0.
//             pObj              -   object is returned in this param.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search handle state and pObject.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Previous(
    ULONG uFlags,
    LPVOID *pObj
    )
{
    RRETURN(E_NOTIMPL);
}

//
// Internal/protected routines
//

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::InitializeSearchContext.
//
// Synopsis:   Prepares the internal state of the object. This initializes
//          the search preferences from the query object, leaveing the search
//          helper ready to retrieve results.
//
// Arguments:  None.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search preferences and also state search handle.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::InitializeSearchContext()
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pPropVals = NULL;
    IUmiPropList *pPropList = NULL;
    LPWSTR pszFilter = NULL;
    LPWSTR *pszAttrNames = NULL;
    DWORD dwAttrCount = (DWORD) -1;
    ULONG ulLangBufSize = 100 * sizeof(WCHAR);
    ULONG ulQueryBufSize = 1024 * sizeof(WCHAR);
    LPWSTR pszLangBuf = NULL;
    LPWSTR pszQueryText = NULL;
    PADS_SORTKEY pSortKey = NULL;

    //
    // We need to walk through the properties in the query and update
    // our local copy of preferences accordingly.
    //
    if (!_pQuery) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = _pQuery->GetInterfacePropList(0, &pPropList);
    BAIL_ON_FAILURE(hr);

    //
    // Need to allocate memory for the buffers.
    //
    pszLangBuf = (LPWSTR) AllocADsMem(ulLangBufSize);
    pszQueryText = (LPWSTR) AllocADsMem(ulQueryBufSize);
    if (!pszLangBuf || !pszQueryText) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    //
    // We need to look at the query language if the language is SQL,
    // then we need to go through and convert the SQL settings to
    // properties on the intfPropList of the query.
    //
    hr = _pQuery->GetQuery(
             &ulLangBufSize,
             pszLangBuf,
             &ulQueryBufSize, // Change this before checking in.
             pszQueryText
             );
    if (hr == E_OUTOFMEMORY ) {
        //
        // Means there was insufficient length in the buffers.
        //
        if (ulLangBufSize > (100 * sizeof(WCHAR))) {
            FreeADsStr(pszLangBuf);
            pszLangBuf = (LPWSTR) AllocADsMem(ulLangBufSize + sizeof(WCHAR));
            if (!pszLangBuf) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        if (ulQueryBufSize > (1024 * sizeof(WCHAR))) {
            FreeADsStr(pszQueryText);
            pszQueryText = (LPWSTR) AllocADsMem(
                ulQueryBufSize + sizeof(WCHAR)
                );
            if (pszQueryText) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        hr = _pQuery->GetQuery(
                 &ulLangBufSize,
                 pszLangBuf,
                 &ulQueryBufSize, // Change this before checking in.
                 pszQueryText
                 );
    }
    BAIL_ON_FAILURE(hr);

    if (*pszLangBuf) {
        if (!_wcsicmp(L"SQL", pszLangBuf)
            || !_wcsicmp(L"WQL", pszLangBuf)
             ) {
            //  
            // This is a sql query and we need to process the query before
            // pulling the options out of the query object.
            //
            hr = ProcessSQLQuery(
                     pszQueryText,
                     &pszFilter,
                     &pSortKey
                     );
            BAIL_ON_FAILURE(hr);

        } 
        else if (!_wcsicmp(L"LDAP", pszLangBuf)) {
            //
            // Neither SQL nor LDAP but the language is set which means
            // we cannot handle this query.
            //
            pszFilter = AllocADsStr(pszQueryText);
            if (!pszFilter) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }
    }

    //
    // At this point we need to go through and pick up all the properties.
    // we know about and update our search preferences accordingly. Each of 
    // these properties has to be set and has to have some valid data.
    //

    //
    // Start with the search scope.
    //
    hr = pPropList->Get(L"__SEARCH_SCOPE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwSearchScope = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the synchronous/asynchronous pref.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ASYNCHRONOUS", 0,  &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fAsynchronous = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the deref aliases search pref.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_DEREF_ALIASES", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._dwDerefAliases = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the size limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_SIZE_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwSizeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the time limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_TIME_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwTimeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the attributes only preference.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ATTRIBTYPES_ONLY", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fAttrsOnly = pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the search scope again ???
    //
    // __PADS_SEARCHPREF_SEARCH_SCOPE (duplicate for consistency cause it should be for all ideally).
    //

    hr = pPropList->Get(L"__PADS_SEARCHPREF_TIMEOUT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwTimeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // The page size is next.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_PAGESIZE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwPageSize = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the paged time limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_PAGED_TIME_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwPagedTimeLimit = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Chase referrals comes next.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_CHASE_REFERRALS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwChaseReferrals = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;
    
    //
    // Get the sort preferences ---> more complex do later.
    //
    // __PADS_SEARCHPREF_SORT_ON ---> potential candidate for all providers.
    //

    //
    // Cache results.
    //
    pPropList->Get(L"__PADS_SEARCHPREF_CACHE_RESULTS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fCacheResults = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // DirSync control --- do later.
    // __PADS_SEARCHPREF_DIRSYNC
    //

    //
    // Tombstone preferences.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_TOMBSTONE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fTombStone = pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Need to get the list of attributes.
    //
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ATTRIBUTES", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    //
    // Need to change to check for NULL then set count to -1.
    //
    pszAttrNames = pPropVals->pPropArray[0].pUmiValue->pszStrValue;
    dwAttrCount = pPropVals->pPropArray[0].uCount;

    //
    // Special case to ask for NULL with 0 to get all attributes.
    //
    if (!dwAttrCount && !pszAttrNames) {
        dwAttrCount = (DWORD) -1;
    }
    //
    // Now that we have all the preferences, we can set the search prefs
    // and also execute the search.
    //
    hr = ADsExecuteSearch(
             _searchPrefs,
             _pszADsPath,
             _pszLdapServer,
             _pszLdapDn,
             pszFilter,
             pszAttrNames,
             dwAttrCount,
             & _hSearchHandle
             );
    BAIL_ON_FAILURE(hr);

    _fSearchExecuted = TRUE;

error:

    if (pPropVals) {
        //
        // Guess we need to use the query to free this !
        //
        _pQuery->FreeMemory(0, (void *)pPropVals);
    }
    
    if (pPropList) {
        pPropList->Release();
    }

    if (pszLangBuf) {
        FreeADsStr(pszLangBuf);
    }

    if (pszQueryText) {
        FreeADsStr(pszQueryText);
    }

    if (pSortKey) {
        if (pSortKey->pszAttrType) {
            FreeADsStr(pSortKey->pszAttrType);
        }
        if (pSortKey->pszReserved) {
            FreeADsStr(pSortKey->pszReserved);
        }

        FreeADsMem(pSortKey);
    }

    if (FAILED(hr)) {
        //
        // Should we really be doing this ?
        //
        LdapInitializeSearchPreferences(&_searchPrefs, FALSE);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::GetNextObject.
//
// Synopsis:   This routine gets the next object in the result set. It calls
//          get next row to get the next row and creates the equivalent
//          cgenobj (need to add code to prepopulate the attributes).
//
// Arguments:  None.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search preferences and also state search handle.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::GetNextObject(IUnknown **pUnk)
{
    HRESULT hr = S_OK;
    ADS_SEARCH_COLUMN adsColumn;
    BSTR ADsPath = NULL;
    LPWSTR pszParent = NULL;
    LPWSTR pszCN = NULL;
    PADSLDP ldapHandle = NULL;
    LDAPMessage *pldapMsg = NULL;

    //
    // Zero init the struct to make sure we can free in error path.
    //
    memset(&adsColumn, 0, sizeof(ADS_SEARCH_COLUMN));


    ADsAssert(_fSearchExecuted);

    if (!_hSearchHandle) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Get the next row.
    //
    hr = ADsGetNextRow(
             _hSearchHandle,
             *_pCreds
             );
    if (hr == S_ADS_NOMORE_ROWS) {
        //
        // Hit end of enumeration.
        //
        *pUnk = NULL;
        RRETURN(S_FALSE);
    } 
    else if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // Fetch the path and use it to create the object.
    //
    hr = ADsGetColumn(
             _hSearchHandle,
             L"ADsPath",
             *_pCreds,
             _dwPort,
             &adsColumn
             );
    BAIL_ON_FAILURE(hr);

    if (adsColumn.dwADsType != ADSTYPE_CASE_IGNORE_STRING
        || adsColumn.dwNumValues != 1) {
        //
        // Bad type or number of return values, this should never happen.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Get the whole ldap message for the current row, that way we can
    // prepopulate the object. Since we are picking up the actual message,
    // we cannot rely on GetNextColumnName to work properly.
    //
    hr = ADsHelperGetCurrentRowMessage(
             _hSearchHandle,
             &ldapHandle, // need this when getting the actual attributes.
             &pldapMsg
             );
    BAIL_ON_FAILURE(hr);

    //
    //
    // For creating the object, the parent path and the rdn is needed.
    //
    hr = BuildADsParentPath(
             adsColumn.pADsValues[0].CaseIgnoreString,
             &pszParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    //
    // Maybe we should just get all the values for this row and
    // send into a constructor for the cgenobj ???
    //
    hr = CLDAPGenObject::CreateGenericObject(
             pszParent,
             pszCN,
             *_pCreds,
             ADS_OBJECT_BOUND,
             ldapHandle,
             pldapMsg,
             _pIID ? (*_pIID) : IID_IUmiObject,
             (void **) pUnk
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszCN) {
        FreeADsStr(pszCN);
    }

    //
    // Calling this can not harm us.
    //
    ADsFreeColumn(&adsColumn);

    if (FAILED(hr) && *pUnk) {
        (*pUnk)->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::ProcessSQLQuery (helper function).
//
// Synopsis:   This routine takes the SQL Query text, parses it using the 
//          wmi query parser and converts the query to preferences on
//          the underlying queryObjects interface proplist.
//
// Arguments:  pszQueryText   -   SQL language query.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Search preferences on the underlying query object.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::ProcessSQLQuery(
    LPCWSTR pszQueryText,
    LPWSTR * ppszFilter,
    PADS_SORTKEY *ppADsSortKey
    )
{
    HRESULT hr = S_OK;
    IWbemQuery *pQuery = NULL;
    ULONG ulFeatures[] = {
        WMIQ_LF1_BASIC_SELECT,
        WMIQ_LF2_CLASS_NAME_IN_QUERY,
        WMIQ_LF6_ORDER_BY,
        WMIQ_LF24_UMI_EXTENSIONS
    };
    SWbemRpnEncodedQuery *pRpn = NULL;
    LPWSTR *pszAttribArray = NULL;
    DWORD dwAttribCount = 0;
    LPWSTR pszFromListFilter = NULL;
    LPWSTR pszFilter = NULL;
    IUmiPropList *pIntfPropList = NULL;
    UMI_PROPERTY umiPropAttribs = {
        UMI_TYPE_LPWSTR,
        1,
        UMI_OPERATION_UPDATE,
        L"__PADS_SEARCHPREF_ATTRIBUTES",
        NULL
    };
    //
    // Will likely need to set the attribute list.
    //
    UMI_PROPERTY pOneUmiProp[1];
     
    pOneUmiProp[0] = umiPropAttribs;

    UMI_PROPERTY_VALUES propUmiVals[1];
    propUmiVals[0].uCount = 1;
    propUmiVals[0].pPropArray = pOneUmiProp;

    ADsAssert(ppszFilter);
    *ppszFilter = NULL;

    //
    // Create the WBEM parser object.
    //
    hr = CoCreateInstance(
             CLSID_WbemQuery,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IWbemQuery,
             (LPVOID *) &pQuery
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set the query into the parser and try and parse the query.
    //
    hr = pQuery->SetLanguageFeatures(
             0,
             sizeof(ulFeatures)/sizeof(ULONG),
             ulFeatures
             );
    BAIL_ON_FAILURE(hr);

    hr = pQuery->Parse(L"SQL", pszQueryText, 0);
    BAIL_ON_FAILURE(hr);

    hr = pQuery->GetAnalysis(
             WMIQ_ANALYSIS_RPN_SEQUENCE,
             0,
             (LPVOID *) &pRpn
             );
    BAIL_ON_FAILURE(hr);

    if (!pRpn->m_uSelectListSize) {
        //
        // Sanity check to make sure we are selecting something.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = HelperGetAttributeList(
             &dwAttribCount,
             &pszAttribArray,
             pRpn->m_uSelectListSize,
             pRpn->m_ppSelectList
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // As of now the from list cannot have anything in other than *.
    //
    hr = HelperGetFromList(
             &pszFromListFilter,
             pRpn
             );
    BAIL_ON_FAILURE(hr);

    hr = HelperGetFilterFromWhereClause(
             &pszFilter,
             pRpn->m_uWhereClauseSize,
             pRpn->m_ppRpnWhereClause
             );
    BAIL_ON_FAILURE(hr);

    //
    // See if we have an order by list, in SQL we support only one
    // order by clause.
    //
    if (pRpn->m_uOrderByListSize) {
        hr = HelperGetSortKey(pRpn, ppADsSortKey);
        BAIL_ON_FAILURE(hr);
    }
    //
    // Need to set the attribute list if applicable.
    //
    if ((dwAttribCount != (DWORD) -1)
        && dwAttribCount) {
        //
        // Need to set the property on the interface proplist.
        //
        hr = _pQuery->GetInterfacePropList(
                 0,
                 &pIntfPropList
                 );
        BAIL_ON_FAILURE(hr);

        pOneUmiProp[0].uCount = dwAttribCount;
        pOneUmiProp[0].pUmiValue = (PUMI_VALUE) (LPVOID) pszAttribArray;

        hr = pIntfPropList->Put(
                 L"__PADS_SEARCHPREF_ATTRIBUTES",
                 0,
                 propUmiVals
                 );
        BAIL_ON_FAILURE(hr);

    }
    //
    // Need to return the filter back.
    //
    *ppszFilter = pszFilter;

error:

    if (pQuery) {
        pQuery->Release();
    }

    if (pszFromListFilter) {
        FreeADsStr(pszFromListFilter);
    }
    
    if (pIntfPropList) {
        pIntfPropList->Release();
    }

    //
    // We might need to return this as a param.
    //
    if (FAILED(hr) && pszFilter) {
        FreeADsStr(pszFilter);
    }

    RRETURN(hr);
}

//****************************************************************************
//                      CQueryStack Implementation                           *
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   CQueryStack::CQueryStack - Constructor.
//
// Synopsis:   Initializes the underlying list to NULL and count to 0.
//
// Arguments:  None.
//
// Returns:    N/A.
//
// Modifies:   All member variables.
//
//----------------------------------------------------------------------------
CQueryStack::CQueryStack():
    _pStackList(NULL),
    _dwElementCount(0)
{
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::~CQueryStack - Destructor.
//
// Synopsis:   Frees the underlying list contents if applicable.
//
// Arguments:  None.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CQueryStack::~CQueryStack()
{
    if (_pStackList) {
        STACKLIST *pList = _pStackList;
        STACKLIST *pPrev = NULL;
        //
        // Walk through and free the list.
        //
        while (pList) {
            pPrev = pList;
            pList = pList->pNext;
            //
            // Need to free prev node and its contents.
            //
            CQueryStack::FreeStackEntry(pPrev);
        }
        _pStackList = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::Push.
//
// Synopsis:   Pushes the node onto the stack and increases the count. The
//          node is added to the head of the underlying list. 
//
// Arguments:  pszString    -   The string value of the node.
//             dwType       -   The type of the node can either be 
//                           a literal or an operator.
//
// Returns:    S_OK or E_OUTOFMEMORY.
//
// Modifies:   The underlying list.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::Push(
    LPWSTR pszString,
    DWORD  dwType
    )
{
    HRESULT hr = S_OK;
    PSTACKLIST pStackEntry = NULL;

    //
    // Allocate the new node.
    //
    hr = CQueryStack::AllocateStackEntry(
             pszString,
             dwType,
             &pStackEntry
             );
    if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // If the list is not already then it is added to the head.
    //
    if (!this->_pStackList) {
        _pStackList = pStackEntry;
    } 
    else {
        //
        // Add new entry to the head of the list.
        //
        pStackEntry->pNext = _pStackList;
        _pStackList = pStackEntry;
    }

    //
    // Increment count as the add to list was successful.
    //
    _dwElementCount++;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::Pop.
//
// Synopsis:   Removes node node from the stack and returns the contents. 
//          Node is removed from the head of the underlying list. 
//
// Arguments:  ppszString   -   Return ptr for string value of node.
//             dwType       -   Return ptr for the type of the node.
//
// Returns:    S_OK, E_OUTOFMEMORY or E_FAIL.
//
// Modifies:   The underlying list.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::Pop(
    LPWSTR *ppszString,
    DWORD  *pdwType
    )
{
    HRESULT hr = S_OK;
    PSTACKLIST pStackEntry = _pStackList;

    if (!pStackEntry
        || !ppszString
        || !pdwType ) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Initialize the return values.
    //
    *ppszString = NULL;
    *pdwType = (DWORD) -1;

    if (pStackEntry->pszElement) {
        *ppszString = AllocADsStr(pStackEntry->pszElement);
        if (!*ppszString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        *pdwType = pStackEntry->dwElementType;
    } 
    else {
        //
        // Should never get here.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Need to advance the list to the next node and free the
    // contents of the current node.
    //
    _pStackList = _pStackList->pNext;
    CQueryStack::FreeStackEntry(pStackEntry);

    //
    // Decrement count as the remove from list was successful.
    //
    _dwElementCount--;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::IsEmpty.
//
// Synopsis:   Returns TRUE or FALSE based on the contents of the stack.
//
// Arguments:  N/A.
//
// Returns:    TRUE or FALSE.
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
BOOL
CQueryStack::IsEmpty()
{
    return (_dwElementCount == 0);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::AllocateStackEntry - static helper routine.
//
// Synopsis:   Allocates a stack node with the specified contents.
//
// Arguments:  pszString    -   The string value of the node.
//             dwType       -   The type of the node can either be 
//                           a literal or an operator.
//             ppStackEntry -   Return value.
//
// Returns:    S_OK, E_OUTOFMEMORY or E_FAIL.
//
// Modifies:   ppStackEntry.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::AllocateStackEntry(
    LPWSTR pszString,
    DWORD  dwType,
    STACKLIST **ppStackEntry
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpString = NULL;

    if (!pszString || !dwType) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppStackEntry = NULL;

    pszTmpString = AllocADsStr(pszString);
    if (!pszString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Allocate the new stack node.
    //
    *ppStackEntry = (PSTACKLIST) AllocADsMem(sizeof(STACKLIST));
    if (!*ppStackEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppStackEntry)->pszElement = pszTmpString;
    (*ppStackEntry)->dwElementType = dwType;
    
error:

   if (FAILED(hr) && pszTmpString) {
       FreeADsStr(pszTmpString);
   }

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::FreeStackEntry - static helper routine.
//
// Synopsis:   Frees contents of the stack node and the node itself.
//
// Arguments:  pStackEntry    -   Pointer to stack node to free.
//
// Returns:    N/A.
//
// Modifies:   pStackEntry and contents.
//
//----------------------------------------------------------------------------
void
CQueryStack::FreeStackEntry(
    PSTACKLIST pStackEntry
    )
{
    if (!pStackEntry) {
        return;
    }

    //
    // Free the string if there is one and then the node.
    //
    if (pStackEntry->pszElement) {
        FreeADsStr(pStackEntry->pszElement);
    }
    FreeADsMem(pStackEntry);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cumiobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiobj.cxx
//
//  Contents: Contains the implementation of IUmiObject/Container methods.
//            Methods are encapsulated in one object but this object holds
//            a pointer to the inner unknown of the corresponding LDAP 
//            object. The methods of IUmiContainer are also implemented on
//            this object, but will only be used if the underlying object
//            is a container. 
//
//  History:  03-06-00    SivaramR  Created.
//            04-07-00    AjayR modified for LDAP Provider.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CLDAPUmiObject
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPUmiObject::CLDAPUmiObject():
    _pPropMgr(NULL),
    _pIntfPropMgr(NULL),
    _pUnkInner(NULL),
    _pIADs(NULL),
    _pIADsContainer(NULL),
    _ulErrorStatus(0),
    _pCoreObj(NULL),
    _pExtMgr(NULL),
    _fOuterUnkSet(FALSE)
{
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::~CLDAPUmiObject
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPUmiObject::~CLDAPUmiObject(void)
{
    if (_pIntfPropMgr) {
        delete _pIntfPropMgr;
    }

    if (_pPropMgr) {
        delete _pPropMgr;
    }

    if (_pUnkInner) {
        _pUnkInner->Release();
    }

    if (_pIADsContainer) {
        _pIADsContainer->Release();
    }

    if (_pIADs) {
        _pIADs->Release();
    }

    //
    // We specifically do not release these as they are all just ptrs
    // _pCreds, _pszLDAPServer, _pszLDAPDn, _pLdapHandle.
    //
    
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::AllocateLDAPUmiObject --- Static constructor.
//
// Synopsis:   Static contstructor routine.
//
// Arguments:  intfPropTable- Schema information for interface properties.
//             pPropCache   - Pointer to property cache (shared with IADs).
//             pUnkInner    - Pointer to inner unknown of underlying obj.
//             pExtMgr      - Pointer to extension manager of object.
//             pCoreObj     - Pointer to the core object of underlying object.
//             ppUmiObj     - Return value.
//
// Returns:   S_OK on success. Error code otherwise. 
//
// Modifies:  *ppUmObj to point to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::CreateLDAPUmiObject(
    INTF_PROP_DATA intfPropTable[],
    CPropertyCache *pPropertyCache,
    IUnknown *pUnkInner,
    CCoreADsObject *pCoreObj,
    IADs *pIADs,
    CCredentials *pCreds,
    CLDAPUmiObject **ppUmiObj,
    DWORD dwPort, // defaulted to -1
    PADSLDP pLdapHandle,  // defaulted to NULL
    LPWSTR pszServerName,  // defaulted to NULL
    LPWSTR pszLDAPDn,  // defaulted to NULL
    CADsExtMgr *pExtMgr  // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPUmiObject *pUmiObject = NULL;
    CPropertyManager *pPropMgr = NULL;
    CPropertyManager *pIntfPropMgr = NULL;

    //
    // This always has to be there, the extension manager will not 
    // be there for RootDSE and schema realted objects.
    //
    ADsAssert(pCoreObj);

    pUmiObject = new CLDAPUmiObject();
    
    if (!pUmiObject) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Property cache is not supported on the schema container object alone.
    // There will be no support for the propList methods for this object.
    //
    if (pPropertyCache) {
        //
        // Has to be valid if we have a property cache.
        //
        ADsAssert(pUnkInner);

        //
        // Need the standard property manager for Get/Put support.
        //
        hr = CPropertyManager::CreatePropertyManager(
                 pIADs,
                 (IUmiObject *) pUmiObject,
                 pPropertyCache,
                 pCreds,
                 pszServerName,
                 &pPropMgr
                 );

        BAIL_ON_FAILURE(hr);
    }

    if (intfPropTable) {
        hr = CPropertyManager::CreatePropertyManager(
                 (IUmiObject *) pUmiObject,
                 pUnkInner, // should support IADs.
                 pCreds,
                 intfPropTable,
                 &pIntfPropMgr
                 );
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // At this point failures are not catastrophic so we can prepare
    // the object for return.
    //
    pUmiObject->_pUnkInner = pUnkInner;
    pUmiObject->_pIADs = pIADs;
    pUmiObject->_pExtMgr = pExtMgr;
    pUmiObject->_pCoreObj = pCoreObj;
    pUmiObject->_pCreds = pCreds;
    pUmiObject->_pPropMgr = pPropMgr;
    pUmiObject->_pIntfPropMgr = pIntfPropMgr;
    pUmiObject->_pszLDAPServer = pszServerName;
    pUmiObject->_pszLDAPDn = pszLDAPDn;
    pUmiObject->_pLdapHandle = pLdapHandle;
    pUmiObject->_dwPort = dwPort;

    //
    // Addref cause we release this in the destructor.
    //
    pIADs->AddRef();

    //
    // Get IADsContainer ptr if applicable - can ignore failures.
    //
    hr = pUnkInner->QueryInterface(
             IID_IADsContainer,
             (void **) &(pUmiObject->_pIADsContainer)
             );

    *ppUmiObj = pUmiObject;

    RRETURN(S_OK);

error:

    if (pUmiObject) {
        delete pUmiObject;
    }
    
    if (pPropMgr) {
        delete pPropMgr;
    }

    if (pIntfPropMgr) {
        delete pIntfPropMgr;
    }
        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::QueryInterface --- IUnknown support.
//
// Synopsis:   Standard query interface method.
//
// Arguments:  iid           -  Interface requested.
//             ppInterface   -  Return pointer to interface requested. 
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pTmpIntfPtr = NULL;

    SetLastStatus(0);

    if (!ppInterface) {
        RRETURN(E_INVALIDARG); 
    }

    *ppInterface = NULL;

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IUmiObject *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiObject)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiContainer)) {
        //
        // Check if underlying LDAP object is a container.
        //
        if (_pIADsContainer != NULL) {
            *ppInterface = (IUmiContainer *) this;
        }
        else {
            RRETURN(E_NOINTERFACE);
        }
    }
    else if (IsEqualIID(iid, IID_IUmiCustomInterfaceFactory)) {
        *ppInterface = (IUmiCustomInterfaceFactory *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjOptPrivate)) {
        if (_pLdapHandle) {
            *ppInterface = (IADsObjOptPrivate*) this;
        } 
        else {
            RRETURN(E_NOINTERFACE);
        }
    } 
    else {
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);
}
        
//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Clone --- IUmiObject support.
//
// Synopsis:   Clones this object. Note that this will do an implicit
//          refresh if one has not already been done on the object before
//          copying all the attributes. The new object has a state that a 
//          bound state (rather than unbound).
//
// Arguments:  uFlags     ---  Must be 0 for now.
//             riid       ---  IID requested on the clone.
//             pCopy      ---  The return ptr for the cloned object.
//
// Returns:    S_OK or appropriate error code. 
//
// Modifies:   pCopy to be updated with new UmiObject ptr on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Clone(
    ULONG uFlags,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT hr = S_OK;
    CCredentials Creds;
    BSTR bstrPath = NULL;
    BSTR bstrClass = NULL;
    LPWSTR pszParent = NULL, pszCommonName = NULL;
    IUmiObject *pUmiObj = NULL;
    IUmiObject *pDestUmiObj = NULL;
    DWORD dwAuthFlags = 0;

    SetLastStatus(0);

    //
    // We cannot clone objects that do not have an underlying IADs ptr.
    //
    if (!_pIADs) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_pCreds) {
        Creds = *_pCreds;
    }

    //
    // Need to tag on the ADS_FAST_BIND to prevent the call from 
    // going on the wire.
    //
    dwAuthFlags = Creds.GetAuthFlags();
    Creds.SetAuthFlags(dwAuthFlags | ADS_FAST_BIND);

    //
    // Need to call Refresh with the internal flag. Note that using this
    // flag means that we will go on the wire only if we have to.
    //
    hr = this->Refresh(
             ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED,
             NULL,
             NULL
             );
    BAIL_ON_FAILURE(hr);

    //
    // Next we need to get the destination object.
    //
    hr = _pIADs->get_ADsPath(&bstrPath);
    BAIL_ON_FAILURE(hr);

    if (_pCoreObj->GetObjectState() == ADS_OBJECT_UNBOUND) {
        //
        // In this case we need to Create the target object.
        // The parent path, the common name and the class are needed.
        //
        hr = BuildADsParentPath(
                 bstrPath,
                 &pszParent,
                 &pszCommonName
                 );
        BAIL_ON_FAILURE(hr);

        hr = _pIADs->get_Class(&bstrClass);
        BAIL_ON_FAILURE(hr);

        hr = CLDAPGenObject::CreateGenericObject(
                 pszParent,
                 pszCommonName,
                 bstrClass,
                 Creds,
                 ADS_OBJECT_UNBOUND,
                 riid, // this is ignored
                 (void **) &pUmiObj
                 );
        BAIL_ON_FAILURE(hr);
    } 
    else {
        // 
        // In this case we bind to the object.
        //
        hr = GetObject(bstrPath, Creds, (void **)&pUmiObj);
        BAIL_ON_FAILURE(hr);
    }

    pUmiObj->QueryInterface(IID_IUmiObject, (void **) &pDestUmiObj);
    BAIL_ON_FAILURE(hr);

    //
    // Now we can call the helper to copy the attributes over.
    //
    hr = this->CopyToHelper(
             (IUmiObject*) this,
             pDestUmiObj,
             0,
             FALSE, // do not mark as update
             FALSE // do not copy intf props
             );
    BAIL_ON_FAILURE(hr);

    //
    // Update return value as this means copy was succesful.
    //
    *pCopy = pDestUmiObj;

error:

    if (FAILED(hr)) {
        if (!_ulErrorStatus) {
            SetLastStatus(hr);
        }
        hr = MapHrToUmiError(hr);

        if (pDestUmiObj) {
            pDestUmiObj->Release();
        }
    }

    if (bstrPath) {
        SysFreeString(bstrPath);
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }
    
    if (pszParent) {
        FreeADsStr(pszParent);
    }
    
    if (pszCommonName) {
        FreeADsStr(pszCommonName);
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CopyTo --- IUmiObject support.
//
// Synopsis:   Copies the object to the new destination.Note that this will
//          do an implicit refresh if one has not already been done on the 
//          object before copying all the attributes. The new objecst state
//          is unbound, and the new object will be created on the destination
//          directory only when Commit is called. If any of the properties on
//          the object being copied are marked as updated/dirty then the call
//          will fail.
//
// Arguments:  uFlags     ---  Must be 0 for now.
//             pURL       ---  Url pointing to the destination.
//             riid       ---  IID requested on the clone.
//             pCopy      ---  The return ptr for the copied object.
//
// Returns:    S_OK or appropriate error code. 
//
// Modifies:   pCopy to be updated with new UmiObject ptr on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::CopyTo(
    IN  ULONG uFlags,
    IN  IUmiURL *pURL,
    IN  REFIID riid,
    OUT LPVOID *pCopy
    )
{
    HRESULT hr = S_OK;
    CCredentials Creds;
    BSTR bstrClass = NULL;
    LPWSTR pszLdapPath = NULL;
    LPWSTR pszParent = NULL, pszCommonName = NULL;
    IUmiObject *pUmiObj = NULL;
    IUmiObject *pUmiDestObj = NULL;
    DWORD dwAuthFlags = 0;

    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
    //*******************************************************/
    // This code is not used currently.                      /
    //*******************************************************/

    //
    // Has to be 0.
    //
    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // All these need to be valid.
    //
    if (!pURL
        || !pCopy
        || (riid != IID_IUmiObject)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // We cannot copy objects that do not have an underlying IADs ptr.
    //
    if (!_pIADs) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_pCreds) {
        Creds = *_pCreds;
    }

    //
    // Need to call Refresh with the internal flag. Note that using this
    // flag means that we will go on the wire only if we have to.
    //
    hr = this->Refresh(
             ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED,
             NULL,
             NULL
             );
    BAIL_ON_FAILURE(hr);

    hr = _pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    //
    // Now we need to convert the UmiPath to LDAPPath that we can use.
    //
    hr = UrlToLDAPPath(
             pURL,
             &pszLdapPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // We need to split path to parent and common name.
    //
    hr = BuildADsParentPath(
             pszLdapPath,
             &pszParent,
             &pszCommonName
             );
    BAIL_ON_FAILURE(hr);

    hr = CLDAPGenObject::CreateGenericObject(
             pszParent,
             pszCommonName,
             bstrClass,
             Creds,
             ADS_OBJECT_UNBOUND,
             riid, // this is ignored
             (void **) &pUmiObj
             );
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, (void **) &pUmiDestObj);
    BAIL_ON_FAILURE(hr);

    //
    // Need to copy the attributes over now.
    //
    hr = this->CopyToHelper(
             this,
             pUmiDestObj,
             0,
             TRUE, // means fail call if property status is not 0
             FALSE // do not copy intf props.
             );
    BAIL_ON_FAILURE(hr);

    *pCopy = pUmiDestObj;

error:

    if (pszLdapPath) {
        FreeADsStr(pszLdapPath);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszCommonName) {
        FreeADsStr(pszCommonName);
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }

    if (FAILED(hr)) {
        if (!this->_ulErrorStatus) {
            SetLastError(hr);
        }

        if (pUmiDestObj) {
            pUmiDestObj->Release();
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Refresh --- IUmiObject support.
//
// Synopsis:   Refreshes the properties of the object. This calls the
//          underlying LDAP object for the operation.
//
// Arguments:  uFlags      -  UMI_FLAGS_REFERESH_ALL, PARTIAL supported
//                           and ADSI internal flag to implicit GetInfo only
//                           if one is needed (helps clone and copyto).
//             uNameCount  -  Number of attributes to refresh.
//             pszNames    -  Names of attributes to refresh.
//
// Returns:    S_OK on success. Error code otherwise
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT CLDAPUmiObject::Refresh(
    ULONG uFlags,
    ULONG uNameCount,
    LPWSTR *pszNames
    )
{
    ULONG   i = 0;
    HRESULT hr = S_OK;
    BOOL fUseGetInfoEx = FALSE;
    DWORD dwGetInfoFlag = TRUE;

    SetLastStatus(0);

    //
    // Only all and partial and the special internal flag. Refresh
    // partial translates to an implicit getinfo in ADSI.
    //
    if ((uFlags != UMI_FLAG_REFRESH_ALL)
        && (uFlags != UMI_FLAG_REFRESH_PARTIAL)
        && (uFlags != ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED)
        ) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (uFlags == UMI_FLAG_REFRESH_PARTIAL) {
        //
        // Cannot specify list of names in this case.
        //
        if (uNameCount != 0) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_OPERATION);
        }
        dwGetInfoFlag = GETINFO_FLAG_IMPLICIT;
    } 
    else if (uFlags == ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED) {
        dwGetInfoFlag = GETINFO_FLAG_IMPLICIT_AS_NEEDED;
    }

    if ((uFlags == UMI_FLAG_REFRESH_ALL) && (uNameCount != 0)) {
        fUseGetInfoEx = TRUE;
    }

    if (fUseGetInfoEx) {
        //
        // Build the variant array of strings.
        //
        VARIANT vVar;
        VariantInit(&vVar);

        //
        // Builds a variant array we can use in GetInfoEx
        //
        hr = ADsBuildVarArrayStr(
                 pszNames,
                 (DWORD)uNameCount,
                 &vVar);
        BAIL_ON_FAILURE(hr);

        //
        // Call GetInfoEx to do the actual work.
        //
        hr = _pIADs->GetInfoEx(vVar, 0);
        VariantClear(&vVar);
    } 
    else {
        hr = this->_pCoreObj->GetInfo(dwGetInfoFlag);
        //
        // Since schema and few others do not implement the implicit GetInfo.
        //
        if (FAILED(hr) && hr == E_NOTIMPL) {
            //
            // Should try just an ordinary GetInfo if applicable.
            //
            if (dwGetInfoFlag == GETINFO_FLAG_EXPLICIT) {
                hr = _pIADs->GetInfo();
            }
        }
    }

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Commit --- IUmiObject support.
//
// Synopsis:   Implements IUmiObject::Commit. Calls SetInfo on WinNT
//             object to commit changes made to the cache. 
//
// Arguments:  uFlags      -   Only 0 for now.
//
// Returns:    S_OK on success. Error code otherwise
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Commit(ULONG uFlags)
{
    HRESULT hr = S_OK;
    IADsObjOptPrivate *pPrivOpt = NULL;
    DWORD dwFlags;

    SetLastStatus(0);

    if (uFlags > UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) {
        SetLastStatus(UMI_E_INVALID_FLAGS);
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    //
    // If this is set do not commit security descriptor.
    //
    if (uFlags & UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) {
        //
        // The prop manager has to do this cause it has the prop cache.
        //
        hr = _pPropMgr->DeleteSDIfPresent();
        BAIL_ON_FAILURE(hr);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        //
        // Need to make sure that we update the SD 
        // flags on the ADSI object if necessary.
        //
        if (!_pIADs) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        
        hr = _pIADs->QueryInterface(
                 IID_IADsObjOptPrivate,
                 (void **)&pPrivOpt
                 );
        BAIL_ON_FAILURE(hr);

        dwFlags = uFlags & UMI_SECURITY_MASK;

        hr = pPrivOpt->SetOption(
                 LDAP_SECURITY_MASK,
                 (void *) &dwFlags
                 );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pIADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }

    RRETURN(hr);
}   

//+---------------------------------------------------------------------------
// IUmiPropList methods
//
// These are implemented by invoking the corresponding method in the
// CUmiPropList object that implements object properties. For a description
// of these methods, refer to cpropmgr.cxx
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Put(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Put(
             pszName,
             uFlags,
             pProp
             );

    if (FAILED(hr)) {
        IID iid;
        //
        // Need to update the error status on this object.
        //
        _pPropMgr->GetLastStatus(  // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            ); 
           
         SetLastStatus(ulStatus);
    }
 
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Get(
             pszName,
             uFlags,
             ppProp
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus(
             0,
             &ulStatus,
             iid,
             NULL
             );

        SetLastStatus(ulStatus);
    }

    //
    // No need to map the error as the property manager would have
    // already done that for us.
    //
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetAs(
             pszName,
             uFlags,
             uCoercionType,
             ppProp
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    //
    // No need to map hr as property manager would have already done that.
    //
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = S_OK;

    if (uReserved) {
        SetLastStatus(E_INVALIDARG);
        RRETURN(E_INVALIDARG);
    }

    hr = FreeUmiPropertyValues((PUMI_PROPERTY_VALUES) pMem);

    SetLastStatus(hr);
    
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem 
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetAt(
             pszName,
             uFlags,
             uBufferLength,
             pExistingMem
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

         SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetProps(
             pszNames,
             uNameCount,
             uFlags,
             pProps
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

         SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->PutProps(
             pszNames,
             uNameCount,
             uFlags,
             pProps
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus(
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

HRESULT CLDAPUmiObject::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->PutFrom(
             pszName,
             uFlags,
             uBufferLength,
             pExistingMem
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;

        _pPropMgr->GetLastStatus(
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Delete(
             pszName,
             uFlags
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetLastStatus --- IUmiBaseObject support.
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments: uFlags           -  Reserved. Must be 0 for now.
//            puSpecificStatus -  Returns status code.
//            riid             -  IID requested. Ignored currently.
//            pStatusObj       -  Returns interface requested.
//                                Always returns NULL currently.
//
// Returns:   S_OK on success. Error code otherwise.
//
// Modifies:  *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (pStatusObj) {
        *pStatusObj = NULL;
    }

    if (puSpecificStatus) {
        *puSpecificStatus = 0;
    } 
    else {
        RRETURN(E_INVALIDARG);
    }

    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    *puSpecificStatus = _ulErrorStatus;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetInterfacePropList --- IUmiBaseObject method.
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:  uFlags     -  Reserved. Must be 0 for now.
//             pPropList  -  Returns pointer to IUmiPropertyList interface
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = S_OK;

    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (!pPropList) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    ADsAssert(_pIntfPropMgr);

    //
    // The refCounts are tricky here. When this operation is done,
    // the ref on this object goes up by one, so you will need to
    // releaserefs on the proplist in order to delete this object.
    // This is to prevent the case of a proplist existing without
    // the underlying object (ok for WinNT not for LDAP).
    //
    hr = _pIntfPropMgr->QueryInterface(IID_IUmiPropList, (void **) pPropList);
    
error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::SetLastStatus --- Internal helper routine.
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus     -   Status to be set
//
// Returns:    N/A.
//
// Modifies:   ulStatus member variable.
//
//----------------------------------------------------------------------------
void 
CLDAPUmiObject::SetLastStatus(ULONG ulStatus)
{
    _ulErrorStatus = ulStatus;

    return;
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Open --- IUmiContainer support.
//
// Synopsis:   Opens the object specified by a URL. URL may be native LDAP
//             path or any UMI path.
//
// Arguments:  pURL        -  Pointer to an IUmiURL interface
//             uFlags      -  Reserved. Must be 0 for now.
//             TargetIID   -  Interface requested.
//             ppInterface -  Returns pointer to interface requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT hr;
    LONG lGenus = UMI_GENUS_INSTANCE;
    LPWSTR pszDN = NULL, pszClass = NULL;
    IDispatch *pDispObj = NULL;

    SetLastStatus(0);
    //
    // Get the class name and the dn from the url.
    //
    if (!pURL || !ppInterface) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // Helper will split the url txt to useful pieces.
    //
    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    //
    // At this point if this is a class instance == schema class object,
    // then if the dn is of the format name="something", we should just
    // pass in "something" to the IADsContainer::Open call.
    //
    if (pszClass
        && *pszClass
        && !_wcsicmp(pszClass, L"Class")) {
        //
        // Want to see if this is a class instance.
        //
        if (_pIntfPropMgr) {
            hr = _pIntfPropMgr->GetLongProperty(L"__GENUS", &lGenus);
            if (FAILED(hr)) {
                //
                // We will assume that this is not a class in this case.
                //
                hr = S_OK;
                lGenus = UMI_GENUS_INSTANCE;
            }
        }

        if (pszDN // should always be true
            && lGenus == UMI_GENUS_CLASS
            ) {
            if (!_wcsnicmp(pszDN, L"name=", 5)) {
                //
                // Copy over the new name and replace pszDN with
                // the new name.
                //
                LPWSTR pszReplace;
                pszReplace = AllocADsStr(pszDN + 5);
                
                if (!pszReplace) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                if (pszDN) {
                    FreeADsStr(pszDN);
                }
                
                pszDN = pszReplace;
            }
        }

    }
    
    //
    // Call the IADSContaienr::GetObject to do the remaining work.
    //
    hr = _pIADsContainer->GetObject(pszClass, pszDN, &pDispObj);
    BAIL_ON_FAILURE(hr);

    if (pszClass && *pszClass) {
        //
        // We need to compare the name cause, the GetObject code cannot
        // do that for umi calls.
        //
        hr = VerifyIfClassMatches(
                 pszClass,
                 pDispObj,
                 lGenus
                 );
        BAIL_ON_FAILURE(hr);
    }
             
    hr = pDispObj->QueryInterface(TargetIID, ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    if (pDispObj) {
        pDispObj->Release();
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}         
    

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Put --- IUmiContainer support.
//
// Synopsis:   Commits an object into the container. Not implemented. 
//
// Arguments:  uFlags       -   Reserved. Must be 0 for now.
//             TargetIID    -   IID of interface pointer requesed.
//             pInterface   -   Output interface pointer.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::PutObject(
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  pInterface
    )   
{
    SetLastStatus(E_NOTIMPL);

    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::DeleteObject --- IUmiContainer support.
//
// Synopsis:   Deletes the object specified by the URL. This calls the
//          underlying container object to do the delete after preparing
//          the arguments suitably. Note that if no class name is specified
//          we will pass in NULL to the IADsContainer::Delete call.
//
// Arguments:  pURL       -   Pointer to URL of object to delete (relative).
//             uFlags     -   Reserved. Must be 0 for now.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   N/A. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::DeleteObject(
    IUmiURL *pURL,
    ULONG   uFlags
    )
{
    HRESULT hr;
    LPWSTR pszClass = NULL, pszDN = NULL;

    if (!pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }
    
    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    //
    // Call the IADsContainer::Delete entry point to do the work.
    //
    hr = _pIADsContainer->Delete(pszClass, pszDN);

error:

    if (pszClass) {
        FreeADsStr(pszClass);
    }
    
    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Create --- IUmiContainer support.
//
// Synopsis:   Creates the object specified by the URL. There always has
//          to be a className for this operation to succeed. The newly
//          created object is not yet on the directory, just local (need
//          to call Commit to create it on the directory).
//
// Arguments:  pURL        -   Pointer to URL of new object (relative).
//             uFlags      -   Reserved. Must be 0 for now.
//             ppNewObj    -   Return ptr for newly created object.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pNewObject to return the IUmiObject interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Create(
    IUmiURL *pURL,
    ULONG   uFlags,
    IUmiObject **ppNewObj
    )
{
    HRESULT hr;
    LPWSTR pszClass = NULL, pszDN = NULL;
    IDispatch *pDispObj = NULL;

    if (!pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    hr = _pIADsContainer->Create(pszClass, pszDN, &pDispObj);
    BAIL_ON_FAILURE(hr);

    hr = ((IUnknown *)pDispObj)->QueryInterface(
               IID_IUmiObject,
               (void **) ppNewObj
               );

error:

    if (pDispObj) {
        pDispObj->Release();
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Move --- IUmiContainer support.
//
// Synopsis:   Moves a specified object into the container.
//
// Arguments: uFlags      -  Reserved. Must be 0 for now.
//           pOldURL      -  URL of the object to be moved.
//           pNewURL      -  New URL of the object within the container. 
//                           If NULL, then no name change is needed.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   N/A. 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Move(
    ULONG   uFlags,
    IUmiURL *pOldURL,
    IUmiURL *pNewURL
    )
{
    HRESULT hr;
    LPWSTR pszOldPath = NULL, pszNewPath = NULL, pszClass = NULL;
    ULONGLONG ullPathType = 0;
    IDispatch *pDispObj = NULL;

    if (!_pIADsContainer) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    if (!pOldURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // What flags should we support here ?
    //
    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = UrlToLDAPPath(
             pOldURL,
             &pszOldPath
             );
    BAIL_ON_FAILURE(hr);

    if (pNewURL) {
        //
        // Update code based on the path type.
        // 
        hr = pNewURL->GetPathInfo(0, &ullPathType);
        BAIL_ON_FAILURE(hr);

        if (ullPathType == UMIPATH_INFO_RELATIVE_PATH) {
            hr = UrlToClassAndDn(
                     pNewURL,
                     &pszClass,
                     &pszNewPath
                     );
            BAIL_ON_FAILURE(hr);
        } 
        else {
            //
            // Does this even make sense on a move ???
            //
            hr = UrlToLDAPPath(
                     pNewURL,
                     &pszNewPath
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // At this point both the new and old path will be set correctly.
    //
    hr = _pIADsContainer->MoveHere(
             pszOldPath,
             pszNewPath,
             &pDispObj
             );
    BAIL_ON_FAILURE(hr);


error:
    
    if (pszOldPath) {
        FreeADsStr(pszOldPath);
    }

    if (pszNewPath) {
        FreeADsStr(pszNewPath);
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pDispObj) {
        pDispObj->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CreateEnum --- IUmiContainer support.
//
// Synopsis:   Creates an enumerator within a container. The enumerator is
//          an IUmiCursor interface pointer. The caller can optionally set
//          a filter on the cursor and then enumerate the contents of the
//          container. The actual enumeration of the container does
//          not happen in this function. It is deferred to the point
//          when the cursor is used to enumerate the results.
//
// Arguments:  pszEnumContext   -   Not used. Must be NULL.
//             uFlags           -   Reserved. Must be 0 for now.
//             TargetIID        -   Interface requested on enum has to be
//                                 IUmiCursor for now.
//             ppInterface      -   Return value for new enurator.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return the IUmiCursor interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::CreateEnum(
    IUmiURL *pszEnumContext,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT hr;

    SetLastStatus(0);
    //
    // Validate args.
    //
    if (pszEnumContext || uFlags) {
        //
        // We do not support contexts currently.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (!(TargetIID == IID_IUmiCursor)) {
        //
        // Type of cursor we do not support.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    hr = CUmiCursor::CreateCursor(
             _pIADsContainer,
             TargetIID,
             ppInterface
             );
    
error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::ExecQuery --- IUmiContainer support.
//
// Synopsis:   Executes a query on this container. 
//             
// Arguments:  pQuery      -   Pointer to the query to execute.
//             uFlags      -   Reserved. Must be 0 for now.
//             TargetIID   -   Interface requested.
//             ppInterface -   Return value for the cursor requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::ExecQuery(
    IUmiQuery *pQuery,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppResult
    )
{
    HRESULT hr = S_OK;
    CLDAPConObject *pConnection = NULL;
    BSTR bstrADsPath = NULL;

    SetLastStatus(0);

    if (!ppResult 
        || !pQuery
        || !(TargetIID == IID_IUmiCursor)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    *ppResult = NULL;

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = this->_pIADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // We want to pre-process this query and verify that it is
    // valid if this is a SQL/WQL style query. This is a little
    // bit of double effort but provides a much easier usage
    // paradigm.
    //
    hr = VerifyIfQueryIsValid(pQuery);
    BAIL_ON_FAILURE(hr);

    hr = CLDAPConObject::CreateConnectionObject(
             &pConnection,
             this->_pLdapHandle
             );
    BAIL_ON_FAILURE(hr);

    hr = CUmiCursor::CreateCursor(
             pQuery,
             pConnection,
             (IUmiObject *) this,
             bstrADsPath,
             _pszLDAPServer,
             _pszLDAPDn,
             *_pCreds,
             _dwPort,
             TargetIID,
             ppResult
             );

    BAIL_ON_FAILURE(hr);


error :

    if (FAILED(hr)) {
        if (*ppResult) {
            ((IUnknown*)(*ppResult))->Release();
        }
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }
    
    if (bstrADsPath) {
        SysFreeString(bstrADsPath);
    }

    if (pConnection) {
        pConnection->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetCLSIDForIID --- ICustomInterfaceFactory.
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. If
//             the interface is one of the interfaces implemented by the
//             underlying LDAP object, then CLSID_LDAPObject is returned.
//             If the IID is one of the interfaces implemented by an 
//             extension object, then the extension's CLSID is returned. 
//
// Arguments:  riid     -   Interface ID for which we want to find the CLSID.
//             lFlags   -   Reserved. Must be 0.
//             pCLSID   -   Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pUnknown = NULL;

    SetLastStatus(0);

    if ( (lFlags) || (!pCLSID) ) {
        SetLastStatus(E_INVALIDARG);
        RRETURN(E_INVALIDARG);
    }

    if (_pExtMgr) {
        //
        // Check if there is any extension that supports this IID.
        //
        hr = _pExtMgr->GetCLSIDForIID(
                riid,
                lFlags,
                pCLSID
                );

        if (SUCCEEDED(hr)) {
            RRETURN(S_OK);
        }
    }

    //
    // check if the underlying LDAP object supports this IID
    //
    hr = _pUnkInner->QueryInterface(riid, (void **) &pUnknown);

    if (SUCCEEDED(hr)) {
        pUnknown->Release();

        memcpy(pCLSID, &CLSID_LDAPObject, sizeof(GUID));

        RRETURN(S_OK);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}
     
//+---------------------------------------------------------------------------
// Function:   GetObjectByCLSID --- IUmiCustomInterfaceFactory support.
//
// Synopsis:   Returns a pointer to a requested interface on the object 
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown. The interface
//             returned is a non-delegating interface on the object.
//
// Arguments:  clsid        -  CLSID of object supporting requested interface.
//             pUnkOuter    -  Aggregating outer unknown.
//             dwClsContext -  Context for running executable code. 
//             riid         -  Interface requested.
//             lFlags       -  Reserved. Must be 0.
//             ppInterface  -  Returns requested interface.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    long lFlags,
    void **ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pCurOuterUnk = NULL;

    SetLastStatus(0);

    if ( (lFlags != 0)
        || (!pUnkOuter)
        || (!ppInterface)
        || (dwClsContext != CLSCTX_INPROC_SERVER) ) 
        {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // ensure outer unknown specified is same as what is on the LDAP object
    //
    if (_fOuterUnkSet) {
        pCurOuterUnk = _pCoreObj->GetOuterUnknown();

        if (pCurOuterUnk != pUnkOuter) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
    }

    //
    // The interface requested has to be IUnknown if there is
    // an outer uknown ptr.
    //
    if (!IsEqualIID(riid, IID_IUnknown)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }


    if (!IsEqualCLSID(clsid, CLSID_LDAPObject)) {
        //
        // has to be a CLSID of an extension object
        //
        if (_pExtMgr) {

            hr = _pExtMgr->GetObjectByCLSID(
                     clsid,
                     pUnkOuter,
                     riid,
                     ppInterface
                     );
            BAIL_ON_FAILURE(hr);

            //
            // successfully got the interface
            //
            _pCoreObj->SetOuterUnknown(pUnkOuter); 
            _fOuterUnkSet = TRUE;

            RRETURN(S_OK);
        }
        else {
            BAIL_ON_FAILURE(hr = E_INVALIDARG); // bad CLSID
        }
    }

    //
    // CLSID == CLSID_LDAPObject. This has to be an interface on the
    // underlying LDAP object. Check if the LDAP object supports this IID.
    //
    hr = _pUnkInner->QueryInterface(riid, ppInterface);

    if (SUCCEEDED(hr)) {
        //
        // successfully got the interface
        //
        _pCoreObj->SetOuterUnknown(pUnkOuter);
        _fOuterUnkSet = TRUE;

        RRETURN(S_OK);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForNames --- ICustomInterfaceFactory support.
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:  rgszNames   -  Names to be mapped.
//             cNames      -  Number of names to be mapped.
//             lcid        -  Locale in which to interpret the names.
//             rgDispId    -  Returns DISPID.
//             lFlags      -  Reserved. Must be 0.
//             pCLSID      -  Returns CLSID of object supporting this
//                            property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT   hr = S_OK;
    IDispatch *pDispatch = NULL;

    SetLastStatus(0);

    if ( (lFlags != 0) || (!pCLSID) ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (cNames == 0) {
        RRETURN(S_OK);
    }

    if ( (!rgszNames) || (!rgDispId) ) {
        RRETURN(S_OK);
    }

    if (_pExtMgr) {
        //
        // check if there is any extension which supports this IID
        //
        hr = _pExtMgr->GetCLSIDForNames(
                 rgszNames,
                 cNames,
                 lcid,
                 rgDispId,
                 lFlags,
                 pCLSID
                 );
        if (SUCCEEDED(hr)) {
            //
            // successfully got the CLSID and DISPIDs
            //
            RRETURN(S_OK);
        }
    }

    //
    // Check if the underlying LDAP object supports this name 
    //
    hr = _pUnkInner->QueryInterface(IID_IDispatch, (void **) &pDispatch);
    if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDispatch->GetIDsOfNames(
             IID_NULL,
             rgszNames,
             cNames,
             lcid,
             rgDispId
             );
    if (SUCCEEDED(hr)) {
        pDispatch->Release();
        memcpy(pCLSID, &CLSID_LDAPObject, sizeof(GUID));

        RRETURN(S_OK);
    }

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetOption --- IADsObjOptPrivate support.
//
// Synopsis:   Private interface for internal use, this function is used to
//          return the ldap handle if applicable.
//
// Arguments:  dwOption    -  Option being read.
//             pValue      -  Return pointer to hold value of option.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pValue to return requested option.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetOption(
    DWORD dwOption,
    void  *pValue
    )
{
    if (dwOption != LDP_CACHE_ENTRY) {
        RRETURN(E_FAIL);
    } 
    else {
        *((PADSLDP *) pValue) = _pLdapHandle;
        RRETURN(S_OK);
    }
}


//+---------------------------------------------------------------------------
// Function:   SetOption --- IADsObjOptPrivate support.
//
// Synopsis:   Private interface for internal use - NOTIMPL.
//
// Arguments:  dwOption    -  Option being set
//             pValue      -  Value of option being set.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pValue to return requested option.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::SetOption(
    DWORD dwOption,
    void  *pValue
    )
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CopyToHelper --- Helper routine protected scope.
//
// Synopsis:   Copies the attributes on the source object over to the
//          destination object.
//
// Arguments:  pUmiObjSr      ---   Source object.
//             pUmiObjDest    ---   Destination object to copy attributes to.
//             uFlags         ---   Only 0 is supported currently.
//             fMarkAsUpdate  ---   Flag indicating if we should mark the
//                               attributes on dest as update rather than 0.
//             fCopyIntfProps ---   Only false is supported currently.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pUmiObjDest
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::CopyToHelper(
    IUmiObject *pUmiSrcObj,
    IUmiObject *pUmiDestObj,
    ULONG uFlags,
    BOOL fMarkAsUpdate, // default is TRUE
    BOOL fCopyIntfProps // default is FALSE
    )
{
    HRESULT hr = S_OK;
    ULONG ulLastError = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropValsList = NULL;
    DWORD dwCount;


    if (!pUmiSrcObj || !pUmiDestObj || uFlags) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // We need to get the list of properties from the src object.
    //
    hr = pUmiSrcObj->GetProps(
             NULL,
             0,
             UMI_FLAG_GETPROPS_NAMES,
             &pUmiPropValsList
             );
    BAIL_ON_FAILURE(hr);

    for (dwCount = 0; dwCount < pUmiPropValsList->uCount; dwCount++) {
        //
        // We need to walk the list, get each properties name and then
        // for each property get its values from the source and put them
        // on the destination.
        //
        LPWSTR pszTempStr = 
            pUmiPropValsList->pPropArray[dwCount].pszPropertyName;
        PUMI_PROPERTY_VALUES pCurProp = NULL;

        if (!pszTempStr) {
            //
            // Name should never be NULL.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        //
        // We need to add a check for the SD cause we want to copy that over
        // as a binary blob to prevent unnecessary traffic.
        //

        // Should change the get to use the force flag once it is done.
        //
        hr = pUmiSrcObj->Get(
                 pszTempStr,
                 0,
                 &pCurProp
                 );
        if (FAILED(hr)) {
            pUmiSrcObj->GetLastStatus(0, &ulLastError, IID_IUnknown, NULL);
            BAIL_ON_FAILURE(hr); 
        }

        hr = pUmiDestObj->Put(
                 pszTempStr,
                 0x8000000,
                 pCurProp
                 );

        //
        // Irrespective of this operation success/failure we need to free
        // the contents of pCurProp.
        //
        pUmiSrcObj->FreeMemory(0, (void *) pCurProp);

        if (FAILED(hr)) {
            pUmiDestObj->GetLastStatus(0, &ulLastError, IID_IUnknown, NULL);
            BAIL_ON_FAILURE(hr); 
        }

    } // for each property in the source object.


error:

    if (pUmiPropValsList) {
        pUmiSrcObj->FreeMemory(0, (void *) pUmiPropValsList);
    }

    if (FAILED(hr)) {
        if (ulLastError) {
            SetLastStatus(ulLastError);
        }
        else {
            SetLastStatus(hr);
        }

        hr = MapHrToUmiError(hr);
    }
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    VerifyifQueryIsValid --- Helper routine protected scope.
//
// Synopsis:   Copies the attributes on the source object over to the
//          destination object.
//
// Arguments:  pUmiQeury      ---   Query object to validate.
//
// Returns:    S_OK on success. Error code from parser otherwise.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::VerifyIfQueryIsValid(
    IUmiQuery *pUmiQuery
    )
{
    HRESULT hr = S_OK;
    ULONG ulLangBufSize = 100 * sizeof(WCHAR);
    ULONG ulQueryBufSize = MAX_PATH * sizeof(WCHAR);
    WCHAR pszLangBuf[100];
    WCHAR szQueryText[MAX_PATH];
    LPWSTR pszQueryText = szQueryText;
    IWbemQuery *pQueryParser = NULL;
    ULONG ulFeatures[] = {
        WMIQ_LF1_BASIC_SELECT,
        WMIQ_LF2_CLASS_NAME_IN_QUERY,
        WMIQ_LF6_ORDER_BY,
        WMIQ_LF24_UMI_EXTENSIONS
    };

    //
    // We need to look at the query language if the language is SQL,
    // then we need to go through and convert the SQL settings to
    // properties on the intfPropList of the query.
    //
    hr = pUmiQuery->GetQuery(
             &ulLangBufSize,
             pszLangBuf,
             &ulQueryBufSize,
             pszQueryText
             );

    if (hr == E_OUTOFMEMORY ) {
        //
        // Means there was insufficient length in the buffers.
        //
        if (ulQueryBufSize > (MAX_PATH * sizeof(WCHAR))) {
            pszQueryText = (LPWSTR) AllocADsMem(
                ulQueryBufSize + sizeof(WCHAR)
                );
            if (pszQueryText) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        hr =  pUmiQuery->GetQuery(
                  &ulLangBufSize,
                  pszLangBuf,
                  &ulQueryBufSize,
                  pszQueryText
                  );
    }
    BAIL_ON_FAILURE(hr);

    if (*pszLangBuf) {
        if (!_wcsicmp(L"SQL", pszLangBuf)
            || !_wcsicmp(L"WQL", pszLangBuf)
             ) {
            //
            // Create the WBEM parser object and verify the query is valid.
            //
            hr = CoCreateInstance(
                     CLSID_WbemQuery,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IWbemQuery,
                     (LPVOID *) &pQueryParser
                     );
            BAIL_ON_FAILURE(hr);

            //
            // Set the query into the parser and try and parse the query.
            //
            hr = pQueryParser->SetLanguageFeatures(
                     0,
                     sizeof(ulFeatures)/sizeof(ULONG),
                     ulFeatures
                     );
            BAIL_ON_FAILURE(hr);

            hr = pQueryParser->Parse(L"SQL", pszQueryText, 0);
            BAIL_ON_FAILURE(hr);
        } // if the language is SQL
    } // if the language has been set
    else {
        //
        // No language ???.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        //
        // For now do not map error as we want error from parser
        // until such time as new error codes are added to umi.
        //        hr = MapHrToUmiError(hr);
    }

    if (pQueryParser) {
        pQueryParser->Release();
    }

    if (pszQueryText && pszQueryText != szQueryText) {
        FreeADsMem(pszQueryText);
    }

    return hr;
}


//+---------------------------------------------------------------------------
// Function:    VerifyIfClassMatches --- Helper routine protected scope.
//
// Synopsis:   Makes sure the class name of the object matches the class
//          asked for.
//
// Arguments:  pszClass      ---   Class requested.
//             pUnk          ---   Ptr to IUnk of Umi Object.
//             lGenus        ---   Is the parent a schema object or not ?
//
// Returns:    S_OK on success. Any failure error code or E_INVALIDARG.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::VerifyIfClassMatches(
    LPWSTR pszClass,
    IUnknown * pUnk,
    LONG     lGenus
    )
{
    HRESULT hr = S_OK;
    IUmiObject *pUmiObject = NULL;
    IUmiPropList *pPropList = NULL;
    UMI_PROPERTY_VALUES *pPropVals = NULL;

    //
    // For now the schema will always succeed cause we have no
    // way to verify the parent class. We will fail the GetObject
    // calls on the schema objects with bad paths.
    //
    if (lGenus == UMI_GENUS_CLASS) {
        RRETURN(hr);
    }

    //
    // Get hold of the IUmiObject and then the proplist from it.
    //
    hr = pUnk->QueryInterface(
             IID_IUmiObject,
             (void **) &pUmiObject
             );
    BAIL_ON_FAILURE(hr);

    hr = pUmiObject->GetInterfacePropList(
             0,
             &pPropList
             );
    BAIL_ON_FAILURE(hr);

    hr = pPropList->Get(L"__CLASS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    //
    // Should have one value that we need to compare
    // 
    if (!pPropVals
        || (pPropVals->uCount != 1)
        || !pPropVals->pPropArray
        || !pPropVals->pPropArray[0].pUmiValue
        || !pPropVals->pPropArray[0].pUmiValue->pszStrValue
        || !pPropVals->pPropArray[0].pUmiValue->pszStrValue[0]
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Failure if the names do not match.
    //
    if (_wcsicmp(
             pPropVals->pPropArray[0].pUmiValue->pszStrValue[0],
             pszClass
             )
        ) {
        hr = E_INVALIDARG;
    }
    
error:

    if (pUmiObject) {
        pUmiObject->Release();
    }

    if (pPropList) {
        pPropList->Release();
    }

    if (pPropVals) {
        FreeMemory(0, (void*)pPropVals);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\cumicurs.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumicurs.cxx
//
//  Contents: Contains the UMI cursor object implementation. There are 2
//          ways to use this object. One is to initialize with an 
//          IADsContainer pointer and the other is to use an IUmiQuery obj.
//
//  History:  03-16-00    SivaramR  Created (in WinNT)
//            03-28-00    AjayR  modified for LDAP.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CUmiCursor
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CUmiCursor::CUmiCursor():
    _pPropMgr(NULL),
    _ulErrorStatus(0),
    _pIID(NULL),
    _pContainer(NULL),
    _pEnum(NULL),
    _pSearchHelper(NULL),
    _fQuery(FALSE)
{
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::~CUmiCursor
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CUmiCursor::~CUmiCursor()
{
    if (_pPropMgr) {
        delete _pPropMgr;
    }

    if (_pContainer) {
        _pContainer->Release();
    }

    if (_pIID){
        FreeADsMem(_pIID);
    }

    if (_pEnum) {
        _pEnum->Release();
    }

    if (_pSearchHelper) {
        delete _pSearchHelper;
    }
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CreateCursor (static constructor overloaded)
//
// Synopsis:   Creats a UmiCursor object in the container mode.
//
// Arguments:  *pCont      - Pointer to container we are enumerating.
//             iid         - IID requested on returned object.
//             ppInterface - Ptr to return value.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppInterface to point to new cursor object.
//
//----------------------------------------------------------------------------
HRESULT 
CUmiCursor::CreateCursor(
    IUnknown *pCont,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    CPropertyManager *pPropMgr = NULL;
    IADsContainer *pContainer = NULL;
    HRESULT    hr = S_OK;

    ADsAssert(ppInterface);
    ADsAssert(pCont);

    pCursor = new CUmiCursor();
    if (!pCursor) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Initialize the various params on this object.
    //
    hr = CPropertyManager::CreatePropertyManager(
             (IUnknown *) pCursor,
             NULL, // IADs ptr
             NULL, // pCreds
             IntfPropsCursor,
             &pPropMgr
             );
    BAIL_ON_FAILURE(hr);

    hr = pCont->QueryInterface(
             IID_IADsContainer, 
             (void **) &pContainer
             );
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on this object is now 2, release the additional ref.
    //
    pCursor->Release();

    pCursor->_pContainer = pContainer;
    pCursor->_pPropMgr = pPropMgr;
    pCursor->_pIID = NULL;
    pCursor->_ulErrorStatus = 0;


    RRETURN(S_OK);

error:

    if (pCursor) {
        delete pCursor;
    }

    if (pPropMgr) {
        delete pPropMgr;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CreateCursor (static constructor overloaded).
//
// Synopsis:   Creats a UmiCursor object in the query mode. Most of the 
//          params are needed for creating the search helper object.
//
// Arguments:  pQuery        - Query being executed.
//             pConnection   - Connection being used for query.
//             pUnk          - ???.
//             pszADsPath    - Path of object query is being executed on.
//             pszLdapServer - Server of object being queried.
//             pszLdapDn     - Dn of the object being searched.
//             cCredentials  - Credentials to use for query.
//             dwPort        - Port being used for connection.
//             iid           - Cursor iid requested 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppInterface to point to new cursor object.
//
//----------------------------------------------------------------------------
HRESULT
CUmiCursor::CreateCursor(
    IUmiQuery *pQuery,
    IUmiConnection *pConnection,
    IUnknown *pUnk,
    LPCWSTR pszADsPath,
    LPCWSTR pszLdapServer,
    LPCWSTR pszLdapDn,
    CCredentials cCredentials,
    DWORD dwPort,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    CPropertyManager *pPropMgr = NULL;
    HRESULT    hr = S_OK;
    CUmiSearchHelper *pSearchHelper = NULL;

    ADsAssert(ppInterface);

    hr = CUmiSearchHelper::CreateSearchHelper(
             pQuery,
             pConnection,
             pUnk,
             pszADsPath,
             pszLdapServer,
             pszLdapDn,
             cCredentials,
             dwPort,
             &pSearchHelper
             );
    BAIL_ON_FAILURE(hr);

    pCursor = new CUmiCursor();
    if (!pCursor) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Initialize the various params on this object.
    //
    hr = CPropertyManager::CreatePropertyManager(
             (IUnknown *) pCursor,
             NULL, // pIADs
             NULL, // pCreds
             IntfPropsCursor,
             &pPropMgr
             );
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on this object is now 2, release the additional ref.
    //
    pCursor->Release();

    pCursor->_pSearchHelper = pSearchHelper;
    pCursor->_pPropMgr = pPropMgr;
    pCursor->_pIID = NULL;
    pCursor->_ulErrorStatus = 0;
    pCursor->_fQuery = TRUE;

    RRETURN(S_OK);

error:

    if (pCursor) {
        delete pCursor;
    }

    if (pSearchHelper) {
        delete pSearchHelper;
    }

    if (pPropMgr) {
        delete pPropMgr;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::QueryInterface (IUnknown interface).
//
// Synopsis:   Standard QueryInterface function.
//
// Arguments:  Self explanatory.
//
// Returns:    S_OK on success or any suitable error code.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if (!ppInterface)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiCursor)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else {
        *ppInterface = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetLastStatus (IUmiBaseObject method).
//
// Synopsis:   Returns only numeric status code from the last operation.
//
// Arguments:  uFlags           -  Only 0 is supported for now.
//             puSpecificStatus -  Returns status/error code.
//             riid             -  Not used.
//             pStatusObj       -  NULL, not used currently.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *puSpecificStatus to return appropriate status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (uFlags != 0) {
       RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!puSpecificStatus) {
        RRETURN(E_INVALIDARG);
    }

    if (pStatusObj) {
        //
        // Should we error out ?
        //
        *pStatusObj = NULL;
    }

    *puSpecificStatus = _ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetInterfacePropList (IUmiBaseObject method).
//
// Synopsis:   Returns a pointer to the interface property list for
//          cursor object.
//
// Arguments:  uFlags      -  Flags, only 0 is supported.
//             ppPropList  -  Return value.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList changed to IUmiPropList pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **ppPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if (uFlags != 0) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!ppPropList) {
        RRETURN(E_INVALIDARG);
    }

    hr = _pPropMgr->QueryInterface(IID_IUmiPropList, (void **)ppPropList);

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetLastStatus (internal private helper routine).
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus      -   Status to be set.
//
// Returns:    Nothing
//
// Modifies:   Internal member status variable.
//
//----------------------------------------------------------------------------
void 
CUmiCursor::SetLastStatus(ULONG ulStatus)
{
    this->_ulErrorStatus = ulStatus;

    return;
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetIID (IUmiCursor method).
//
// Synopsis:   Sets the interface to be requested off each item returned by
//             the enumerator. Default is IID_IUmiObject. 
//
// Arguments: riid        -   IID of interface to request.
//
// Returns:   UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:  Nothing. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiCursor::SetIID(
    REFIID riid
    )
{
    SetLastStatus(0);

    if (_fQuery) {
        RRETURN(this->_pSearchHelper->SetIID(riid));
    } 
    else {
        if (!_pIID){
    
           _pIID = (IID *) AllocADsMem(sizeof(IID));
           if (!_pIID){
               RRETURN(E_OUTOFMEMORY);
           }
        }

        memcpy(_pIID, &riid, sizeof(IID));
    }

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::Reset (IUmiCursor method).
//
// Synopsis:   Resets the enumerator to restart from begining (this is for
//          likely to return an error for the IADsContainer case).
//
// Arguments:  N/A.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::Reset(void)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(hr);

    //
    // Rest of the code can be invoked when we have proper support.
    //
    SetLastStatus(0);

    if (!_fQuery) {
    
        //
        // it is possible that _pEnum may be NULL here if the user
        // called Reset before calling Next()
        //
        if (!_pEnum) {
            RRETURN(UMI_S_NO_ERROR);
        }
    
        hr = _pEnum->Reset();
        BAIL_ON_FAILURE(hr);

        hr = S_OK;
    } 
    else {
        hr = _pSearchHelper->Reset();
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }
    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetFilter (internal private helper routine).
//
// Synopsis:   Gets the filter from the interface property cache. If the
//             interface property was not set, an emty variant is returned. 
//
// Arguments:  pvFilter   -  ptr to variant for return value.
//
// Returns:    UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:   *pvFilter to return the filter. 
//
//----------------------------------------------------------------------------
HRESULT
CUmiCursor::GetFilter(VARIANT *pvFilter)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              *ppszFilters = NULL;
    DWORD               dwNumFilters = 0;

    ADsAssert(pvFilter);

    VariantInit(pvFilter);

    hr = _pPropMgr->Get(
             L"__FILTER",
             0,
             &pUmiProp
             );

    if (hr == UMI_E_NOT_FOUND) {
        //
        // interface property was not set. Return empty variant.
        //
        RRETURN(hr);
    }

    BAIL_ON_FAILURE(hr);

    ADsAssert(pUmiProp->pPropArray->uType == UMI_TYPE_LPWSTR);
    //
    // Make sure we have data back and that it is not just NULL.
    // We will not get back a NULL string but instead an array with 
    // one element that is NULL. That is as good as no filter.
    //
    if (pUmiProp->pPropArray->uCount
        && pUmiProp->pPropArray->pUmiValue
        && pUmiProp->pPropArray->pUmiValue->pszStrValue[0]
        ) {
        //
        // Valid filter is present.
        //
        ppszFilters = pUmiProp->pPropArray->pUmiValue->pszStrValue;
        dwNumFilters = pUmiProp->pPropArray->uCount;

        hr = ADsBuildVarArrayStr(ppszFilters, dwNumFilters, pvFilter);
        BAIL_ON_FAILURE(hr);
    }
    else {
        hr = UMI_E_NOT_FOUND;
    }

error:

    if (pUmiProp) {
        _pPropMgr->FreeMemory(0, pUmiProp);
    }
    RRETURN(hr);
} 

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::Next  (IUmiCursor method). 
//
// Synopsis:   Returns the next "n" item(s) in the enumeration sequence.
//
// Arguments:  uNumRequested     -  Number of items requested.
//             pNumReturned      -  Returns actual number of objects returned.
//             ppObjects         -  Array of interface pointers of size 
//                                 *pNumReturned.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNumReturned to return the number of objects returned
//             *ppObjects to return the interface pointers 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT   hr = S_OK;;
    VARIANT   vFilter, *pvResults = NULL;
    ULONG     ulIndex = 0, uNumReturned = 0, uNumResults = 0;
    IDispatch *pDisp = NULL;
    IUnknown  **pUnkArr = NULL, *pTmpUnk = NULL;
    VARIANT   vOldFilter;
    BOOL      fReplaceFilter = FALSE;

    SetLastStatus(0);
    VariantInit(&vOldFilter);

    if ( (!puNumReturned) || (!ppObjects) ){
        RRETURN(E_INVALIDARG);
    }

    *puNumReturned = 0;
    *ppObjects = NULL;

    //
    // If this is a query then we need to get the results from the
    // query object.
    //
    if (_fQuery) {
        hr = _pSearchHelper->Next(
                 uNumRequested,
                 puNumReturned,
                 ppObjects
                 );
        //
        // MapHrToUmiError
        //
        RRETURN(hr);
    }

    //
    // If we get here this is a container enumerate.
    //
    VariantInit(&vFilter);

    if (!_pEnum) {
        //
        // first call to Next()
        //
        ADsAssert(_pContainer);

        //
        // check if the user set a filter on the cursor 
        //
        hr = GetFilter(&vFilter);
        if (SUCCEEDED(hr)) {
            //
            // We need to get the old filter to restore it.
            //
            hr = _pContainer->get_Filter(&vOldFilter);
            if (SUCCEEDED(hr)) {
                fReplaceFilter = TRUE;
            }
            //
            // We have a valid filter that we need to set.
            //
            hr = _pContainer->put_Filter(vFilter);
        } 
        else if (hr == UMI_E_NOT_FOUND) {
            //
            // Reset error as this one is expected, anything else we bail.
            //
            hr = S_OK;
        } 
        //
        // Catch either GetFilter failure or put_Filter failure.
        //
        BAIL_ON_FAILURE(hr);
        
        hr = _pContainer->get__NewEnum((IUnknown **) &_pEnum);
        //
        // Restore old filter irrespective of ECODE.
        //
        if (fReplaceFilter) {
            _pContainer->put_Filter(vOldFilter);
        }
        BAIL_ON_FAILURE(hr);
    }

    //
    // allocate memory for variants to return objects
    //
    pvResults = (VARIANT *) AllocADsMem(uNumRequested * sizeof(VARIANT));
    if (!pvResults) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = _pEnum->Next(
             uNumRequested,
             pvResults,
             &uNumReturned
             );
    BAIL_ON_FAILURE(hr);

    if (!uNumReturned) {
        //
        // This will handle the S_FALSE case.
        //
        goto error;
    }

    //
    // allocate memory for array of interface pointers to return
    //
    pUnkArr = (IUnknown **) AllocADsMem(uNumReturned * sizeof(IUnknown *));
    if (!pUnkArr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // convert the V_DISPATCH variants to the requested interface properties
    //
    for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {

        pDisp = V_DISPATCH(&pvResults[ulIndex]);

        if (_pIID) {
            hr = pDisp->QueryInterface(*_pIID, (void **) &pTmpUnk);
        } 
        else {
            hr = pDisp->QueryInterface(IID_IUmiObject, (void **) &pTmpUnk);
        }

        //
        // Is this really correct ?
        //
        if (FAILED(hr)) {
            continue;
        }

        pUnkArr[uNumResults] = pTmpUnk;
        uNumResults++;
    }

    *puNumReturned = uNumResults;

    if (uNumResults > 0) {
        *ppObjects = pUnkArr;
    }
    else {
        FreeADsMem(pUnkArr);
    }
       
error:

    VariantClear(&vFilter);
    VariantClear(&vOldFilter);

    if (pvResults) {
        for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {
            VariantClear(&pvResults[ulIndex]);
        }

        FreeADsMem(pvResults);
    }
            
    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
// Function:   Count 
//
// Synopsis:   Counts the number of results returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Count(
    ULONG *puNumObjects
    )
{
    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
}       

//+---------------------------------------------------------------------------
// Function:   Previous 
//
// Synopsis:   Returnss the previous object returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Previous(
    ULONG uFlags,
    LPVOID *pObj 
    )
{
    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:  
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// List of interface properties for Generic Objects
//
INTF_PROP_DATA IntfPropsGeneric[] =
{
    // 9999 implies BSTR value got using pIADs ptr.
    { TEXT("__Class"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__GUID"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Path"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Parent"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Schema"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__URL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    // end of list from IADs::get_ methods.
    { TEXT("__Genus"), OPERATION_CODE_READABLE,
      UMI_TYPE_I4,  FALSE, {UMI_GENUS_INSTANCE}},
    { TEXT("__Name"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__KEY"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELPATH"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__FULLRELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__PADS_SCHEMA_CONTAINER_PATH"), OPERATION_CODE_READABLE,
      9999, FALSE, {NULL}},
    { TEXT("__SECURITY_DESCRIPTOR"), OPERATION_CODE_READWRITE,
      9999, FALSE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Same as generic save that genus is set to schema value.
//
INTF_PROP_DATA IntfPropsSchema[] =
{
    // 9999 implies BSTR value got using pIADs ptr.
    { TEXT("__Class"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Path"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Parent"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__URL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    // end of list from IADs::get_ methods.
    { TEXT("__Genus"), OPERATION_CODE_READABLE,
      UMI_TYPE_I4, FALSE, {UMI_GENUS_CLASS}},
    { TEXT("__Name"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELPATH"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__FULLRELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__SUPERCLASS"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Interface property data for connection objects.
//
INTF_PROP_DATA IntfPropsConnection[] =
{
    { TEXT("Class"), OPERATION_CODE_READABLE,
         UMI_TYPE_LPWSTR, FALSE, {NULL} },
    { TEXT("__UserId"), OPERATION_CODE_READWRITE, 
        UMI_TYPE_LPWSTR, FALSE, {NULL}},
    { TEXT("__Password"), OPERATION_CODE_WRITEABLE,
        UMI_TYPE_LPWSTR, FALSE, {NULL}},
    { TEXT("__SECURE_AUTHENTICATION"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {TRUE}},
    { TEXT("__NO_AUTHENTICATION"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_READONLY_SERVER"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_PROMPT_CREDENTIALS"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SERVER_BIND"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_FAST_BIND"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_USE_SIGNING"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_USE_SEALING"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
//    { TEXT("SecurityFlags"), OPERATION_CODE_READWRITE,
//        UMI_TYPE_I4, FALSE, {1}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};


//
// Interface property data for cursor objects.
//
INTF_PROP_DATA IntfPropsCursor[] =
{
    { TEXT("__Filter"), OPERATION_CODE_READWRITE, 
        UMI_TYPE_LPWSTR, TRUE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Interface properties for query object.
//
INTF_PROP_DATA IntfPropsQuery[]=
{
    { TEXT("__SEARCH_SCOPE"), OPERATION_CODE_READWRITE, UMI_TYPE_I4,
         FALSE, {LDAP_SCOPE_SUBTREE} },
    { TEXT("__PADS_SEARCHPREF_ASYNCHRONOUS"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_DEREF_ALIASES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_SIZE_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBTYPES_ONLY"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_TIMEOUT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGESIZE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGED_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_CHASE_REFERRALS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {ADS_CHASE_REFERRALS_EXTERNAL}},
    //
    // BugBug do we keep this similar to IDirectorySearch or do we not cache.
    //
    { TEXT("__PADS_SEARCHPREF_CACHE_RESULTS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {TRUE}},
    { TEXT("__PADS_SEARCHPREF_TOMBSTONE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_FILTER"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBUTES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, TRUE, {0}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

BOOL   g_fDllsLoaded = FALSE;
HANDLE g_hDllNtdsapi = NULL;
HANDLE g_hDllSecur32 = NULL;
CRITICAL_SECTION g_csLoadLibsCritSect;

//
// Loads all the dynamic libs we need.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (g_fDllsLoaded) {
        return;
    }

    ENTER_LOADLIBS_CRITSECT();
    if (g_fDllsLoaded) {
        LEAVE_LOADLIBS_CRITSECT();
        return;
    }

    if (!(g_hDllNtdsapi = LoadLibrary(L"NTDSAPI.DLL"))) {
        dwErr = GetLastError();
    }

    if (g_hDllSecur32 = LoadLibrary(L"SECUR32.DLL")) {
        if (dwErr) {
            //
            // Set the last error for whatever it is worth.
            // This does not really matter cause any dll we
            // cannot load, we will not get functions on that
            // dll. If secur32 load failed, then that call
            // would have set a relevant last error.
            //
            SetLastError(dwErr);
        }
    }

    g_fDllsLoaded = TRUE;
    LEAVE_LOADLIBS_CRITSECT();

    return;
}

//
// Loads the appropriate ntdsapi fn.
//
PVOID LoadNtDsApiFunction(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNtdsapi) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllNtdsapi, function));
    }

    return NULL;
}


//
// Loads the appropriate secur32 fn.
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllSecur32, function));
    }

    return NULL;
}

//
// DsUnquoteRdnValueWrapper
//
DWORD DsUnquoteRdnValueWrapper(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWSTR  psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWSTR   psUnquotedRdnValue
    )
{
    static PF_DsUnquoteRdnValueW pfDsUnquoteRdnVal = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsUnquoteRdnVal == NULL) {
        pfDsUnquoteRdnVal =
            (PF_DsUnquoteRdnValueW) LoadNtDsApiFunction(DSUNQUOTERDN_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsUnquoteRdnVal != NULL) {
        return ((*pfDsUnquoteRdnVal)(
                      cQuotedRdnValueLength,
                      psQuotedRdnValue,
                      pcUnquotedRdnValueLength,
                      psUnquotedRdnValue
                      )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }

}


//
// DsMakePasswordCredentialsWrapper
//
DWORD DsMakePasswordCredentialsWrapper(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )
{
    static PF_DsMakePasswordCredentialsW pfMakePwdCreds = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfMakePwdCreds == NULL) {
        pfMakePwdCreds = (PF_DsMakePasswordCredentialsW)
                                LoadNtDsApiFunction(DSMAKEPASSWD_CRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfMakePwdCreds != NULL) {
        return ((*pfMakePwdCreds)(
                       User,
                       Domain,
                       Password,
                       pAuthIdentity
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsFreePasswordCredentialsWrapper
//
DWORD DsFreePasswordCredentialsWrapper(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    )
{
    static PF_DsFreePasswordCredentials pfFreeCreds = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfFreeCreds == NULL) {
        pfFreeCreds = (PF_DsFreePasswordCredentials)
                          LoadNtDsApiFunction(DSFREEPASSWD_CRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfFreeCreds != NULL) {
        return ((*pfFreeCreds)(
                       AuthIdentity
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsBindWrapper.
//
DWORD DsBindWrapper(
    LPCWSTR         DomainControllerName,
    LPCWSTR         DnsDomainName,
    HANDLE          *phDS
    )
{
    static PF_DsBindW pfDsBind = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsBind == NULL) {
        pfDsBind = (PF_DsBindW) LoadNtDsApiFunction(DSBIND_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsBind != NULL) {
        return ((*pfDsBind)(
                       DomainControllerName,
                       DnsDomainName,
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsUnBindWrapper.
//
DWORD DsUnBindWrapper(
     HANDLE          *phDS
     )
{
    static PF_DsUnbindW pfDsUnbind = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsUnbind == NULL) {
        pfDsUnbind = (PF_DsUnbindW) LoadNtDsApiFunction(DSUNBIND_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsUnbind != NULL) {
        return ((*pfDsUnbind)(
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsCrackNamesWrapper.
//
DWORD DsCrackNamesWrapper(
    HANDLE              hDS,
    DS_NAME_FLAGS       flags,
    DS_NAME_FORMAT      formatOffered,
    DS_NAME_FORMAT      formatDesired,
    DWORD               cNames,
    const LPCWSTR       *rpNames,
    PDS_NAME_RESULTW    *ppResult
    )
{
    static PF_DsCrackNamesW pfDsCrackNames = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsCrackNames == NULL) {
        pfDsCrackNames = (PF_DsCrackNamesW)
                              LoadNtDsApiFunction(DSCRACK_NAMES_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsCrackNames != NULL) {
        return ((*pfDsCrackNames)(
                      hDS,
                      flags,
                      formatOffered,
                      formatDesired,
                      cNames,
                      rpNames,
                      ppResult
                      )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsBindWithCredWrapper.
//
DWORD DsBindWithCredWrapper(
    LPCWSTR         DomainControllerName,
    LPCWSTR         DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    HANDLE          *phDS
    )
{
    static PF_DsBindWithCredW pfDsBindWithCred = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsBindWithCred == NULL) {
        pfDsBindWithCred = (PF_DsBindWithCredW)
                                LoadNtDsApiFunction(DSBINDWITHCRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsBindWithCred != NULL) {
        return ((*pfDsBindWithCred)(
                       DomainControllerName,
                       DnsDomainName,
                       AuthIdentity,
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsFreeNameResultWrapper.
//
DWORD DsFreeNameResultWrapper(
    DS_NAME_RESULTW *pResult
    )
{
    static PF_DsFreeNameResultW pfDsFreeNameResult = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsFreeNameResult == NULL) {
        pfDsFreeNameResult = (PF_DsFreeNameResultW)
                                  LoadNtDsApiFunction(DSFREENAME_RESULT_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsFreeNameResult != NULL) {
        return ((*pfDsFreeNameResult)(
                       pResult
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}

//
// QueryContextAttributesWrapper.
//
DWORD QueryContextAttributesWrapper(
    PCtxtHandle phContext,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    )
{
    static PF_QueryContextAttributes pfQueryCtxtAttr = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfQueryCtxtAttr == NULL) {
        pfQueryCtxtAttr = (PF_QueryContextAttributes)
                                  LoadSecur32Function(QUERYCONTEXT_ATTR_API);
        f_LoadAttempted = TRUE;
    }

    if (pfQueryCtxtAttr != NULL) {
        return ((*pfQueryCtxtAttr)(
                       phContext,
                       ulAttribute,
                       pBuffer
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//+---------------------------------------------------------------------------
// Function:   UrlToClassAndDn - global scope, helper function.
//
// Synopsis:   This function takes strings of the following formats and 
//          returns the class name and dn part in the appropriate return
//          values :
//          1) Fully qualified = user.cn=MyTestUser,
//          2) Full Name (umi) = .cn=MyTestUser,
//          3) ADSI style RDN  = cn=MyTestUser.
//
// Arguments:  pUrl            -  IUmiURL pointer.
//             ppszDN          -  Contains returned DN (callee must free
//                              using FreeADsStr.
//             ppszClass       -  Contains returned class name string. It
//                              is the callees responsiblity to free using 
//                              FreeADsStrResult.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszDN && *ppszClass.
//
//----------------------------------------------------------------------------
HRESULT
UrlToClassAndDn(
    IN  IUmiURL *pUrl,
    OUT LPWSTR *ppszClass,
    OUT LPWSTR *ppszDN
    )
{
    HRESULT hr;
    WCHAR pszTxt[1024];
    ULONG ulLen = 1023;
    WCHAR *pszUrlTxt = pszTxt;
    LPCWSTR pszUrlTxtCopy = NULL;
    LPWSTR pszDN = NULL, pszClass = NULL;
    DWORD dwClassCount = 0;

    *ppszDN = *ppszClass = NULL;

    ADsAssert(pUrl);
    //
    // Something on the url object telling us what is wrong will help.
    //

    //
    // We need to get hold of the string from the url.
    //
    hr = pUrl->Get(0, &ulLen, pszUrlTxt);
    // replace the correct error code below WBEM_E_BUFFER_TOO_SMALL
    if (hr == 0x8004103c) {
        //
        // not enough space in our buffer, lets try again.
        //
        pszUrlTxt = (WCHAR*) AllocADsMem(ulLen * sizeof(WCHAR));
        if (!pszUrlTxt) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = pUrl->Get(0, &ulLen, pszUrlTxt);
    }

    BAIL_ON_FAILURE(hr);

    pszUrlTxtCopy = pszUrlTxt;
    //
    // Look for the . if there is one that is.
    //
    while (*pszUrlTxtCopy
           && (*pszUrlTxtCopy != L'.')
           && (*pszUrlTxtCopy != L'=')
           ) {
        dwClassCount++;
        pszUrlTxtCopy++;
    }

    if (!*pszUrlTxtCopy) {
        //
        // There was no = in the url has to be a bad RDN.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Urls without a . or not valid.
    //
    if (*pszUrlTxtCopy != L'.') {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (*pszUrlTxtCopy == L'=') {
        //
        // We do not have any class name
        //
        pszDN = AllocADsStr(pszUrlTxt);

        if (!pszDN) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    } 
    else {
        //
        // If the count is zero then we have .cn=something
        //
        if (dwClassCount == 0) {
            pszDN = AllocADsStr(++pszUrlTxtCopy);

            if (!pszDN) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            //
            // A valid class name is present.
            //
            pszClass = (LPWSTR) AllocADsMem(sizeof(WCHAR) * (dwClassCount+1));
        
            if (!pszClass) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            wcsncpy(pszClass, pszUrlTxt, dwClassCount);

            //
            // Advance beyond the . in the url and copy the rdn.
            //
            pszUrlTxtCopy++;

            if (!*pszUrlTxtCopy) {
                //
                // Only class name, no RDN.
                //
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            pszDN = AllocADsStr(pszUrlTxtCopy);

            if (!pszDN) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } // end of else that is dwClassCount != 0
    } // end of else corresponding to class name or . present

    //
    // Alloc class name into new str so we can free using FreeADsStr.
    // 
    if (pszClass) {
        *ppszClass = AllocADsStr(pszClass);

        if (!*ppszClass) {
            BAIL_ON_FAILURE(hr);
        }
        FreeADsMem(pszClass);
    }

    *ppszDN = pszDN;

error:

    if (pszUrlTxt && (pszUrlTxt != pszTxt)) {
        FreeADsMem(pszUrlTxt);
    }

    //
    // Free the DN and Class only if applicable.
    //
    if (FAILED(hr)) {
        if (pszDN) {
            FreeADsStr(pszDN);
        }

        if (pszClass) {
            FreeADsMem(pszClass);
        }
    }

    RRETURN(hr);
}

HRESULT
GetRDn(
    IUmiURL *pURL,
    DWORD  dwComponent,
    LPWSTR pszRDn,
    DWORD  dwRDnLen
    )
{
    HRESULT hr = S_OK;
    IUmiURLKeyList * pKeyList = NULL;
    DWORD dwLen = dwRDnLen;
    DWORD dwKeyNameLen = 64;
    WCHAR szKeyName[64];
    LPWSTR pszTmpStr = NULL;
    BOOL fSchema = FALSE;

    pszTmpStr = (WCHAR*)AllocADsMem(dwRDnLen);
    if (!pszTmpStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the component we need, num is passed in.
    //
    hr = pURL->GetComponent(
             dwComponent,
             &dwLen,
             pszRDn,
             &pKeyList
             );
    BAIL_ON_FAILURE(hr);

    if (!pKeyList) {
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    //
    // Make sure that the key count is only one, anything 
    //else cannot be an LDAP path component.
    //  
    hr = pKeyList->GetCount(&dwLen);
    BAIL_ON_FAILURE(hr);

    if (dwLen != 1) {
        //
        // Need to see if we have the pszRDN set, if so that is the
        // RDN itself - for example Schema or RootDSE.
        //
        if (pszRDn) {
            goto error;
        }
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    dwLen = dwRDnLen;
    //
    // Get the RDN from the key !.
    //
    hr = pKeyList->GetKey(
             0,
             0,
             &dwKeyNameLen,
             szKeyName,
             &dwLen,
             pszTmpStr
             );
    BAIL_ON_FAILURE(hr);

    //
    // We need to special case class.Name=User. This means
    // we are looking for a class called user not an instance
    // of class with RDN Name=User.
    //
    fSchema = !_wcsicmp(pszRDn, L"Class")
              || !_wcsicmp(pszRDn, L"Schema")
              || !_wcsicmp(pszRDn, L"Property")
              || !_wcsicmp(pszRDn, L"Syntax");

    if (fSchema
        && szKeyName
        && !_wcsicmp(szKeyName, L"Name")
        ) {
        //
        // We have class.Name=User.
        //
        wsprintf(pszRDn, L"%s", pszTmpStr);
    }
    else {
        //
        // We have right values and this is the normal code path.
        //
        wsprintf(pszRDn, L"%s=",szKeyName);
        wcscat(pszRDn, pszTmpStr);
    }

error:

    if (pKeyList) {
        pKeyList->Release();
    }

    if (pszTmpStr) {
        FreeADsMem(pszTmpStr);
    }

    RRETURN(hr);
}

HRESULT
GetDNFromURL(
    IUmiURL *pURL,
    LPWSTR *pszDnStr,
    DWORD dwTotalLen
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumComponents = 0, dwCtr = 0;
    LPWSTR pszLocalDn = NULL;
    LPWSTR pszRDn = NULL;

    *pszDnStr = NULL;
    hr = pURL->GetComponentCount(&dwNumComponents);
    BAIL_ON_FAILURE(hr);

    if (dwNumComponents == 0) {
        //
        // DnStr is NULL in this case.
        //
        RRETURN(hr);
    }

    //
    // This is for the retval.
    //
    pszLocalDn = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszLocalDn) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // This is for the rdn's, this buffer should be more than enough
    //
    pszRDn = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszRDn) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // We need to get each of the individuals dn's and keep adding
    // them to the dn we return.
    //
    for (dwCtr = 0; dwCtr < dwNumComponents; dwCtr++) {
        *pszRDn = NULL;
        hr = GetRDn(pURL, (dwNumComponents-1) - dwCtr, pszRDn, dwTotalLen);
        BAIL_ON_FAILURE(hr);
        if (*pszRDn) {
            wcscat(pszLocalDn, pszRDn);
            if (dwCtr != (dwNumComponents - 1)) {
                wcscat(pszLocalDn, L",");
            }
        } 
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // We must have the correct DN !
    //
    *pszDnStr = pszLocalDn;


error:

    if (FAILED(hr)) {
        if (pszLocalDn) {
            FreeADsMem(pszLocalDn);
        }
    }

    if (pszRDn) {
        FreeADsMem(pszRDn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UrlToLDAPPath - global scope, helper function.
//
// Synopsis:   This routine converts the URL to the 
//
// Arguments:  pURL            -  URL to be converted to path. Note
//                              that this can be native or Umi.
//             pszLDAPPath     -  Path is allocated into this var.
//             ppszDn          -  
//             ppszClass       -  Contains returned class name string. It
//                              is the callees responsiblity to free using 
//                              FreeADsStrResult.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszDN && *ppszClass.
//
//----------------------------------------------------------------------------
HRESULT
UrlToLDAPPath(
    IN  IUmiURL *pURL,
    OUT LPWSTR *ppszLDAPPath,
    OPTIONAL OUT LPWSTR *ppszDn,
    OPTIONAL OUT LPWSTR *ppszServer
    )
{
    HRESULT hr = S_OK;
    DWORD dwURLType = 0;
    DWORD dwLen = 1023;
    DWORD dwTxtLen = 1023;
    WCHAR pszTxt[1024];
    LPWSTR pszDn = NULL;
    LPWSTR pszLdapPath = NULL;
    BOOL fAddSlash = FALSE;
    ULONGLONG ululPathType = UMIPATH_INFO_INSTANCE_PATH;

    //
    // We need the type of the url, if it is an ldap native path.
    // For now though this support is not available. We assume that
    // this is a umi path for now.
    //
    
    //
    // Get the total length needed for the path.
    //
    hr = pURL->Get(0, &dwLen, pszTxt);
    // replace the correct error code below WBEM_E_BUFFER_TOO_SMALL
    if ((FAILED(hr) && (hr != 0x8004103c))
        || (dwLen == 0)) {
        //
        // Failure was either length was zero or error was someting
        // other than buffer too small.
        //
        BAIL_ON_FAILURE(hr);
    }

    dwLen++; // for the terminating \0.
    pszLdapPath = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
    if (!pszLdapPath) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = pURL->GetPathInfo(0, &ululPathType);
    BAIL_ON_FAILURE(hr);

    if (ululPathType == UMIPATH_INFO_NATIVE_STRING) {
        //
        // Just get the path in pszLdapPath and return.
        //
        hr = pURL->Get(0, &dwLen, pszLdapPath);
        BAIL_ON_FAILURE(hr);
    } 
    else {
    
    
        //
        // Make sure that the namespace is either LDAP or GC.
        // We bail on failure cause we cannot possibly have a locator
        // that is more than our buffer size !
        //
        hr = pURL->GetRootNamespace(&dwTxtLen, pszTxt);
        BAIL_ON_FAILURE(hr);
    
        if (!_wcsicmp(L"LDAP", pszTxt)) {
            wsprintf(pszLdapPath, L"%s", L"LDAP:");
        } 
        else if (!_wcsicmp(L"GC", pszTxt)) {
            wsprintf(pszLdapPath, L"%s", L"GC:");
        } 
        else {
            BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
        }
    
        //
        // We now need to add the server and the // if applicable.
        //
        dwTxtLen = 1023;
        hr = pURL->GetLocator(&dwTxtLen, pszTxt);
        if (hr == 0x8004103c) {
            //
            // Unexpected cause locator is too big !.
            //
            hr = E_FAIL;
        }
        BAIL_ON_FAILURE(hr);
    
        if (!wcscmp(pszTxt, L".")) {
            //
            // This would mean we are going serverless.
            //
            wcscat(pszLdapPath, L"/");
        } 
        else if (!*pszTxt)  {
            //
            // Means that we have the LDAP namespace or no server.
            //
            fAddSlash = TRUE;
        } 
        else {
            //
            // Add the // and the servername given.
            //
            wcscat(pszLdapPath, L"//");
            wcscat(pszLdapPath, pszTxt);
        }
    
        //
        // Now we need to get the DN and tag it along.
        //
        hr = GetDNFromURL(pURL, &pszDn, dwLen);
        BAIL_ON_FAILURE(hr);
    
        if (pszDn && *pszDn) {
            if (fAddSlash) {
                //
                // Serverless path.
                //
                wcscat(pszLdapPath, L"/");
            }
            //
            // Tag on the DN now, it will do the right thing for 
            // both server and serverless paths.
            //
            wcscat(pszLdapPath,L"/");
            wcscat(pszLdapPath,pszDn);
        }
    } // this was not a native path.

    *ppszLDAPPath = pszLdapPath;

error:

    if (FAILED(hr)) {
        if (pszLdapPath) {
            FreeADsMem(pszLdapPath);
        }
    }

    if (pszDn) {
        FreeADsMem(pszDn);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   ADsPathToUmiUrl - global scope, helper function.
//
// Synopsis:   This routine converts the ADsPath to UMI URL txt.
//
// Arguments:  ADsPath         -  Input string.
//             ppszUrlTxt      -  Output converted url txt.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszUrlTxt - to point to the correct 
//
//----------------------------------------------------------------------------
HRESULT
ADsPathToUmiURL(
    IN  LPWSTR ADsPath,
    OUT LPWSTR *ppszUrlTxt
    )
{
    HRESULT hr = S_OK;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD dwNumComponents = 0, dwCtr;
    LPWSTR pszUrl = NULL;
    BOOL fReverseOrder = TRUE;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    ADsAssert(ADsPath && ppszUrlTxt);
    *ppszUrlTxt = NULL;

    //
    // We build our ObjectInfo struct and then build the url
    // from the objectInfo struct.
    //
    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
    hr = ADsObject(ADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;
    //
    // We can make a guess as to the size we need for the string.
    //
    pszUrl = (WCHAR *) AllocADsMem(
                           ( sizeof(WCHAR) * wcslen(ADsPath) )
                           // for the actual name
                           + (sizeof(WCHAR) * dwNumComponents)
                           // for all the .'s we need as in .DC=test
                           + (sizeof(WCHAR) * 15)
                           );
    //
    // sizeof(WCHAR) * 15 has been added so that we can handle
    // the umi:// (6) which is extra + if we have a GC path, then 
    // we would need to add LDAP/ (5) just in case a small buffer
    // of 4 giving the 15
    //
    if (!pszUrl) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the umi:// in the output, then add the server if applicable,
    // then the LDAP/GC or LDAP alone as applicable.
    //
    wsprintf(pszUrl, L"%s", L"umi://");

    if (pObjectInfo->dwServerPresent) {
        if (pObjectInfo->TreeName) {
            wcscat(pszUrl, pObjectInfo->TreeName);
        }
    }

    wcscat(pszUrl, L"/"); // need if there is a server or not.
    wcscat(pszUrl, L"LDAP"); // needed if LDAP or GC.

    if (!_wcsicmp(pObjectInfo->ProviderName, szGCNamespaceName)) {
        wcscat(pszUrl, L"/GC");
    }

    //
    // This is to check if we were given an LDAP windows style path,
    // with reverse order rather than LDAP dn style path.
    //
    if (pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        //
        // Already reversed so just use the order directly.
        //
        for (dwCtr = 0; dwCtr < dwNumComponents; dwCtr++) {
            //
            // When you have a path like LDAP://RootDSE, then the szComponent
            // alone is set and not the value in these cases we need to 
            // build the path in a different manner.
            //
            if (pObjectInfo->ComponentArray[dwCtr].szValue) {

                wcscat(pszUrl, L"/.");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr].szComponent
                    );
                wcscat(pszUrl, L"=");
                wcscat(pszUrl, pObjectInfo->ComponentArray[dwCtr].szValue);
            } 
            else {
                //
                // We just have a component as in RootDSE or Schema so.
                //
                wcscat(pszUrl, L"/");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr].szComponent
                    );
            }
        }
    }
    else {
        //
        // Need to do this reverse order.
        //
        for (dwCtr = dwNumComponents; dwCtr > 0; dwCtr--) {
            //
            // When you have a path like LDAP://RootDSE, then the szComponent
            // alone is set and not the value in these cases we need to 
            // build the path in a different manner.
            //
            if (pObjectInfo->ComponentArray[dwCtr-1].szValue) {

                wcscat(pszUrl, L"/.");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr-1].szComponent
                    );
                wcscat(pszUrl, L"=");
                wcscat(pszUrl, pObjectInfo->ComponentArray[dwCtr-1].szValue);
            } 
            else {
                //
                // We just have a component as in RootDSE or Schema so.
                //
                wcscat(pszUrl, L"/");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr-1].szComponent
                    );
            }

        }
    }

    *ppszUrlTxt = pszUrl;

error:

    if (FAILED(hr)) {
        if (pszUrl) {
            FreeADsMem(pszUrl);
        }
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);
}


BOOL
IsPreDefinedErrorCode(HRESULT hr)
{
    switch (hr) {
    case E_UNEXPECTED :
    case E_NOTIMPL :
    case E_OUTOFMEMORY :
    case E_INVALIDARG :
    case E_NOINTERFACE :
    case E_HANDLE :
    case E_ABORT :
    case E_FAIL :
    case E_ACCESSDENIED :
    case E_PENDING :
    case E_POINTER :
    case UMI_E_CONNECTION_FAILURE :
    case UMI_E_TIMED_OUT :
    case UMI_E_TYPE_MISMATCH :
    case UMI_E_NOT_FOUND : 
    case UMI_E_INVALID_FLAGS : 
    case UMI_E_UNSUPPORTED_FLAGS :
    case UMI_E_SYNCHRONIZATION_REQUIRED :
    case UMI_E_UNSUPPORTED_OPERATION : 
    case UMI_E_TRANSACTION_FAILURE : 
        RRETURN(TRUE);
        break;

    default:
        RRETURN(FALSE);
        break;
    }
}

//+---------------------------------------------------------------------------
// Function:   MapHrToUmiError - global scope, helper function.
//
// Synopsis:   This routine converts the given hr to an equivalent umi err.
//
// Arguments:  hr      -   hr to convert to umi error.
//
// Returns:    HRESULT -   umi error code corresponing to hr passed in.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
MapHrToUmiError(HRESULT hr)
{
    HRESULT retHr = hr;

    if (IsPreDefinedErrorCode(hr)) {
        RRETURN(hr);
    }

    switch (hr) {

    case E_ADS_INVALID_DOMAIN_OBJECT:
    case E_ADS_INVALID_USER_OBJECT:
    case E_ADS_INVALID_COMPUTER_OBJECT:
    case E_ADS_UNKNOWN_OBJECT:
        retHr = UMI_E_NOT_FOUND;
        break;

    case E_ADS_PROPERTY_NOT_FOUND:
        retHr = UMI_E_NOT_FOUND;
        break;

    case E_ADS_BAD_PARAMETER:
        retHr = E_INVALIDARG;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:
        retHr = UMI_E_TYPE_MISMATCH;
        break;

    case E_ADS_BAD_PATHNAME:
        retHr = E_INVALIDARG;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) :
        // LDAP_NO_SUCH_ATTRIBUTE
        retHr = UMI_E_NOT_FOUND;
        break;
    
    case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) :
        // LDAP_NO_SUCH_OBJECT
        retHr = UMI_E_NOT_FOUND;
        break;

    default:
        retHr = E_FAIL;
        break;
    } // end of case
            
    RRETURN(retHr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  LDAP CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_LDAPOle, 0x228d9a80, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPProvider, 0x228d9a81, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPNamespace, 0x228d9a82, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPGenObject, 0x228d9a83, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPUser, 0x228d9a84, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPGroup, 0x228d9a85, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPSchema, 0x228d9a86, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPClass, 0x228d9a87, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPProperty, 0x228d9a88, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPSyntax, 0x228d9a89, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPLocality, 0x228d9a8A, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPO, 0x228d9a8B, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPOU, 0x228d9a8C, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPCountry, 0x228d9a8D, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPDomain, 0x228d9a8E, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPComputer, 0x228d9a8F, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPPrintQueue, 0x228d9a90, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  getobj.cxx
//
//  Contents:  LDAP GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

LPWSTR gpszStickyServerName = NULL;
LPWSTR gpszStickyDomainName = NULL;
//
// Dont do DsGetDCName with FORCE_DISCOVERY too frequently.
// LastVerifyDefaultServer is uses to track tick count.
//
#define  DC_NORETRY (1000 * 60 * 5)

DWORD LastVerifyDefaultServer = 0 ;

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetServerBasedObject(
    LPWSTR szBuffer,
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;

    TCHAR szNamespace[MAX_PATH];

    IADs *pADs = NULL;

    LPTSTR *aValues = NULL;
    LPTSTR *aValuesNamingContext = NULL;
    int nCount = 0;

    TCHAR *pszNewADsPath = NULL;
    LPWSTR pszNewADsParent = NULL;
    LPWSTR pszNewADsCommonName = NULL;

    LPWSTR pszNamingContext = NULL;

    TCHAR *pszLast = NULL;
    BOOL fVerify = FALSE ;

    DWORD dwPort = 0;
    ADS_LDP *ld = NULL;
    BOOL fGCDefaulted = FALSE;
    BOOL fNoDefaultNamingContext = FALSE;
    BOOL fFastBind = Credentials.GetAuthFlags() & ADS_FAST_BIND;

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is LDAP:
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    // Get the namespace name

    wcscpy(szNamespace, pObjectInfo->NamespaceName);
    wcscat(szNamespace, L":");

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_ROOTDSE:
        //
        // This means that this is a RootDSE object;
        // instantiate the RootDSE object
        //

        hr = GetRootDSEObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;


    case TOKEN_SCHEMA:
    case TOKEN_CLASS:
    case TOKEN_PROPERTY:
    case TOKEN_SYNTAX:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                pObjectInfo->PortNumber,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        hr = BuildLDAPPathFromADsPath2(
                    szBuffer,
                    &pszLDAPServer,
                    &pszLDAPDn,
                    &dwPort
                    );

        hr = LdapOpenObject2(
                        pszLDAPServer,
                        NULL,
                        NULL,
                        &ld,
                        Credentials,
                        dwPort
                        );
        BAIL_ON_FAILURE(hr);

        if ( pszLDAPDn  == NULL ) {

            // If only server name is specified, we need to
            // find the root of the naming context...

            if (dwPort == USE_DEFAULT_GC_PORT) {
                pszNamingContext = NULL;
                fGCDefaulted = TRUE;
            } else {
                pszNamingContext = TEXT(LDAP_OPATT_DEFAULT_NAMING_CONTEXT);
            }

            // We already have an open connection so we can do
            // fast read to avoid looking up the bind cache.
            if (!fGCDefaulted ) {

                hr = LdapReadAttributeFast(
                         ld,
                         NULL, // the DN is that of the RootDSE
                         pszNamingContext,
                         &aValuesNamingContext,
                         &nCount
                         );

                if (SUCCEEDED(hr) && (nCount < 1)) {
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                }
            }

            //
            // If we fail reading the naming context then we need to continue
            // if the error was no attribute or value, set some flags
            //
            if (FAILED(hr)) {

              if ( hr != HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) ) {

                  nCount = 1;
                  pszNamingContext = NULL;
                  hr = S_OK;
                  fNoDefaultNamingContext = TRUE;
                  fGCDefaulted = TRUE;
              }
            }
        
            BAIL_ON_FAILURE(hr);

            //
            // At this point we have either
            // 1) Valid defaultNamingContext and pszNamingContext
            // 2) Either a GC or a case where defaultNamingContext
            //   is not available - essentially just a null dn
            //

            hr = BuildADsPathFromLDAPPath2(
                     TRUE,               //Server is Present
                     szNamespace,
                     pszLDAPServer,
                     dwPort,
                     pszNamingContext ?
                        aValuesNamingContext[0] :
                        TEXT(""),
                     &pszNewADsPath
                     );
            BAIL_ON_FAILURE(hr);

            hr = BuildADsParentPath(
                      pszNewADsPath,
                      &pszNewADsParent,
                      &pszNewADsCommonName
                      );
            BAIL_ON_FAILURE(hr);


            if (pszLDAPServer) {
                FreeADsStr(pszLDAPServer);
                pszLDAPServer = NULL;
            }

            if (pszLDAPDn) {
                FreeADsStr(pszLDAPDn);
                pszLDAPDn = NULL;
            }

        //
        // Put the info from the new path build above into the
        // various components - matters if we are dealing with
        // a valid defaultNanmingContext
        //
        hr = BuildLDAPPathFromADsPath2(
             pszNewADsPath,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );

        }
        nCount = 0;

        // At this point we have a valid DN
        // so we can go ahead and do the a fast read rather than
        // just a plain read to avoid the overhead of looking upt
        // the bindcache.

        if (!fGCDefaulted && !fFastBind) {

            hr = LdapReadAttributeFast(
                     ld,
                     pszLDAPDn,
                     TEXT("objectClass"),
                     &aValues,
                     &nCount
                     );

            BAIL_ON_FAILURE(hr);

            if (nCount == 0) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
            }
        }

        if (fGCDefaulted) {

            //
            // This is either  GC://server, where we want to
        // set the object DN to null so that all
        // searches will yield correct results.
        // or the case of a server that did not have
        // a default naming context in the RootDSE
        //
        hr = CLDAPGenObject::CreateGenericObject(
                                     pszNewADsParent,
                                     pszNewADsCommonName,
                                     L"top",
                                     Credentials,
                                     ADS_OBJECT_BOUND,
                                     IID_IADs,
                                     (void **) &pADs
                                     );
        }
        else if (aValuesNamingContext ) {

            //
            // Need to create the object with new parent
            // and newADsCN
            //
            if (fFastBind) {
                hr = CLDAPGenObject::CreateGenericObject(
                            pszNewADsParent,
                            pszNewADsCommonName,
                            L"top",
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );

            } else {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszNewADsParent,
                            pszNewADsCommonName,
                            aValues,
                            nCount,
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );
                }

        } else {
            //
            // This is the default case where we build the info from
            // the data passed into GetObject call
            //
            hr = BuildADsParentPathFromObjectInfo2(
                        pObjectInfo,
                        &pszParent,
                        &pszCommonName
                        );
            BAIL_ON_FAILURE(hr);

            if (fFastBind) {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszParent,
                            pszCommonName,
                            L"top",
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );

            } else {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszParent,
                            pszCommonName,
                            aValues,
                            nCount,
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );
            }
        }

        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = pADs->QueryInterface(
                        IID_IUnknown,
                        ppObject
                        );

        BAIL_ON_FAILURE(hr);
        break;

    }

error:

    if ( ld ){
        LdapCloseObject( ld );
    }

    if (pADs)
        pADs->Release();

    if ( aValuesNamingContext )
        LdapValueFree( aValuesNamingContext );

    if ( aValues )
        LdapValueFree( aValues );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

     if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
     }

    if ( pszNewADsPath )
        FreeADsStr( pszNewADsPath );

    if (pszNewADsParent) {
       FreeADsStr(pszNewADsParent);
    }

    if (pszNewADsCommonName) {
       FreeADsStr(pszNewADsCommonName);
    }

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    WCHAR szNamespace[MAX_PATH];


    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    wsprintf(szNamespace,L"%s:", pObjectInfo->NamespaceName);

    hr = CLDAPNamespace::CreateNamespace(
                TEXT("ADs:"),
                szNamespace,
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetRootDSEObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetRootDSEObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    LPWSTR pszParent = NULL;
    LPWSTR pszCommonName = NULL;

    hr = ValidateRootDSEObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPathFromObjectInfo2(
                pObjectInfo,
                &pszParent,
                &pszCommonName
                );
    BAIL_ON_FAILURE(hr);

    hr = CLDAPRootDSE::CreateRootDSE(
                pszParent,
                pszCommonName,
                L"",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                (void **)ppObject
                );
error:

    if (pszParent) {
      FreeADsStr(pszParent);
    }

    if (pszCommonName) {
       FreeADsStr(pszCommonName);
    }


    RRETURN(hr);
}


HRESULT
ValidateRootDSEObject(
    POBJECTINFO pObjectInfo
    )
{
    if ( pObjectInfo->NumComponents > 1 )
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    RRETURN(S_OK);
}


HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (_tcsicmp(pObjectInfo->NamespaceName, szLDAPNamespaceName) == 0 ||
        _tcsicmp(pObjectInfo->NamespaceName, szGCNamespaceName) == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (_tcscmp(pObjectInfo->ProviderName, szProviderName) == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials&  Credentials,
    DWORD dwPort,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    TCHAR szDomainName[MAX_PATH];
    TCHAR szServerName[MAX_PATH];
    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;
    DWORD dwObjectType = 0;
    DWORD i,dwStatus;

    LDAP_SCHEMA_HANDLE hSchema = NULL;
    BOOL fFound = FALSE;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

   if (pObjectInfo->TreeName) {
      _tcscpy(szDomainName, pObjectInfo->TreeName);

   }else {

      LPTSTR aAddresses[5];
      DWORD nCount = 5;
      BOOL fVerify = FALSE;

      dwStatus = GetDefaultServer(
                     dwPort,
                     fVerify,
                     szDomainName,
                     szServerName,
                     TRUE
                     );

      if (dwStatus) {
          hr = HRESULT_FROM_WIN32(dwStatus);
          BAIL_ON_FAILURE(hr);
      }
   }

    hr = SchemaOpen(
             szDomainName,
             &hSchema,
             Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPathFromObjectInfo2(
             pObjectInfo,
             &pszParent,
             &pszCommonName
             );
    BAIL_ON_FAILURE(hr);

    switch (dwObjectType) {

    case LDAP_SCHEMA_ID:
        hr = CLDAPSchema::CreateSchema(
                    pszParent,
                    pszCommonName,
                    szDomainName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case LDAP_CLASS_ID:
    {
        CLASSINFO *pClassInfo = NULL;

        if ( pObjectInfo->NumComponents < 2 )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given class name
        //

        if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
                hr = SchemaGetClassInfo(
                     hSchema,
                     pObjectInfo->ComponentArray[1].szComponent,
                    &pClassInfo );
        }else {
              hr = SchemaGetClassInfo(
                        hSchema,
                        pObjectInfo->ComponentArray[0].szComponent,
                        &pClassInfo);
        }

        if ( SUCCEEDED(hr))
        {
            if ( pClassInfo == NULL )  // could not find the class name
            {
                // Do not bail on failure here since we might need to fall
                // through to the property case.

                hr = E_ADS_BAD_PATHNAME;
            }
        }

        if ( SUCCEEDED(hr))
        {
            //
            // Class name found, create and return the object
            //
            hr = CLDAPClass::CreateClass( pszParent,
                                          hSchema,
                                          pClassInfo->pszName,
                                          pClassInfo,
                                          Credentials,
                                          ADS_OBJECT_BOUND,
                                          IID_IUnknown,
                                          ppObject );
        }

        if ( SUCCEEDED(hr)
           || ( pObjectInfo->ObjectType == TOKEN_CLASS )
           )
        {
            BAIL_ON_FAILURE(hr);
            break;
        }
        hr = S_OK;
        // Else the exact type was not specified and we guessed it to be class
        // but since CreateClass failed, we need to try and see if it is a
        // property object. Hence, falls through
    }

    case LDAP_PROPERTY_ID:
    {
        PROPERTYINFO *pPropertyInfo = NULL;

        if ( pObjectInfo->NumComponents < 2)
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given property name
        //


        if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
            hr = SchemaGetPropertyInfo(
                     hSchema,
                    pObjectInfo->ComponentArray[1].szComponent,
                    &pPropertyInfo );
        }else{
            hr = SchemaGetPropertyInfo(
                        hSchema,
                        pObjectInfo->ComponentArray[0].szComponent,
                        &pPropertyInfo
                        );

        }

        if ( SUCCEEDED(hr))
        {
            if ( pPropertyInfo == NULL ) // could not find the property name
            {
                // Do not bail on failure here since we might need to fall
                // through to the syntax case.

                hr = E_ADS_BAD_PATHNAME;
            }
        }

        if ( SUCCEEDED(hr))
        {
            //
            // Property name found, so create and return the object
            //
            hr = CLDAPProperty::CreateProperty(
                                     pszParent,
                                     hSchema,
                                     pPropertyInfo->pszPropertyName,
                                     pPropertyInfo,
                                     Credentials,
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     ppObject );
        }

        if ( SUCCEEDED(hr)
           || ( pObjectInfo->ObjectType == TOKEN_PROPERTY )
           )
        {
            BAIL_ON_FAILURE(hr);
            break;
        }
        hr = S_OK;
        // Else the exact type was not specified and we guessed it to be
        // property but since CreateProperty failed, we need to try and see if
        // it is a syntax object. Hence, falls through
    }

    case LDAP_SYNTAX_ID:
        if ( pObjectInfo->NumComponents < 2 )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given syntax name
        //

        for ( i = 0; i < g_cLDAPSyntax; i++ )
        {
            if ( _tcsicmp( g_aLDAPSyntax[i].pszName,
                       (pObjectInfo->dwPathType == PATHTYPE_WINDOWS)?
                       pObjectInfo->ComponentArray[1].szComponent:
                       pObjectInfo->ComponentArray[0].szComponent ) == 0 )
                break;
        }

        if ( i == g_cLDAPSyntax )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Syntax name found, create and return the object
        //

        hr = CLDAPSyntax::CreateSyntax(
                  pszParent,
                  &(g_aLDAPSyntax[i]),
                  Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IUnknown,
                  ppObject
                  );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;

    }

error:

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    if ( hSchema )
        SchemaClose( &hSchema );

    RRETURN(hr);
}

HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;

    switch ( pObjectInfo->ObjectType )
    {

    case TOKEN_CLASS:
        *pdwObjectType = LDAP_CLASS_ID;
        break;

    case TOKEN_SYNTAX:
        *pdwObjectType = LDAP_SYNTAX_ID;
        break;

    case TOKEN_PROPERTY:
        *pdwObjectType = LDAP_PROPERTY_ID;
        break;

    case TOKEN_SCHEMA:
        dwNumComponents = pObjectInfo->NumComponents;

        switch (dwNumComponents) {

        case 1:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,
                          SCHEMA_NAME))
                *pdwObjectType = LDAP_SCHEMA_ID;
            break;

        case 2:

            if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
                if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,
                              SCHEMA_NAME))
                    *pdwObjectType = LDAP_CLASS_ID;

                    // Might also be a property or syntax object
                    // see function GetSchemaObject()
                }else {
                    if (!_tcsicmp(pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent,
                                  SCHEMA_NAME))
                        *pdwObjectType = LDAP_CLASS_ID;

                        // Might also be a property or syntax object
                        // see function GetSchemaObject()
                }

            break;

        default:
            hr = E_FAIL;
            break;
        }
        break;


    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    if ( pObjectInfo->ObjectType != TOKEN_LDAPOBJECT )
    {
        // The type has already been specified in this case using COMMA
        RRETURN(S_OK);
    }

    if (  pObjectInfo->NamespaceName
       && !pObjectInfo->TreeName
       && !pObjectInfo->NumComponents
       )
    {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }
    else if (  pObjectInfo->NamespaceName
            && pObjectInfo->TreeName
            && pObjectInfo->NumComponents)
    {

        switch (pObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,ROOTDSE_NAME))
                     pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;


        case PATHTYPE_X500:
        default:
            if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;

        }


    }else if (  pObjectInfo->NamespaceName
            && !pObjectInfo->TreeName
            && pObjectInfo->NumComponents)
    {
        switch (pObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;


        case PATHTYPE_X500:
        default:
            if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;

        }

    }

    RRETURN(S_OK);
}


HRESULT
GetServerLessBasedObject(
    LPWSTR szBuffer,
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = NO_ERROR;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;

    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;

    TCHAR szADsClassName[64];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    WCHAR *pszServerName=NULL;

    IADs *pADs = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;

    TCHAR *pszLast = NULL;
    BOOL fVerify = FALSE ;

    DWORD dwPort = 0;
    ADS_LDP *ld = NULL;

    BOOL fFastBind = Credentials.GetAuthFlags() & ADS_FAST_BIND;
    BOOL fUseSpecifiedServer = (gpszStickyServerName != NULL);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is LDAP:
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                       pObjectInfo,
                       Credentials,
                       ppObject
                       );
        BAIL_ON_FAILURE(hr);
        break;

    case TOKEN_ROOTDSE:
       //
       // This means taht this is a namespace object;
       // instantiate the namespace object
       //
       hr = GetRootDSEObject(
               pObjectInfo,
               Credentials,
               ppObject
               );
       BAIL_ON_FAILURE(hr);
       break;

    case TOKEN_SCHEMA:
    case TOKEN_CLASS:
    case TOKEN_PROPERTY:
    case TOKEN_SYNTAX:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                pObjectInfo->PortNumber,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        if ( pObjectInfo->TreeName == NULL )
        {
            LPTSTR pszName;
            LPTSTR aAddresses[5];

            //
            // fVerify is initially FALSE. If TRUE DsGetDCName will hit the net.
            //

RetryGetDefaultServer:

            dwStatus = GetDefaultServer(
                           pObjectInfo->PortNumber,
                           fVerify,
                           szDomainName,
                           szServerName,
                           TRUE
                           );
            if (dwStatus) {
                hr = HRESULT_FROM_WIN32(dwStatus);
                BAIL_ON_FAILURE(hr);
            }
            pszServerName=szServerName;

            if (fUseSpecifiedServer) {
                //
                // We need to change the name of the domain to be that of
                // the server we want to target. The swap is made if
                // 1) gpszDomainName == NULL, that implies that just
                // a serverName was set and not which domain it applies to.
                // 2) If a domainName is specified, then the domainName
                // from above should be that set in the global pointer for
                // the target server to be changed.
                //
                if ((gpszStickyDomainName
                     && (!_wcsicmp(szDomainName, gpszStickyDomainName))
                     )
                    || (gpszStickyDomainName == NULL)
                    ) {
                    //
                    // We need to change the target to the server.
                    //
                    wcscpy(szDomainName,gpszStickyServerName);
                    pszServerName = NULL;
                    //
                    // Make sure if server is down we go to another
                    // server on the retryGetDefault server path.
                    //
                    fUseSpecifiedServer = FALSE;
                }

            }

            hr = BuildLDAPPathFromADsPath2(
                        szBuffer,
                        &pszLDAPServer,
                        &pszLDAPDn,
                        &dwPort
                        );

            nCount = 0;

            // We need to open object here because we want to
            // keep the handle open, read will open/close if there
            // are no outstanding connections which is likely the case
            hr = LdapOpenObject2(
                     szDomainName,
                     pszServerName,
                     pszLDAPDn,
                     &ld,
                     Credentials,
                     dwPort
                     );

            if (SUCCEEDED(hr) && !fFastBind) {

                hr = LdapReadAttributeFast(
                         ld,
                         pszLDAPDn,
                         TEXT("objectClass"),
                         &aValues,
                         &nCount
                         );

                BAIL_ON_FAILURE(hr);

            }

            //
            // If server not present and we have NOT tried with fVerify
            // set to TRUE.
            //
            if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
                 (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN)))
                        && !fVerify)
            {
                DWORD Last = LastVerifyDefaultServer ;
                DWORD Current = GetTickCount() ;

                //
                // If tick is zero, assume first time. In the very unlikely
                // event we wrapped managed to get exactly zero, we pay the
                // cost of the DsGetDcName (with verify).
                //
                if ((Last == 0) ||
                    ((Last <= Current) && ((Current-Last) > DC_NORETRY)) ||
                    ((Last >  Current) &&
                        ((Current+(((DWORD)(-1))- Last)) > DC_NORETRY))) {


                    //
                    // Set the time. Note this is not critical section
                    // protected and in this case it is not necessary.
                    //
                    LastVerifyDefaultServer = GetTickCount() ;

                    fVerify = TRUE ;

                    goto RetryGetDefaultServer ;
                }
            }
        }

        BAIL_ON_FAILURE(hr);

        if ( (nCount == 0) && !fFastBind)
        {
            // This object exists but does not have an objectClass. We
            // can't do anything without the objectClass. Hence, return
            // bad path error.
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        hr = BuildADsParentPathFromObjectInfo2(
                    pObjectInfo,
                    &pszParent,
                    &pszCommonName
                    );
        BAIL_ON_FAILURE(hr);

        if (fFastBind) {

            hr = CLDAPGenObject::CreateGenericObject(
                        pszParent,
                        pszCommonName,
                        L"Top",
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs,
                        fFastBind
                       );

        } else {

            hr = CLDAPGenObject::CreateGenericObject(
                        pszParent,
                        pszCommonName,
                        aValues,
                        nCount,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs,
                        fFastBind
                       );

        }

        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = pADs->QueryInterface(
                        IID_IUnknown,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    }

error:

    if (pADs)
        pADs->Release();

    if ( aValues )
        LdapValueFree( aValues );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

     if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
     }

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    // If ld is open, we need to close it, note that if the object
    // was created successfuly, the Generic object created will have
    // the outstanding reference, if not the connection will be torn
    // down as should be expected.
    if (ld) {
        LdapCloseObject(ld);
    }


    RRETURN(hr);
}


HRESULT
GetObject(
    LPTSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
      HRESULT hr = S_OK;
      OBJECTINFO ObjectInfo;
      POBJECTINFO pObjectInfo = &ObjectInfo;

      if (!szBuffer || !ppObject) {
        hr = E_INVALIDARG;
        RRETURN_EXP_IF_ERR(hr);
      }

      memset(pObjectInfo, 0, sizeof(OBJECTINFO));
      pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
      hr = ADsObject(szBuffer, pObjectInfo);
      BAIL_ON_FAILURE(hr);

      switch (pObjectInfo->dwServerPresent) {

      case TRUE:
         hr = GetServerBasedObject(
                       szBuffer,
                       pObjectInfo,
                       Credentials,
                       ppObject
                       );
        break;

      case FALSE:
         hr = GetServerLessBasedObject(
                     szBuffer,
                     pObjectInfo,
                     Credentials,
                     ppObject
                     );

      }

      BAIL_ON_FAILURE(hr);


error:

      if (pObjectInfo) {
         FreeObjectInfo(pObjectInfo);
      }

      RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

    if (pExtensionHead)
    {
        pClassEntry->pExtensionHead = pExtensionHead;
    }
    else
    {
        //
        // There are no values under the key
        //
        FreeADsMem(pClassEntry);
        pClassEntry = NULL;
    }

CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object to inner object -> inner object self destroyed.
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    //
    // Initialize global extensions list if not already
    // initialized.  Note that this takes place inside the
    // g_ExtCritSect to protect against multiple threads trying
    // to simultaneously initialize it.
    //
    if (!gpClassHead) {
        gpClassHead = BuildClassesList();
    }

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//+------------------------------------------------------------------------
//
//  Function:   ADSIAppendToExntesionList
//
//  Synopsis:   Adds to the end of the current class entry,
//           the extensions of the class pszClassName. This is
//           used in scenarios as follows - suppose fooUser
//           is derived from User, then we want to load the extensions
//           defined for User too apart from the extensions available
//           directly on fooUser.
//
//              The first cut is not going to see if the class is already
//           there in the list. This optimization can be done later if
//           needed.
//
//  Arguments:  [pszClassName]      -- name of class.
//              [ppClassEntry]      -- class entry returned
//
//              The class entry will be modified only if there were no
//           entries, if not we will append the new entry at the end.
//           AjayR 11-17-98 (added)
//-------------------------------------------------------------------------
HRESULT
ADSIAppendToExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pLocalExtEntry = NULL;
    PCLASS_ENTRY pLocClassEntry = NULL;


    //
    // Check if there are no extensions on the list
    //
    if (!*ppClassEntry) {
        RRETURN(ADSIGetExtensionList(pszClassName, ppClassEntry));
    }

    pLocalExtEntry = (*ppClassEntry)->pExtensionHead;
    while(pLocalExtEntry->pNext) {
        pLocalExtEntry = pLocalExtEntry->pNext;
    }

    //
    // Now get the extension list for the current class
    //
    hr = ADSIGetExtensionList(pszClassName, &pLocClassEntry);

    if (FAILED(hr)) {
        //
        // not a critical failure
        //
        hr = S_OK;
    }
    else {
        //
        // Add to the end of the current list.
        //
        if (pLocClassEntry) {

            pLocalExtEntry->pNext = pLocClassEntry->pExtensionHead;

            FreeADsMem((void*)pLocClassEntry);
        }
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for LDAP guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// LDAPOle CLSIDs
//
//-------------------------------------------


//
// LDAPOle objects
//

extern const CLSID LIBID_LDAPOle;

extern const CLSID CLSID_LDAPProvider;

extern const CLSID CLSID_LDAPNamespace;

extern const CLSID CLSID_LDAPGenObject;

extern const CLSID CLSID_LDAPUser;

extern const CLSID CLSID_LDAPGroup;

extern const CLSID CLSID_LDAPSchema;

extern const CLSID CLSID_LDAPClass;

extern const CLSID CLSID_LDAPProperty;

extern const CLSID CLSID_LDAPSyntax;

extern const CLSID CLSID_LDAPLocality;

extern const CLSID CLSID_LDAPO;

extern const CLSID CLSID_LDAPOU;

extern const CLSID CLSID_LDAPCountry;

extern const CLSID CLSID_LDAPDomain;

extern const CLSID CLSID_LDAPComputer;

extern const CLSID CLSID_LDAPPrintQueue;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldap2.h ===
#define LDAP_LIBIID_LDAPOle        228D9A80-C302-11cf-9AA4-00AA004A5691
#define DBGUID_LDAPDialect         83889f20-07d5-11d0-831a-00aa00b505db

#define LDAP_CLSID_LDAPProvider    228D9A81-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPNamespace   228D9A82-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGenObject   228D9A83-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPUser        228D9A84-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGroup       228D9A85-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSchema      228D9A86-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPClass       228D9A87-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPProperty    228D9A88-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSyntax      228D9A89-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPLocality    228D9A8A-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPO           228D9A8B-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPOU          228D9A8C-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPCountry     228D9A8D-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPDomain      228D9A8E-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPComputer    228D9A8F-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPPrintQueue  228D9A90-C302-11cf-9AA4-00AA004A5691

#define LDAP_CLSID_DSOObject       549365d0-ec26-11cf-8310-00aa00b505db
#define LDAP_CLSID_MSDATT          2dbed740-0819-11d0-831a-00aa00b505db
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapres.h ===
#define LDAP_PROVIDER_ID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldap2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldap2var.cxx
//
//  Contents:   LDAP Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Jun-96   yihsins  Created.
//
//
//  Issues:
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// LdapType objects copy code
//

HRESULT
LdapTypeToVarTypeString(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;

    pVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
             LDAPOBJECT_STRING(pLdapSrcObject),
             &(pVarDestObject->bstrVal)
             );

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeBoolean(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    pVarDestObject->vt = VT_BOOL;

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 )
    {
        pVarDestObject->boolVal = VARIANT_TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 )
    {
        pVarDestObject->boolVal = VARIANT_FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;

    pVarDestObject->vt = VT_I4;

    pVarDestObject->lVal = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);
}


HRESULT
LdapTypeToVarTypeSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    BOOL fNTDS = TRUE;

    pVarDestObject->vt = VT_DISPATCH;

    hr = ReadServerType(
             pszServerName,
             &Credentials,
             &fNTDS
             );
    BAIL_ON_FAILURE(hr);


    hr = ConvertSecDescriptorToVariant(
                pszServerName,
                Credentials,
                LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
                pVarDestObject,
                fNTDS
                );

error:

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeLargeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;
   LARGE_INTEGER largeint;

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   swscanf (LDAPOBJECT_STRING(pLdapSrcObject), L"%I64d", &largeint);

   hr = pLargeInteger->put_LowPart(largeint.LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(largeint.HighPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   V_VT(pVarDestObject) = VT_DISPATCH;
   V_DISPATCH(pVarDestObject) =  pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }
   RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithBinary *pDNWithBinary = NULL;
    IDispatch *pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    BSTR bstrTemp = NULL;

    memset(&AdsValue, 0, sizeof(AdsValue));

    hr = CoCreateInstance(
             CLSID_DNWithBinary,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithBinary,
             (void **) &pDNWithBinary
             );
    BAIL_ON_FAILURE(hr);


    //
    // Convert the ldapString to an adsvalue and then take it
    // to DNWithBinary object
    //
    hr = LdapTypeToAdsTypeDNWithBinary(
             pLdapSrcObject,
             &AdsValue
             );

    BAIL_ON_FAILURE(hr);

    if (AdsValue.pDNWithBinary->pszDNString) {
        hr = ADsAllocString(AdsValue.pDNWithBinary->pszDNString, &bstrTemp);
        BAIL_ON_FAILURE(hr);

        //
        // Put the value in the object - we can only set BSTR's
        //
        hr = pDNWithBinary->put_DNString(bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = AdsValue.pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, AdsValue.pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    hr = pDNWithBinary->put_BinaryValue(*pVarDestObject);
    VariantClear(pVarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) &pDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pDispatch;

error:

    if (pDNWithBinary) {
        pDNWithBinary->Release();
    }

    if (AdsValue.pDNWithBinary) {
        if (AdsValue.pDNWithBinary->lpBinaryValue) {
            FreeADsMem(AdsValue.pDNWithBinary->lpBinaryValue);
        }

        if (AdsValue.pDNWithBinary->pszDNString) {
            FreeADsStr(AdsValue.pDNWithBinary->pszDNString);
        }
        FreeADsMem(AdsValue.pDNWithBinary);
    }

    if (bstrTemp) {
        ADsFreeString(bstrTemp);
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithString *pDNWithString = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrStrVal = NULL;
    BSTR bstrDNVal = NULL;

    memset(&AdsValue, 0, sizeof(AdsValue));

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pDNWithString
             );
    BAIL_ON_FAILURE(hr);


    //
    // Convert the ldapString to an adsvalue and then take it
    // to DNWithString object
    //
    hr = LdapTypeToAdsTypeDNWithString(
             pLdapSrcObject,
             &AdsValue
             );

    BAIL_ON_FAILURE(hr);

    if (AdsValue.pDNWithString->pszDNString) {
        hr = ADsAllocString(AdsValue.pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (AdsValue.pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 AdsValue.pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) &pDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pDispatch;

error:

    if (pDNWithString) {
        pDNWithString->Release();
    }

    if (AdsValue.pDNWithString) {
        if (AdsValue.pDNWithString->pszStringValue) {
            FreeADsStr(AdsValue.pDNWithString->pszStringValue);
        }

        if (AdsValue.pDNWithString->pszDNString) {
            FreeADsStr(AdsValue.pDNWithString->pszDNString);
        }
        FreeADsMem(AdsValue.pDNWithString);
    }

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}



HRESULT
LdapTypeToVarTypeBinaryData(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeUTCTime(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    int nSuccess = 0;
    ADSVALUE AdsValue;

    pVarDestObject->vt = VT_DATE;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeUTCTime(
        pLdapSrcObject,
        &AdsValue);
    BAIL_ON_FAILURE(hr);

    nSuccess = SystemTimeToVariantTime(
                    &AdsValue.UTCTime,
                    &pVarDestObject->date
                    );
    if (!nSuccess) {
        hr =E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeGeneralizedTime(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    BOOL fSuccess = FALSE;
    ADSVALUE AdsValue;

    pVarDestObject->vt = VT_DATE;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeGeneralizedTime(
        pLdapSrcObject,
        &AdsValue);
    BAIL_ON_FAILURE(hr);

    fSuccess = SystemTimeToVariantTime(
                   &AdsValue.UTCTime,
                   &pVarDestObject->date);
    if (!fSuccess) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

error:
    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeCopy(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PLDAPOBJECT pLdapSrcObject,
    DWORD       dwSyntaxId,
    PVARIANT    pVarDestObject
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {

        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        //
        // These types are treatable as strings
        // (see RFCs 2252, 2256)
        //
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = LdapTypeToVarTypeString(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = LdapTypeToVarTypeBoolean(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = LdapTypeToVarTypeInteger(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;


        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            hr = LdapTypeToVarTypeBinaryData(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = LdapTypeToVarTypeGeneralizedTime(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = LdapTypeToVarTypeUTCTime(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;


    case LDAPTYPE_SECURITY_DESCRIPTOR:
        hr = LdapTypeToVarTypeSecDes(
                    pszServerName,
                    Credentials,
                    pLdapSrcObject,
                    pVarDestObject
                    );
        break;

    case LDAPTYPE_INTEGER8:
        hr = LdapTypeToVarTypeLargeInteger(
                    pLdapSrcObject,
                    pVarDestObject
                    );
        break;

#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = LdapTypeToVarTypeDNWithBinary(
                     pLdapSrcObject,
                     pVarDestObject
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = LdapTypeToVarTypeDNWithString(
                     pLdapSrcObject,
                     pVarDestObject
                     );

            break;

        default:

            //
            // LDAPTYPE_UNKNOWN  (schemaless server property) will be
            // not be converted.
            //

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);

}


HRESULT
LdapTypeToVarTypeCopyConstruct(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    LDAPOBJECTARRAY ldapSrcObjects,
    DWORD dwSyntaxId,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = ldapSrcObjects.dwCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) ldapSrcObjects.dwCount; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = LdapTypeToVarTypeCopy(
                    pszServerName,
                    Credentials,
                    ldapSrcObjects.pLdapObjects + i,
                    dwSyntaxId,
                    &v
                    );


        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);

        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}


//
// Use this if the object needs to go on the wire to
// get any of the core properties (will be case for FAST_BIND
// and GUID in all cases). Also takes care of <WkGuid=...> case.
//
#define DEFINE_IADs_Shorter_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}





#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


/* Macro to call the ADsSetLastError function */
#define Macro_ClearADsLastError(providerString)                             \
ADsSetLastError(NO_ERROR, NULL, providerString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\namecf.cxx ===
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNameTranslateCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslateCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNameTranslate::CreateNameTranslate(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldap2umi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ldap2umi.cxx
//
//  Contents: File containing the implemenation of the conversion routines
//       that conver the cached ldap values to UMI data types.
//       LdapTypeToUMITypeCopyConstruct. 
//
//  History:    02-14-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   ConvertLdapSyntaxIdToUmiType.
//
// Synopsis:   Converts the ldapsyntaxId to the corresponding Umi type.
//
//
// Arguments:  dwLdapSyntax    -   Input ldapSyntaxId to convert.
//             uUmiType        -   Reference to return value.
//
// Returns:    HRESULT - S_OK or any failure code.
//
// Modifies:   uUmiType.
//
//----------------------------------------------------------------------------
HRESULT 
ConvertLdapSyntaxIdToUmiType(
    DWORD dwLdapSyntaxId,
    ULONG &uUmiType
    )
{
    HRESULT hr = S_OK;

    switch (dwLdapSyntaxId) {
    
    case LDAPTYPE_BITSTRING:
    case LDAPTYPE_PRINTABLESTRING:
    case LDAPTYPE_DIRECTORYSTRING:
    case LDAPTYPE_COUNTRYSTRING:
    case LDAPTYPE_DN:
    case LDAPTYPE_NUMERICSTRING:
    case LDAPTYPE_IA5STRING:
    case LDAPTYPE_CASEIGNORESTRING:
    case LDAPTYPE_CASEEXACTSTRING:
//    case LDAPTYPE_CASEIGNOREIA5STRING:
    case LDAPTYPE_OID:
    case LDAPTYPE_TELEPHONENUMBER:
    case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
    case LDAPTYPE_OBJECTCLASSDESCRIPTION:

    case LDAPTYPE_DELIVERYMETHOD:
    case LDAPTYPE_ENHANCEDGUIDE:
    case LDAPTYPE_FACSIMILETELEPHONENUMBER:
    case LDAPTYPE_GUIDE:
    case LDAPTYPE_NAMEANDOPTIONALUID:
    case LDAPTYPE_POSTALADDRESS:
    case LDAPTYPE_PRESENTATIONADDRESS:
    case LDAPTYPE_TELEXNUMBER:
    case LDAPTYPE_DSAQUALITYSYNTAX:
    case LDAPTYPE_DATAQUALITYSYNTAX:
    case LDAPTYPE_MAILPREFERENCE:
    case LDAPTYPE_OTHERMAILBOX:
    case LDAPTYPE_ACCESSPOINTDN:
    case LDAPTYPE_ORNAME:
    case LDAPTYPE_ORADDRESS:
        uUmiType = UMI_TYPE_LPWSTR;
        break;
    
    case LDAPTYPE_BOOLEAN:
        uUmiType = UMI_TYPE_BOOL;
        break;
    
    case LDAPTYPE_INTEGER:
        uUmiType = UMI_TYPE_I4;
        break;
    
    case LDAPTYPE_OCTETSTRING:
    case LDAPTYPE_CERTIFICATE:
    case LDAPTYPE_CERTIFICATELIST:
    case LDAPTYPE_CERTIFICATEPAIR:
    case LDAPTYPE_PASSWORD:
    case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
    case LDAPTYPE_AUDIO:
    case LDAPTYPE_JPEG:
    case LDAPTYPE_FAX:
        uUmiType = UMI_TYPE_OCTETSTRING;
        break;
    
    case LDAPTYPE_GENERALIZEDTIME:  
        uUmiType = UMI_TYPE_SYSTEMTIME;
        break;
    
    case LDAPTYPE_UTCTIME:
        uUmiType = UMI_TYPE_SYSTEMTIME;
        break;
    
    case LDAPTYPE_SECURITY_DESCRIPTOR:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    case LDAPTYPE_INTEGER8:
        uUmiType = UMI_TYPE_I8;
        break;
    
    case LDAPTYPE_DNWITHBINARY:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    case LDAPTYPE_DNWITHSTRING:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    default:

        //
        // LDAPTYPE_UNKNOWN  (schemaless server property) will be
        // not be converted.
        //
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;
    } // end of switch.

    RRETURN(hr);
}

//
// Note about functions in this file and the difference between the functions
// in Ldap2var.cxx. In that file, we allocate everything into variants
// and then we put all the variants in a safe array.
// The functions in this file are also different from those in 
// ldapc\ldap2ods.cxx in that each of the actual conversion routines deals 
// with a native data type rather than the UMI_VALUE as a whole (or ADSVALUE
// in the case of ldap2ods.cxx). This is because in UMI_VALUE's each UMI_VALUE
// struct can contain an array in itself, so you do not need multiple
// UMI_VALUE's to represent all values of an attribute.
//

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeLPWSTR
//
// Synopsis:   Converts an ldap string value to a LPWSTR. Note that the
//        output is not a UMI_VALUE but a string.   
//
// Arguments:  Self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pszUmiString to point to the string being copied.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeLPWSTR(
    PLDAPOBJECT pLdapSrcObject,
    LPWSTR *pszUmiString
    )
{
    HRESULT hr = S_OK;
    
    ADsAssert(pszUmiString);

    //
    // We should not have NULL values but it is a good idea to check.
    //
    if (LDAPOBJECT_STRING(pLdapSrcObject)) {
        *pszUmiString = AllocADsStr(LDAPOBJECT_STRING(pLdapSrcObject));
    
        if (!pszUmiString) {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyStrings
//
// Synopsis:   Converts the ldap source objects into an array of strings
//            and assigns the array to the values in the UMI_VALUE *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the string array.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyStrings(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    LPWSTR *pszStrArray = NULL;
    LPWSTR pszTmpString = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pszStrArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * dwCount);
    
    if (!pszStrArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeLPWSTR(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &pszTmpString
                 );
        if (SUCCEEDED(hr)) {
            pszStrArray[dwCtr] = pszTmpString;
            pszTmpString = NULL;
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pszStrArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    //
    // Do not think this is really necessary but cannot hurt.
    //
    if (pszTmpString) {
        FreeADsStr(pszTmpString);
    }

    if (pszStrArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pszStrArray[dwCtr-1]) {
                    FreeADsStr(pszStrArray[dwCtr-1]);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pszStrArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeBool
//
// Synopsis:   Converts an ldap boolean value to a BOOL value
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pfBool points to the returned value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeBool(
    PLDAPOBJECT pLdapSrcObject,
    PBOOL pfBool
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    ADsAssert(pfBool);

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 ) {
        *pfBool = TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 ) {
        *pfBool = FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyBooleans
//
// Synopsis:   Converts the ldap source objects into an array of booleans
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of bools.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyBooleans(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    BOOL *pfBoolArray = NULL;
    BOOL fTempVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pfBoolArray = (BOOL *) AllocADsMem(sizeof(BOOL) * dwCount);
    
    if (!pfBoolArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeBool(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &fTempVal
                 );
        if (SUCCEEDED(hr)) {
            pfBoolArray[dwCtr] = fTempVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pfBoolArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pfBoolArray) {
        FreeADsMem( (void *) pfBoolArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeInteger
//
// Synopsis:   Converts an ldap boolean value to a BOOL value. It appears
//        that if _ttol fails, there is no real way to tell cause 0 is
//        returned in that case. There is no way to distinguish a value
//        0 coming back from ldap and 0 because the conversion failed. 
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLong points to the returned value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    LONG *pLong
    )
{
    HRESULT hr = S_OK;
    
    ADsAssert(pLong);

    *pLong = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyIntegers
//
// Synopsis:   Converts the ldap source objects into an array of integers
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of integers.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyIntegers(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    LONG *pLongArray = NULL;
    LONG lTempVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pLongArray = (LONG *) AllocADsMem(sizeof(LONG) * dwCount);
    
    if (!pLongArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeInteger(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &lTempVal
                 );
        if (SUCCEEDED(hr)) {
            pLongArray[dwCtr] = lTempVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pLongArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pLongArray) {
        FreeADsMem( (void *) pLongArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeOctetString
//
// Synopsis:   Converts an ldap security ber value to an octet string.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pOctetStr points to the returned binary blob value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeOctetString(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_OCTET_STRING pUmiOctetString
    )
{
    DWORD dwLength;

    dwLength = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

    pUmiOctetString->lpValue = (byte*)AllocADsMem(dwLength);
    pUmiOctetString->uLength = dwLength;

    if (!pUmiOctetString->lpValue) {
        RRETURN(E_OUTOFMEMORY);
    }

    memcpy( 
        pUmiOctetString->lpValue,
        LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
        dwLength
        );

    RRETURN(S_OK);

}



//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyOctetStrings
//
// Synopsis:   Converts the ldap source objects into an array of octet strings
//            and assigns the array to the values in the UMI_VALUE *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the octet string array.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyOctetStrings(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    PUMI_OCTET_STRING pOctetArray = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pOctetArray = (PUMI_OCTET_STRING) 
                      AllocADsMem(sizeof(UMI_OCTET_STRING) * dwCount);
    
    if (!pOctetArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeOctetString(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &pOctetArray[dwCtr]
                 );

    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pOctetArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    if (pOctetArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pOctetArray[dwCtr-1].lpValue) {
                    FreeADsMem(pOctetArray[dwCtr-1].lpValue);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pOctetArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeDNWithBinary
//
// Synopsis:   Converts ldap DNWithBinary data to a UMI_COM_OBJECT with
//          the interface IADsDNWithBinary.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if successful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    IADsDNWithBinary *pDNBin = NULL;

    VariantInit(&vVar);

    hr = LdapTypeToVarTypeDNWithBinary(
             pLdapSrcObject,
             &vVar
             );

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsDNWithBinary,
             (void **) &pDNBin
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pDNBin->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsDNWithBinary), sizeof(IID));

    pUmiComObject->pInterface = (void *) pDNBin;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeDNWithString
//
// Synopsis:   Converts ldap DNWithString data to a UMI_COM_OBJECT with
//          the interface IADsDNWithString.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if successful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    IADsDNWithString *pDNStr = NULL;

    VariantInit(&vVar);

    hr = LdapTypeToVarTypeDNWithString(
             pLdapSrcObject,
             &vVar
             );

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsDNWithString,
             (void **) &pDNStr
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pDNStr->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsDNWithString), sizeof(IID));

    pUmiComObject->pInterface = (void *) pDNStr;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeSecurityDescriptor
//
// Synopsis:   Converts an ldap security descriptor to an 
//         IADsSecurityDescriptor Com object. Note that this routine assumes
//         that we are dealing only with NT style SD's and that specifically
//         we do not have the old SS type SD's.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pCreds         -  Pointer to credentials (for conversion).
//             pszServerName  -  Name of server we got this blob from.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if succesful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeSecurityDescriptor(
    PLDAPOBJECT pLdapSrcObject,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    CCredentials creds;
    VARIANT vVar;
    IADsSecurityDescriptor *pSecDesc = NULL;

    VariantInit(&vVar);

    //
    // Update the credentials object with value passed in if applicable.
    //
    if (pCreds) {
        creds = *pCreds;
    }

    hr = ConvertSecDescriptorToVariant(
             pszServerName,
             creds,
             LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
             &vVar,
             TRUE // fNTDS type flag
             );
    BAIL_ON_FAILURE(hr);

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pSecDesc
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pSecDesc->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsSecurityDescriptor), sizeof(IID));

    pUmiComObject->pInterface = (void *) pSecDesc;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeComObjects
//
// Synopsis:   Converts the ldap data to the corresponding com objects.
//          This routine calls the individual conversion routines,
//          converting one object at a time and packages the result into
//          the output values.
//
// Arguments:  pLdapSrcObjects  -  raw ldap data that needs to be converted.
//             pCreds           -  Credentials used for SD's can be NULL.
//             pszServerName    -  Server Name again only for SD's NULL legal.
//             requiredIID      -  Tells us what type of COM_OBJECT to return.
//             pUmiProp         -  Return value.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the COM_OBJECT array.
//
//----------------------------------------------------------------------------
LdapTypeToUmiTypeCopyComObjects(
    LDAPOBJECTARRAY pLdapSrcObjects,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    IID requiredIID,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    PUMI_COM_OBJECT pComObjectArray = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pComObjectArray = (PUMI_COM_OBJECT) 
                      AllocADsMem(sizeof(UMI_COM_OBJECT) * dwCount);
    
    if (!pComObjectArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Call the appropriate conversion routine based on the
        // IID that we need to return.
        //
        if (requiredIID == IID_IADsSecurityDescriptor) {
            //
            // Copy over security descriptor.
            //
            hr = LdapTypeToUmiTypeSecurityDescriptor(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     pCreds,
                     pszServerName,
                     &pComObjectArray[dwCtr]
                     );
        } 
        else if (requiredIID == IID_IADsDNWithBinary) {
            //
            // Copy over the Dn With Binary object.
            //
            hr = LdapTypeToUmiTypeDNWithBinary(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &pComObjectArray[dwCtr]
                     );
        
        }
        else if (requiredIID == IID_IADsDNWithString) {
            //
            // Copy over the Dn With String object.
            //
            hr = LdapTypeToUmiTypeDNWithString(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &pComObjectArray[dwCtr]
                     );
        } 
        else {
            //
            // Got to be bad data.
            //
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE)
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pComObjectArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    if (pComObjectArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pComObjectArray[dwCtr-1].pInterface) {
                    //
                    // Releasing the object will delete it if appropriate.
                    //
                    ((IUnknown*)
                     pComObjectArray[dwCtr-1].pInterface)->Release();
                }

                if (pComObjectArray[dwCtr-1].priid) {
                    FreeADsMem((void *)pComObjectArray[dwCtr-1].priid);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pComObjectArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeI8
//
// Synopsis:   Converts an ldap security large integer to an I8.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pInt8 points to the returned large integer value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeI8(
    PLDAPOBJECT pLdapSrcObject,
    __int64 *pInt64
    )
{
    ADsAssert(pInt64);

    *pInt64 = _ttoi64(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyLargeIntegers
//
// Synopsis:   Converts the ldap source objects into an array of int64's
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of int64's.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyLargeIntegers(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    __int64 *pInt64Array = NULL;
    __int64 int64Val;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pInt64Array = (__int64 *) AllocADsMem(sizeof(__int64) * dwCount);
    
    if (!pInt64Array) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeI8(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &int64Val
                 );

        if (SUCCEEDED(hr)) {
            pInt64Array[dwCtr] = int64Val;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pInt64Array;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pInt64Array) {
        FreeADsMem( (void *) pInt64Array);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeTime
//
// Synopsis:   Converts an ldap time value to a SystemTime value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pSysTime points to the returned time value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeUTCTimeToUmiTypeTime(
    PLDAPOBJECT pLdapSrcObject,
    SYSTEMTIME *pSystemTime
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;

    ADsAssert(pSystemTime);

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeUTCTime(
             pLdapSrcObject,
             &AdsValue
             );
    BAIL_ON_FAILURE(hr);

    *pSystemTime = AdsValue.UTCTime;

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeGeneralizedTimeToUmiTypeTime
//
// Synopsis:   Converts an ldap time value to a SystemTime value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pSysTime points to the returned time value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeGeneralizedTimeToUmiTypeTime(
    PLDAPOBJECT pLdapSrcObject,
    SYSTEMTIME *pSystemTime
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeGeneralizedTime(
             pLdapSrcObject,
             &AdsValue
             );
    BAIL_ON_FAILURE(hr);

    *pSystemTime = AdsValue.UTCTime;

error:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeTimeObjects
//
// Synopsis:   Converts the ldap source objects into an array of systemtimes
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
//             dwSyntaxId      - tells us what type of time this is (rather
//                              write the same code again for UTC and Gen).
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the new array of systimes.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyTimeObjects(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp,
    DWORD dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    SYSTEMTIME *pSysTimeArray = NULL;
    SYSTEMTIME sysTimeVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pSysTimeArray = (SYSTEMTIME *) AllocADsMem(sizeof(SYSTEMTIME) * dwCount);
    
    if (!pSysTimeArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each element appropriately.
        //
        switch (dwSyntaxId) {

        case LDAPTYPE_UTCTIME :
            hr = LdapTypeGeneralizedTimeToUmiTypeTime(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &sysTimeVal
                     );
            break;

        case LDAPTYPE_GENERALIZEDTIME :
            hr = LdapTypeGeneralizedTimeToUmiTypeTime(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &sysTimeVal
                     );
            break;

        default:
            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }

        BAIL_ON_FAILURE(hr);

        if (SUCCEEDED(hr)) {
            pSysTimeArray[dwCtr] = sysTimeVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pSysTimeArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pSysTimeArray) {
        FreeADsMem( (void *) pSysTimeArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopy.
//
// Synopsis:   Helper routine to convert ldap values to the required UMI
//            data type. 
//
// Arguments:  pLdapSrcObjects   -  The source objects to convert.
//             pProp             -  Return value.
//             dwStatus          -  Indicates status of property in cache.
//             dwLdapSyntaxId    -  Ldap syntax of the data.
//             pCreds            -  Ptr to credentials to use for conversion.
//             pszServerName     -  Name of the server to use for conversion.
//             uUmiFlags         -  UMI flag corresponding to dwStatus.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pProp and dwLdapSyntaxId
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopy(
    LDAPOBJECTARRAY pLdapSrcObjects,
    UMI_PROPERTY_VALUES **pProp,
    DWORD dwStatus,
    DWORD dwLdapSyntaxId,
    CCredentials *pCreds, // needed for sd's
    LPWSTR pszServerName, // needed for sd's
    ULONG uUmiFlags
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr;
    UMI_PROPERTY *pProperty = NULL;
    LPVOID lpVoid = NULL;

    //
    // Allocate the UMI_PROPERTY_VALUES needed, only one element for now.
    //
    *pProp = (UMI_PROPERTY_VALUES*)AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*pProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // We are only going to have one value.
    //
    (*pProp)->uCount = 1;
    
    //
    // Now allocate the actual property object.
    //
    pProperty = (UMI_PROPERTY*) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!pProperty) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*pProp)->pPropArray = pProperty;

    //
    // If the operation is clear/delete, then we do not have anything
    // to return. There is one Umi object with no values in it and 
    // possibly no datatype.
    //
    if (dwStatus == PROPERTY_DELETE) {
        pProperty->pUmiValue = NULL;
        pProperty->uType = 0;
    } 
    else {
    
            
        switch (dwLdapSyntaxId) {
    
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
    //    case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:
    
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:
    
            hr = LdapTypeToUmiTypeCopyStrings(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_LPWSTR;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_BOOLEAN:
    
            hr = LdapTypeToUmiTypeCopyBooleans(
                     pLdapSrcObjects,
                     pProperty
                     );
    
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_BOOL;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_INTEGER:
    
            hr = LdapTypeToUmiTypeCopyIntegers(
                     pLdapSrcObjects,
                     pProperty
                     );
    
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_I4;
            pProperty->pszPropertyName = NULL;
    
            break;
    
    
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
    
            hr = LdapTypeToUmiTypeCopyOctetStrings(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_OCTETSTRING;
            pProperty->pszPropertyName = NULL;
    
            break;
    
    
        case LDAPTYPE_GENERALIZEDTIME:
            
            hr = LdapTypeToUmiTypeCopyTimeObjects(
                     pLdapSrcObjects,
                     pProperty,
                     LDAPTYPE_GENERALIZEDTIME
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_SYSTEMTIME;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_UTCTIME:
    
            hr = LdapTypeToUmiTypeCopyTimeObjects(
                     pLdapSrcObjects,
                     pProperty,
                     LDAPTYPE_UTCTIME
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_SYSTEMTIME;
            pProperty->pszPropertyName = NULL;
            break;
    
    
        case LDAPTYPE_SECURITY_DESCRIPTOR:
    
            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsSecurityDescriptor,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_INTEGER8:
    
            hr = LdapTypeToUmiTypeCopyLargeIntegers(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_I8;
            pProperty->pszPropertyName = NULL;
    
            break;
    /*
    #if 0
            case LDAPTYPE_CASEEXACTLIST:
            case LDAPTYPE_CASEIGNORELIST:
    #endif
    */
    
        case LDAPTYPE_DNWITHBINARY:

            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsDNWithBinary,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);

            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
            break;
    
        case LDAPTYPE_DNWITHSTRING:

            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsDNWithString,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);

            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
            break;
    
        default:
    
            //
            // LDAPTYPE_UNKNOWN  (schemaless server property) will be
            // not be converted.
            //
    
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
        } // end of case.
    } // end of if property != DELETE.
    
    //
    // Need to set the property type on the operation if we get here.
    //
    pProperty->uOperationType = uUmiFlags;

    RRETURN(hr);

error:

    //
    // Free the Property array as needed.
    //
    // FreeUmiPropertyArray();

    // DO NOT FREE pProperty it will be handled byt FreeUmiPropertyArray
    // Write code to free lpVoid as it will have valid data in failure cases.

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\name.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cNameTranslate.cxx
//
//  Contents:  NameTranslate object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------


#include "ldap.hxx"
#pragma hdrstop

#define ABORT_ON_ERROR(err)                                         \
    if ( 0 != (err) )                                               \
    {                                                               \
        hr = E_FAIL;                                                \
        goto error;                                                 \
    }


//  Class CNameTranslate
DEFINE_IDispatch_Implementation(CNameTranslate)

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::CNameTranslate
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CNameTranslate::CNameTranslate():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNameTranslate);
    _hDS = NULL;
    _rgszGuid = NULL;
    _rgDomainHandle = NULL;
    _cGuid = 0;
    _bChaseReferral = TRUE;
    _bAuthSet = FALSE;
    _pDomainHandle = new CDomainToHandle;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::CreateNameTranslate
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
HRESULT
CNameTranslate::CreateNameTranslate(
    REFIID riid,
    void **ppvObj
    )
{
    CNameTranslate FAR * pNameTranslate = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNameTranslateObject(&pNameTranslate);
    BAIL_ON_FAILURE(hr);

    hr = pNameTranslate->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNameTranslate->Release();
    RRETURN(hr);

error:
    delete pNameTranslate;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CNameTranslate::~CNameTranslate
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CNameTranslate::~CNameTranslate( )
{
    DWORD i;
    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }
    delete _pDispMgr;
    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
    }
    if (_rgDomainHandle) {
        FreeADsMem(_rgDomainHandle);
    }
    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }
    if (_pDomainHandle) {
        delete _pDomainHandle;
    }
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        return E_POINTER;
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNameTranslate))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT MapCrackErrToHR(DWORD dwErr)
{
    HRESULT hr = S_OK;

    switch (dwErr) {
        case DS_NAME_NO_ERROR:
            hr = S_OK;
            break;

        case DS_NAME_ERROR_RESOLVING:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING);
            break;

        case DS_NAME_ERROR_NOT_FOUND:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND);
            break;

        case DS_NAME_ERROR_NOT_UNIQUE:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE);
            break;

        case DS_NAME_ERROR_NO_MAPPING:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING);
            break;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY);
            break;

        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            hr = HRESULT_FROM_WIN32(
                     ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
                     );
            break;

        case DS_NAME_ERROR_TRUST_REFERRAL:
            
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_TRUST_REFERRAL);
            break;

        default:
            hr = E_FAIL;
    }
    return hr;
}

HRESULT MapAdsToCrack(DWORD dwType, DS_NAME_FORMAT *pdwReturn)
{
    HRESULT hr = S_OK;
    switch (dwType) {
        case ADS_NAME_TYPE_1779:
            *pdwReturn = DS_FQDN_1779_NAME;
            break;
        case ADS_NAME_TYPE_CANONICAL:
            *pdwReturn = DS_CANONICAL_NAME;
            break;
        case ADS_NAME_TYPE_NT4:
            *pdwReturn = DS_NT4_ACCOUNT_NAME;
            break;
        case ADS_NAME_TYPE_DISPLAY:
            *pdwReturn = DS_DISPLAY_NAME;
            break;
        case ADS_NAME_TYPE_DOMAIN_SIMPLE:
            *pdwReturn = DS_DOMAIN_SIMPLE_NAME;
            break;
        case ADS_NAME_TYPE_ENTERPRISE_SIMPLE:
            *pdwReturn = DS_ENTERPRISE_SIMPLE_NAME;
            break;
        case ADS_NAME_TYPE_GUID:
            *pdwReturn = DS_UNIQUE_ID_NAME;
            break;
        case ADS_NAME_TYPE_USER_PRINCIPAL_NAME:
            *pdwReturn = DS_USER_PRINCIPAL_NAME;
            break;
        case ADS_NAME_TYPE_CANONICAL_EX:
            *pdwReturn = DS_CANONICAL_NAME_EX;
            break;
        case ADS_NAME_TYPE_SERVICE_PRINCIPAL_NAME:
            *pdwReturn = DS_SERVICE_PRINCIPAL_NAME;
            break;
        case ADS_NAME_TYPE_UNKNOWN:
            *pdwReturn = DS_UNKNOWN_NAME;
            break;
        case ADS_NAME_TYPE_SID_OR_SID_HISTORY_NAME:
            *pdwReturn = DS_SID_OR_SID_HISTORY_NAME;
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            break;
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::AllocateNameTranslateObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
HRESULT
CNameTranslate::AllocateNameTranslateObject(
    CNameTranslate ** ppNameTranslate
    )
{
    CNameTranslate FAR * pNameTranslate = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNameTranslate = new CNameTranslate();
    if (pNameTranslate == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsNameTranslate,
                (IADsNameTranslate *)pNameTranslate,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pNameTranslate->_pDispMgr = pDispMgr;
    *ppNameTranslate = pNameTranslate;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Set
//
// Synopsis:    Sets the values of the NameTranslate object
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Set(long dwSetType,BSTR bstrADsPath)
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS = NULL;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT  dsFormat;
    DWORD i;
    BOOL fDoNotFree = FALSE;

    //
    // fDoNotFree is used to determine if we need to free
    // the dsresul pResult or not. There are some cases when
    // the call can fail but the ptr modified, and in those
    // cases it should not be freed.
    //
    if (!bstrADsPath) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (_rgDomainHandle) {
        FreeADsMem(_rgDomainHandle);
        _rgDomainHandle = NULL;
    }


    hr = MapAdsToCrack(dwSetType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    dsFormat,           // format in
                    DS_UNIQUE_ID_NAME,  // format out
                    1,                  // name count
                    &bstrADsPath,
                    &pResult);
    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    if (_bChaseReferral && pResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY) {
        if (!pResult->rItems[0].pDomain) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        //
        // Chasing Referral
        //

        hr = _pDomainHandle->Find(bstrADsPath,
                                  &hDS);
        if (hr == E_FAIL ) {

            if (!_bAuthSet) {
                dwErr = DsBindWrapper(
                            NULL,
                            pResult->rItems[0].pDomain,
                            &hDS);
            }
            else {
                dwErr = DsBindWithCredWrapper(
                            NULL,
                            pResult->rItems[0].pDomain,
                            _AuthIdentity,
                            &hDS);
            }
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
            hr = _pDomainHandle->AddElement(bstrADsPath, hDS);
            BAIL_ON_FAILURE(hr);
        }

        dwErr = DsCrackNamesWrapper(
                        hDS,
                        DS_NAME_NO_FLAGS,   // flags
                        dsFormat,           // format in
                        DS_UNIQUE_ID_NAME,  // format out
                        1,                  // name count
                        &bstrADsPath,
                        &pResult);
        if (dwErr) {
            fDoNotFree = FALSE;
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }

        if (!_rgDomainHandle) {
            _rgDomainHandle = (HANDLE*)AllocADsMem(sizeof(HANDLE));
            if (!_rgDomainHandle) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        _rgDomainHandle [0] = hDS;

    }

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    //
    // All below will essentially return E_FAIL on failure.
    //
    ABORT_ON_ERROR(1 != pResult->cItems);
    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);

    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
        _rgszGuid = NULL;
    }

    _rgszGuid = (LPWSTR*)AllocADsMem(sizeof(LPWSTR));
    if (!_rgszGuid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    _rgszGuid[0] = AllocADsStr(pResult->rItems[0].pName);
    if (!_rgszGuid[0]) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    _cGuid = 1;

    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }

    if (pResult) {
        DsFreeNameResultWrapper(pResult);
    }
    return hr;

error:
    if (hDS) {
        DsUnBindWrapper(&hDS);
        hDS = NULL;
    }
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }

    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Init
//
// Synopsis:    Initialize the object
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Init(long lnType,BSTR bstrADsPath)
{
    DWORD           dwErr;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;

    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }

    _pDomainHandle->Init();

    switch (lnType) {
        case ADS_NAME_INITTYPE_SERVER:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWrapper(
                        bstrADsPath,
                        NULL,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_DOMAIN:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWrapper(
                        NULL,
                        bstrADsPath,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_GC:
            dwErr = DsBindWrapper(
                        NULL,
                        NULL,
                        &hDS);
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            break;
    }
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _hDS = hDS;
    hr = S_OK;
error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::InitEx
//
// Synopsis:    Initialize the object with Credentials
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    14-2-98   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::InitEx(long lnType,BSTR bstrADsPath,BSTR bstrUserID, BSTR bstrDomain, BSTR bstrPassword)
{
    DWORD           dwErr;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;

    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }

    hr = _pDomainHandle->Init();

    BAIL_ON_FAILURE(hr);

    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }

    dwErr = DsMakePasswordCredentialsWrapper(
                bstrUserID,
                bstrDomain,
                bstrPassword,
                &_AuthIdentity
                );
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _bAuthSet = TRUE;

    switch (lnType) {
        case ADS_NAME_INITTYPE_SERVER:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWithCredWrapper(
                        bstrADsPath,
                        NULL,
                        _AuthIdentity,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_DOMAIN:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWithCredWrapper(
                        NULL,
                        bstrADsPath,
                        _AuthIdentity,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_GC:
            dwErr = DsBindWithCredWrapper(
                        NULL,
                        NULL,
                        _AuthIdentity,
                        &hDS);
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            break;
    }
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _hDS = hDS;
    hr = S_OK;
    return hr;
error:
    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }
    return hr;
}


STDMETHODIMP
CNameTranslate::put_ChaseReferral(THIS_ long lnChase)
{
    _bChaseReferral = (BOOLEAN)lnChase;
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Get
//
// Synopsis:    Retrive the pathname as different formats
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Get(THIS_ long dwFormatType, BSTR FAR *pbstrName)
{
    DS_NAME_RESULTW *pResult = NULL;
    HRESULT         hr = E_FAIL;
    DWORD           dwErr = 0;
    HANDLE          hDS;
    DS_NAME_FORMAT  dsFormat;
    BOOL fDoNotFree = FALSE;

    //
    // Look at ::Set for more info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (!pbstrName) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (dwFormatType == ADS_NAME_TYPE_UNKNOWN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if ((_cGuid) != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwFormatType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    if (_bChaseReferral && _rgDomainHandle && _rgDomainHandle[0]) {
        dwErr = DsCrackNamesWrapper(
                        _rgDomainHandle[0],
                        DS_NAME_NO_FLAGS,   // flags
                        DS_UNIQUE_ID_NAME,  // format in
                        dsFormat,           // format out
                        _cGuid,             // name count
                        _rgszGuid,
                        &pResult);
    }
    else {
        dwErr = DsCrackNamesWrapper(
                        _hDS,
                        DS_NAME_NO_FLAGS,   // flags
                        DS_UNIQUE_ID_NAME,  // format in
                        dsFormat,           // format out
                        _cGuid,             // name count
                        _rgszGuid,
                        &pResult);
    }

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(1 != pResult->cItems);
    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);
    hr = ADsAllocString(pResult->rItems[0].pName,
                        pbstrName);
error:
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::GetEx
//
// Synopsis:    Retrive the pathname as different formats
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::GetEx(THIS_ long dwFormatType, VARIANT FAR *pvarstrName)
{
    long i = 0;
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT dsFormat;
    LPWSTR szGuid = (LPWSTR)_szGuid;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BOOL fDoNotFree = FALSE;
    //
    // Look at ::Set for info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (!pvarstrName) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (dwFormatType == ADS_NAME_TYPE_UNKNOWN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwFormatType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    DS_UNIQUE_ID_NAME,  // format in
                    dsFormat,           // format out
                    _cGuid,                  // name count
                    _rgszGuid,
                    &pResult);

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);

    VariantInit( pvarstrName );

    aBound.lLbound = 0;
    aBound.cElements = pResult->cItems;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) pResult->cItems; i++ )
    {
        VARIANT v;

        VariantInit(&v);

        hr = ADsAllocString(
                 pResult->rItems[i].pName,
                 &(v.bstrVal)
                 );
        BAIL_ON_FAILURE(hr);

        v.vt = VT_BSTR;

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pvarstrName) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarstrName) = aList;

    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
        BAIL_ON_FAILURE(hr);
    }
    if (pResult) {
        DsFreeNameResultWrapper(pResult);
    }

    RRETURN(S_OK);

error:
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    return hr;
}

HRESULT
ConvertSafeArrayToBstrArray(
    VARIANT *pvarSafeArray,
    BSTR **ppVarArray,
    DWORD *pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    BSTR * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    if(!((V_VT(pvarSafeArray) & VT_BSTR) && V_ISARRAY(pvarSafeArray)))
        return(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(pvarSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(pvarSafeArray));
    else
        pArray = V_ARRAY(pvarSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        return(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (BSTR*)AllocADsMem(
                                sizeof(BSTR)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        if (FAILED(hr)) {
                continue;
        }
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    return(hr);
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::SetEx
//
// Synopsis:    Set multiple objects names
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::SetEx(THIS_ long dwSetType, VARIANT varstrName)
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT  dsFormat;
    VARIANT *vVarArray = NULL;
    PWSTR *ppszStrArray = NULL;
    DWORD dwNum,i;
    BOOL fDoNotFree = FALSE;
    //
    // Look at ::Set for more info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwSetType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    hr = ConvertSafeArrayToVariantArray(
             varstrName,
             &vVarArray,
             &dwNum
             );
    // returns E_FAIL if varstrname is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
             
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToLDAPStringArray(
             vVarArray,
             &ppszStrArray,
             dwNum
             );
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    dsFormat,           // format in
                    DS_UNIQUE_ID_NAME,  // format out
                    dwNum,              // name count
                    ppszStrArray,
                    &pResult
                    );

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);


    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
    }

    _rgszGuid = (LPWSTR*)AllocADsMem(dwNum * sizeof(LPWSTR));
    if (!_rgszGuid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    for (i=0;i<dwNum;i++) {
        _rgszGuid[i] = AllocADsStr(pResult->rItems[i].pName);
        if (!_rgszGuid[i]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    _cGuid = dwNum;

error:
    if (ppszStrArray) {

        for (i=0; i < dwNum; i++) {
            if (ppszStrArray[i]) {
                FreeADsStr(ppszStrArray[i]);
            }
        }
        FreeADsMem(ppszStrArray);
    }

    if (vVarArray) {

        for (i=0; i < dwNum; i++) {
            VariantClear(vVarArray + i);
        }
        FreeADsMem(vVarArray);
    }

    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }

    return hr;
}


CDomainToHandle::CDomainToHandle()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgMap = NULL;
}

CDomainToHandle::~CDomainToHandle()
{
    Free();
}

DWORD CDomainToHandle::NumElements()
{
    return m_iszNext;
}

HRESULT CDomainToHandle::Init()
{
    HRESULT hr = S_OK;

    Free();

    m_rgMap = (DomainToHandle*)AllocADsMem( STRINGPLEX_INC * sizeof(DomainToHandle) );
    if (!m_rgMap) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgMap, 0, STRINGPLEX_INC * sizeof(DomainToHandle) );

error:
    return hr;
}

HRESULT CDomainToHandle::AddElement(LPWSTR szValue, HANDLE hDS)
{
    HRESULT hr = S_OK;
    DomainToHandle *rgMap = NULL;

    if (!szValue) {
        return E_ADS_BAD_PARAMETER;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgMap = (DomainToHandle*)ReallocADsMem(m_rgMap ,
                                m_cszMax*sizeof(DomainToHandle),
                                (m_cszMax + STRINGPLEX_INC)*sizeof(DomainToHandle));
        if (!rgMap) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        m_rgMap = rgMap;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgMap[m_iszNext].szDomain = AllocADsStr(szValue);
    if (!m_rgMap[m_iszNext].szDomain) {
         hr = E_OUTOFMEMORY;
         BAIL_ON_FAILURE(hr);
    }
    m_rgMap[m_iszNext].hDS = hDS;

    m_iszNext++;
error:
    return hr;
}

HRESULT CDomainToHandle::Find(LPWSTR szValue, HANDLE *phDS)
{
    HRESULT hr = E_FAIL;
    UINT i;

    if (!szValue) {
        return E_ADS_BAD_PARAMETER;
    }

    for (i=0;i<m_iszNext;i++) {
        if (wcscmp(m_rgMap[i].szDomain, szValue) == 0) {
            *phDS = m_rgMap[i].hDS;
            return S_OK;
        }
    }

    return hr;
}

void CDomainToHandle::Free()
{
    DWORD isz = 0;

    if (m_rgMap) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgMap[isz].szDomain) {
                FreeADsMem(m_rgMap[isz].szDomain);
                DsUnBindWrapper(&m_rgMap[isz].hDS);
            }
        }
        FreeADsMem(m_rgMap);
        m_rgMap = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
extern HMODULE g_hActiveDs;

typedef DWORD (*PF_DllGetClassObject) (
    REFCLSID clsid,
    REFIID iid,
    LPVOID FAR* ppverved
);

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

extern CRITICAL_SECTION  g_RootDSECritSect;

extern CRITICAL_SECTION  g_ExtCritSect;

extern CRITICAL_SECTION  g_TypeInfoCritSect;

extern CRITICAL_SECTION  g_DispTypeInfoCritSect;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    TCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(TEXT("LDAP"),TEXT("heapInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        heapInfoLevel = _tcstoul(awcs, NULL, 16);

    if (GetProfileString(TEXT("LDAP"),TEXT("Ot"), TEXT("00000003"), awcs, MAXINFOLEN))
        OtInfoLevel = _tcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(TEXT("LDAP"),TEXT("ADsInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        ADsInfoLevel = _tcstoul(awcs, NULL, 16);
#endif
}

//  Globals

ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll

CLDAPProviderCF g_cfProvider;
CLDAPNamespaceCF g_cfNamespace;
CADSystemInfoCF  g_cfADSystemInfo;
CLDAPConnectionCF g_cfLDAPConnection;
CUmiLDAPQueryCF g_cfLDAPUmiQuery;
CNameTranslateCF g_cfNameTranslate;

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};


CLSCACHE g_aclscache[] =
{
    &CLSID_LDAPProvider,                        &g_cfProvider,
    &CLSID_LDAPNamespace,                       &g_cfNamespace,
    &CLSID_NameTranslate,                       &g_cfNameTranslate,
    &CLSID_ADSystemInfo,                        &g_cfADSystemInfo,
    &CLSID_LDAPConnectionObject,                &g_cfLDAPConnection,
    &CLSID_UmiLDAPQueryObject,                  &g_cfLDAPUmiQuery
};

extern PCLASS_ENTRY gpClassHead;

//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr = E_NOINTERFACE;
    size_t          i;
    HKEY hKey = NULL;
    HINSTANCE hDll = NULL ;

    if (ppv)
        *ppv = NULL;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    //
    // This workaround is for the special case where an old version of ADSI
    // is installed in the system. Installing that will overwrite the registry
    // with the old setting for pathcracker. The pathcracker object used to live
    // on adsldp.
    // The following code redirects the call to the DllGetClassObject in
    // activeds if the Pathname object is being requested. It also fixes the
    // registry to point to the correct DLL.
    //
    if (IsEqualCLSID(clsid, CLSID_Pathname)) {
        PF_DllGetClassObject pfDllGetClassObject= NULL ;
        WCHAR szPathDescriptor[] = L"ADs Pathname Object";
        WCHAR szDllName[] = L"activeds.dll";
        DWORD WinError;

        if (!(hDll = LoadLibrary(szDllName))) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        if (!(pfDllGetClassObject = (PF_DllGetClassObject)GetProcAddress(hDll, "DllGetClassObject"))) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        hr = (*pfDllGetClassObject)(clsid,
                              iid,
                              ppv);
        BAIL_ON_FAILURE(hr);

        //
        // Setting the general description
        // Even if any of the operations below fails, we'll just bail with the
        // hr from DllGetClassObject.
        //
        WinError = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                L"CLSID\\{080d0d78-f421-11d0-a36e-00c04fb950dc}",
                                NULL,
                                KEY_ALL_ACCESS,
                                &hKey);
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        WinError = RegSetValueEx(hKey,
                                NULL,
                                0,
                                REG_SZ,
                                (BYTE *)szPathDescriptor,
                                (wcslen(szPathDescriptor)+1) * sizeof(WCHAR));
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        //
        // Setting the inprocserver
        //
        WinError = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                L"CLSID\\{080d0d78-f421-11d0-a36e-00c04fb950dc}\\InprocServer32",
                                NULL,
                                KEY_ALL_ACCESS,
                                &hKey);
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        WinError = RegSetValueEx(hKey,
                                NULL,
                                0,
                                REG_SZ,
                                (BYTE *)szDllName,
                                (wcslen(szDllName)+1) * sizeof(WCHAR));
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }
    }

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

error:
    if (hDll) {
        FreeLibrary(hDll);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // Both the ldap and utils\cdispmgr count need to be 0
    //
    if (AggregatorDllCanUnload() && DllReadyToUnload()) {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // In try to catch possibily of init crit sects failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

            // Maybe we should check the handle.

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_RootDSECritSect);
            InitializeCriticalSection(&g_ExtCritSect);
            InitializeCriticalSection(&g_TypeInfoCritSect);
            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            InitializeCriticalSection(&g_csLoadLibsCritSect);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // Something went wrong
            //
            return FALSE;
        }

            break;


    case DLL_PROCESS_DETACH:

        //
        // free global list of class entries for 3rd party ext
        //

        if (gpClassHead) {
            FreeClassesList(gpClassHead);
        }

        if (gpszStickyServerName) {
            FreeADsStr(gpszStickyServerName);
            gpszStickyServerName = NULL;
        }

        if (gpszStickyDomainName) {
            FreeADsStr(gpszStickyDomainName);
            gpszStickyDomainName = NULL;
        }

        FreeServerType();

        //
        // Good idea to delete all the critical sections
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif
        DeleteCriticalSection(&g_RootDSECritSect);
        DeleteCriticalSection(&g_ExtCritSect);
        DeleteCriticalSection(&g_TypeInfoCritSect);
        DeleteCriticalSection(&g_DispTypeInfoCritSect);
        DeleteCriticalSection(&g_csLoadLibsCritSect);

        //
        // Should be ok to free the dynamically loaded libs.
        //
        if (g_hDllNtdsapi) {
            FreeLibrary((HMODULE) g_hDllNtdsapi);
            g_hDllNtdsapi = NULL;
        }

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE) g_hDllSecur32);
        }

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPTSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_tcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!(V_VT(&var) ==  (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\pathutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pathmgmt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-April-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR pszADsPath = NULL;
    HRESULT hr = S_OK;

    hr = BuildADsPathFromParent( Parent, Name, &pszADsPath );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszADsPath, pADsPath);
    BAIL_ON_FAILURE(hr);

error:

    if ( pszADsPath )
        FreeADsMem( pszADsPath );

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    TCHAR *pszADsSchema = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    WCHAR szPort[32];
    DWORD dwLen;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {

        hr = ADsObject(bstrADsPath, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            dwLen =  wcslen(pObjectInfo->NamespaceName) + 
                     wcslen(pObjectInfo->TreeName) +
                     wcslen(bstrClass) +
                     11 +        // ":///schema/"
                     1;

            if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                dwLen += wcslen(szPort);
            }
                
            pszADsSchema = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
            if ( pszADsSchema == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            wsprintf(pszADsSchema,TEXT("%s://"),pObjectInfo->NamespaceName);
            wcscat(pszADsSchema, pObjectInfo->TreeName);

            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsSchema, szPort);
            }

            wcscat(pszADsSchema, TEXT("/schema/"));
            wcscat(pszADsSchema, bstrClass);

        }else {

           pszADsSchema = (LPTSTR) AllocADsMem(
                              ( _tcslen(pObjectInfo->NamespaceName) +
                                _tcslen(bstrClass) +
                                12 ) * sizeof(TCHAR)); //includes ":///schema/"

           if ( pszADsSchema == NULL )
           {
               hr = E_OUTOFMEMORY;
               BAIL_ON_FAILURE(hr);
           }

           _stprintf(pszADsSchema,TEXT("%s://"),pObjectInfo->NamespaceName);
           _tcscat(pszADsSchema, TEXT("schema/"));
           _tcscat(pszADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( pszADsSchema? pszADsSchema : TEXT(""), pSchemaPath);

error:

    if ( pszADsSchema )
        FreeADsStr( pszADsSchema );

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}


HRESULT
BuildADsPathFromLDAPDN(
    BSTR bstrParent,
    BSTR bstrObject,
    LPTSTR *ppszADsPath
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp = NULL;
    int i;
    int j;
    int nCount;
    int *aIndex = NULL;

    if ( bstrObject == NULL || *bstrObject == 0 )
    {
        BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
    }

    *ppszADsPath = (LPTSTR) AllocADsMem( ( _tcslen(bstrParent)
                                         + _tcslen(bstrObject)
                                         + 1) * sizeof(TCHAR) );

    if ( *ppszADsPath == NULL )
    {
        BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);
    }

    _tcscpy( *ppszADsPath, bstrParent );

    pszTemp = _tcschr( *ppszADsPath, TEXT(':'));

    if ( pszTemp )
    {
        pszTemp += _tcslen(TEXT("://"));

        if ( pszTemp )
        {
            pszTemp = _tcschr( pszTemp, TEXT('/'));
        }
    }

    if ( pszTemp == NULL )
    {
        BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
    }

    i = 0;
    nCount = 1;
    while ( bstrObject[i] != 0 )
    {
        if ( bstrObject[i++] == TEXT(',') )
            nCount++;
    }

    aIndex = (int *) AllocADsMem( nCount * sizeof(int));
    if ( aIndex == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    i = 0; j = 0;
    aIndex[j++] = 0;
    while ( bstrObject[i] != 0 )
    {
        if ( bstrObject[i++] == TEXT(',') )
            aIndex[j++] = i;
    }

    for ( i = nCount; i > 0; i-- )
    {
        *(pszTemp++) = TEXT('/');
        j = aIndex[i-1];
        while ( ( bstrObject[j] != 0 ) && ( bstrObject[j] != TEXT(',') ))
            *(pszTemp++) = bstrObject[j++];
    }

    *pszTemp = 0;

error:

    if ( aIndex )
        FreeADsMem( aIndex );

    if ( FAILED(hr))
    {
        if ( *ppszADsPath )
            FreeADsStr( *ppszADsPath );

        *ppszADsPath = NULL;
    }

    return hr;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\property.cxx ===
#include "ldap.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}


//
// Helper to set octetstring property on the object
//
HRESULT
put_OCTETSTRING_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BYTE byteArr[],
    DWORD  dwLen
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    VARIANT vDestObject;

    VariantInit(&vDestObject);

    aBound.lLbound = 0;
    aBound.cElements = dwLen;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, byteArr, dwLen );
    SafeArrayUnaccessData( aList );

    V_VT(&vDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(&vDestObject) = aList;


    hr = pADsObject->Put(
            bstrPropertyName,
            vDestObject
            );

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\system.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPathname.cxx
//
//  Contents:  Pathname object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

#define DEFAULT_NC _T(LDAP_OPATT_DEFAULT_NAMING_CONTEXT)
#define SCHEMA_NC  _T(LDAP_OPATT_SCHEMA_NAMING_CONTEXT)

HANDLE g_hSecur32Dll = NULL;

//  Class CADSystemInfo

DEFINE_IDispatch_Implementation(CADSystemInfo)

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::CADSystemInfo
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CADSystemInfo::CADSystemInfo():
        _pDispMgr(NULL),
        _hSecur32(NULL),
        _Secur32LoadAttempted(FALSE),
        _hNetApi32(NULL),
        _NetApi32LoadAttempted(FALSE)
{
    ENLIST_TRACKING(CADSystemInfo);
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::CreateADSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::CreateADSystemInfo(
    REFIID riid,
    void **ppvObj
    )
{
    CADSystemInfo FAR * pADSystemInfo = NULL;
    HRESULT hr = S_OK;

    hr = AllocateADSystemInfoObject(&pADSystemInfo);
    BAIL_ON_FAILURE(hr);

    hr = pADSystemInfo->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pADSystemInfo->Release();

    RRETURN(hr);

error:
    delete pADSystemInfo;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::~CADSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CADSystemInfo::~CADSystemInfo( )
{

    delete _pDispMgr;

    if (_hSecur32)
        FreeLibrary(_hSecur32);

    if (_hNetApi32)
        FreeLibrary(_hNetApi32);
}

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADSystemInfo::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsADSystemInfo))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::AllocateADSystemInfoObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::AllocateADSystemInfoObject(
    CADSystemInfo  ** ppADSystemInfo
    )
{
    CADSystemInfo FAR * pADSystemInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pADSystemInfo = new CADSystemInfo();
    if (pADSystemInfo == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsADSystemInfo,
                (IADsADSystemInfo *)pADSystemInfo,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pADSystemInfo->_pDispMgr = pDispMgr;
    *ppADSystemInfo = pADSystemInfo;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::InterfaceSupportsErrorInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsADSystemInfo)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


HRESULT
CADSystemInfo::get_UserName(
    BSTR * bstrUserName
    )
{
    PWSTR pszUserDN = NULL;
    ULONG uLength;
    GETUSERNAMEEX pGetUserNameEx;
    HRESULT hr;
    HINSTANCE hModule;

    //
    // Validate parameters
    //
    if ( !bstrUserName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get handle to secur32.dll, and get required entry point
    //
    hr = GetSecur32Handle(&hModule);
    BAIL_ON_FAILURE(hr);

    pGetUserNameEx = (GETUSERNAMEEX) GetProcAddress(hModule, "GetUserNameExW");
    if (!pGetUserNameEx)
    {
        RRETURN(E_FAIL);
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    (*pGetUserNameEx)(NameFullyQualifiedDN,
                      NULL,
                      &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszUserDN = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszUserDN)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if ((*pGetUserNameEx)(NameFullyQualifiedDN,
                              pszUserDN,
                              &uLength))
        {

            hr = ADsAllocString(pszUserDN, bstrUserName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszUserDN)
    {
        FreeADsMem(pszUserDN);
    }

    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_ComputerName(
    BSTR * bstrComputerName
    )
{
    PWSTR pszComputerName = NULL;
    ULONG uLength;
    GETCOMPUTEROBJECTNAME pGetComputerObjectName;
    HRESULT hr;
    HINSTANCE hModule;

    //
    // Validate parameters
    //
    if (!bstrComputerName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get handle to secur32.dll, and get required entry point
    //
    hr = GetSecur32Handle(&hModule);
    BAIL_ON_FAILURE(hr);

    pGetComputerObjectName = (GETCOMPUTEROBJECTNAME)GetProcAddress(hModule, "GetComputerObjectNameW");
    if (!pGetComputerObjectName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    (*pGetComputerObjectName)(NameFullyQualifiedDN,
                              NULL,
                              &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszComputerName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszComputerName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if ((*pGetComputerObjectName)(NameFullyQualifiedDN,
                                      pszComputerName,
                                      &uLength))
        {

            hr = ADsAllocString(pszComputerName, bstrComputerName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszComputerName)
    {
        FreeADsMem(pszComputerName);
    }

    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_SiteName(
    BSTR * bstrSiteName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrSiteName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find client site
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->ClientSiteName, bstrSiteName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_DomainShortName(
    BSTR * bstrDomainName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDomainName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find domain short name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, DS_RETURN_FLAT_NAME, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DomainName, bstrDomainName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::get_DomainDNSName(
    BSTR * bstrDomainDNSName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDomainDNSName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find domain DNS name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DomainName, bstrDomainDNSName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_ForestDNSName(
    BSTR * bstrForestDNSName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrForestDNSName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find forest DNS name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DnsForestName, bstrForestDNSName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::get_PDCRoleOwner(
    BSTR * bstrPDCRoleOwner
    )
{
    RRETURN(GetfSMORoleOwner(DEFAULT_NC, bstrPDCRoleOwner));
}

HRESULT
CADSystemInfo::get_SchemaRoleOwner(
    BSTR * bstrSchemaRoleOwner
    )
{
    RRETURN(GetfSMORoleOwner(SCHEMA_NC, bstrSchemaRoleOwner));
}

HRESULT
CADSystemInfo::get_IsNativeMode(
    VARIANT_BOOL *retVal
    )
{
    IADs *pADs = NULL;
    IDirectoryObject *pDir = NULL;
    HRESULT hr;
    ADS_ATTR_INFO *pAttrInfo = NULL;
    DWORD  dwReturn = 0;
    LPWSTR  pAttrNames[] = {L"nTMixedDomain" };
    DWORD  dwNumAttr = sizeof(pAttrNames)/sizeof(LPWSTR);

    //
    // Validate parameters
    //
    if (!retVal)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    hr = GetNCHead(DEFAULT_NC,  &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**) &pDir);
    BAIL_ON_FAILURE(hr);

    //
    // Get the nTMixedDomain attribute
    //
    hr = pDir->GetObjectAttributes(pAttrNames,
                                   dwNumAttr,
                                   &pAttrInfo,
                                   &dwReturn);
    BAIL_ON_FAILURE(hr);

    if (dwReturn == 0)
    {
        BAIL_ON_FAILURE(hr=E_FAIL);
    }

    *retVal = pAttrInfo->pADsValues->Boolean == FALSE ? VARIANT_TRUE : VARIANT_FALSE;

error:

    //
    // Clean-up
    //
    if (pAttrInfo)
        FreeADsMem(pAttrInfo);

    if (pDir)
        pDir->Release();

    if (pADs)
        pADs->Release();

    return hr;
}


HRESULT
CADSystemInfo::GetAnyDCName(
    BSTR *bstrDCName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDCName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find DC name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(&pdcInfo->DomainControllerName[2], bstrDCName); // skip "\\"
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetDCSiteName(
    BSTR bstrDCName,
    BSTR *bstrSiteName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDCName|| !bstrSiteName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find DC site name
    //
    err = (*pDsGetDcName)(bstrDCName, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DcSiteName, bstrSiteName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::RefreshSchemaCache(
    void
    )
{
    IADs *pRootDSE = NULL;
    VARIANT var;
    HRESULT hr;

    VariantInit( &var );

    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**) &pRootDSE);
    BAIL_ON_FAILURE(hr);

    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;

    hr = pRootDSE->Put(LDAP_OPATT_SCHEMA_UPDATE_NOW_W, var);
    BAIL_ON_FAILURE(hr);

    hr = pRootDSE->SetInfo();
    BAIL_ON_FAILURE(hr);

error:
    VariantClear( &var );

    if (pRootDSE)
        pRootDSE->Release();

    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetTrees(
    VARIANT *pVar
    )
{
    PDS_DOMAIN_TRUSTS pDomains = NULL;
    DSENUMERATEDOMAINTRUSTS pDsEnumerateDomainTrusts;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY *psa = NULL;
    DWORD dwErr = 0;
    ULONG i, lCount;
    HRESULT hr = S_OK;
    DWORD count;

    //
    // Validate parameters
    //
    if (!pVar )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to NetEnumerateTrustedDomainsEx
    //
    pDsEnumerateDomainTrusts = GetDsEnumerateDomainTrusts();
    if (! pDsEnumerateDomainTrusts)
    {
        RRETURN(E_FAIL);
    }

    //
    // Enumerate all trusted domains
    //
    dwErr = (*pDsEnumerateDomainTrusts)(
                NULL,
                DS_DOMAIN_PRIMARY
                | DS_DOMAIN_IN_FOREST
                | DS_DOMAIN_DIRECT_OUTBOUND,
                &pDomains,
                &lCount
                );

    if (dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);

    //
    // Count number of domains that are tree roots
    //
    count = 0;
    for(i = 0; i < lCount; i++)
    {
        if (pDomains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            ASSERT(pDomains[i].DnsDomainName);

            count++;
        }
    }

    //
    // We have no tree roots - we must be on an NT4 domain, return
    // an empty variant
    //
    if (count == 0)
    {
        VariantClear(pVar);
        V_VT(pVar) = VT_EMPTY;
        RRETURN(S_OK);
    }

    //
    // Create Safe Array
    //
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = count;

    psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (! psa)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    VariantClear(pVar);
    V_VT(pVar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(pVar) = psa;

    VARIANT varItem;

    //
    // Now iterate through each returned element and
    // add it to the variant array if it is a tree root
    //
    count = 0;
    for(i = 0; i < lCount; i++)
    {
        if (pDomains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            VariantInit(&varItem);

            V_VT(&varItem) = VT_BSTR;
            hr = ADsAllocString(pDomains[i].DnsDomainName, &(V_BSTR(&varItem)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement(psa, (long *) &count, &varItem);
            VariantClear(&varItem);

            BAIL_ON_FAILURE(hr);
            count++;
        }
    }

error:
    if (pDomains)
        NetApiBufferFree(pDomains);

    if (FAILED(hr) && psa)
        SafeArrayDestroy(psa);

    return hr;
}


HRESULT
CADSystemInfo::GetNCHead(
    LPTSTR szNCName,
    IADs **pADs
    )
{
    WCHAR szPathName[MAX_PATH];
    VARIANT var;
    HRESULT hr;
    IADs *pRootDSE = NULL;

    //
    // Open RootDSE and query for NC object name
    //
    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**) &pRootDSE );
    BAIL_ON_FAILURE(hr);

    hr = pRootDSE->Get(szNCName, &var);
    BAIL_ON_FAILURE(hr);

    //
    // Build LDAP://<naming context>
    //
    wcscpy(szPathName, L"LDAP://");
    wcscat(szPathName, V_BSTR(&var));

    //
    // Get pointer to NC object
    //
    hr = ADsGetObject(szPathName, IID_IADs, (void**) pADs);
    BAIL_ON_FAILURE(hr);

error:
   if (pRootDSE)
   {
       pRootDSE->Release();
   }

   RRETURN(hr);

}

HRESULT
CADSystemInfo::GetfSMORoleOwner(
    LPTSTR szNCName,
    BSTR *bstrRoleOwner
    )
{
    IADs             *pADs = NULL;
    IDirectoryObject *pDir = NULL;
    ADS_ATTR_INFO    *pAttrInfo = NULL;
    LPWSTR           pAttrNames[] = {L"fSMORoleOwner" };
    DWORD            dwNumAttrs = sizeof(pAttrNames)/sizeof(LPWSTR);
    HRESULT          hr;
    DWORD            dwReturn;

    //
    // Validate parameters
    //
    if (!bstrRoleOwner )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    hr = GetNCHead(szNCName, &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**) &pDir);
    BAIL_ON_FAILURE(hr);

    //
    // Get the fSMORoleOwner
    //
    hr = pDir->GetObjectAttributes(pAttrNames,
                                   dwNumAttrs,
                                   &pAttrInfo,
                                   &dwReturn);
    BAIL_ON_FAILURE(hr);

    if (dwReturn == 0)
    {
        BAIL_ON_FAILURE(hr=E_FAIL);
    }

    hr = ADsAllocString(pAttrInfo->pADsValues->CaseIgnoreString, bstrRoleOwner);
    BAIL_ON_FAILURE(hr);

error:

    //
    // Clean-up
    //
    if (pDir)
        pDir->Release();

    if (pADs)
        pADs->Release();

    FreeADsMem(pAttrInfo);

    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetSecur32Handle(
    HINSTANCE *pHandle
    )
{
    if (! _Secur32LoadAttempted)
    {
        _hSecur32 = LoadLibrary(__TEXT("secur32.dll"));
        _Secur32LoadAttempted = TRUE;
    }

    *pHandle = _hSecur32;
    if (_hSecur32)
        RRETURN(S_OK);
    else
        RRETURN(E_FAIL);
}


DSGETDCNAME
CADSystemInfo::GetDsGetDcName(
    void
    )
{
    DSGETDCNAME pDsGetDcName = NULL;

    if (! _NetApi32LoadAttempted)
    {
        _hNetApi32 = LoadLibrary(__TEXT("netapi32.dll"));
        _NetApi32LoadAttempted = TRUE;
    }

    if (_hNetApi32)
    {
        pDsGetDcName = (DSGETDCNAME)GetProcAddress(_hNetApi32, "DsGetDcNameW");
    }

    return pDsGetDcName;
}

DSENUMERATEDOMAINTRUSTS
CADSystemInfo::GetDsEnumerateDomainTrusts(
    void
    )
{
    DSENUMERATEDOMAINTRUSTS pDsEnumerateDomainTrusts = NULL;

    if (! _NetApi32LoadAttempted)
    {
        _hNetApi32 = LoadLibrary(__TEXT("netapi32.dll"));
        _NetApi32LoadAttempted = TRUE;
    }

    if (_hNetApi32)
    {
        pDsEnumerateDomainTrusts = (DSENUMERATEDOMAINTRUSTS)
                    GetProcAddress(
                        _hNetApi32,
                        "DsEnumerateDomainTrustsW"
                        );
    }

    return pDsEnumerateDomainTrusts;
}


STDMETHODIMP
CADSystemInfoCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CADSystemInfo::CreateADSystemInfo(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\putget.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  putget.cxx
//
//  Contents:
//
//
//  History:   01-14-97  krishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


STDMETHODIMP
CLDAPGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!pvProp || !bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    BOOL fIndexValid = TRUE;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) & VT_VARIANT) &&  V_ISARRAY(pvProp) && V_ISBYREF(pvProp)){

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else if ((V_VT(pvProp) &  VT_VARIANT) &&  V_ISARRAY(pvProp)) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }
    else {

        dwNumValues = 1;
    }

    if (pvProp == NULL) {
        dwSyntaxId = LDAPTYPE_UNKNOWN;
    }
    else {

        hr = GetLdapSyntaxFromVariant(
                 pvProp,
                 &dwSyntaxId,
                 _pszLDAPServer,
                 bstrName,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (!_wcsicmp(bstrName, L"ntSecurityDescriptor")){
        dwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //
    // No Schema??
    // mattrim 5/16/00 - doesn't matter if no schema since
    // this isn't getting built, it's #if'ed out
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);

        // Set the flag as the dwIndex is not valid in this case
        fIndexValid = FALSE;
    }

    //
    // Now update the property in the cache
    //

    if (fIndexValid) {
        // do an optimized put
        hr = _pPropertyCache->putproperty(
                                  dwIndex,
                                  PROPERTY_UPDATE,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    } else {

        // Index is not valid so let the cache figure it out.
        hr = _pPropertyCache->putproperty(
                                  bstrName,
                                  PROPERTY_UPDATE,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    }

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // For those who know no not what they do
    //
    if (!pvProp || !bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
                _pszLDAPServer,
                _Credentials,
                ldapSrcObjects,
                dwSyntaxId,
                pvProp
                );
    BAIL_ON_FAILURE(hr);

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    BOOL fIndexValid = TRUE;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    switch ( lnControlCode ) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = PROPERTY_ADD;
        break;

    case ADS_PROPERTY_DELETE:
        dwFlags = PROPERTY_DELETE_VALUE;
        break;


    default:
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }


    if ( dwFlags != PROPERTY_DELETE )
    {
        //
            // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
            // We should dereference a VT_BYREF|VT_VARIANT once and see
            // what's inside.
            //
            pvProp = &vProp;

            if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
                pvProp = V_VARIANTREF(&vProp);
            }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
            (V_VT(pvProp) ==  (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }


        if (pvProp == NULL) {
            //
            // If array is empty, set dwSyntaxId to Unknown. This value will not be used
            //
            dwSyntaxId = LDAPTYPE_UNKNOWN;
        }
        else {

            hr = GetLdapSyntaxFromVariant(
                     pvProp,
                     &dwSyntaxId,
                     _pszLDAPServer,
                     bstrName,
                     _Credentials,
                     _dwPort
                     );

            BAIL_ON_FAILURE(hr);

            if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
            {
                //
                // If array is empty, set dwSyntaxId to Unknown. This value will
                // not be used
                //
                hr = E_ADS_CANT_CONVERT_DATATYPE;
                BAIL_ON_FAILURE(hr);
            }
        }

        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
        fIndexValid = FALSE;
    }

    //
    // Now update the property in the cache
    //
    if (fIndexValid) {

        // do an optimized put property with the index
        hr = _pPropertyCache->putproperty(
                                  dwIndex,
                                  dwFlags,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    } else {

        // we need to use the property name in this case
        hr = _pPropertyCache->putproperty(
                                  bstrName,
                                  dwFlags,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    }

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\proplist.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CLDAPGenObject::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    BSTR bstrProperty = NULL;
    SAFEARRAY *psaProperty = NULL;
    SAFEARRAYBOUND rgsabound[1];
    long lsaDim[1];
    VARIANT varProperty;


    //  ??? _pPropertyCache canNOT be NULL or bailed out during
    //      CLDAPGenObject creation already
    //  assert(_PropertyCache);

    if (_pPropertyCache) {
          hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }


    RRETURN_EXP_IF_ERR(hr);

}


////////////////////////////////////////////////////////////////////////////
//
// - Return the "next" item (item with the current index) in cache, if any,
//   in a property entry [*pVariant].
// - Return E_ADS_PROPERTY_NOT_FOUND when current index is out of bound.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CLDAPGenObject::Next(
    THIS_ VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    IDispatch * pDispatch = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;

    if(!_pPropertyCache->index_valid())
       RRETURN_EXP_IF_ERR(E_FAIL);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwPropStatus,
                &ldapSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

    //
    // translate the LDAP objects to variants
    //

    hr = ConvertLdapValuesToVariant(
            _pPropertyCache->get_CurrentPropName(),
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    Skip(1);

    LdapTypeFreeLdapObjects(&ldapSrcObjects);


    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Skip(
    THIS_ long cElements
    )
{
   HRESULT hr = S_OK;

   hr = _pPropertyCache->skip_propindex(
                cElements
                );
   RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CLDAPGenObject::ResetPropertyItem(THIS_ VARIANT varEntry)
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    switch (V_VT(&varEntry)) {

    case VT_BSTR:

        hr = _pPropertyCache->findproperty(
                            V_BSTR(&varEntry),
                            &dwIndex
                            );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:
        dwIndex = V_I4(&varEntry);
        break;


    case VT_I2:
        dwIndex = V_I2(&varEntry);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->deleteproperty(
                        dwIndex
                        );
error:


    RRETURN_EXP_IF_ERR(hr);
}


//////////////////////////////////////////////////////////////////////////
//
// Retrieve property [bstrName] from the cache (only, no wire calls) as
// a PropertyEntry.
//
// [*pVariant]
//      - store ptr to IDispatch of the PropertyEntry.
//
// If the property in cache has control code = ADS_PROPERTY_DELETE,
//      - PropertyEntry will contain an empty variant and
//      - adstype = ADSTYPE_INVALID.
//
// If property in cache has UNKNWON type, (not deleted, for schemaless-server
// property which is not in ADSI default schema)
//      - [lnAdsType] must be a valid type (NO ADSTYPE_UNKNWON/INVALID)
//      - property will be retrieved as [lnADsType]
//
// If property in cache has KNOWN type,
//      - [lnADsType] must either match type in cache or == ADSTYPE_UNKNOWN
//      - property will be retreived as the type in cache.
//
/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CLDAPGenObject::GetPropertyItem(
    THIS_
    IN  BSTR bstrName,
    IN  LONG lnADsType,
    IN OUT VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwCachedSyntax = LDAPTYPE_UNKNOWN;
    DWORD dwUserSyntax = LDAPTYPE_UNKNOWN;
    DWORD dwSyntaxUsed = LDAPTYPE_UNKNOWN;  // extra, make code easier to read
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LDAPOBJECTARRAY ldapSrc2Objects;
    LDAPOBJECTARRAY * pLdapSrcObjects = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);
    LDAPOBJECTARRAY_INIT(ldapSrc2Objects);


    if (!bstrName || !pVariant)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // retrieve property from cache; CONTINUE if property exist but
    // has no value (control code flag as a DELETE)
    //

    hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwCachedSyntax,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
    BAIL_ON_FAILURE(hr);

    // For backward compatibility -- no issue as you
    // need to return a value even if it is delete.


    //
    // map adstype from client to ldap type;
    //

    dwUserSyntax =  MapADSTypeToLDAPType((ADSTYPE)lnADsType);


    //
    // determine the syntax to retrieve property in
    //

    if ( (dwCachedSyntax == LDAPTYPE_UNKNOWN)
            ||
         (dwCachedSyntax == 0) // should NOT be 0, but misuse of 0 everywhere
       )                       // and in case i didn't clean up all
    {
        //
        // syntax not stored in cache, user must spcify a valid sytax
        // Exception: cleared property values have LDAPTYPE_UNKNOWN, and we
        // return them as ADSTYPE_UNKNOWN
        //

        if ((dwUserSyntax == LDAPTYPE_UNKNOWN) && (dwPropStatus != PROPERTY_DELETE))
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }

        dwSyntaxUsed = dwUserSyntax;

        //
        // convert from cached data from ldap binary format to ldap string
        // IFF necessary based on dwUserSyntax
        //

        hr = LdapTypeBinaryToString(
                dwSyntaxUsed,
                &ldapSrcObjects,
                &ldapSrc2Objects
                );

        //
        // dwSyntaxUsed (dwUserSyntax) must be valid from
        // MapADSTypeToLDAPType() or code bug in MapADsTypeToLDAPType() !!
        //

        ADsAssert(SUCCEEDED(hr));

        if (hr==S_OK)
        {
            pLdapSrcObjects = &ldapSrc2Objects;     // conversion done
        }
        else // hr == S_FALSE
        {
            pLdapSrcObjects = &ldapSrcObjects;      // no conversion
        }
    }

    else // dwCachedSyntax known and valid
    {
        //
        // syntax stored in cache, user MUST either specify
        //  1) ADSTYPE_UNKNWON  or
        //  2) a syntax which matches the one in cache. The comparision must
        //     be done in ADsType, not LdapType, since LdapType To ADSType
        //     is n to 1 mapping and as long as ADsType match, ok.
        //

        if ( ! (
                (dwUserSyntax == LDAPTYPE_UNKNOWN)
                    ||
                ( (ADSTYPE) lnADsType == MapLDAPTypeToADSType(dwCachedSyntax))
               )
           )
        {

            if (dwUserSyntax != dwCachedSyntax) {

                //
                // Check if the user wants the data back for the
                // security descriptor as an octet or vice versa
                //
                if (  (dwUserSyntax == LDAPTYPE_OCTETSTRING
                       && dwCachedSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
                      ||(dwUserSyntax == LDAPTYPE_SECURITY_DESCRIPTOR
                         && dwCachedSyntax == LDAPTYPE_OCTETSTRING))
                {
                    dwCachedSyntax = dwUserSyntax;

                } else {
                    //
                    // Check for UTC/GenTime mismatch before ret error.
                    //
                    if (!((dwCachedSyntax == LDAPTYPE_GENERALIZEDTIME)
                            && (dwUserSyntax == LDAPTYPE_UTCTIME))) {

                        hr = E_ADS_CANT_CONVERT_DATATYPE;
                        BAIL_ON_FAILURE(hr);
                    }
                }
            } // if dwUserSyntax != dwCachedSyntax
        }

        dwSyntaxUsed = dwCachedSyntax;

        pLdapSrcObjects = &ldapSrcObjects;           // no conversion needed
    }


    //
    // translate ldap prop status to ads control code
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);


    //
    // translate the property from Ldap objects to a PropertyEntry
    //

    hr = ConvertLdapValuesToVariant(
            bstrName,
            pLdapSrcObjects,
            dwSyntaxUsed,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );
    LdapTypeFreeLdapObjects( &ldapSrc2Objects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::PutPropertyItem(
    THIS_ VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    DWORD dwControlCode = 0;
    LDAPOBJECTARRAY ldapDestObjects;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwSyntaxId = 0;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = ConvertVariantToLdapValues(
                varData,
                szPropertyName,
                &dwControlCode,
                &ldapDestObjects,
                &dwSyntaxId,
                _pszLDAPServer,
                &_Credentials,
                _dwPort
                );
    BAIL_ON_FAILURE(hr);

    switch ( dwControlCode ) {

    case 0 :
        //
        // Users better know what they are doing here,
        // This the property as cleared so we do not send it
        // on the wire on th next SetInfo.
        //
        dwFlags = PROPERTY_INIT;
        break;

    case ADS_PROPERTY_CLEAR:

        //
        // Clears an entire property
        //

        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:

        //
        // Updates the entire property
        //

        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        //
        // Appends a set of values to the property
        //

        dwFlags = PROPERTY_ADD;
        break;

    case ADS_PROPERTY_DELETE:
        //
        // Delete a value(s) from the property

        dwFlags = PROPERTY_DELETE_VALUE;
        break;


    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }



    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( szPropertyName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    szPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    DWORD ADsType,
    DWORD numValues,
    DWORD dwOperation,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(ADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    if (dwOperation) {
        hr = pPropEntry->put_ControlCode((long)dwOperation);
    }

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

STDMETHODIMP
CLDAPGenObject::Item(
    THIS_ VARIANT varIndex,
    VARIANT * pVariant
    )

{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwNumValues = 0;
    LPWSTR szPropName = NULL;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = (DWORD) -1;
    VARIANT * pvVar = &varIndex;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; if one exis
    //

    // If the object has been deleted (and is in the cache
    // marked for deletion), we return
    // the item with DELETE ctrl code in all
    // the cases below.  This is consistent with GetPropertyItem's
    // behavior as well.

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:

        //
        // retrieve data object from cache; if one exists
        //

        hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwPropStatus,
                        &ldapSrcObjects
                        );
        BAIL_ON_FAILURE(hr);

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                V_BSTR(pvVar),
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );

        BAIL_ON_FAILURE(hr);

       break;

    case VT_I4:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I4(pvVar),
                    &dwSyntaxId,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                        (DWORD)V_I4(pvVar)
                        );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                szPropName,
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );

        BAIL_ON_FAILURE(hr);

        break;


    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                        (DWORD)V_I2(pvVar)
                        );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                szPropName,
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // translate the Ldap objects to variants
    //


error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::PurgePropertyList()
{
    _pPropertyCache->flushpropertycache();
    RRETURN(S_OK);
}


DWORD
MapPropCacheFlagToControlCode(
    DWORD dwPropStatus
    )
{
    DWORD dwADsCtrlCode = (DWORD) -1;

    switch (dwPropStatus) {

    case PROPERTY_INIT:
        //
        // 0 is not defined as any of the ADS_PROPERTY_ flags
        // use it to indicate that property is in init state
        //
        dwADsCtrlCode = 0;
        break;

    case PROPERTY_UPDATE:
        dwADsCtrlCode = ADS_PROPERTY_UPDATE;
        break;

    case PROPERTY_ADD:
        dwADsCtrlCode = ADS_PROPERTY_APPEND;
        break;

    case PROPERTY_DELETE:
        dwADsCtrlCode = ADS_PROPERTY_CLEAR;
        break;

    case PROPERTY_DELETE_VALUE:
        dwADsCtrlCode = ADS_PROPERTY_DELETE;
        break;

    default:
        // set to speical value to indicate unknow code
        dwADsCtrlCode = (DWORD) -1;
        break;
    }

    return dwADsCtrlCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\umi_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\servtype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#define ENTER_ROOTDSE_CRITSECT()  EnterCriticalSection(&g_RootDSECritSect)
#define LEAVE_ROOTDSE_CRITSECT()  LeaveCriticalSection(&g_RootDSECritSect)

CRITICAL_SECTION  g_RootDSECritSect;

typedef struct _rootdselist {
   LPWSTR pszLDAPServer;
   BOOL fNTDS;
   struct _rootdselist *pNext;
} ROOTDSELIST, *PROOTDSELIST;

PROOTDSELIST gpRootDSEList = NULL;

static DWORD dwRootDSECount = 0;

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );


HRESULT
ReadServerType(
    LPWSTR pszLDAPServer,
    CCredentials* pCredentials,
    BOOL * pfNTDS
    )
{

    LPTSTR *aValues = NULL;
    DWORD nCount = 0;
    HRESULT hr = S_OK;

    PROOTDSELIST pTemp = NULL;
    PROOTDSELIST pNewNode = NULL;
    BOOL fNTDS = FALSE;
    CCredentials localCredentials(NULL, NULL, 0);

    ENTER_ROOTDSE_CRITSECT();

    //
    // Let's see how many times we called this guy
    //

    dwRootDSECount++;

    pTemp = gpRootDSEList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)){

            *pfNTDS = pTemp->fNTDS;

            LEAVE_ROOTDSE_CRITSECT();

            RRETURN(hr);
       }

       pTemp = pTemp->pNext;

    }

    LEAVE_ROOTDSE_CRITSECT();

    if (pCredentials) {
        localCredentials = *pCredentials;
    }

    hr = LdapReadAttribute(
                pszLDAPServer,
                NULL,
                TEXT("SecurityMode"),
                &aValues,
                (int *)&nCount,
                localCredentials,
                (unsigned long)USE_DEFAULT_LDAP_PORT
                );
    if (SUCCEEDED(hr)) {

        if (!aValues || aValues[0] == NULL) {

            fNTDS = TRUE;

        }else if (!_wcsicmp(aValues[0], L"NT")) {

            fNTDS = TRUE;
        }else {

            fNTDS = FALSE;
        }
    }else {

        fNTDS = TRUE;
        hr = S_OK;

    }


    ENTER_ROOTDSE_CRITSECT();

    pTemp =  gpRootDSEList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)) {
            //
            // Found a match -looks like someone has come in before us
            //

            *pfNTDS = pTemp->fNTDS;

            goto exit;
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PROOTDSELIST)AllocADsMem(sizeof(ROOTDSELIST));

    if (!pNewNode) {

        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pNewNode->pNext = gpRootDSEList;


    pNewNode->pszLDAPServer = AllocADsStr(pszLDAPServer);
    //
    // pszLDAPServer might be NULL, in which case NULL is the
    // expected return value from the alloc.
    //
    if ((!(pNewNode->pszLDAPServer)) && pszLDAPServer) {

        FreeADsMem(pNewNode);
    
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pNewNode->fNTDS = fNTDS;

    gpRootDSEList = pNewNode;

    *pfNTDS =  fNTDS;

exit:

    LEAVE_ROOTDSE_CRITSECT();

    if (aValues) {

        LdapValueFree(aValues);
    }

    RRETURN(hr);
}



BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {
#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) { 
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
                ) == CSTR_EQUAL ) {
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
FreeServerType(
    )
{
    PROOTDSELIST pTemp = NULL;
    PROOTDSELIST pNext = NULL;

    ENTER_ROOTDSE_CRITSECT();

    pTemp = gpRootDSEList;

    while (pTemp) {

        pNext = pTemp->pNext;

        if (pTemp->pszLDAPServer) {

            FreeADsStr(pTemp->pszLDAPServer);
            pTemp->pszLDAPServer = NULL;

        }

        FreeADsMem(pTemp);

        pTemp = NULL;

        pTemp = pNext;

    }

    LEAVE_ROOTDSE_CRITSECT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\umi2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umi2ldap.cxx
//
//  Contents: File containing the implemenation of the conversion routines
//       that convert the user given UMI values to ldap values that can 
//       subsequently be cached if required.
//
//  History:    02-17-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"


//+---------------------------------------------------------------------------
// Function:   UmiTypeLPWSTRToLdapString
//
// Synopsis:   Converts a string value to an equivalent ldap value.
//
// Arguments:  Self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject)
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeLPWSTRToLdapString(
    LPWSTR pszSourceString,
    PLDAPOBJECT pLdapDestObject
    )
{
    ADsAssert(pszSourceString);

    //
    // We should not have NULL values but it is a good idea to check.
    //
    if (pszSourceString) {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(pszSourceString);

        if (!LDAPOBJECT_STRING(pLdapDestObject)) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeBoolean
//
// Synopsis:   Converts a bool value to an ldap boolean value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject) appropriately.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeBoolean(
    BOOL fBool,
    PLDAPOBJECT pLdapDestObject
    )
{
    if (fBool) {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(L"TRUE");
    } 
    else {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(L"FALSE");
    }

    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyI4
//
// Synopsis:   Converts a long (I4) value to an equivalent ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject) contains the new values.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyI4(
    LONG lVal,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    ADsAssert(pLdapDestObject);

    _ltot(lVal, Buffer, 10);

    LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(Buffer);
    
    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeOctetString
//
// Synopsis:   Converts an UmiOctetString to an ldap ber value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeOctetString(
    UMI_OCTET_STRING umiOctetStr,
    PLDAPOBJECT pLdapDestObject
    )
{
    DWORD dwLength = 0;

    if (umiOctetStr.lpValue) {
        dwLength = umiOctetStr.uLength;

        LDAPOBJECT_BERVAL(pLdapDestObject) = (struct berval *) 
            AllocADsMem(dwLength + sizeof(struct berval));

        if (!LDAPOBJECT_BERVAL(pLdapDestObject)) {
            RRETURN(E_OUTOFMEMORY);
        }

        //
        // Set the pointer to data and the length in the dest object.
        //
        LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwLength;
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) 
            ( (LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) 
                      + sizeof(struct berval));
       
        memcpy(
            LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            umiOctetStr.lpValue,
            dwLength
            );
    } // umiOctetStr.lpValue

    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeSecurityDescriptor.
//
// Synopsis:   Converts a UmiComObject that is an SD to an equivalent
//          ldap binary blob.
//
// Arguments:  umiComObject      -  Has the IADsSecDesc to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//             pCreds            -  Credentials to use for conversion.
//             pszServerName     -  ServerName associated with SD.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopySecurityDescriptor(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject,
    CCredentials *pCreds,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pBinarySecDesc = NULL;
    IUnknown *pUnk = (IUnknown *) umiComObject.pInterface;
    IADsSecurityDescriptor*  pADsSecDesc = NULL;
    CCredentials creds;
    DWORD dwSDLength = 0;

    //
    // QI for the IADsSecDesc, that way we can be sure of the interface.
    //
    hr = pUnk->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pADsSecDesc
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // Update the credentials if needed.
    //
    if (pCreds) {
        creds = *pCreds;
    }

    //
    // Call the helper that does the conversion in activeds.dll
    //
    hr = ConvertSecurityDescriptorToSecDes(
             pszServerName,
             creds,
             pADsSecDesc,
             &pBinarySecDesc,
             &dwSDLength,
             TRUE // NT style SD.
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now we need to copy over the data into the ldap struct.
    //
    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSDLength);

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSDLength;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = 
        (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) 
                  + sizeof(struct berval));

    memcpy( 
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject), 
        pBinarySecDesc,
        dwSDLength
        );

error:

    if (pBinarySecDesc) {
        FreeADsMem(pBinarySecDesc);
    }

    if (pADsSecDesc) {
        pADsSecDesc->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyDNWithBinary.
//
// Synopsis:   Converts a UmiComObject that is DNWithBinary obj to 
//          and equivalent ldap data.
//
// Arguments:  umiComObject      -  Has the IADsDNWithBinary to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyDNWithBinary(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IUnknown * pUnk = (IUnknown *)umiComObject.pInterface;
    VARIANT vVar;

    VariantInit(&vVar);

    vVar.vt = VT_DISPATCH;

    hr = pUnk->QueryInterface(IID_IDispatch, (void **) &vVar.pdispVal);
    BAIL_ON_FAILURE(hr);

    //
    // Call the var2ldap conversion helper to do all the hard work !.
    //
    hr = VarTypeToLdapTypeDNWithBinary(
             &vVar,
             pLdapDestObject
             );

error:

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyDNWithString.
//
// Synopsis:   Converts a UmiComObject that is DNWithString obj to 
//          and equivalent ldap data.
//
// Arguments:  umiComObject      -  Has the IADsDNWithString to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyDNWithString(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IUnknown * pUnk = (IUnknown *)umiComObject.pInterface;
    VARIANT vVar;

    VariantInit(&vVar);

    vVar.vt = VT_DISPATCH;

    hr = pUnk->QueryInterface(IID_IDispatch, (void **) &vVar.pdispVal);
    BAIL_ON_FAILURE(hr);

    //
    // Call the var2ldap conversion helper to do all the hard work !.
    //
    hr = VarTypeToLdapTypeDNWithString(
             &vVar,
             pLdapDestObject
             );

error:

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyI8
//
// Synopsis:   Convert an int64 value to the corresponding ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded large integer object.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyI8(
    __int64 int64Val,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if (!swprintf (Buffer, L"%I64d", int64Val))
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

    LDAPOBJECT_STRING(pLdapDestObject) = /*(LPTSTR)*/ AllocADsStr( Buffer );

    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error :

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyUTCTime
//
// Synopsis:   Convert a SYSTEMTIME object to the corresponding ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded utc time value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyUTCTime(
    SYSTEMTIME sysTimeObj,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;
    ADSVALUE adsValue;

    adsValue.dwType = ADSTYPE_UTC_TIME;
    adsValue.UTCTime = sysTimeObj;

    //
    // Use the helper to convert the value appropriately.
    //
    hr = AdsTypeToLdapTypeCopyTime(
             &adsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyGeneralizedTime
//
// Synopsis:   Converts a SystemTime value to a ldap generalized time value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded generalized time value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyGeneralizedTime(
    SYSTEMTIME sysTimeObj,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;
    ADSVALUE adsValue;

    adsValue.dwType = ADSTYPE_UTC_TIME;
    adsValue.UTCTime = sysTimeObj;

    //
    // Use the helper to convert the value appropriately.
    //
    hr = AdsTypeToLdapTypeCopyGeneralizedTime(
             &adsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeEnumToLdapTypeEnum
//
// Synopsis:   Converts the passed in umiType to the equivalent ldapType.
//          Note that the conversion is just for the type and not the actual
//          data itself. Example UMI_TYPE_I4 to LDAPTYPE_INTEGER.
//
// Arguments:  ulUmiType       -   Umi type to convert.
//             pdwSyntax       -   Return ldap syntax.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *pdwSyntax with appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeEnum(
    ULONG  ulUmiType,
    PDWORD pdwSyntax
    )
{
    HRESULT hr = S_OK;

    switch (ulUmiType) {
    
    case UMI_TYPE_I4 :
        *pdwSyntax = LDAPTYPE_INTEGER;
        break;

    case UMI_TYPE_I8 :
        *pdwSyntax = LDAPTYPE_INTEGER8;
        break;

    case UMI_TYPE_SYSTEMTIME :
        //
        // What about utc Time ?
        //
        *pdwSyntax = LDAPTYPE_GENERALIZEDTIME;
        break;

    case UMI_TYPE_BOOL :
        *pdwSyntax = LDAPTYPE_BOOLEAN;
        break;

    case UMI_TYPE_IUNKNOWN :
        //
        // How about the other IUnknowns ?
        //
        *pdwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
        break;

    case UMI_TYPE_LPWSTR :
        *pdwSyntax = LDAPTYPE_CASEIGNORESTRING;
        break;

    case UMI_TYPE_OCTETSTRING :
        *pdwSyntax = LDAPTYPE_OCTETSTRING;
        break;

    case UMI_TYPE_UNDEFINED:
    case UMI_TYPE_NULL :
    case UMI_TYPE_I1 :
    case UMI_TYPE_I2 :
    case UMI_TYPE_UI1 :
    case UMI_TYPE_UI2 :
    case UMI_TYPE_UI4 :
    case UMI_TYPE_UI8 :
    case UMI_TYPE_R4 :
    case UMI_TYPE_R8 :
    case UMI_TYPE_FILETIME :
    case UMI_TYPE_IDISPATCH :
    case UMI_TYPE_VARIANT :
    case UMI_TYPE_UMIARRAY :
    case UMI_TYPE_DISCOVERY :
    case UMI_TYPE_DEFAULT :
    default:
        *pdwSyntax = (DWORD) -1;
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopy
//
// Synopsis:   Helper routine to convert ldap values to the required UMI
//            data type. 
//
// Arguments:  umiPropArray     - input UMI data.
//             ulFlags          - flags indicating type of operation.
//             pLdapDestObjects - Ptr to hold the output from routine.
//             dwLdapSyntaxId   - ref to dword.
//             fUtcTime         - optional defaulted to False.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObjects to point to valid data.
//             dwLdapSyntaxId with the ldap syntax id for the data type (this
//             will enable us to return the data correctly to the user).
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopy(
    UMI_PROPERTY_VALUES umiPropArray,
    ULONG ulFlags,
    LDAPOBJECTARRAY *pLdapDestObjects,
    DWORD &dwLdapSyntaxId,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    BOOL fUtcTime
    )
{
    HRESULT hr = S_OK;
    ULONG ulUmiType, ulCount, ulCtr;
    PUMI_PROPERTY pUmiProp;

    //
    // Internal routine so an assert should be enough.
    //
    ADsAssert(pLdapDestObjects);

    //
    // Initalize count on ldapobjects to zero and 
    // default is string values for the contents.
    //
    pLdapDestObjects->dwCount = 0;
    pLdapDestObjects->fIsString = TRUE;

    //
    // Verify that we have some valid data.
    //
    if (!umiPropArray.pPropArray || (umiPropArray.uCount != 1)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    pUmiProp = umiPropArray.pPropArray;
    ulUmiType = pUmiProp->uType;
    ulCount = pUmiProp->uCount;

    if ( ulCount == 0 ) {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects =
        (PLDAPOBJECT)AllocADsMem( ulCount * sizeof(LDAPOBJECT));

    if (pLdapDestObjects->pLdapObjects == NULL)
        RRETURN(E_OUTOFMEMORY);

    //
    // If we are here, then pUmiValue has to be valid.
    //
    if (!pUmiProp->pUmiValue) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    for (ulCtr =0; ulCtr < ulCount; ulCtr++) {
        //
        // Need to go through and convert each of the values.
        //
        switch (ulUmiType) {
        //
        // Call appropriate routine based on type.
        //
        case UMI_TYPE_I1 :
        case UMI_TYPE_I2 :

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_I4 :

            if (!pUmiProp->pUmiValue->lValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            hr = UmiTypeToLdapTypeCopyI4(
                     pUmiProp->pUmiValue->lValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_INTEGER;
            break;
            
        case UMI_TYPE_I8 :

            if (!pUmiProp->pUmiValue->nValue64) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            hr = UmiTypeToLdapTypeCopyI8(
                     pUmiProp->pUmiValue->nValue64[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_INTEGER8;
            break;

        case UMI_TYPE_UI1 :
        case UMI_TYPE_UI2 :
        case UMI_TYPE_UI4 :
        case UMI_TYPE_UI8 :
        case UMI_TYPE_R4  :
        case UMI_TYPE_R8  :
            //
            // We do not handle any of the unsigned data types or 
            // the real data types..
            //
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_SYSTEMTIME :

            if (!pUmiProp->pUmiValue->sysTimeValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            //
            // Need to use the special info to see if this is an UTC Time
            // value or if this is a Generalized time value - GenTime is
            // always the default value though.
            //
            if (fUtcTime) {
                hr = UmiTypeToLdapTypeCopyUTCTime(
                         pUmiProp->pUmiValue->sysTimeValue[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_UTCTIME;
            }
            else {
                hr = UmiTypeToLdapTypeCopyGeneralizedTime(
                         pUmiProp->pUmiValue->sysTimeValue[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_GENERALIZEDTIME;
            }
            
            break;

        case UMI_TYPE_BOOL :

            if (!pUmiProp->pUmiValue->bValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            hr = UmiTypeToLdapTypeBoolean(
                     pUmiProp->pUmiValue->bValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_BOOLEAN;
            break;

        case UMI_TYPE_IDISPATCH :
        case UMI_TYPE_VARIANT  :
            //
            // We do not support these.
            //
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_LPWSTR :

            if (!pUmiProp->pUmiValue->pszStrValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            hr = UmiTypeLPWSTRToLdapString(
                     pUmiProp->pUmiValue->pszStrValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_CASEEXACTSTRING;
            break;

        case UMI_TYPE_OCTETSTRING :
            
            if (!pUmiProp->pUmiValue->octetStr) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            //
            // Override default settings as this is no longer true.
            //
            pLdapDestObjects->fIsString = FALSE;

            hr = UmiTypeToLdapTypeOctetString(
                     pUmiProp->pUmiValue->octetStr[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_OCTETSTRING;
            break;

        case UMI_TYPE_IUNKNOWN:

            if (!pUmiProp->pUmiValue->comObject
                || !pUmiProp->pUmiValue->comObject[ulCtr].pInterface
                ) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            //
            // Based on the type we should call the appropriate function.
            //
            IID *priid;
            priid = pUmiProp->pUmiValue->comObject[ulCtr].priid;

            if (!priid) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            if (*priid == IID_IADsSecurityDescriptor) {
                //
                // SD is stored as berval in cache.
                //
                pLdapDestObjects->fIsString = FALSE;
                
                //
                // SD needs the servername and credentials for conversion.
                //
                hr = UmiTypeToLdapTypeCopySecurityDescriptor(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr,
                         pCreds,
                         pszServerName
                         );
                dwLdapSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            } 
            else if (*priid == IID_IADsDNWithBinary) {
                //
                // Convert DNBin obj to ldap equivalent.
                //
                hr = UmiTypeToLdapTypeCopyDNWithBinary(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_DNWITHBINARY;
            }
            else if (*priid == IID_IADsDNWithString) {
                //
                // Convert DNStr obj to ldap equivalent.
                //
                hr = UmiTypeToLdapTypeCopyDNWithString(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_DNWITHSTRING;
            }
            else {
                //
                // Unknown type.
                //
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }                
            break;

        case UMI_TYPE_UMIARRAY :
        case UMI_TYPE_DISCOVERY :
        case UMI_TYPE_UNDEFINED :
        case UMI_TYPE_DEFAULT :
            
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;

        default :
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;

        } // end of case statement
        
        //
        // if hr is set there was a problem converting value.
        //
        BAIL_ON_FAILURE(hr);
        
        //
        // In case of failure we now have one more object to free
        // in the ldap object array.
        //
        pLdapDestObjects->dwCount++;

    } // end of for statement

    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    //
    // Free the ldapProperty array as needed.
    //
    LdapTypeFreeLdapObjects(pLdapDestObjects);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\wmiutils.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for wmiutils.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmiutils_h__
#define __wmiutils_h__

/* Forward Declarations */ 

#ifndef __IWbemPathKeyList_FWD_DEFINED__
#define __IWbemPathKeyList_FWD_DEFINED__
typedef interface IWbemPathKeyList IWbemPathKeyList;
#endif 	/* __IWbemPathKeyList_FWD_DEFINED__ */


#ifndef __IWbemPath_FWD_DEFINED__
#define __IWbemPath_FWD_DEFINED__
typedef interface IWbemPath IWbemPath;
#endif 	/* __IWbemPath_FWD_DEFINED__ */


#ifndef __WbemDefPath_FWD_DEFINED__
#define __WbemDefPath_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemDefPath WbemDefPath;
#else
typedef struct WbemDefPath WbemDefPath;
#endif /* __cplusplus */

#endif 	/* __WbemDefPath_FWD_DEFINED__ */


#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef interface IWbemQuery IWbemQuery;
#endif 	/* __IWbemQuery_FWD_DEFINED__ */


#ifndef __WbemQuery_FWD_DEFINED__
#define __WbemQuery_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemQuery WbemQuery;
#else
typedef struct WbemQuery WbemQuery;
#endif /* __cplusplus */

#endif 	/* __WbemQuery_FWD_DEFINED__ */


#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef interface IWbemQuery IWbemQuery;
#endif 	/* __IWbemQuery_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemUtilities_v1_LIBRARY_DEFINED__
#define __WbemUtilities_v1_LIBRARY_DEFINED__

/* library WbemUtilities_v1 */
/* [uuid] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_PATH_STATUS_FLAG
    {	WBEMPATH_INFO_ANON_LOCAL_MACHINE	= 0x1,
	WBEMPATH_INFO_HAS_MACHINE_NAME	= 0x2,
	WBEMPATH_INFO_IS_CLASS_REF	= 0x4,
	WBEMPATH_INFO_IS_INST_REF	= 0x8,
	WBEMPATH_INFO_HAS_SUBSCOPES	= 0x10,
	WBEMPATH_INFO_IS_COMPOUND	= 0x20,
	WBEMPATH_INFO_HAS_V2_REF_PATHS	= 0x40,
	WBEMPATH_INFO_HAS_IMPLIED_KEY	= 0x80,
	WBEMPATH_INFO_CONTAINS_SINGLETON	= 0x100,
	WBEMPATH_INFO_V1_COMPLIANT	= 0x200,
	WBEMPATH_INFO_V2_COMPLIANT	= 0x400,
	WBEMPATH_INFO_CIM_COMPLIANT	= 0x800,
	WBEMPATH_INFO_IS_SINGLETON	= 0x1000,
	WBEMPATH_INFO_IS_PARENT	= 0x2000,
	WBEMPATH_INFO_SERVER_NAMESPACE_ONLY	= 0x4000,
	WBEMPATH_INFO_NATIVE_PATH	= 0x8000,
	WBEMPATH_INFO_WMI_PATH	= 0x10000
    } 	tag_WBEM_PATH_STATUS_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_PATH_CREATE_FLAG
    {	WBEMPATH_CREATE_ACCEPT_RELATIVE	= 0x1,
	WBEMPATH_CREATE_ACCEPT_ABSOLUTE	= 0x2,
	WBEMPATH_CREATE_ACCEPT_ALL	= 0x4,
	WBEMPATH_TREAT_SINGLE_IDENT_AS_NS	= 0x8
    } 	tag_WBEM_PATH_CREATE_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_TEXT_FLAGS
    {	WBEMPATH_COMPRESSED	= 0x1,
	WBEMPATH_GET_RELATIVE_ONLY	= 0x2,
	WBEMPATH_GET_SERVER_TOO	= 0x4,
	WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY	= 0x8
    } 	tag_WBEM_GET_TEXT_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_KEY_FLAGS
    {	WBEMPATH_TEXT	= 0x1,
	WBEMPATH_QUOTEDTEXT	= 0x2
    } 	tag_WBEM_GET_KEY_FLAGS;



EXTERN_C const IID LIBID_WbemUtilities_v1;

#ifndef __IWbemPathKeyList_INTERFACE_DEFINED__
#define __IWbemPathKeyList_INTERFACE_DEFINED__

/* interface IWbemPathKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemPathKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9AE62877-7544-4bb0-AA26-A13824659ED6")
    IWbemPathKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeSingleton( 
            /* [in] */ boolean bSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemPathKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemPathKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemPathKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey2 )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey2 )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeSingleton )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ boolean bSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText);
        
        END_INTERFACE
    } IWbemPathKeyListVtbl;

    interface IWbemPathKeyList
    {
        CONST_VTBL struct IWbemPathKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemPathKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemPathKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemPathKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemPathKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IWbemPathKeyList_SetKey(This,wszName,uFlags,uCimType,pKeyVal)	\
    (This)->lpVtbl -> SetKey(This,wszName,uFlags,uCimType,pKeyVal)

#define IWbemPathKeyList_SetKey2(This,wszName,uFlags,uCimType,pKeyVal)	\
    (This)->lpVtbl -> SetKey2(This,wszName,uFlags,uCimType,pKeyVal)

#define IWbemPathKeyList_GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType)

#define IWbemPathKeyList_GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType)	\
    (This)->lpVtbl -> GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType)

#define IWbemPathKeyList_RemoveKey(This,wszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,wszName,uFlags)

#define IWbemPathKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IWbemPathKeyList_MakeSingleton(This,bSet)	\
    (This)->lpVtbl -> MakeSingleton(This,bSet)

#define IWbemPathKeyList_GetInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetInfo(This,uRequestedInfo,puResponse)

#define IWbemPathKeyList_GetText(This,lFlags,puBuffLength,pszText)	\
    (This)->lpVtbl -> GetText(This,lFlags,puBuffLength,pszText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetCount_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IWbemPathKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_SetKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCimType,
    /* [in] */ LPVOID pKeyVal);


void __RPC_STUB IWbemPathKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_SetKey2_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCimType,
    /* [in] */ VARIANT __RPC_FAR *pKeyVal);


void __RPC_STUB IWbemPathKeyList_SetKey2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
    /* [out][in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
    /* [out][in] */ LPVOID pKeyVal,
    /* [out] */ ULONG __RPC_FAR *puApparentCimType);


void __RPC_STUB IWbemPathKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetKey2_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
    /* [out][in] */ LPWSTR pszKeyName,
    /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
    /* [out] */ ULONG __RPC_FAR *puApparentCimType);


void __RPC_STUB IWbemPathKeyList_GetKey2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_RemoveKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemPathKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_RemoveAllKeys_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemPathKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_MakeSingleton_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ boolean bSet);


void __RPC_STUB IWbemPathKeyList_MakeSingleton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetInfo_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IWbemPathKeyList_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetText_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPathKeyList_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemPathKeyList_INTERFACE_DEFINED__ */


#ifndef __IWbemPath_INTERFACE_DEFINED__
#define __IWbemPath_INTERFACE_DEFINED__

/* interface IWbemPath */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BC15AF2-736C-477e-9E51-238AF8667DCC")
    IWbemPath : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllNamespaces( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScope( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllScopes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemPath __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetServer )( 
            IWbemPath __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServer )( 
            IWbemPath __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceCount )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllNamespaces )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeCount )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScopeFromText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeAsText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllScopes )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClassName )( 
            IWbemPath __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassName )( 
            IWbemPath __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassPart )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassPart )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemPathVtbl;

    interface IWbemPath
    {
        CONST_VTBL struct IWbemPathVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemPath_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemPath_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemPath_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemPath_SetText(This,uMode,pszPath)	\
    (This)->lpVtbl -> SetText(This,uMode,pszPath)

#define IWbemPath_GetText(This,lFlags,puBuffLength,pszText)	\
    (This)->lpVtbl -> GetText(This,lFlags,puBuffLength,pszText)

#define IWbemPath_GetInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetInfo(This,uRequestedInfo,puResponse)

#define IWbemPath_SetServer(This,Name)	\
    (This)->lpVtbl -> SetServer(This,Name)

#define IWbemPath_GetServer(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetServer(This,puNameBufLength,pName)

#define IWbemPath_GetNamespaceCount(This,puCount)	\
    (This)->lpVtbl -> GetNamespaceCount(This,puCount)

#define IWbemPath_SetNamespaceAt(This,uIndex,pszName)	\
    (This)->lpVtbl -> SetNamespaceAt(This,uIndex,pszName)

#define IWbemPath_GetNamespaceAt(This,uIndex,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetNamespaceAt(This,uIndex,puNameBufLength,pName)

#define IWbemPath_RemoveNamespaceAt(This,uIndex)	\
    (This)->lpVtbl -> RemoveNamespaceAt(This,uIndex)

#define IWbemPath_RemoveAllNamespaces(This)	\
    (This)->lpVtbl -> RemoveAllNamespaces(This)

#define IWbemPath_GetScopeCount(This,puCount)	\
    (This)->lpVtbl -> GetScopeCount(This,puCount)

#define IWbemPath_SetScope(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetScope(This,uIndex,pszClass)

#define IWbemPath_SetScopeFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetScopeFromText(This,uIndex,pszText)

#define IWbemPath_GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IWbemPath_GetScopeAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetScopeAsText(This,uIndex,puTextBufSize,pszText)

#define IWbemPath_RemoveScope(This,uIndex)	\
    (This)->lpVtbl -> RemoveScope(This,uIndex)

#define IWbemPath_RemoveAllScopes(This)	\
    (This)->lpVtbl -> RemoveAllScopes(This)

#define IWbemPath_SetClassName(This,Name)	\
    (This)->lpVtbl -> SetClassName(This,Name)

#define IWbemPath_GetClassName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetClassName(This,puBuffLength,pszName)

#define IWbemPath_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IWbemPath_CreateClassPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateClassPart(This,lFlags,Name)

#define IWbemPath_DeleteClassPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteClassPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemPath_SetText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uMode,
    /* [in] */ LPCWSTR pszPath);


void __RPC_STUB IWbemPath_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetInfo_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IWbemPath_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetServer_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_SetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetServer_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IWbemPath_GetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetNamespaceCount_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IWbemPath_GetNamespaceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [string][in] */ LPCWSTR pszName);


void __RPC_STUB IWbemPath_SetNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IWbemPath_GetNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IWbemPath_RemoveNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveAllNamespaces_Proxy( 
    IWbemPath __RPC_FAR * This);


void __RPC_STUB IWbemPath_RemoveAllNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScopeCount_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IWbemPath_GetScopeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IWbemPath_SetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetScopeFromText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_SetScopeFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IWbemPath_GetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScopeAsText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_GetScopeAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IWbemPath_RemoveScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveAllScopes_Proxy( 
    IWbemPath __RPC_FAR * This);


void __RPC_STUB IWbemPath_RemoveAllScopes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetClassName_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_SetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetClassName_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IWbemPath_GetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetKeyList_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IWbemPath_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_CreateClassPart_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_CreateClassPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_DeleteClassPart_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemPath_DeleteClassPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemPath_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemDefPath;

#ifdef __cplusplus

class DECLSPEC_UUID("cf4cc405-e2c5-4ddd-b3ce-5e7582d8c9fa")
WbemDefPath;
#endif

#ifndef __IWbemQuery_INTERFACE_DEFINED__
#define __IWbemQuery_INTERFACE_DEFINED__

/* interface IWbemQuery */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81166f58-dd98-11d3-a120-00105a1f515a")
    IWbemQuery : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Empty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguageFeatures( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestLanguageFeatures( 
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAnalysis( 
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueryInfo( 
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachClassDef( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pClassDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestObject( 
            /* [in] */ ULONG uTestType,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringTest( 
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Empty )( 
            IWbemQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageFeatures )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestLanguageFeatures )( 
            IWbemQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parse )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnalysis )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQueryInfo )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachClassDef )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pClassDef);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestObject )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uTestType,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringTest )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr);
        
        END_INTERFACE
    } IWbemQueryVtbl;

    interface IWbemQuery
    {
        CONST_VTBL struct IWbemQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQuery_Empty(This)	\
    (This)->lpVtbl -> Empty(This)

#define IWbemQuery_SetLanguageFeatures(This,lFlags,uArraySize,puFeatures)	\
    (This)->lpVtbl -> SetLanguageFeatures(This,lFlags,uArraySize,puFeatures)

#define IWbemQuery_TestLanguageFeatures(This,uArraySize,puFeatures)	\
    (This)->lpVtbl -> TestLanguageFeatures(This,uArraySize,puFeatures)

#define IWbemQuery_Parse(This,pszLang,pszQuery,uFlags)	\
    (This)->lpVtbl -> Parse(This,pszLang,pszQuery,uFlags)

#define IWbemQuery_GetAnalysis(This,uAnalysisType,uFlags,pAnalysis)	\
    (This)->lpVtbl -> GetAnalysis(This,uAnalysisType,uFlags,pAnalysis)

#define IWbemQuery_FreeMemory(This,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,pMem)

#define IWbemQuery_GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf)	\
    (This)->lpVtbl -> GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf)

#define IWbemQuery_AttachClassDef(This,riid,pClassDef)	\
    (This)->lpVtbl -> AttachClassDef(This,riid,pClassDef)

#define IWbemQuery_TestObject(This,uTestType,uFlags,riid,pObj)	\
    (This)->lpVtbl -> TestObject(This,uTestType,uFlags,riid,pObj)

#define IWbemQuery_StringTest(This,uTestType,pszTestStr,pszExpr)	\
    (This)->lpVtbl -> StringTest(This,uTestType,pszTestStr,pszExpr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQuery_Empty_Proxy( 
    IWbemQuery __RPC_FAR * This);


void __RPC_STUB IWbemQuery_Empty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_SetLanguageFeatures_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uArraySize,
    /* [in] */ ULONG __RPC_FAR *puFeatures);


void __RPC_STUB IWbemQuery_SetLanguageFeatures_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_TestLanguageFeatures_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *uArraySize,
    /* [out] */ ULONG __RPC_FAR *puFeatures);


void __RPC_STUB IWbemQuery_TestLanguageFeatures_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_Parse_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLang,
    /* [in] */ LPCWSTR pszQuery,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemQuery_Parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_GetAnalysis_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uAnalysisType,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pAnalysis);


void __RPC_STUB IWbemQuery_GetAnalysis_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_FreeMemory_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ LPVOID pMem);


void __RPC_STUB IWbemQuery_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_GetQueryInfo_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uAnalysisType,
    /* [in] */ ULONG uInfoId,
    /* [in] */ ULONG uBufSize,
    /* [out] */ LPVOID pDestBuf);


void __RPC_STUB IWbemQuery_GetQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_AttachClassDef_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pClassDef);


void __RPC_STUB IWbemQuery_AttachClassDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_TestObject_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uTestType,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pObj);


void __RPC_STUB IWbemQuery_TestObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_StringTest_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uTestType,
    /* [in] */ LPCWSTR pszTestStr,
    /* [in] */ LPCWSTR pszExpr);


void __RPC_STUB IWbemQuery_StringTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQuery_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemQuery;

#ifdef __cplusplus

class DECLSPEC_UUID("EAC8A024-21E2-4523-AD73-A71A0AA2F56A")
WbemQuery;
#endif
#endif /* __WbemUtilities_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wmiutils_0107 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0001
    {	WMIQ_ANALYSIS_RPN_SEQUENCE	= 0x1,
	WMIQ_ANALYSIS_ASSOC_QUERY	= 0x2,
	WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX	= 0x3
    } 	WMIQ_ANALYSIS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0002
    {	WMIQ_RPN_TOKEN_EXPRESSION	= 1,
	WMIQ_RPN_TOKEN_AND	= 2,
	WMIQ_RPN_TOKEN_OR	= 3,
	WMIQ_RPN_TOKEN_NOT	= 4,
	WMIQ_RPN_OP_UNDEFINED	= 0,
	WMIQ_RPN_OP_EQ	= 1,
	WMIQ_RPN_OP_NE	= 2,
	WMIQ_RPN_OP_GE	= 3,
	WMIQ_RPN_OP_LE	= 4,
	WMIQ_RPN_OP_LT	= 5,
	WMIQ_RPN_OP_GT	= 6,
	WMIQ_RPN_OP_LIKE	= 7,
	WMIQ_RPN_OP_ISA	= 8,
	WMIQ_RPN_OP_ISNOTA	= 9,
	WMIQ_RPN_LEFT_PROPERTY_NAME	= 0x1,
	WMIQ_RPN_RIGHT_PROPERTY_NAME	= 0x2,
	WMIQ_RPN_CONST2	= 0x4,
	WMIQ_RPN_CONST	= 0x8,
	WMIQ_RPN_RELOP	= 0x10,
	WMIQ_RPN_LEFT_FUNCTION	= 0x20,
	WMIQ_RPN_RIGHT_FUNCTION	= 0x30,
	WMIQ_RPN_GET_TOKEN_TYPE	= 1,
	WMIQ_RPN_GET_EXPR_SHAPE	= 2,
	WMIQ_RPN_GET_LEFT_FUNCTION	= 3,
	WMIQ_RPN_GET_RIGHT_FUNCTION	= 4,
	WMIQ_RPN_GET_RELOP	= 5,
	WMIQ_RPN_NEXT_TOKEN	= 1,
	WMIQ_RPN_FROM_UNARY	= 0x1,
	WMIQ_RPN_FROM_PATH	= 0x2,
	WMIQ_RPN_FROM_CLASS_LIST	= 0x4
    } 	WMIQ_RPN_TOKEN_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0003
    {	WMIQ_ASSOCQ_ASSOCIATORS	= 0x1,
	WMIQ_ASSOCQ_REFERENCES	= 0x2,
	WMIQ_ASSOCQ_RESULTCLASS	= 0x4,
	WMIQ_ASSOCQ_ROLE	= 0x8,
	WMIQ_ASSOCQ_RESULTROLE	= 0x10,
	WMIQ_ASSOCQ_REQUIREDQUALIFIER	= 0x20,
	WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER	= 0x40,
	WMIQ_ASSOCQ_CLASSDEFSONLY	= 0x80,
	WMIQ_ASSOCQ_KEYSONLY	= 0x100,
	WMIQ_ASSOCQ_SCHEMAONLY	= 0x200,
	WMIQ_ASSOCQ_CLASSREFSONLY	= 0x400
    } 	WMIQ_ASSOCQ_FLAGS;

typedef struct tag_SWbemQueryQualifiedName
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNameListSize;
    LPCWSTR __RPC_FAR *m_ppszNameList;
    BOOL m_bArraysUsed;
    BOOL __RPC_FAR *m_pbArrayElUsed;
    ULONG __RPC_FAR *m_puArrayIndex;
    } 	SWbemQueryQualifiedName;

typedef union tag_SWbemRpnConst
    {
    LPCWSTR m_pszStrVal;
    BOOL m_bBoolVal;
    LONG m_lLongVal;
    ULONG m_uLongVal;
    double m_dblVal;
    __int64 m_lVal64;
    __int64 m_uVal64;
    } 	SWbemRpnConst;

typedef struct tag_SWbemRpnQueryToken
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uSubexpressionShape;
    ULONG m_uOperator;
    SWbemQueryQualifiedName __RPC_FAR *m_pRightIdent;
    SWbemQueryQualifiedName __RPC_FAR *m_pLeftIdent;
    ULONG m_uConstApparentType;
    SWbemRpnConst m_Const;
    ULONG m_uConst2ApparentType;
    SWbemRpnConst m_Const2;
    LPCWSTR m_pszRightFunc;
    LPCWSTR m_pszLeftFunc;
    } 	SWbemRpnQueryToken;

typedef struct tag_SWbemRpnTokenList
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNumTokens;
    } 	SWbemRpnTokenList;

typedef 
enum tag_WMIQ_LANGUAGE_FEATURES
    {	WMIQ_LF1_BASIC_SELECT	= 1,
	WMIQ_LF2_CLASS_NAME_IN_QUERY	= 2,
	WMIQ_LF3_STRING_CASE_FUNCTIONS	= 3,
	WMIQ_LF4_PROP_TO_PROP_TESTS	= 4,
	WMIQ_LF5_COUNT_STAR	= 5,
	WMIQ_LF6_ORDER_BY	= 6,
	WMIQ_LF7_DISTINCT	= 7,
	WMIQ_LF8_ISA	= 8,
	WMIQ_LF9_THIS	= 9,
	WMIQ_LF10_COMPEX_SUBEXPRESSIONS	= 10,
	WMIQ_LF11_ALIASING	= 11,
	WMIQ_LF12_GROUP_BY_HAVING	= 12,
	WMIQ_LF13_WMI_WITHIN	= 13,
	WMIQ_LF14_SQL_WRITE_OPERATIONS	= 14,
	WMIQ_LF15_GO	= 15,
	WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS	= 16,
	WMIQ_LF17_QUALIFIED_NAMES	= 17,
	WMIQ_LF18_ASSOCIATONS	= 18,
	WMIQ_LF19_SYSTEM_PROPERTIES	= 19,
	WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES	= 20,
	WMIQ_LF21_SQL89_JOINS	= 21,
	WMIQ_LF22_SQL92_JOINS	= 22,
	WMIQ_LF23_SUBSELECTS	= 23,
	WMIQ_LF24_UMI_EXTENSIONS	= 24,
	WMIQ_LF25_DATEPART	= 25,
	WMIQ_LF26_LIKE	= 26,
	WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS	= 27,
	WMIQ_LF28_STANDARD_AGGREGATES	= 28,
	WMIQ_LF29_MULTI_LEVEL_ORDER_BY	= 29,
	WMIQ_LF30_WMI_PRAGMAS	= 30,
	WMIQ_LF31_QUALIFIER_TESTS	= 31,
	WMIQ_LF32_SP_EXECUTE	= 32,
	WMIQ_LF33_ARRAY_ACCESS	= 33,
	WMIQ_LF34_UNION	= 34,
	WMIQ_LF35_COMPLEX_SELECT_TARGET	= 35,
	WMIQ_LF36_REFERENCE_TESTS	= 36,
	WMIQ_LF37_SELECT_INTO	= 37,
	WMIQ_LF38_BASIC_DATETIME_TESTS	= 38,
	WMIQ_LF_LAST	= 39
    } 	WMIQ_LANGUAGE_FEATURES;

typedef 
enum tag_WMIQ_RPNQ_FEATURE
    {	WMIQ_RPNF_WHERE_CLAUSE_PRESENT	= 0x1,
	WMIQ_RPNF_QUERY_IS_CONJUNCTIVE	= 0x2,
	WMIQ_RPNF_QUERY_IS_DISJUNCTIVE	= 0x4,
	WMIQ_RPNF_PROJECTION	= 0x8,
	WMIQ_RPNF_FEATURE_SELECT_STAR	= 0x10,
	WMIQ_RPNF_EQUALITY_TESTS_ONLY	= 0x20,
	WMIQ_RPNF_COUNT_STAR	= 0x40,
	WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT	= 0x80,
	WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE	= 0x100,
	WMIQ_RPNF_PROP_TO_PROP_TESTS	= 0x200,
	WMIQ_RPNF_ORDER_BY	= 0x400,
	WMIQ_RPNF_ISA_USED	= 0x800,
	WMIQ_RPNF_ISNOTA_USED	= 0x1000,
	WMIQ_RPNF_GROUP_BY_HAVING	= 0x2000,
	WMIQ_RPNF_WITHIN_INTERVAL	= 0x4000,
	WMIQ_RPNF_WITHIN_AGGREGATE	= 0x8000,
	WMIQ_RPNF_SYSPROP_CLASS	= 0x10000,
	WMIQ_RPNF_REFERENCE_TESTS	= 0x20000,
	WMIQ_RPNF_DATETIME_TESTS	= 0x40000,
	WMIQ_RPNF_ARRAY_ACCESS	= 0x80000,
	WMIQ_RPNF_QUALIFIER_FILTER	= 0x100000,
	WMIQ_RPNF_SELECTED_FROM_PATH	= 0x200000
    } 	WMIQ_RPNF_FEATURE;

typedef struct tag_SWbemRpnEncodedQuery
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uParsedFeatureMask1;
    ULONG m_uParsedFeatureMask2;
    ULONG m_uDetectedArraySize;
    ULONG __RPC_FAR *m_puDetectedFeatures;
    ULONG m_uSelectListSize;
    SWbemQueryQualifiedName __RPC_FAR *__RPC_FAR *m_ppSelectList;
    ULONG m_uFromTargetType;
    LPCWSTR m_pszOptionalFromPath;
    ULONG m_uFromListSize;
    LPCWSTR __RPC_FAR *m_ppszFromList;
    ULONG m_uWhereClauseSize;
    SWbemRpnQueryToken __RPC_FAR *__RPC_FAR *m_ppRpnWhereClause;
    double m_dblWithinPolling;
    double m_dblWithinWindow;
    ULONG m_uOrderByListSize;
    LPCWSTR __RPC_FAR *m_ppszOrderByList;
    ULONG __RPC_FAR *m_uOrderDirectionEl;
    } 	SWbemRpnEncodedQuery;

typedef struct tag_SWbemAnalysisMatrix
    {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    LPCWSTR m_pszProperty;
    ULONG m_uPropertyType;
    ULONG m_uEntries;
    LPVOID __RPC_FAR *m_pValues;
    BOOL __RPC_FAR *m_pbTruthTable;
    } 	SWbemAnalysisMatrix;

typedef struct tag_SWbemAnalysisMatrixList
    {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    ULONG m_uNumMatrices;
    SWbemAnalysisMatrix __RPC_FAR *m_pMatrices;
    } 	SWbemAnalysisMatrixList;

typedef struct tag_SWbemAssocQueryInf
    {
    ULONG m_uVersion;
    ULONG m_uAnalysisType;
    ULONG m_uFeatureMask;
    IWbemPath __RPC_FAR *m_pPath;
    LPWSTR m_pszPath;
    LPWSTR m_pszQueryText;
    LPWSTR m_pszResultClass;
    LPWSTR m_pszAssocClass;
    LPWSTR m_pszRole;
    LPWSTR m_pszResultRole;
    LPWSTR m_pszRequiredQualifier;
    LPWSTR m_pszRequiredAssocQualifier;
    } 	SWbemAssocQueryInf;



extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0107_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\var2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       var2ldap.cxx
//
//  Contents:   Variant to LDAP object Copy Routines
//
//  Functions:
//
//  History:      25-Jun-96   yihsins  Created.
//
//
//  Issues:
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// LdapType objects copy code
//

HRESULT
VarTypeToLdapTypeString(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD nStrLen;

    if(pVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!pVarSrcObject->bstrVal) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    nStrLen = _tcslen( pVarSrcObject->bstrVal );

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (nStrLen + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    if ( nStrLen == 0 ) {
        _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), L"");
        RRETURN(S_OK);
    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), pVarSrcObject->bstrVal );

    RRETURN(S_OK);
}

HRESULT
VarTypeToLdapTypeBoolean(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszStr = NULL;

    if(pVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ( pVarSrcObject->boolVal )
        pszStr = TEXT("TRUE");
    else
        pszStr = TEXT("FALSE");

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (_tcslen(pszStr) + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        RRETURN(hr = E_OUTOFMEMORY);

    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), pszStr );

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeUTCTime(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    int nSuccess = 0;
    ADSVALUE adsValue;
    DWORD dwSyntaxId = 0;

    if (pVarSrcObject->vt != VT_DATE)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    adsValue.dwType = ADSTYPE_UTC_TIME;
    nSuccess = VariantTimeToSystemTime(
                        pVarSrcObject->date,
                        &adsValue.UTCTime
                        );
    if (!nSuccess) {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    hr = AdsTypeToLdapTypeCopyTime(
                &adsValue,
                pLdapDestObject,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeGeneralizedTime(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE adsValue;
    DWORD dwErr = 0;
    DWORD dwSyntaxId = 0;

    if (pVarSrcObject->vt != VT_DATE)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    adsValue.dwType = ADSTYPE_UTC_TIME;

    dwErr = VariantTimeToSystemTime(
                pVarSrcObject->date,
                &adsValue.UTCTime
                );

    if (dwErr != TRUE) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }


    hr = AdsTypeToLdapTypeCopyGeneralizedTime(
                    &adsValue,
                    pLdapDestObject,
                    &dwSyntaxId
                    );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeInteger(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if( pVarSrcObject->vt != VT_I4 && pVarSrcObject->vt != VT_I2){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if(pVarSrcObject->vt == VT_I4)
       _ltot( pVarSrcObject->lVal, Buffer, 10 );
    else
       _itot( pVarSrcObject->iVal, Buffer, 10 );

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (_tcslen(Buffer) + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), Buffer );

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeBinaryData(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSUBound - dwSLBound + 1);

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSUBound - dwSLBound + 1;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject), pArray,dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

error:

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )

{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor FAR * pSecDes = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwSDLength = 0;
    IDispatch FAR * pDispatch = NULL;
    BOOL fNTDS = TRUE;

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    pDispatch = V_DISPATCH(pVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsSecurityDescriptor,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);


    hr = ReadServerType(
             pszServerName,
             &Credentials,
             &fNTDS
             );
    BAIL_ON_FAILURE(hr);

    hr = ConvertSecurityDescriptorToSecDes(
                pszServerName,
                Credentials,
                pSecDes,
                &pSecurityDescriptor,
                &dwSDLength,
                fNTDS
                );
    BAIL_ON_FAILURE(hr);

    LDAPOBJECT_BERVAL(pLdapDestObject) =

        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSDLength);


    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSDLength;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =(CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject), pSecurityDescriptor, dwSDLength);


error:
    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeLargeInteger(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsLargeInteger *pLargeInteger = NULL;
    TCHAR Buffer[64];
    LARGE_INTEGER LargeInteger;

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsLargeInteger,
                             (void **)&pLargeInteger
                             );
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_HighPart(&LargeInteger.HighPart);
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_LowPart((LONG*)&LargeInteger.LowPart);
    BAIL_ON_FAILURE(hr);

    swprintf (Buffer, L"%I64d", LargeInteger);

    LDAPOBJECT_STRING(pLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

error:
    if (pLargeInteger) {
        pLargeInteger->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeDNWithBinary(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsDNWithBinary *pDNBinary = NULL;
    PADSVALUE pADsValue = NULL;
    VARIANT vBinary;
    BSTR bstrDN = NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    DWORD dwSyntaxId = 0;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;
    CHAR HUGEP *pArray = NULL;

    VariantInit(&vBinary);

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsDNWithBinary,
                             (void **)&pDNBinary
                             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNBinary->get_BinaryValue(&vBinary);
    BAIL_ON_FAILURE(hr);

    if ((vBinary.vt != (VT_ARRAY | VT_UI1))
        && vBinary.vt != VT_EMPTY) {

        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDNBinary->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    //
    // Get the byte array in a usable format.
    //
    hr = SafeArrayGetLBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    dwLength = dwSUBound - dwSLBound + 1;

    lpByte = (LPBYTE) AllocADsMem(dwLength);

    if (dwLength && !lpByte) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vBinary),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(lpByte, pArray, dwLength);

    SafeArrayUnaccessData( V_ARRAY(&vBinary) );

    pADsValue = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

    if (!pADsValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->dwType = ADSTYPE_DN_WITH_BINARY;
    pADsValue->pDNWithBinary = (PADS_DN_WITH_BINARY)
                                 AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pADsValue->pDNWithBinary) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->pDNWithBinary->dwLength = dwLength;
    pADsValue->pDNWithBinary->lpBinaryValue = lpByte;


    pADsValue->pDNWithBinary->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pADsValue->pDNWithBinary->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // At this point the ADSIValue object is ready
    //
    hr = AdsTypeToLdapTypeCopyDNWithBinary(
             pADsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pDNBinary) {
        pDNBinary->Release();
    }

    VariantClear(&vBinary);

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    //
    // Since we just have ptr to the byte array in the adsvalue
    // struct, if that is freed, we do not have to seperately
    // free the lpByte - if not we have to.
    //
    if (pADsValue) {
        //
        // Maybe we should replace with ADsTypeFreeAdsObjects.
        //
        if (pADsValue->pDNWithBinary) {
            if (pADsValue->pDNWithBinary->pszDNString) {
                FreeADsStr(pADsValue->pDNWithBinary->pszDNString);
            }
            if (pADsValue->pDNWithBinary->lpBinaryValue) {
                FreeADsMem(pADsValue->pDNWithBinary->lpBinaryValue);
            }
            FreeADsMem(pADsValue->pDNWithBinary);
        }

        FreeADsMem(pADsValue);
    }
    else if (lpByte) {
        FreeADsMem(lpByte);
    }


    RRETURN(hr);
}



HRESULT
VarTypeToLdapTypeDNWithString(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsDNWithString *pDNString = NULL;
    PADSVALUE pADsValue = NULL;
    BSTR bstrStringValue = NULL;
    BSTR bstrDN = NULL;
    DWORD dwSyntaxId = 0;
    DWORD dwLength = 0;


    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsDNWithString,
                             (void **)&pDNString
                             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNString->get_StringValue(&bstrStringValue);
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    pADsValue = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

    if (!pADsValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->dwType = ADSTYPE_DN_WITH_STRING;
    pADsValue->pDNWithString = (PADS_DN_WITH_STRING)
                                AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pADsValue->pDNWithString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Put String value in the DNString struct.
    //
    pADsValue->pDNWithString->pszStringValue = AllocADsStr(bstrStringValue);

    if (bstrStringValue && !pADsValue->pDNWithString->pszStringValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->pDNWithString->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pADsValue->pDNWithString->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // At this point the ADSIValue object is ready
    //
    hr = AdsTypeToLdapTypeCopyDNWithString(
             pADsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pDNString) {
        pDNString->Release();
    }

    if (bstrStringValue) {
        ADsFreeString(bstrStringValue);
    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    if (pADsValue) {
        //
        // Maybe we should replace with ADsTypeFreeAdsObjects.
        //
        if (pADsValue->pDNWithString) {

            if (pADsValue->pDNWithString->pszDNString) {
                FreeADsStr(pADsValue->pDNWithString->pszDNString);
            }

            if (pADsValue->pDNWithString->pszStringValue) {
                FreeADsMem(pADsValue->pDNWithString->pszStringValue);
            }
            FreeADsMem(pADsValue->pDNWithString);
        }

        FreeADsMem(pADsValue);
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeCopy(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    DWORD dwLdapType,
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject,
    BOOL *pfIsString
    )
{
    HRESULT hr = S_OK;

    *pfIsString = TRUE;  // This will only be FALSE when the variant
                         // contains binary data

    switch (dwLdapType){
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:

        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        //
        // These types are treatable as strings
        // (see RFCs 2252, 2256)
        //
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = VarTypeToLdapTypeString(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = VarTypeToLdapTypeBoolean(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = VarTypeToLdapTypeInteger(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            *pfIsString = FALSE;
            hr = VarTypeToLdapTypeBinaryData(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = VarTypeToLdapTypeGeneralizedTime(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = VarTypeToLdapTypeUTCTime(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_SECURITY_DESCRIPTOR:
            *pfIsString = FALSE;
            hr = VarTypeToLdapTypeSecDes(
                        pszServerName,
                        Credentials,
                        pVarSrcObject,
                        pLdapDestObject
                        );
            break;

        case LDAPTYPE_INTEGER8:
            hr = VarTypeToLdapTypeLargeInteger(
                        pVarSrcObject,
                        pLdapDestObject
                        );
            break;

#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = VarTypeToLdapTypeDNWithBinary(
                     pVarSrcObject,
                     pLdapDestObject
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = VarTypeToLdapTypeDNWithString(
                     pVarSrcObject,
                     pLdapDestObject
                     );
            break;

        default:
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeCopyConstruct(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    DWORD dwLdapType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LDAPOBJECTARRAY *pLdapDestObjects
    )
{

    DWORD i = 0;
    HRESULT hr = S_OK;


    if ( dwNumObjects == 0 )
    {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects =
        (PLDAPOBJECT)AllocADsMem( dwNumObjects * sizeof(LDAPOBJECT));

    if (pLdapDestObjects->pLdapObjects == NULL)
        RRETURN(E_OUTOFMEMORY);

    pLdapDestObjects->dwCount = dwNumObjects;

    for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToLdapTypeCopy(
                    pszServerName,
                    Credentials,
                    dwLdapType,
                    pVarSrcObjects + i,
                    pLdapDestObjects->pLdapObjects + i,
                    &(pLdapDestObjects->fIsString)
                    );
         BAIL_ON_FAILURE(hr);
     }

     RRETURN(S_OK);

error:

     LdapTypeFreeLdapObjects( pLdapDestObjects );

     RRETURN(hr);
}

HRESULT
GetLdapSyntaxFromVariant(
    VARIANT * pvProp,
    PDWORD pdwSyntaxId,
    LPTSTR pszServer,
    LPTSTR pszAttrName,
    CCredentials& Credentials,
    DWORD dwPort
    )
{

//    IADsSecurityDescriptor * pSecDes = NULL;
//    IADsLargeInteger * pLargeInt = NULL;
    IDispatch * pDispObj = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    if (!pvProp) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    switch (pvProp->vt) {
    case VT_BSTR:
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
        break;

    case VT_I8:
        *pdwSyntaxId = LDAPTYPE_INTEGER8;
        break;

    case VT_I4:
        *pdwSyntaxId = LDAPTYPE_INTEGER;
        break;

    case VT_I2:
        *pdwSyntaxId = LDAPTYPE_INTEGER;
        break;

    case VT_BOOL:
        *pdwSyntaxId = LDAPTYPE_BOOLEAN;
        break;

    case VT_DATE:
        //
        // We need to determine if it is a GeneralizedTime
        // or UTCTime property. If the lookup fails on the
        // server we will failover to GenTime.
        //
        hr = E_FAIL;

        if (pszAttrName) {

            //
            // pszAttrName will be null if we are coming in
            // from the property cache on putproperty
            //
            hr = LdapGetSyntaxOfAttributeOnServer(
                     pszServer,
                     pszAttrName,
                     pdwSyntaxId,
                     Credentials,
                     dwPort
                     );
        }

        if (FAILED(hr)) {
            // Default to GenTime
            *pdwSyntaxId = LDAPTYPE_GENERALIZEDTIME;
        }

        break;

    case (VT_ARRAY | VT_UI1):
        *pdwSyntaxId = LDAPTYPE_OCTETSTRING;
        break;


    case (VT_DISPATCH):
        pDispatch = V_DISPATCH(pvProp);

        // Security Descriptor
        hr = pDispatch->QueryInterface(
                        IID_IADsSecurityDescriptor,
                        (void **)&pDispObj
                        );

        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            break;
        }

        // Large Integer
        hr = pDispatch->QueryInterface(
                        IID_IADsLargeInteger,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_INTEGER8;
            break;
        }

        // DN With Binary
        hr = pDispatch->QueryInterface(
                        IID_IADsDNWithBinary,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_DNWITHBINARY;
            break;
        }

        // DN With String
        hr = pDispatch->QueryInterface(
                        IID_IADsDNWithString,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_DNWITHSTRING;
            break;
        }

        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER)
        break;

    default:
       RRETURN(E_FAIL);


    }

    RRETURN(S_OK);

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\proto-lb.h ===
/*
 * lber-proto.h
 * function prototypes for lber library
 */

#ifdef LDAP_DEBUG
extern int lber_debug;
#endif

#ifndef LDAPFUNCDECL
#ifdef _WIN32
#define LDAPFUNCDECL	__declspec( dllexport )
#else /* _WIN32 */
#define LDAPFUNCDECL
#endif /* _WIN32 */
#endif /* LDAPFUNCDECL */

/*
 * in bprint.c:
 */
LDAPFUNCDECL void lber_bprint( char *data, int len );

/*
 * in decode.c:
 */
LDAPFUNCDECL unsigned long ber_get_tag( BerElement *ber );
LDAPFUNCDECL unsigned long ber_skip_tag( BerElement *ber, unsigned long *len );
LDAPFUNCDECL unsigned long ber_peek_tag( BerElement *ber, unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_int( BerElement *ber, long *num );
LDAPFUNCDECL unsigned long ber_get_stringb( BerElement *ber, char *buf,
	unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_stringa( BerElement *ber, char **buf );
LDAPFUNCDECL unsigned long ber_get_stringal( BerElement *ber, struct berval **bv );
LDAPFUNCDECL unsigned long ber_get_bitstringa( BerElement *ber, char **buf,
	unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_null( BerElement *ber );
LDAPFUNCDECL unsigned long ber_get_boolean( BerElement *ber, int *boolval );
LDAPFUNCDECL unsigned long ber_first_element( BerElement *ber, unsigned long *len,
	char **last );
LDAPFUNCDECL unsigned long ber_next_element( BerElement *ber, unsigned long *len,
	char *last );
#if defined( MACOS ) || defined( BC31 ) || defined( _WIN32 )
LDAPFUNCDECL unsigned long ber_scanf( BerElement *ber, char *fmt, ... );
#else
LDAPFUNCDECL unsigned long ber_scanf();
#endif
LDAPFUNCDECL void ber_bvfree( struct berval *bv );
LDAPFUNCDECL void ber_bvecfree( struct berval **bv );
LDAPFUNCDECL struct berval *ber_bvdup( struct berval *bv );
#ifdef STR_TRANSLATION
LDAPFUNCDECL void ber_set_string_translators( BerElement *ber,
	BERTranslateProc encode_proc, BERTranslateProc decode_proc );
#endif /* STR_TRANSLATION */

/*
 * in encode.c
 */
LDAPFUNCDECL int ber_put_enum( BerElement *ber, long num, unsigned long tag );
LDAPFUNCDECL int ber_put_int( BerElement *ber, long num, unsigned long tag );
LDAPFUNCDECL int ber_put_ostring( BerElement *ber, char *str, unsigned long len,
	unsigned long tag );
LDAPFUNCDECL int ber_put_string( BerElement *ber, char *str, unsigned long tag );
LDAPFUNCDECL int ber_put_bitstring( BerElement *ber, char *str,
	unsigned long bitlen, unsigned long tag );
LDAPFUNCDECL int ber_put_null( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_put_boolean( BerElement *ber, int boolval,
	unsigned long tag );
LDAPFUNCDECL int ber_start_seq( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_start_set( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_put_seq( BerElement *ber );
LDAPFUNCDECL int ber_put_set( BerElement *ber );
#if defined( MACOS ) || defined( BC31 ) || defined( _WIN32 )
LDAPFUNCDECL int ber_printf( BerElement *ber, char *fmt, ... );
#else
LDAPFUNCDECL int ber_printf();
#endif

/*
 * in io.c:
 */
LDAPFUNCDECL long ber_read( BerElement *ber, char *buf, unsigned long len );
LDAPFUNCDECL long ber_write( BerElement *ber, char *buf, unsigned long len,
	int nosos );
LDAPFUNCDECL void ber_free( BerElement *ber, int freebuf );
LDAPFUNCDECL int ber_flush( Sockbuf *sb, BerElement *ber, int freeit );
LDAPFUNCDECL BerElement *ber_alloc( void );
LDAPFUNCDECL BerElement *der_alloc( void );
LDAPFUNCDECL BerElement *ber_alloc_t( int options );
LDAPFUNCDECL BerElement *ber_dup( BerElement *ber );
LDAPFUNCDECL void ber_dump( BerElement *ber, int inout );
LDAPFUNCDECL void ber_sos_dump( Seqorset *sos );
LDAPFUNCDECL unsigned long ber_get_next( Sockbuf *sb, unsigned long *len,
	BerElement *ber );
LDAPFUNCDECL void ber_init( BerElement *ber, int options );
LDAPFUNCDECL void ber_reset( BerElement *ber, int was_writing );

#ifdef NEEDGETOPT
/*
 * in getopt.c
 */
int getopt( int nargc, char **nargv, char *ostr );
#endif /* NEEDGETOPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\ldap.h ===
/*
 * Copyright (c) 1990 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _LDAP_H
#define _LDAP_H

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINSOCK
#include "msdos.h"
#include <winsock.h>
#endif

#if !defined( NEEDPROTOS ) && defined(__STDC__)
#define NEEDPROTOS	1
#endif

#define LDAP_PORT	389
#define LDAP_VERSION1	1
#define LDAP_VERSION2	2
#define LDAP_VERSION	LDAP_VERSION2

#define COMPAT20
#define COMPAT30
#if defined(COMPAT20) || defined(COMPAT30)
#define COMPAT
#endif

#define LDAP_MAX_ATTR_LEN	100

/* debugging stuff */
#ifdef LDAP_DEBUG
extern int	ldap_debug;
#ifdef LDAP_SYSLOG
extern int	ldap_syslog;
extern int	ldap_syslog_level;
#endif
#define LDAP_DEBUG_TRACE	0x001
#define LDAP_DEBUG_PACKETS	0x002
#define LDAP_DEBUG_ARGS		0x004
#define LDAP_DEBUG_CONNS	0x008
#define LDAP_DEBUG_BER		0x010
#define LDAP_DEBUG_FILTER	0x020
#define LDAP_DEBUG_CONFIG	0x040
#define LDAP_DEBUG_ACL		0x080
#define LDAP_DEBUG_STATS	0x100
#define LDAP_DEBUG_STATS2	0x200
#define LDAP_DEBUG_SHELL	0x400
#define LDAP_DEBUG_PARSE	0x800
#define LDAP_DEBUG_ANY		0xffff

#ifdef LDAP_SYSLOG
#define Debug( level, fmt, arg1, arg2, arg3 )	\
	{ \
		if ( ldap_debug & level ) \
			fprintf( stderr, fmt, arg1, arg2, arg3 ); \
		if ( ldap_syslog & level ) \
			syslog( ldap_syslog_level, fmt, arg1, arg2, arg3 ); \
	}
#else /* LDAP_SYSLOG */
#ifndef WINSOCK
#define Debug( level, fmt, arg1, arg2, arg3 ) \
		if ( ldap_debug & level ) \
			fprintf( stderr, fmt, arg1, arg2, arg3 );
#else /* !WINSOCK */
extern void Debug( int level, char* fmt, ... );
#endif /* !WINSOCK */
#endif /* LDAP_SYSLOG */
#else /* LDAP_DEBUG */
#define Debug( level, fmt, arg1, arg2, arg3 )
#endif /* LDAP_DEBUG */

/* 
 * specific LDAP instantiations of BER types we know about
 */

/* general stuff */
#define LDAP_TAG_MESSAGE	0x30L	/* tag is 16 + constructed bit */
#define OLD_LDAP_TAG_MESSAGE	0x10L	/* forgot the constructed bit  */
#define LDAP_TAG_MSGID		0x02L

/* possible operations a client can invoke */
#define LDAP_REQ_BIND			0x60L	/* application + constructed */
#define LDAP_REQ_UNBIND			0x42L	/* application + primitive   */
#define LDAP_REQ_SEARCH			0x63L	/* application + constructed */
#define LDAP_REQ_MODIFY			0x66L	/* application + constructed */
#define LDAP_REQ_ADD			0x68L	/* application + constructed */
#define LDAP_REQ_DELETE			0x4aL	/* application + primitive   */
#define LDAP_REQ_MODRDN			0x6cL	/* application + constructed */
#define LDAP_REQ_COMPARE		0x6eL	/* application + constructed */
#define LDAP_REQ_ABANDON		0x50L	/* application + primitive   */

/* version 3.0 compatibility stuff */
#define LDAP_REQ_UNBIND_30		0x62L
#define LDAP_REQ_DELETE_30		0x6aL
#define LDAP_REQ_ABANDON_30		0x70L

/* 
 * old broken stuff for backwards compatibility - forgot application tag
 * and constructed/primitive bit
 */
#define OLD_LDAP_REQ_BIND		0x00L
#define OLD_LDAP_REQ_UNBIND		0x02L
#define OLD_LDAP_REQ_SEARCH		0x03L
#define OLD_LDAP_REQ_MODIFY		0x06L
#define OLD_LDAP_REQ_ADD		0x08L
#define OLD_LDAP_REQ_DELETE		0x0aL
#define OLD_LDAP_REQ_MODRDN		0x0cL
#define OLD_LDAP_REQ_COMPARE		0x0eL
#define OLD_LDAP_REQ_ABANDON		0x10L

/* possible result types a server can return */
#define LDAP_RES_BIND			0x61L	/* application + constructed */
#define LDAP_RES_SEARCH_ENTRY		0x64L	/* application + constructed */
#define LDAP_RES_SEARCH_RESULT		0x65L	/* application + constructed */
#define LDAP_RES_MODIFY			0x67L	/* application + constructed */
#define LDAP_RES_ADD			0x69L	/* application + constructed */
#define LDAP_RES_DELETE			0x6bL	/* application + constructed */
#define LDAP_RES_MODRDN			0x6dL	/* application + constructed */
#define LDAP_RES_COMPARE		0x6fL	/* application + constructed */
#define LDAP_RES_ANY			(-1L)

/* old broken stuff for backwards compatibility */
#define OLD_LDAP_RES_BIND		0x01L
#define OLD_LDAP_RES_SEARCH_ENTRY	0x04L
#define OLD_LDAP_RES_SEARCH_RESULT	0x05L
#define OLD_LDAP_RES_MODIFY		0x07L
#define OLD_LDAP_RES_ADD		0x09L
#define OLD_LDAP_RES_DELETE		0x0bL
#define OLD_LDAP_RES_MODRDN		0x0dL
#define OLD_LDAP_RES_COMPARE		0x0fL

/* authentication methods available */
#define LDAP_AUTH_NONE		0x00L	/* no authentication		  */
#define LDAP_AUTH_SIMPLE	0x80L	/* context specific + primitive   */
#define LDAP_AUTH_KRBV4		0xffL	/* means do both of the following */
#define LDAP_AUTH_KRBV41	0x81L	/* context specific + primitive   */
#define LDAP_AUTH_KRBV42	0x82L	/* context specific + primitive   */

/* 3.0 compatibility auth methods */
#define LDAP_AUTH_SIMPLE_30	0xa0L	/* context specific + constructed */
#define LDAP_AUTH_KRBV41_30	0xa1L	/* context specific + constructed */
#define LDAP_AUTH_KRBV42_30	0xa2L	/* context specific + constructed */

/* old broken stuff */
#define OLD_LDAP_AUTH_SIMPLE	0x00L
#define OLD_LDAP_AUTH_KRBV4	0x01L
#define OLD_LDAP_AUTH_KRBV42	0x02L

/* filter types */
#define LDAP_FILTER_AND		0xa0L	/* context specific + constructed */
#define LDAP_FILTER_OR		0xa1L	/* context specific + constructed */
#define LDAP_FILTER_NOT		0xa2L	/* context specific + constructed */
#define LDAP_FILTER_EQUALITY	0xa3L	/* context specific + constructed */
#define LDAP_FILTER_SUBSTRINGS	0xa4L	/* context specific + constructed */
#define LDAP_FILTER_GE		0xa5L	/* context specific + constructed */
#define LDAP_FILTER_LE		0xa6L	/* context specific + constructed */
#define LDAP_FILTER_PRESENT	0x87L	/* context specific + primitive   */
#define LDAP_FILTER_APPROX	0xa8L	/* context specific + constructed */

/* 3.0 compatibility filter types */
#define LDAP_FILTER_PRESENT_30	0xa7L	/* context specific + constructed */

/* old broken stuff */
#define OLD_LDAP_FILTER_AND		0x00L
#define OLD_LDAP_FILTER_OR		0x01L
#define OLD_LDAP_FILTER_NOT		0x02L
#define OLD_LDAP_FILTER_EQUALITY	0x03L
#define OLD_LDAP_FILTER_SUBSTRINGS	0x04L
#define OLD_LDAP_FILTER_GE		0x05L
#define OLD_LDAP_FILTER_LE		0x06L
#define OLD_LDAP_FILTER_PRESENT		0x07L
#define OLD_LDAP_FILTER_APPROX		0x08L

/* substring filter component types */
#define LDAP_SUBSTRING_INITIAL	0x80L	/* context specific */
#define LDAP_SUBSTRING_ANY	0x81L	/* context specific */
#define LDAP_SUBSTRING_FINAL	0x82L	/* context specific */

/* 3.0 compatibility substring filter component types */
#define LDAP_SUBSTRING_INITIAL_30	0xa0L	/* context specific */
#define LDAP_SUBSTRING_ANY_30		0xa1L	/* context specific */
#define LDAP_SUBSTRING_FINAL_30		0xa2L	/* context specific */

/* old broken stuff */
#define OLD_LDAP_SUBSTRING_INITIAL	0x00L
#define OLD_LDAP_SUBSTRING_ANY		0x01L
#define OLD_LDAP_SUBSTRING_FINAL	0x02L

/* search scopes */
#define LDAP_SCOPE_BASE		0x00
#define LDAP_SCOPE_ONELEVEL	0x01
#define LDAP_SCOPE_SUBTREE	0x02

/* for modifications */
typedef struct ldapmod {
	int		mod_op;
#define LDAP_MOD_ADD		0x00
#define LDAP_MOD_DELETE		0x01
#define LDAP_MOD_REPLACE	0x02
#define LDAP_MOD_BVALUES	0x80
	char		*mod_type;
	union {
		char		**modv_strvals;
		struct berval	**modv_bvals;
	} mod_vals;
#define mod_values	mod_vals.modv_strvals
#define mod_bvalues	mod_vals.modv_bvals
	struct ldapmod	*mod_next;
} LDAPMod;

/* 
 * possible error codes we can return
 */

#define LDAP_SUCCESS			0x00
#define LDAP_OPERATIONS_ERROR		0x01
#define LDAP_PROTOCOL_ERROR		0x02
#define LDAP_TIMELIMIT_EXCEEDED		0x03
#define LDAP_SIZELIMIT_EXCEEDED		0x04
#define LDAP_COMPARE_FALSE		0x05
#define LDAP_COMPARE_TRUE		0x06
#define LDAP_STRONG_AUTH_NOT_SUPPORTED	0x07
#define LDAP_STRONG_AUTH_REQUIRED	0x08
#define LDAP_PARTIAL_RESULTS		0x09

#define LDAP_NO_SUCH_ATTRIBUTE		0x10
#define LDAP_UNDEFINED_TYPE		0x11
#define LDAP_INAPPROPRIATE_MATCHING	0x12
#define LDAP_CONSTRAINT_VIOLATION	0x13
#define LDAP_TYPE_OR_VALUE_EXISTS	0x14
#define LDAP_INVALID_SYNTAX		0x15

#define LDAP_NO_SUCH_OBJECT		0x20
#define LDAP_ALIAS_PROBLEM		0x21
#define LDAP_INVALID_DN_SYNTAX		0x22
#define LDAP_IS_LEAF			0x23
#define LDAP_ALIAS_DEREF_PROBLEM	0x24

#define NAME_ERROR(n)	((n & 0xf0) == 0x20)

#define LDAP_INAPPROPRIATE_AUTH		0x30
#define LDAP_INVALID_CREDENTIALS	0x31
#define LDAP_INSUFFICIENT_ACCESS	0x32
#define LDAP_BUSY			0x33
#define LDAP_UNAVAILABLE		0x34
#define LDAP_UNWILLING_TO_PERFORM	0x35
#define LDAP_LOOP_DETECT		0x36

#define LDAP_NAMING_VIOLATION		0x40
#define LDAP_OBJECT_CLASS_VIOLATION	0x41
#define LDAP_NOT_ALLOWED_ON_NONLEAF	0x42
#define LDAP_NOT_ALLOWED_ON_RDN		0x43
#define LDAP_ALREADY_EXISTS		0x44
#define LDAP_NO_OBJECT_CLASS_MODS	0x45
#define LDAP_RESULTS_TOO_LARGE		0x46

#define LDAP_OTHER			0x50
#define LDAP_SERVER_DOWN		0x51
#define LDAP_LOCAL_ERROR		0x52
#define LDAP_ENCODING_ERROR		0x53
#define LDAP_DECODING_ERROR		0x54
#define LDAP_TIMEOUT			0x55
#define LDAP_AUTH_UNKNOWN		0x56
#define LDAP_FILTER_ERROR		0x57
#define LDAP_USER_CANCELLED		0x58
#define LDAP_PARAM_ERROR		0x59
#define LDAP_NO_MEMORY			0x5a


/* default limit on nesting of referrals */
#define LDAP_DEFAULT_REFHOPLIMIT	5

/*
 * This structure represents both ldap messages and ldap responses.
 * These are really the same, except in the case of search responses,
 * where a response has multiple messages.
 */

typedef struct ldapmsg {
	int		lm_msgid;	/* the message id */
	int		lm_msgtype;	/* the message type */
	BerElement	*lm_ber;	/* the ber encoded message contents */
	struct ldapmsg	*lm_chain;	/* for search - next msg in the resp */
	struct ldapmsg	*lm_next;	/* next response */
	unsigned long	lm_time;	/* used to maintain cache */
} LDAPMessage;
#define NULLMSG	((LDAPMessage *) NULL)


#ifdef LDAP_REFERRALS
/*
 * structure for tracking LDAP server host, ports, DNs, etc.
 */
typedef struct ldap_server {
	char			*lsrv_host;
	char			*lsrv_dn;	/* if NULL, use default */
	int			lsrv_port;
	struct ldap_server	*lsrv_next;
} LDAPServer;


/*
 * structure for representing an LDAP server connection
 */
typedef struct ldap_conn {
	Sockbuf			*lconn_sb;
	int			lconn_refcnt;
	unsigned long		lconn_lastused;	/* time */
	int			lconn_status;
#define LDAP_CONNST_NEEDSOCKET		1
#define LDAP_CONNST_CONNECTING		2
#define LDAP_CONNST_CONNECTED		3
	LDAPServer		*lconn_server;
	char			*lconn_krbinstance;
	struct ldap_conn	*lconn_next;
} LDAPConn;


/*
 * structure used to track outstanding requests
 */
typedef struct ldapreq {
	int		lr_msgid;	/* the message id */
	int		lr_status;	/* status of request */
#define LDAP_REQST_INPROGRESS	1
#define LDAP_REQST_CHASINGREFS	2
#define LDAP_REQST_NOTCONNECTED	3
#define LDAP_REQST_WRITING	4
	int		lr_outrefcnt;	/* count of outstanding referrals */
	int		lr_origid;	/* original request's message id */
	int		lr_parentcnt;	/* count of parent requests */
	int		lr_res_msgtype;	/* result message type */
	int		lr_res_errno;	/* result LDAP errno */
	char		*lr_res_error;	/* result error string */
	char		*lr_res_matched;/* result matched DN string */
	BerElement	*lr_ber;	/* ber encoded request contents */
	LDAPConn	*lr_conn;	/* connection used to send request */
	struct ldapreq	*lr_parent;	/* request that spawned this referral */
	struct ldapreq	*lr_refnext;	/* next referral spawned */
	struct ldapreq	*lr_prev;	/* previous request */
	struct ldapreq	*lr_next;	/* next request */
} LDAPRequest;
#endif /* LDAP_REFERRALS */


/*
 * structure for client cache
 */
#define LDAP_CACHE_BUCKETS	31	/* cache hash table size */
typedef struct ldapcache {
	LDAPMessage	*lc_buckets[LDAP_CACHE_BUCKETS];/* hash table */
	LDAPMessage	*lc_requests;			/* unfulfilled reqs */
	long		lc_timeout;			/* request timeout */
	long		lc_maxmem;			/* memory to use */
	long		lc_memused;			/* memory in use */
	int		lc_enabled;			/* enabled? */
	unsigned long	lc_options;			/* options */
#define LDAP_CACHE_OPT_CACHENOERRS	0x00000001
#define LDAP_CACHE_OPT_CACHEALLERRS	0x00000002
}  LDAPCache;
#define NULLLDCACHE ((LDAPCache *)NULL)

/*
 * structures for ldap getfilter routines
 */

typedef struct ldap_filt_info {
	char			*lfi_filter;
	char			*lfi_desc;
	int			lfi_scope;	/* LDAP_SCOPE_BASE, etc */
	int			lfi_isexact;	/* exact match filter? */
	struct ldap_filt_info	*lfi_next;
} LDAPFiltInfo;

typedef struct ldap_filt_list {
    char			*lfl_tag;
    char			*lfl_pattern;
    char			*lfl_delims;
    LDAPFiltInfo		*lfl_ilist;
    struct ldap_filt_list	*lfl_next;
} LDAPFiltList;


#define LDAP_FILT_MAXSIZ	1024

typedef struct ldap_filt_desc {
	LDAPFiltList		*lfd_filtlist;
	LDAPFiltInfo		*lfd_curfip;
	LDAPFiltInfo		lfd_retfi;
	char			lfd_filter[ LDAP_FILT_MAXSIZ ];
	char			*lfd_curval;
	char			*lfd_curvalcopy;
	char			**lfd_curvalwords;
	char			*lfd_filtprefix;
	char			*lfd_filtsuffix;
} LDAPFiltDesc;


/*
 * structure representing an ldap connection
 */

typedef struct ldap {
	Sockbuf		ld_sb;		/* socket descriptor & buffer */
	char		*ld_host;
	int		ld_version;
	char		ld_lberoptions;
	int		ld_deref;
#define LDAP_DEREF_NEVER	0
#define LDAP_DEREF_SEARCHING	1
#define LDAP_DEREF_FINDING	2
#define LDAP_DEREF_ALWAYS	3

	int		ld_timelimit;
	int		ld_sizelimit;
#define LDAP_NO_LIMIT		0

	LDAPFiltDesc	*ld_filtd;	/* from getfilter for ufn searches */
	char		*ld_ufnprefix;	/* for incomplete ufn's */

	int		ld_errno;
	char		*ld_error;
	char		*ld_matched;
	int		ld_msgid;

	/* do not mess with these */
#ifdef LDAP_REFERRALS
	LDAPRequest	*ld_requests;	/* list of outstanding requests */
#else /* LDAP_REFERRALS */
	LDAPMessage	*ld_requests;	/* list of outstanding requests */
#endif /* LDAP_REFERRALS */
	LDAPMessage	*ld_responses;	/* list of outstanding responses */
	int		*ld_abandoned;	/* array of abandoned requests */
	char		ld_attrbuffer[LDAP_MAX_ATTR_LEN];
	LDAPCache	*ld_cache;	/* non-null if cache is initialized */
	char		*ld_cldapdn;	/* DN used in connectionless search */

	/* it is OK to change these next four values directly */
	int		ld_cldaptries;	/* connectionless search retry count */
	int		ld_cldaptimeout;/* time between retries */
	int		ld_refhoplimit;	/* limit on referral nesting */
	unsigned long	ld_options;	/* boolean options */
#ifdef LDAP_DNS
#define LDAP_OPT_DNS		0x00000001	/* use DN & DNS */
#endif /* LDAP_DNS */
#ifdef LDAP_REFERRALS
#define LDAP_OPT_REFERRALS	0x00000002	/* chase referrals */
#endif /* LDAP_REFERRALS */
#define LDAP_OPT_RESTART	0x00000004	/* restart if EINTR occurs */

	/* do not mess with the rest though */
	char		*ld_defhost;	/* full name of default server */
	int		ld_defport;	/* port of default server */
	BERTranslateProc ld_lber_encode_translate_proc;
	BERTranslateProc ld_lber_decode_translate_proc;
#ifdef LDAP_REFERRALS
	LDAPConn	*ld_defconn;	/* default connection */
	LDAPConn	*ld_conns;	/* list of server connections */
	void		*ld_selectinfo;	/* platform specifics for select */
	int		(*ld_rebindproc)( struct ldap *ld, char **dnp,
				char **passwdp, int *authmethodp, int freeit );
				/* routine to get info needed for re-bind */
#endif /* LDAP_REFERRALS */
} LDAP;


/*
 * structure for ldap friendly mapping routines
 */

typedef struct friendly {
	char	*f_unfriendly;
	char	*f_friendly;
} FriendlyMap;


/*
 * handy macro to check whether LDAP struct is set up for CLDAP or not
 */
#define LDAP_IS_CLDAP( ld )	( ld->ld_sb.sb_naddr > 0 )


/*
 * types for ldap URL handling
 */
typedef struct ldap_url_desc {
    char	*lud_host;
    int		lud_port;
    char	*lud_dn;
    char	**lud_attrs;
    int		lud_scope;
    char	*lud_filter;
    char	*lud_string;	/* for internal use only */
} LDAPURLDesc;
#define NULLLDAPURLDESC	((LDAPURLDesc *)NULL)

#define LDAP_URL_ERR_NOTLDAP	1	/* URL doesn't begin with "ldap://" */
#define LDAP_URL_ERR_NODN	2	/* URL has no DN (required) */
#define LDAP_URL_ERR_BADSCOPE	3	/* URL scope string is invalid */
#define LDAP_URL_ERR_MEM	4	/* can't allocate memory space */


#ifndef NEEDPROTOS
extern LDAP * ldap_open();
extern LDAP *ldap_init();
#ifdef STR_TRANSLATION
extern void ldap_set_string_translators();
#ifdef LDAP_CHARSET_8859
extern int ldap_t61_to_8859();
extern int ldap_8859_to_t61();
#endif /* LDAP_CHARSET_8859 */
#endif /* STR_TRANSLATION */
extern LDAPMessage *ldap_first_entry();
extern LDAPMessage *ldap_next_entry();
extern char *ldap_get_dn();
extern char *ldap_dn2ufn();
extern char **ldap_explode_dn();
extern char *ldap_first_attribute();
extern char *ldap_next_attribute();
extern char **ldap_get_values();
extern struct berval **ldap_get_values_len();
extern void ldap_value_free();
extern void ldap_value_free_len();
extern int ldap_count_values();
extern int ldap_count_values_len();
extern char *ldap_err2string();
extern void ldap_getfilter_free();
extern LDAPFiltDesc *ldap_init_getfilter();
extern LDAPFiltDesc *ldap_init_getfilter_buf();
extern LDAPFiltInfo *ldap_getfirstfilter();
extern LDAPFiltInfo *ldap_getnextfilter();
extern void ldap_setfilteraffixes();
extern void ldap_build_filter();
extern void ldap_flush_cache();
extern void ldap_set_cache_options();
extern void ldap_uncache_entry();
extern void ldap_uncache_request();
extern char *ldap_friendly_name();
extern void ldap_free_friendlymap();
extern LDAP *cldap_open();
extern void cldap_setretryinfo();
extern void cldap_close();
extern LDAPFiltDesc *ldap_ufn_setfilter();
extern int ldap_ufn_timeout();
extern int ldap_sort_entries();
extern int ldap_sort_values();
extern int ldap_sort_strcasecmp();
void ldap_free_urldesc();
void ldap_set_rebind_proc();
void ldap_enable_translation();


#if defined(ultrix) || defined(VMS) || defined( nextstep )
extern char *strdup();
#endif

#else /* NEEDPROTOS */
#if !defined(MACOS) && !defined(DOS) && !defined(_WIN32) && !defined(WINSOCK)
#include <sys/time.h>
#endif
#if defined(WINSOCK)
#include "proto-ld.h"
#else
#include "proto-ldap.h"
#endif

#ifdef VMS
extern char *strdup( const char *s );
#endif
#if defined(ultrix) || defined( nextstep )
extern char *strdup();
#endif

#endif /* NEEDPROTOS */

#ifdef __cplusplus
}
#endif
#endif /* _LDAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\disptmpl.h ===
/*
 * Copyright (c) 1993, 1994 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 *
 * disptmpl.h:  display template library defines
 * 7 March 1994 by Mark C Smith
 */

#ifndef _DISPTMPL_H
#define _DISPTMPL_H

#ifdef __cplusplus
extern "C" {
#endif


#define LDAP_TEMPLATE_VERSION	1

/*
 * general types of items (confined to most significant byte)
 */
#define LDAP_SYN_TYPE_TEXT		0x01000000L
#define LDAP_SYN_TYPE_IMAGE		0x02000000L
#define LDAP_SYN_TYPE_BOOLEAN		0x04000000L
#define LDAP_SYN_TYPE_BUTTON		0x08000000L
#define LDAP_SYN_TYPE_ACTION		0x10000000L


/*
 * syntax options (confined to second most significant byte)
 */
#define LDAP_SYN_OPT_DEFER		0x00010000L


/* 
 * display template item syntax ids (defined by common agreement)
 * these are the valid values for the ti_syntaxid of the tmplitem
 * struct (defined below).  A general type is encoded in the
 * most-significant 8 bits, and some options are encoded in the next
 * 8 bits.  The lower 16 bits are reserved for the distinct types.
 */
#define LDAP_SYN_CASEIGNORESTR	( 1 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_MULTILINESTR	( 2 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_DN		( 3 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_BOOLEAN	( 4 | LDAP_SYN_TYPE_BOOLEAN )
#define LDAP_SYN_JPEGIMAGE	( 5 | LDAP_SYN_TYPE_IMAGE )
#define LDAP_SYN_JPEGBUTTON	( 6 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_FAXIMAGE	( 7 | LDAP_SYN_TYPE_IMAGE )
#define LDAP_SYN_FAXBUTTON	( 8 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_AUDIOBUTTON	( 9 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_TIME		( 10 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_DATE		( 11 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_LABELEDURL	( 12 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_SEARCHACTION	( 13 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_LINKACTION	( 14 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_ADDDNACTION	( 15 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_VERIFYDNACTION ( 16 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_RFC822ADDR	( 17 | LDAP_SYN_TYPE_TEXT )


/*
 * handy macros
 */
#define LDAP_GET_SYN_TYPE( syid )	((syid) & 0xFF000000L )
#define LDAP_GET_SYN_OPTIONS( syid )	((syid) & 0x00FF0000L )


/*
 * display options for output routines (used by entry2text and friends)
 */
/*
 * use calculated label width (based on length of longest label in
 * template) instead of contant width
 */
#define LDAP_DISP_OPT_AUTOLABELWIDTH	0x00000001L
#define LDAP_DISP_OPT_HTMLBODYONLY	0x00000002L

/*
 * perform search actions (applies to ldap_entry2text_search only) 
 */
#define LDAP_DISP_OPT_DOSEARCHACTIONS	0x00000002L

/*
 * include additional info. relevant to "non leaf" entries only
 * used by ldap_entry2html and ldap_entry2html_search to include "Browse"
 * and "Move Up" HREFs
 */
#define LDAP_DISP_OPT_NONLEAF		0x00000004L


/*
 * display template item options (may not apply to all types)
 * if this bit is set in ti_options, it applies.
 */
#define LDAP_DITEM_OPT_READONLY		0x00000001L
#define LDAP_DITEM_OPT_SORTVALUES	0x00000002L
#define LDAP_DITEM_OPT_SINGLEVALUED	0x00000004L
#define LDAP_DITEM_OPT_HIDEIFEMPTY	0x00000008L
#define LDAP_DITEM_OPT_VALUEREQUIRED	0x00000010L
#define LDAP_DITEM_OPT_HIDEIFFALSE	0x00000020L	/* booleans only */



/*
 * display template item structure
 */
struct ldap_tmplitem {
    unsigned long		ti_syntaxid;
    unsigned long		ti_options;
    char  			*ti_attrname;
    char			*ti_label;
    char			**ti_args;
    struct ldap_tmplitem	*ti_next_in_row;
    struct ldap_tmplitem	*ti_next_in_col;
    void			*ti_appdata;
};


#define NULLTMPLITEM	((struct ldap_tmplitem *)0)

#define LDAP_SET_TMPLITEM_APPDATA( ti, datap )	\
	(ti)->ti_appdata = (void *)(datap)

#define LDAP_GET_TMPLITEM_APPDATA( ti, type )	\
	(type)((ti)->ti_appdata)

#define LDAP_IS_TMPLITEM_OPTION_SET( ti, option )	\
	(((ti)->ti_options & option ) != 0 )


/*
 * object class array structure
 */
struct ldap_oclist {
    char		**oc_objclasses;
    struct ldap_oclist	*oc_next;
};

#define NULLOCLIST	((struct ldap_oclist *)0)


/*
 * add defaults list
 */
struct ldap_adddeflist {
    int			ad_source;
#define LDAP_ADSRC_CONSTANTVALUE	1
#define LDAP_ADSRC_ADDERSDN		2
    char		*ad_attrname;
    char		*ad_value;
    struct ldap_adddeflist	*ad_next;
};

#define NULLADLIST	((struct ldap_adddeflist *)0)


/*
 * display template global options
 * if this bit is set in dt_options, it applies.
 */
/*
 * users should be allowed to try to add objects of these entries
 */
#define LDAP_DTMPL_OPT_ADDABLE		0x00000001L

/*
 * users should be allowed to do "modify RDN" operation of these entries
 */
#define LDAP_DTMPL_OPT_ALLOWMODRDN	0x00000002L

/*
 * this template is an alternate view, not a primary view
 */
#define LDAP_DTMPL_OPT_ALTVIEW		0x00000004L


/*
 * display template structure
 */
struct ldap_disptmpl {
    char			*dt_name;
    char			*dt_pluralname;
    char			*dt_iconname;
    unsigned long		dt_options;
    char			*dt_authattrname;
    char			*dt_defrdnattrname;
    char			*dt_defaddlocation;
    struct ldap_oclist		*dt_oclist;
    struct ldap_adddeflist	*dt_adddeflist;
    struct ldap_tmplitem	*dt_items;
    void			*dt_appdata;
    struct ldap_disptmpl	*dt_next;
};

#define NULLDISPTMPL	((struct ldap_disptmpl *)0)

#define LDAP_SET_DISPTMPL_APPDATA( dt, datap )	\
	(dt)->dt_appdata = (void *)(datap)

#define LDAP_GET_DISPTMPL_APPDATA( dt, type )	\
	(type)((dt)->dt_appdata)

#define LDAP_IS_DISPTMPL_OPTION_SET( dt, option )	\
	(((dt)->dt_options & option ) != 0 )

#define LDAP_TMPL_ERR_VERSION	1
#define LDAP_TMPL_ERR_MEM	2
#define LDAP_TMPL_ERR_SYNTAX	3
#define LDAP_TMPL_ERR_FILE	4

/*
 * buffer size needed for entry2text and vals2text
 */
#define LDAP_DTMPL_BUFSIZ	8192


#ifndef NEEDPROTOS

typedef int (*writeptype)();

int ldap_init_templates();
int ldap_init_templates_buf();
void ldap_free_templates();
struct ldap_disptmpl *ldap_first_disptmpl();
struct ldap_disptmpl *ldap_next_disptmpl();
struct ldap_disptmpl *ldap_name2template();
struct ldap_disptmpl *ldap_oc2template();
char **ldap_tmplattrs();
struct ldap_tmplitem *ldap_first_tmplrow();
struct ldap_tmplitem *ldap_next_tmplrow();
struct ldap_tmplitem *ldap_first_tmplcol();
struct ldap_tmplitem *ldap_next_tmplcol();
int ldap_entry2text_search();
int ldap_entry2text();
int ldap_vals2text();
int ldap_entry2html_search();
int ldap_entry2html();
int ldap_vals2html();

#else /* !NEEDPROTOS */

typedef int (*writeptype)( void *writeparm, char *p, int len );

LDAPFUNCDECL int
ldap_init_templates( char *file, struct ldap_disptmpl **tmpllistp );

LDAPFUNCDECL int
ldap_init_templates_buf( char *buf, long buflen,
	struct ldap_disptmpl **tmpllistp );

LDAPFUNCDECL void
ldap_free_templates( struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_first_disptmpl( struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_next_disptmpl( struct ldap_disptmpl *tmpllist,
	struct ldap_disptmpl *tmpl );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_name2template( char *name, struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_oc2template( char **oclist, struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL char **
ldap_tmplattrs( struct ldap_disptmpl *tmpl, char **includeattrs, int exclude,
	 unsigned long syntaxmask );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_first_tmplrow( struct ldap_disptmpl *tmpl );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_next_tmplrow( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_first_tmplcol( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_next_tmplcol( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row,
	struct ldap_tmplitem *col );

LDAPFUNCDECL int
ldap_entry2text( LDAP *ld, char *buf, LDAPMessage *entry,
	struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts );

LDAPFUNCDECL int
ldap_vals2text( LDAP *ld, char *buf, char **vals, char *label, int labelwidth,
	unsigned long syntaxid, writeptype writeproc, void *writeparm,
	char *eol, int rdncount );

LDAPFUNCDECL int
ldap_entry2text_search( LDAP *ld, char *dn, char *base, LDAPMessage *entry,
	struct ldap_disptmpl *tmpllist, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts );

LDAPFUNCDECL int
ldap_entry2html( LDAP *ld, char *buf, LDAPMessage *entry,
	struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts, char *urlprefix, char *base );

LDAPFUNCDECL int
ldap_vals2html( LDAP *ld, char *buf, char **vals, char *label, int labelwidth,
	unsigned long syntaxid, writeptype writeproc, void *writeparm,
	char *eol, int rdncount, char *urlprefix );

LDAPFUNCDECL int
ldap_entry2html_search( LDAP *ld, char *dn, char *base, LDAPMessage *entry,
	struct ldap_disptmpl *tmpllist, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts, char *urlprefix );
#endif /* !NEEDPROTOS */


#ifdef __cplusplus
}
#endif
#endif /* _DISPTMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\lber.h ===
/*
 * Copyright (c) 1990 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _LBER_H
#define _LBER_H

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( NEEDPROTOS ) && defined(__STDC__)
#define NEEDPROTOS	1
#endif

/* BER classes and mask */
#define LBER_CLASS_UNIVERSAL	0x00
#define LBER_CLASS_APPLICATION	0x40
#define LBER_CLASS_CONTEXT	0x80
#define LBER_CLASS_PRIVATE	0xc0
#define LBER_CLASS_MASK		0xc0

/* BER encoding type and mask */
#define LBER_PRIMITIVE		0x00
#define LBER_CONSTRUCTED	0x20
#define LBER_ENCODING_MASK	0x20

#define LBER_BIG_TAG_MASK	0x1f
#define LBER_MORE_TAG_MASK	0x80

/*
 * Note that LBER_ERROR and LBER_DEFAULT are values that can never appear
 * as valid BER tags, and so it is safe to use them to report errors.  In
 * fact, any tag for which the following is true is invalid:
 *     (( tag & 0x00000080 ) != 0 ) && (( tag & 0xFFFFFF00 ) != 0 )
 */
#define LBER_ERROR		0xffffffffL
#define LBER_DEFAULT		0xffffffffL

/* general BER types we know about */
#define LBER_BOOLEAN		0x01L
#define LBER_INTEGER		0x02L
#define LBER_BITSTRING		0x03L
#define LBER_OCTETSTRING	0x04L
#define LBER_NULL		0x05L
#define LBER_ENUMERATED		0x0aL
#define LBER_SEQUENCE		0x30L	/* constructed */
#define LBER_SET		0x31L	/* constructed */

#define OLD_LBER_SEQUENCE	0x10L	/* w/o constructed bit - broken */
#define OLD_LBER_SET		0x11L	/* w/o constructed bit - broken */

#ifdef NEEDPROTOS
typedef int (*BERTranslateProc)( char **bufp, unsigned long *buflenp,
	int free_input );
#else /* NEEDPROTOS */
typedef int (*BERTranslateProc)();
#endif /* NEEDPROTOS */

typedef struct berelement {
	char		*ber_buf;
	char		*ber_ptr;
	char		*ber_end;
	struct seqorset	*ber_sos;
	unsigned long	ber_tag;
	unsigned long	ber_len;
	int		ber_usertag;
	char		ber_options;
#define LBER_USE_DER		0x01
#define LBER_USE_INDEFINITE_LEN	0x02
#define LBER_TRANSLATE_STRINGS	0x04
	char		*ber_rwptr;
	BERTranslateProc ber_encode_translate_proc;
	BERTranslateProc ber_decode_translate_proc;
} BerElement;
#define NULLBER	((BerElement *) 0)

typedef struct sockbuf {
#ifndef MACOS
	int		sb_sd;
#else /* MACOS */
	void		*sb_sd;
#endif /* MACOS */
	BerElement	sb_ber;

	int		sb_naddr;	/* > 0 implies using CLDAP (UDP) */
	void		*sb_useaddr;	/* pointer to sockaddr to use next */
	void		*sb_fromaddr;	/* pointer to message source sockaddr */
	void		**sb_addrs;	/* actually an array of pointers to
						sockaddrs */

	int		sb_options;	/* to support copying ber elements */
#define LBER_TO_FILE		0x01	/* to a file referenced by sb_fd   */
#define LBER_TO_FILE_ONLY	0x02	/* only write to file, not network */
#define LBER_MAX_INCOMING_SIZE	0x04	/* impose limit on incoming stuff  */
#define LBER_NO_READ_AHEAD	0x08	/* read only as much as requested  */
	int		sb_fd;
	long		sb_max_incoming;
} Sockbuf;
#define READBUFSIZ	8192

typedef struct seqorset {
	BerElement	*sos_ber;
	unsigned long	sos_clen;
	unsigned long	sos_tag;
	char		*sos_first;
	char		*sos_ptr;
	struct seqorset	*sos_next;
} Seqorset;
#define NULLSEQORSET	((Seqorset *) 0)

/* structure for returning a sequence of octet strings + length */
struct berval {
	unsigned long	bv_len;
	char		*bv_val;
};

#ifndef NEEDPROTOS
extern BerElement *ber_alloc();
extern BerElement *der_alloc();
extern BerElement *ber_alloc_t();
extern BerElement *ber_dup();
extern int lber_debug;
extern void ber_bvfree();
extern void ber_bvecfree();
extern struct berval *ber_bvdup();
extern void ber_dump();
extern void ber_sos_dump();
extern void lber_bprint();
extern void ber_reset();
extern void ber_init();
#else /* NEEDPROTOS */
#if defined(WINSOCK)
#include "proto-lb.h"
#else
#include "proto-lber.h"
#endif
#endif /* NEEDPROTOS */

#if !defined(__alpha) || defined(VMS)

#define LBER_HTONL( l )	htonl( l )
#define LBER_NTOHL( l )	ntohl( l )

#else /* __alpha */
/*
 * htonl and ntohl on the DEC Alpha under OSF 1 seem to only swap the
 * lower-order 32-bits of a (64-bit) long, so we define correct versions
 * here.
 */
#define LBER_HTONL( l )	(((long)htonl( (l) & 0x00000000FFFFFFFF )) << 32 \
    			| htonl( ( (l) & 0xFFFFFFFF00000000 ) >> 32 ))

#define LBER_NTOHL( l )	(((long)ntohl( (l) & 0x00000000FFFFFFFF )) << 32 \
    			| ntohl( ( (l) & 0xFFFFFFFF00000000 ) >> 32 ))
#endif /* __alpha */


/*
 * SAFEMEMCPY is an overlap-safe copy from s to d of n bytes
 */
#ifdef MACOS
#define SAFEMEMCPY( d, s, n )	BlockMoveData( (Ptr)s, (Ptr)d, n )
#else /* MACOS */
#ifdef sunos4
#define SAFEMEMCPY( d, s, n )	bcopy( s, d, n )
#else /* sunos4 */
#define SAFEMEMCPY( d, s, n )	memmove( d, s, n )
#endif /* sunos4 */
#endif /* MACOS */


#ifdef __cplusplus
}
#endif
#endif /* _LBER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\msdos.h ===
/* wsa.h */
/*
 * Copyright (c) 1993 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _MSDOS_H
#define _MSDOS_H

/*
 * NOTE: This file should be included via ldap.h.  Many symbols are
 * defined here that are needed BEFORE anything else is included.
 * Be careful !!!
 */
/*
 * The following are defined within the Integrated Development Environment
 * of Microsoft's Visual C++ Compiler (v1.52c)
 * (Options/Project/Compiler/Preprocessor/Symbols and Macros to Define)
 * But there's a (buffer length) limit to how long this list can be, so 
 * I'm doing the rest here in msdos.h
 * WINSOCK, DOS, NEEDPROTOS, NO_USERINTERFACE
 */
/*
 * MIT's krb.h doesn't use the symbols provided by Microsoft.
 * It needs __MSDOS__ and WINDOWS.  Normally _WINDOWS is provided by MS
 * but it's based on having the prolog/epilog optimization switches set
 * in a way that we don't set them. So define it manually.
 *
 * kbind.c needs __MSDOS__ for krb.h to include osconf.h 
 * which includes conf-pc.h which defines byte order and such
 */
#define __MSDOS__
/*
 * conf-pc.h wants WINDOWS rather than _WINDOWS which Microsoft provides
 */
#define WINDOWS

/*
 * Where two of the config files live in the windows environment
 * There are two others also; ldfriend.cfg, & srchpref.cfg
 * These names are different that the unix names due to 8.3 rule
 */
#define FILTERFILE 	"ldfilter.cfg"
#define TEMPLATEFILE 	"disptmpl.cfg"
/*
 * These are not automatically defined for us even though we're a DLL.  They
 * are triggered by prolog/epilog configuration options that we don't use.
 * But be careful not to redefine them for other apps that include this file.
 */
#ifndef _WINDLL
/*
 * Needed by wshelper.h
 */
#define _WINDLL
#endif

#ifndef _WINDOWS
/*
 * Needed by authlib.h via kerberos.c via AUTHMAN
 */
#define _WINDOWS 1
#endif
  
/*
 * KERBEROS must be defined as a preprocessor symbol in the compiler.
 * It's too late to define it in this file.
 */

/*
 * AUTHMAN - Use Authlib.dll as a higher level interface to krbv4win.dll 
 * (kerberos).  If defined, get_kerberosv4_credentials in kerberos.c is
 * used and authlib.dll (and krbv4win.dll) are dynamically loaded and used.  
 * If AUTHMAN is not defined, the get_kerberosv4_credentials in 
 * kbind.c works just fine, but requires the presence of krbv4win.dll at
 * load time.
 */
/* don't want to be dependent on authman
 * #define AUTHMAN
 */

/*
 * define WSHELPER if you want wsockip.c to use rgethostbyaddr() (in
 * WSHELPER.DLL) rather than gethostbyaddr().  You might want this if your
 * gethostbyaddr() returns the WRONG host name and you want to use
 * kerberos authentication (need host name to form service ticket
 * request).  Most won't want kerberos, and of those, there might actually
 * be some vendors who really do the lookup rather than use cached info
 * from gethostbyname() calls.
 */
#define WSHELPER
/*
 * The new slapd stuff
 */
#define LDAP_REFERRALS
/*
 * LDAP character string translation routines
 * I compiled and tested these and they seemed to work.
 * The thing to test with is: 
 *   cn=Charset Test Entry, ou=SWITCHdirectory, o=SWITCH, c=CH
 *
 * I'm disabling it for release.
#define STR_TRANSLATION
#define LDAP_CHARSET_8859 88591
#define LDAP_DEFAULT_CHARSET LDAP_CHARSET_8859
 */



#define LDAP_DEBUG
#include <winsock.h>


#include <string.h>
#include <malloc.h>
#ifndef _WIN32
#define memcpy( a, b, n )	_fmemcpy( a, b, n )
#define strcpy( a, b )		_fstrcpy( a, b )
#define strchr( a, c )		_fstrchr( a, c )
#endif /* !_WIN32 */
#define strcasecmp(a,b) 	stricmp(a,b)
#define strncasecmp(a,b,len) 	strnicmp(a,b,len)

#endif /* _MSDOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\proto-ld.h ===
/*
 * proto-ldap.h
 * function prototypes for ldap library
 */


#ifndef LDAPFUNCDECL
#ifdef _WIN32
#define LDAPFUNCDECL	__declspec( dllexport ) 
#else /* _WIN32 */
#define LDAPFUNCDECL    
#endif /* _WIN32 */
#endif /* LDAPFUNCDECL */


/*
 * in abandon.c:
 */
LDAPFUNCDECL int __cdecl ldap_abandon( LDAP *ld, int msgid );

/*
 * in add.c:
 */
LDAPFUNCDECL int __cdecl ldap_add( LDAP *ld, char *dn, LDAPMod **attrs );
LDAPFUNCDECL int __cdecl ldap_add_s( LDAP *ld, char *dn, LDAPMod **attrs );

/*
 * in bind.c:
 */
LDAPFUNCDECL int __cdecl ldap_bind( LDAP *ld, char *who, char *passwd, int authmethod );
LDAPFUNCDECL int __cdecl ldap_bind_s( LDAP *ld, char *who, char *cred, int method );
#ifdef LDAP_REFERRALS
LDAPFUNCDECL void __cdecl ldap_set_rebind_proc( LDAP *ld, int (*rebindproc)( LDAP *ld,
	char **dnp, char **passwdp, int *authmethodp, int freeit ));
#endif /* LDAP_REFERRALS */

/*
 * in sbind.c:
 */
LDAPFUNCDECL int __cdecl ldap_simple_bind( LDAP *ld, char *who, char *passwd );
LDAPFUNCDECL int __cdecl ldap_simple_bind_s( LDAP *ld, char *who, char *passwd );

/*
 * in kbind.c:
 */
LDAPFUNCDECL int __cdecl ldap_kerberos_bind_s( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind1( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind1_s( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind2( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind2_s( LDAP *ld, char *who );
 

#ifndef NO_CACHE
/*
 * in cache.c
 */
LDAPFUNCDECL int __cdecl ldap_enable_cache( LDAP *ld, long timeout, long maxmem );
LDAPFUNCDECL void __cdecl ldap_disable_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_set_cache_options( LDAP *ld, unsigned long opts );
LDAPFUNCDECL void __cdecl ldap_destroy_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_flush_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_uncache_entry( LDAP *ld, char *dn );
LDAPFUNCDECL void __cdecl ldap_uncache_request( LDAP *ld, int msgid );
#endif /* !NO_CACHE */

/*
 * in compare.c:
 */
LDAPFUNCDECL int __cdecl ldap_compare( LDAP *ld, char *dn, char *attr, char *value );
LDAPFUNCDECL int __cdecl ldap_compare_s( LDAP *ld, char *dn, char *attr, char *value );

/*
 * in delete.c:
 */
LDAPFUNCDECL int __cdecl ldap_delete( LDAP *ld, char *dn );
LDAPFUNCDECL int __cdecl ldap_delete_s( LDAP *ld, char *dn );

/*
 * in error.c:
 */
LDAPFUNCDECL int __cdecl ldap_result2error( LDAP *ld, LDAPMessage *r, int freeit );
LDAPFUNCDECL char * __cdecl ldap_err2string( int err );
LDAPFUNCDECL void __cdecl ldap_perror( LDAP *ld, char *s );

/*
 * in modify.c:
 */
LDAPFUNCDECL int __cdecl ldap_modify( LDAP *ld, char *dn, LDAPMod **mods );
LDAPFUNCDECL int __cdecl ldap_modify_s( LDAP *ld, char *dn, LDAPMod **mods );

/*
 * in modrdn.c:
 */
LDAPFUNCDECL int __cdecl ldap_modrdn( LDAP *ld, char *dn, char *newrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn_s( LDAP *ld, char *dn, char *newrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn2( LDAP *ld, char *dn, char *newrdn,
	int deleteoldrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn2_s( LDAP *ld, char *dn, char *newrdn,
	int deleteoldrdn);

/*
 * in open.c:
 */
LDAPFUNCDECL LDAP * __cdecl ldap_open( char *host, int port );
LDAPFUNCDECL LDAP * __cdecl ldap_init( char *defhost, int defport );

/*
 * in getentry.c:
 */
LDAPFUNCDECL LDAPMessage * __cdecl ldap_first_entry( LDAP *ld, LDAPMessage *chain );
LDAPFUNCDECL LDAPMessage * __cdecl ldap_next_entry( LDAP *ld, LDAPMessage *entry );
LDAPFUNCDECL int  __cdecl ldap_count_entries( LDAP *ld, LDAPMessage *chain );

/*
 * in addentry.c
 */
LDAPFUNCDECL LDAPMessage * __cdecl ldap_delete_result_entry( LDAPMessage **list,
	LDAPMessage *e );
LDAPFUNCDECL void  __cdecl ldap_add_result_entry( LDAPMessage **list, LDAPMessage *e );

/*
 * in getdn.c
 */
LDAPFUNCDECL char * __cdecl ldap_get_dn( LDAP *ld, LDAPMessage *entry );
LDAPFUNCDECL char * __cdecl ldap_dn2ufn( char *dn );
LDAPFUNCDECL char ** __cdecl ldap_explode_dn( char *dn, int notypes );
LDAPFUNCDECL char ** __cdecl ldap_explode_dns( char *dn );
LDAPFUNCDECL int __cdecl  ldap_is_dns_dn( char *dn );

/*
 * in getattr.c
 */
LDAPFUNCDECL char * __cdecl ldap_first_attribute( LDAP *ld, LDAPMessage *entry,
	BerElement **ber );
LDAPFUNCDECL char * __cdecl ldap_next_attribute( LDAP *ld, LDAPMessage *entry,
	BerElement *ber );

/*
 * in getvalues.c
 */
LDAPFUNCDECL char ** __cdecl ldap_get_values( LDAP *ld, LDAPMessage *entry, char *target );
LDAPFUNCDECL struct berval ** __cdecl ldap_get_values_len( LDAP *ld, LDAPMessage *entry,
	char *target );
LDAPFUNCDECL int  __cdecl ldap_count_values( char **vals );
LDAPFUNCDECL int  __cdecl ldap_count_values_len( struct berval **vals );
LDAPFUNCDECL void  __cdecl ldap_value_free( char **vals );
LDAPFUNCDECL void  __cdecl ldap_value_free_len( struct berval **vals );

/*
 * in result.c:
 */
LDAPFUNCDECL int  __cdecl ldap_result( LDAP *ld, int msgid, int all,
	struct timeval *timeout, LDAPMessage **result );
LDAPFUNCDECL int  __cdecl ldap_msgfree( LDAPMessage *lm );
LDAPFUNCDECL int  __cdecl ldap_msgdelete( LDAP *ld, int msgid );

/*
 * in search.c:
 */
LDAPFUNCDECL int  __cdecl ldap_search( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly );
LDAPFUNCDECL int  __cdecl ldap_search_s( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly, LDAPMessage **res );
LDAPFUNCDECL int  __cdecl ldap_search_st( LDAP *ld, char *base, int scope, char *filter,
    char **attrs, int attrsonly, struct timeval *timeout, LDAPMessage **res );

/*
 * in ufn.c
 */
LDAPFUNCDECL int  __cdecl ldap_ufn_search_c( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res, int (*cancelproc)( void *cl ),
	void *cancelparm );
LDAPFUNCDECL int  __cdecl ldap_ufn_search_ct( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res, int (*cancelproc)( void *cl ),
	void *cancelparm, char *tag1, char *tag2, char *tag3 );
LDAPFUNCDECL int  __cdecl ldap_ufn_search_s( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res );
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_ufn_setfilter( LDAP *ld, char *fname );
LDAPFUNCDECL void  __cdecl ldap_ufn_setprefix( LDAP *ld, char *prefix );
LDAPFUNCDECL int __cdecl  ldap_ufn_timeout( void *tvparam );


/*
 * in unbind.c
 */
LDAPFUNCDECL int  __cdecl ldap_unbind( LDAP *ld );
LDAPFUNCDECL int  __cdecl ldap_unbind_s( LDAP *ld );


/*
 * in getfilter.c
 */
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_init_getfilter( char *fname );
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_init_getfilter_buf( char *buf, long buflen );
LDAPFUNCDECL LDAPFiltInfo * __cdecl ldap_getfirstfilter( LDAPFiltDesc *lfdp, char *tagpat,
	char *value );
LDAPFUNCDECL LDAPFiltInfo * __cdecl ldap_getnextfilter( LDAPFiltDesc *lfdp );
LDAPFUNCDECL void  __cdecl ldap_setfilteraffixes( LDAPFiltDesc *lfdp, char *prefix, char *suffix );
LDAPFUNCDECL void  __cdecl ldap_build_filter( char *buf, unsigned long buflen,
	char *pattern, char *prefix, char *suffix, char *attr,
	char *value, char **valwords );

/*
 * in free.c
 */
LDAPFUNCDECL void  __cdecl ldap_getfilter_free( LDAPFiltDesc *lfdp );
LDAPFUNCDECL void  __cdecl ldap_mods_free( LDAPMod **mods, int freemods );

/*
 * in friendly.c
 */
LDAPFUNCDECL char * __cdecl ldap_friendly_name( char *filename, char *uname,
	FriendlyMap **map );
LDAPFUNCDECL void  __cdecl ldap_free_friendlymap( FriendlyMap **map );


/*
 * in cldap.c
 */
LDAPFUNCDECL LDAP *cldap_open( char *host, int port );
LDAPFUNCDECL void cldap_close( LDAP *ld );
LDAPFUNCDECL int cldap_search_s( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly, LDAPMessage **res, char *logdn );
LDAPFUNCDECL void cldap_setretryinfo( LDAP *ld, int tries, int timeout );


/*
 * in sort.c
 */
LDAPFUNCDECL int ldap_sort_entries( LDAP *ld, LDAPMessage **chain, char *attr,
	int (*cmp)() );
LDAPFUNCDECL int ldap_sort_values( LDAP *ld, char **vals, int (*cmp)() );
LDAPFUNCDECL int ldap_sort_strcasecmp( char **a, char **b );


/*
 * in url.c
 */
LDAPFUNCDECL int  __cdecl ldap_is_ldap_url( char *url );
LDAPFUNCDECL int  __cdecl ldap_url_parse( char *url, LDAPURLDesc **ludpp );
LDAPFUNCDECL void  __cdecl ldap_free_urldesc( LDAPURLDesc *ludp );
LDAPFUNCDECL int  __cdecl ldap_url_search( LDAP *ld, char *url, int attrsonly );
LDAPFUNCDECL int  __cdecl ldap_url_search_s( LDAP *ld, char *url, int attrsonly,
	LDAPMessage **res );
LDAPFUNCDECL int  __cdecl ldap_url_search_st( LDAP *ld, char *url, int attrsonly,
	struct timeval *timeout, LDAPMessage **res );


/*
 * in charset.c
 */
#ifdef STR_TRANSLATION
LDAPFUNCDECL void  __cdecl ldap_set_string_translators( LDAP *ld,
	BERTranslateProc encode_proc, BERTranslateProc decode_proc );
LDAPFUNCDECL int  __cdecl ldap_translate_from_t61( LDAP *ld, char **bufp,
	unsigned long *lenp, int free_input );
LDAPFUNCDECL int  __cdecl ldap_translate_to_t61( LDAP *ld, char **bufp,
	unsigned long *lenp, int free_input );
LDAPFUNCDECL void  __cdecl ldap_enable_translation( LDAP *ld, LDAPMessage *entry,
	int enable );

#ifdef LDAP_CHARSET_8859
LDAPFUNCDECL int  __cdecl ldap_t61_to_8859( char **bufp, unsigned long *buflenp,
	int free_input );
LDAPFUNCDECL int  __cdecl ldap_8859_to_t61( char **bufp, unsigned long *buflenp,
	int free_input );
#endif /* LDAP_CHARSET_8859 */
#endif /* STR_TRANSLATION */


#ifdef WINSOCK
/*
 * in msdos/winsock/wsa.c
 */
LDAPFUNCDECL void  __cdecl ldap_memfree( void *p );
#endif /* WINSOCK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldap\ldapinc\srchpref.h ===
/*
 * Copyright (c) 1993, 1994 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 *
 * searchpref.h:  display template library defines
 * 16 May 1994 by Gordon Good
 */


#ifndef _SRCHPREF_H
#define _SRCHPREF_H

#ifdef __cplusplus
extern "C" {
#endif


struct ldap_searchattr {
	char				*sa_attrlabel;
	char				*sa_attr;
					/* max 32 matchtypes for now */
	unsigned long			sa_matchtypebitmap;
	char				*sa_selectattr;
	char				*sa_selecttext;
	struct ldap_searchattr		*sa_next;
};

struct ldap_searchmatch {
	char				*sm_matchprompt;
	char				*sm_filter;
	struct ldap_searchmatch		*sm_next;
};

struct ldap_searchobj {
	char				*so_objtypeprompt;
	unsigned long			so_options;
	char				*so_prompt;
	short				so_defaultscope;
	char				*so_filterprefix;
	char				*so_filtertag;
	char				*so_defaultselectattr;
	char				*so_defaultselecttext;
	struct ldap_searchattr		*so_salist;
	struct ldap_searchmatch		*so_smlist;
	struct ldap_searchobj		*so_next;
};

#define NULLSEARCHOBJ			((struct ldap_searchobj *)0)

/*
 * global search object options
 */
#define LDAP_SEARCHOBJ_OPT_INTERNAL	0x00000001

#define LDAP_IS_SEARCHOBJ_OPTION_SET( so, option )	\
	(((so)->so_options & option ) != 0 )

#define LDAP_SEARCHPREF_VERSION_ZERO	0
#define LDAP_SEARCHPREF_VERSION		1

#define LDAP_SEARCHPREF_ERR_VERSION	1
#define LDAP_SEARCHPREF_ERR_MEM		2
#define LDAP_SEARCHPREF_ERR_SYNTAX	3
#define LDAP_SEARCHPREF_ERR_FILE	4


#ifndef NEEDPROTOS
int			ldap_init_searchprefs();
int			ldap_init_searchprefs_buf();
void			ldap_free_searchprefs();
struct ldap_searchobj	*ldap_first_searchobj();
struct ldap_searchobj	*ldap_next_searchobj();

#else /* !NEEDPROTOS */

LDAPFUNCDECL int
ldap_init_searchprefs( char *file, struct ldap_searchobj **solistp );

LDAPFUNCDECL int
ldap_init_searchprefs_buf( char *buf, long buflen,
	struct ldap_searchobj **solistp );

LDAPFUNCDECL void
ldap_free_searchprefs( struct ldap_searchobj *solist );

LDAPFUNCDECL struct ldap_searchobj *
ldap_first_searchobj( struct ldap_searchobj *solist );

LDAPFUNCDECL struct ldap_searchobj *
ldap_next_searchobj( struct ldap_searchobj *sollist,
	struct ldap_searchobj *so );

#endif /* !NEEDPROTOS */


#ifdef __cplusplus
}
#endif
#endif /* _SRCHPREF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldapres.h ===
#define LDAP_PROVIDER_ID 1

#define GC_PORT 3268
#define GC_SSL_PORT 3269

#define USE_DEFAULT_LDAP_PORT -1
#define USE_DEFAULT_GC_PORT -2

#define LDAPC_NT_AUTHORITY   7000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\adsi.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

class ADS_OBJECT_HANDLE
{
public:
    ADS_LDP *_ld;
    LPWSTR  _pszADsPath;
    LPWSTR  _pszLDAPServer;
    LPWSTR  _pszLDAPDn;
    CCredentials _Credentials;
    LDAP_SEARCH_PREF  _SearchPref;
    DWORD   _dwPort;

    ADS_OBJECT_HANDLE( ADS_LDP *ld,
                       LPWSTR pszADsPath,
                       LPWSTR pszLDAPServer,
                       LPWSTR pszLDAPDn,
                       CCredentials Credentials,
                       DWORD dwPort
                       );

    ~ADS_OBJECT_HANDLE();

};

ADS_OBJECT_HANDLE::ADS_OBJECT_HANDLE( ADS_LDP *ld,
                                      LPWSTR pszADsPath,
                                      LPWSTR pszLDAPServer,
                                      LPWSTR pszLDAPDn,
                                      CCredentials Credentials,
                                      DWORD dwPort
                                      )
{

    _ld = ld;
    _pszADsPath = pszADsPath;
    _pszLDAPServer = pszLDAPServer;
    _pszLDAPDn = pszLDAPDn;
    _Credentials = Credentials;
    _dwPort = dwPort;
    LdapInitializeSearchPreferences(&_SearchPref, FALSE);
}

ADS_OBJECT_HANDLE::~ADS_OBJECT_HANDLE()
{
    if ( _ld )
    {
        LdapCloseObject( _ld);
        _ld = NULL;
    }

    if ( _pszADsPath )
    {
        FreeADsStr( _pszADsPath );
        _pszADsPath = NULL;
    }

    if (_pszLDAPServer) {
        FreeADsStr(_pszLDAPServer);
        _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);
        _pszLDAPDn = NULL;
    }

    //
    // Free sort keys if applicable.
    //
    if (_SearchPref._pSortKeys) {
        FreeSortKeys(_SearchPref._pSortKeys, _SearchPref._nSortKeys);
    }

    //
    // Free the VLV information if applicable
    //
    if (_SearchPref._pVLVInfo) {
        FreeLDAPVLVInfo(_SearchPref._pVLVInfo);
    }    

    //
    // Free the attribute-scoped query information if applicable
    //
    if (_SearchPref._pAttribScoped) {
        FreeADsStr(_SearchPref._pAttribScoped);
    }
}


HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwPort = 0;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    ADS_LDP *ld = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    ADS_OBJECT_HANDLE *pADsObjectHandle = NULL;

    LPWSTR szAttributes[2] = { L"objectClass", NULL };
    int nCount;
    LDAPMessage *res = NULL;
    LONG lnFlags = lnReserved;


    if (lnFlags & ADS_FAST_BIND) {
        // mask it out as openobject does not know about the flag
        lnFlags &= ~ADS_FAST_BIND;
    }

    CCredentials Credentials( pszUserName, pszPassword, lnFlags );


    pszADsPath = AllocADsStr( pszDNName );
    if ( pszADsPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildLDAPPathFromADsPath2(
             pszDNName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE( hr);

    if (pszLDAPDn == NULL) {
        //
        // LDAP://Server is not valid in ldapc
        // LDAP://RootDSE is valid though
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    if (!_wcsicmp(pszLDAPDn, L"rootdse")) {
        FreeADsStr(pszLDAPDn);
        pszLDAPDn = NULL;
    }

    hr = LdapOpenObject(
                    pszLDAPServer,
                    pszLDAPDn,
                    &ld,
                    Credentials,
                    dwPort
                    );

    BAIL_ON_FAILURE(hr);


    if (!(lnReserved & ADS_FAST_BIND)) {

        // if fast bind is not specified we need to get the objectClass

        hr = LdapSearchS(
                 ld,
                 pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 szAttributes,
                 0,
                 &res
                 );

        if (  FAILED(hr)
              || ((nCount = LdapCountEntries( ld, res)) == 0))
        {
            if (!FAILED(hr)) {
                hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
            }
        }

        // Need to free the message if one came back
        if (res) {
            LdapMsgFree(res);
            res = NULL;
        }

        BAIL_ON_FAILURE(hr);
    }

    pADsObjectHandle = new ADS_OBJECT_HANDLE(
                               ld, pszADsPath,
                               pszLDAPServer, pszLDAPDn,
                               Credentials, dwPort
                               );

    if ( pADsObjectHandle == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *phDSObject = (HANDLE) pADsObjectHandle;

    RRETURN(S_OK);

error:

    if ( pszADsPath )
        FreeADsStr( pszADsPath );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if ( ld )
        LdapCloseObject( ld );

    *phDSObject = NULL;

    RRETURN(hr);

}


HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    )
{
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    delete pADsObjectHandle;

    RRETURN(S_OK);
}


HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    SECURITY_INFORMATION seInfo = OWNER_SECURITY_INFORMATION
                                 | GROUP_SECURITY_INFORMATION
                                 | DACL_SECURITY_INFORMATION;

    //
    // seInfo is the default value for now anyone wanting to set
    // the SACL will have to use IDirectoryObject.
    //


    hr = ADsSetObjectAttributes(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             seInfo,
             pAttributeEntries,
             dwNumAttributes,
             pdwNumAttributesModified
             );

    RRETURN(hr);
}


HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    SECURITY_INFORMATION seInfo = OWNER_SECURITY_INFORMATION
                                 | GROUP_SECURITY_INFORMATION
                                 | DACL_SECURITY_INFORMATION;

    //
    // seInfo is the default value for now anyone wanting to read
    // the SACL will have to use IDirectoryObject.
    //

    hr = ADsGetObjectAttributes(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             seInfo,
             pAttributeNames,
             dwNumberAttributes,
             ppAttributeEntries,
             pdwNumAttributesReturned
             );

    RRETURN(hr);
}


HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hParentDSObject;

    hr = ADsCreateDSObject(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszADsPath,
             pszRDNName,
             pAttributeEntries,
             dwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hParentDSObject;

    hr = ADsDeleteDSObject(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszADsPath,
             pszRDNName
             );

    RRETURN(hr);
}


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsSetSearchPreference(
             pSearchPrefs,
             dwNumPrefs,
             &(pADsObjectHandle->_SearchPref),
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort
             );

    RRETURN(hr);
}



HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsExecuteSearch(
             pADsObjectHandle->_SearchPref,
             pADsObjectHandle->_pszADsPath,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pszSearchFilter,
             pAttributeNames,
             dwNumberAttributes,
             phSearchHandle
             );

    RRETURN(hr);
}


HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    IN PADS_SEARCH_HANDLE phSearchHandle
    )
{
    HRESULT hr = S_OK;

    ADsAssert(phSearchHandle);

    hr = ADsAbandonSearch(
             *phSearchHandle
             );

    RRETURN(hr);
}



HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    hr = ADsCloseSearchHandle(
             hSearchHandle
             );

    RRETURN(hr);
}


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetFirstRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetNextRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetPreviousRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetColumn(
             hSearchHandle,
             pszColumnName,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             pColumn
             );

    RRETURN(hr);
}


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetNextColumnName(
             hSearchHandle,
             ppszColumnName
             );

    RRETURN(hr);
}


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsFreeColumn(
             pColumn
             );

    RRETURN(hr);
}

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsEnumAttributes(
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             ppszAttrNames,
             dwNumAttributes,
             ppAttrDefinition,
             pdwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );
    RRETURN(hr);
}


HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );

    RRETURN(hr);
}

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteAttributeDefinition(
             pszAttributeName
             );

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ADSIModifyRDN
//
//  Synopsis: Rename the object from the ldapc layer. This is just
//           a wrapper for LDAPModRdnS.
//
//
//  Arguments:  Handle to the object being renamed.
//              new RDN of the object.
//
//-------------------------------------------------------------------------

HRESULT
ADSIModifyRdn(
    HANDLE hDSObject,
    LPWSTR pszOldRdn,
    LPWSTR pszNewRdn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    TCHAR *pszOldDN = NULL;
    DWORD dwLen = 0;

    if (!pszOldRdn || !pszNewRdn) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    dwLen = wcslen(pADsObjectHandle->_pszLDAPDn) + wcslen(pszOldRdn) + 2;

    pszOldDN = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if (!pszOldDN) {
        RRETURN (hr = E_OUTOFMEMORY);
    }

    // Build the DN of the object being renamed
    wsprintf(pszOldDN, L"%s,", pszOldRdn);

    wcscat(pszOldDN, pADsObjectHandle->_pszLDAPDn);


    hr = LdapModRdnS(
             pADsObjectHandle->_ld,
             pszOldDN,
             pszNewRdn
             );

    if (pszOldDN) {
        FreeADsStr(pszOldDN);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\adsiutil.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

//
//Hard Coded Support for RootDSE object
//

LPWSTR SpecialSyntaxesTable[] =
{
   LDAP_OPATT_CURRENT_TIME_W,
   LDAP_OPATT_SUBSCHEMA_SUBENTRY_W,
   LDAP_OPATT_SERVER_NAME_W,
   LDAP_OPATT_NAMING_CONTEXTS_W,
   LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
   LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W,
   LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
   LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W,
   LDAP_OPATT_SUPPORTED_CONTROL_W,
   LDAP_OPATT_SUPPORTED_LDAP_VERSION_W,
   L"lowestUncommittedUSN",
   L"allowedAttributesEffective",
   L"supportedExtension",
   L"altServer",
   NULL
};



HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize,
    PDWORD pdwNumValues
    );

LPBYTE
CopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    );

HRESULT
ADsSetObjectAttributes(
    ADS_LDP *ld,
    LPTSTR  pszLDAPServer,
    LPTSTR  pszLDAPDn,
    CCredentials Credentials,
    DWORD dwPort,
    SECURITY_INFORMATION seInfo,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;

    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    LDAPOBJECTARRAY ldapObjectArray;
    DWORD dwSyntaxId = 0;

    LDAPMod  **aMods = NULL;
    LDAPModW *aModsBuffer = NULL;
    DWORD dwNumAttributesReturn = 0;
    BOOL fNTSecDescriptor = FALSE;
    int ldaperr = 0;
    DWORD dwOptions = 0;

    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOL fModifyDone = FALSE;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    LDAPControl     ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    PLDAPControl    ServerControlsOnlyModify[2] =
                    {
                        &ModifyControl,
                        NULL
                    };

    PLDAPControl    ServerControlsAll[3] =
                    {
                        &SeInfoControl,
                        &ModifyControl,
                        NULL
                    };

    BOOL fServerIsAD = FALSE;


    *pdwNumAttributesModified = 0;

    //
    // Allocate memory to send the modify request
    //

    aMods = (LDAPModW **) AllocADsMem((dwNumAttributes+1) * sizeof(LDAPModW*));
    if ( aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwNumAttributes * sizeof(LDAPModW));
    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Format the modify request
    //
    for (i = 0; i < dwNumAttributes; i++) {

        BOOL fGenTime = FALSE;
        LDAPOBJECTARRAY_INIT(ldapObjectArray);

        pThisAttribute = pAttributeEntries + i;

        if (!fNTSecDescriptor
            && _wcsicmp(L"ntSecurityDescriptor", pThisAttribute->pszAttrName)
                        == 0)
        {

            {
                // we need to use appropriate controls if the operation
                // is modify the security descriptor. Specifically we do
                // not want to use any control if the operation is a clear
                // and default to whatever the server deems fit.
                if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
                   fNTSecDescriptor = TRUE;
                }
            }
        }

        if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
            //
            // If this is a time attribute, see if it is GenTime or
            // UTCTime and set the syntax the flag appropriately
            //
            if (pThisAttribute->dwADsType == ADSTYPE_UTC_TIME) {

                hr = LdapGetSyntaxOfAttributeOnServer(
                         pszLDAPServer,
                         pThisAttribute->pszAttrName,
                         &dwSyntaxId,
                         Credentials,
                         dwPort
                         );
                if (SUCCEEDED(hr) && (dwSyntaxId == LDAPTYPE_GENERALIZEDTIME)) {
                    //
                    // Use GenTime conversion
                    //
                    fGenTime = TRUE;
                }

            }

        }

        switch (pThisAttribute->dwControlCode) {
        case ADS_ATTR_UPDATE:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_REPLACE;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_APPEND:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_ADD;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_CLEAR:
            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type   = pThisAttribute->pszAttrName;
            aModsBuffer[i].mod_bvalues = NULL;
            aModsBuffer[i].mod_op |= LDAP_MOD_DELETE;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_DELETE:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_DELETE;
            dwNumAttributesReturn++;
            break;


        default:
            //
            // ignore this attribute and move on
            //
            break;


        }


    }

    //
    // Find out if server is AD.
    //
    hr = ReadServerSupportsIsADControl(
             pszLDAPServer,
             &fServerIsAD,
             Credentials,
             dwPort
             );
    if (FAILED(hr)) {
        //
        // Assume it is not AD and continue, there is no
        // good reason for this to fail on AD.
        //
        fServerIsAD = FALSE;
    }

    //
    // Modify the object with appropriate call
    //
    if (fNTSecDescriptor) {
        //
        // Check if we are V3
        //
        ldaperr = ldap_get_option(
                      ld->LdapHandle,
                      LDAP_OPT_VERSION,
                      &dwOptions
                      );

        //
        // check supported controls and set accordingly
        //

        if (ldaperr == LDAP_SUCCESS && (dwOptions == LDAP_VERSION3)) {


            //
            // Read the security descriptor type if applicable
            //
            hr = ReadSecurityDescriptorControlType(
                     pszLDAPServer,
                     &dwSecDescType,
                     Credentials,
                     dwPort
                     );

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapModifyExtS(
                         ld,
                         pszLDAPDn,
                         aMods,
                         fServerIsAD ?
                            (PLDAPControl *) &ServerControlsAll :
                            (PLDAPControl *) &ServerControls,
                         NULL
                         );

                fModifyDone = TRUE;

            }
        } // If Read Version succeeded
    }

    //
    // Perform a simple modify - only if fModifyDone is false
    //

    if (!fModifyDone) {

        if (fServerIsAD) {

            //
            // Need to send the OID that allows delete on empty attributes
            // without sending an error - for clients that have gotten used
            // to bad practices.
            //
            hr = LdapModifyExtS(
                     ld,
                     pszLDAPDn,
                     aMods,
                     (PLDAPControl *)&ServerControlsOnlyModify,
                     NULL
                     );
        }
        else {

            //
            // Regular calls from most folks not using AD.
            //
            hr = LdapModifyS(
                 ld,
                 pszLDAPDn,
                 aMods
                 );
        }
    }

    BAIL_ON_FAILURE(hr);

    *pdwNumAttributesModified = dwNumAttributesReturn;

error:

    if ( aModsBuffer )
    {
        for ( j = 0; j < i; j++ )
        {
             if ( aModsBuffer[j].mod_op & LDAP_MOD_BVALUES )
             {
                 if ( aModsBuffer[j].mod_bvalues )
                 {
                     for ( DWORD k = 0; aModsBuffer[j].mod_bvalues[k]; k++ )
                         FreeADsMem( aModsBuffer[j].mod_bvalues[k] );

                     FreeADsMem( aModsBuffer[j].mod_bvalues );
                 }
             }
             else if ( aModsBuffer[j].mod_values )
             {
                 for ( DWORD k = 0; aModsBuffer[j].mod_values[k]; k++ )
                     FreeADsMem( aModsBuffer[j].mod_values[k] );

                 FreeADsMem( aModsBuffer[j].mod_values );
             }
        }

        FreeADsMem( aModsBuffer );
    }

    if ( aMods )
        FreeADsMem( aMods );

    return hr;
}


HRESULT
ADsGetObjectAttributes(
    ADS_LDP *ld,
    LPTSTR  pszLDAPServer,
    LPTSTR  pszLDAPDn,
    CCredentials Credentials,
    DWORD dwPort,
    SECURITY_INFORMATION seInfo,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;

    DWORD i = 0;
    DWORD j = 0;

    LPWSTR *aStrings = NULL;

    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;
    void *ptr;
    DWORD dwNumberOfEntries = 0;
    LPTSTR pszAttrName = NULL;
    LDAPOBJECTARRAY ldapObjectArray;
    PADSVALUE pAdsDestValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;

    DWORD dwSyntaxId = 0;

    PADS_ATTR_INFO pAdsAttributes = NULL;
    PADS_ATTR_INFO pThisAttributeDef = NULL;

    LPBYTE pAttributeBuffer = NULL;
    DWORD dwAttrCount = 0;

    DWORD dwMemSize = 0;
    DWORD dwTotalValues = 0;
    DWORD dwNumValues = 0;
    LPBYTE pValueBuffer = NULL;
    LPBYTE pDataBuffer = NULL;
    PADS_ATTR_INFO pAttrEntry = NULL;
    PADSVALUE pAttrValue  = NULL;

    PADS_ATTR_INFO pThisAdsSrcAttribute = NULL;
    PADS_ATTR_INFO pThisAdsTargAttribute = NULL;
    PADSVALUE pThisAdsSrcValue = NULL;
    PADSVALUE pThisAdsTargValue = NULL;

    *ppAttributeEntries = NULL;
    *pdwNumAttributesReturned = 0;

    DWORD ldaperr = 0;
    DWORD dwOptions = 0;

    BOOLEAN getSecDesc = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOLEAN fSearchDone = FALSE;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    LDAPOBJECTARRAY_INIT(ldapObjectArray);

    if (dwNumberAttributes != (DWORD)-1)
    {

        if ( dwNumberAttributes == 0 )
            return S_OK;

        //
        // Package attributes
        //

        aStrings = (LPWSTR *) AllocADsMem( sizeof(LPTSTR) * (dwNumberAttributes + 1));

        if ( aStrings == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for ( i = 0; i < dwNumberAttributes; i++)
        {
            aStrings[i] = pAttributeNames[i];

            if (!getSecDesc &&
                _wcsicmp(L"ntSecurityDescriptor", pAttributeNames[i]) == 0) {
                // we need go to get the security descriptor
                getSecDesc = TRUE;
            }
        }
    }
    else
    {
        //
        // If all attributes are requested, we will mark as read
        // security descriptor also. Further down, the decision to
        // use or not use a control is made.
        //
        getSecDesc = TRUE;
    }

    //
    // Read the DS Object
    //

    // modified from LdapSearchS to LdapSearchExtS to get all attributes
    // including SecurityDescriptor by one call

    if (getSecDesc) {

        ldaperr = ldap_get_option(
                        ld->LdapHandle,
                        LDAP_OPT_VERSION,
                        &dwOptions
                        );

        if (dwOptions == LDAP_VERSION3) {

            //
            // Read the security descriptor type if applicable
            //
            hr = ReadSecurityDescriptorControlType(
                     pszLDAPServer,
                     &dwSecDescType,
                     Credentials,
                     dwPort
                     );

            //
            // If we could no get the control information for whatever reason,
            // just try the SearchS.
            //

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapSearchExtS(
                         ld,
                         pszLDAPDn,
                         LDAP_SCOPE_BASE,
                         TEXT("(objectClass=*)"),
                         aStrings,
                         0,
                         (PLDAPControl *)&ServerControls,
                         NULL,
                         NULL,
                         10000,
                         &res
                         );

                fSearchDone = TRUE;


            }
        }
    }

    //
    // Perform just a LdapSearchS if the flag indicates that
    // no search has been done. We do not try a second search
    // if the first tone failed (saves packets on the wire).
    //
    if (!fSearchDone) {

        hr = LdapSearchS(
                    ld,
                    pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    aStrings,
                    0,
                    &res
                    );

        fSearchDone = TRUE;

        BAIL_ON_FAILURE(hr);

    }


    //
    // Should only contain one entry
    //

    if ( LdapCountEntries( ld, res ) == 0 )
        goto error;

    hr = LdapFirstEntry( ld, res, &entry );
    BAIL_ON_FAILURE(hr);

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    hr = LdapFirstAttribute( ld, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        dwNumberOfEntries++;
        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        hr = LdapNextAttribute( ld, entry, ptr, &pszAttrName );
        if (FAILED(hr))
            break;   // error occurred, ignore the rest of the attributes
    }

    //
    // Allocate an attribute buffer which is as large as the
    // number of attributes present
    //
    //

    // Note that pADsAttributes is inited to Null
    if (dwNumberOfEntries != 0) {

        pAdsAttributes = (PADS_ATTR_INFO)AllocADsMem(
                               sizeof(ADS_ATTR_INFO) * dwNumberOfEntries
                               );
        if (!pAdsAttributes)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    dwAttrCount = 0;
    ptr = NULL;
    hr = LdapFirstAttribute( ld, entry, &ptr, &pszAttrName );

    while (  SUCCEEDED(hr)
          && ( pszAttrName != NULL )
          && ( dwAttrCount < dwNumberOfEntries )
          )
    {
        //
        // Get the syntax of the attribute. Force only
        // if we know that the this is not the RootDSE
        // as RootDSE attributes are not in schema.
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszLDAPServer,
                 pszAttrName,
                 &dwSyntaxId,
                 Credentials,
                 dwPort,
                 pszLDAPDn ? TRUE : FALSE
                 );

        //
        // If it failed with errorcode 0x8000500D which is
        // E_ADS_PROPERTY_NOT_FOUND,
        // see if it is one of the RootDSE syntaxes,
        // if so set Syntax to ADSTYPE_CASE_IGNORE_STRING
        //

        if (hr == E_ADS_PROPERTY_NOT_FOUND) {

            //
            // search the hardcoded table to see if it is a known entry
            //

            BOOLEAN valFound = FALSE;
            DWORD ctr = 0;
            while (SpecialSyntaxesTable[ctr] && !valFound) {
                if (!_wcsicmp(pszAttrName, SpecialSyntaxesTable[ctr])) {
                    dwSyntaxId = ADSTYPE_CASE_IGNORE_STRING;
                    hr = S_OK;
                    valFound = TRUE;
                }
                ctr++;
            }
        }else {

            if (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) {
                dwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            }
        }

        if ( hr == E_ADS_PROPERTY_NOT_FOUND ) {
            //
            // We will default to provider specific
            //
            dwSyntaxId = LDAPTYPE_UNKNOWN;
        }
        else if (FAILED(hr)) {
            //
            // Some other failure so skip attribute
            //
            goto NextAttr;
        }

        //
        // Get the values of the current attribute
        //
        hr = UnMarshallLDAPToLDAPSynID(
                    pszAttrName,
                    ld,
                    entry,
                    dwSyntaxId,
                    &ldapObjectArray
                    );

        if ( FAILED(hr))
            goto NextAttr;

        hr = LdapTypeToAdsTypeCopyConstruct(
                    ldapObjectArray,
                    dwSyntaxId,
                    &pAdsDestValues,
                    &dwNumAdsValues,
                    &dwAdsType
                    );

        if (FAILED(hr))
            goto NextAttr;

        pThisAttributeDef = pAdsAttributes + dwAttrCount;
        pThisAttributeDef->pszAttrName = AllocADsStr(pszAttrName);

        if ( !pThisAttributeDef->pszAttrName )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pThisAttributeDef->pADsValues = pAdsDestValues;
        if ( pThisAttributeDef->dwNumValues = ldapObjectArray.dwCount )
            pThisAttributeDef->dwADsType = pAdsDestValues[0].dwType;
        dwAttrCount++;

NextAttr:

        if ( pszAttrName ) {
            LdapAttributeFree( pszAttrName );
            pszAttrName = NULL;
        }

        if ( ldapObjectArray.pLdapObjects )
        {
            if ( ldapObjectArray.fIsString )
                LdapValueFree( (TCHAR **) ldapObjectArray.pLdapObjects );
            else
                LdapValueFreeLen( (struct berval **) ldapObjectArray.pLdapObjects );

            LDAPOBJECTARRAY_INIT(ldapObjectArray);
        }

        if ( hr == E_OUTOFMEMORY )  // break on serious error
            break;

        hr = LdapNextAttribute( ld, entry, ptr, &pszAttrName );
    }

    BAIL_ON_FAILURE(hr);

    if ( dwAttrCount == 0 )
        goto error;

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeAttributeBufferSize(
                pAdsAttributes,
                dwAttrCount,
                &dwMemSize,
                &dwTotalValues
                );
    BAIL_ON_FAILURE(hr);

    pAttributeBuffer = (LPBYTE) AllocADsMem( dwMemSize );

    if (!pAttributeBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pValueBuffer = pAttributeBuffer + dwAttrCount * (sizeof(ADS_ATTR_INFO));
    pDataBuffer = pValueBuffer + dwTotalValues * sizeof(ADSVALUE);

    pAttrEntry = (PADS_ATTR_INFO) pAttributeBuffer;
    pAttrValue = (PADSVALUE) pValueBuffer;

    for (i = 0; i < dwAttrCount; i++) {

        pThisAdsSrcAttribute = pAdsAttributes + i;
        pThisAdsTargAttribute = pAttrEntry + i;

        dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsTargAttribute->dwNumValues = dwNumValues;
        pThisAdsTargAttribute->dwADsType =  pThisAdsSrcAttribute->dwADsType;
        pThisAdsTargAttribute->pADsValues = pAttrValue;

        pThisAdsSrcValue = pThisAdsSrcAttribute->pADsValues;
        pThisAdsTargValue = pAttrValue;

        if (!pDataBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for ( j = 0; j < dwNumValues; j++) {

            pDataBuffer = AdsTypeCopy(
                                pThisAdsSrcValue,
                                pThisAdsTargValue,
                                pDataBuffer
                                );
            pAttrValue++;
            pThisAdsTargValue = pAttrValue;
            pThisAdsSrcValue++;

        }

        if (!pDataBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pDataBuffer = CopyAttributeName(
                                pThisAdsSrcAttribute,
                                pThisAdsTargAttribute,
                                pDataBuffer
                                );

    }

    hr = S_OK;

error:

    if ( aStrings )
        FreeADsMem( aStrings );

    if ( res )
        LdapMsgFree( res );

    //
    // Clean up the header based Ods structures
    //

    if ( pAdsAttributes ) {

        for (i = 0; i < dwAttrCount; i++)
        {
            pThisAttributeDef = pAdsAttributes + i;
            FreeADsStr( pThisAttributeDef->pszAttrName );

            AdsTypeFreeAdsObjects( pThisAttributeDef->pADsValues,
                                   pThisAttributeDef->dwNumValues );
        }

        FreeADsMem( pAdsAttributes );
    }

    if (FAILED(hr))
    {
        if ( pAttributeBuffer )
            FreeADsMem(pAttributeBuffer);

        *ppAttributeEntries = NULL;
        *pdwNumAttributesReturned = 0;
    }
    else
    {
        *ppAttributeEntries = (PADS_ATTR_INFO)pAttributeBuffer;
        *pdwNumAttributesReturned = dwAttrCount;
    }

    return hr;
}

HRESULT
ADsCreateDSObjectExt(
    ADS_LDP *ld,
    LPTSTR ADsPath,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    SECURITY_INFORMATION seInfo,
    BOOL fSecDesc
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwSyntaxId = 0;

    DWORD dwPort = 0;

    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    LDAPOBJECTARRAY ldapObjectArray;
    LDAPMod  **aMods = NULL;
    LDAPModW *aModsBuffer = NULL;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    //
    // Get the LDAP path of the object to create
    //
    hr = BuildADsPathFromParent(
                ADsPath,
                pszRDNName,
                &pszAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pszAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Allocate memory to store the add request
    //
    aMods = (LDAPModW **) AllocADsMem((dwNumAttributes+1) * sizeof(LDAPModW*));
    if ( aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwNumAttributes * sizeof(LDAPModW));
    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Format the add request
    //
    for (i = 0; i < dwNumAttributes; i++) {

        BOOL fGenTime = FALSE;

        LDAPOBJECTARRAY_INIT(ldapObjectArray);

        pThisAttribute = pAttributeEntries + i;

        if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
            //
            // If this is a time attribute, see if it is GenTime or
            // UTCTime and set the syntax the flag appropriately
            //
            if (pThisAttribute->dwADsType == ADSTYPE_UTC_TIME) {

                hr = LdapGetSyntaxOfAttributeOnServer(
                         pszLDAPServer,
                         pThisAttribute->pszAttrName,
                         &dwSyntaxId,
                         (*ld->pCredentials),
                         ld->PortNumber
                         );
                if (SUCCEEDED(hr) && (dwSyntaxId == LDAPTYPE_GENERALIZEDTIME)) {
                    //
                    // Use GenTime conversion
                    //
                    fGenTime = TRUE;
                }

            }

        }

        hr = AdsTypeToLdapTypeCopyConstruct(
                    pThisAttribute->pADsValues,
                    pThisAttribute->dwNumValues,
                    &ldapObjectArray,
                    &dwSyntaxId,
                    fGenTime
                    );
        BAIL_ON_FAILURE(hr);

        aMods[i] = &aModsBuffer[i];
        aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
        }

        aModsBuffer[i].mod_op |= LDAP_MOD_REPLACE;
    }

    if (fSecDesc) {

        hr = LdapAddExtS(
                 ld,
                 pszLDAPDn,
                 aMods,
                 (PLDAPControl *)&ServerControls,
                 NULL
                 );
    }
    else {

        //
        // Now, send the add request
        //
        hr = LdapAddS(
                 ld,
                 pszLDAPDn,
                 aMods
                 );
    }

        BAIL_ON_FAILURE(hr);

error:

    if ( pszAbsoluteName ) {
        FreeADsStr( pszAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {
        FreeADsStr( pszLDAPDn);
    }


    if ( aModsBuffer )
    {
        for ( j = 0; j < i; j++ )
        {
             if ( aModsBuffer[j].mod_op & LDAP_MOD_BVALUES )
             {
                 if ( aModsBuffer[j].mod_bvalues )
                 {
                     for ( DWORD k = 0; aModsBuffer[j].mod_bvalues[k]; k++ )
                         FreeADsMem( aModsBuffer[j].mod_bvalues[k] );

                     FreeADsMem( aModsBuffer[j].mod_bvalues );
                 }
             }
             else if ( aModsBuffer[j].mod_values )
             {
                 for ( DWORD k = 0; aModsBuffer[j].mod_values[k]; k++ )
                     FreeADsMem( aModsBuffer[j].mod_values[k] );

                 FreeADsMem( aModsBuffer[j].mod_values );
             }
        }

        FreeADsMem( aModsBuffer );
    }

    if ( aMods )
        FreeADsMem( aMods );

    return hr;
}


HRESULT
ADsCreateDSObject(
    ADS_LDP *ld,
    LPTSTR  ADsPath,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    )
{

    RRETURN ( ADsCreateDSObjectExt(
                  ld,
                  ADsPath,
                  pszRDNName,
                  pAttributeEntries,
                  dwNumAttributes,
                  0, // for seInfo since it is ignored
                  FALSE
                  )
              );

}


HRESULT
ADsDeleteDSObject(
    ADS_LDP *ld,
    LPTSTR  ADsPath,
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;


    //
    // Get the LDAP path of the object to delete
    //

    hr = BuildADsPathFromParent(
                ADsPath,
                pszRDNName,
                &pszAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pszAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now, send the delete request
    //
    hr = LdapDeleteS(
                    ld,
                    pszLDAPDn
                    );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszAbsoluteName ) {
        FreeADsStr( pszAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }


    return hr;
}

HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize,
    PDWORD pdwNumValues
    )
{
    PADS_ATTR_INFO pThisAttribute = NULL;
    PADSVALUE pAdsSrcValues = NULL;
    DWORD dwNumValues = 0;

    DWORD dwSize = 0;
    DWORD dwTotalNumValues = 0;


    for ( DWORD i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        dwTotalNumValues += dwNumValues;

        pAdsSrcValues = pThisAttribute->pADsValues;

        for ( DWORD j = 0; j < dwNumValues; j++)
            dwSize += AdsTypeSize(pAdsSrcValues + j) + sizeof(ADSVALUE);

        dwSize += sizeof(ADS_ATTR_INFO);
        dwSize += ((wcslen(pThisAttribute->pszAttrName) + 1)*sizeof(WCHAR)) + (ALIGN_WORD-1);
    }

    *pdwSize = dwSize;
    *pdwNumValues = dwTotalNumValues;

    return S_OK;
}

LPBYTE
CopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    )
{

    //
    // strings should be WCHAR (i.e., WORD) aligned
    //
    pDataBuffer = (LPBYTE) ROUND_UP_POINTER(pDataBuffer, ALIGN_WORD);

    LPWSTR pCurrentPos = (LPWSTR)pDataBuffer;

    wcscpy(pCurrentPos, pThisAdsSrcAttribute->pszAttrName);

    pThisAdsTargAttribute->pszAttrName = pCurrentPos;

    pDataBuffer = pDataBuffer + (wcslen(pThisAdsSrcAttribute->pszAttrName) + 1)*sizeof(WCHAR);

    return(pDataBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// The default schema to use if the ldap server does not support schema
//
LPTSTR g_aDefaultAttributeTypes[] =
{ TEXT("( 2.5.4.0 NAME 'objectClass' EQUALITY objectIdentifierMatch SYNTAX 'OID' )"),
  TEXT("( 2.5.4.1 NAME 'aliasedObjectName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE )"),
  TEXT("( 2.5.4.2 NAME 'knowledgeInformation' EQUALITY caseIgnoreMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.3 NAME 'cn' SUP name )"),
  TEXT("( 2.5.4.4 NAME 'sn' SUP name )"),
  TEXT("( 2.5.4.5 NAME 'serialNumber' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.6 NAME 'c' SUP name SINGLE-VALUE )"),
  TEXT("( 2.5.4.7 NAME 'l' SUP name )"),
  TEXT("( 2.5.4.8 NAME 'st' SUP name )"),
  TEXT("( 2.5.4.9 NAME 'street' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.10 NAME 'o' SUP name )"),
  TEXT("( 2.5.4.11 NAME 'ou' SUP name )"),
  TEXT("( 2.5.4.12 NAME 'title' SUP name )"),
  TEXT("( 2.5.4.13 NAME 'description' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.14 NAME 'searchGuide' SYNTAX 'Guide' )"),
  TEXT("( 2.5.4.15 NAME 'businessCategory' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.16 NAME 'postalAddress' EQUALITY caseIgnoreListMatch SUBSTR caseIgnoreListSubstringsMatch SYNTAX 'PostalAddress' )"),
  TEXT("( 2.5.4.17 NAME 'postalCode' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.18 NAME 'postOfficeBox' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.19 NAME 'physicalDeliveryOfficeName' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.20 NAME 'telephoneNumber' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 2.5.4.21 NAME 'telexNumber' SYNTAX 'TelexNumber' )"),
  TEXT("( 2.5.4.22 NAME 'teletexTerminalIdentifier' SYNTAX 'TeletexTerminalIdentifier' )"),
  TEXT("( 2.5.4.23 NAME 'facsimileTelephoneNumber' SYNTAX 'FacsimileTelephoneNumber' )"),
  TEXT("( 2.5.4.24 NAME 'x121Address' EQUALITY numericStringMatch SUBSTR numericStringSubstringsMatch SYNTAX 'NumericString' )"),
  TEXT("( 2.5.4.25 NAME 'internationaliSDNNumber' EQUALITY numericStringMatch SUBSTR numericStringSubstringsMatch SYNTAX 'NumericString' )"),
  TEXT("( 2.5.4.26 NAME 'registeredAddress' SUP postalAddress SYNTAX 'PostalAddress' )"),
  TEXT("( 2.5.4.27 NAME 'destinationIndicator' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.28 NAME 'preferredDeliveryMethod' SYNTAX 'DeliveryMethod' SINGLE-VALUE )"),
  TEXT("( 2.5.4.29 NAME 'presentationAddress' EQUALITY presentationAddressMatch SYNTAX 'PresentationAddress' SINGLE-VALUE )"),
  TEXT("( 2.5.4.30 NAME 'supportedApplicationContext' EQUALITY objectIdentifierMatch SYNTAX 'OID' )"),
  TEXT("( 2.5.4.31 NAME 'member' SUP distinguishedName )"),
  TEXT("( 2.5.4.32 NAME 'owner' SUP distinguishedName )"),
  TEXT("( 2.5.4.33 NAME 'roleOccupant' SUP distinguishedName )"),
  TEXT("( 2.5.4.34 NAME 'seeAlso' SUP distinguishedName )"),
  TEXT("( 2.5.4.35 NAME 'userPassword' EQUALITY octetStringMatch SYNTAX 'Password')"),
  TEXT("( 2.5.4.36 NAME 'userCertificate' SYNTAX 'Certificate' )"),
  TEXT("( 2.5.4.37 NAME 'cACertificate' SYNTAX 'Certificate' )"),
  TEXT("( 2.5.4.38 NAME 'authorityRevocationList' SYNTAX 'CertificateList' )"),
  TEXT("( 2.5.4.39 NAME 'certificateRevocationList' SYNTAX 'CertificateList' )"),
  TEXT("( 2.5.4.40 NAME 'crossCertificatePair' SYNTAX 'CertificatePair' )"),
  TEXT("( 2.5.4.41 NAME 'name' DESC 'The name attribute type is the attribute supertype from which string attribute types typically used for naming may be formed.' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.42 NAME 'givenName' SUP name )"),
  TEXT("( 2.5.4.43 NAME 'initials' DESC 'The initials attribute type contains the initials of some or all of an individuals names, but not the surname(s).' SUP name )"),
  TEXT("( 2.5.4.44 NAME 'generationQualifier'  DESC 'e.g. Jr or II.' SUP name )"),
  TEXT("( 2.5.4.45 NAME 'x500UniqueIdentifier'  DESC 'used to distinguish between objects when a distinguished name has been reused.' EQUALITY bitStringMatch SYNTAX 'BitString' )"),
  TEXT("( 2.5.4.46 NAME 'dnQualifier' DESC 'The dnQualifier attribute type specifies disambiguating information to add to the relative distinguished name of an entry.  It is intended to be used for entries held in multiple DSAs which would otherwise have the same name, and that its value be the same in a given DSA for all entries to which this information has been added.' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.47 NAME 'enhancedSearchGuide' SYNTAX 'EnhancedGuide' )"),
  TEXT("( 2.5.4.48 NAME 'protocolInformation' EQUALITY protocolInformationMatch SYNTAX 'ProtocolInformation' )"),
  TEXT("( 2.5.4.49 NAME 'distinguishedName'  DESC 'This is not the name of the object itself, but a base type from which attributes with DN syntax inherit.' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 2.5.4.50 NAME 'uniqueMember' EQUALITY uniqueMemberMatch SYNTAX 'NameAndOptionalUID' )"),
  TEXT("( 2.5.4.51 NAME 'houseIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.1 NAME 'uid' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.2 NAME 'textEncodedORaddress' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.3 NAME 'mail' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.4 NAME 'info' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.5 NAME 'drink' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.6 NAME 'roomNumber' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.7 NAME 'photo' SYNTAX 'Fax' )"),
  TEXT("( 0.9.2342.19200300.100.1.8 NAME 'userClass' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.9 NAME 'host' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.10 NAME 'manager' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.11 NAME 'documentIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.12 NAME 'documentTitle' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.13 NAME 'documentVersion' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.14 NAME 'documentAuthor' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.15 NAME 'documentLocation' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch  SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.20 NAME 'homePhone' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.21 NAME 'secretary' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.22 NAME 'otherMailbox' SYNTAX 'OtherMailbox' )"),
  TEXT("( 0.9.2342.19200300.100.1.25 NAME 'dc' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.26 NAME 'dNSRecord' EQUALITY caseExactIA5Match SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.37 NAME 'associatedDomain' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.38 NAME 'associatedName' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.39 NAME 'homePostalAddress' EQUALITY caseIgnoreListMatch SUBSTR caseIgnoreListSubstringsMatch SYNTAX 'PostalAddress' )"),
  TEXT("( 0.9.2342.19200300.100.1.40 NAME 'personalTitle' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.41 NAME 'mobile' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.42 NAME 'pager' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.43 NAME 'co' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.44 NAME 'pilotUniqueIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.45 NAME 'organizationalStatus' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.46 NAME 'janetMailbox' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.47 NAME 'mailPreferenceOption' SYNTAX 'INTEGER' SINGLE-VALUE NO-USER-MODIFICATION  USAGE directoryOperation )"),
  TEXT("( 0.9.2342.19200300.100.1.48 NAME 'buildingName' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.49 NAME 'dSAQuality' SYNTAX 'DSAQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.50 NAME 'singleLevelQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.51 NAME 'subtreeMinimumQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.52 NAME 'subtreeMaximumQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.53 NAME 'personalSignature' SYNTAX 'Fax' )"),
  TEXT("( 0.9.2342.19200300.100.1.54 NAME 'dITRedirect' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.55 NAME 'audio' SYNTAX 'Audio' )"),
  TEXT("( 0.9.2342.19200300.100.1.56 NAME 'documentPublisher' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.60 NAME 'jpegPhoto' SYNTAX 'JPEG' )"),
  TEXT("( 2.5.18.1 NAME 'createTimestamp' EQUALITY generalizedTimeMatch ORDERING generalizedTimeOrderingMatch SYNTAX 'GeneralizedTime' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.2 NAME 'modifyTimestamp' EQUALITY generalizedTimeMatch ORDERING generalizedTimeOrderingMatch SYNTAX 'GeneralizedTime' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.3 NAME 'creatorsName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.4 NAME 'modifiersName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.10 NAME 'subschemaSubentry' DESC 'The value of this attribute is the name of a subschema subentry, an entry in which the server makes available attributes specifying the schema.' EQUALITY distinguishedNameMatch SYNTAX 'DN' NO-USER-MODIFICATION SINGLE-VALUE USAGE directoryOperation )"),
  TEXT("( 2.5.21.5 NAME 'attributeTypes' EQUALITY objectIdentifierFirstComponentMatch SYNTAX 'AttributeTypeDescription' USAGE directoryOperation )"),
  TEXT("( 2.5.21.6 NAME 'objectClasses' EQUALITY objectIdentifierFirstComponentMatch SYNTAX 'ObjectClassDescription' USAGE directoryOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.1 NAME 'administratorsAddress' DESC 'This attribute\27s values are string containing the addresses of the LDAP server\27s human administrator.  This information may be of use when tracking down problems in an Internet distributed directory.  For simplicity the syntax of the values are limited to being URLs of the mailto form with an RFC 822 address: \"mailto:user@domain\".  Future versions of this protocol may permit other forms of addresses.' SYNTAX 'IA5String' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.2 NAME 'currentTime' DESC 'This attribute has a single value, a string containing a GeneralizedTime character string.  This attribute need only be present if the server supports LDAP strong or protected simple authentication. Otherwise if the server does not know the current time, or does not choose to present it to clients, this attribute need not be present. The client may wish to use this value to detect whether a strong or protected bind is failing because the client and server clocks are not sufficiently synchronized.  Clients should not use this time field for setting their own system clock.' SYNTAX 'GeneralizedTime' SINGLE-VALUE USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.3 NAME 'serverName' DESC 'This attribute\27s value is the server\27s Distinguished Name.  If the server does not have a Distinguished Name it will not be able to accept X.509-style strong authentication, and this attribute should be absent.  However the presence of this attribute does not guarantee that the server will be able to perform strong authentication.  If the server acts as a gateway to more than one X.500 DSA capable of strong authentication, there may be multiple values of this attribute, one per DSA.  (Note: this attribute is distinct from myAccessPoint, for it is not required that a server have a presentation address in order to perform strong authentication.)  (Note: it is likely that clients will retrieve this attribute in binary.)' SYNTAX 'DN' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.4 NAME 'certificationPath' DESC 'This attribute contains a binary DER encoding of an AF.CertificatePath data type, which is the certificate path for a server.  If the server does not have a certificate path this attribute should be absent.  (Note: this attribute may only be retrieved in binary.)' SYNTAX 'CertificatePath' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.5 NAME 'namingContexts' DESC 'The values of this attribute correspond to naming contexts which this server masters or shadows.  If the server does not master any information (e.g. it is an LDAP gateway to a public X.500 directory) this attribute should be absent.  If the server believes it contains the entire directory, the attribute should have a single value, and that value should be the empty string (indicating the null DN of the root). This attribute will allow clients to choose suitable base objects for searching when it has contacted a server.' SYNTAX 'DN' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.6 NAME 'altServer' DESC 'The values of this attribute are URLs of other servers which may be contacted when this server becomes unavailable.  If the server does not know of any other servers which could be used this attribute should be absent. Clients should cache this information in case their preferred LDAP server later becomes unavailable.' SYNTAX 'IA5String' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.7 NAME 'supportedExtension' DESC 'The values of this attribute are OBJECT IDENTIFIERs, the names of supported extensions which the server supports.   If the server does not support any extensions this attribute should be absent.' SYNTAX 'OID' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.8 NAME 'entryName' SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.9 NAME 'modifyRights' SYNTAX 'ModifyRight' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.10 NAME 'incompleteEntry' SYNTAX 'BOOLEAN' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.11 NAME 'fromEntry' SYNTAX 'BOOLEAN' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.121.1 NAME 'url' DESC 'Uniform Resource Locator' EQUALITY caseExactIA5Match SYNTAX 'IA5String' )"),
  TEXT("( 2.16.840.1.113730.3.1.18 NAME 'mailHost' DESC 'mailHost attribute on some V2 servers' SYNTAX 'DirectoryString' )")
};

DWORD g_cDefaultAttributeTypes = sizeof(g_aDefaultAttributeTypes)/sizeof(g_aDefaultAttributeTypes[0]);

LPTSTR g_aDefaultObjectClasses[] = {
  TEXT("( 2.5.6.0 NAME 'top' ABSTRACT MUST objectClass )"),
  TEXT("( 2.5.6.1 NAME 'alias' SUP top STRUCTURAL MUST aliasedObjectName )"),
  TEXT("( 2.5.6.2 NAME 'country' SUP top STRUCTURAL MUST c MAY ( searchGuide $ description ) )"),
  TEXT("( 2.5.6.3 NAME 'locality' SUP top STRUCTURAL MAY ( street $ seeAlso $ searchGuide $ st $ l $ description ) )"),
  TEXT("( 2.5.6.4 NAME 'organization' SUP top STRUCTURAL MUST o MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description ) )"),
  TEXT("( 2.5.6.5 NAME 'organizationalUnit' SUP top STRUCTURAL MUST ou MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description ) )"),
  TEXT("( 2.5.6.6 NAME 'person' SUP top STRUCTURAL MUST ( sn $ cn ) MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) )"),
  TEXT("( 2.5.6.7 NAME 'organizationalPerson' SUP person STRUCTURAL MAY ( title $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ ou $ st $ l ) )"),
  TEXT("( 2.5.6.8 NAME 'organizationalRole' SUP top STRUCTURAL MUST cn MAY ( x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ seeAlso $ roleOccupant $ preferredDeliveryMethod $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ ou $ st $ l $ description ) )"),
  TEXT("( 2.5.6.9 NAME 'groupOfNames' SUP top STRUCTURAL MUST ( member $ cn ) MAY ( businessCategory $ seeAlso $ owner $ ou $ o $ description ) )"),
  TEXT("( 2.5.6.10 NAME 'residentialPerson' SUP person STRUCTURAL MUST l MAY ( businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ preferredDeliveryMethod $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st ) )"),
  TEXT("( 2.5.6.11 NAME 'applicationProcess' SUP top STRUCTURAL MUST cn MAY ( seeAlso $ ou $ l $ description ) )"),
  TEXT("( 2.5.6.12 NAME 'applicationEntity' SUP top STRUCTURAL MUST ( presentationAddress $ cn ) MAY ( supportedApplicationContext $ seeAlso $ ou $ o $ l $ description ) )"),
  TEXT("( 2.5.6.13 NAME 'dSA' SUP applicationEntity STRUCTURAL MAY knowledgeInformation )"),
  TEXT("( 2.5.6.14 NAME 'device' SUP top STRUCTURAL MUST cn MAY ( serialNumber $ seeAlso $ owner $ ou $ o $ l $ description ) )"),
  TEXT("( 2.5.6.15 NAME 'strongAuthenticationUser' SUP top STRUCTURAL MUST userCertificate )"),
  TEXT("( 2.5.6.16 NAME 'certificationAuthority' SUP top STRUCTURAL MUST ( authorityRevocationList $ certificateRevocationList $ cACertificate ) MAY crossCertificatePair )"),
  TEXT("( 2.5.6.17 NAME 'groupOfUniqueNames' SUP top STRUCTURAL MUST ( uniqueMember $ cn ) MAY ( businessCategory $ seeAlso $ owner $ ou $ o $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.3 NAME 'pilotObject' SUP top STRUCTURAL MAY ( jpegPhoto $ audio $ dITRedirect $ lastModifiedBy $ lastModifiedTime $  pilotUniqueIdentifier $ manager $ photo $ info ) )"),
  TEXT("( 0.9.2342.19200300.100.4.4 NAME 'newPilotPerson' SUP person STRUCTURAL MAY ( personalSignature $ mailPreferenceOption $ organizationalStatus $ pagerTelephoneNumber $ mobileTelephoneNumber $ otherMailbox $ janetMailbox $ businessCategory $ preferredDeliveryMethod $ personalTitle $ secretary $ homePostalAddress $ homePhone $ userClass $ roomNumber $ favouriteDrink $ rfc822Mailbox $ textEncodedORaddress $ userid ) )"),
  TEXT("( 0.9.2342.19200300.100.4.5 NAME 'account' SUP top STRUCTURAL MUST userid MAY ( host $ ou $ o $ l $ seeAlso $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.6 NAME 'document' SUP ( top $ pilotObject ) STRUCTURAL MUST documentIdentifier MAY ( documentPublisher $ documentStore $ documentAuthorSurName $ documentAuthorCommonName $ abstract $ subject $ keywords $ updatedByDocument $ updatesDocument $ obsoletedByDocument $ obsoletesDocument $ documentLocation $ documentAuthor $ documentVersion $ documentTitle $ ou $ o $ l $ seeAlso $ description $ cn ) )"),
  TEXT("( 0.9.2342.19200300.100.4.7 NAME 'room' SUP top STRUCTURAL MUST cn MAY ( telephoneNumber $ seeAlso $ description $ roomNumber ) )"),
  TEXT("( 0.9.2342.19200300.100.4.9 NAME 'documentSeries' SUP top STRUCTURAL MUST cn MAY ( ou $ o $ l $ telephoneNumber $ seeAlso $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.13 NAME 'domain' SUP top STRUCTURAL MUST dc MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description $ o $ associatedName ) ) "),
  TEXT("( 0.9.2342.19200300.100.4.14 NAME 'rFC822localPart' SUP domain STRUCTURAL MAY ( x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ streetAddress $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ telephoneNumber $ seeAlso $ description $ sn $ cn ) ) "),
  TEXT("( 0.9.2342.19200300.100.4.15 NAME 'dNSDomain' SUP domain STRUCTURAL MAY dNSRecord ) "),
  TEXT("( 0.9.2342.19200300.100.4.17 NAME 'domainRelatedObject' SUP top STRUCTURAL MUST associatedDomain )"),
  TEXT("( 0.9.2342.19200300.100.4.18 NAME 'friendlyCountry' SUP country STRUCTURAL MUST co )"),
  TEXT("( 0.9.2342.19200300.100.4.19 NAME 'simpleSecurityObject' SUP top STRUCTURAL MUST userPassword )"),
  TEXT("( 0.9.2342.19200300.100.4.20 NAME 'pilotOrganization' SUP ( organization $ organizationalUnit ) STRUCTURAL MAY buildingName )"),
  TEXT("( 0.9.2342.19200300.100.4.21 NAME 'pilotDSA' SUP dSA STRUCTURAL MUST dSAQuality )"),
  TEXT("( 0.9.2342.19200300.100.4.23 NAME 'qualityLabelledData' SUP top STRUCTURAL MUST singleLevelQuality MAY ( subtreeMaximumQuality $ subtreeMinimumQuality ) ) ")
};

DWORD g_cDefaultObjectClasses = sizeof(g_aDefaultObjectClasses)/sizeof(g_aDefaultObjectClasses[0]);


//
// Table mapping from LDAPType To ADsType
//
ADSTYPE g_MapLdapTypeToADsType[] = {
    ADSTYPE_INVALID,
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_BITSTRING                   */
    ADSTYPE_PRINTABLE_STRING,                  /* LDAPTYPE_PRINTABLESTRING             */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DIRECTORYSTRING             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATE                 */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATELIST             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATEPAIR             */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_COUNTRYSTRING               */
    ADSTYPE_DN_STRING,                         /* LDAPTYPE_DN                          */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DELIVERYMETHOD              */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ENHANCEDGUIDE               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_FACSIMILETELEPHONENUMBER    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_GUIDE                       */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_NAMEANDOPTIONALUID          */
    ADSTYPE_NUMERIC_STRING,                    /* LDAPTYPE_NUMERICSTRING               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OID                         */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_PASSWORD                    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_POSTALADDRESS               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_PRESENTATIONADDRESS         */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_TELEPHONENUMBER             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_TELETEXTERMINALIDENTIFIER   */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_TELEXNUMBER                 */
    ADSTYPE_UTC_TIME,                          /* LDAPTYPE_UTCTIME                     */
    ADSTYPE_BOOLEAN,                           /* LDAPTYPE_BOOLEAN                     */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_AUDIO                       */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DSAQUALITYSYNTAX            */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DATAQUALITYSYNTAX           */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_IA5STRING                   */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_JPEG                        */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_MAILPREFERENCE              */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OTHERMAILBOX                */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_FAX                         */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ATTRIBUTETYPEDESCRIPRITION  */
    ADSTYPE_UTC_TIME,                          /* LDAPTYPE_GENERALIZEDTIME             */
    ADSTYPE_INTEGER,                           /* LDAPTYPE_INTEGER                     */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OBJECTCLASSDESCRIPTION      */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_OCTETSTRING                 */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_CASEIGNORESTRING            */
    ADSTYPE_LARGE_INTEGER,                     /* LDAPTYPE_INTEGER8                    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ACCESSPOINTDN               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ORNAME                      */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MASTERANDSHADOWACCESSPOINTS */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MATCHINGRULEDESCRIPTION     */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MATCHINGRULEUSEDESCRIPTION  */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_NAMEFORMDESCRIPTION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUBTREESPECIFICATION        */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERINFORMATION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERORCONSUMER          */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERANDCONSUMERS        */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_PROTOCOLINFORMATION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MODIFYRIGHT                 */
    ADSTYPE_NT_SECURITY_DESCRIPTOR,            /* LDAPTYPE_SECURITY_DESCRIPTOR         */
    ADSTYPE_CASE_EXACT_STRING,                 /* LDAPTYPE_CASEEXACT_STRING            */
    ADSTYPE_DN_WITH_BINARY,                    /* LDAPTYPE_DNWITHBINARY                */
    ADSTYPE_DN_WITH_STRING,                    /* LDAPTYPE_DNWITHSTRING                */
    ADSTYPE_CASE_IGNORE_STRING                 /* LDAPTYPE_ORADDRESS                   */
};


DWORD g_cMapLdapTypeToADsType = ARRAY_SIZE(g_MapLdapTypeToADsType);


//
// Table mapping from ADsType To LDAPType
//
DWORD g_MapADsTypeToLdapType[] = {
    LDAPTYPE_UNKNOWN,               // ADSTYPE_UNKNOWN
	LDAPTYPE_DN,                    // ADSTYPE_DN_STRING
	LDAPTYPE_CASEIGNORESTRING,      // ADSTYPE_CASE_EXACT_STRING
	LDAPTYPE_CASEIGNORESTRING,      // ADSTYPE_CASE_IGNORE_STRING
	LDAPTYPE_PRINTABLESTRING,       // ADSTYPE_CASE_PRINTABLE_STRING
	LDAPTYPE_NUMERICSTRING,         // ADSTYPE_CASE_NUMERIC_STRING
	LDAPTYPE_BOOLEAN,               // ADSTYPE_BOOLEAN
	LDAPTYPE_INTEGER,               // ADSTYPE_INTEGER
	LDAPTYPE_OCTETSTRING,           // ADSTYPE_OCTET_STRING
	LDAPTYPE_UTCTIME,               // ADSTYPE_UTC_TIME
	LDAPTYPE_INTEGER8,              // ADSTYPE_LARGE_INTEGER
	LDAPTYPE_OCTETSTRING,           // ADSTYPE_PROV_SPECIFIC
	LDAPTYPE_UNKNOWN,               // ADSTYPE_OBJECT_CLASS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_CASEIGNORE_LIST
	LDAPTYPE_UNKNOWN,               // ADSTYPE_OCTET_LIST
	LDAPTYPE_UNKNOWN,               // ADSTYPE_PATH
	LDAPTYPE_UNKNOWN,               // ADSTYPE_POSTALADDRESS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_TIMESTAMP
	LDAPTYPE_UNKNOWN,               // ADSTYPE_BACKLINK
	LDAPTYPE_UNKNOWN,               // ADSTYPE_TYPEDNAME
	LDAPTYPE_UNKNOWN,               // ADSTYPE_HOLD
	LDAPTYPE_UNKNOWN,               // ADSTYPE_NETADDRESS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_REPLICAPOINTER
	LDAPTYPE_UNKNOWN,               // ADSTYPE_FAXNUMBER
	LDAPTYPE_UNKNOWN,               // ADSTYPE_EMAIL
	LDAPTYPE_SECURITY_DESCRIPTOR,   // ADSTYPE_NT_SECURITY_DESCRIPTOR
	LDAPTYPE_UNKNOWN                // ADSTYPE_UNKNOWN
};


DWORD g_cMapADsTypeToLdapType = ARRAY_SIZE(g_MapADsTypeToLdapType);


//+------------------------------------------------------------------------
//
//  Function:   MapADsTypeToLDAPType
//
//  Synopsis: This function attempts a best effort map from
//      ADSTYPE to LDAPTTPE - this is a best effort map
//      because LDAPTYPE->ADSTYPE is not a 1 --> 1 mapping.
//
//  Arguments:  [dwADsType]    -- ADSTYPE to be mapped
//
//  RetVal   : DWORD giving the ldaptype
//
//-------------------------------------------------------------------------
DWORD
MapADSTypeToLDAPType(
    ADSTYPE dwAdsType
    )
{
    DWORD dwADSTYPE = (DWORD) dwAdsType;

    if (dwAdsType < 0 || (DWORD)dwAdsType > g_cMapADsTypeToLdapType) {
        return (LDAPTYPE_UNKNOWN);
    } else {
        return (g_MapADsTypeToLdapType[(DWORD)dwAdsType]);
    }
}



ADSTYPE
MapLDAPTypeToADSType(
    DWORD dwLdapType
    )
{
    //
    // - LDAPTYPE_UNKNOWN or 0 -> ADSTYPE_UNKNOWN
    //   NOTE:  should not be but misuse of 0 everywhere and just in case
    //          I didn't clean up completely
    //
    // - other undefined ldaptypes -> ADSTYPE_INVALID
    //

    if (dwLdapType==LDAPTYPE_UNKNOWN || dwLdapType==0) {

        return ADSTYPE_UNKNOWN;
    }

    else if (dwLdapType < g_cMapLdapTypeToADsType) {

        return(g_MapLdapTypeToADsType[dwLdapType]);
    }

    else {

        return(ADSTYPE_INVALID);
    }
}


LDAP_REFERRAL_CALLBACK g_LdapReferralCallBacks = {
    sizeof( LDAP_REFERRAL_CALLBACK ),
    &QueryForConnection,
    &NotifyNewConnection,
    &DereferenceConnection
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\encode.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#define UNICODE
#define _UNICODE


#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <winldap.h>
#include <adserr.h>


#include "memory.h"


#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

HRESULT 
ADsEncodeBinaryData (
   PBYTE   pbSrcData,
   DWORD   dwSrcLen,
   LPWSTR  * ppszDestData
   )
{
    LPWSTR pszDest = NULL;
    DWORD dwDestLen, dwDestSize = 0;
    WCHAR wch;

    if (!ppszDestData || (!pbSrcData && dwSrcLen))
        return (E_ADS_BAD_PARAMETER);

    *ppszDestData = NULL;

    //
    //  figure out how long of a buffer we need.
    //

    dwDestLen = ldap_escape_filter_element (
                         (char *) pbSrcData,
                         dwSrcLen,
                         NULL,
                         0
                         );

    if (dwDestLen == 0) {
        return S_OK;
    }

    dwDestSize = dwDestLen * sizeof (WCHAR);

    pszDest = (LPWSTR) AllocADsMem(  dwDestSize );
    if (pszDest == NULL) 
        return  (E_OUTOFMEMORY );

    ldap_escape_filter_element (
        (char *) pbSrcData,
        dwSrcLen,
        pszDest,
        dwDestSize
        );

    *ppszDestData = pszDest;

    return (S_OK);

}

HRESULT 
ADsDecodeBinaryData (
   LPWSTR szSrcData,
   PBYTE  *ppbDestData,
   ULONG  *pdwDestLen
   )
{
    HRESULT hr = S_OK;
    ULONG dwDestLen = 0;
    LPWSTR szSrc = NULL;
    PBYTE pbDestData = NULL;
    PBYTE pbDestDataCurrent = NULL;
    WCHAR ch = 0;

    if (szSrcData == NULL) {
        return E_FAIL;
    }

    // 
    // Counting length of output binary string
    //
    szSrc = szSrcData;
    while (*szSrc != L'\0') {
        ch = *(szSrc++);

        if (ch == L'\\') {
            szSrc = szSrc + 2;
        }
        dwDestLen++;
    }
    

    // 
    // Allocating return binary string
    //
    pbDestData = (PBYTE) AllocADsMem(dwDestLen);
    if (pbDestData == NULL) {
        hr = E_OUTOFMEMORY;
        return (hr);
    }

    // 
    // Decoding String
    //
    szSrc = szSrcData;
        pbDestDataCurrent = pbDestData;
    while (*szSrc != L'\0') {
        ch = *szSrc ++;

        if (ch == L'\\') {
            *(pbDestDataCurrent++) = MAPHEXTODIGIT( *szSrc ) * 16 +
                                     MAPHEXTODIGIT( *(szSrc+1) );
            szSrc+=2;
        }
        else {
            *(pbDestDataCurrent++) = (BYTE)ch;
        }
    }

    *ppbDestData = pbDestData;
    *pdwDestLen = dwDestLen;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldapsch.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  ldapsch.cxx
//
//  Contents:  LDAP Schema Parser
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#define ADSI_LDAP_KEY    TEXT("SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP")
#define SCHEMA_DIR_NAME  TEXT("SchCache\\")
#define SCHEMA_FILE_NAME_EXT TEXT(".sch")
#define DEFAULT_SCHEMA_FILE_NAME TEXT("Default")
#define DEFAULT_SCHEMA_FILE_NAME_WITH_EXT TEXT("Default.sch")
#define SCHEMA_FILE_NAME TEXT("File")
#define SCHEMA_TIME      TEXT("Time")
#define SCHEMA_PROCESSAUX    TEXT("ProcessAUX")


#define MAX_LOOP_COUNT  30  // Maximum depth of schema class tree
#define ENTER_SCHEMA_CRITSECT()  EnterCriticalSection(&g_SchemaCritSect)
#define LEAVE_SCHEMA_CRITSECT()  LeaveCriticalSection(&g_SchemaCritSect)

#define ENTER_SUBSCHEMA_CRITSECT()  EnterCriticalSection(&g_SubSchemaCritSect)
#define LEAVE_SUBSCHEMA_CRITSECT()  LeaveCriticalSection(&g_SubSchemaCritSect)

#define ENTER_DEFAULTSCHEMA_CRITSECT()  EnterCriticalSection(&g_DefaultSchemaCritSect)
#define LEAVE_DEFAULTSCHEMA_CRITSECT()  LeaveCriticalSection(&g_DefaultSchemaCritSect)



#define ID_ATTRTYPES       1
#define ID_OBJCLASSES      2
#define ID_DITCONTENTRULES 3

#ifdef WIN95
int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii );
#endif

//
// Constants used to determine what elements of string array to free.
//
const int FREE_ALL = 0;
const int FREE_ARRAY_NOT_ELEMENTS = 1;
const int FREE_ALL_BUT_FIRST = 2;



//
// RFC 2252
//
KWDLIST g_aSchemaKeywordList[] =
{
    { TOKEN_NAME,        TEXT("NAME") },
    { TOKEN_DESC,        TEXT("DESC") },
    { TOKEN_OBSOLETE,    TEXT("OBSOLETE") },
    { TOKEN_SUP,         TEXT("SUP") },
    { TOKEN_EQUALITY,    TEXT("EQUALITY") },
    { TOKEN_ORDERING,    TEXT("ORDERING") },
    { TOKEN_SUBSTR,      TEXT("SUBSTR") },
    { TOKEN_SYNTAX,      TEXT("SYNTAX") },
    { TOKEN_SINGLE_VALUE, TEXT("SINGLE-VALUE") },
    { TOKEN_COLLECTIVE,  TEXT("COLLECTIVE") },
    { TOKEN_DYNAMIC,     TEXT("DYNAMIC") },
    { TOKEN_NO_USER_MODIFICATION, TEXT("NO-USER-MODIFICATION") },
    { TOKEN_USAGE,       TEXT("USAGE") },
    { TOKEN_ABSTRACT,    TEXT("ABSTRACT") },
    { TOKEN_STRUCTURAL,  TEXT("STRUCTURAL") },
    { TOKEN_AUXILIARY,   TEXT("AUXILIARY") },
    { TOKEN_MUST,        TEXT("MUST") },
    { TOKEN_MAY,         TEXT("MAY") },
    { TOKEN_AUX,         TEXT("AUX") },
    { TOKEN_NOT,         TEXT("NOT") }
    // FORM
};

DWORD g_dwSchemaKeywordListSize = sizeof(g_aSchemaKeywordList)/sizeof(KWDLIST);

CRITICAL_SECTION  g_SchemaCritSect;
CRITICAL_SECTION  g_DefaultSchemaCritSect;
CRITICAL_SECTION  g_SubSchemaCritSect;
SCHEMAINFO *g_pSchemaInfoList = NULL;  // Link list of cached schema info
SCHEMAINFO *g_pDefaultSchemaInfo = NULL;

//
// Non-AD sd control.
//
#define ADSI_LDAP_OID_SECDESC_OLD L"1.2.840.113556.1.4.416"

typedef struct _subschemalist {
   LPWSTR pszLDAPServer;
   LPWSTR pszSubSchemaEntry;
   BOOL fPagingSupported;
   BOOL fSortingSupported;
   BOOL fDomScopeSupported;
   BOOL fTalkingToAD;
   BOOL fTalkingToEnhancedAD;
   BOOL fVLVSupported;
   BOOL fAttribScopedSupported;
   struct _subschemalist *pNext;
   BOOL fNoDataGot;
   DWORD dwSecDescType;
} SCHEMALIST, *PSCHEMALIST;

//
// The fNoDataReturned will be set for v2 servers that do not
// have a subSchemaSubEntry, this will prevent hitting the server
// multiple times for the same data.
//

typedef SCHEMALIST ROOTDSENODE, *PROOTDSENODE;

PSCHEMALIST gpSubSchemaList = NULL;

static DWORD dwSubSchemaSubEntryCount = 0;

HRESULT
GetSchemaInfoTime(
    LPTSTR  pszServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  *ppszTimeReg,
    LPTSTR  *ppszTimeDS,
    CCredentials& Credentials,
    DWORD dwPort
);

HRESULT
LdapReadSchemaInfoFromServer(
    LPTSTR pszLDAPPath,
    LPTSTR pszSubSchemaSubEntry,
    LPTSTR  pszTimeReg,
    LPTSTR  pszTimeDS,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
);

HRESULT
ReadRootDSENode(
    LPWSTR pszLDAPServer,
    PROOTDSENODE pRootDSENode,
    OUT BOOL * pfBoundOk,           // optional, can be NULL
    CCredentials& Credentials,
    DWORD dwPort
    );

HRESULT
LdapReadDefaultSchema(
    LPTSTR  pszServer,
    CCredentials &Credentials,
    SCHEMAINFO **ppSchemaInfo
);

HRESULT FillPropertyInfoArray(
    LPTSTR *aAttrTypes,
    DWORD  dwCount,
    PROPERTYINFO **paProperties,
    DWORD *pnProperties,
    SEARCHENTRY **paSearchTable
);

HRESULT FillClassInfoArray(
    LPTSTR *aObjectClasses,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO **paClasses,
    DWORD *pnClasses,
    SEARCHENTRY **paSearchTable
);

HRESULT FillAuxClassInfoArray(
    LPTSTR *aDITContentRules,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aSearchTable
);

HRESULT ProcessClassInfoArray(
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *paSearchTable,
    BOOL fProcessAUX = FALSE
);

HRESULT ProcessPropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD nProperties,
    SEARCHENTRY **paSearchTable
);

DWORD ReadSchemaInfoFromRegistry(
    HKEY hKey,
    LPWSTR pszServer,
    LPTSTR **paValuesAttribTypes,
    int *pnCountAttribTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pBuffer
);

DWORD StoreSchemaInfoInRegistry(
    HKEY hKey,
    LPTSTR pszServer,
    LPTSTR pszTime,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules,
    BOOL fProcessAUX
);

HRESULT
AttributeTypeDescription(
    LPTSTR pszAttrType,
    PPROPERTYINFO pPropertyInfo,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
);

HRESULT
ObjectClassDescription(
    LPTSTR pszDescription,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
);

HRESULT DITContentRuleDescription(
    LPTSTR pszObjectClass,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount
);

//
// Helper routine that adds new elements to the property info array.
//
HRESULT AddNewNamesToPropertyArray(
    PROPERTYINFO **ppPropArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    );

//
// Helper routine that adds new elements to the class info array.
//
HRESULT AddNewNamesToClassArray(
    CLASSINFO **ppClassArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    );

//
// The 3rd param was added to work around bad schema data.
//
HRESULT Oid(
    CSchemaLexer * pTokenizer,
    LPTSTR *ppszOID,
    BOOL fNoGuid = FALSE
);

HRESULT Oids(
    CSchemaLexer * pTokenizer,
    LPTSTR **pOIDs,
    DWORD *pnNumOfOIDs
);

HRESULT PropOids(
    CSchemaLexer * pTokenizer,
    int **pOIDs,
    DWORD *pnNumOfOIDs,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount
);

HRESULT DirectoryString(
    CSchemaLexer * pTokenizer,
    LPTSTR *ppszDirString
);

//
// Returns *pdwCount strings in ppszDirStrings.
//
HRESULT DirectoryStrings(
    CSchemaLexer * pTokenizer,
    LPTSTR **pppszDirStrings,
    PDWORD pdwCount
    );

void FreeDirectoryStrings(
    LPTSTR *ppszDirStrings,
    DWORD dwCount,
    DWORD dwElementsToFree= FREE_ALL
    );                

VOID SortAndRemoveDuplicateOIDs(
    int *pOIDs,
    DWORD *pnNumOfOIDs
);

int _cdecl searchentrycmp(
    const void *s1,
    const void *s2
);

long CompareUTCTime(
    LPTSTR pszTime1,
    LPTSTR pszTime2
);

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );

BOOL
EquivalentUsers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

//
// Makes a copy of a string array that has NULL as the last element.
// If the copy failed because of lack of memory NULL is returned.
//
LPTSTR *
CopyStringArray(
    LPTSTR * ppszStr
    ) 
{
    LPTSTR * ppszRetVal = NULL;
    DWORD dwCount = 0;

    if (!ppszStr) {
        BAIL_ON_FAILURE(E_FAIL);
    }
       
    //
    // Get the count first.
    //
    while (ppszStr && ppszStr[dwCount]) {
        dwCount++;
    }

    //
    // Alloc memory for the array, + 1, is for the NULL string that
    // acts as the delimiter for the array.
    //
    ppszRetVal = (LPTSTR *) AllocADsMem((dwCount+1) * sizeof(LPTSTR));

    if (!ppszRetVal) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    for (DWORD dwCtr = 0; dwCtr <= dwCount; dwCtr++) {
        if (ppszStr[dwCtr]) {
            ppszRetVal[dwCtr] = AllocADsStr(ppszStr[dwCtr]);
            
            if (!ppszRetVal[dwCtr]) {
                BAIL_ON_FAILURE(E_OUTOFMEMORY);
            }
        }
    }

    return ppszRetVal;

error:

   if (ppszRetVal) {
       for (DWORD i = 0; i < dwCtr; i++) {
           if (ppszRetVal[i]) {
               FreeADsStr(ppszRetVal[i]);
           }
       }
       FreeADsMem(ppszRetVal);
       ppszRetVal = NULL;
   }

   //
   // Null from this routine means there was a failure.
   //
   return NULL;
}


VOID
SchemaInit(
    VOID
)
{
    InitializeCriticalSection( &g_SchemaCritSect );
    InitializeCriticalSection(&g_SubSchemaCritSect);
    InitializeCriticalSection(&g_DefaultSchemaCritSect);
}

VOID
SchemaCleanup(
    VOID
)
{
    SCHEMAINFO *pList = g_pSchemaInfoList;

    while ( pList )
    {
        SCHEMAINFO *pNext = pList->Next;

        delete pList;
        pList = pNext;
    }

    delete g_pDefaultSchemaInfo;


    //
    // Delete the schema list containing the server infos
    //

    PSCHEMALIST pSubSchemaList = gpSubSchemaList;

    while ( pSubSchemaList )
    {
        PSCHEMALIST pNext = pSubSchemaList->pNext;

        if ( pSubSchemaList->pszLDAPServer )
            FreeADsStr( pSubSchemaList->pszLDAPServer );

        if ( pSubSchemaList->pszSubSchemaEntry )
            FreeADsStr( pSubSchemaList->pszSubSchemaEntry );

        FreeADsMem( pSubSchemaList );

        pSubSchemaList = pNext;
    }

    //
    // Delete critsects initialized in SchemaInit
    //
    DeleteCriticalSection(&g_SchemaCritSect);
    DeleteCriticalSection(&g_SubSchemaCritSect);
    DeleteCriticalSection(&g_DefaultSchemaCritSect);
}


HRESULT
LdapGetSchema(
    LPTSTR pszLDAPServer,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp = NULL;

    SCHEMAINFO *pList = NULL;
    SCHEMAINFO *pPrev = NULL;

    LPTSTR pszTimeReg = NULL;
    LPTSTR pszTimeDS = NULL;
    BOOL fNotCurrent = FALSE;
    WCHAR szDomainDnsName[MAX_PATH];

    *ppSchemaInfo = NULL;

    DWORD nCount =0;

    LPWSTR pszSubSchemaEntry = NULL;

    BOOL fBoundOk = FALSE;    // has once bound to domain okay?
    BOOL fReuseSchema = FALSE;
    BOOL fTalktoAD = FALSE;


    //
    // In the case of a serverless path, we want to substitute the name
    // of the domain for the serverName. This is because we can get more
    // than one file called default.sch if a person logs on from different
    // forests on to the same domain.
    //
    if (!pszLDAPServer) {
        WCHAR szServerName[MAX_PATH];
        DWORD dwErr;
        
        dwErr = GetDefaultServer(
                    dwPort,
                    FALSE, // do not force verify
                    szDomainDnsName,
                    szServerName,
                    !(Credentials.GetAuthFlags() & ADS_READONLY_SERVER)
                        ? TRUE : FALSE
                    );
        if (dwErr == NO_ERROR) {
            //
            // Use the domainName returned.
            //
            pszLDAPServer = szDomainDnsName;
        }
    }

    //
    // Check if the server uses default schema and return the schema info
    //

    hr = Credentials.GetUserName(&pszTemp);
    BAIL_IF_ERROR(hr);


    ENTER_SCHEMA_CRITSECT();

    pList = g_pSchemaInfoList;
    pPrev = NULL;

    
    while ( pList )
    {
        //
        // Checking for Schemas can now use NULL and NULL
        //

        //
        // If the server is equivalent, and we've cached it as using
        // a default (V2) schema, then we want to immediately return
        // that cached schema, UNLESS (1) the server in question 
        // appeared to be a V3 server when we tried to retrieve the schema
        // (i.e., it had a rootDSE with a subschemasubentry), AND (2)
        // we're currently using different user credentials then when
        // we cached the server schema.  This is because we might be going
        // against a V3 server that has security restrictions on its schema.
        // If we previously tried to read the schema, but didn't have
        // sufficient access permissions to do so, we would have defaulted
        // to treating it as a v2 schema.  Now, if we're using different
        // credentials, we try again, in case we now have sufficient
        // access permissions to read the schema.
        //
        if (EquivalentServers(pList->pszServerName, pszLDAPServer)) {
        
            if ( pList->fDefaultSchema &&
                 !(pList->fAppearsV3 &&
                   !EquivalentUsers(pszTemp, pList->pszUserName)
                  )
               )
            {
                    *ppSchemaInfo = pList;
                    (*ppSchemaInfo)->AddRef();

                    LEAVE_SCHEMA_CRITSECT();
                    goto cleanup;
            }
            else if (pList->fDefaultSchema &&
                     pList->fAppearsV3 &&
                     !EquivalentUsers(pszTemp, pList->pszUserName))
            {
                //
                // Dump the cached schema in preparation for reading
                // it again.
                //
                if ( pList->IsRefCountZero())
                {                
                    if ( pPrev == NULL )
                        g_pSchemaInfoList = pList->Next;
                    else
                        pPrev->Next = pList->Next;

                    delete pList;
                    break;
                }   
            }
        }
        
        pPrev = pList;
        pList = pList->Next;
    }

    LEAVE_SCHEMA_CRITSECT();

    //
    // Read the schema path from the root of the DS
    //

    hr = ReadSubSchemaSubEntry(
                 pszLDAPServer,
                 &pszSubSchemaEntry,
                 &fBoundOk,
                 Credentials,
                 dwPort
                 ) ;

    if ( SUCCEEDED(hr))     // pszSubSchemaEntry!=NULL if hr = S_OK. Checked.
    {

        ENTER_SCHEMA_CRITSECT();

        pPrev = NULL;
        pList = g_pSchemaInfoList;
        while ( pList )
        {
            
            hr = ReadServerSupportsIsADControl(pszLDAPServer, &fTalktoAD, Credentials, dwPort);
            if (FAILED(hr)) {
                //
                // Assume it is not AD and continue, there is no
                // good reason for this to fail on AD.
                //
                fTalktoAD = FALSE;
            }

            if(fTalktoAD) {
            	// we talking to the server with AD, so then we don't have to compare the servername
            	fReuseSchema =  EquivalentServers(pList->pszSubSchemaSubEntry, pszSubSchemaEntry );
            }
            else
            {
                // otherwise, we need to compare the server name
                fReuseSchema = EquivalentServers(pList->pszServerName, pszLDAPServer) &&
            	               EquivalentServers(pList->pszSubSchemaSubEntry, pszSubSchemaEntry );
            }
            	
            if ( fReuseSchema )
            {
                if ( pList->IsObsolete())
                {
                    hr = GetSchemaInfoTime(
                             pszLDAPServer,
                             pszSubSchemaEntry,
                             &pszTimeReg,
                             &pszTimeDS,
                             Credentials,
                             dwPort );

                    if ( FAILED(hr))
                    {
                        // Cannot get the time, assume the cache is not
                        // current and read again.

                        fNotCurrent = TRUE;
                        break;
                    }
                    else
                    {
                        //
                        // If the servers are not the same, then we should
                        // not comparet the times. This is because
                        // each server has a ModifyTimeStamp that is not
                        // based on its update time not that of the domain.
                        // Note that at this point we know that the
                        // subSchemaSubEntry is the same.
                        //
                        if (!EquivalentServers(
                                 pList->pszServerName,
                                 pszLDAPServer
                                 )
                            ) {
                            fNotCurrent = TRUE;
                            break;
                        }
                        // Compare the time to see if we need to read
                        // the schema info from the file or from the DS

                        if ( CompareUTCTime( pList->pszTime, pszTimeReg ) >= 0 )
                        {
                            if ( CompareUTCTime( pszTimeReg, pszTimeDS ) < 0 )
                            {
                                fNotCurrent = TRUE;
                                break;
                            }
                        }
                        else
                        {
                            // The schema in memory is not as current as the
                            // the one stored in the registry, hence, we
                            // need to read it anyway.
                            fNotCurrent = TRUE;
                            break;
                        }
                    }

                    pList->MakeCurrent();
                }

                *ppSchemaInfo = pList;
                (*ppSchemaInfo)->AddRef();

                LEAVE_SCHEMA_CRITSECT();
                goto cleanup;
            }

            pPrev = pList;
            pList = pList->Next;
        }

        if ( fNotCurrent && pList != NULL )
        {
            if ( pList->IsRefCountZero())
            {
                SCHEMAINFO *pDelete = pList;

                if ( pPrev == NULL )
                    g_pSchemaInfoList = pDelete->Next;
                else
                    pPrev->Next = pDelete->Next;

                delete pDelete;
            }

            pList = NULL;
        }

        LEAVE_SCHEMA_CRITSECT();

        // pList should be NULL at this point

        hr = LdapReadSchemaInfoFromServer(
                 pszLDAPServer,
                 pszSubSchemaEntry,  // SubSchemaSubEntry
                 pszTimeReg,
                 pszTimeDS,
                 ppSchemaInfo,
                 Credentials,
                 dwPort
                 );

        if (SUCCEEDED(hr)) {

            ENTER_SCHEMA_CRITSECT();

            (*ppSchemaInfo)->Next = g_pSchemaInfoList;
            g_pSchemaInfoList = *ppSchemaInfo;
            (*ppSchemaInfo)->AddRef();

            LEAVE_SCHEMA_CRITSECT();
        }
        else {

            //
            // There was some problem in reading from the DS. If it was
            // because of some error like the attributes were not
            // obtained or were not of the proper form, we will fall
            // back to the default schema
            //
            hr = LdapReadDefaultSchema(pszLDAPServer, Credentials, ppSchemaInfo);
            BAIL_IF_ERROR(hr);

            //
            // We leave fAppearsV3 == TRUE because this server has a
            // subschemasubentry --- it's just that we can't read the
            // schema (e.g., maybe we don't have permission)
            //

            ENTER_SCHEMA_CRITSECT();

            (*ppSchemaInfo)->Next = g_pSchemaInfoList;
            g_pSchemaInfoList = *ppSchemaInfo;
            (*ppSchemaInfo)->AddRef();

            LEAVE_SCHEMA_CRITSECT();
        }

    } // end of if read of subSchemaSubEntry succeeded 
    else if ( fBoundOk )
    {
        //
        // If we cannot get subschemasubentry, use default schema if
        // fBoundOk; that is, we have at least
        // once bound to the domain successfully before.
        //

        hr = LdapReadDefaultSchema( pszLDAPServer, Credentials, ppSchemaInfo );
        BAIL_IF_ERROR(hr);

        (*ppSchemaInfo)->fAppearsV3 = FALSE;

        ENTER_SCHEMA_CRITSECT();

        (*ppSchemaInfo)->Next = g_pSchemaInfoList;
        g_pSchemaInfoList = *ppSchemaInfo;
        (*ppSchemaInfo)->AddRef();

        LEAVE_SCHEMA_CRITSECT();
    }

    else
    {

        //
        // we cannot read subschemasubentry, but we are not using
        // default schema since we have no indication that the
        // we had ever bound to the domain before
        //

        if ( SUCCEEDED(hr)) // i.e. we could not read the schema
        {
            hr = E_ADS_BAD_PATHNAME;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    if (pszSubSchemaEntry) {
        FreeADsStr(pszSubSchemaEntry);
        }

    if ( pszTimeReg )
        FreeADsMem( pszTimeReg );

    if ( pszTimeDS )
        FreeADsMem( pszTimeDS );

    if ( pszTemp )
        FreeADsStr( pszTemp );

    RRETURN(hr);
}

HRESULT
LdapRemoveSchemaInfoOnServer(
    LPTSTR pszLDAPPath,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pList = NULL;
    LPWSTR pszSubSchemaSubEntry = NULL;
    BOOL fBoundOk = FALSE;

    //
    // Read the subschemaSubEntry only once.
    //
    hr = ReadSubSchemaSubEntry(
             pszLDAPPath,
             &pszSubSchemaSubEntry,
             &fBoundOk,
             Credentials,
             dwPort
             ) ;
    //
    // If we cannot read the subSchemaSubEntry it is not a
    // V3 server and we cannot refresh.
    //
    BAIL_ON_FAILURE(hr);

    ENTER_SCHEMA_CRITSECT();

    pList = g_pSchemaInfoList;
    while ( pList )
    {
        //
        // Both NULL and NULL and also check for the servers
        //

        if (!pList->pszServerName  && !pszLDAPPath) {

            pList->MakeObsolete();

            if (fForce) {
                //
                // Will reset time to something ancient so we
                // will always pick up the schema from server.
                //
                LPWSTR pszTempTime;
                pszTempTime = AllocADsStr(L"19800719000000.0Z");

                if (pszTempTime && pList->pszTime) {
                    FreeADsStr(pList->pszTime);
                    pList->pszTime = pszTempTime;
                }
            }

        } else {

            //
            // The match at this point has to be made based on the
            // subschemaSubEntry and not on the server names.
            //


            if (EquivalentServers(
                    pList->pszSubSchemaSubEntry,
                    pszSubSchemaSubEntry
                    )
                )
            {
                pList->MakeObsolete();

                if (fForce) {
                    //
                    // Will reset time to something ancient so we
                    // will always pick up the schema from server.
                    //
                    LPWSTR pszTempTime;
                    pszTempTime = AllocADsStr(L"19800719000000.0Z");

                    if (pszTempTime && pList->pszTime) {
                        FreeADsStr(pList->pszTime);
                        pList->pszTime = pszTempTime;
                    }
                }

            }
        } // the server name is not NULL
        pList = pList->Next;
    }

    LEAVE_SCHEMA_CRITSECT();

error :

    if (pszSubSchemaSubEntry) {
        FreeADsStr(pszSubSchemaSubEntry);
    }

    RRETURN(hr);
}

HRESULT
GetSchemaInfoTime(
    LPTSTR  pszLDAPServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  *ppszTimeReg,
    LPTSTR  *ppszTimeDS,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = NO_ERROR;
    LPTSTR pszLDAPPath = NULL;
    LPTSTR pszRegPath = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;

    TCHAR szTimeReg[64];
    HKEY hKey = NULL;
    DWORD dwLength;
    DWORD dwType;

    //
    // Read the schema timestamp on the DS server
    //

    hr = LdapReadAttribute2(
                   pszLDAPServer,
                   NULL,
                   pszSubSchemaSubEntry,
                   TEXT("modifyTimeStamp"),
                   &aValues,
                   &nCount,
                   Credentials,
                   dwPort,
                   L"(objectClass=subschema)"
                   );
    if (nCount==0) {

        //
        // cannot get to time stamp or get to a time stamp with no values:
        // both treat as E_FAIL
        //

        hr = E_FAIL;
    }

    BAIL_IF_ERROR(hr);

    ADsAssert( nCount == 1 );

    *ppszTimeDS = AllocADsStr( aValues[0] );
    LdapValueFree( aValues );

    if ( *ppszTimeDS == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // See if we can find the schema info in the registry
    //

    pszRegPath = (LPTSTR) AllocADsMem( (_tcslen(ADSI_LDAP_KEY) +
                                        _tcslen(pszSubSchemaSubEntry) +
                                        2 ) * sizeof(TCHAR));  // includes "\\"

    if ( pszRegPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( pszRegPath, ADSI_LDAP_KEY );
    _tcscat( pszRegPath, TEXT("\\"));
    _tcscat( pszRegPath, pszSubSchemaSubEntry );

    dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             pszRegPath,
                             0,
                             KEY_READ,
                             &hKey
                             );

    if ( dwStatus != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_IF_ERROR(hr);
    }

    //
    //  Read the time stamp of the schema in registry.
    //

    dwLength = sizeof(szTimeReg);

    dwStatus = RegQueryValueEx( hKey,
                                SCHEMA_TIME,
                                NULL,
                                &dwType,
                                (LPBYTE) szTimeReg,
                                &dwLength );

    if ( dwStatus )
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_IF_ERROR(hr);
    }
    else
    {
        *ppszTimeReg = AllocADsStr( szTimeReg );

        if ( *ppszTimeReg == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    if ( hKey )
        RegCloseKey( hKey );

    if ( pszLDAPPath != NULL )
        FreeADsStr( pszLDAPPath );

    if ( pszRegPath != NULL )
        FreeADsStr( pszRegPath );

    if ( FAILED(hr))
    {
        if ( *ppszTimeDS )
        {
            FreeADsMem( *ppszTimeDS );
            *ppszTimeDS = NULL;
        }

        if ( *ppszTimeReg )
        {
            FreeADsMem( *ppszTimeReg );
            *ppszTimeReg = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
LdapReadSchemaInfoFromServer(
    LPTSTR  pszLDAPServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  pszTimeReg,
    LPTSTR  pszTimeDS,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR;
    LPTSTR pszRegPath = NULL;
    SCHEMAINFO *pSchemaInfo = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;
    TCHAR szTimeReg[64];


    LPWSTR aStrings[4] = { L"attributeTypes",
                           L"objectClasses",
                           L"ditContentRules",
                           NULL
                         };

    LPWSTR szNTFilter = L"objectClass=*";
    LPWSTR szGenericFilter = L"objectClass=subSchema";
    BOOL fNTDS = FALSE;
    DWORD dwSecDescType = 0;

    LPTSTR *aValuesAttribTypes = NULL;
    int nCountAttribTypes = 0;
    LPTSTR *aValuesObjClasses = NULL;
    int nCountObjClasses = 0;
    LPTSTR *aValuesRules = NULL;
    int nCountRules = 0;
    LPBYTE Buffer = NULL;

    HKEY hKeySchema = NULL;
    HKEY hKey = NULL;
    DWORD dwDisposition;
    BOOL fReadFromDS = TRUE;
    BOOL fProcessAUX = FALSE;
    DWORD dwRegPathLen = 0;

    *ppSchemaInfo = NULL;

    DWORD dwRegAUXType = REG_DWORD;
    DWORD dwRegProcessAUX = 0;
    DWORD dwRegLength = sizeof(dwRegProcessAUX);

    //
    // Allocate an entry for the schema info that we are going to read
    //

#if DBG

    static BOOL fSchemaRead = FALSE;
    static BOOL fGoSchemaLess = FALSE;
    WCHAR pszRegPathDbg[MAX_PATH];
    DWORD dwType = 0;
    DWORD dwRetVal = 0;
    DWORD dwLength = 0;

    if (!fSchemaRead) {

        _tcscpy( pszRegPathDbg, ADSI_LDAP_KEY );
        _tcscat( pszRegPathDbg, TEXT("\\"));
        _tcscat( pszRegPathDbg, TEXT("DBGSchema"));
        //DebugDisabled
        // If DBG, try and read the schema key and return
        // value if that is set to 1.
        dwStatus = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       pszRegPathDbg,
                       0,
                       KEY_READ,
                       &hKeySchema
                       );

        if (dwStatus != NO_ERROR) {
            // Do not want to keep coming back to this.
            fSchemaRead = TRUE;
        } else {

            dwLength = sizeof(DWORD);
            // Read the value of the DWORD DebugDisabled
            dwStatus = RegQueryValueEx(
                           hKeySchema,
                           L"DebugDisabled",
                           0,
                           &dwType,
                           (LPBYTE) &dwRetVal,
                           &dwLength
                           );

            if (dwStatus != NO_ERROR) {
                fSchemaRead = TRUE;
            } else {
                // Look at the value and proceed
                if (dwRetVal == 0) {
                    fGoSchemaLess = TRUE;
                    hr = E_FAIL;
                }

            } // else - we were able to read the DebugDisabled key
        } // else - we were able to open the key
    } // if fSchemaRead

    if ( hKeySchema )
        RegCloseKey( hKeySchema );

    // hr will be set only if we have schema disabled.
    // Note that hr is initialised to S_OK so default case
    // will fall through
    BAIL_IF_ERROR(hr);

#endif

    pSchemaInfo = new SCHEMAINFO;
    if ( pSchemaInfo == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }
    memset(pSchemaInfo, 0, sizeof(SCHEMAINFO));

    //
    // Store the server name
    //


    if (pszLDAPServer) {
        pSchemaInfo->pszServerName = AllocADsStr( pszLDAPServer );
        if ( pSchemaInfo->pszServerName == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    //
    // Store the name of the user under whose credentials
    // we're reading the schema
    //
    hr = Credentials.GetUserName(&(pSchemaInfo->pszUserName));
    BAIL_IF_ERROR(hr);


    //
    // Store the subSchemaSubEntry path
    //

    pSchemaInfo->pszSubSchemaSubEntry = AllocADsStr( pszSubSchemaSubEntry );
    if ( pSchemaInfo->pszSubSchemaSubEntry == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // Try and see if this is NTDS or not to optimize schema calls.
    // This is very likely to be satisfied from our cache as we would
    // have already read the RootDSE at this point.
    //
    hr = ReadSecurityDescriptorControlType(
             pszLDAPServer,
             &dwSecDescType,
             Credentials,
             dwPort
             );

    if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT))
            fNTDS = TRUE;

    if ( pszTimeDS == NULL )
    {

        hr = LdapReadAttribute2(
                       pszLDAPServer,
                       NULL,
                       pszSubSchemaSubEntry,
                       TEXT("modifyTimeStamp"),
                       &aValues,
                       &nCount,
                       Credentials,
                       dwPort,
                       fNTDS ? szNTFilter : szGenericFilter
                       );

        if (FAILED(hr) || nCount==0)
        {
            //
            // cannot read modifyTimeStamp or modifyTimeStamp has no values:
            // - treat as same
            //

            hr = S_OK;
        }
        else
        {
            ADsAssert( nCount == 1 );

            pSchemaInfo->pszTime = AllocADsStr( aValues[0] );
            LdapValueFree( aValues );

            if ( pSchemaInfo->pszTime == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }
        }
    }
    else
    {
        pSchemaInfo->pszTime = AllocADsStr( pszTimeDS );

        if ( pSchemaInfo->pszTime == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    //
    // See if we can find the schema info in the registry
    //
    dwRegPathLen = _tcslen(ADSI_LDAP_KEY)
                  + _tcslen(pszSubSchemaSubEntry)
                  + (pszLDAPServer ? _tcslen(pszLDAPServer) : 0)
                  + 3; // includes "\\" and . for serverName
    
    pszRegPath = (LPTSTR) AllocADsMem( dwRegPathLen * sizeof(TCHAR));  

    if ( pszRegPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( pszRegPath, ADSI_LDAP_KEY );
    _tcscat( pszRegPath, TEXT("\\"));
    _tcscat( pszRegPath, pszSubSchemaSubEntry );
    
    //
    // If the server is not NTDS, and it has the subSchemaSubEntry cn=Schema,
    // to avoid schema key conflicts, we will add .ServerName to the key.
    //
    if (!fNTDS
        && pszSubSchemaSubEntry
        && pszLDAPServer // should alwasy be true 
        && !_tcsicmp(pszSubSchemaSubEntry, TEXT("cn=Schema"))
        ) {
        _tcscat( pszRegPath, TEXT("."));
        _tcscat( pszRegPath, pszLDAPServer);
    }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pszRegPath,
                               0,
                               TEXT(""),
                               REG_OPTION_NON_VOLATILE,  // or volatile
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hKey,
                               &dwDisposition
                               );

    if (dwStatus == NO_ERROR) {

       if (  ( dwDisposition == REG_OPENED_EXISTING_KEY )
          && ( pSchemaInfo->pszTime != NULL )
          && ( pszTimeReg == NULL )
          )
       {
           //
           //  Read the time stamp of the schema in cache and the time stamp
           //  of the schema on the server. If the time stamp on the server is
           //  newer, then we need to read the info from the server. Else
           //  the info in the cache is current and hence don't need to read
           //  it again.
           //

           DWORD dwLength = sizeof(szTimeReg);
           DWORD dwType;


           dwStatus = RegQueryValueEx( hKey,
                                       SCHEMA_TIME,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szTimeReg,
                                       &dwLength );

           if ( dwStatus )
           {
               dwStatus = NO_ERROR;
           }
           else
           {
               // Compare the two time
               if ( CompareUTCTime( szTimeReg, pSchemaInfo->pszTime ) >= 0 )
                   fReadFromDS = FALSE;
           }
       }
       else if ( ( pSchemaInfo->pszTime != NULL ) && ( pszTimeReg != NULL ))
       {
           if ( CompareUTCTime( pszTimeReg, pSchemaInfo->pszTime ) >= 0 )
               fReadFromDS = FALSE;
       }

    }else {

       fReadFromDS = TRUE;

    }

    
    if ( !fReadFromDS )
    {
        //
        // Read from registry, if we failed to read from the registry,
        // then read it from the DS.
        //

        //
        // We can av while reading bad info from a file
        // or while processing it
        //
        __try {

            dwStatus = ReadSchemaInfoFromRegistry(
                           hKey,
                           pszLDAPServer,
                           &aValuesAttribTypes,
                           &nCountAttribTypes,
                           &aValuesObjClasses,
                           &nCountObjClasses,
                           &aValuesRules,
                           &nCountRules,
                           &Buffer                                                   
                           );

            if ( dwStatus == NO_ERROR)
            {            
                //
                // At this stage we need to try and process the info
                // we got from the file. There is always a chance that
                // the read was successful but the schema data is bad
                //

                //
                // First we need to read from the registry to find whether we need to process
                // AUX class or not.
                //

                dwStatus = RegQueryValueExW( hKey,
                                       SCHEMA_PROCESSAUX,
                                       NULL,
                                       &dwRegAUXType,
                                       (LPBYTE) &dwRegProcessAUX,
                                       &dwRegLength);   
                
                if(ERROR_SUCCESS == dwStatus) {

                    fProcessAUX = (BOOL) dwRegProcessAUX;
                	                	
                    hr = ProcessSchemaInfo(
                             pSchemaInfo,
                             aValuesAttribTypes,
                             nCountAttribTypes,
                             aValuesObjClasses,
                             nCountObjClasses,
                             aValuesRules,
                             nCountRules,
                             fProcessAUX
                             );
                }
                
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

              dwStatus = GetExceptionCode();

              if (dwStatus != EXCEPTION_ACCESS_VIOLATION) {
                  ADsDebugOut((DEB_ERROR, "Processing Schema Info:Unknown Exception %d\n", dwStatus));
              }

              hr = E_FAIL;

        } // end of exception handler


        if (FAILED(hr) || dwStatus) {
            //
            // We can read the schema from the ds and upgrade our
            // local copy to get rid of the bad file
            //
            fReadFromDS = TRUE;

            //
            // Need to cleanup here so that we wont leak mem.
            //
            if ( aValuesAttribTypes ){
                FreeADsMem( aValuesAttribTypes );
                aValuesAttribTypes = NULL;
            }

            if ( aValuesObjClasses ) {
                FreeADsMem( aValuesObjClasses );
                aValuesObjClasses = NULL;
            }

            if ( aValuesRules ) {
                FreeADsMem( aValuesRules );
                aValuesRules = NULL;
            }

            if ( Buffer ) {
                FreeADsMem( Buffer );
                Buffer = NULL;
            }

            hr = E_FAIL;
            fReadFromDS = TRUE;
        }


    } // if !fReadFromDS

    if ( fReadFromDS )
    {          

        //
        // At this point, the info in the DS is newer or we have failed
        // to read the info from the registry, hence we need to read
        // from the DS and then store it in the registry.
        //

        //
        // As per the LDAP spec if the server does not know about
        // an attribute then it will ignore the attribute. So it should
        // be ok to ask for the ditContentRules even though the server
        // may not know about them.
        //
        hr = HelperReadLDAPSchemaInfo(
                 pszLDAPServer,
                 pszSubSchemaSubEntry,
                 aStrings,
                 fNTDS ? szNTFilter : szGenericFilter,
                 &aValuesAttribTypes,
                 &aValuesObjClasses,
                 &aValuesRules,
                 &nCountAttribTypes,
                 &nCountObjClasses,
                 &nCountRules,
                 Credentials,
                 dwPort);

        BAIL_IF_ERROR(hr);

        if (nCountAttribTypes == 0 || nCountObjClasses == 0) {
            BAIL_IF_ERROR(hr = E_FAIL);
        }
        

        //
        // We need to know if we need to process the aux classes
        // or not at this stage. If the server is enhanced AD (build 2220+),
        // we should not. Also if it is anything other than AD on Win2k we should
        // not as we will end up interpreting the schema incorrectly.
        // 
        BOOL fLaterThanAD, fAD;
        hr = ReadServerSupportsIsEnhancedAD(
                 pszLDAPServer,
                 &fLaterThanAD,
                 &fAD,
                 Credentials,
                 dwPort
                 );
        if (FAILED(hr)) {
            //
            // We will not process the aux classes.
            //
            fProcessAUX = FALSE;
        }

        if (fLaterThanAD) {
            fProcessAUX = FALSE;
        } 
        else if (!fLaterThanAD && fAD) {
            fProcessAUX = TRUE;
        }


        //
        // This is not expected to AV as this is info from the
        // server that is why it is not in a try except block
        //
        hr = ProcessSchemaInfo(
                 pSchemaInfo,
                 aValuesAttribTypes,
                 nCountAttribTypes,
                 aValuesObjClasses,
                 nCountObjClasses,
                 aValuesRules,
                 nCountRules,
                 fProcessAUX
                 );

        BAIL_IF_ERROR(hr);

    } // if fReadFromDS

    //
    // Store all the info in the registry only if the time stamp
    // is present and we have read just read it from the server.
    // Ignore the error since if we failed to store it, we can
    // still read it from the DS.
    //

    if ( fReadFromDS && pSchemaInfo->pszTime )
    {
        StoreSchemaInfoInRegistry( hKey,
                                   pszLDAPServer,
                                   pSchemaInfo->pszTime,
                                   aValuesAttribTypes,
                                   nCountAttribTypes,
                                   aValuesObjClasses,
                                   nCountObjClasses,
                                   aValuesRules,
                                   nCountRules,
                                   fProcessAUX);
    }

    *ppSchemaInfo = pSchemaInfo;

cleanup:

   if ( fReadFromDS )
    {
        if ( aValuesAttribTypes )
            LdapValueFree( aValuesAttribTypes );

        if ( aValuesObjClasses )
            LdapValueFree( aValuesObjClasses );

        if ( aValuesRules )
            LdapValueFree( aValuesRules );

    }
    else
    {
        if ( aValuesAttribTypes )
            FreeADsMem( aValuesAttribTypes );

        if ( aValuesObjClasses )
            FreeADsMem( aValuesObjClasses );

        if ( aValuesRules )
            FreeADsMem( aValuesRules );

        if ( Buffer )
            FreeADsMem( Buffer );
    }

    if ( hKey )
        RegCloseKey( hKey );

    if ( pszRegPath != NULL )
        FreeADsStr( pszRegPath );

    if ( FAILED(hr) && pSchemaInfo )
        delete pSchemaInfo;

    RRETURN(hr);
}


HRESULT
ProcessSchemaInfo(
    SCHEMAINFO *pSchemaInfo,
    LPTSTR *aValuesAttribTypes,
    DWORD  dwAttribCount,
    LPTSTR *aValuesObjClasses,
    DWORD  dwObjClassesCount,
    LPTSTR *aValuesRules,
    DWORD  dwRulesCount,
    BOOL fProcessAUX
)
{
    HRESULT hr = S_OK;

    hr = FillPropertyInfoArray(
             aValuesAttribTypes,
             dwAttribCount,
             &(pSchemaInfo->aProperties),
             &(pSchemaInfo->nNumOfProperties),
             &(pSchemaInfo->aPropertiesSearchTable)
             );

    BAIL_IF_ERROR(hr);

    hr = FillClassInfoArray(
             aValuesObjClasses,
             dwObjClassesCount,
             pSchemaInfo->aPropertiesSearchTable,
             pSchemaInfo->nNumOfProperties * 2,
             &(pSchemaInfo->aClasses),
             &(pSchemaInfo->nNumOfClasses),
             &(pSchemaInfo->aClassesSearchTable)
             );
    BAIL_IF_ERROR(hr);
    
    if ( aValuesRules )
    {
        hr = FillAuxClassInfoArray(
                 aValuesRules,
                 dwRulesCount,
                 pSchemaInfo->aPropertiesSearchTable,
                 pSchemaInfo->nNumOfProperties * 2,
                 pSchemaInfo->aClasses,
                 pSchemaInfo->nNumOfClasses,
                 pSchemaInfo->aClassesSearchTable
                 );
        BAIL_IF_ERROR(hr);
    }

    //
    // fProcssAUX tells us if we need to add the list of must
    // contain on each of the classes in the AUX list to the appopriate
    // classes list. Say :
    // 1.2.3.4 NAME 'OrganizationalUnit' AUX ($Class1 $CLASS2) MUST (List)
    // May (List). Then if the flag is true, we will add the Must and May
    // of class1 and class2 to the must and may of class OrganizationalUnit
    // (the must and may list is always processed - they are lists
    // of attributes).
    //
    hr = ProcessClassInfoArray(
             pSchemaInfo->aClasses,
             pSchemaInfo->nNumOfClasses,
             pSchemaInfo->aClassesSearchTable,
             fProcessAUX
             );
    BAIL_IF_ERROR(hr);

cleanup :
    //
    // Nothing to do for now
    //
    RRETURN(hr);

}


//
// Helper to read the schema information from subSchemaSubEntry
//
HRESULT
HelperReadLDAPSchemaInfo(
    LPWSTR pszLDAPServer,
    LPWSTR pszSubSchemaSubEntry,
    LPWSTR szAttributes[],
    LPWSTR pszFilter,
    LPTSTR **aValuesAttribTypes,
    LPTSTR **aValuesObjClasses,
    LPTSTR **aValuesRules,
    int *nCountAttributes,
    int *nCountObjClasses,
    int *nCountRules,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;

    hr = LdapOpenObject2(
             pszLDAPServer,
             NULL,
             pszSubSchemaSubEntry,
             &ld,
             Credentials,
             dwPort
             );

    BAIL_ON_FAILURE(hr);

    ADsAssert(ld && ld->LdapHandle);

    hr = LdapSearchS(
             ld,
             pszSubSchemaSubEntry,
             LDAP_SCOPE_BASE,
             pszFilter,
             szAttributes,
             0,
             &res
             );

    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE((hr = LdapFirstEntry(ld, res, &e)));

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[0],
             aValuesAttribTypes,
             nCountAttributes
             );
    BAIL_ON_FAILURE(hr);

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[1],
             aValuesObjClasses,
             nCountObjClasses
             );

    BAIL_ON_FAILURE(hr);

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[2],
             aValuesRules,
             nCountRules
             );

    if (FAILED(hr)) {
        //
        // This is non critical
        //
        *aValuesRules = NULL;
        nCountRules = 0;
        hr = S_OK;
    }

error:

    if (res) {
        LdapMsgFree(res);
    }

    if (ld) {
        LdapCloseObject(ld);
    }

    RRETURN(hr);
}

HRESULT
LdapReadDefaultSchema(
    LPTSTR  pszServer,
    CCredentials &Credentials,
    SCHEMAINFO **ppSchemaInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *ppSchemaInfo = NULL;

    ENTER_DEFAULTSCHEMA_CRITSECT();

    if ( g_pDefaultSchemaInfo == NULL )
    {
        g_pDefaultSchemaInfo = new SCHEMAINFO;
        if ( g_pDefaultSchemaInfo == NULL )
        {
            LEAVE_DEFAULTSCHEMA_CRITSECT();
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        hr = FillPropertyInfoArray( g_aDefaultAttributeTypes,
                                    g_cDefaultAttributeTypes,
                                    &(g_pDefaultSchemaInfo->aProperties),
                                    &(g_pDefaultSchemaInfo->nNumOfProperties),
                                    &(g_pDefaultSchemaInfo->aPropertiesSearchTable));

        //
        // Now read the object classes from the schema
        //

        if ( SUCCEEDED(hr))
        {

            hr = FillClassInfoArray( g_aDefaultObjectClasses,
                                     g_cDefaultObjectClasses,
                                     g_pDefaultSchemaInfo->aPropertiesSearchTable,
                                     g_pDefaultSchemaInfo->nNumOfProperties * 2,
                                     &(g_pDefaultSchemaInfo->aClasses),
                                     &(g_pDefaultSchemaInfo->nNumOfClasses),
                                     &(g_pDefaultSchemaInfo->aClassesSearchTable));

            if ( SUCCEEDED(hr))
            {
                hr = ProcessClassInfoArray( g_pDefaultSchemaInfo->aClasses,
                                            g_pDefaultSchemaInfo->nNumOfClasses,
                                            g_pDefaultSchemaInfo->aClassesSearchTable );
            }
        }

        if (FAILED(hr))
        {
            delete g_pDefaultSchemaInfo;
            g_pDefaultSchemaInfo = NULL;
            LEAVE_DEFAULTSCHEMA_CRITSECT();
        }        

        BAIL_IF_ERROR(hr);
    }

    LEAVE_DEFAULTSCHEMA_CRITSECT();

    //
    // Allocate an entry for the schema info
    //

    pSchemaInfo = new SCHEMAINFO;
    if ( pSchemaInfo == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // Store the server name
    //

    if (pszServer) {

        pSchemaInfo->pszServerName = AllocADsStr( pszServer );
        if ( pSchemaInfo->pszServerName == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

    }

    //
    // Store the name of the user under whose credentials
    // we're reading the schema
    //
    hr = Credentials.GetUserName(&(pSchemaInfo->pszUserName));
    BAIL_IF_ERROR(hr);


    pSchemaInfo->aClasses = g_pDefaultSchemaInfo->aClasses;
    pSchemaInfo->nNumOfClasses = g_pDefaultSchemaInfo->nNumOfClasses;
    pSchemaInfo->aClassesSearchTable = g_pDefaultSchemaInfo->aClassesSearchTable;
    pSchemaInfo->aProperties = g_pDefaultSchemaInfo->aProperties;
    pSchemaInfo->nNumOfProperties = g_pDefaultSchemaInfo->nNumOfProperties;
    pSchemaInfo->aPropertiesSearchTable = g_pDefaultSchemaInfo->aPropertiesSearchTable;
    pSchemaInfo->fDefaultSchema = TRUE;

    *ppSchemaInfo = pSchemaInfo;

cleanup:

    if ( FAILED(hr) && pSchemaInfo )
        delete pSchemaInfo;

    RRETURN(hr);
}

HRESULT FillPropertyInfoArray(
    LPTSTR *aAttrTypes,
    DWORD  dwCount,
    PROPERTYINFO **paProperties,
    DWORD *pnProperties,
    SEARCHENTRY **paPropertiesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    PROPERTYINFO * pPropArray = NULL;
    PROPERTYINFO * pNewPropArray = NULL;
    LPWSTR *ppszNewNames = NULL;
    DWORD dwNewNameCount = 0;
    DWORD dwDisplacement = 0;
    BOOL fFreeNames = TRUE;

    *paProperties = NULL;
    *pnProperties = 0;
    *paPropertiesSearchTable = NULL;

    if ( dwCount == 0 )
        RRETURN(S_OK);

    pPropArray = (PROPERTYINFO *)AllocADsMem( sizeof(PROPERTYINFO) * dwCount);
    if (!pPropArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++) {

        fFreeNames = FREE_ALL_BUT_FIRST;
        dwNewNameCount = 0;

        pPropArray[i].dwUsage = ATTR_USAGE_USERAPPLICATIONS;
        
        hr = AttributeTypeDescription(
                 aAttrTypes[i],
                 pPropArray + (i+dwDisplacement),
                 &ppszNewNames,
                 &dwNewNameCount
                 );

        BAIL_ON_FAILURE(hr);

        if (ppszNewNames) {

            if (dwNewNameCount > 1) {
                hr = AddNewNamesToPropertyArray(
                         &pPropArray,
                         i + dwDisplacement, // current position in array
                         dwCount + dwDisplacement, // total number already in array
                         ppszNewNames, // array of names.
                         dwNewNameCount // number of names
                         );

                //
                // In the failure case, we can still continue, just
                // that the additional names will not be recognized.
                //
                if (SUCCEEDED(hr)) {
                    //
                    // In this case the new array has the data needed.
                    // The count is updated suitably only on success.
                    // 
                    fFreeNames = FALSE;
                    dwDisplacement += (dwNewNameCount - 1);
                }
            }
            
            FreeDirectoryStrings(
                ppszNewNames,
                dwNewNameCount,
                fFreeNames ?
                    FREE_ALL_BUT_FIRST : FREE_ARRAY_NOT_ELEMENTS
                );
            
            ppszNewNames = NULL; // freed in the above call.

        }
    }

    //
    // Reduce i by one in case we fail and call FreePropertyInfoArray below.
    //
    i--;
    dwCount += dwDisplacement;
    hr = ProcessPropertyInfoArray(pPropArray, dwCount, paPropertiesSearchTable);
    BAIL_ON_FAILURE(hr);

    *paProperties = pPropArray;
    *pnProperties = dwCount;

    RRETURN(S_OK);

error:

    FreePropertyInfoArray( pPropArray, i + 1);

    //
    // Need to free the new names list if it is valid.
    //
    if (ppszNewNames) {
        //
        // This function frees pszNames too.
        //
        FreeDirectoryStrings(
            ppszNewNames,
            dwNewNameCount,
            FREE_ALL_BUT_FIRST // do not free first element
            );
    }

    RRETURN(hr);
}

HRESULT
GetInfoFromSuperiorProperty(
    PROPERTYINFO *pPropertyInfo,
    PROPERTYINFO *pPropertyInfoSuperior
)
{
    HRESULT hr = S_OK;

    if ( pPropertyInfo->pszSyntax == NULL )
    {
        pPropertyInfo->pszSyntax =
            AllocADsStr( pPropertyInfoSuperior->pszSyntax );

        if ( pPropertyInfo->pszSyntax == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

#if 0
    if (  pPropertyInfo->lMaxRange == 0
       && pPropertyInfo->lMinRange == 0
       )
    {
        pPropertyInfo->lMaxRange = pPropertyInfoSuperior->lMaxRange;
        pPropertyInfo->lMinRange = pPropertyInfoSuperior->lMinRange;
    }
#endif

    if (  pPropertyInfoSuperior->fSingleValued
       && !pPropertyInfo->fSingleValued
       )
    {
        pPropertyInfo->fSingleValued = pPropertyInfoSuperior->fSingleValued;
    }

    if (  pPropertyInfo->pszOIDEquality == NULL
       && pPropertyInfoSuperior->pszOIDEquality != NULL
       )
    {
        pPropertyInfo->pszOIDEquality =
            AllocADsStr( pPropertyInfoSuperior->pszOIDEquality );

        if ( pPropertyInfo->pszOIDEquality == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    if (  pPropertyInfo->pszOIDOrdering == NULL
       && pPropertyInfoSuperior->pszOIDOrdering != NULL
       )
    {
        pPropertyInfo->pszOIDOrdering =
            AllocADsStr( pPropertyInfoSuperior->pszOIDOrdering );

        if ( pPropertyInfo->pszOIDOrdering == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    if (  pPropertyInfo->pszOIDSubstr == NULL
       && pPropertyInfoSuperior->pszOIDSubstr != NULL
       )
    {
        pPropertyInfo->pszOIDSubstr =
            AllocADsStr( pPropertyInfoSuperior->pszOIDSubstr );

        if ( pPropertyInfo->pszOIDSubstr == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    RRETURN(hr);

}

HRESULT ProcessPropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD nProperties,
    SEARCHENTRY **paPropertiesSearchTable
)
{
    HRESULT hr = S_OK;
    SEARCHENTRY *aSearchTable = NULL;
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry;
    DWORD i;
    BOOL  fProcessedAll = TRUE;
    DWORD nLoop = 0;

    *paPropertiesSearchTable = NULL;

    //
    // First, build a binary search table for faster lookup
    //

    aSearchTable = (SEARCHENTRY *) AllocADsMem(
                        sizeof(SEARCHENTRY) * nProperties * 2);

    if (!aSearchTable) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < nProperties; i++ )
    {
        // OIDs can be specified in 2.5.6.0 format or name.
        // So, we need both entries in the search table.

        //
        // Special case to handle no names or OID's
        //
        if (aProperties[i].pszPropertyName == NULL) {
            aProperties[i].pszPropertyName = AllocADsStr(aProperties[i].pszOID);
        }

        if (aProperties[i].pszOID == NULL) {
            aProperties[i].pszOID = AllocADsStr(aProperties[i].pszPropertyName);
        }

        aSearchTable[2*i].pszName = aProperties[i].pszPropertyName;
        aSearchTable[2*i].nIndex = i;
        aSearchTable[2*i+1].pszName = aProperties[i].pszOID;
        aSearchTable[2*i+1].nIndex = i;
    }

    //
    // Sort the table
    //
    qsort( aSearchTable, 2*nProperties, sizeof(SEARCHENTRY), searchentrycmp );


    do {

        fProcessedAll = TRUE;

        for ( DWORD i = 0; i < nProperties; i++ )
        {
            LPTSTR pszOIDSup = NULL;

            if ( aProperties[i].fProcessedSuperiorClass )
                continue;

            pszOIDSup = aProperties[i].pszOIDSup;

            if ( pszOIDSup == NULL )
            {
                aProperties[i].fProcessedSuperiorClass = TRUE;
                continue;
            }

            searchEntry.pszName = pszOIDSup;
            matchedEntry = (SEARCHENTRY *) bsearch(
                                (SEARCHENTRY *) &searchEntry,
                                aSearchTable, 2*nProperties,
                                sizeof(SEARCHENTRY), searchentrycmp );

            if ( matchedEntry )  // found the superior class
            {
                if (!aProperties[matchedEntry->nIndex].fProcessedSuperiorClass)
                {
                    fProcessedAll = FALSE;
                    continue;
                }

                hr = GetInfoFromSuperiorProperty(
                         &(aProperties[i]), &(aProperties[matchedEntry->nIndex]));
                BAIL_ON_FAILURE(hr);
            }

            aProperties[i].fProcessedSuperiorClass = TRUE;
        }

        nLoop++;

    } while ( (nLoop < MAX_LOOP_COUNT) && !fProcessedAll );

    *paPropertiesSearchTable = aSearchTable;
    RRETURN(S_OK);

error:

    if ( aSearchTable )
        FreeADsMem( aSearchTable );

    RRETURN(hr);
}

VOID FreePropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD  nProperties
)
{
    if ( aProperties )
    {
        DWORD j;

        for ( j = 0; j < nProperties; j++ )
        {
            FreeADsStr( aProperties[j].pszPropertyName );
            FreeADsStr( aProperties[j].pszOID );
            FreeADsStr( aProperties[j].pszSyntax );
            FreeADsStr( aProperties[j].pszDescription );
            FreeADsStr( aProperties[j].pszOIDSup );
            FreeADsStr( aProperties[j].pszOIDEquality );
            FreeADsStr( aProperties[j].pszOIDOrdering );
            FreeADsStr( aProperties[j].pszOIDSubstr );
        }

        FreeADsMem( aProperties );
    }
}

HRESULT FillClassInfoArray(
    LPTSTR *aObjectClasses,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO **paClasses,
    DWORD *pnClasses,
    SEARCHENTRY **paClassesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    CLASSINFO * pClassArray = NULL;
    SEARCHENTRY *aSearchTable = NULL;
    LPWSTR *ppszNewNames = NULL;
    DWORD dwNewNameCount = 0;
    DWORD dwDisplacement = 0;
    BOOL fFreeNames = FALSE;

    *paClasses= NULL;
    *pnClasses= 0;
    *paClassesSearchTable = NULL;

    if ( dwCount == 0 )
        RRETURN(S_OK);

    pClassArray = (CLASSINFO *)AllocADsMem( sizeof(CLASSINFO) * dwCount );
    if (!pClassArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++) {

        ppszNewNames = NULL;
        dwNewNameCount = 0;
        fFreeNames = TRUE;

        pClassArray[i].IsContainer = -1;
        pClassArray[i].dwType = CLASS_TYPE_STRUCTURAL;
        
        hr = ObjectClassDescription(
                 aObjectClasses[i],
                 pClassArray + (i + dwDisplacement),
                 aPropSearchTable,
                 dwSearchTableCount,
                 &ppszNewNames,
                 &dwNewNameCount
                 );

        BAIL_ON_FAILURE(hr);

        if (ppszNewNames) {

            if (dwNewNameCount > 1) {
                //
                // ********************** IMPORTANT NOTE ************
                // In this routine, we specifically do not duplicate
                // the pCLSID and pPrimaryInterfaceGUID as these are not
                // freed when we exit and do not appear to be used anywehre.
                // If ObjectClasDescription is changed to add this info,
                // then the fn below needs to be update accordingly.
                // **************************************************
                //
                hr = AddNewNamesToClassArray(
                        &pClassArray,
                        i + dwDisplacement, // current position in array
                        dwCount + dwDisplacement, // total number already in array
                        ppszNewNames, // array of names.
                        dwNewNameCount // number of names
                        );

                //
                // In the failure case, we can still continue, just
                // that the additional names will not be recognized.
                //
                if (SUCCEEDED(hr)) {
                    //
                    // In this case the new array has the data needed.
                    // The count is updated suitably only on success.
                    // 
                    fFreeNames = FALSE;
                    dwDisplacement += (dwNewNameCount - 1);
                }
            }

            FreeDirectoryStrings(
                ppszNewNames,
                dwNewNameCount,
                fFreeNames ?
                    FREE_ALL_BUT_FIRST : FREE_ARRAY_NOT_ELEMENTS
                );

            ppszNewNames = NULL; // freed in the above call.

        } // if newNames is valid.

    } // for 

    //
    // Count should now include the new elements added.
    //
    dwCount += dwDisplacement;
    //
    // Build a binary search table for faster lookup
    //

    aSearchTable = (SEARCHENTRY *) AllocADsMem(
                                 sizeof(SEARCHENTRY) * dwCount * 2);

    if (!aSearchTable) {
        hr = E_OUTOFMEMORY;
        //
        // i is now dwCount but should be one less as
        // the free call is made with i+1
        //
        i--;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++ )
    {

        //
        // Take care of the NULL name/OID in case of some servers
        //
        if (pClassArray[i].pszName == NULL) {
            pClassArray[i].pszName = AllocADsStr(pClassArray[i].pszOID);
        }

        if (pClassArray[i].pszOID == NULL) {
            pClassArray[i].pszOID = AllocADsStr(pClassArray[i].pszName);
        }

        // OIDs can be specified in 2.5.6.0 format or name.
        // So, we need both entries in the search table.

        aSearchTable[2*i].pszName = pClassArray[i].pszName;
        aSearchTable[2*i].nIndex = i;
        aSearchTable[2*i+1].pszName = pClassArray[i].pszOID;
        aSearchTable[2*i+1].nIndex = i;
    }

    //
    // Sort the table
    //
    qsort( aSearchTable, 2*dwCount, sizeof(SEARCHENTRY), searchentrycmp );

    *paClasses = pClassArray;
    *pnClasses = dwCount;
    *paClassesSearchTable = aSearchTable;

    RRETURN(S_OK);

error:

    FreeClassInfoArray( pClassArray, i + 1 );

    if ( aSearchTable )
        FreeADsMem( aSearchTable );

    if (ppszNewNames) {
        FreeDirectoryStrings(
            ppszNewNames,
            dwNewNameCount,
            FREE_ALL_BUT_FIRST // first taken care of above.
            );
    }

    RRETURN(hr);
}

HRESULT FillAuxClassInfoArray(
    LPTSTR *aDITContentRules,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aClassesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    CLASSINFO ClassInfo;
    int index;


    if ( dwCount == 0 )
        RRETURN(S_OK);

    for ( i = 0; i < dwCount; i++) {

        memset( &ClassInfo, 0, sizeof(ClassInfo));

        hr = DITContentRuleDescription( aDITContentRules[i], &ClassInfo,
                                        aPropSearchTable, dwSearchTableCount );

        BAIL_ON_FAILURE(hr);

        index = FindEntryInSearchTable( ClassInfo.pszOID,
                                        aClassesSearchTable,
                                        nClasses * 2 );

        if ( index == -1 )
            continue;  // Cannot find the class, ignore and continue


        aClasses[index].pOIDsNotContain = ClassInfo.pOIDsNotContain;
        aClasses[index].nNumOfNotContain = ClassInfo.nNumOfNotContain;

        aClasses[index].pOIDsAuxClasses = ClassInfo.pOIDsAuxClasses;

        if ( ClassInfo.pOIDsMustContain )
        {
            DWORD nMustContain = aClasses[index].nNumOfMustContain;
            
            if ( nMustContain == 0 )
            {
                aClasses[index].pOIDsMustContain = ClassInfo.pOIDsMustContain;
                aClasses[index].nNumOfMustContain = ClassInfo.nNumOfMustContain;
            }
            else
            {
                aClasses[index].pOIDsMustContain =
                     (int *) ReallocADsMem( aClasses[index].pOIDsMustContain,
                                 sizeof(int) * nMustContain,
                                 sizeof(int) * ( nMustContain +
                                             ClassInfo.nNumOfMustContain + 1));

                if ( aClasses[index].pOIDsMustContain == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                memcpy( &(aClasses[index].pOIDsMustContain[nMustContain]),
                        ClassInfo.pOIDsMustContain,
                        ClassInfo.nNumOfMustContain * sizeof(int));

                aClasses[index].nNumOfMustContain += ClassInfo.nNumOfMustContain;
                //
                // Need to terminate with -1.
                //
                aClasses[index].pOIDsMustContain[nMustContain+ClassInfo.nNumOfMustContain] = -1;

                FreeADsMem( ClassInfo.pOIDsMustContain );
                ClassInfo.pOIDsMustContain = NULL;                
            }     
        }

        if ( ClassInfo.pOIDsMayContain )
        {
            DWORD nMayContain = aClasses[index].nNumOfMayContain;

            if ( nMayContain == 0 )
            {
                aClasses[index].pOIDsMayContain = ClassInfo.pOIDsMayContain;
                aClasses[index].nNumOfMayContain = ClassInfo.nNumOfMayContain;
            }
            else
            {
                aClasses[index].pOIDsMayContain =
                     (int *) ReallocADsMem( aClasses[index].pOIDsMayContain,
                                 sizeof(int) * nMayContain,
                                 sizeof(int) * ( nMayContain +
                                             ClassInfo.nNumOfMayContain + 1));

                if ( aClasses[index].pOIDsMayContain == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                memcpy( &(aClasses[index].pOIDsMayContain[nMayContain]),
                        ClassInfo.pOIDsMayContain,
                        ClassInfo.nNumOfMayContain * sizeof(int));

                aClasses[index].nNumOfMayContain += ClassInfo.nNumOfMayContain;

                //
                // Need to terminate with -1.
                //
                aClasses[index].pOIDsMayContain[nMayContain+ClassInfo.nNumOfMayContain] = -1;

                FreeADsMem( ClassInfo.pOIDsMayContain );
                ClassInfo.pOIDsMayContain = NULL;
            }
            
        }

        FreeADsStr( ClassInfo.pszOID );
        ClassInfo.pszOID = NULL;

        FreeADsStr( ClassInfo.pszName );
        FreeADsStr( ClassInfo.pszDescription );
    }

    RRETURN(S_OK);

error:

    if ( ClassInfo.pszOID )
    {
        FreeADsStr( ClassInfo.pszOID );
        FreeADsStr( ClassInfo.pszName );
        FreeADsStr( ClassInfo.pszDescription );

        if ( ClassInfo.pOIDsMustContain )
        {
            FreeADsMem( ClassInfo.pOIDsMustContain );
        }

        if ( ClassInfo.pOIDsMayContain )
        {
            FreeADsMem( ClassInfo.pOIDsMayContain );
        }
    }

    RRETURN(hr);
}


HRESULT
GetInfoFromSuperiorClasses(
    CLASSINFO *pClassInfo,
    CLASSINFO *pClassInfoSuperior
)
{
    HRESULT hr = S_OK;
    DWORD i;


    int *pOIDsMustSup = pClassInfoSuperior->pOIDsMustContain;
    int *pOIDsMaySup = pClassInfoSuperior->pOIDsMayContain;
    DWORD nCountMustSup = pClassInfoSuperior->nNumOfMustContain;
    DWORD nCountMaySup = pClassInfoSuperior->nNumOfMayContain;

    int *pOIDsMust = pClassInfo->pOIDsMustContain;
    int *pOIDsMay = pClassInfo->pOIDsMayContain;
    DWORD nCountMust = pClassInfo->nNumOfMustContain;
    DWORD nCountMay = pClassInfo->nNumOfMayContain;

    int *pOIDsMustNew = NULL;
    int *pOIDsMayNew = NULL;

    if ( pOIDsMaySup == NULL && pOIDsMustSup == NULL )
        RRETURN(S_OK);

    if ( nCountMustSup > 0 )
    {
        pOIDsMustNew = (int *) AllocADsMem(
                            sizeof(int) * (nCountMust + nCountMustSup + 1));

        if ( pOIDsMustNew == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        for ( i = 0; i < nCountMustSup; i++ )
        {
            pOIDsMustNew[i] = pOIDsMustSup[i];
        }

        for ( i = 0; i < nCountMust; i++ )
        {
            pOIDsMustNew[i+nCountMustSup] = pOIDsMust[i];
        }

        pOIDsMustNew[nCountMustSup+nCountMust] = -1;

        pClassInfo->pOIDsMustContain = pOIDsMustNew;
        pClassInfo->nNumOfMustContain = nCountMust + nCountMustSup;
        if ( pOIDsMust )
            FreeADsMem( pOIDsMust );

        pOIDsMustNew = NULL;
    }

    if ( nCountMaySup > 0 )
    {
        pOIDsMayNew = (int *) AllocADsMem(
                            sizeof(int) * ( nCountMay + nCountMaySup + 1 ));

        if ( pOIDsMayNew == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        for ( i = 0; i < nCountMaySup; i++ )
        {
            pOIDsMayNew[i] = pOIDsMaySup[i];
        }

        for ( i = 0; i < nCountMay; i++ )
        {
            pOIDsMayNew[i+nCountMaySup] = pOIDsMay[i];
        }

        pOIDsMayNew[nCountMaySup+nCountMay] = -1;

        pClassInfo->pOIDsMayContain = pOIDsMayNew;
        pClassInfo->nNumOfMayContain = nCountMay + nCountMaySup;
        if ( pOIDsMay )
            FreeADsMem( pOIDsMay );

        pOIDsMayNew = NULL;
    }

cleanup:

    if (FAILED(hr))
    {
        if ( pOIDsMustNew )
            FreeADsMem( pOIDsMustNew );

        if ( pOIDsMayNew )
            FreeADsMem( pOIDsMayNew );
    }

    RRETURN(hr);

}


HRESULT ProcessClassInfoArray(
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aSearchTable,
    BOOL fProcessAUX // defaulted to false
)
{
    HRESULT hr = S_OK;
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry;
    DWORD i;
    BOOL fProcessedAll = TRUE;
    DWORD nLoop = 0;

    do
    {
        fProcessedAll = TRUE;

        for ( DWORD i = 0; i < nClasses; i++ )
        {
            LPTSTR *pOIDsSup = NULL;
            LPTSTR *pOIDsAux = NULL;
            DWORD j = 0;

            if ( aClasses[i].fProcessedSuperiorClasses )
                continue;

            pOIDsSup = aClasses[i].pOIDsSuperiorClasses;
            //
            // If fProcessAUX then we ne need to add the aux
            // class lists must and may to the classes own list.
            // Please look at where this flag is being set for
            // more details.
            //
            if (fProcessAUX) {
                pOIDsAux = aClasses[i].pOIDsAuxClasses;
            } 
            else {
                pOIDsAux = NULL;
            }

            if ( pOIDsSup == NULL )
            {
                aClasses[i].fProcessedSuperiorClasses = TRUE;
                continue;
            }

            // This is here just in case the schema description for class "top"
            // has other superior classes. "top" should not have any superior
            // classes.

            if ( _tcsicmp( aClasses[i].pszName, TEXT("top")) == 0 )
            {
                aClasses[i].fProcessedSuperiorClasses = TRUE;
                continue;
            }

            j = 0;
            while ( pOIDsSup[j] )
            {
                searchEntry.pszName = pOIDsSup[j];
                matchedEntry = (SEARCHENTRY *) bsearch(
                                    (SEARCHENTRY *) &searchEntry,
                                    aSearchTable, 2*nClasses,
                                    sizeof(SEARCHENTRY), searchentrycmp );

                if ( matchedEntry )  // found the superior class
                {
                    if (!aClasses[matchedEntry->nIndex].fProcessedSuperiorClasses)
                    {
                        fProcessedAll = FALSE;
                        break;
                    }

                    hr = GetInfoFromSuperiorClasses(
                             &(aClasses[i]), &(aClasses[matchedEntry->nIndex]));
                    BAIL_ON_FAILURE(hr);
                }

                j++;
            }

            if ( pOIDsSup[j] == NULL )
            {
                if ( pOIDsAux == NULL )
                {
                    aClasses[i].fProcessedSuperiorClasses = TRUE;
                }
                else
                {
                    j = 0;
                    while ( pOIDsAux[j] )
                    {
                        searchEntry.pszName = pOIDsAux[j];
                        matchedEntry = (SEARCHENTRY *) bsearch(
                                           (SEARCHENTRY *) &searchEntry,
                                           aSearchTable, 2*nClasses,
                                           sizeof(SEARCHENTRY), searchentrycmp);

                        if ( matchedEntry )  // found the superior class
                        {
                            if (!aClasses[matchedEntry->nIndex].fProcessedSuperiorClasses)
                            {
                                fProcessedAll = FALSE;
                                break;
                            }

                            hr = GetInfoFromSuperiorClasses(
                                     &(aClasses[i]),
                                     &(aClasses[matchedEntry->nIndex]));
                            BAIL_ON_FAILURE(hr);
                        }

                        j++;
                    }

                    if ( pOIDsAux[j] == NULL )
                        aClasses[i].fProcessedSuperiorClasses = TRUE;
                }
            }
        }

        nLoop++;

    } while ( (nLoop < MAX_LOOP_COUNT) && !fProcessedAll );

    for ( i = 0; i < nClasses; i++ )
    {
        CLASSINFO *pClass = &(aClasses[i]);
        DWORD j, k;

        //
        // Eliminate duplicates in MustContain
        //

        if ( pClass->pOIDsMustContain != NULL )
        {
            SortAndRemoveDuplicateOIDs( pClass->pOIDsMustContain,
                                        &pClass->nNumOfMustContain );
        }

        //
        // Eliminate duplicates in MayContain
        //

        if ( pClass->pOIDsMayContain != NULL )
        {
            SortAndRemoveDuplicateOIDs( pClass->pOIDsMayContain,
                                        &pClass->nNumOfMayContain );
        }

        //
        // Eliminate duplicates between MustContain and MayContain
        //
        if (  ( pClass->pOIDsMustContain == NULL )
           || ( pClass->pOIDsMayContain == NULL )
           )
        {
            continue;
        }

        j = 0; k = 0;
        while (  ( pClass->pOIDsMustContain[j] != -1 )
              && ( pClass->pOIDsMayContain[k] != -1 )
              )
        {
            int nMust = pClass->pOIDsMustContain[j];
            int nMay = pClass->pOIDsMayContain[k];

            if ( nMust < nMay )
            {
                j++;
            }
            else if ( nMust > nMay )
            {
                k++;
            }
            else  // nMust == nMay
            {
                j++;

                DWORD m = k;

                do {
                    pClass->pOIDsMayContain[m] = pClass->pOIDsMayContain[m+1];
                    m++;
                } while ( pClass->pOIDsMayContain[m] != -1 );
            }
        }

        //
        // Removes the NotContain from the MustContain or MayContain list
        //

        if ( pClass->pOIDsNotContain != NULL )
        {
            qsort( pClass->pOIDsNotContain, pClass->nNumOfNotContain,
                   sizeof(pClass->pOIDsNotContain[0]), intcmp );

            j = 0; k = 0;
            while (  ( pClass->pOIDsMustContain[j] != -1 )
                  && ( pClass->pOIDsNotContain[k] != -1 )
                  )
            {
                int nMust = pClass->pOIDsMustContain[j];
                int nNot = pClass->pOIDsNotContain[k];

                if ( nMust < nNot )
                {
                    j++;
                }
                else if ( nMust > nNot )
                {
                    k++;
                }
                else  // nMust == nNot
                {
                    k++;

                    DWORD m = j;

                    do {
                        pClass->pOIDsMustContain[m] = pClass->pOIDsMustContain[m+1];
                        m++;
                    } while ( pClass->pOIDsMustContain[m] != -1 );
                }
            }

            j = 0; k = 0;
            while (  ( pClass->pOIDsMayContain[j] != -1 )
                  && ( pClass->pOIDsNotContain[k] != -1 )
                  )
            {
                int nMay = pClass->pOIDsMayContain[j];
                int nNot = pClass->pOIDsNotContain[k];

                if ( nMay < nNot )
                {
                    j++;
                }
                else if ( nMay > nNot )
                {
                    k++;
                }
                else  // nMay == nNot
                {
                    k++;

                    DWORD m = j;

                    do {
                        pClass->pOIDsMayContain[m] = pClass->pOIDsMayContain[m+1];
                        m++;
                    } while ( pClass->pOIDsMayContain[m] != -1 );
                }
            }

            FreeADsMem( pClass->pOIDsNotContain );
            pClass->pOIDsNotContain = NULL;
        }
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

VOID SortAndRemoveDuplicateOIDs(
    int *aOIDs,
    DWORD *pnNumOfOIDs
)
{
    DWORD j, k;

    qsort( aOIDs, *pnNumOfOIDs, sizeof( aOIDs[0]), intcmp );

    // The following code removes duplicate strings in place.
    // index j is the index to walk the array, and index k is the
    // index of the last non-duplicate entry. The array is sorted
    // and so we compare the string at index j and index k.
    // (1) If they are the same, then j++
    // (2) If not the same, increment k, free the string at k and
    //     make k point to the string at j. Then increment j and
    //     continue.
    //
    // NOTE: aOIDs must be an array of integers that ends with -1.


    j = 1; k = 0;
    while ( aOIDs[j] != -1 )
    {
        while ( aOIDs[j] == aOIDs[k] )
        {
            j++;
            if ( aOIDs[j] == -1 )
                break;
        }

        if ( aOIDs[j] != -1 )
        {
            k++;

            if ( k != j )
            {
                aOIDs[k] = aOIDs[j];
                aOIDs[j] = -1;
            }
            j++;
        }
    }

    k++;
    aOIDs[k] = -1;
    *pnNumOfOIDs = k;
}

VOID FreeClassInfoArray(
    CLASSINFO *aClasses,
    DWORD  nClasses
)
{
    if ( aClasses )
    {
        DWORD j;
        for ( j = 0; j < nClasses; j++ )
        {
            FreeADsStr( aClasses[j].pszName );
            FreeADsStr( aClasses[j].pszOID );
            FreeADsStr( aClasses[j].pszHelpFileName );
            FreeADsStr( aClasses[j].pszDescription );

            DWORD k = 0;
            if ( aClasses[j].pOIDsSuperiorClasses )
            {
                while ( aClasses[j].pOIDsSuperiorClasses[k] )
                    FreeADsStr( aClasses[j].pOIDsSuperiorClasses[k++]);
                FreeADsMem( aClasses[j].pOIDsSuperiorClasses );
            }

            k = 0;
            if ( aClasses[j].pOIDsAuxClasses )
            {
                while ( aClasses[j].pOIDsAuxClasses[k] )
                    FreeADsStr( aClasses[j].pOIDsAuxClasses[k++]);
                FreeADsMem( aClasses[j].pOIDsAuxClasses );
            }

            if ( aClasses[j].pOIDsMustContain )
            {
                FreeADsMem( aClasses[j].pOIDsMustContain );
            }

            if ( aClasses[j].pOIDsMayContain )
            {
                FreeADsMem( aClasses[j].pOIDsMayContain );
            }

            if ( aClasses[j].pOIDsNotContain )
            {
                FreeADsMem( aClasses[j].pOIDsNotContain );
            }
        }

        FreeADsMem( aClasses );
    }
}



DWORD ReadSchemaInfoFromFileWithHandle(
    HANDLE hFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    DWORD dwFileSize = 0;
    DWORD dwBytesRead = 0;
    LPTSTR pLine = NULL;
    LPTSTR pEndOfLine = NULL;
    DWORD nCount;
    DWORD nType;
    DWORD dwStatus = NO_ERROR;
    //
    // Even though the calling routine has an exception handler,
    // we need one over here also as this we need to close the file
    // over here, we do not have the file handle in the calling routine.
    //
    __try {

        dwFileSize = GetFileSize( hFile, NULL );

        if ( dwFileSize == -1 )
        {
            err = GetLastError();
            goto cleanup;
        }
        else if ( dwFileSize == 0 )
        {
            err = ERROR_FILE_INVALID;
            goto cleanup;
        }

        *pFileBuffer = (LPBYTE) AllocADsMem( dwFileSize );
        if ( *pFileBuffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        if ( !ReadFile( hFile,
                        *pFileBuffer,
                        dwFileSize,
                        &dwBytesRead,
                        NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }


        for ( pLine = ((LPTSTR) *pFileBuffer) + 1;  // go past Unicode BOM marker
             pLine < (LPTSTR) ( *pFileBuffer + dwFileSize );
             pLine = pEndOfLine + 1 )
        {
            if ( pEndOfLine = _tcschr( pLine, TEXT('\n')))
                *pEndOfLine = 0;

            if ( _tcsicmp( pLine, TEXT("[attributeTypes]")) == 0 )
            {
                nType = ID_ATTRTYPES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[objectClasses]")) == 0 )
            {
                nType = ID_OBJCLASSES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[DITContentRules]")) == 0 )
            {
                nType = ID_DITCONTENTRULES;
                continue;
            }

            switch ( nType )
            {
                case ID_ATTRTYPES:
                    (*pnCountAttrTypes)++;
                    break;

                case ID_OBJCLASSES:
                    (*pnCountObjClasses)++;
                    break;

                case ID_DITCONTENTRULES:
                    (*pnCountRules)++;
                    break;
            }
        }

        *paValuesAttrTypes = (LPTSTR *) AllocADsMem( *pnCountAttrTypes * sizeof(LPTSTR));
        if ( *paValuesAttrTypes == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        *paValuesObjClasses = (LPTSTR *) AllocADsMem( *pnCountObjClasses * sizeof(LPTSTR));
        if ( *paValuesObjClasses == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        *paValuesRules = (LPTSTR *) AllocADsMem( *pnCountRules * sizeof(LPTSTR));
        if ( *paValuesRules == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        for ( pLine = ((LPTSTR) *pFileBuffer) + 1;// go past Unicode BOM marker
             pLine < (LPTSTR) ( *pFileBuffer + dwFileSize );
             pLine += ( _tcslen(pLine) + 1) )
        {
            if ( _tcsicmp( pLine, TEXT("[attributeTypes]")) == 0 )
            {
                nCount = 0;
                nType = ID_ATTRTYPES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[objectClasses]")) == 0 )
            {
                nCount = 0;
                nType = ID_OBJCLASSES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[DITContentRules]")) == 0 )
            {
                nCount = 0;
                nType = ID_DITCONTENTRULES;
                continue;
            }

            switch ( nType )
            {
                case ID_ATTRTYPES:
                    (*paValuesAttrTypes)[nCount++] = pLine;
                    break;

                case ID_OBJCLASSES:
                    (*paValuesObjClasses)[nCount++] = pLine;
                    break;

                case ID_DITCONTENTRULES:
                    (*paValuesRules)[nCount++] = pLine;
                    break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

          err = GetExceptionCode();

          if (dwStatus != EXCEPTION_ACCESS_VIOLATION) {
              ADsDebugOut((DEB_ERROR, "Processing Schema Info:Unknown Exception %d\n", err));

          }
    }

cleanup:

    CloseHandle( hFile );

    if ( err )
    {
        *pnCountAttrTypes = 0;
        *pnCountObjClasses = 0;
        *pnCountRules = 0;

        if ( *paValuesAttrTypes )
            FreeADsMem( *paValuesAttrTypes );

        if ( *paValuesObjClasses )
            FreeADsMem( *paValuesObjClasses );

        if ( *paValuesRules )
            FreeADsMem( *paValuesRules );

        if ( *pFileBuffer )
            FreeADsMem( *pFileBuffer );

        *paValuesAttrTypes = NULL;
        *paValuesObjClasses = NULL;
        *paValuesRules = NULL;
        *pFileBuffer = NULL;
    }

    return err;
}


#ifdef WIN95
DWORD ReadSchemaInfoFromFileA(
    LPSTR pszFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    *pnCountAttrTypes = 0;
    *pnCountObjClasses = 0;
    *pnCountRules = 0;


    hFile = CreateFileA( pszFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return GetLastError();

    return (
            ReadSchemaInfoFromFileWithHandle(
                hFile,
                paValuesAttrTypes,
                pnCountAttrTypes,
                paValuesObjClasses,
                pnCountObjClasses,
                paValuesRules,
                pnCountRules,
                pFileBuffer
                )
    );
}
#endif

DWORD ReadSchemaInfoFromFileW(
    LPTSTR pszFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;

    *pnCountAttrTypes = 0;
    *pnCountObjClasses = 0;
    *pnCountRules = 0;


    hFile = CreateFile( pszFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return GetLastError();

    return (
            ReadSchemaInfoFromFileWithHandle(
                hFile,
                paValuesAttrTypes,
                pnCountAttrTypes,
                paValuesObjClasses,
                pnCountObjClasses,
                paValuesRules,
                pnCountRules,
                pFileBuffer
                )
    );

}


DWORD StoreSchemaInfoToFileWithHandle(
    HANDLE hFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    TCHAR szEndOfLine[2] = TEXT("\n");
    TCHAR szSection[MAX_PATH];
    DWORD dwBytesWritten;
    int i;

    szSection[0] = 0xFEFF;   // Unicode BOM marker
    if ( !WriteFile( hFile,
                     szSection,
                     sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    _tcscpy( szSection, TEXT("[attributeTypes]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountAttribTypes; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesAttribTypes[i],
                         _tcslen( aValuesAttribTypes[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    _tcscpy( szSection, TEXT("[objectClasses]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountObjClasses; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesObjClasses[i],
                         _tcslen( aValuesObjClasses[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    _tcscpy( szSection, TEXT("[DITContentRules]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountRules; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesRules[i],
                         _tcslen( aValuesRules[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

cleanup:

    CloseHandle( hFile );

    return err;
}

#ifdef WIN95
DWORD StoreSchemaInfoToFileA(
    LPSTR pszFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    hFile = CreateFileA( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        err = GetLastError();

        if ( err == ERROR_PATH_NOT_FOUND )
        {
            //
            // The directory is not created yet, create it now.
            //

            LPSTR pszTemp = strstr( pszFile, "SchCache\\");
            pszTemp += strlen("SchCache");
            *pszTemp = 0;

            if ( !CreateDirectoryA( pszFile, NULL ))
                return GetLastError();

            *pszTemp = '\\';
            hFile = CreateFileA( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
                return GetLastError();

            err = NO_ERROR;
        }
        else
        {
            return err;
        }
    }

    err = StoreSchemaInfoToFileWithHandle(
              hFile,
              aValuesAttribTypes,
              nCountAttribTypes,
              aValuesObjClasses,
              nCountObjClasses,
              aValuesRules,
              nCountRules
              );

    if ( err != NO_ERROR )
        DeleteFileA( pszFile );

    return err;

}

#endif

DWORD StoreSchemaInfoToFileW(
    LPTSTR pszFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    hFile = CreateFile( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        err = GetLastError();

        if ( err == ERROR_PATH_NOT_FOUND )
        {
            // The directory is not created yet, create it now.

            LPTSTR pszTemp = _tcsrchr( pszFile, TEXT('\\'));
            *pszTemp = 0;

            if ( !CreateDirectory( pszFile, NULL ))
                return GetLastError();

            *pszTemp = TEXT('\\');
            hFile = CreateFile( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
                return GetLastError();

            err = NO_ERROR;
        }
        else
        {
            return err;
        }
    }

    err = StoreSchemaInfoToFileWithHandle(
              hFile,
              aValuesAttribTypes,
              nCountAttribTypes,
              aValuesObjClasses,
              nCountObjClasses,
              aValuesRules,
              nCountRules
              );

    if ( err != NO_ERROR )
        DeleteFile( pszFile );

    return err;
}

DWORD ReadSchemaInfoFromRegistry(
    HKEY hKey,
    LPWSTR pszServer,
    LPTSTR **paValuesAttribTypes,
    int *pnCountAttribTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pBuffer    
)
{
    DWORD err = NO_ERROR;
    LPTSTR pszPath = NULL;
    LPTSTR pszExpandedPath = NULL;
    LPSTR pszPathAscii = NULL;
    LPSTR pszExpandedPathAscii = NULL;
    LPTSTR pszTempPath = NULL;
    DWORD dwLength = 0;
    DWORD dwType;
    

    //
    // On chk bits would be good to make sure that this never
    // happens as some schema stuff is messed up in this case.
    //
    if (!pszServer) {
        ADsAssert(!"No server name was passed");
    }
    //
    // Get the file name that is used to store the schema info
    // from the registry.
    //

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           NULL,
                           &dwLength );
#ifndef WIN95
    if ( err )
        goto cleanup;
#else
    if (err == ERROR_MORE_DATA ) {
        //
        // Continue cause Win9x is dumb.
        //
        err = 0;
    } else
        goto cleanup;
#endif

    pszPath = (LPTSTR) AllocADsMem( dwLength );
    if ( pszPath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           (LPBYTE) pszPath,
                           &dwLength );

    if ( err )
        goto cleanup;

    //
    // Expand the path
    //
    pszExpandedPath = (LPTSTR) AllocADsMem( MAX_PATH * sizeof(WCHAR));
    if ( pszExpandedPath == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // At this point we want to rename all files called default.sch
    // We look for default.sch in the string and then create a new
    // string. For example if the string is %systemroot%\SCHEMA_DIR\
    // Default.sch we will replace with %systemroot%\SCHEMA_DIR\
    // pszServer.sch. This change will force schema to be dropped
    // and we will end up picking up and storing the schema under the 
    // correct name. This will ensure that 2 different forests do
    // not end up creating conflicting default.sch files that we 
    // never recover from internally. This excercise is futile unless
    // a server name was passed in (should be the case always).
    //
    if (pszPath && *pszPath && pszServer) {
        //
        // Look for default.sch
        //
        pszTempPath = wcsstr( pszPath, DEFAULT_SCHEMA_FILE_NAME_WITH_EXT);

        if (pszTempPath) {
            //
            // We now need to replace this string.
            //
            DWORD dwLenStr, dwLenNewPath;
            dwLenStr = pszTempPath - pszPath;
            
            //
            // Now build the new string from the old one. Length is 
            // pszServer + the old piece upto schema file name.
            //
            dwLenNewPath = wcslen(pszServer) 
                          + wcslen(SCHEMA_FILE_NAME_EXT)
                          + dwLenStr
                          + 1;

            pszTempPath = (LPTSTR) AllocADsMem(dwLenNewPath * sizeof(WCHAR));
            if (!pszTempPath) {
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            wcsncpy(pszTempPath, pszPath, dwLenStr);
            wcscat(pszTempPath, pszServer);
            wcscat(pszTempPath, SCHEMA_FILE_NAME_EXT);

            FreeADsMem(pszPath);
            pszPath = pszTempPath;
            pszTempPath = NULL;
            
            //
            // Now update the key in the registry. Ignore the error
            // cause there is nothing we can really do about it.
            //
            err = RegSetValueEx( 
                      hKey,
                      SCHEMA_FILE_NAME,
                      0,
                      REG_EXPAND_SZ,
                      (CONST BYTE *) pszPath,
                      (_tcslen(pszPath) + 1 ) * sizeof(TCHAR)
                      );
        }
    }

    dwLength = ExpandEnvironmentStrings( pszPath,
                                         pszExpandedPath,
                                         MAX_PATH );

#ifdef WIN95
    //
    // Just in case 3 bytes for each WCHAR rather than just 2.
    //
    pszExpandedPathAscii = (LPSTR) AllocADsMem( MAX_PATH * sizeof(char) * 3);
    if (!pszExpandedPathAscii) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (err = ConvertToAscii(pszPath, &pszPathAscii)) {
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStringsA(
                   pszPathAscii,
                   pszExpandedPathAscii,
                   MAX_PATH * sizeof(char) * 3
                   );
#endif

    if ( dwLength == 0 )
    {
        err = GetLastError();
        goto cleanup;
    }
    else if ( dwLength > MAX_PATH )
    {
        FreeADsMem( pszExpandedPath );
        pszExpandedPath = (LPTSTR) AllocADsMem( dwLength * sizeof(WCHAR));
        if ( pszExpandedPath == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        dwLength = ExpandEnvironmentStrings( pszPath,
                                             pszExpandedPath,
                                             dwLength );
        if ( dwLength == 0 )
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    //
    // Now, read the info from the file
    //
#ifndef WIN95
    err = ReadSchemaInfoFromFileW(
              pszExpandedPath,
              paValuesAttribTypes,
              pnCountAttribTypes,
              paValuesObjClasses,
              pnCountObjClasses,
              paValuesRules,
              pnCountRules,
              pBuffer
              );
#else
    err = ReadSchemaInfoFromFileA(
              pszExpandedPathAscii,
              paValuesAttribTypes,
              pnCountAttribTypes,
              paValuesObjClasses,
              pnCountObjClasses,
              paValuesRules,
              pnCountRules,
              pBuffer
              );

#endif


cleanup:

    if ( pszPath )
        FreeADsMem( pszPath );

    if ( pszExpandedPath )
        FreeADsMem( pszExpandedPath );

    if (pszTempPath) {
        FreeADsMem(pszTempPath);
    }

#ifdef WIN95
    if (pszPathAscii) {
        FreeADsMem(pszPathAscii);
    }

    if (pszExpandedPathAscii) {
        FreeADsMem(pszExpandedPathAscii);
    }
#endif

    return err;
}

DWORD StoreSchemaInfoInRegistry(
    HKEY hKey,
    LPTSTR pszServer,
    LPTSTR pszTime,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules,
    BOOL fProcessAUX
)
{
    DWORD err = NO_ERROR;
    LPTSTR pszPath = NULL;
    LPTSTR pszExpandedPath = NULL;
    LPSTR pszPathAscii = NULL;
    LPSTR pszExpandedPathAscii = NULL;
    DWORD dwLength = 0;
    DWORD dwType;
    DWORD dwProcessAUX;

    //
    // See if we can find the file name that is used to store the schema info
    // in the registry.
    //

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           NULL,
                           &dwLength );

    if ( err == NO_ERROR )
    {
        pszPath = (LPTSTR) AllocADsMem( dwLength );
        if ( pszPath == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = RegQueryValueEx( hKey,
                               SCHEMA_FILE_NAME,
                               NULL,
                               &dwType,
                               (LPBYTE) pszPath,
                               &dwLength );

        if ( err )
            goto cleanup;

    }

    err = NO_ERROR;

    if ( pszPath == NULL )   // Cannot read from the registry
    {
        //
        // Allocate pszPath to be either MAX_PATH chars or sufficient
        // to hold %SystemRoot%/<SCHEMA_DIR_NAME>/<pszServer>.sch, whichever
        // is larger.
        //
        if (pszServer) {
            DWORD cbPath = (MAX_PATH > (_tcslen(TEXT("%SystemRoot%\\")) +
                                        _tcslen(SCHEMA_DIR_NAME) +
                                        _tcslen(pszServer) +
                                        _tcslen(SCHEMA_FILE_NAME_EXT))) ?
                           (MAX_PATH * sizeof(WCHAR)) :
                           (2 * _tcslen(pszServer) * sizeof(WCHAR));

                                        
            pszPath = (LPTSTR) AllocADsMem(cbPath);
        }
        else{
            //
            // pszServe can be NULL in the ldapc layer users case
            //
            pszPath = (LPTSTR) AllocADsMem(MAX_PATH * sizeof(WCHAR));
        }

        if ( pszPath == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        //
        // Build the path of the schema info file
        //
#ifndef WIN95
        _tcscpy( pszPath, TEXT("%SystemRoot%\\"));
#else
        _tcscpy( pszPath, TEXT("%WINDIR%\\"));
#endif
        _tcscat( pszPath, SCHEMA_DIR_NAME);
        if (pszServer) {

            //
            // Server strings may have a port number in them,
            // e.g., "ntdev:389".  We need to change this to
            // "ntdev_389", otherwise the colon will give us trouble
            // in the filename.
            //
            LPTSTR pszColon = _tcschr(pszServer, (TCHAR)':');
            
            if (!pszColon) {
                _tcscat( pszPath, pszServer);
            }
            else {
                _tcsncat( pszPath, pszServer, pszColon-pszServer);
                _tcscat ( pszPath, TEXT("_"));
                _tcscat ( pszPath, pszColon+1); // the number after the colon 
            }
            
        }
        else {
            _tcscat( pszPath, DEFAULT_SCHEMA_FILE_NAME);
        }

        _tcscat( pszPath, SCHEMA_FILE_NAME_EXT );
    }

    pszExpandedPath = (LPTSTR) AllocADsMem( MAX_PATH * sizeof(WCHAR) );
    if ( pszExpandedPath == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStrings( pszPath,
                                         pszExpandedPath,
                                         MAX_PATH );
#ifdef WIN95

    pszExpandedPathAscii = (LPSTR) AllocADsMem(MAX_PATH * sizeof(char) * 3);
    if (!pszExpandedPathAscii) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (err = ConvertToAscii(pszPath, &pszPathAscii)) {
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStringsA(
                   pszPathAscii,
                   pszExpandedPathAscii,
                   MAX_PATH * sizeof(char) * 3
                   );
#endif

    if ( dwLength == 0 )
    {
        err = GetLastError();
        goto cleanup;
    }
    else if ( dwLength > MAX_PATH )
    {
        FreeADsMem( pszExpandedPath );
        pszExpandedPath = (LPTSTR) AllocADsMem( dwLength * sizeof(WCHAR) );
        if ( pszExpandedPath == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        dwLength = ExpandEnvironmentStrings( pszPath,
                                             pszExpandedPath,
                                             dwLength );
        if ( dwLength == 0 )
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    //
    // Write the schema information into the file
    //
#ifndef WIN95
    err = StoreSchemaInfoToFileW(
               pszExpandedPath,
               aValuesAttribTypes,
               nCountAttribTypes,
               aValuesObjClasses,
               nCountObjClasses,
               aValuesRules,
               nCountRules
               );
#else
    err = StoreSchemaInfoToFileA(
               pszExpandedPathAscii,
               aValuesAttribTypes,
               nCountAttribTypes,
               aValuesObjClasses,
               nCountObjClasses,
               aValuesRules,
               nCountRules
               );
#endif

    if ( err )
        goto cleanup;

    //
    // Write the information into the registry
    //

    err = RegSetValueEx( hKey,
                         SCHEMA_FILE_NAME,
                         0,
                         REG_EXPAND_SZ,
                         (CONST BYTE *) pszPath,
                         (_tcslen(pszPath) + 1 ) * sizeof(TCHAR));

    if ( err )
        goto cleanup;

    err = RegSetValueEx( hKey,
                         SCHEMA_TIME,
                         0,
                         REG_SZ,
                         (CONST BYTE *) pszTime,
                         (_tcslen(pszTime) + 1 ) * sizeof(TCHAR));

    if ( err )
        goto cleanup;

    
    dwProcessAUX = (TRUE == fProcessAUX) ? 1: 0;
    err = RegSetValueExW( hKey,
                         SCHEMA_PROCESSAUX,
                         0,
                         REG_DWORD,
                         (CONST BYTE *) &dwProcessAUX,
                         sizeof(dwProcessAUX));
   

cleanup:

    if ( pszPath )
        FreeADsMem( pszPath );

    if ( pszExpandedPath )
        FreeADsMem( pszExpandedPath );

#ifdef WIN95
    if (pszPathAscii) {
        FreeADsMem(pszPathAscii);
    }

    if (pszExpandedPathAscii) {
        FreeADsMem(pszExpandedPathAscii);
    }
#endif

    return err;
}


//+---------------------------------------------------------------------------
//  Function:   AttributeTypeDescription
//
//  Synopsis:   Parses an attribute type description.
//              It parses the following grammar rules
//
//  <AttributeTypeDescription> ::= "("
//          <oid>   -- AttributeType identifier
//          [ "NAME" <DirectoryStrings> ] -- name used in AttributeType
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "SUP" <oid> ]         -- derived from this other AttributeType
//          [ "EQUALITY" <oid> ]    -- Matching Rule name
//          [ "ORDERING" <oid> ]    -- Matching Rule name
//          [ "SUBSTR" <oid> ]      -- Matching Rule name
//          [ "SYNTAX" <DirectoryString> ] -- see section 4.2
//          [ "SINGLE-VALUE" ]              -- default multi-valued
//          [ "COLLECTIVE" ]                -- default not collective
//          [ "DYNAMIC" ]                   -- default not dynamic
//          [ "NO-USER-MODIFICATION" ]      -- default user modifiable
//          [ "USAGE" <AttributeUsage> ]    -- default user applications
//          ")"
//
//   <AttributeUsage> ::=
//            "userApplications"
//          | "directoryOperation"
//          | "distributedOperation"  -- DSA-shared
//          | "dSAOperation"          -- DSA-specific, value depends on server
//
//
//  Arguments:  [LPTSTR] pszAttrType : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
AttributeTypeDescription(
    LPTSTR pszAttrType,
    PPROPERTYINFO pPropertyInfo,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
    )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer( pszAttrType );

    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    //
    // use TRUE flag as there is a chance that from
    // some schemas, we get bad data that has no GUID
    //
    hr = Oid( &Tokenizer, &(pPropertyInfo->pszOID), TRUE);
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {
        LPWSTR *ppszDirStrings;
        DWORD dwCount,dwCtr;
        ppszDirStrings = NULL;
        dwCount = 0;

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                BAIL_IF_ERROR(hr);

                if (!ppszDirStrings) {
                    //
                    // We need at least one name.
                    //
                    BAIL_IF_ERROR(
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
                        );
                }

                //
                // For now we will only support the first name in the list.
                //
                pPropertyInfo->pszPropertyName = ppszDirStrings[0];

                //
                // The remaining values if any will require additional 
                // processing in FillPropertyInfoArray.
                //
                *pppszNames = ppszDirStrings;
                *pdwNameCount = dwCount;

                break;

            case TOKEN_DESC:
                hr = DirectoryString( &Tokenizer,
                                      &(pPropertyInfo->pszDescription));
                break;

            case TOKEN_OBSOLETE:
                // attribute is obsolete (RFC 2252)
                pPropertyInfo->fObsolete = TRUE;
                break;

            case TOKEN_SUP:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDSup));
                break;

            case TOKEN_EQUALITY:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDEquality));
                break;

            case TOKEN_ORDERING:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDOrdering));
                break;

            case TOKEN_SUBSTR:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDSubstr));
                break;

            case TOKEN_SYNTAX:
                hr = DirectoryString( &Tokenizer, &(pPropertyInfo->pszSyntax));
                //
                // It need not necessarily be a DirectoryString can also be
                // an OID. So if DirectoryString fails, we should try OID.
                //
                if (FAILED(hr)
                    && (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA))
                    ) {

                    Tokenizer.PushBackToken();
                    hr = Oid( &Tokenizer, &(pPropertyInfo->pszSyntax));
                }

                break;

            case TOKEN_SINGLE_VALUE:
                pPropertyInfo->fSingleValued = TRUE;
                break;

            case TOKEN_COLLECTIVE:
                pPropertyInfo->fCollective = TRUE;
                break;

            case TOKEN_DYNAMIC:
                pPropertyInfo->fDynamic = TRUE;
                break;

            case TOKEN_NO_USER_MODIFICATION:
                pPropertyInfo->fNoUserModification = TRUE;
                break;

            case TOKEN_USAGE:
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (_tcsicmp(szToken, TEXT("userApplications")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_USERAPPLICATIONS;
                else if (_tcsicmp(szToken, TEXT("directoryOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DIRECTORYOPERATION;
                else if (_tcsicmp(szToken, TEXT("distributedOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DISTRIBUTEDOPERATION;
                else if (_tcsicmp(szToken, TEXT("dSAOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DSAOPERATION;
                break;

            case TOKEN_OPEN_CURLY :
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (dwToken != TOKEN_IDENTIFIER) {
                    BAIL_IF_ERROR(hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
                }
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (dwToken != TOKEN_CLOSE_CURLY) {
                    BAIL_IF_ERROR(hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
                }
                break;

            case TOKEN_X :
                //
                // This means that this token and the following 
                // DirectoryStrings token (which can be empty string)
                // need to be ignored.
                //
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                //
                // If we could not process this then we need to BAIL
                // as the Tokenizer is not in a recoverable state.
                //
                BAIL_IF_ERROR(hr);

                //
                // Free the strings that came back.
                //
                FreeDirectoryStrings(
                    ppszDirStrings,
                    dwCount
                    );

                ppszDirStrings = NULL;
                
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:   ObjectClassDescription
//
//  Synopsis:   Parses an object class description.
//              It parses the following grammar rules
//
// <ObjectClassDescription> ::= "("
//          <oid>   -- ObjectClass identifier
//          [ "NAME" <DirectoryStrings> ]
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "SUP" <oids> ]    -- Superior ObjectClasses
//          [ ( "ABSTRACT" | "STRUCTURAL" | "AUXILIARY" )] -- default structural
//          [ "MUST" <oids> ]   -- AttributeTypes
//          [ "MAY" <oids> ]    -- AttributeTypes
//      ")"
//
//  Arguments:  [LPTSTR] pszObjectClass : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
ObjectClassDescription(
    LPTSTR pszObjectClass,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount,
    LPWSTR **pppszNewNames,
    PDWORD pdwNameCount
    )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    LPWSTR pszTemp;
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer( pszObjectClass );

    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    //
    // use TRUE flag as there is a chance that from
    // some schemas, we get bad data that has no GUID
    //
    hr = Oid( &Tokenizer, &(pClassInfo->pszOID), TRUE);
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {
        LPWSTR *ppszDirStrings;
        DWORD dwCount,dwCtr;
        ppszDirStrings = NULL;
        dwCount = 0;

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                BAIL_IF_ERROR(hr);

                if (!ppszDirStrings) {
                    //
                    // We need at least one name.
                    //
                    BAIL_IF_ERROR(
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
                        );
                }

                //
                // For now we will only support the first name in the list.
                //
                pClassInfo->pszName = ppszDirStrings[0];

                
                //
                // The remaining strings will need additional processing
                // in fillClassInfoArray
                //
                *pppszNewNames = ppszDirStrings;
                *pdwNameCount = dwCount;
                
                break;

            case TOKEN_DESC:
                hr = DirectoryString(&Tokenizer,&(pClassInfo->pszDescription));
                break;

            case TOKEN_OBSOLETE:
                // class is obsolete (RFC 2252)
                pClassInfo->fObsolete = TRUE;
                break;

            case TOKEN_SUP:
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                Tokenizer.PushBackToken();

                if ( dwToken == TOKEN_QUOTE )
                {

                    DWORD dwNumStrings = 0;
                    LPWSTR *ppszTmp = NULL;

                    while (dwToken == TOKEN_QUOTE) {

                        hr = DirectoryString( &Tokenizer,
                                              &(pszTemp));
                        BAIL_IF_ERROR(hr);

                        if (dwNumStrings == 0) {

                            pClassInfo->pOIDsSuperiorClasses
                                = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);

                        } else {

                            ppszTmp
                                = (LPWSTR *)
                                    ReallocADsMem(
                                        pClassInfo->pOIDsSuperiorClasses,
                                        sizeof(LPWSTR) * (dwNumStrings + 1),
                                        sizeof(LPWSTR) * (dwNumStrings + 2)
                                        );

                            pClassInfo->pOIDsSuperiorClasses = ppszTmp;
                        }

                        if ( pClassInfo->pOIDsSuperiorClasses == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            BAIL_IF_ERROR(hr);
                        }

                        pClassInfo->pOIDsSuperiorClasses[dwNumStrings] = pszTemp;
                        pClassInfo->pOIDsSuperiorClasses[++dwNumStrings] = NULL;

                        hr = Tokenizer.GetNextToken(szToken, &dwToken);
                        BAIL_IF_ERROR(hr);

                        Tokenizer.PushBackToken();

                    } // while

                } // the token was not a quote
                else {
                    hr = Oids(&Tokenizer, &(pClassInfo->pOIDsSuperiorClasses),NULL);
                }

                break;
            case TOKEN_ABSTRACT:
                pClassInfo->dwType = CLASS_TYPE_ABSTRACT;
                break;

            case TOKEN_STRUCTURAL:
                pClassInfo->dwType = CLASS_TYPE_STRUCTURAL;
                break;

            case TOKEN_AUXILIARY:
                pClassInfo->dwType = CLASS_TYPE_AUXILIARY;
                break;

            case TOKEN_MUST:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMustContain),
                              &(pClassInfo->nNumOfMustContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_MAY:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMayContain),
                              &(pClassInfo->nNumOfMayContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_X:
                //
                // This is provider specific info - parse and ignore.
                //
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                //
                // If we could not process this then we need to BAIL
                // as the Tokenizer is not in a recoverable state.
                //
                BAIL_IF_ERROR(hr);
                
                if (ppszDirStrings) {
                    FreeDirectoryStrings(
                        ppszDirStrings,
                        dwCount
                        );
                    ppszDirStrings = NULL;
                }
                
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:   DITContentRuleDescription
//
//  Synopsis:   Parses an DIT content rule description.
//              It parses the following grammar rules
//
// <DITContentDescription> ::= "("
//          <oid>   -- ObjectClass identifier
//          [ "NAME" <DirectoryStrings> ]
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "AUX" <oids> ]    -- Auxiliary ObjectClasses
//          [ "MUST" <oids> ]   -- AttributeTypes
//          [ "MAY" <oids> ]    -- AttributeTypes
//          [ "NOT" <oids> ]    -- AttributeTypes
//      ")"
//
//  Arguments:  [LPTSTR] pszObjectClass : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
DITContentRuleDescription( LPTSTR pszObjectClass, PCLASSINFO pClassInfo,
                           SEARCHENTRY *aPropSearchTable,
                           DWORD dwSearchTableCount )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer( pszObjectClass );

    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    hr = Oid( &Tokenizer, &(pClassInfo->pszOID));
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryString( &Tokenizer, NULL);
                // DirectoryStrings
                break;

            case TOKEN_DESC:
                hr = DirectoryString( &Tokenizer, NULL);
                break;

            case TOKEN_OBSOLETE:
                // rule is obsolete (RFC 2252)
                pClassInfo->fObsolete = TRUE;
                break;

            case TOKEN_AUX:
                hr = Oids(&Tokenizer, &(pClassInfo->pOIDsAuxClasses), NULL);
                break;

            case TOKEN_MUST:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMustContain),
                              &(pClassInfo->nNumOfMustContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_MAY:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMayContain),
                              &(pClassInfo->nNumOfMayContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_NOT:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsNotContain),
                              &(pClassInfo->nNumOfNotContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

HRESULT
Oid(CSchemaLexer * pTokenizer, LPTSTR *ppszOID, BOOL fNoGuid )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    *ppszOID = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_IDENTIFIER )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    //
    // Since some people do not like to have
    // an OID on all attributes, we need to work around them.
    // This should be changed once all schemas are compliant
    // AjayR 11-12-98.
    //
    if (fNoGuid && _wcsicmp(szToken, L"NAME") == 0) {
        *ppszOID = AllocADsStr(L"");
        pTokenizer->PushBackToken();
    } else
        *ppszOID = AllocADsStr( szToken );

    if ( *ppszOID == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    if ( FAILED(hr))
    {
        if ( *ppszOID )
        {
            FreeADsStr( *ppszOID );
            *ppszOID = NULL;
        }
    }

    RRETURN(hr);

}

HRESULT
Oids(CSchemaLexer * pTokenizer, LPTSTR **pOIDs, DWORD *pnNumOfOIDs )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;
    DWORD nCount = 0;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    if ( pnNumOfOIDs )
        *pnNumOfOIDs = 0;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_IDENTIFIER )
    {
        // All classes are subclasses of "top", and hence must contain
        // "objectClass" attribute. Add the "objectClass" attribute here
        // to prevent processing later.

        nCount = 2;

        *pOIDs = (LPTSTR *) AllocADsMem( sizeof(LPTSTR) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        (*pOIDs)[nCurrent] = AllocADsStr( szToken );
        if ( (*pOIDs)[nCurrent] == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        (*pOIDs)[++nCurrent] = NULL;

    }
    else if ( dwToken == TOKEN_OPENBRACKET )
    {
        nCount = 10;
        *pOIDs = (LPTSTR *) AllocADsMem( sizeof(LPTSTR) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        do {

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_IDENTIFIER )
            {
                if ( nCurrent == nCount )
                {
                    *pOIDs = (LPTSTR *) ReallocADsMem( *pOIDs,
                                          sizeof(LPTSTR) * nCount,
                                          sizeof(LPTSTR) * nCount * 2);
                    if ( *pOIDs == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        BAIL_IF_ERROR(hr);
                    }

                    nCount *= 2;

                }

                (*pOIDs)[nCurrent] = AllocADsStr( szToken );
                if ( (*pOIDs)[nCurrent] == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_IF_ERROR(hr);
                }
                nCurrent++;
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } while ( dwToken == TOKEN_DOLLAR );

        if ( dwToken != TOKEN_CLOSEBRACKET )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            BAIL_IF_ERROR(hr);
        }

        if ( nCurrent == nCount )
        {
            // Need one extra NULL entry at the end of the array
            *pOIDs = (LPTSTR *) ReallocADsMem( *pOIDs,
                                      sizeof(LPTSTR) * nCount,
                                      sizeof(LPTSTR) * (nCount + 1));

            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }

            nCount += 1;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    if ( pnNumOfOIDs )
        *pnNumOfOIDs = nCurrent;

cleanup:

    if ( FAILED(hr))
    {
        if ( *pOIDs )
        {
            for ( DWORD i = 0; i < nCount; i++ )
            {
                if ( (*pOIDs)[i] )
                    FreeADsStr( (*pOIDs)[i] );
            }
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
PropOids(CSchemaLexer * pTokenizer, int **pOIDs, DWORD *pnNumOfOIDs,
         SEARCHENTRY *aPropSearchTable, DWORD dwSearchTableCount )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;
    DWORD nCount = 0;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    if ( pnNumOfOIDs )
        *pnNumOfOIDs = 0;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_IDENTIFIER )
    {
        int nIndex = FindSearchTableIndex( szToken,
                                           aPropSearchTable,
                                           dwSearchTableCount );

        if ( nIndex != -1 )
        {
            nCount = 2;

            *pOIDs = (int *) AllocADsMem( sizeof(int) * nCount);
            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }

            (*pOIDs)[nCurrent] = nIndex;
            (*pOIDs)[++nCurrent] = -1;
        }

    }
    else if ( dwToken == TOKEN_OPENBRACKET )
    {
        nCount = 10;
        *pOIDs = (int *) AllocADsMem( sizeof(int) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        do {

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_CLOSEBRACKET )
            {
                FreeADsMem( *pOIDs );
                *pOIDs = NULL;
                goto cleanup;
            }

            if ( dwToken == TOKEN_IDENTIFIER )
            {
                int nIndex = FindSearchTableIndex( szToken,
                                                   aPropSearchTable,
                                                   dwSearchTableCount );

                if ( nIndex != -1 )
                {
                    if ( nCurrent == nCount )
                    {
                        *pOIDs = (int *) ReallocADsMem( *pOIDs,
                                              sizeof(int) * nCount,
                                              sizeof(int) * nCount * 2);
                        if ( *pOIDs == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            BAIL_IF_ERROR(hr);
                        }

                        nCount *= 2;

                    }

                    (*pOIDs)[nCurrent++] = nIndex;
                }

                // else we cannot find the property, so skip over it.
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } while ( dwToken == TOKEN_DOLLAR );

        if ( dwToken != TOKEN_CLOSEBRACKET )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            BAIL_IF_ERROR(hr);
        }

        if ( nCurrent == nCount )
        {
            // Need one extra NULL entry at the end of the array
            *pOIDs = (int *) ReallocADsMem( *pOIDs,
                                      sizeof(int) * nCount,
                                      sizeof(int) * (nCount + 1));

            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }

            nCount += 1;
        }

        (*pOIDs)[nCurrent] = -1;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    if ( pnNumOfOIDs )
        *pnNumOfOIDs = nCurrent;

cleanup:

    if ( FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
DirectoryString(CSchemaLexer * pTokenizer, LPTSTR *ppszDirString )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    if ( ppszDirString )
        *ppszDirString = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_QUOTE )
    {
        hr = pTokenizer->GetNextToken2(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
        {
            if ( ppszDirString )
            {
                *ppszDirString = AllocADsStr( szToken );
                if ( *ppszDirString == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_IF_ERROR(hr);
                }
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_QUOTE )
                RRETURN(S_OK);
        }
    }

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

cleanup:

    if ( FAILED(hr))
    {
        if ( ppszDirString && *ppszDirString )
        {
            FreeAD