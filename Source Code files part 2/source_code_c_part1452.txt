f enum _PropStatus {
        PROPSTATUS_UNSET = 0,
        PROPSTATUS_SET_DWORD,
        PROPSTATUS_SET_HRESULT,
        PROPSTATUS_SET_BOOL,
        PROPSTATUS_SET_PVOID,
        PROPSTATUS_SET_STRINGA,
        PROPSTATUS_SET_IUNKNOWN,
        PROPSTATUS_SET_IMAILMSGPROPERTIES,
        PROPSTATUS_SET_IMAILMSGRECIPIENTSADD,
        PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES,
        PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE,
        PROPSTATUS_SET_ICATEGORIZERMAILMSGS,
        PROPSTATUS_SET_ICATEGORIZERITEM
    } PROPSTATUS, *PPROPSTATUS;

    typedef struct _tagProp {
        PROPSTATUS PropStatus;
        union _tag_PropValue {
            LPSTR  pszValue;
            DWORD  dwValue;
            BOOL   fValue;
            PVOID  pvValue;
            IUnknown *pIUnknownValue;
            IMailMsgProperties *pIMailMsgPropertiesValue;
            IMailMsgRecipientsAdd *pIMailMsgRecipientsAddValue;
            ICategorizerItemAttributes *pICategorizerItemAttributesValue;
            ICategorizerListResolve *pICategorizerListResolveValue;
            ICategorizerMailMsgs *pICategorizerMailMsgsValue;
            ICategorizerItem *pICategorizerItemValue;
        } PropValue;
    } PROPERTY, *PPROPERTY;

    DWORD m_dwSignature;
    IUnknown *m_pIUnknown;
    DWORD m_dwNumPropIds;
    PPROPERTY m_rgProperties;

    friend class CCategorizer;
    friend class CICategorizerItemIMP;
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
};

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::m_strdup
//
// Synopsis: Allocates and copies a string
//
// Arguments:
//   psz: String to copy
//
// Returns:
//   Address of allocated string buffer, or NULL if out of memory
//  
// History:
// jstamerj 1998/06/20 19:07:12: Created.
//
//-------------------------------------------------------------
inline LPSTR CICategorizerPropertiesIMP::m_strdup(
    LPSTR psz)
{
    _ASSERT(psz);

    LPSTR pszNew;
    pszNew = new CHAR[lstrlen(psz)+1];
    if(pszNew) {
        lstrcpy(pszNew, psz);
    }
    return pszNew;
}

#endif //__ICATPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatmailmsgs.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatmailmsgs.h
//
// Contents: Implementation of ICategorizerMailMsgs
//
// Classes: CICategorizerMailMsgsIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/30 13:21:41: Created.
//
//-------------------------------------------------------------
#ifndef _ICATMAILMSGS_H_
#define _ICATMAILMSGS_H_


#include "mailmsg.h"
#include "smtpevent.h"
#include "cattype.h"
#include <listmacr.h>
#include "mailmsgprops.h"
#include "catperf.h"

#define ICATEGORIZERMAILMSGS_DEFAULTIMSGID  0

#define SIGNATURE_CICATEGORIZERMAILMSGSIMP          (DWORD)'ICMM'
#define SIGNATURE_CICATEGORIZERMAILMSGSIMP_INVALID  (DWORD)'XCMM'


class CICategorizerMailMsgsIMP : public ICategorizerMailMsgs
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) {
        return m_pIUnknown->QueryInterface(iid, ppv);
    }
    STDMETHOD_(ULONG, AddRef) () { return m_pIUnknown->AddRef(); }
    STDMETHOD_(ULONG, Release) () { return m_pIUnknown->Release(); }

  public:
    //ICategorizerMailMsgs
    STDMETHOD (GetMailMsg) (
        IN  DWORD dwId,
        OUT IMailMsgProperties **ppIMailMsgProperties,
        OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd,
        OUT BOOL *pfCreated);

    STDMETHOD (ReBindMailMsg) (
        IN  DWORD dwFlags,
        IN  IUnknown *pStoreDriver);

    STDMETHOD (BeginMailMsgEnumeration) (
        IN  PCATMAILMSG_ENUMERATOR penumerator);

    STDMETHOD (GetNextMailMsg) (
        IN  PCATMAILMSG_ENUMERATOR penumerator,
        OUT DWORD *pdwFlags,
        OUT IMailMsgProperties **ppIMailMsgProperties,
        OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd);

    STDMETHOD (EndMailMsgEnumeration) (
        IN  PCATMAILMSG_ENUMERATOR penumerator)
    {
        //
        // Nothing to do...
        //
        return S_OK;
    }

  private:
    // Internal types
    typedef struct _tagIMsgEntry {
        LIST_ENTRY              listentry;
        DWORD                   dwId;
        IUnknown                *pIUnknown;
        IMailMsgProperties      *pIMailMsgProperties;
        IMailMsgRecipients      *pIMailMsgRecipients;
        IMailMsgRecipientsAdd   *pIMailMsgRecipientsAdd;
        BOOL                    fBoundToStore;
    } IMSGENTRY, *PIMSGENTRY;

  private:
    // Internal categorizer functions
    CICategorizerMailMsgsIMP(
        CICategorizerListResolveIMP *pCICatListResolveIMP);
    ~CICategorizerMailMsgsIMP();

    HRESULT Initialize(
        IUnknown *pIMsg);

    HRESULT CreateIMsgEntry(
        PIMSGENTRY *ppIE,
        IUnknown *pIUnknown = NULL,
        IMailMsgProperties *pIMailMsgProperties = NULL,
        IMailMsgRecipients *pIMailMsgRecipients = NULL,
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL,
        BOOL fBoundToStore = FALSE);

    HRESULT CreateAddIMsgEntry(
        DWORD dwId,
        IUnknown *pIUnknown = NULL,
        IMailMsgProperties *pIMailMsgProperties = NULL,
        IMailMsgRecipients *pIMailMsgRecipients = NULL,
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL,
        BOOL fBoundToStore = FALSE);

    HRESULT GetNumIMsgs() { return m_dwNumIMsgs; }

    HRESULT WriteListAll();
    HRESULT RevertAll();
    HRESULT GetAllIUnknowns(
        IUnknown **rgpIMsgs,
        DWORD cPtrs);

    HRESULT SetMsgStatusAll(
        DWORD dwMsgStatus);

    HRESULT HrPrepareForCompletion();

    IUnknown * GetDefaultIUnknown();
    IMailMsgProperties * GetDefaultIMailMsgProperties();
    IMailMsgRecipients * GetDefaultIMailMsgRecipients();
    IMailMsgRecipientsAdd * GetDefaultIMailMsgRecipientsAdd();

    PIMSGENTRY FindIMsgEntry(
        DWORD dwId);

    PCATPERFBLOCK GetPerfBlock();

    VOID FinalRelease();

  private:
    // Data
    DWORD m_dwSignature;

    // A count of the number of elements in the list
    DWORD m_dwNumIMsgs;

    // A list of IMSGENTRY structs
    LIST_ENTRY m_listhead;

    // Back pointer to use for QI/AddRef/Release
    IUnknown *m_pIUnknown;
    CICategorizerListResolveIMP *m_pCICatListResolveIMP;

    CRITICAL_SECTION m_cs;
    
    friend class CICategorizerListResolveIMP;
};

#endif // _ICATMAILMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ldapstr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       ldapstr.h
//
//  Contents:   Until LDAP Schema issues can be hammered out, we store all
//              LDAP related strings in this central file.
//
//  Classes:
//
//  Functions:
//
//  History:    January 24, 1997    Milan Shah (milans)
//
//-----------------------------------------------------------------------------

#ifndef _LDAPSTR_H_
#define _LDAPSTR_H_

#include <smtpevent.h>

typedef struct _SCHEMA_CONFIG_STRING_TABLE_ENTRY {
    eDSPARAMETER DSParam;
    LPSTR        pszValue;
} SCHEMA_CONFIG_STRING_TABLE_ENTRY, * PSCHEMA_CONFIG_STRING_TABLE;

#define SCHEMA_CONFIG_STRING_TABLE_NT5 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_RDN,    "cn"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "forwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "User"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "group"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822-Distribution-List"}, \
    { DSPARAMETER_INVALID, NULL} \
}

#define SCHEMA_REQUEST_STRINGS_NT5 { \
      "distinguishedName", \
      "forwardingAddress", \
      "objectClass", \
      "mail", \
      "member", \
      NULL \
}

#define SCHEMA_CONFIG_STRING_TABLE_EXCHANGE5 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_X400,   "textEncodedORAddress"}, \
    { DSPARAMETER_SEARCHFILTER_X400,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_RDN,    "rdn"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_X400, "textEncodedORAddress"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "ForwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "person"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "groupOfNames"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822-Distribution-List"}, \
    { DSPARAMETER_INVALID, NULL} \
}
#define SCHEMA_REQUEST_STRINGS_EXCHANGE5 { \
      "objectClass", \
      "distinguishedName", \
      "mail", \
      "textEncodedORAddress", \
      "LegacyExchangeDN", \
      "member", \
      "ForwardingAddress", \
      NULL \
}

#define SCHEMA_CONFIG_STRING_TABLE_MCIS3 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_RDN,    "CN"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "ForwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "member"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "distributionList"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822DistributionList"}, \
    { DSPARAMETER_INVALID, NULL} \
}

#define SCHEMA_REQUEST_STRINGS_MCIS3 { \
      "objectClass", \
      "distinguishedName", \
      "mail", \
      "member", \
      "ForwardingAddress", \
      NULL \
}
#endif // _LDAPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatparam.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatdsparam.h
//
// Contents: NT5's implementation of ICategorizerParameters
//
// Classes:
//   CICategorizerParametersIMP
//   CICategorizerRequestedAttributesIMP
//
// Functions:
//
// History:
// jstamerj 980611 16:16:46: Created.
//
//-------------------------------------------------------------
#include "smtpevent.h"
#include "caterr.h"
#include <rwex.h>

#define SIGNATURE_CICategorizerParametersIMP  ((DWORD)'ICPI')
#define SIGNATURE_CICategorizerParametersIMP_Invalid ((DWORD)'XCPI')

#define DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE    25

class CICategorizerRequestedAttributesIMP;

CatDebugClass(CICategorizerParametersIMP),
    public ICategorizerParametersEx
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerParametersEx
    STDMETHOD(GetDSParameterA)(
        IN   DWORD dwDSParameter,
        OUT  LPSTR *ppszValue);

    STDMETHOD(GetDSParameterW)(
        IN   DWORD dwDSParameter,
        OUT  LPWSTR *ppszValue);

    STDMETHOD(SetDSParameterA)(
        IN   DWORD dwDSParameter,
        IN   LPCSTR pszValue);

    STDMETHOD(RequestAttributeA)(
        IN   LPCSTR pszName);

    STDMETHOD(GetAllAttributes)(
        OUT  LPSTR **prgszAllAttributes)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(ReserveICatItemPropIds)(
        IN   DWORD   dwNumPropIdsRequested,
        OUT  DWORD *pdwBeginningPropId);

    STDMETHOD(ReserveICatListResolvePropIds)(
        IN   DWORD   dwNumPropIdsRequested,
        OUT  DWORD *pdwBeginningPropId);

    STDMETHOD(GetCCatConfigInfo)(
        OUT  PCCATCONFIGINFO *ppCCatConfigInfo);

    STDMETHOD(GetRequestedAttributes)(
        OUT  ICategorizerRequestedAttributes **ppIRequestedAttributes);

    STDMETHOD(RegisterCatLdapConfigInterface)(
        IN   ICategorizerLdapConfig *pICatLdapConfigInfo);

    STDMETHOD(GetLdapConfigInterface)(
        OUT  ICategorizerLdapConfig **ppICatLdapConfigInfo);

   private:

    CICategorizerParametersIMP(
        PCCATCONFIGINFO pCCatConfigInfo,
        DWORD dwInitialICatItemProps,
        DWORD dwInitialICatListResolveProps);

    ~CICategorizerParametersIMP();

    VOID SetReadOnly(BOOL fReadOnly) { m_fReadOnly = fReadOnly; }

    DWORD GetNumPropIds_ICatItem() { return m_dwCurPropId_ICatItem; }
    DWORD GetNumPropIds_ICatListResolve() { return m_dwCurPropId_ICatListResolve; }
  private:
    DWORD m_dwSignature;
    ULONG m_cRef;

    BOOL  m_fReadOnly;
    CICategorizerRequestedAttributesIMP *m_pCIRequestedAttributes;

    DWORD m_dwCurPropId_ICatItem;
    DWORD m_dwCurPropId_ICatListResolve;
    LPSTR m_rgszDSParameters[DSPARAMETER_ENDENUMMESS];
    LPWSTR m_rgwszDSParameters[DSPARAMETER_ENDENUMMESS];
    PCCATCONFIGINFO m_pCCatConfigInfo;
    CExShareLock m_sharelock;
    ICategorizerLdapConfig *m_pICatLdapConfigInfo;

    friend class CCategorizer;
};


CatDebugClass(CICategorizerRequestedAttributesIMP),
    public ICategorizerRequestedAttributes
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ()
    {
        return InterlockedIncrement((PLONG)&m_ulRef);
    }
    STDMETHOD_(ULONG, Release) ()
    {
        ULONG ulRet;
        ulRet = InterlockedDecrement((PLONG)&m_ulRef);
        if(ulRet == 0)
            delete this;
        return ulRet;
    }

  public:
    //ICategorizerRequestedAttributes
    STDMETHOD (GetAllAttributes) (
        OUT LPSTR **prgszAllAttributes);

    STDMETHOD (GetAllAttributesW) (
        OUT LPWSTR **prgszAllAttributes);

  private:
    CICategorizerRequestedAttributesIMP();
    ~CICategorizerRequestedAttributesIMP();

    HRESULT ReAllocArrayIfNecessary(LONG lNewAttributeCount);
    HRESULT AddAttribute(LPCSTR pszAttribute);
    HRESULT FindAttribute(LPCSTR pszAttribute);
    ULONG   GetReferenceCount()
    {
        return m_ulRef;
    }

  private:
    #define SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP         (DWORD)'ICRA'
    #define SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP_INVALID (DWORD)'XCRA'
    DWORD m_dwSignature;
    LONG  m_ulRef;
    LONG  m_lAttributeArraySize;
    LPSTR  *m_rgszAttributeArray;
    LPWSTR *m_rgwszAttributeArray;
    LONG  m_lNumberAttributes;

    friend class CICategorizerParametersIMP;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\spinlock.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.h
//
// Contents: Spinlock package
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980511 17:25:05: Created.
//
//-------------------------------------------------------------
#include <windows.h>

//
// Simple spinlock package used by CLdapConnection
//

typedef LONG SPIN_LOCK;
typedef LPLONG PSPIN_LOCK;

typedef VOID (__stdcall *PFN_ACQUIRESPINLOCK)(PSPIN_LOCK);

extern PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

VOID InitializeSpinLock(
    PSPIN_LOCK psl);

#define AcquireSpinLock (*g_AcquireSpinLock)

VOID AcquireSpinLockSingleProc(
    PSPIN_LOCK psl);
VOID AcquireSpinLockMultipleProc(
    PSPIN_LOCK psl);
VOID ReleaseSpinLock(
    PSPIN_LOCK psl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\idstore.h ===
//
// idstore.h -- This file contains class and function definitions for
//
//      CEmailIDStore -- A pure virtual class that is used by the common
//          router code to store and retrieve email ID information. By making
//          this a pure virtual class, we facilitate multiple implementations
//          of this class.
//
//      GetEmailIDStore -- Each implementation must provide this routine to
//          return a pointer to an uninitialized instance of a CEmailIDStore.
//
//      ReleaseEmailIDStore -- Each implementation must provide this routine
//          to free up resources used by the instance of CEmailIDStore being
//          released.
//
// Created:
//      Dec 17, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef __IDSTORE_H__
#define __IDSTORE_H__

#include <windows.h>
#include <transmem.h>
#include "catdefs.h"
#include "cattype.h"
#include "smtpevent.h"

//
// A FNLIST_COMPLETION routine is called when all email ids in a list being
// resolve asynchronously have been resolved.
//
typedef VOID (*LPFNLIST_COMPLETION)(VOID *pContext);

typedef VOID (*LPSEARCHCOMPLETIONCOMPLETION)(
    LPVOID lpContext);

typedef VOID (*PFN_DLEXPANSIONCOMPLETION)(
    HRESULT hrStatus,
    PVOID pContext);

class CInsertionRequest;

template <class T> class CEmailIDStore {
  public:

    //
    // Initialize the store.
    // If this fails, SMTPSVC will not start
    //
    virtual HRESULT Initialize(
        ICategorizerParametersEx *pICatParams,
        ISMTPServer *pISMTPServer) = 0;

    //
    // Create a new context for looking up a list of entries
    // asynchronously
    //
    virtual HRESULT InitializeResolveListContext(
        VOID *pUserContext,
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    //
    // Free the context allocated witht InitializeResolveListContext
    //
    virtual VOID FreeResolveListContext(
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    virtual HRESULT InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        CInsertionRequest *pCRequest) = 0;

    //
    // Fetch an entry asynchronously. This function returns as soon as
    // the Lookup request has been queued.
    // Lookup the address contained in the CCatAddr object.
    // Upon completion, SetProperty routines will be called in the
    // CCatAddr object for returned properties followed by a call
    // to CCatAddr::HrCompletion
    //
    virtual HRESULT LookupEntryAsync(
        T *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    //
    // Multi-Thread-UNSAFE cancel of pending resolves in the resolve list
    // context that have not yet been dispatched
    //
    virtual HRESULT CancelResolveList(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        HRESULT hr) = 0;

    //
    // Cancel all outstanding lookup requests
    //
    virtual VOID CancelAllLookups() = 0;

    //
    // Paged DL's require repeated lookups with a "special" attribute
    // list (ie. "members;range=1000-*").  Because of this special
    // behavior, we have an interface function for it.
    //
    virtual HRESULT HrExpandPagedDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        CAT_ADDRESS_TYPE CAType,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    //
    // Similar to paged DLs, dynamic DLs require a special lookup
    // where every result found is a DL member.  Rather than pass a
    // query string dirctly to ldapstor we have a special interface
    // function for Dynamic DLs
    //
    virtual HRESULT HrExpandDynamicDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    //
    // Users of this object should call GetInsertionContext before
    // calling LookupEntryAsync.  ReleaseInsertionContext should be
    // called once for every GetInsertionContext.
    //
    virtual VOID GetInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext) = 0;

    virtual VOID ReleaseInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext) = 0;
};

//
// Function to instantiate a new CEmailIDStore object.
//
template <class T> HRESULT GetEmailIDStore(
    CEmailIDStore<T> **ppStore);

//
// Function to release an instance of CEmailIDStore object.
//
template <class T> VOID ReleaseEmailIDStore(
    CEmailIDStore<T> *pStore);

class CInsertionRequest
{
  public:
    CInsertionRequest()
    {
        m_dwRefCount = 1;
    }
    virtual ~CInsertionRequest()
    {
        _ASSERT(m_dwRefCount == 0);
    }
    virtual DWORD AddRef()
    {
        return InterlockedIncrement((PLONG)&m_dwRefCount);
    }
    virtual DWORD Release()
    {
        DWORD dwRet;
        dwRet = InterlockedDecrement((PLONG)&m_dwRefCount);
        if(dwRet == 0)
            FinalRelease();
        return dwRet;
    }
    virtual HRESULT HrInsertSearches(
        DWORD dwcSearches,
        DWORD *pdwcSearchesIssued) = 0;

    virtual VOID NotifyDeQueue(
        HRESULT hr) = 0;

    LIST_ENTRY m_listentry_insertionrequest;

  protected:
    virtual VOID FinalRelease()
    {
        delete this;
    }

    LONG m_dwRefCount;
};



#endif // __IDSTORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatlistresolve.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatlistresolve.h
//
// Contents: Implementation of ICategorizerListResolve
//
// Classes: CICategorizerListResolveIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 17:40:39: Created.
//
//-------------------------------------------------------------
#ifndef __ICATLISTRESOLVE_H__
#define __ICATLISTRESOLVE_H__

#include <smtpevent.h>
#include <smtpinet.h>
#include <ccat.h>
#include <baseobj.h>
#include "icatmailmsgs.h"
#include "icatprops.h"

#define SIGNATURE_CICATEGORIZERLISTRESOLVEIMP (DWORD)'ICLR'
#define SIGNATURE_CICATEGORIZERLISTRESOLVEIMP_FREE (DWORD)'XCLR'

//
// Disable the warnings concerining using this in the constructor.
// Trust me, it's safe here since it's just a back pointer being
// passed into a member class (it's not used during construction in
// any other way)
//
#pragma warning (disable: 4355)

class CCatRecip;
class CICategorizerListResolveIMP;

CatDebugClass(CSinkInsertionRequest),
    public CInsertionRequest
{
  public:
    DWORD AddRef();
    DWORD Release();
    HRESULT HrInsertSearches(
        DWORD dwcSearches,
        DWORD *pdwcSearchesIssued);

    VOID NotifyDeQueue(
        HRESULT hr);

    VOID FinalRelease() {}

  private:
    #define SIGNATURE_CSINKINSERTIONREQUEST         (DWORD)'QRIS'
    #define SIGNATURE_CSINKINSERTIONREQUEST_INVALID (DWORD)'XRIS'

    CSinkInsertionRequest(
        CICategorizerListResolveIMP *pCICatListResolve)
    {
        m_dwSignature = SIGNATURE_CSINKINSERTIONREQUEST;
        m_fInserted = FALSE;
        InitializeSpinLock(&m_spinlock);
        InitializeListHead(&m_listhead);
        m_pCICatListResolve = pCICatListResolve;
    }
    ~CSinkInsertionRequest()
    {
        _ASSERT(IsListEmpty(&m_listhead));
        _ASSERT(m_dwSignature == SIGNATURE_CSINKINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CSINKINSERTIONREQUEST_INVALID;
        //
        // Set the base object (CInsertionRequest's) refcount to zero
        // so that it does not assert in the destructor
        //
        m_dwRefCount = 0;
    }

    VOID InsertItem(
        CCatAddr *pCCatAddr);

    VOID InsertInternalInsertionRequest(BOOL fReinset = FALSE);

  private:
    DWORD      m_dwSignature;
    SPIN_LOCK  m_spinlock;
    BOOL       m_fInserted;
    LIST_ENTRY m_listhead;
    CICategorizerListResolveIMP *m_pCICatListResolve;

    friend class CICategorizerListResolveIMP;
};

CatDebugClass(CTopLevelInsertionRequest),
    public CInsertionRequest
{
  public:
    DWORD AddRef();
    DWORD Release();
    HRESULT HrInsertSearches(
        DWORD dwcSearches,
        DWORD *pdwcSearchesIssued);

    VOID NotifyDeQueue( 
        HRESULT hr);

    VOID FinalRelease() {}

  private:
    #define SIGNATURE_CTOPLEVELINSERTIONREQUEST         (DWORD)'RILT'
    #define SIGNATURE_CTOPLEVELINSERTIONREQUEST_INVALID (DWORD)'XILT'

    CTopLevelInsertionRequest(
        CICategorizerListResolveIMP *pCICatListResolve)
    {
        m_dwSignature = SIGNATURE_CTOPLEVELINSERTIONREQUEST;
        m_pCICatListResolve = pCICatListResolve;

        m_pIMailMsgProperties = NULL;
        m_pOrigRecipList = NULL;
        m_pCatRecipList = NULL;

        m_fSenderFinished = FALSE;
        m_dwcRecips = 0;
        m_dwNextRecip = 0;
        m_hr = S_OK;
    }
    ~CTopLevelInsertionRequest()
    {
        _ASSERT(m_dwSignature == SIGNATURE_CTOPLEVELINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CTOPLEVELINSERTIONREQUEST_INVALID;
        //
        // Set the base object (CInsertionRequest's) refcount to zero
        // so that it does not assert in the destructor
        //
        m_dwRefCount = 0;
    }

    VOID BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList); 

    BOOL fTopLevelInsertionFinished()
    {
        return (FAILED(m_hr) || 
                ((m_fSenderFinished) && (m_dwNextRecip >= m_dwcRecips)));
    }

    PCATPERFBLOCK GetPerfBlock();

  private:
    DWORD      m_dwSignature;
    CICategorizerListResolveIMP *m_pCICatListResolve;
    BOOL       m_fSenderFinished;
    DWORD      m_dwcRecips;
    DWORD      m_dwNextRecip;
    HRESULT    m_hr;
    IMailMsgProperties *m_pIMailMsgProperties;
    IMailMsgRecipients *m_pOrigRecipList;
    IMailMsgRecipientsAdd *m_pCatRecipList;

    friend class CICategorizerListResolveIMP;
};



class CICategorizerListResolveIMP :
    public CICategorizerPropertiesIMP,
    public CCatDLO<CICategorizerListResolveIMP_didx>,
    public ICategorizerListResolve
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) () 
    { 
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release) ()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRef);
        if(lRet == 0)
            FinalRelease();
        return lRet;
    }

  public:
    //ICategorizerListResolve
    STDMETHOD(AllocICategorizerItem)(
        IN   eSourceType Sourcetype,
        OUT  ICategorizerItem **ppICatItem);

    STDMETHOD(ResolveICategorizerItem)(
        IN   ICategorizerItem *pICatItem);

    STDMETHOD(SetListResolveStatus)(
        IN   HRESULT hrStatus);

    STDMETHOD(GetListResolveStatus)(
        IN   HRESULT *phrStatus);

  protected:
    CICategorizerListResolveIMP(
        CCategorizer *pCCat,
        PFNCAT_COMPLETION pfnCatCompletion,
        PVOID pContext) : 
        m_CICategorizerMailMsgs(this),
        CICategorizerPropertiesIMP((ICategorizerListResolve *)this),
        m_CSinkInsertionRequest(this),
        m_CTopLevelInsertionRequest(this)
    {
        _ASSERT(pCCat);
        m_Signature = SIGNATURE_CICATEGORIZERLISTRESOLVEIMP;
        m_pCCat = pCCat;
        m_pCCat->AddRef();
        m_hrListResolveStatus = S_OK;
        m_pfnCatCompletion = pfnCatCompletion;
        m_pCompletionContext = pContext;
        m_fSenderResolved = FALSE;
        m_fResolvingSender = FALSE;
        InitializeSpinLock(&m_spinlock);
        InitializeListHead(&m_listhead_recipients);
        m_dwcPendingLookups = 0;
        m_lRef = 1; // 1 Reference from the creator
    }
    virtual ~CICategorizerListResolveIMP()
    {
        _ASSERT(m_Signature == SIGNATURE_CICATEGORIZERLISTRESOLVEIMP);
        m_Signature = SIGNATURE_CICATEGORIZERLISTRESOLVEIMP_FREE;
    }
    
    HRESULT Initialize(
        IUnknown *pIMsg);

    //
    // Kicks off async categorizer for all recipients&sender in the message
    //
    virtual HRESULT StartMessageCategorization();

    //
    // Handles list resolve completion
    //
    virtual HRESULT CompleteMessageCategorization();

    //
    // Helper routines to create all ICatItems and start a message
    // resolve
    //
    virtual HRESULT BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList);

    //
    // Helper routines to set the cat status property of a mailmsg
    //
    HRESULT SetMailMsgCatStatus(
        IMailMsgProperties *pIMailMsgProps, 
        HRESULT hrStatus);

    HRESULT SetMailMsgCatStatus(
        IUnknown *pIMsg, 
        HRESULT hrStatus);

    // Inline Methods on accessing context members:
    CCategorizer *GetCCategorizer() {
        return m_pCCat;
    }
    CICategorizerMailMsgsIMP * GetCICategorizerMailMsgs() {
        return &m_CICategorizerMailMsgs;
    }
    HRESULT GetListResolveStatus() {
        return m_hrListResolveStatus;
    }
    CEmailIDStore<CCatAddr> * GetEmailIDStore() {
        return m_pCCat->GetEmailIDStore();
    }
    LPRESOLVE_LIST_CONTEXT GetResolveListContext() {
        return &m_rlc;
    }
    HRESULT CancelResolveList(HRESULT hrReason) {
        return GetEmailIDStore()->CancelResolveList(&m_rlc, hrReason);
    }
    HRESULT GetCCatAddrFromICategorizerItem(
        ICategorizerItem *pICatItem,
        CCatAddr **ppCCatAddr)
    {
        HRESULT hr;
        hr = pICatItem->GetPVoid(
            m_pCCat->GetICatItemCCatAddrPropId(),
            (PVOID *)ppCCatAddr);
        return hr;
    }
    ISMTPServer *GetISMTPServer()
    {
        return m_pCCat->GetISMTPServer();
    }
    ICategorizerDomainInfo *GetIDomainInfo()
    {
        return m_pCCat->GetIDomainInfo();
    }
    VOID AddToResolveChain(
        ICategorizerItem **ppICatItemHead,
        ICategorizerItem **ppICatItemTail,
        ICategorizerItem *pICatItemAdd)
    {
        HRESULT hr = S_OK;

        if(*ppICatItemHead == NULL) {
            _ASSERT(*ppICatItemTail == NULL);
            //
            // The new item is the new head/tail -- set and addref it
            //
            *ppICatItemHead = *ppICatItemTail = pICatItemAdd;
            pICatItemAdd->AddRef();

        } else {
            //
            // Add the new item to the tail of the list
            //
            _VERIFY(SUCCEEDED((*ppICatItemTail)->PutICategorizerItem(
                GetCCategorizer()->GetICatItemChainPropId(),
                pICatItemAdd)));
            
            //
            // Update the new tail
            //
            *ppICatItemTail = pICatItemAdd;
        }
    }

    virtual VOID CallCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pMsg,
        IUnknown **rgpMsgs) {
        
        _ASSERT(m_pfnCatCompletion);
        GetCCategorizer()->CatCompletion(
            m_pfnCatCompletion,
            hr,
            pContext,
            pMsg,
            rgpMsgs);
    }
    DWORD GetNumCatItemProps()
    {
        return GetCCategorizer()->GetNumCatItemProps();
    }
    virtual DWORD GetCatFlags()
    {
        return GetCCategorizer()->GetCatFlags();
    }
    VOID SetSenderResolved(BOOL fResolved);

    VOID SetResolvingSender(BOOL fResolving)
    {
        m_fResolvingSender = fResolving;
    }
    VOID ResolveRecipientAfterSender(CCatRecip *pRecip);

    BOOL IsSenderResolveFinished()
    {
        // only return false if the sender resolve is pending
        return (m_fResolvingSender ? m_fSenderResolved : TRUE);
    }
    ICategorizerParameters *GetICatParams()
    {
        return GetCCategorizer()->GetICatParams();
    }
    VOID Cancel()
    {
        _VERIFY(SUCCEEDED(SetListResolveStatus(
            HRESULT_FROM_WIN32(ERROR_CANCELLED))));
    }
    VOID IncPendingLookups()
    {
        InterlockedIncrement((PLONG)&m_dwcPendingLookups);
    }
    VOID DecrPendingLookups()
    {
        if(InterlockedDecrement((PLONG)&m_dwcPendingLookups) == 0) {
            //
            // The list resolve is finished
            //
            CompleteMessageCategorization();
        }
    }
    VOID GetStoreInsertionContext()
    {
        GetEmailIDStore()->GetInsertionContext(GetResolveListContext());
    }
    VOID ReleaseStoreInsertionContext()
    {
        GetEmailIDStore()->ReleaseInsertionContext(GetResolveListContext());
    }
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest)
    {
        if(FAILED(m_hrListResolveStatus))
            return m_hrListResolveStatus;
        else 
            return GetEmailIDStore()->InsertInsertionRequest(
                GetResolveListContext(),
                pCInsertionRequest);
    }

    HRESULT HrLookupEntryAsync(
        CCatAddr *pCCatAddr)
    {
        if(FAILED(m_hrListResolveStatus))
            return m_hrListResolveStatus;
        else
            return GetEmailIDStore()->LookupEntryAsync(
                pCCatAddr,
                GetResolveListContext());
    }
    PCATPERFBLOCK GetPerfBlock()
    {
        return GetCCategorizer()->GetPerfBlock();
    }
    VOID FinalRelease()
    {
        //
        // Call FinalRelease on CICategorizerMailMsgs to release all
        // mailmsg references
        //
        m_CICategorizerMailMsgs.FinalRelease();
        //
        // Release CCategorizer after releasing all mailmsg references
        //
        m_pCCat->Release();
        //
        // Delete this object
        //
        delete this;
    }

  private:
    DWORD m_Signature;
    LONG  m_lRef;
    CCategorizer *m_pCCat;
    RESOLVE_LIST_CONTEXT m_rlc;
    HRESULT m_hrListResolveStatus;
    PFNCAT_COMPLETION m_pfnCatCompletion;
    LPVOID m_pCompletionContext;
    BOOL m_fSenderResolved;
    BOOL m_fResolvingSender;
    LIST_ENTRY m_li;
    LIST_ENTRY m_listhead_recipients;
    SPIN_LOCK  m_spinlock;
    DWORD m_dwcPendingLookups;
    CICategorizerMailMsgsIMP m_CICategorizerMailMsgs;
    CSinkInsertionRequest m_CSinkInsertionRequest;
    CTopLevelInsertionRequest m_CTopLevelInsertionRequest;

    friend class CCategorizer;
    friend class CCatAddr;
    friend class CIMsgSenderAddr;
    friend class CIMsgRecipListAddr;
    friend class CCatSender;
    friend class CCatRecip;
    friend class CCatDLRecip;
    friend class CICategorizerMailMsgsIMP;
    friend class CSinkInsertionRequest;
    friend class CTopLevelInsertionRequest;
    friend VOID AsyncIMsgCatCompletion(VOID *pContext);
};

//
// class CICategorizerDLListResolveIMP
//  similar to CICategorizerListResolve with Alloc overrided to use
//  CCatDLRecip instead of CCatRecip and additional support for
//  resolving DL's included
//
class CICategorizerDLListResolveIMP :
    public CICategorizerListResolveIMP,
    public CCatDLO<CICategorizerDLListResolveIMP_didx>
{
  public:
    STDMETHOD(AllocICategorizerItem)(
        IN   eSourceType Sourcetype,
        OUT  ICategorizerItem **ppICatItem);

  private:
    CICategorizerDLListResolveIMP(
        CCategorizer *pCCat,
        PFNCAT_COMPLETION pfnCatCompletion,
        PVOID pContext);

    HRESULT Initialize(
        IUnknown *pMsg,
        BOOL fExpandAll = TRUE,
        PBOOL pfMatch = NULL,
        CAT_ADDRESS_TYPE CAType = CAT_UNKNOWNTYPE,
        LPSTR pszAddress = NULL);

    virtual ~CICategorizerDLListResolveIMP();

  private:
    //
    // Methods from CCatDLRecip
    //
    HRESULT HrContinueResolve();

    HRESULT HrNotifyAddress(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPSTR *rgpszAddress);

    DWORD GetCatFlags()
    {
        //
        // We don't want to resolve senders, so mask off this bit
        //
        return (CICategorizerListResolveIMP::GetCatFlags() &
                ~(SMTPDSFLAG_RESOLVESENDER));
    }

  private:
    BOOL    m_fExpandAll;
    CAT_ADDRESS_TYPE m_CAType;
    LPSTR   m_pszAddress;
    PBOOL   m_pfMatch;

    friend class CCategorizer;
    friend class CCatAddr;
    friend class CIMsgSenderAddr;
    friend class CIMsgRecipListAddr;
    friend class CCatSender;
    friend class CCatRecip;
    friend class CCatDLRecip;

};

inline DWORD CSinkInsertionRequest::AddRef()
{
    return m_pCICatListResolve->AddRef();
}
inline DWORD CSinkInsertionRequest::Release()
{
    return m_pCICatListResolve->Release();
}
inline DWORD CTopLevelInsertionRequest::AddRef()
{
    return m_pCICatListResolve->AddRef();
}
inline DWORD CTopLevelInsertionRequest::Release()
{
    return m_pCICatListResolve->Release();
}
inline PCATPERFBLOCK CTopLevelInsertionRequest::GetPerfBlock()
{
    return m_pCICatListResolve->GetPerfBlock();
}

#endif //__ICATLISTRESOLVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\asyncctx.cpp ===
//
// asyncctx.cpp -- This file contains the class implementation for:
//      CAsyncLookupContext
//
// Created:
//      Mar 4, 1997 -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "simparray.cpp"

DWORD CBatchLdapConnection::m_nMaxSearchBlockSize = 0;
DWORD CBatchLdapConnection::m_nMaxPendingSearches = 0;

//+----------------------------------------------------------------------------
//
//  Function:   CBatchLdapConnection::InitializeFromRegistry
//
//  Synopsis:   Static function that looks at registry to determine maximum
//              number of queries that will be compressed into a single query.
//              If the registry key does not exist or there is any other
//              problem reading the key, the value defaults to
//              MAX_SEARCH_BLOCK_SIZE
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------
VOID CBatchLdapConnection::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, MAX_SEARCH_BLOCK_SIZE_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_SEARCH_BLOCK_SIZE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
            dwValue > 0 && dwValue < MAX_SEARCH_BLOCK_SIZE) {

            InterlockedExchange((PLONG) &m_nMaxSearchBlockSize, (LONG)dwValue);
        }

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_PENDING_SEARCHES_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
            dwValue > 0) {

            InterlockedExchange((PLONG) &m_nMaxPendingSearches, (LONG)dwValue);
        }
        RegCloseKey( hkey );
    }
    if(m_nMaxSearchBlockSize == 0)
        m_nMaxSearchBlockSize = MAX_SEARCH_BLOCK_SIZE;
    if(m_nMaxPendingSearches == 0)
        m_nMaxPendingSearches = MAX_PENDING_SEARCHES;
    if(m_nMaxPendingSearches < m_nMaxSearchBlockSize)
        m_nMaxPendingSearches = m_nMaxSearchBlockSize;
}

//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::operator new
//
// Synopsis: Allocate enough memory for this and the specified number
// of SEARCH_REQUEST structurers
//
// Arguments:
//  size: Normal size of object
//  dwNumRequests: Number of props desired in this object
//
// Returns: ptr to allocated memory or NULL
//
// History:
// jstamerj 1999/03/10 16:15:43: Created
//
//-------------------------------------------------------------
void * CSearchRequestBlock::operator new(
    size_t size,
    DWORD dwNumRequests)
{
    DWORD dwSize;
    void  *pmem;
    CSearchRequestBlock *pBlock;

    //
    // Calcualte size in bytes required
    //
    dwSize = size +
             (dwNumRequests*sizeof(SEARCH_REQUEST)) +
             (dwNumRequests*sizeof(ICategorizerItem *));

    pmem = new BYTE[dwSize];

    if(pmem) {

        pBlock = (CSearchRequestBlock *)pmem;
        pBlock->m_dwSignature = SIGNATURE_CSEARCHREQUESTBLOCK;
        pBlock->m_cBlockSize = dwNumRequests;

        pBlock->m_prgSearchRequests = (PSEARCH_REQUEST)
                                      ((PBYTE)pmem + size);

        pBlock->m_rgpICatItems = (ICategorizerItem **)
                                 ((PBYTE)pmem + size +
                                  (dwNumRequests*sizeof(SEARCH_REQUEST)));

        _ASSERT( (DWORD) ((PBYTE)pBlock->m_rgpICatItems +
                          (dwNumRequests*sizeof(ICategorizerItem *)) -
                          (PBYTE)pmem)
                 == dwSize);
    }

    return pmem;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::~CSearchRequestBlock
//
// Synopsis: Release everything we have references to
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 18:45:59: Created
//
//-------------------------------------------------------------
CSearchRequestBlock::~CSearchRequestBlock()
{
    DWORD dwCount;
    //
    // Release all CCatAddrs
    //
    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);

        preq->pCCatAddr->Release();
    }
    //
    // Release all the attr interfaces
    //
    for(dwCount = 0;
        dwCount < m_csaItemAttr.Size();
        dwCount++) {

        ((ICategorizerItemAttributes **)
         m_csaItemAttr)[dwCount]->Release();
    }

    if(m_pISMTPServer)
        m_pISMTPServer->Release();

    if(m_pICatParams)
        m_pICatParams->Release();

    if(m_pszSearchFilter)
        delete m_pszSearchFilter;

    if(m_pConn)
        m_pConn->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CSEARCHREQUESTBLOCK);
    m_dwSignature = SIGNATURE_CSEARCHREQUESTBLOCK_INVALID;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::InsertSearchRequest
//
// Synopsis: Inserts a search request in this block.  When the block
//           is full, dispatch the block to LDAP before returning
//
// Arguments:
//  pISMTPServer: ISMTPServer to use for triggering events
//  pICatParams: ICategorizerParameters to use
//  pCCatAddr: Address item for the search
//  fnSearchCompletion: Async Completion routine
//  ctxSearchCompletion: Context to pass to the async completion routine
//  pszSearchFilter: Search filter to use
//  pszDistinguishingAttribute: The distinguishing attribute for matching
//  pszDistinguishingAttributeValue: above attribute's distinguishing value
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 13:12:20: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::InsertSearchRequest(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams,
    CCatAddr *pCCatAddr,
    LPSEARCHCOMPLETION fnSearchCompletion,
    LPVOID  ctxSearchCompletion,
    LPSTR   pszSearchFilter,
    LPSTR   pszDistinguishingAttribute,
    LPSTR   pszDistinguishingAttributeValue)
{
    PSEARCH_REQUEST preq;
    DWORD dwIndex;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::InsertSearchRequest");
    //
    // Unset any existing HRSTATUS -- the status will be set again in
    // the search completion
    //
    _VERIFY(SUCCEEDED(
        pCCatAddr->UnSetPropId(
            ICATEGORIZERITEM_HRSTATUS)));

    m_pConn->IncrementPendingSearches();

    preq = GetNextSearchRequest(&dwIndex);

    _ASSERT(preq);

    pCCatAddr->AddRef();
    preq->pCCatAddr = pCCatAddr;
    preq->fnSearchCompletion = fnSearchCompletion;
    preq->ctxSearchCompletion = ctxSearchCompletion;
    preq->pszSearchFilter = pszSearchFilter;
    preq->pszDistinguishingAttribute = pszDistinguishingAttribute;
    preq->pszDistinguishingAttributeValue = pszDistinguishingAttributeValue;

    m_rgpICatItems[dwIndex] = pCCatAddr;

    if(dwIndex == 0) {
        //
        // Use the first insertion's ISMTPServer
        //
        _ASSERT(m_pISMTPServer == NULL);
        m_pISMTPServer = pISMTPServer;
        if(m_pISMTPServer)
            m_pISMTPServer->AddRef();

        _ASSERT(m_pICatParams == NULL);
        m_pICatParams = pICatParams;
        m_pICatParams->AddRef();
    }

    //
    // Now dispatch this block if we are the last request to finish
    //
    if( (DWORD) (InterlockedIncrement((PLONG)&m_cBlockRequestsReadyForDispatch)) == m_cBlockSize)
        DispatchBlock();

    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrDispatchBlock
//
// Synopsis: Send the LDAP query for this search request block
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 15:00:44: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::DispatchBlock()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::DispatchBlock");

    m_pConn->RemoveSearchRequestBlockFromList(this);
    //
    // Build up the query string
    //
    hr = HrTriggerBuildQueries();
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "TriggerBuildQueries failed hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // Send the query
    //
    hr = HrTriggerSendQuery();
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "TriggerSendQuery failed hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr)) {
        CompleteBlockWithError(hr);
        delete this;
    }
    //
    // this may be deleted, but that's okay; we're just tracing a user
    // value
    //
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerBuildQueries
//
// Synopsis: Trigger the BuildQueries event
//
// Arguments:
//  pCICatQueries: CICategorizerQueriesIMP object to use
//
// Returns:
//  S_OK: Success
//  error from dispatcher
//
// History:
// jstamerj 1999/03/11 19:03:29: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerBuildQueries()
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATBUILDQUERIES Params;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerBuildQueries");

    Params.pICatParams = m_pICatParams;
    Params.dwcAddresses = DwNumBlockRequests();
    Params.rgpICatItems = m_rgpICatItems;
    Params.pICatQueries = &m_CICatQueries;
    Params.pfnDefault = HrBuildQueriesDefault;
    Params.pblk = this;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT,
            &Params);

    } else {
        //
        // Events are disabled
        //
        hr = HrBuildQueriesDefault(
            S_OK,
            &Params);
    }
    //
    // Make sure somebody really set the query string
    //
    if(SUCCEEDED(hr) &&
       (m_pszSearchFilter == NULL))
        hr = E_FAIL;


    DebugTrace((LPARAM)this, "returning hr %08lx",hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrBuildQueriesDefault
//
// Synopsis: Default implementation of the build queries sink
//
// Arguments:
//  hrStatus: Status of events so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/11 19:42:53: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrBuildQueriesDefault(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATBUILDQUERIES pParams;
    DWORD cReqs, cOrTerms, idx, idxSecondToLastTerm, idxLastTerm;
    DWORD cbSearchFilter, rgcbSearchFilters[MAX_SEARCH_BLOCK_SIZE];
    LPSTR pszSearchFilterNew;
    CSearchRequestBlock *pblk;

    pParams = (PEVENTPARAMS_CATBUILDQUERIES)pContext;
    _ASSERT(pParams);
    pblk = (CSearchRequestBlock *)pParams->pblk;
    _ASSERT(pblk);

    TraceFunctEnterEx((LPARAM)pblk, "CSearchRequestBlock::HrBuildQueriesDefault");

    cReqs = pblk->DwNumBlockRequests();
    _ASSERT( cReqs > 0 );

    cOrTerms = cReqs - 1;
    //
    // Figure out the size of the composite search filter
    //
    cbSearchFilter = 0;

    for (idx = 0; idx < cReqs; idx++) {

        rgcbSearchFilters[idx] =
            strlen(pblk->m_prgSearchRequests[idx].pszSearchFilter);

        cbSearchFilter += rgcbSearchFilters[idx];
    }

    cbSearchFilter += cOrTerms * (sizeof( "(|  )" ) - 1);
    cbSearchFilter++;                            // Terminating NULL.

    pszSearchFilterNew = new CHAR [cbSearchFilter];

    if (pszSearchFilterNew != NULL) {

        idxLastTerm = cReqs - 1;
        idxSecondToLastTerm = idxLastTerm - 1;
        //
        // We special case the cReqs == 1
        //
        if (cReqs == 1) {

            strcpy(
                pszSearchFilterNew,
                pblk->m_prgSearchRequests[0].pszSearchFilter);

        } else {
            //
            // The loop below builds up the block filter all the way up to the
            // last term. For each term, it adds a "(| " to start a new OR
            // term, then adds the OR term itself, then puts a space after the
            // OR term. Also, it puts a matching ")" at the end of the
            // search filter string being built up.
            //
            LPSTR szNextItem = &pszSearchFilterNew[0];
            LPSTR szTerminatingParens =
                &pszSearchFilterNew[cbSearchFilter - 1 - (cReqs-1)];

            pszSearchFilterNew[cbSearchFilter - 1] = 0;

            for (idx = 0; idx <= idxSecondToLastTerm; idx++) {

                strcpy( szNextItem, "(| " );
                szNextItem += sizeof( "(| " ) - 1;

                strcpy(
                    szNextItem,
                    pblk->m_prgSearchRequests[idx].pszSearchFilter);
                szNextItem += rgcbSearchFilters[idx];
                *szNextItem++ = ' ';
                *szTerminatingParens++ = ')';
            }

            //
            // Now, all that remains is to add in the last OR term
            //
            CopyMemory(
                szNextItem,
                pblk->m_prgSearchRequests[idxLastTerm].pszSearchFilter,
                rgcbSearchFilters[idxLastTerm]);

        }

        _ASSERT( ((DWORD) lstrlen(pszSearchFilterNew)) < cbSearchFilter );

        //
        // Save our generated filter string in ICategorizerQueries
        //
        hr = pblk->m_CICatQueries.SetQueryStringNoAlloc(pszSearchFilterNew);

        // There's no good reason for that to fail...
        _ASSERT(SUCCEEDED(hr));

    } else {

        hr = E_OUTOFMEMORY;
    }

    DebugTrace((LPARAM)pblk, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)pblk);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerSendQuery
//
// Synopsis: Trigger the SendQuery event
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/11 20:18:02: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerSendQuery()
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATSENDQUERY Params;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerSendQuery");

    Params.pICatParams            = m_pICatParams;
    Params.pICatQueries           = &m_CICatQueries;
    Params.pICatAsyncContext      = &m_CICatAsyncContext;
    Params.pIMailTransportNotify  = NULL; // These should be set in CStoreParams
    Params.pvNotifyContext        = NULL;
    Params.hrResolutionStatus     = S_OK;
    Params.pblk                   = this;
    Params.pfnDefault             = HrSendQueryDefault;
    Params.pfnCompletion          = HrSendQueryCompletion;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT,
            &Params);

    } else {
        //
        // Events are disabled
        // Heap allocation is required
        //
        PEVENTPARAMS_CATSENDQUERY pParams;
        pParams = new EVENTPARAMS_CATSENDQUERY;
        if(pParams == NULL) {

            hr = E_OUTOFMEMORY;

        } else {
            CopyMemory(pParams, &Params, sizeof(EVENTPARAMS_CATSENDQUERY));
            HrSendQueryDefault(
                S_OK,
                pParams);
        }
    }

    DebugTrace((LPARAM)this, "returning %08lx", (hr == MAILTRANSPORT_S_PENDING) ? S_OK : hr);
    TraceFunctLeaveEx((LPARAM)this);
    return (hr == MAILTRANSPORT_S_PENDING) ? S_OK : hr;
} // CSearchRequestBlock::HrTriggerSendQuery



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSendQueryDefault
//
// Synopsis: The default sink function for the SendQuery event
//
// Arguments:
//  hrStatus: status of the event so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 11:46:24: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSendQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;
    LPWSTR *rgpszAttributes = NULL;
    ICategorizerParametersEx *pIPhatParams = NULL;
    ICategorizerRequestedAttributes *pIRequestedAttributes = NULL;

    pParams = (PEVENTPARAMS_CATSENDQUERY) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);
    TraceFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSendQueryDefault");
    hr = pParams->pICatParams->QueryInterface(
        IID_ICategorizerParametersEx,
        (LPVOID *)&pIPhatParams);

    if(FAILED(hr)) {
        pIPhatParams = NULL;
        goto CLEANUP;
    }

    hr = pIPhatParams->GetRequestedAttributes(
        &pIRequestedAttributes);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRequestedAttributes->GetAllAttributesW(
        &rgpszAttributes);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pBlock->m_pConn->AsyncSearch(
        pBlock->m_pConn->GetNamingContextW(),
        LDAP_SCOPE_SUBTREE,
        pBlock->m_pszSearchFilter,
        (LPCWSTR *)rgpszAttributes,
        0,                      // Do not do a paged search
        LDAPCompletion,
        pParams);

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)pBlock, "HrSendQueryDefault failing hr %08lx", hr);
        //
        // Call the completion routine directly with the error
        //
        hr = pParams->pICatAsyncContext->CompleteQuery(
            pParams,                    // Query context
            hr,                         // Status
            0,                          // dwcResults
            NULL,                       // rgpItemAttributes,
            TRUE);                      // fFinalCompletion
        //
        // CompleteQuery should not fail
        //
        _ASSERT(SUCCEEDED(hr));
    }
    if(pIRequestedAttributes)
        pIRequestedAttributes->Release();
    if(pIPhatParams)
        pIPhatParams->Release();

    TraceFunctLeaveEx((LPARAM)pBlock);
    return MAILTRANSPORT_S_PENDING;
} // CSearchRequestBlock::HrSendQueryDefault


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::LDAPCompletion
//
// Synopsis: Wrapper for the default processing completion of SendQuery
//
//  Arguments:  [ctx] -- Opaque pointer to EVENTPARAMS_SENDQUERY being
//                       completed
//              [dwNumReults] -- The number of objects found
//              [rgpICatItemAttributes] -- An array of
//              ICategorizerItemAttributes; one per object found
//              [hrStatus] -- The error code if the search request failed
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
//
// Returns: Nothing
//
// History:
// jstamerj 1999/03/16 12:23:54: Created
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::LDAPCompletion(
    LPVOID ctx,
    DWORD dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttributes,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    pParams = (PEVENTPARAMS_CATSENDQUERY) ctx;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    TraceFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::LDAPCompletion");

    //
    // Call the normal sink completion routine
    //
    hr = pParams->pICatAsyncContext->CompleteQuery(
        pParams,                    // Query Context
        hrStatus,                   // Status
        dwNumResults,               // dwcResults
        rgpICatItemAttributes,      // rgpItemAttributes
        fFinalCompletion);          // Is this the final completion for the query?

    _ASSERT(SUCCEEDED(hr));

    TraceFunctLeaveEx((LPARAM)pBlock);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSendQueryCompletion
//
// Synopsis: The completion routine for the SendQuery event
//
// Arguments:
//  hrStatus: status of the event so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 12:52:22: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSendQueryCompletion(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    pParams = (PEVENTPARAMS_CATSENDQUERY) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    TraceFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSendQueryCompletion");

    pBlock->CompleteSearchBlock(
        pParams->hrResolutionStatus);

    if(pBlock->m_pISMTPServer == NULL) {
        //
        // Events are disabled
        // We must free the eventparams
        //
        delete pParams;
    }
    //
    // The purpose of this block is complete.  Today is a good day to
    // die!
    // -- Lt. Commander Worf
    //
    delete pBlock;

    TraceFunctLeaveEx((LPARAM)pBlock);
    return S_OK;
} // HrSendQueryCompletion


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::CompleteSearchBlock
//
// Synopsis: Completion routine when the SendQuery event is done
//
// Arguments:
//  hrStatus: Resolution status
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 13:36:33: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::CompleteSearchBlock(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    HRESULT hrFetch, hrResult;
    DWORD dwCount;
    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::CompleteSearchBlock");

    hr = HrTriggerSortQueryResult(hrStatus);
    if(FAILED(hr))
        goto CLEANUP;

    //
    // Check every ICategorizerItem
    // If any one of them does not have an hrStatus set, set it to
    // HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
    //
    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        hrFetch = m_rgpICatItems[dwCount]->GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hrResult);

        if(FAILED(hrFetch)) {
            _ASSERT(hrFetch == CAT_E_PROPNOTFOUND);
            _VERIFY(SUCCEEDED(
                m_rgpICatItems[dwCount]->PutHRESULT(
                    ICATEGORIZERITEM_HRSTATUS,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))));
        }
    }

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Failing block hr %08lx", hr);
        PutBlockHRESULT(hr);
    }
    //
    // Call all the individual completion routines
    //
    CallCompletions();

    TraceFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::CompleteSearchBlock



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::PutBlockHRESULT
//
// Synopsis: Set the status of every ICatItem in the block to some hr
//
// Arguments:
//  hr: Status to set
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:03:30: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::PutBlockHRESULT(
    HRESULT hr)
{
    DWORD dwCount;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::PutBlockHRESULT");
    DebugTrace((LPARAM)this, "hr = %08lx", hr);

    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);
        //
        // Set the error status
        //
        _VERIFY(SUCCEEDED(preq->pCCatAddr->PutHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            hr)));
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::PutBlockHRESULT


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::CallCompletions
//
// Synopsis: Call the completion routine of every item in the block
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:05:50: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::CallCompletions()
{
    DWORD dwCount;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::CallCompletions");
    //
    // Get an Insertion context before calling completions so that
    // newly inserted searches will be batched
    //
    m_pConn->GetInsertionContext();

    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);

        preq->fnSearchCompletion(
            preq->pCCatAddr,
            preq->ctxSearchCompletion,
            m_pConn);
    }

    m_pConn->DecrementPendingSearches(
        DwNumBlockRequests());

    m_pConn->ReleaseInsertionContext();

    TraceFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::CallCompletions



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerSortQueryResult
//
// Synopsis: Trigger the SortQueryResult event
//
// Arguments:
//  hrStatus: Status of Resolution
//
// Returns:
//  S_OK: Success
//  error from the dispatcher
//
// History:
// jstamerj 1999/03/16 14:09:12: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerSortQueryResult(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATSORTQUERYRESULT Params;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerSortQueryResult");

    Params.pICatParams = m_pICatParams;
    Params.hrResolutionStatus = hrStatus;
    Params.dwcAddresses = DwNumBlockRequests();
    Params.rgpICatItems = m_rgpICatItems;
    Params.dwcResults = m_csaItemAttr.Size();
    Params.rgpICatItemAttributes = m_csaItemAttr;
    Params.pfnDefault = HrSortQueryResultDefault;
    Params.pblk = this;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT,
            &Params);

    } else {
        //
        // Events are disabled, call default processing
        //
        HrSortQueryResultDefault(
            S_OK,
            &Params);
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSearchRequestBlock::HrTriggerSortQueryResult


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSortQueryResultDefault
//
// Synopsis: Default sink for SortQueryResult -- match the objects found
//           with the objects requested
//
// Arguments:
//  hrStatus: Status of events
//  pContext: Params context for this event
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 14:17:49: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSortQueryResultDefault(
    HRESULT hrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSORTQUERYRESULT pParams;
    CSearchRequestBlock *pBlock;
    DWORD dwAttrIndex, dwReqIndex;
    ATTRIBUTE_ENUMERATOR enumerator;

    pParams = (PEVENTPARAMS_CATSORTQUERYRESULT) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    TraceFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSortQueryResultDefault");
    DebugTrace((LPARAM)pBlock, "hrResolutionStatus %08lx, dwcResults %08lx",
               pParams->hrResolutionStatus, pParams->dwcResults);

    if(FAILED(pParams->hrResolutionStatus)) {
        //
        // Fail the entire block
        //
        pBlock->PutBlockHRESULT(pParams->hrResolutionStatus);
        goto CLEANUP;
    }
    //
    // Resolution succeeded
    // If dwcResults is not zero, then rgpICatItemAttrs can NOT be null
    //
    _ASSERT((pParams->dwcResults == 0) ||
            (pParams->rgpICatItemAttributes != NULL));

    //
    // Loop through every rgpICatItemAttrs.  For each
    // ICategorizerItemAttributes, looking for a matching SEARCH_REQUEST
    //
    for(dwAttrIndex = 0; dwAttrIndex < pParams->dwcResults; dwAttrIndex++) {
        ICategorizerItemAttributes *pICatItemAttr = NULL;
        ICategorizerUTF8Attributes *pIUTF8 = NULL;

        pICatItemAttr = pParams->rgpICatItemAttributes[dwAttrIndex];
        LPCSTR pszLastDistinguishingAttribute = NULL;
        BOOL fEnumerating = FALSE;

        hr = pICatItemAttr->QueryInterface(
            IID_ICategorizerUTF8Attributes,
            (LPVOID *) &pIUTF8);
        if(FAILED(hr))
            goto CLEANUP;

        for(dwReqIndex = 0; dwReqIndex < pBlock->DwNumBlockRequests();
            dwReqIndex++) {
            PSEARCH_REQUEST preq = &(pBlock->m_prgSearchRequests[dwReqIndex]);

            //
            // If we don't have a distinguishing attribute and
            // distinguishing attribute value for this search
            // request, we've no hope of matching it up
            //
            if((preq->pszDistinguishingAttribute == NULL) ||
               (preq->pszDistinguishingAttributeValue == NULL))
                continue;

            //
            // Start an attribute value enumeration if necessary
            //
            if((pszLastDistinguishingAttribute == NULL) ||
               (lstrcmpi(pszLastDistinguishingAttribute,
                         preq->pszDistinguishingAttribute) != 0)) {
                if(fEnumerating) {
                    pIUTF8->EndUTF8AttributeEnumeration(&enumerator);
                }
                hr = pIUTF8->BeginUTF8AttributeEnumeration(
                    preq->pszDistinguishingAttribute,
                    &enumerator);
                fEnumerating = SUCCEEDED(hr);
                pszLastDistinguishingAttribute = preq->pszDistinguishingAttribute;
            } else {
                //
                // else just rewind our current enumeration
                //
                if(fEnumerating)
                    _VERIFY(SUCCEEDED(pIUTF8->RewindUTF8AttributeEnumeration(
                        &enumerator)));
            }
            //
            // If we can't enumerate through the distinguishing
            // attribute, there's no hope in matching up requests
            //
            if(!fEnumerating)
                continue;

            //
            // See if the distinguishing attribute value matches
            //
            LPSTR pszDistinguishingAttributeValue;
            hr = pIUTF8->GetNextUTF8AttributeValue(
                &enumerator,
                &pszDistinguishingAttributeValue);
            while(SUCCEEDED(hr)) {
                if(lstrcmpi(
                    pszDistinguishingAttributeValue,
                    preq->pszDistinguishingAttributeValue) == 0) {

                    DebugTrace((LPARAM)pBlock, "Matched dwAttrIndex %d with dwReqIndex %d", dwAttrIndex, dwReqIndex);
                    pBlock->MatchItem(
                        preq->pCCatAddr,
                        pICatItemAttr);
                }
                hr = pIUTF8->GetNextUTF8AttributeValue(
                    &enumerator,
                    &pszDistinguishingAttributeValue);
            }
        }
        //
        // End any last enumeration going on
        //
        if(fEnumerating)
            pIUTF8->EndUTF8AttributeEnumeration(&enumerator);
        fEnumerating = FALSE;
        if(pIUTF8) {
            pIUTF8->Release();
            pIUTF8 = NULL;
        }
    }

 CLEANUP:
    TraceFunctLeaveEx((LPARAM)pBlock);
    return S_OK;
} // CSearchRequestBlock::HrSortQueryResultDefault


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::MatchItem
//
// Synopsis: Match a particular ICategorizerItem to a particular ICategorizerItemAttributes
// If already matched with an ICategorizerItemAttributes with an
// identical ID then set item status to CAT_E_MULTIPLE_MATCHES
// If already matched with an ICategorizerItemAttributes with a
// different ID then attempt aggregation
////
// Arguments:
//  pICatItem: an ICategorizerItem
//  pICatItemAttr: the matching attribute interface for pICatItem
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:36:45: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::MatchItem(
    ICategorizerItem *pICatItem,
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr = S_OK;
    ICategorizerItemAttributes *pICatItemAttr_Current = NULL;

    TraceFunctEnterEx((LPARAM)this, "CSearchRequestBlock::MatchItem");

    _ASSERT(pICatItem);
    _ASSERT(pICatItemAttr);
    //
    // Check to see if this item already has
    // ICategorizerItemAttributes set
    //
    hr = pICatItem->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr_Current);
    if(SUCCEEDED(hr)) {
        //
        // This guy is already matched.  Is the duplicate from the
        // same resolver sink?
        //
        GUID GOriginal, GNew;
        GOriginal = pICatItemAttr_Current->GetTransportSinkID();
        GNew = pICatItemAttr->GetTransportSinkID();

        if(GOriginal == GNew) {
            //
            // Two matches from the same resolver sink indicates that
            // there are multiple matches for this object.  This is an
            // error.
            //

            //
            // This guy is already matched -- the distinguishing attribute
            // really wasn't distinguishing.  Set error hrstatus.
            //
            _VERIFY(SUCCEEDED(
                pICatItem->PutHRESULT(
                    ICATEGORIZERITEM_HRSTATUS,
                    CAT_E_MULTIPLE_MATCHES)));
        } else {

            //
            // We have multiple matches from different resolver
            // sinks.  Let's try to aggregate the new
            // ICategorizerItemAttributes
            //

            hr = pICatItemAttr_Current->AggregateAttributes(
                pICatItemAttr);

            if(FAILED(hr) && (hr != E_NOTIMPL)) {
                //
                // Fail categorization for this item
                //
                _VERIFY(SUCCEEDED(
                    pICatItem->PutHRESULT(
                        ICATEGORIZERITEM_HRSTATUS,
                        hr)));
            }
        }
    } else {
        //
        // Normal case -- set the ICategorizerItemAttribute property
        // of ICategorizerItem
        //
        _VERIFY(SUCCEEDED(
            pICatItem->PutICategorizerItemAttributes(
                ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
                pICatItemAttr)));
        //
        // Set hrStatus of this guy to success
        //
        _VERIFY(SUCCEEDED(
            pICatItem->PutHRESULT(
                ICATEGORIZERITEM_HRSTATUS,
                S_OK)));
    }

    if(pICatItemAttr_Current)
        pICatItemAttr_Current->Release();

    TraceFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::MatchItem



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::HrInsertSearchRequest
//
// Synopsis: Insert a search request
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for triggering events
//  pCCatAddr: Address item for the search
//  fnSearchCompletion: Async Completion routine
//  ctxSearchCompletion: Context to pass to the async completion routine
//  pszSearchFilter: Search filter to use
//  pszDistinguishingAttribute: The distinguishing attribute for matching
//  pszDistinguishingAttributeValue: above attribute's distinguishing value
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/08 19:41:37: Created.
//
//-------------------------------------------------------------
HRESULT CBatchLdapConnection::HrInsertSearchRequest(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams,
    CCatAddr *pCCatAddr,
    LPSEARCHCOMPLETION fnSearchCompletion,
    LPVOID  ctxSearchCompletion,
    LPSTR   pszSearchFilter,
    LPSTR   pszDistinguishingAttribute,
    LPSTR   pszDistinguishingAttributeValue)
{
    HRESULT hr = S_OK;
    CSearchRequestBlock *pBlock;

    TraceFunctEnterEx((LPARAM)this, "CBatchLdapConnection::HrInsertSearchRequest");

    _ASSERT(m_cInsertionContext);
    _ASSERT(pCCatAddr);
    _ASSERT(fnSearchCompletion);
    _ASSERT(pszSearchFilter);
    _ASSERT(pszDistinguishingAttribute);
    _ASSERT(pszDistinguishingAttributeValue);

    pBlock = GetSearchRequestBlock();

    if(pBlock == NULL) {

        ErrorTrace((LPARAM)this, "out of memory getting a search block");
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    pBlock->InsertSearchRequest(
        pISMTPServer,
        pICatParams,
        pCCatAddr,
        fnSearchCompletion,
        ctxSearchCompletion,
        pszSearchFilter,
        pszDistinguishingAttribute,
        pszDistinguishingAttributeValue);

 CLEANUP:
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::GetSearchRequestBlock
//
// Synopsis: Gets the next available search block with room
//
// Arguments: NONE
//
// Returns:
//  NULL: Out of memory
//  else, a search block object
//
// History:
// jstamerj 1999/03/08 19:41:37: Created.
//
//-------------------------------------------------------------
CSearchRequestBlock * CBatchLdapConnection::GetSearchRequestBlock()
{
    HRESULT hr = E_FAIL;
    PLIST_ENTRY ple;
    CSearchRequestBlock *pBlock = NULL;

    AcquireSpinLock(&m_spinlock);
    //
    // See if there is an insertion block with available slots
    //
    for(ple = m_listhead.Flink;
        (ple != &m_listhead) && (FAILED(hr));
        ple = ple->Flink) {

        pBlock = CONTAINING_RECORD(ple, CSearchRequestBlock, m_listentry);

        hr = pBlock->ReserveSlot();
    }

    ReleaseSpinLock(&m_spinlock);

    if(SUCCEEDED(hr))
        return pBlock;

    //
    // Create a block
    //
    pBlock = new (m_nMaxSearchBlockSize) CSearchRequestBlock(this);
    if(pBlock) {
        //
        // Reserve a slot for us and add to the list
        //
        hr = pBlock->ReserveSlot();
        _ASSERT(SUCCEEDED(hr));

        AcquireSpinLock(&m_spinlock);
        InsertTailList(&m_listhead, &(pBlock->m_listentry));
        ReleaseSpinLock(&m_spinlock);
    }
    return pBlock;
}


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::DispatchBlocks
//
// Synopsis: Dispatch all the blocks in a list
//
// Arguments:
//  plisthead: List to dispatch
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 15:16:36: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::DispatchBlocks(
    PLIST_ENTRY plisthead)
{
    PLIST_ENTRY ple, ple_next;
    CSearchRequestBlock *pBlock;

    for(ple = plisthead->Flink;
        ple != plisthead;
        ple = ple_next) {

        ple_next = ple->Flink;

        pBlock = CONTAINING_RECORD(ple, CSearchRequestBlock,
                                   m_listentry);

        pBlock->DispatchBlock();
    }
}


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::CStoreListResolveContext
//
// Synopsis: Construct a CStoreListResolveContext object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 12:16:08: Created.
//
//-------------------------------------------------------------
CStoreListResolveContext::CStoreListResolveContext(
    CEmailIDLdapStore<CCatAddr> *pStore)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::CStoreListResolveContext");

    m_dwSignature = SIGNATURE_CSTORELISTRESOLVECONTEXT;
    m_pConn = NULL;
    m_fCanceled = FALSE;
    m_dwcRetries = 0;
    InitializeSpinLock(&m_spinlock);
    m_pISMTPServer = NULL;
    m_pICatParams = NULL;
    m_dwcInsertionContext = 0;
    m_pStore = pStore;

    TraceFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::CStoreListResolveContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::~CStoreListResolveContext
//
// Synopsis: Destruct a list resolve context
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 12:18:01: Created.
//
//-------------------------------------------------------------
CStoreListResolveContext::~CStoreListResolveContext()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::~CStoreListResolveContext");

    _ASSERT(m_dwSignature == SIGNATURE_CSTORELISTRESOLVECONTEXT);
    m_dwSignature = SIGNATURE_CSTORELISTRESOLVECONTEXT_INVALID;

    if(m_pConn)
        m_pConn->Release();

    if(m_pISMTPServer)
        m_pISMTPServer->Release();

    if(m_pICatParams)
        m_pICatParams->Release();

    TraceFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::~CStoreListResolveContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInitialize
//
// Synopsis: Initailize this object so that it is ready to handle lookups
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for triggering events
//  pICatParams:  ICatParams interface to use
//
//  Note: All of these string buffers must remain valid for the
//        lifetime of this object!
//  pszAccount: LDAP account to use for binding
//  pszPassword: LDAP password to use
//  pszNamingContext: Naming context to use for searches
//  pszHost: LDAP Host to connect to
//  dwPort: LDAP TCP port to use
//  bt: Method of LDAP bind to use
//
// Returns:
//  S_OK: Success
//  error from LdapConnectionCache
//
// History:
// jstamerj 1999/03/22 12:20:31: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInitialize(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrInitialize");

    _ASSERT(m_pISMTPServer == NULL);
    _ASSERT(m_pICatParams == NULL);
    _ASSERT(pICatParams != NULL);

    if(pISMTPServer) {
        m_pISMTPServer = pISMTPServer;
        m_pISMTPServer->AddRef();
    }
    if(pICatParams) {
        m_pICatParams = pICatParams;
        m_pICatParams->AddRef();
    }

    hr = m_pStore->HrGetConnection(
        &m_pConn);

    if(FAILED(hr))
        m_pConn = NULL;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrInitialize



//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrLookupEntryAsync
//
// Synopsis: Dispatch an async LDAP lookup
//
// Arguments:
//  pCCatAddr: Address object to lookup
//
// Returns:
//  S_OK: Success
//  error from LdapConn
//
// History:
// jstamerj 1999/03/22 12:28:52: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrLookupEntryAsync(
    CCatAddr *pCCatAddr)
{
    HRESULT hr = S_OK;
    LPSTR pszSearchFilter = NULL;
    LPSTR pszDistinguishingAttribute = NULL;
    LPSTR pszDistinguishingAttributeValue = NULL;
    BOOL  fTryAgain;

    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrLookupEntryAsync");

    //
    // Addref the CCatAddr here, release after completion
    //
    pCCatAddr->AddRef();

    hr = pCCatAddr->HrTriggerBuildQuery();

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Fetch the distinguishing attribute and distinguishing attribute
    // value from pCCatAddr
    //
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        &pszSearchFilter);
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
        &pszDistinguishingAttribute);
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
        &pszDistinguishingAttributeValue);

    //
    // Check to see if anyone set a search filter
    //
    if(pszSearchFilter == NULL) {

        HRESULT hrStatus;
        //
        // If the status is unset, set it to CAT_E_NO_FILTER
        //
        hr = pCCatAddr->GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hrStatus);

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "No search filter set");

            _VERIFY(SUCCEEDED(pCCatAddr->PutHRESULT(
                ICATEGORIZERITEM_HRSTATUS,
                CAT_E_NO_FILTER)));
        }
        DebugTrace((LPARAM)this, "BuildQuery did not build a search filter");
        //
        // Call the completion directly
        //
        pCCatAddr->LookupCompletion();
        pCCatAddr->Release();
        hr = S_OK;
        goto CLEANUP;
    }
    if((pszDistinguishingAttribute == NULL) ||
       (pszDistinguishingAttributeValue == NULL)) {
        ErrorTrace((LPARAM)this, "Distinguishing attribute not set");
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    do {

        fTryAgain = FALSE;
        CBatchLdapConnection *pConn;

        pConn = GetConnection();

        //
        // Insert the search request into the CBatchLdapConnection
        // object. We will use the email address as the distinguishing
        // attribute
        //
        if(pConn == NULL) {

            hr = CAT_E_DBCONNECTION;

        } else {

            pConn->GetInsertionContext();

            hr = pConn->HrInsertSearchRequest(
                m_pISMTPServer,
                m_pICatParams,
                pCCatAddr,
                CStoreListResolveContext::AsyncLookupCompletion,
                (LPVOID) this,
                pszSearchFilter,
                pszDistinguishingAttribute,
                pszDistinguishingAttributeValue);

            pConn->ReleaseInsertionContext();
        }
        //
        // If the above fails with CAT_E_TRANX_FAILED, it may be due
        // to a stale connection.  Attempt to reconnect.
        //
        if((hr == CAT_E_TRANX_FAILED) || (hr == CAT_E_DBCONNECTION))

            fTryAgain = SUCCEEDED(
                HrInvalidateConnectionAndRetrieveNewConnection(pConn));

        if(pConn != NULL)
            pConn->Release();

    } while(fTryAgain);

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "failing hr %08lx", hr);
        pCCatAddr->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrLookupEntryAsync


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::Cancel
//
// Synopsis: Cancels pending lookups
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/22 12:45:21: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::Cancel()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::Cancel");

    AcquireSpinLock(&m_spinlock);

    m_fCanceled = TRUE;
    m_pConn->CancelAllSearches();

    ReleaseSpinLock(&m_spinlock);

    TraceFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::HrCancel


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::AsyncLookupCompletion
//
// Synopsis: Handle completion of a CCatAddr from CSearchRequestBlock
//
// Arguments:
//  pCCatAddr: the item being completed
//  lpContext: Context passed to InsertSearchRequest
//  pConn: Connection object used to do the search
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 14:37:09: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::AsyncLookupCompletion(
    CCatAddr *pCCatAddr,
    LPVOID    lpContext,
    CBatchLdapConnection *pConn)
{
    HRESULT hr = S_OK;
    HRESULT hrStatus;
    CStoreListResolveContext *pslrc;

    TraceFunctEnterEx((LPARAM)lpContext,
                      "CStoreListResolveContext::AsyncLookupCompletion");

    pslrc = (CStoreListResolveContext *)lpContext;

    _ASSERT(pCCatAddr);

    hr = pCCatAddr->GetHRESULT(
        ICATEGORIZERITEM_HRSTATUS,
        &hrStatus);
    _ASSERT(SUCCEEDED(hr));

    if( (hrStatus == CAT_E_DBCONNECTION) &&
        SUCCEEDED(pslrc->HrInvalidateConnectionAndRetrieveNewConnection(pConn))) {
        //
        // Retry the search with the new connection
        //
        hr = pslrc->HrLookupEntryAsync(pCCatAddr);
        if(FAILED(hr))
            pCCatAddr->LookupCompletion();

    } else {

        pCCatAddr->LookupCompletion();
    }
    pCCatAddr->Release(); // Release reference count addref'd in LookupEntryAsync

    TraceFunctLeaveEx((LPARAM)lpContext);
} // CStoreListResolveContext::AsyncLookupCompletion



//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection
//
// Synopsis: Invalidate our current connection and get a new connection
//
// Arguments:
//  pConn: The old LDAP connection
//
// Returns:
//  S_OK: Success
//  CAT_E_MAX_RETRIES: Too many retries already
//  or error from ldapconn
//
// History:
// jstamerj 1999/03/22 14:50:07: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection(
    CBatchLdapConnection *pConn)
{
    HRESULT hr = S_OK;
    CCfgConnection *pNewConn = NULL;
    CCfgConnection *pOldConn = NULL;
    DWORD dwCount;
    DWORD dwcInsertionContext;

    TraceFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection");

    DebugTrace((LPARAM)this, "pConn: %08lx", pConn);

    AcquireSpinLock(&m_spinlock);

    DebugTrace((LPARAM)this, "m_pConn: %08lx", (CBatchLdapConnection *)m_pConn);

    if(pConn != m_pConn) {

        DebugTrace((LPARAM)this, "Connection already invalidated");
        //
        // We have already invalidated this connection
        //
        ReleaseSpinLock(&m_spinlock);
        hr = S_OK;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Invalidating conn %08lx",
               (CBatchLdapConnection *)m_pConn);
    m_pConn->Invalidate();

    if(InterlockedIncrement((PLONG)&m_dwcRetries) >
       MAX_CONNECTION_RETRIES) {

        ErrorTrace((LPARAM)this, "Over max retry limit");

        ReleaseSpinLock(&m_spinlock);
        hr = CAT_E_MAX_RETRIES;
        goto CLEANUP;

    } else {

        hr = m_pStore->HrGetConnection(
            &pNewConn);

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "HrGetConnection failed hr %08lx", hr);
            ReleaseSpinLock(&m_spinlock);
            goto CLEANUP;
        }

        DebugTrace((LPARAM)this, "pNewConn: %08lx", pNewConn);

        //
        // Switch-a-roo
        //
        pOldConn = m_pConn;
        m_pConn = pNewConn;

        DebugTrace((LPARAM)this, "m_dwcInsertionContext: %08lx",
                   m_dwcInsertionContext);
        //
        // Get insertion contexts on the new connection
        //
        dwcInsertionContext = m_dwcInsertionContext;

        for(dwCount = 0;
            dwCount < dwcInsertionContext;
            dwCount++) {

            pNewConn->GetInsertionContext();
        }
        ReleaseSpinLock(&m_spinlock);

        //
        // Release insertion contexts on the old connection
        //
        for(dwCount = 0;
            dwCount < dwcInsertionContext;
            dwCount++) {

            pOldConn->ReleaseInsertionContext();
        }

        pOldConn->Release();
    }
 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::HrInsertInsertionRequest
//
// Synopsis: Queues an insertion request
//
// Arguments: pCInsertionRequest: the insertion context to queue up
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/24 16:51:10: Created.
//
//-------------------------------------------------------------
HRESULT CBatchLdapConnection::HrInsertInsertionRequest(
    CInsertionRequest *pCInsertionRequest)
{
    TraceFunctEnterEx((LPARAM)this, "CBatchLdapConnection::HrInsertInsertionRequest");

    //
    // Add this thing to the queue and then call
    // DecrementPendingSearches to dispatch available requests
    //
    pCInsertionRequest->AddRef();
    GetInsertionContext();

    AcquireSpinLock(&m_spinlock_insertionrequests);

    InsertTailList(&m_listhead_insertionrequests,
                   &(pCInsertionRequest->m_listentry_insertionrequest));

    ReleaseSpinLock(&m_spinlock_insertionrequests);

    DecrementPendingSearches(0); // Decrement zero searches

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
} // CBatchLdapConnection::HrInsertInsertionRequest


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::DecrementPendingSearches
//
// Synopsis: Decrement the pending LDAP search count and issue
//           searches if we are below MAX_PENDING_SEARCHES and items
//           are left in the InsertionRequestQueue
//
// Arguments:
//  dwcSearches: Amount to decrement by
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 17:09:38: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::DecrementPendingSearches(
    DWORD dwcSearches)
{
    HRESULT hr;
    DWORD dwcSearchesToDecrement = dwcSearches;
    DWORD dwcSearchesReserved;
    DWORD dwcDispatched;
    CInsertionRequest *pCInsertionRequest = NULL;
    BOOL fLoop = TRUE;
    CANCELNOTIFY cn;

    TraceFunctEnterEx((LPARAM)this, "CBatchLdapConnection::DecrementPendingSearches");

    //
    // The module that calls us (CStoreListResolve) has a reference to
    // us (obviously).  However, it may release us when a search
    // fails, for example inside of
    // pCInsertionRequest->HrInsertSearches().  Since we need to
    // continue to access member data in this situation, AddRef() here
    // and Release() at the end of this function.
    //
    AddRef();

    //
    // Decrement the count first
    //
    AcquireSpinLock(&m_spinlock_insertionrequests);
    m_dwcPendingSearches -= dwcSearchesToDecrement;
    ReleaseSpinLock(&m_spinlock_insertionrequests);
    //
    // Now dispatch any insertion requests we can dispatch
    //
    while(fLoop) {

        pCInsertionRequest = NULL;
        AcquireSpinLock(&m_spinlock_insertionrequests);

        if( ((m_dwcPendingSearches + m_dwcReservedSearches) <
             m_nMaxPendingSearches) &&
            (!IsListEmpty(&m_listhead_insertionrequests))) {

            dwcSearchesReserved = min(
                m_nMaxPendingSearches - (m_dwcPendingSearches + m_dwcReservedSearches),
                m_nMaxPendingSearches / 10);

            pCInsertionRequest = CONTAINING_RECORD(
                m_listhead_insertionrequests.Flink,
                CInsertionRequest,
                m_listentry_insertionrequest);

            m_dwcReservedSearches += dwcSearchesReserved;

            RemoveEntryList(m_listhead_insertionrequests.Flink);
            //
            // Insert a cancel-Notify structure so that we know if we
            // should cancel this insertion request (ie. not reinsert)
            //
            cn.hrCancel = S_OK;
            InsertTailList(&m_listhead_cancelnotifies, &(cn.le));

        } else {
            //
            // There are no requests or no room to insert
            // requests...Break out of the loop
            //
            fLoop = FALSE;
        }
        ReleaseSpinLock(&m_spinlock_insertionrequests);

        if(pCInsertionRequest) {
            //
            // Dispatch up to dwcSearchesReserved searches
            //
            dwcDispatched = 0;
            hr = pCInsertionRequest->HrInsertSearches(
                dwcSearchesReserved,
                &dwcDispatched);

            if(FAILED(hr) || (dwcDispatched < dwcSearchesReserved)) {
                pCInsertionRequest->NotifyDeQueue(hr);
                pCInsertionRequest->Release();
                ReleaseInsertionContext();

                //
                // Release the reserved amount (it has now been dispatched)
                //
                AcquireSpinLock(&m_spinlock_insertionrequests);
                m_dwcReservedSearches -= dwcSearchesReserved;
                //
                // Remove the cancel notify
                //
                RemoveEntryList(&(cn.le));
                ReleaseSpinLock(&m_spinlock_insertionrequests);

            } else {
                //
                // There is more work to be done in this block; insert it
                // back into the queue
                //
                AcquireSpinLock(&m_spinlock_insertionrequests);
                //
                // Release the reserved amount
                //
                m_dwcReservedSearches -= dwcSearchesReserved;

                //
                // Remove the cancel notify
                //
                RemoveEntryList(&(cn.le));

                //
                // If we are NOT cancelling, then insert back into the queue
                //
                if(cn.hrCancel == S_OK) {

                    InsertHeadList(&m_listhead_insertionrequests,
                                   &(pCInsertionRequest->m_listentry_insertionrequest));
                }
                ReleaseSpinLock(&m_spinlock_insertionrequests);

                //
                // If we are cancelling, then release this insertion request
                //
                if(cn.hrCancel != S_OK) {

                    pCInsertionRequest->NotifyDeQueue(cn.hrCancel);
                    pCInsertionRequest->Release();
                    ReleaseInsertionContext();
                }
            }
        }
    }
    Release();
    TraceFunctLeaveEx((LPARAM)this);
} // CBatchLdapConnection::DecrementPendingSearches



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::CancelAllSearches
//
// Synopsis: Cancels all outstanding searches
//
// Arguments:
//  hr: optinal reason for cancelling the searches
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 11:44:30: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::CancelAllSearches(
    HRESULT hr)
{
    LIST_ENTRY listhead;
    PLIST_ENTRY ple;
    CInsertionRequest *pCInsertionRequest;

    TraceFunctEnterEx((LPARAM)this, "CBatchLdapConnection::CancelAllSearches");

    _ASSERT(hr != S_OK);

    AcquireSpinLock(&m_spinlock_insertionrequests);
    //
    // Grab the list
    //
    if(!IsListEmpty(&m_listhead_insertionrequests)) {

        CopyMemory(&listhead, &m_listhead_insertionrequests, sizeof(LIST_ENTRY));
        listhead.Flink->Blink = &listhead;
        listhead.Blink->Flink = &listhead;
        InitializeListHead(&m_listhead_insertionrequests);

    } else {

        InitializeListHead(&listhead);
    }
    //
    // Traverse the cancel notify list and set each hresult
    //
    for(ple = m_listhead_cancelnotifies.Flink;
        ple != &m_listhead_cancelnotifies;
        ple = ple->Flink) {

        PCANCELNOTIFY pcn;
        pcn = CONTAINING_RECORD(ple, CANCELNOTIFY, le);
        pcn->hrCancel = hr;
    }

    ReleaseSpinLock(&m_spinlock_insertionrequests);

    for(ple = listhead.Flink;
        ple != &listhead;
        ple = listhead.Flink) {

        pCInsertionRequest = CONTAINING_RECORD(
            ple,
            CInsertionRequest,
            m_listentry_insertionrequest);

        RemoveEntryList(&(pCInsertionRequest->m_listentry_insertionrequest));
        pCInsertionRequest->NotifyDeQueue(hr);
        pCInsertionRequest->Release();
        ReleaseInsertionContext();
    }
    CCachedLdapConnection::CancelAllSearches(hr);

    TraceFunctLeaveEx((LPARAM)this);
} // CBatchLdapConnection::CancelAllSearches


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::GetConnection
//
// Synopsis: AddRef/return the current connection
//
// Arguments: NONE
//
// Returns: Connection pointer
//
// History:
// jstamerj 1999/06/21 12:14:50: Created.
//
//-------------------------------------------------------------
CCfgConnection * CStoreListResolveContext::GetConnection()
{
    CCfgConnection *ret;
    AcquireSpinLock(&m_spinlock);
    ret = m_pConn;
    if(ret)
        ret->AddRef();
    ReleaseSpinLock(&m_spinlock);
    return ret;
} // CStoreListResolveContext::GetConnection


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::GetInsertionContext
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:16:38: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::GetInsertionContext()
{
    AcquireSpinLock(&m_spinlock);
    InterlockedIncrement((PLONG) &m_dwcInsertionContext);
    m_pConn->GetInsertionContext();
    ReleaseSpinLock(&m_spinlock);
} // CStoreListResolveContext::GetInsertionContext

//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::ReleaseInsertionContext
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:16:48: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::ReleaseInsertionContext()
{
    AcquireSpinLock(&m_spinlock);
    InterlockedDecrement((PLONG) &m_dwcInsertionContext);
    m_pConn->ReleaseInsertionContext();
    ReleaseSpinLock(&m_spinlock);

} // CStoreListResolveContext::ReleaseInsertionContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInsertInsertionRequest
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:20:19: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInsertInsertionRequest(
    CInsertionRequest *pCInsertionRequest)
{
    return m_pConn->HrInsertInsertionRequest(pCInsertionRequest);
} // CStoreListResolveContext::HrInsertInsertionRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatasyncctx.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatasyncctx.h
//
// Contents: ICategorizerAsyncContext implementation
//
// Classes: CICategorizerAsyncContextIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/05 16:33:02: Created.
//
//-------------------------------------------------------------
#include <windows.h>
#include <dbgtrace.h>
#include "smtpevent.h"

class CICategorizerAsyncContextIMP : public ICategorizerAsyncContext
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    STDMETHOD (CompleteQuery) (
        IN  PVOID pvQueryContext,
        IN  HRESULT hrResolutionStatus,
        IN  DWORD dwcResults,
        IN  ICategorizerItemAttributes *prgpItemAttributes);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatasync.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatasync.h
//
// Contents: Implementation of ICategorizerAsyncContext
//
// Classes: CICategorizerAyncContext
//
// Functions:
//
// History:
// jstamerj 1998/07/16 11:13:50: Created.
//
//-------------------------------------------------------------
#ifndef _ICATASYNC_H_
#define _ICATASYNC_H_


#include <windows.h>
#include <smtpevent.h>
#include <dbgtrace.h>

CatDebugClass(CICategorizerAsyncContextIMP),
    public ICategorizerAsyncContext
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerAsyncContext
    STDMETHOD (CompleteQuery) (
        IN  PVOID   pvQueryContext,
        IN  HRESULT hrResolutionStatus,
        IN  DWORD   dwcResults,
        IN  ICategorizerItemAttributes **rgpItemAttributes,
        IN  BOOL    fFinalCompletion);

  private:
    CICategorizerAsyncContextIMP();
    ~CICategorizerAsyncContextIMP();

  private:

    #define SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP          (DWORD)'ICAC'
    #define SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP_INVALID  (DWORD)'XCAC'

    DWORD m_dwSignature;
    ULONG m_cRef;

    friend class CAsyncLookupContext;
    friend class CSearchRequestBlock;
};



//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::CICategorizerAsyncContext
//
// Synopsis: Initialize signature/refcount
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 11:21:36: Created.
//
//-------------------------------------------------------------
inline CICategorizerAsyncContextIMP::CICategorizerAsyncContextIMP()
{
    m_dwSignature = SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP;
    m_cRef = 0;
}


//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::~CICategorizerAsyncContext
//
// Synopsis: Assert check member variables before destruction
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 11:23:26: Created.
//
//-------------------------------------------------------------
inline CICategorizerAsyncContextIMP::~CICategorizerAsyncContextIMP()
{
    _ASSERT(m_cRef == 0);

    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP_INVALID;
}
    
#endif //_ICATASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\cnfgmgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cnfgmgr.h
//
// Contents: Declaration of classes related to the handling on
//           different LDAP host configurations.
//           This includes LDAP failover and load balancing.
//
// Classes:
//  CLdapCfgMgr
//  CLdapCfg
//  CLdapHost
//  CCfgConnectionCache
//  CCfgConnection
//
// Functions:
//
// History:
// jstamerj 1999/06/15 14:49:52: Created.
//
//-------------------------------------------------------------
#ifndef __CNFGMGR_H__
#define __CNFGMGR_H__


#include <windows.h>
#include "asyncctx.h"
#include <baseobj.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <baseobj.h>
#include "asyncctx.h"

class CLdapCfg;
class CLdapServerCfg;
class CCfgConectionCache;
class CCfgConnection;

#define CONN_RETRY_TIME         (5*60)      // 5 Minutes
typedef DWORD CONN_PRIORITY;

enum CONN_STATE {
    CONN_STATE_INITIAL,
    CONN_STATE_CONNECTED,
    CONN_STATE_DOWN,
    CONN_STATE_RETRY,
};

typedef struct _tagLdapServerConfig {
    DWORD dwPort;
    CONN_PRIORITY pri;
    LDAP_BIND_TYPE bt;
    CHAR  szHost[CAT_MAX_DOMAIN];
    CHAR  szNamingContext[CAT_MAX_DOMAIN];
    CHAR  szAccount[CAT_MAX_LOGIN];
    CHAR  szPassword[CAT_MAX_PASSWORD];
} LDAPSERVERCONFIG, *PLDAPSERVERCONFIG;

typedef DWORD LDAPSERVERCOST, *PLDAPSERVERCOST;

//
// Connection costs:
//
// The smallest unit of cost is the number of pending searches.
// The next factor of cost is the connection state.
// States:
//   Connected = + COST_CONNECTED
//   Initially state (unconnected) = + COST_INITIAL
//   Connection down = + COST_RETRY
//   Connection recently went down = + COST_DOWN
//
// A configurable priority is always added to the cost.
//
#define COST_CONNECTED_LOCAL    0
#define COST_CONNECTED_REMOTE   2
#define COST_INITIAL_LOCAL      8
#define COST_INITIAL_REMOTE     16
#define COST_RETRY_LOCAL        12
#define COST_RETRY_REMOTE       32
#define COST_DOWN_LOCAL         0x80000000
#define COST_DOWN_REMOTE        0x80000000
#define COST_TOO_HIGH_TO_CONNECT 0x80000000

//
// The maximum number of threads that will try to connect to a
// connection in CONN_STATE_RETRY:
//
#define MAX_CONNECT_THREADS     1

//
// Requerying of available GC control:
// The code will rebuild the list of available GCs at a hard coded
// time interval.  The code will also requery for available GCs after
// a hard coded number of connection failures and a minimum time interval.
//
#define REBUILD_GC_LIST_MAX_INTERVAL    (60*60)     // 1 hour
#define REBUILD_GC_LIST_MAX_FAILURES    (100)       // 100 connection failures
#define REBUILD_GC_LIST_MIN_INTERVAL    (60*5)      // 5 minutes

//
// An LDAP connection cache object that creates CCfgConnection objects
//
class CCfgConnectionCache :
    public CBatchLdapConnectionCache
{
  public:
    HRESULT GetConnection(
        CCfgConnection **ppConn,
        PLDAPSERVERCONFIG pServerConfig,
        CLdapServerCfg *pCLdapServerConfig);

    CCachedLdapConnection *CreateCachedLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext);
    
  private:
    #define SIGNATURE_CCFGCONNECTIONCACHE           (DWORD)'CCCC'
    #define SIGNATURE_CCFGCONNECTIONCACHE_INVALID   (DWORD)'CCCX'
    DWORD m_dwSignature;
};

//
// CLdapCfgMgr is a wrapper around CLdapCfg.  It contains thread save
// code to build a new CLdapCfg object with a new list of available
// LDAP servers
//
CatDebugClass(CLdapCfgMgr),
    public CBaseObject
{
  public:
    CLdapCfgMgr(
        BOOL fAutomaticConfigUpdate,
        ICategorizerParameters *pICatParams,
        LDAP_BIND_TYPE bt = BIND_TYPE_NONE,
        LPSTR pszAccount = NULL,
        LPSTR pszPassword = NULL,
        LPSTR pszNamingContext = NULL);

    //
    // Build a list of all available GCs and initialize
    // This function may be called multiple times (necessary if the
    // available GCs change)
    //
    HRESULT HrInit(
        BOOL fRediscoverGCs = FALSE);

    //
    // Initialize using a specified list of avialable LDAP servers
    // THis function may be called more than once
    //
    HRESULT HrInit(
        DWORD dwcServers, 
        PLDAPSERVERCONFIG prgServerConfig);

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        CCfgConnection **ppConn);

    //
    // Called very often to update the GC configuration if warranted.
    //
    HRESULT HrUpdateConfigurationIfNecessary();

    //
    // Wrapper to cancel all searches on all connections
    //
    VOID CancelAllConnectionSearches(
        ISMTPServer *pIServer)
    {
        m_LdapConnectionCache.CancelAllConnectionSearches(
            pIServer);
    }


  private:
    ~CLdapCfgMgr();

    HRESULT HrGetGCServers(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    HRESULT HrBuildGCServerArray(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  BOOL  fRediscoverGCs,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    HRESULT HrBuildArrayFromDCInfo(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  DWORD dwcDSDCInfo,
        IN  PDS_DOMAIN_CONTROLLER_INFO_2 prgDSDCInfo,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    BOOL fReadyForUpdate();

    LPSTR SzConnectNameFromDomainControllerInfo(
        PDS_DOMAIN_CONTROLLER_INFO_2 pDCInfo)
    {
        if(pDCInfo->DnsHostName)
            return pDCInfo->DnsHostName;
        else if(pDCInfo->NetbiosName)
            return pDCInfo->NetbiosName;
        else
            return NULL;
    }
        
  private:
    #define SIGNATURE_CLDAPCFGMGR           (DWORD)'MCLC'
    #define SIGNATURE_CLDAPCFGMGR_INVALID   (DWORD)'MCLX'
    DWORD m_dwSignature;
    BOOL  m_fAutomaticConfigUpdate;
    DWORD m_dwUpdateInProgress;
    ULARGE_INTEGER m_ulLastUpdateTime;
    CExShareLock m_sharelock;
    CLdapCfg *m_pCLdapCfg;

    //
    // Default configuration to use with automatic host selection
    //
    LDAP_BIND_TYPE      m_bt;
    CHAR                m_szNamingContext[CAT_MAX_DOMAIN];
    CHAR                m_szAccount[CAT_MAX_LOGIN];
    CHAR                m_szPassword[CAT_MAX_PASSWORD];

    ICategorizerParameters  *m_pICatParams;

    CCfgConnectionCache m_LdapConnectionCache;
};

//
// CLdapCfg contains the configuration of a group of LDAP servers at
// one point in time.  The group of LDAP servers may not be changed
// (without creating a new CLdapCfg object)
//
CatDebugClass(CLdapCfg), 
    public CBaseObject
{
  public:
    CLdapCfg();

    void * operator new(size_t size, DWORD dwcServers);
    //
    // HrInit should only be called once per object
    //
    HRESULT HrInit(
        DWORD dwcServers,
        PLDAPSERVERCONFIG prgServerConfig,
        CLdapCfg *pCLdapCfgOld);

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        CCfgConnection **ppConn,
        CCfgConnectionCache *pLdapConnectionCache);

    DWORD DwNumConnectionFailures()
    {
        return m_dwcConnectionFailures;
    }
    DWORD DwNumServers()
    {
        return m_dwcServers;
    }

  private:
    ~CLdapCfg();

    VOID ShuffleArray();

  private:
    #define SIGNATURE_CLDAPCFG              (DWORD)'fCLC'
    #define SIGNATURE_CLDAPCFG_INVALID      (DWORD)'fCLX'

    DWORD m_dwSignature;
    DWORD m_dwInc;
    CExShareLock m_sharelock;    // Protects m_prgpCLdapServerCfg
    DWORD m_dwcServers;
    DWORD m_dwcConnectionFailures;
    CLdapServerCfg **m_prgpCLdapServerCfg;
};

//
// CLdapServerCfg maintains information on the state of one LDAP
// server/port
//
CatDebugClass(CLdapServerCfg)
{
  public:
    static VOID GlobalInit()
    {
        InitializeListHead(&m_listhead);
    }
    static HRESULT GetServerCfg(
        IN  PLDAPSERVERCONFIG pServerConfig,
        OUT CLdapServerCfg **ppCLdapServerCfg);

    LONG AddRef()
    {
        return InterlockedIncrement(&m_lRefCount);
    }
    LONG Release()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRefCount);
        if(lRet == 0) {
            //
            // Remove object from global list and destroy
            //
            m_listlock.ExclusiveLock();

            if(m_lRefCount > 0) {
                //
                // Somebody grabbed this object out of the global list
                // and AddRef'd it.  Abort deletion.
                //
            } else {
                
                RemoveEntryList(&m_le);
                delete this;
            }
            m_listlock.ExclusiveUnlock();
        }
        return lRet;
    }

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        CCfgConnection **ppConn,
        CCfgConnectionCache *pLdapConnectionCache);

    VOID Cost(
        OUT PLDAPSERVERCOST pCost);
        
    VOID IncrementPendingSearches()
    {
        DWORD dwcSearches;
        TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::IncrementPendingSearches");
        dwcSearches = (LONG) InterlockedIncrement((PLONG)&m_dwcPendingSearches);
        DebugTrace((LPARAM)this, "%ld pending searches on connection [%s:%d]",
                   dwcSearches, m_ServerConfig.szHost, m_ServerConfig.dwPort);
        TraceFunctLeaveEx((LPARAM)this);
    }
    VOID DecrementPendingSearches()
    {
        DWORD dwcSearches;
        TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::IncrementPendingSearches");
        dwcSearches = (DWORD) InterlockedDecrement((PLONG)&m_dwcPendingSearches);
        DebugTrace((LPARAM)this, "%ld pending searches on connection [%s:%d]",
                   dwcSearches, m_ServerConfig.szHost, m_ServerConfig.dwPort);
        TraceFunctLeaveEx((LPARAM)this);
    }

    VOID UpdateConnectionState(
        ULARGE_INTEGER *pft,
        CONN_STATE connstate);

    VOID IncrementFailedCount()
    {
        InterlockedIncrement((PLONG) &m_dwcFailedConnectAttempts);
    }        
    VOID ResetFailedCount()
    {
        InterlockedExchange((PLONG) &m_dwcFailedConnectAttempts, 0);
    }        
    CONN_STATE CurrentState()
    {
        return m_connstate;
    }
    ULARGE_INTEGER GetCurrentTime()
    {
        ULARGE_INTEGER FileTime;

        _ASSERT(sizeof(ULARGE_INTEGER) == sizeof(FILETIME));
        GetSystemTimeAsFileTime((LPFILETIME)&FileTime);
        return FileTime;
    }
  private:
    CLdapServerCfg();
    ~CLdapServerCfg();

    HRESULT HrInit(
        PLDAPSERVERCONFIG pServerConfig);

    BOOL fReadyForRetry()
    {
        // 100 nanoseconds * 10^7 == 1 second
        return ((GetCurrentTime().QuadPart - m_ftLastStateUpdate.QuadPart) >=
                ((LONGLONG)CONN_RETRY_TIME * 10000000));
    }

    BOOL fMatch(
        PLDAPSERVERCONFIG pServerConfig);

    static CLdapServerCfg *FindServerCfg(
        PLDAPSERVERCONFIG pServerConfig);

    static BOOL fIsLocalComputer(
        PLDAPSERVERCONFIG pServerConfig);

  private:
    #define SIGNATURE_CLDAPSERVERCFG         (DWORD)'CSLC'
    #define SIGNATURE_CLDAPSERVERCFG_INVALID (DWORD)'CSLX'
    DWORD m_dwSignature;
    LONG m_lRefCount;
    LDAPSERVERCONFIG m_ServerConfig;
    CExShareLock m_sharelock;
    CONN_STATE m_connstate;
    ULARGE_INTEGER m_ftLastStateUpdate;
    DWORD m_dwcPendingSearches;
    DWORD m_dwcCurrentConnectAttempts;
    DWORD m_dwcFailedConnectAttempts;

    //
    // Member variables to keep/protect a list of CLdapServer objects
    //
    LIST_ENTRY m_le;
    BOOL m_fLocalServer;
    static CExShareLock m_listlock;
    static LIST_ENTRY m_listhead;
};

//
// An LDAP connection that notifies CLdapServerCfg about state changes
//
class CCfgConnection :
    public CBatchLdapConnection
{
    #define SIGNATURE_CCFGCONNECTION           (DWORD)'oCCC'
    #define SIGNATURE_CCFGCONNECTION_INVALID   (DWORD)'oCCX'
  public:
    CCfgConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        CLdapConnectionCache *pCache,
        CLdapServerCfg *pCLdapServerCfg) :
        CBatchLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCache)
    {
        m_dwSignature = SIGNATURE_CCFGCONNECTION;
        m_pCLdapServerCfg = pCLdapServerCfg;
        pCLdapServerCfg->AddRef();

        m_connstate = CONN_STATE_INITIAL;
    }

    ~CCfgConnection()
    {
        _ASSERT(m_pCLdapServerCfg);
        m_pCLdapServerCfg->Release();

        _ASSERT(m_dwSignature == SIGNATURE_CCFGCONNECTION);
        m_dwSignature = SIGNATURE_CCFGCONNECTION_INVALID;
    }

    virtual HRESULT Connect();

    virtual HRESULT AsyncSearch(             // Asynchronously look up
        LPCWSTR szBaseDN,                    // objects matching specified
        int nScope,                          // criteria in the DS. The
        LPCWSTR szFilter,                    // results are passed to
        LPCWSTR szAttributes[],              // fnCompletion when they
        DWORD dwPageSize,                    // Optinal page size
        LPLDAPCOMPLETION fnCompletion,       // become available.
        LPVOID ctxCompletion);

  private:
    virtual VOID CallCompletion(
        PPENDING_REQUEST preq,
        PLDAPMessage pres,
        HRESULT hrStatus,
        BOOL fFinalCompletion);

    VOID NotifyServerDown();

  private:
    DWORD m_dwSignature;
    CLdapServerCfg *m_pCLdapServerCfg;
    CExShareLock m_sharelock;
    CONN_STATE m_connstate;
};


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrUpdateConfigurationIfNecessary
//
// Synopsis: Check to see if the CLdapCfg should be updated.
//           If it should be, do the update. 
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from HrInit
//
// History:
// jstamerj 1999/06/29 20:51:23: Created.
//
//-------------------------------------------------------------
inline HRESULT CLdapCfgMgr::HrUpdateConfigurationIfNecessary()
{
    HRESULT hr = S_OK;
    DWORD dw;
    BOOL fUpdate;

    if(m_fAutomaticConfigUpdate == FALSE)
        //
        // Update is disabled
        return S_OK;

    //
    // See if some other thread is already updating the configuration
    // (try to enter the lock)
    //
    dw = InterlockedExchange((PLONG)&m_dwUpdateInProgress, TRUE);

    if(dw == FALSE) {
        //
        // No other thread is updating
        //
        fUpdate = fReadyForUpdate();

        if(fUpdate) {
            //
            // Call HrInit to generate a new CLdapCfg
            //
            hr = HrInit(TRUE);
            if(SUCCEEDED(hr)) {
                //
                // Set the last update time
                //
                GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastUpdateTime);
            }
        }
        //
        // Release the lock
        //
        InterlockedExchange((PLONG)&m_dwUpdateInProgress, FALSE);
    }
    return hr;
} // CLdapCfgMgr::HrUpdateConfigurationIfNecessary


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::fReadyForUpdate
//
// Synopsis: Calculates wether or not this object is due for an
//           automatic cfg update
//
// Arguments: NONE
//
// Returns:
//  TRUE: Yes, it is time for an update
//  FALSE: No, an update is not required at this time
//
// History:
// jstamerj 1999/06/30 12:08:35: Created.
//
//-------------------------------------------------------------
inline BOOL CLdapCfgMgr::fReadyForUpdate()
{
    DWORD dwNumConnectionFailures;
    ULARGE_INTEGER ulCurrentTime;

    //
    // We need an update when:
    // 1) A periodic time interval has ellapsed
    // 100 ns * 10^7 == 1 second
    //
    GetSystemTimeAsFileTime((LPFILETIME)&ulCurrentTime);

    if((ulCurrentTime.QuadPart - m_ulLastUpdateTime.QuadPart) >=
       (LONGLONG)REBUILD_GC_LIST_MAX_INTERVAL * 10000000)
        
        return TRUE;

    //
    // We also need an update when:
    // 2) We have received more than a set number of connection
    // failures on the current configuration and at least a minimum
    // time interval has passed 
    //
    // Check for the mimimum time interval
    //
    if( (ulCurrentTime.QuadPart - m_ulLastUpdateTime.QuadPart) >=
        ((LONGLONG)REBUILD_GC_LIST_MIN_INTERVAL * 10000000)) {
        //
        // Get the number of connection failures
        //
        m_sharelock.ShareLock();
    
        if(m_pCLdapCfg) {
            dwNumConnectionFailures = m_pCLdapCfg->DwNumConnectionFailures();
        } else {
            dwNumConnectionFailures = 0;
            _ASSERT(0 && "HrInit was not called or failed");
        }

        m_sharelock.ShareUnlock();

        if(dwNumConnectionFailures >= REBUILD_GC_LIST_MAX_FAILURES)
            return TRUE;
    }

    return FALSE;
} // CLdapCfgMgr::fReadyForUpdate

#endif //__CNFGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\globals.h ===
//
// ldapdata.h -- This file contains the global data structures used by the
//  LDAP Email ID store implementation
//
// Created:
//  Jan 12, 1996    Milan Shah (milans)
//
// Changes:
//

#include "winldap.h"
#include "ldapstr.h"
#include "ldapstor.h"
#include "ldapconn.h"
#include "asyncctx.h"
#include "cnfgmgr.h"

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

//
// Defines used for debugging
//

#define LDAP_STORE_DBG      0x100
#define LDAP_CONN_DBG       0x101
#define LDAP_CCACHE_DBG     0x102
#define LDAP_DCACHE_DBG     0x103

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\cnfgmgr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cnfgmgr.cpp
//
// Contents: Implementation of the classes defined in cnfgmgr.h
//
// Classes:
//  CLdapCfgMgr
//  CLdapCfg
//  CLdapHost
//  CCfgConnectionCache
//  CCfgConnection
//
// Functions:
//
// History:
// jstamerj 1999/06/16 14:41:45: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "cnfgmgr.h"

//
// Globals
//
CExShareLock CLdapServerCfg::m_listlock;
LIST_ENTRY   CLdapServerCfg::m_listhead;


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::CLdapCfgMgr
//
// Synopsis: Initialize member data
//
// Arguments: Optional:
//  fAutomaticConfigUpdate: TRUE indicates that the object is to
//                          periodicly automaticly update the list of
//                          GCs.
//                          FALSE disables this functionality
//
//  bt: Default bindtype to use
//  pszAccount: Default account for LDAP bind
//  pszPassword: Password of above account
//  pszNamingContext: Naming context to use for all LDAP searches
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/16 14:42:39: Created.
//
//-------------------------------------------------------------
CLdapCfgMgr::CLdapCfgMgr(
    BOOL                    fAutomaticConfigUpdate,
    ICategorizerParameters  *pICatParams,
    LDAP_BIND_TYPE          bt,
    LPSTR                   pszAccount,
    LPSTR                   pszPassword,
    LPSTR                   pszNamingContext)
{
    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::CLdapCfgMgr");

    m_dwSignature = SIGNATURE_CLDAPCFGMGR;
    m_pCLdapCfg = NULL;
    ZeroMemory(&m_ulLastUpdateTime, sizeof(m_ulLastUpdateTime));
    m_dwUpdateInProgress = FALSE;
    m_fAutomaticConfigUpdate = fAutomaticConfigUpdate;

    //
    // Copy default
    //
    m_bt = bt;
    if(pszAccount)
        lstrcpyn(m_szAccount, pszAccount, sizeof(m_szAccount));
    else
        m_szAccount[0] = '\0';

    if(pszPassword)
        lstrcpyn(m_szPassword, pszPassword, sizeof(m_szPassword));
    else
        m_szPassword[0] = '\0';

    if(pszNamingContext)
        lstrcpyn(m_szNamingContext, pszNamingContext, sizeof(m_szNamingContext));
    else
        m_szNamingContext[0] = '\0';

    m_pICatParams = pICatParams;
    m_pICatParams->AddRef();

    m_LdapConnectionCache.AddRef();

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapCfgMgr::CLdapCfgMgr


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::~CLdapCfgMgr
//
// Synopsis: Release member data/pointers
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/16 14:44:28: Created.
//
//-------------------------------------------------------------
CLdapCfgMgr::~CLdapCfgMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::~CLdapCfgMgr");

    if(m_pCLdapCfg) {
        //
        // Release it
        //
        m_pCLdapCfg->Release();
        m_pCLdapCfg = NULL;
    }

    if(m_pICatParams) {

        m_pICatParams->Release();
        m_pICatParams = NULL;
    }
    //
    // This will not return until all ldap connections have been released/destroyed
    //
    m_LdapConnectionCache.Release();

    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFGMGR);
    m_dwSignature = SIGNATURE_CLDAPCFGMGR_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapCfgMgr::~CLdapCfgMgr



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrInit
//
// Synopsis: Initialize with a list of available GCs
//
// Arguments:
//  fRediscoverGCs: TRUE: pass in the force rediscovery flag to DsGetDcName
//                  FALSE: Attempt to call DsGetDcName first without
//                         passing in the force rediscovery flag.
//
// Returns:
//  S_OK: Success
//  error from NT5 (DsGetDcName)
//  CAT_E_NO_GC_SERVERS: THere are no GC servers available to build
//                       the list of GCs
//
// History:
// jstamerj 1999/06/16 14:48:11: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrInit(
    BOOL fRediscoverGCs)
{
    HRESULT hr = S_OK;
    DWORD dwcServerConfig;
    PLDAPSERVERCONFIG prgServerConfig = NULL;

    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrInit");
    //
    // Get GC servers from dsaccess.dll (which either discovers them or
    // reads them from the registry.
    //
    hr = HrGetGCServers(
        m_bt,
        m_szAccount,
        m_szPassword,
        m_szNamingContext,
        &dwcServerConfig,
        &prgServerConfig);


    if(SUCCEEDED(hr)) {
        //
        // Call the other init function with the array
        //
        hr = HrInit(
            dwcServerConfig,
            prgServerConfig);

        if(FAILED(hr))
            ErrorTrace((LPARAM)this, "HrInit failed hr %08lx", hr);

        goto CLEANUP;
    }


    DebugTrace((LPARAM)this, "Failed to get GC list from dsaccess -- falling back to NT-API");
    //
    // Build an array of server configs consiting of available GCs
    //
    hr = HrBuildGCServerArray(
        m_bt,
        m_szAccount,
        m_szPassword,
        m_szNamingContext,
        fRediscoverGCs,
        &dwcServerConfig,
        &prgServerConfig);

    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "HrBuildGCServerArray failed hr %08lx", hr);

        if(fRediscoverGCs == FALSE) {
            //
            // Attempt to build the array again.  This time, force
            // rediscovery of available GCs.  This is expensive which is
            // why we initially try to find all available GCs without
            // forcing rediscovery.
            //
            hr = HrBuildGCServerArray(
                m_bt,
                m_szAccount,
                m_szPassword,
                m_szNamingContext,
                TRUE,              // fRediscoverGCs
                &dwcServerConfig,
                &prgServerConfig);

            if(FAILED(hr)) {
                ErrorTrace((LPARAM)this, "HrBuildGCServerArray failed 2nd time hr %08lx", hr);
                hr = CAT_E_NO_GC_SERVERS;
                goto CLEANUP;
            }
        } else {
            //
            // We already forced rediscovery and failed
            //
            hr = CAT_E_NO_GC_SERVERS;
            goto CLEANUP;
        }
    }

    if(dwcServerConfig == 0) {
        hr = CAT_E_NO_GC_SERVERS;
        goto CLEANUP;
    }

    //
    // Call the other init function with the array
    //
    hr = HrInit(
        dwcServerConfig,
        prgServerConfig);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "HrInit failed hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    if(prgServerConfig != NULL)
        delete prgServerConfig;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrInit


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrGetGCServers
//
// Synopsis: Get the list of GCs from dsaccess.dll
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  fRediscoverGCs: Attempt to rediscover GCs -- this is expensive and should
//                  only be TRUE after the function has failed once
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There are no available GC servers to build
//                       the list of GCs
//  error from ntdsapi
//
// History:
// jstamerj 1999/07/01 17:53:02: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrGetGCServers(
    IN  LDAP_BIND_TYPE bt,
    IN  LPSTR pszAccount,
    IN  LPSTR pszPassword,
    IN  LPSTR pszNamingContext,
    OUT DWORD *pdwcServerConfig,
    OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT hr = S_OK;
    DWORD dwNumGCs = 0;
    DWORD dwIdx = 0;
    ICategorizerLdapConfig *pICatLdapConfigInterface = NULL;
    ICategorizerParametersEx *pIPhatCatParams = NULL;
    IServersListInfo *pIServersList = NULL;

    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildArrayFromDCInfo");

    _ASSERT(pdwcServerConfig);
    _ASSERT(pprgServerConfig);
    _ASSERT(m_pICatParams);

    *pdwcServerConfig = 0;

    if(!m_pICatParams) {

        ErrorTrace((LPARAM)this, "No interface to query for cat config");
        hr = CAT_E_NO_GC_SERVERS;
        goto CLEANUP;
    }

    hr = m_pICatParams->QueryInterface(IID_ICategorizerParametersEx, (LPVOID *)&pIPhatCatParams);
    _ASSERT(SUCCEEDED(hr) && "Unable to get phatcatparams interface");

    pIPhatCatParams->GetLdapConfigInterface(&pICatLdapConfigInterface);
    if(!pICatLdapConfigInterface) {

        ErrorTrace((LPARAM)this, "Unable to get Ldap config interface");
        hr = CAT_E_NO_GC_SERVERS;
        goto CLEANUP;
    }

    hr = pICatLdapConfigInterface->GetGCServers(&pIServersList);
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Unable to get the list of GC servers");
        _ASSERT(0 && "Failed to get GC servers!");
        goto CLEANUP;
    }

    hr = pIServersList->GetNumGC(&dwNumGCs);
    _ASSERT(SUCCEEDED(hr) && "GetNumGC should always succeed!");

    DebugTrace((LPARAM)this, "Got %d GCs", dwNumGCs);
    if(dwNumGCs == 0) {

        DebugTrace((LPARAM)this, "There are no GC servers");
        hr = CAT_E_NO_GC_SERVERS;
        goto CLEANUP;
    }

    //
    // Allocate array
    //
    *pprgServerConfig = new LDAPSERVERCONFIG[dwNumGCs];

    if(*pprgServerConfig == NULL) {

        ErrorTrace((LPARAM)this, "Out of memory allocating array of %d LDAPSERVERCONFIGs", dwNumGCs);
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // Fill in LDAPSERVERCONFIG structures
    //
    for(dwIdx = 0; dwIdx < dwNumGCs; dwIdx++) {

        PLDAPSERVERCONFIG pServerConfig;
        LPSTR pszName = NULL;

        pServerConfig = &((*pprgServerConfig)[dwIdx]);
        //
        // Copy bindtype, account, password, naming context
        //
        pServerConfig->bt = bt;

        if(pszNamingContext)
            lstrcpyn(pServerConfig->szNamingContext, pszNamingContext,
                     sizeof(pServerConfig->szNamingContext));
        else
            pServerConfig->szNamingContext[0] = '\0';

        if(pszAccount)
            lstrcpyn(pServerConfig->szAccount, pszAccount,
                     sizeof(pServerConfig->szAccount));
        else
            pServerConfig->szAccount[0] = '\0';

        if(pszPassword)
            lstrcpyn(pServerConfig->szPassword, pszPassword,
                     sizeof(pServerConfig->szPassword));
        else
            pServerConfig->szPassword[0] = '\0';

        //
        // Initialize priority and TCP port
        //
        pServerConfig->pri = 0;

        hr = pIServersList->GetItem(
                    dwIdx,
                    &pServerConfig->dwPort,
                    &pszName);

        _ASSERT(SUCCEEDED(hr) && "GetItem should always succeed");

        //
        // Copy the name
        //
        lstrcpyn(pServerConfig->szHost, pszName,
                sizeof(pServerConfig->szHost));

        DebugTrace((LPARAM)this, "GC: %s on Port: %d", pServerConfig->szHost, pServerConfig->dwPort);
    }
    //
    // Set the out parameter for the array size
    //
    *pdwcServerConfig = dwNumGCs;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Free the allocated array if we're failing
        //
        if(*pprgServerConfig) {
            delete *pprgServerConfig;
            *pprgServerConfig = NULL;
        }
    }

    if(pIPhatCatParams)
        pIPhatCatParams->Release();

    if(pIServersList)
        pIServersList->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildArrayFromDCInfo

//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrBuildGCServerArray
//
// Synopsis: Allocate/build an array of LDAPSERVERCONFIG structures --
//           one for each available GC
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  fRediscoverGCs: Attempt to rediscover GCs -- this is expensive and should
//                  only be TRUE after the function has failed once
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There are no available GC servers to build
//                       the list of GCs
//  error from ntdsapi
//
// History:
// jstamerj 1999/07/01 17:53:02: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrBuildGCServerArray(
    IN  LDAP_BIND_TYPE bt,
    IN  LPSTR pszAccount,
    IN  LPSTR pszPassword,
    IN  LPSTR pszNamingContext,
    IN  BOOL  fRediscoverGCs,
    OUT DWORD *pdwcServerConfig,
    OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT                         hr = S_OK;
    DWORD                           dwErr;
    ULONG                           ulFlags;
    PDOMAIN_CONTROLLER_INFO         pDCInfo = NULL;
    HANDLE                          hDS = INVALID_HANDLE_VALUE;
    DWORD                           cDSDCInfo;
    PDS_DOMAIN_CONTROLLER_INFO_2    prgDSDCInfo = NULL;

    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildGCServerArray");
    //
    // Find one GC using DsGetDcName()
    //
    ulFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_GC_SERVER_REQUIRED;
    if(fRediscoverGCs)
        ulFlags |= DS_FORCE_REDISCOVERY;

    dwErr = DsGetDcName(
        NULL,    // Computername to process this function -- local computer
        NULL,    // Domainname -- primary domain of this computer
        NULL,    // Domain GUID
        NULL,    // Sitename -- site of this computer
        ulFlags, // Flags; we want a GC
        &pDCInfo); // Out parameter for the returned info

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        FatalTrace((LPARAM)this, "DsGetDcName failed hr %08lx", hr);
        //
        // Map one error code
        //
        if(hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
            hr = CAT_E_NO_GC_SERVERS;

        pDCInfo = NULL;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Binding to DC %s",
               pDCInfo->DomainControllerName);

    //
    // Bind to the DC
    //
    dwErr = DsBind(
        pDCInfo->DomainControllerName,    // DomainControllerAddress
        NULL,                             // DnsDomainName
        &hDS);                           // Out param -- handle to DS

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        FatalTrace((LPARAM)this, "DsBind failed hr %08lx", hr);
        hDS = INVALID_HANDLE_VALUE;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Finding all domain controllers for %s", pDCInfo->DomainName);
    //
    // Get information about all the domain controllers
    //
    dwErr = DsGetDomainControllerInfo(
        hDS,                    // Handle to the DS
        pDCInfo->DomainName,    // Domain name -- use the same domain
                                // as the GC found above
        2,                      // Retrive struct version 2
        &cDSDCInfo,             // Out param for array size
        (PVOID *) &prgDSDCInfo); // Out param for array ptr

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        FatalTrace((LPARAM)this, "DsGetDomainControllerInfo failed hr %08lx", hr);
        prgDSDCInfo = NULL;
        goto CLEANUP;
    }

    hr = HrBuildArrayFromDCInfo(
        bt,
        pszAccount,
        pszPassword,
        pszNamingContext,
        cDSDCInfo,
        prgDSDCInfo,
        pdwcServerConfig,
        pprgServerConfig);


 CLEANUP:
    if(prgDSDCInfo != NULL)
        DsFreeDomainControllerInfo(
            2,              // Free struct version 2
            cDSDCInfo,      // size of array
            prgDSDCInfo);   // array ptr

    if(hDS != INVALID_HANDLE_VALUE)
        DsUnBind(&hDS);

    if(pDCInfo != NULL)
        NetApiBufferFree(pDCInfo);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildGCServerArray


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrBuildArrayFromDCInfo
//
// Synopsis: Allocate/build an array of LDAPSERVERCONFIG structures --
//           one for each available GC in the array
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  dwDSDCInfo: size of the prgDSDCInfo array
//  prgDSDCInfo: array of domain controller info structures
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There were no GCs in the array
//
// History:
// jstamerj 1999/06/17 10:40:46: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrBuildArrayFromDCInfo(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  DWORD dwcDSDCInfo,
        IN  PDS_DOMAIN_CONTROLLER_INFO_2 prgDSDCInfo,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT hr = S_OK;
    DWORD dwNumGCs = 0;
    DWORD dwSrcIdx;
    DWORD dwDestIdx;
    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildArrayFromDCInfo");

    _ASSERT(pdwcServerConfig);
    _ASSERT(pprgServerConfig);

    for(dwSrcIdx = 0; dwSrcIdx < dwcDSDCInfo; dwSrcIdx++) {

        LPSTR pszName;

        pszName = SzConnectNameFromDomainControllerInfo(
            &(prgDSDCInfo[dwSrcIdx]));

        if(pszName == NULL) {

            ErrorTrace((LPARAM)this, "DC \"%s\" has no dns/netbios names",
                       prgDSDCInfo[dwSrcIdx].ServerObjectName ?
                       prgDSDCInfo[dwSrcIdx].ServerObjectName :
                       "unknown");

        } else if(prgDSDCInfo[dwSrcIdx].fIsGc) {

            dwNumGCs++;
            DebugTrace((LPARAM)this, "Discovered GC #%d: %s",
                       dwNumGCs, pszName);

        } else {

            DebugTrace((LPARAM)this, "Discarding non-GC: %s",
                       pszName);
        }
    }
    //
    // Allocate array
    //
    *pprgServerConfig = new LDAPSERVERCONFIG[dwNumGCs];

    if(*pprgServerConfig == NULL) {

        ErrorTrace((LPARAM)this, "Out of memory alloacting array of %d LDAPSERVERCONFIGs", dwNumGCs);
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // Fill in LDAPSERVERCONFIG structures
    //
    for(dwSrcIdx = 0, dwDestIdx = 0; dwSrcIdx < dwcDSDCInfo; dwSrcIdx++) {

        LPSTR pszName;

        pszName = SzConnectNameFromDomainControllerInfo(
            &(prgDSDCInfo[dwSrcIdx]));

        if((pszName != NULL) && (prgDSDCInfo[dwSrcIdx].fIsGc)) {

            PLDAPSERVERCONFIG pServerConfig;

            _ASSERT(dwDestIdx < dwNumGCs);

            pServerConfig = &((*pprgServerConfig)[dwDestIdx]);
            //
            // Copy bindtype, account, password, naming context
            //
            pServerConfig->bt = bt;

            if(pszNamingContext)
                lstrcpyn(pServerConfig->szNamingContext, pszNamingContext,
                         sizeof(pServerConfig->szNamingContext));
            else
                pServerConfig->szNamingContext[0] = '\0';

            if(pszAccount)
                lstrcpyn(pServerConfig->szAccount, pszAccount,
                         sizeof(pServerConfig->szAccount));
            else
                pServerConfig->szAccount[0] = '\0';

            if(pszPassword)
                lstrcpyn(pServerConfig->szPassword, pszPassword,
                         sizeof(pServerConfig->szPassword));
            else
                pServerConfig->szPassword[0] = '\0';

            //
            // Initialize priority and TCP port
            //
            pServerConfig->pri = 0;
            pServerConfig->dwPort = LDAP_GC_PORT;

            //
            // Copy the name
            //
            lstrcpyn(pServerConfig->szHost, pszName,
                    sizeof(pServerConfig->szHost));

            dwDestIdx++;
        }
    }
    //
    // Assert check -- we should have filled in the entire array
    //
    _ASSERT(dwDestIdx == dwNumGCs);
    //
    // Set the out parameter for the array size
    //
    *pdwcServerConfig = dwNumGCs;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Free the allocated array if we're failing
        //
        if(*pprgServerConfig) {
            delete *pprgServerConfig;
            *pprgServerConfig = NULL;
        }
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildArrayFromDCInfo


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrInit
//
// Synopsis: Initialize given an array of LDAPSERVERCONFIG structs
//
// Arguments:
//  dwcServers: Size of the array
//  prgServerConfig: Array of LDAPSERVERCONFIG structs
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/17 12:32:11: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrInit(
    DWORD dwcServers,
    PLDAPSERVERCONFIG prgServerConfig)
{
    HRESULT hr = S_OK;
    CLdapCfg *pCLdapCfgOld = NULL;
    CLdapCfg *pCLdapCfg = NULL;
    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrInit");

    pCLdapCfg = new (dwcServers) CLdapCfg();

    if(pCLdapCfg == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // Allow only one config change at a time
    //
    m_sharelock.ExclusiveLock();

    //
    // Grab the current m_pCLdapCfg into pCLdapCfgOld
    //
    pCLdapCfgOld = m_pCLdapCfg;

    hr = pCLdapCfg->HrInit(
        dwcServers,
        prgServerConfig,
        pCLdapCfgOld);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Put the new configuration in place
    // Swap pointers
    //
    m_pCLdapCfg = pCLdapCfg;

    //
    // Set the last update time
    //
    GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastUpdateTime);

    m_sharelock.ExclusiveUnlock();

 CLEANUP:
    if(pCLdapCfgOld)
        pCLdapCfgOld->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrInit



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrGetConnection
//
// Synopsis: Select/return a connection
//
// Arguments:
//  ppConn: Out parameter to receive ptr to connection
//
// Returns:
//  S_OK: Success
//  E_FAIL: not initialized
//  error from CLdapConnectionCache
//
// History:
// jstamerj 1999/06/17 15:25:51: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrGetConnection(
    CCfgConnection **ppConn)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrGetConnection");

    hr = HrUpdateConfigurationIfNecessary();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "HrUpdateConfigurationIfNecessary failed hr %08lx", hr);
        goto CLEANUP;
    }

    m_sharelock.ShareLock();

    if(m_pCLdapCfg) {

        DWORD dwcAttempts = 0;
        do {
            dwcAttempts++;
            hr = m_pCLdapCfg->HrGetConnection(ppConn, &m_LdapConnectionCache);

        } while((hr == HRESULT_FROM_WIN32(ERROR_RETRY)) &&
                (dwcAttempts <= m_pCLdapCfg->DwNumServers()));
        //
        // If we retried DwNumServers() times and still couldn't get a
        // connection, fail with E_DBCONNECTION.
        //
        if(hr == HRESULT_FROM_WIN32(ERROR_RETRY))
            hr = CAT_E_DBCONNECTION;

    } else {
        hr = E_FAIL;
        _ASSERT(0 && "HrInit not called or did not succeed");
    }

    m_sharelock.ShareUnlock();

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrGetConnection



//+------------------------------------------------------------
//
// Function: CLdapCfg::operator new
//
// Synopsis: Allocate memory for a CLdapCfg object
//
// Arguments:
//  size: size of C++ object
//  dwcServers: Number of servers in this configuration
//
// Returns:
//  void pointer to the new object
//
// History:
// jstamerj 1999/06/17 13:40:56: Created.
//
//-------------------------------------------------------------
void * CLdapCfg::operator new(
    size_t size,
    DWORD dwcServers)
{
    CLdapCfg *pCLdapCfg;
    DWORD dwAllocatedSize;
    TraceFunctEnterEx((LPARAM)0, "CLdapCfg::operator new");

    _ASSERT(size == sizeof(CLdapCfg));

    //
    // Allocate space fo the CLdapServerCfg * array contigously after
    // the memory for the C++ object
    //
    dwAllocatedSize = sizeof(CLdapCfg) + (dwcServers *
                                          sizeof(CLdapServerCfg));

    pCLdapCfg = (CLdapCfg *) new BYTE[dwAllocatedSize];

    if(pCLdapCfg) {
        pCLdapCfg->m_dwSignature = SIGNATURE_CLDAPCFG;
        pCLdapCfg->m_dwcServers = dwcServers;
        pCLdapCfg->m_prgpCLdapServerCfg = (CLdapServerCfg **) (pCLdapCfg + 1);
    }

    TraceFunctLeaveEx((LPARAM)pCLdapCfg);
    return pCLdapCfg;
} // CLdapCfg::operator new


//+------------------------------------------------------------
//
// Function: CLdapCfg::CLdapCfg
//
// Synopsis: Initialize member data
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 13:46:50: Created.
//
//-------------------------------------------------------------
CLdapCfg::CLdapCfg()
{
    TraceFunctEnterEx((LPARAM)this, "CLdapCfg::CLdapCfg");
    //
    // signature and number of servers should be set by the new operator
    //
    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFG);

    //
    // Zero out the array of pointers to CLdapServerCfg objects
    //
    ZeroMemory(m_prgpCLdapServerCfg, m_dwcServers * sizeof(CLdapServerCfg *));

    m_dwInc = 0;
    m_dwcConnectionFailures = 0;

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapCfg::CLdapCfg


//+------------------------------------------------------------
//
// Function: CLdapCfg::~CLdapCfg
//
// Synopsis: Clean up
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 14:47:25: Created.
//
//-------------------------------------------------------------
CLdapCfg::~CLdapCfg()
{
    DWORD dwCount;

    TraceFunctEnterEx((LPARAM)this, "CLdapCfg::~CLdapCfg");

    //
    // Release all connections configurations
    //
    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {
        CLdapServerCfg *pCLdapServerCfg;

        pCLdapServerCfg = m_prgpCLdapServerCfg[dwCount];
        m_prgpCLdapServerCfg[dwCount] = NULL;

        if(pCLdapServerCfg)
            pCLdapServerCfg->Release();
    }
    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFG);
    m_dwSignature = SIGNATURE_CLDAPCFG_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapCfg::~CLdapCfg



//+------------------------------------------------------------
//
// Function: CLdapCfg::HrInit
//
// Synopsis: Initialize the configuration
//
// Arguments:
//  dwcServers: Size of config array
//  prgSeverConfig: LDAPSERVERCONFIG array
//  pCLdapCfgOld: The previous configuration
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/17 13:52:20: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfg::HrInit(
    DWORD dwcServers,
    PLDAPSERVERCONFIG prgServerConfig,
    CLdapCfg *pCLdapCfgOld)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    TraceFunctEnterEx((LPARAM)this, "CLdapCfg::HrInit");
    //
    // m_dwcServers should be initialized by the new operator
    //
    _ASSERT(dwcServers == m_dwcServers);

    m_sharelock.ExclusiveLock();
    //
    // Zero out the array of pointers to CLdapServerCfg objects
    //
    ZeroMemory(m_prgpCLdapServerCfg, m_dwcServers * sizeof(CLdapServerCfg *));

    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {

        CLdapServerCfg *pServerCfg = NULL;

        hr = CLdapServerCfg::GetServerCfg(
            &(prgServerConfig[dwCount]),
            &pServerCfg);

        if(FAILED(hr))
            goto CLEANUP;

        m_prgpCLdapServerCfg[dwCount] = pServerCfg;
    }

    ShuffleArray();

 CLEANUP:
    m_sharelock.ExclusiveUnlock();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfg::HrInit


//+------------------------------------------------------------
//
// Function: CLdapCfg::HrGetConnection
//
// Synopsis: Select a connection and return it
//
// Arguments:
//  ppConn: Set to a pointer to the selected connection
//  pLdapConnectionCache: Cache to get connection from
//
// Returns:
//  S_OK: Success
//  E_FAIL: We are shutting down
//  error from ldapconn
//
// History:
// jstamerj 1999/06/17 14:49:37: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfg::HrGetConnection(
    CCfgConnection **ppConn,
    CCfgConnectionCache *pLdapConnectionCache)
{
    HRESULT hr = S_OK;
    LDAPSERVERCOST Cost, BestCost;
    DWORD dwCount;
    CLdapServerCfg *pCLdapServerCfg = NULL;
    BOOL fFirstServer = TRUE;
    DWORD dwStart, dwCurrent;

    TraceFunctEnterEx((LPARAM)this, "CLdapCfg::HrGetConnection");
    //
    // Get the cost of the first connection
    //
    m_sharelock.ShareLock();

    //
    // Round robin where we start searching the array
    // Do this so we will use connections with the same cost
    // approximately the same amount of time.
    //
    dwStart = InterlockedIncrement((PLONG) &m_dwInc) % m_dwcServers;

    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {

        dwCurrent = (dwStart + dwCount) % m_dwcServers;

        if(m_prgpCLdapServerCfg[dwCurrent]) {

            m_prgpCLdapServerCfg[dwCurrent]->Cost(&Cost);
            if(fFirstServer) {
                pCLdapServerCfg = m_prgpCLdapServerCfg[dwCurrent];
                fFirstServer = FALSE;
                BestCost = Cost;

            } else if(Cost < BestCost) {
                pCLdapServerCfg = m_prgpCLdapServerCfg[dwCurrent];
                BestCost = Cost;
            }
        }
    }
    if(pCLdapServerCfg == NULL) {
        ErrorTrace((LPARAM)this, "HrGetConnection can not find any connections");
        hr = E_FAIL;
        _ASSERT(0 && "HrInit not called or did not succeed");
        goto CLEANUP;
    }

    if(BestCost >= COST_TOO_HIGH_TO_CONNECT) {
        DebugTrace((LPARAM)this, "BestCost is too high to attempt connection");
        hr = CAT_E_DBCONNECTION;
        goto CLEANUP;
    }

    hr = pCLdapServerCfg->HrGetConnection(ppConn, pLdapConnectionCache);

    //  If we fail to connect to a GC --- there may be other GCs which
    //  are still up. Therefore we should try to connect to them (till
    //  we run out of GCs (BestCost >= COST_TOO_HIGH_TO_CONNECT)

    if(FAILED(hr)) {
        DebugTrace((LPARAM)this, "Failed to connect. hr = 0x%08x", hr);
        hr = HRESULT_FROM_WIN32(ERROR_RETRY);
    }

 CLEANUP:
    m_sharelock.ShareUnlock();

    if(FAILED(hr))
        InterlockedIncrement((PLONG)&m_dwcConnectionFailures);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfg::HrGetConnection


//+------------------------------------------------------------
//
// Function: CLdapCfg::ShuffleArray
//
// Synopsis: Randomize the order of the CLdapServerCfg array
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 19:10:06: Created.
//
//-------------------------------------------------------------
VOID CLdapCfg::ShuffleArray()
{
    DWORD dwCount;
    DWORD dwSwap;
    CLdapServerCfg *pTmp;
    TraceFunctEnterEx((LPARAM)this, "CLdapCfg::ShuffleArray");

    srand((int)(GetCurrentThreadId() * time(NULL)));

    for(dwCount = 0; dwCount < (m_dwcServers - 1); dwCount++) {
        //
        // Choose an integer between dwCount and m_dwcServers - 1
        //
        dwSwap = dwCount + (rand() % (m_dwcServers - dwCount));
        //
        // Swap pointers
        //
        pTmp = m_prgpCLdapServerCfg[dwCount];
        m_prgpCLdapServerCfg[dwCount] = m_prgpCLdapServerCfg[dwSwap];
        m_prgpCLdapServerCfg[dwSwap] = pTmp;
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapCfg::ShuffleArray



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::CLdapServerCfg
//
// Synopsis: Initialize member variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 15:30:32: Created.
//
//-------------------------------------------------------------
CLdapServerCfg::CLdapServerCfg()
{
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::CLdapServerCfg");

    m_dwSignature = SIGNATURE_CLDAPSERVERCFG;

    m_ServerConfig.dwPort = 0;
    m_ServerConfig.pri = 0;
    m_ServerConfig.bt = BIND_TYPE_NONE;
    m_ServerConfig.szHost[0] = '\0';
    m_ServerConfig.szNamingContext[0] = '\0';
    m_ServerConfig.szAccount[0] = '\0';
    m_ServerConfig.szPassword[0] = '\0';

    m_connstate = CONN_STATE_INITIAL;
    ZeroMemory(&m_ftLastStateUpdate, sizeof(m_ftLastStateUpdate));
    m_dwcPendingSearches = 0;
    m_lRefCount = 1;
    m_fLocalServer = FALSE;
    m_dwcCurrentConnectAttempts = 0;
    m_dwcFailedConnectAttempts = 0;

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::CLdapServerCfg


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::~CLdapServerCfg
//
// Synopsis: object destructor.  Check and invalidate signature
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/22 11:09:03: Created.
//
//-------------------------------------------------------------
CLdapServerCfg::~CLdapServerCfg()
{
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::~CLdapServerCfg");

    _ASSERT(m_dwSignature == SIGNATURE_CLDAPSERVERCFG);
    m_dwSignature = SIGNATURE_CLDAPSERVERCFG_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::~CLdapServerCfg


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::HrInit
//
// Synopsis: Initialize with the passed in config
//
// Arguments:
//  pCLdapCfg: the cfg object to notify when servers go down
//  pServerConfig: The server config struct to use
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/17 15:43:25: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::HrInit(
    PLDAPSERVERCONFIG pServerConfig)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::HrInit");

    CopyMemory(&m_ServerConfig, pServerConfig, sizeof(m_ServerConfig));
    //
    // Check if this is the local computer
    //
    if(fIsLocalComputer(pServerConfig))
        m_fLocalServer = TRUE;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapServerCfg::HrInit



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::fIsLocalComputer
//
// Synopsis: Determine if pServerConfig is the local computer or not
//
// Arguments:
//  pServerConfig: the server config info structure
//
// Returns:
//  TRUE: Server is the local computer
//  FALSE: Sevrver is a remote computer
//
// History:
// jstamerj 1999/06/22 15:26:53: Created.
//
//-------------------------------------------------------------
BOOL CLdapServerCfg::fIsLocalComputer(
    PLDAPSERVERCONFIG pServerConfig)
{
    BOOL fLocal = FALSE;
    DWORD dwSize;
    CHAR szHost[CAT_MAX_DOMAIN];
    TraceFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::fIsLocalComputer");

    //
    // Check the FQ name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameDnsFullyQualified,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;
    }

    //
    // Check the DNS name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameDnsHostname,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;
    }
    //
    // Check the netbios name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameNetBIOS,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;

    }

 CLEANUP:
    DebugTrace((LPARAM)NULL, "returning %08lx", fLocal);
    TraceFunctLeaveEx((LPARAM)NULL);
    return fLocal;
} // CLdapServerCfg::fIsLocalComputer


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::Cost
//
// Synopsis: Return the cost of choosing this connection
//
// Arguments:
//  pCost: Cost sturcture to fill in
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 16:08:23: Created.
//
//-------------------------------------------------------------
VOID CLdapServerCfg::Cost(
    OUT PLDAPSERVERCOST pCost)
{
    BOOL fShareLock = FALSE;
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::Cost");
    //
    // The smallest unit of cost is the number of pending searches.
    // The next factor of cost is the connection state.
    // States:
    //   Connected = + COST_CONNECTED
    //   Initially state (unconnected) = + COST_INITIAL
    //   Connection down = + COST_RETRY
    //   Connection recently went down = + COST_DOWN
    //
    // A configurable priority is always added to the cost.
    // Also, COST_REMOTE is added to the cost of all non-local servers.
    //
    *pCost = m_ServerConfig.pri + m_dwcPendingSearches;
    //
    // Protect the connection state variables with a spinlock
    //
    m_sharelock.ShareLock();
    fShareLock = TRUE;

    switch(m_connstate) {

     case CONN_STATE_INITIAL:
         (*pCost) += (m_fLocalServer) ? COST_INITIAL_LOCAL : COST_INITIAL_REMOTE;
         break;

     case CONN_STATE_RETRY:
         if(m_dwcCurrentConnectAttempts >= MAX_CONNECT_THREADS)
             (*pCost) += COST_TOO_HIGH_TO_CONNECT;
         else
             (*pCost) += (m_fLocalServer) ? COST_RETRY_LOCAL : COST_RETRY_REMOTE;
         break;

     case CONN_STATE_DOWN:
         //
         // Check if the state should be changed to CONN_STATE_RETRY
         //
         if(fReadyForRetry()) {
             (*pCost) += (m_fLocalServer) ? COST_RETRY_LOCAL : COST_RETRY_REMOTE;
             //
             // Change state
             //
             fShareLock = FALSE;
             m_sharelock.ShareUnlock();
             m_sharelock.ExclusiveLock();
             //
             // Double check in the exclusive lock
             //
             if((m_connstate == CONN_STATE_DOWN) &&
                fReadyForRetry()) {

                 m_connstate = CONN_STATE_RETRY;
             }
             m_sharelock.ExclusiveUnlock();

         } else {
             //
             // Server is probably still down (don't retry yet)
             //
             (*pCost) += (m_fLocalServer) ? COST_DOWN_LOCAL : COST_DOWN_REMOTE;

         }
         break;

     case CONN_STATE_CONNECTED:
         (*pCost) += (m_fLocalServer) ? COST_CONNECTED_LOCAL : COST_CONNECTED_REMOTE;
         break;

     default:
         // Nothing to add
         break;
    }
    if(fShareLock)
        m_sharelock.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::Cost


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::HrGetConnection
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/18 10:49:04: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::HrGetConnection(
    CCfgConnection **ppConn,
    CCfgConnectionCache *pLdapConnectionCache)
{
    HRESULT hr = S_OK;
    DWORD dwcConnectAttempts = 0;
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::HrGetConnection");

    dwcConnectAttempts = (DWORD) InterlockedIncrement((PLONG) &m_dwcCurrentConnectAttempts);

    m_sharelock.ShareLock();
    if((m_connstate == CONN_STATE_RETRY) &&
       (dwcConnectAttempts > MAX_CONNECT_THREADS)) {

            m_sharelock.ShareUnlock();

            ErrorTrace((LPARAM)this, "Over max connect thread limit");
            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
            goto CLEANUP;
    }
    m_sharelock.ShareUnlock();

    DebugTrace((LPARAM)this, "Attempting to connect to %s:%d",
               m_ServerConfig.szHost,
               m_ServerConfig.dwPort);

    hr = pLdapConnectionCache->GetConnection(
        ppConn,
        &m_ServerConfig,
        this);
    //
    // CCfgConnection::Connect will update the connection state
    //
 CLEANUP:
    InterlockedDecrement((PLONG) &m_dwcCurrentConnectAttempts);
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapServerCfg::HrGetConnection


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::UpdateConnectionState
//
// Synopsis: Update the connection state.
//
// Arguments:
//  pft: Time of update -- if this time is before the last update done,
//       then this update will be ignored.
//       If NULL, the function will assume the current time.
//  connstate: The new connection state.
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/18 13:22:25: Created.
//
//-------------------------------------------------------------
VOID CLdapServerCfg::UpdateConnectionState(
    ULARGE_INTEGER *pft_IN,
    CONN_STATE connstate)
{
    ULARGE_INTEGER ft, *pft;
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::UpdateConnectionState");

    if(pft_IN != NULL) {
        pft = pft_IN;
    } else {
        ft = GetCurrentTime();
        pft = &ft;
    }

    //
    // Protect connection state variables with a sharelock
    //
    m_sharelock.ShareLock();
    //
    // If we have the latest information about the connection state,
    // then update the state if the connection state changed.
    // Also update m_ftLastStateUpdate to the latest ft when the
    // connection state is down -- m_ftLastStateUpdate is assumed to
    // be the last connection attempt time when connstate is down.
    //
    if( (pft->QuadPart > m_ftLastStateUpdate.QuadPart) &&
        ((m_connstate != connstate) ||
         (connstate == CONN_STATE_DOWN))) {
        //
        // We'd like to update the connection state
        //
        m_sharelock.ShareUnlock();
        m_sharelock.ExclusiveLock();
        //
        // Double check
        //
        if( (pft->QuadPart > m_ftLastStateUpdate.QuadPart) &&
            ((m_connstate != connstate) ||
             (connstate == CONN_STATE_DOWN))) {
            //
            // Update
            //
            m_ftLastStateUpdate = *pft;
            m_connstate = connstate;

            DebugTrace((LPARAM)this, "Updating state %d, conn %s:%d",
                       connstate,
                       m_ServerConfig.szHost,
                       m_ServerConfig.dwPort);

        } else {

            DebugTrace((LPARAM)this, "Ignoring state update %d, conn %s:%d",
                       connstate,
                       m_ServerConfig.szHost,
                       m_ServerConfig.dwPort);
        }
        m_sharelock.ExclusiveUnlock();

    } else {

        DebugTrace((LPARAM)this, "Ignoring state update %d, conn %s:%d",
                   connstate,
                   m_ServerConfig.szHost,
                   m_ServerConfig.dwPort);

        m_sharelock.ShareUnlock();
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::UpdateConnectionState


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::GetServerCfg
//
// Synopsis: Find or Create a CLdapServerCfg object with the specified
//           configuration.
//
// Arguments:
//  pServerConfig: desired configuration
//  pCLdapServerCfg: return pointer for the CLdapServerCfg object
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/21 11:26:49: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::GetServerCfg(
    IN  PLDAPSERVERCONFIG pServerConfig,
    OUT CLdapServerCfg **ppCLdapServerCfg)
{
    HRESULT hr = S_OK;
    CLdapServerCfg *pCCfg;
    TraceFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::GetServerCfg");

    m_listlock.ShareLock();

    pCCfg = FindServerCfg(pServerConfig);
    if(pCCfg)
        pCCfg->AddRef();

    m_listlock.ShareUnlock();

    if(pCCfg == NULL) {
        //
        // Check again for a server cfg object inside an exclusive
        // lock
        //
        m_listlock.ExclusiveLock();

        pCCfg = FindServerCfg(pServerConfig);
        if(pCCfg) {
            pCCfg->AddRef();
        } else {
            //
            // Create a new object
            //
            pCCfg = new CLdapServerCfg();
            if(pCCfg == NULL) {

                hr = E_OUTOFMEMORY;

            } else {

                hr = pCCfg->HrInit(pServerConfig);
                if(FAILED(hr)) {
                    delete pCCfg;
                    pCCfg = NULL;
                } else {
                    //
                    // Add to global list
                    //
                    InsertTailList(&m_listhead, &(pCCfg->m_le));
                }
            }
        }
        m_listlock.ExclusiveUnlock();
    }
    //
    // Set out parameter
    //
    *ppCLdapServerCfg = pCCfg;

    DebugTrace((LPARAM)NULL, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)NULL);
    return hr;

} // CLdapServerCfg::GetServerCfg



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::FindServerCfg
//
// Synopsis: Find a server cfg object that matches the
//           LDAPSERVERCONFIG structure.  Note, m_listlock must be
//           locked when calling this function.
//
// Arguments:
//  pServerConfig: pointer to the LDAPSERVERCONFIG struct
//
// Returns:
//  NULL: there is no such server cfg object
//  else, ptr to the found CLdapServerCfg object
//
// History:
// jstamerj 1999/06/21 10:43:23: Created.
//
//-------------------------------------------------------------
CLdapServerCfg * CLdapServerCfg::FindServerCfg(
    PLDAPSERVERCONFIG pServerConfig)
{
    CLdapServerCfg *pMatch = NULL;
    PLIST_ENTRY ple;
    TraceFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::FindServerCfg");

    for(ple = m_listhead.Flink;
        (ple != &m_listhead) && (pMatch == NULL);
        ple = ple->Flink) {

        CLdapServerCfg *pCandidate = NULL;

        pCandidate = CONTAINING_RECORD(ple, CLdapServerCfg, m_le);

        if(pCandidate->fMatch(
            pServerConfig)) {

            pMatch = pCandidate;
        }
    }

    TraceFunctLeaveEx((LPARAM)NULL);
    return pMatch;
} // CLdapServerCfg::FindServerCfg



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::fMatch
//
// Synopsis: Determine if this object matches the passed in config
//
// Arguments:
//  pServerConfig: config to check against
//
// Returns:
//  TRUE: match
//  FALSE: no match
//
// History:
// jstamerj 1999/06/21 12:45:10: Created.
//
//-------------------------------------------------------------
BOOL CLdapServerCfg::fMatch(
    PLDAPSERVERCONFIG pServerConfig)
{
    BOOL fRet;
    TraceFunctEnterEx((LPARAM)this, "CLdapServerCfg::fMatch");

    if((pServerConfig->dwPort != m_ServerConfig.dwPort) ||
       (pServerConfig->bt     != m_ServerConfig.bt) ||
       (lstrcmpi(pServerConfig->szHost,
                 m_ServerConfig.szHost) != 0) ||
       (lstrcmpi(pServerConfig->szNamingContext,
                 m_ServerConfig.szNamingContext) != 0) ||
       (lstrcmpi(pServerConfig->szAccount,
                 m_ServerConfig.szAccount) != 0) ||
       (lstrcmpi(pServerConfig->szPassword,
                 m_ServerConfig.szPassword) != 0)) {

        fRet = FALSE;

    } else {

        fRet = TRUE;
    }

    DebugTrace((LPARAM)this, "returning %08lx", fRet);
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
} // CLdapServerCfg::fMatch



//+------------------------------------------------------------
//
// Function: CCfgConnection::Connect
//
// Synopsis: Cfg wrapper for the Connect call.
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//  CAT_E_DBCONNECTION (or whatever CBatchLdapConnection::Connect returns)
//
// History:
// jstamerj 2000/04/13 17:44:43: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnection::Connect()
{
    HRESULT hr = S_OK;
    ULARGE_INTEGER ft;
    CONN_STATE connstate;
    TraceFunctEnterEx((LPARAM)this, "CCfgConnection::Connect");

    connstate = m_pCLdapServerCfg->CurrentState();
    if(connstate == CONN_STATE_DOWN) {

        DebugTrace((LPARAM)this, "Not connecting because %s:%d is down",
                   m_szHost, m_dwPort);
        hr = CAT_E_DBCONNECTION;
        goto CLEANUP;
    }

    ft = m_pCLdapServerCfg->GetCurrentTime();

    hr = CBatchLdapConnection::Connect();
    if(FAILED(hr)) {
        connstate = CONN_STATE_DOWN;
        m_pCLdapServerCfg->IncrementFailedCount();
    } else {
        connstate = CONN_STATE_CONNECTED;
        m_pCLdapServerCfg->ResetFailedCount();
    }
    //
    // Update the connection state while inside CLdapConnectionCache's
    // lock.  This will prevent a succeeding thread from attempting
    // another connection to the GC right after CLdapConnectionCache
    // releases its lock.  Contact msanna for more details.
    //
    m_pCLdapServerCfg->UpdateConnectionState(&ft, connstate);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCfgConnection::Connect


//+------------------------------------------------------------
//
// Function: CCfgConnection::AsyncSearch
//
// Synopsis: Wrapper around AsyncSearch -- keep track of the # of
//           pending searches and connection state.
//
// Arguments: See CLdapConnection::AsyncSearch
//
// Returns:
//  Value returned from CLdapConnection::AsyncSearch
//
// History:
// jstamerj 1999/06/18 13:49:45: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnection::AsyncSearch(
    LPCWSTR szBaseDN,
    int nScope,
    LPCWSTR szFilter,
    LPCWSTR szAttributes[],
    DWORD dwPageSize,
    LPLDAPCOMPLETION fnCompletion,
    LPVOID ctxCompletion)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CCfgConnection::AsyncSearch");

    m_pCLdapServerCfg->IncrementPendingSearches();

    hr = CBatchLdapConnection::AsyncSearch(
        szBaseDN,
        nScope,
        szFilter,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);

    if(FAILED(hr)) {

        m_pCLdapServerCfg->DecrementPendingSearches();
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCfgConnection::AsyncSearch


//+------------------------------------------------------------
//
// Function: CCfgConnection::CallCompletion
//
// Synopsis: Wrapper around CLdapConnection::CallCompletion.  Checks
//           for server down errors and keeps track of pending searches.
//
// Arguments: See CLdapConnection::CallCompletion
//
// Returns: See CLdapConnection::CallCompletion
//
// History:
// jstamerj 1999/06/18 13:58:28: Created.
//
//-------------------------------------------------------------
VOID CCfgConnection::CallCompletion(
    PPENDING_REQUEST preq,
    PLDAPMessage pres,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    TraceFunctEnterEx((LPARAM)this, "CCfgConnection::CallCompletion");

    //
    // The user(s) of CLdapConnection normally try to get a new
    // connection and reissue their search when AsyncSearch
    // fails.  When opening a new connection fails, CLdapServerCfg
    // will be notified that the LDAP server is down.  We do not
    // want to call NotifyServerDown() here because the LDAP
    // server may have just closed this connection due to idle
    // time (the server may not actually be down).
    //
    if(fFinalCompletion) {

        m_pCLdapServerCfg->DecrementPendingSearches();
    }

    CBatchLdapConnection::CallCompletion(
        preq,
        pres,
        hrStatus,
        fFinalCompletion);

    TraceFunctLeaveEx((LPARAM)this);
} // CCfgConnection::CallCompletion


//+------------------------------------------------------------
//
// Function: CCfgConnection::NotifyServerDown
//
// Synopsis: Notify the server config that this connection is down.
//           If we already notified it, don't do so again.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/18 14:07:48: Created.
//
//-------------------------------------------------------------
VOID CCfgConnection::NotifyServerDown()
{
    BOOL fNotify;
    TraceFunctEnterEx((LPARAM)this, "CCfgConnection::NotifyServerDown");

    m_sharelock.ShareLock();
    if(m_connstate == CONN_STATE_DOWN) {
        //
        // We already notified m_pCLdapServerCfg the server went
        // down.  Don't repeteadly call it
        //
        fNotify = FALSE;

        m_sharelock.ShareUnlock();

    } else {

        m_sharelock.ShareUnlock();
        m_sharelock.ExclusiveLock();
        //
        // Double check
        //
        if(m_connstate == CONN_STATE_DOWN) {

            fNotify = FALSE;

        } else {

            m_connstate = CONN_STATE_DOWN;
            fNotify = TRUE;
        }
        m_sharelock.ExclusiveUnlock();
    }
    if(fNotify)
        m_pCLdapServerCfg->UpdateConnectionState(
            NULL,               // Current time
            CONN_STATE_DOWN);

    TraceFunctLeaveEx((LPARAM)this);
} // CCfgConnection::NotifyServerDown


//+------------------------------------------------------------
//
// Function: CatStoreInitGlobals
//
// Synopsis: This is called to initialize global variables in the
//           store layer.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/22 11:03:53: Created.
//
//-------------------------------------------------------------
HRESULT CatStoreInitGlobals()
{
    TraceFunctEnterEx((LPARAM)NULL, "CatStoreInitGlobals");

    CLdapServerCfg::GlobalInit();

    TraceFunctLeaveEx((LPARAM)NULL);
    return S_OK;
} // CatStoreInitGlobals


//+------------------------------------------------------------
//
// Function: CatStoreDeinitGlobals
//
// Synopsis: Called to deinitialize store layer globals -- called once
//           only when CatStoreInitGlobals succeeds
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/22 11:05:44: Created.
//
//-------------------------------------------------------------
VOID CatStoreDeinitGlobals()
{
    TraceFunctEnterEx((LPARAM)NULL, "CatStoreDeinitGlobals");
    //
    // Nothing to do
    //
    TraceFunctLeaveEx((LPARAM)NULL);
} // CatStoreDeinitGlobals


//+------------------------------------------------------------
//
// Function: CCfgConnectionCache::GetConnection
//
// Synopsis: Same as CLdapConnectionCache::GetConnection, except
//           retrieves a CCfgConnection instead of a CLdapConnection.
//
// Arguments:
//  ppConn: out parameter for new connection
//  pServerConfig: desired configuration
//  pCLdapServerConfig: Pointer to config object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/20 16:49:12: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnectionCache::GetConnection(
    CCfgConnection **ppConn,
    PLDAPSERVERCONFIG pServerConfig,
    CLdapServerCfg *pCLdapServerConfig)
{
    return CBatchLdapConnectionCache::GetConnection(
        (CBatchLdapConnection **)ppConn,
        pServerConfig->szHost,
        pServerConfig->dwPort,
        pServerConfig->szNamingContext,
        pServerConfig->szAccount,
        pServerConfig->szPassword,
        pServerConfig->bt,
        (PVOID) pCLdapServerConfig); // pCreateContext
} // CCfgConnectionCache::GetConnection


//+------------------------------------------------------------
//
// Function: CCfgConnectionCache::CreateCachedLdapConnection
//
// Synopsis: Create a CCfgConnection (Called by GetConnection only)
//
// Arguments: See CLdapConnectionCache::CreateCachedLdapConnection
//
// Returns:
//  Connection ptr if successfull.
//  NULL if unsuccessfull.
//
// History:
// jstamerj 1999/12/20 16:57:49: Created.
//
//-------------------------------------------------------------
CCfgConnectionCache::CCachedLdapConnection * CCfgConnectionCache::CreateCachedLdapConnection(
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE bt,
    PVOID pCreateContext)
{
    CCfgConnection *pret;
    pret = new CCfgConnection(
        szHost,
        dwPort,
        szNamingContext,
        szAccount,
        szPassword,
        bt,
        this,
        (CLdapServerCfg *)pCreateContext);

    if(pret)
        if(FAILED(pret->HrInitialize())) {
            pret->Release();
            pret = NULL;
        }
    return pret;
} // CCfgConnectionCache::CreateCachedLdapConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\asyncctx.h ===
//
// asyncctx.h -- This file contains the class definitions for:
//   CSearchRequestBlock
//   CBatchLdapConnection
//   CBatchLdapConnectionCache
//   CStoreListResolveContext
//
// Created:
//      Feb 19, 1997 -- Milan Shah (milans)
//
// Changes:
// jstamerj 1999/03/16 15:29:20: Heavily modified to batch requests
//                               togethor across multiple message
//                               categorizations
// jstamerj 1999/03/22 12:44:01: Modified to support throttling via a
//                               queue of CInsertionRequest objects 
//

#ifndef _ASYNCCTX_H_
#define _ASYNCCTX_H_

#include "ldapconn.h"
#include "ccataddr.h"
#include "simparray.h"
#include "icatqueries.h"
#include "icatasync.h"

class CBatchLdapConnectionCache;
class CCfgConnection;
template <class T> class CEmailIDLdapStore;

//
// The MCIS3 LDAP server beta 1 does not correctly handle queries with more
// than 4 legs in an OR clause. Because of this, we need to limit our search
// query compression on a configurable basis. The global value,
// nMaxSearchBlockSize constrains how many searches will be compressed into
// a single search. The value is read from the registry key
// szMaxSearchBlockSize. If it is not present, it defaults to
// MAX_SEARCH_BLOCK_SIZE.
//

#define MAX_SEARCH_BLOCK_SIZE_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define MAX_SEARCH_BLOCK_SIZE_VALUE "MaxSearchBlockSize"

#define MAX_SEARCH_BLOCK_SIZE   20

#define MAX_PENDING_SEARCHES_VALUE  "MaxPendingSearches"

#define MAX_PENDING_SEARCHES    1024

#define MAX_CONNECTION_RETRIES  10

class CBatchLdapConnectionCache;
class CBatchLdapConnection;

typedef VOID (*LPFNLIST_COMPLETION)(VOID *lpContext);

typedef VOID (*LPSEARCHCOMPLETION)(
    CCatAddr *pCCatAddr,
    LPVOID lpContext,
    CBatchLdapConnection *pConn);


//------------------------------------------------------------
//
// Class CSearchRequestBlock
//
//------------------------------------------------------------
CatDebugClass(CSearchRequestBlock) 
{
  private:
    typedef struct _SearchRequest {
        CCatAddr *pCCatAddr;
        LPSEARCHCOMPLETION fnSearchCompletion;
        LPVOID  ctxSearchCompletion;
        LPSTR   pszSearchFilter;
        LPSTR   pszDistinguishingAttribute;
        LPSTR   pszDistinguishingAttributeValue;
    } SEARCH_REQUEST, *PSEARCH_REQUEST;

    #define SIGNATURE_CSEARCHREQUESTBLOCK           (DWORD)'lBRS'
    #define SIGNATURE_CSEARCHREQUESTBLOCK_INVALID   (DWORD)'lBRX'

  public:
    void * operator new(size_t size, DWORD dwNumRequests);
        
    CSearchRequestBlock(
        CBatchLdapConnection *pConn);

    ~CSearchRequestBlock();

    VOID InsertSearchRequest(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams,
        CCatAddr *pCCatAddr,
        LPSEARCHCOMPLETION fnSearchCompletion,
        LPVOID  ctxSearchCompletion,
        LPSTR   pszSearchFilter,
        LPSTR   pszDistinguishingAttribute,
        LPSTR   pszDistinguishingAttributeValue);

    VOID DispatchBlock();
    
    HRESULT ReserveSlot()
    {
        if( ((DWORD)InterlockedIncrement((PLONG)&m_cBlockRequestsReserved)) > m_cBlockSize)
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else
            return S_OK;
    }

    HRESULT AddResults(
        DWORD dwNumResults,
        ICategorizerItemAttributes **rgpItemAttributes)
    {
        HRESULT hr;
        hr = m_csaItemAttr.AddArray(
            dwNumResults,
            rgpItemAttributes);

        if(SUCCEEDED(hr)) {
            //
            // AddRef all the interfaces we hold
            //
            for(DWORD dwCount = 0; dwCount < dwNumResults; dwCount++) {
                
                rgpItemAttributes[dwCount]->AddRef();
            }
        }
        return hr;
    }

  private:
    PSEARCH_REQUEST GetNextSearchRequest(DWORD *pdwIndex)
    {
        *pdwIndex = InterlockedIncrement((PLONG)&m_cBlockRequestsAllocated) - 1;
        _ASSERT(*pdwIndex < m_cBlockSize);
        
        return &(m_prgSearchRequests[*pdwIndex]);
    }

    VOID CompleteBlockWithError(HRESULT hr)
    {
        PutBlockHRESULT(hr);
        CallCompletions();
    }

    static VOID LDAPCompletion(
        LPVOID ctx,
        DWORD dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttributes,
        HRESULT hrStatus,
        BOOL fFinalCompletion);

    HRESULT HrTriggerBuildQueries();
    HRESULT HrTriggerSendQuery();

    static HRESULT HrBuildQueriesDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    static HRESULT HrSendQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    static HRESULT HrSendQueryCompletion(
        HRESULT HrStatus,
        PVOID   pContext);

    VOID CompleteSearchBlock(
        HRESULT hrStatus);

    HRESULT HrTriggerSortQueryResult(
        HRESULT hrStatus);

    static HRESULT HrSortQueryResultDefault(
        HRESULT hrStatus,
        PVOID   pContext);

    VOID PutBlockHRESULT(
        HRESULT hr);

    VOID CallCompletions();

    VOID MatchItem(
        ICategorizerItem *pICatItem,
        ICategorizerItemAttributes *pICatItemAttr);

    DWORD DwNumBlockRequests()
    {
        return m_cBlockRequestsReadyForDispatch;
    }

    DWORD m_dwSignature;
    ISMTPServer *m_pISMTPServer;
    ICategorizerParameters *m_pICatParams;
    DWORD m_cBlockRequestsReserved;
    DWORD m_cBlockRequestsAllocated;
    DWORD m_cBlockRequestsReadyForDispatch;
    DWORD m_cBlockSize;
    LIST_ENTRY m_listentry;
    PSEARCH_REQUEST m_prgSearchRequests;
    ICategorizerItem **m_rgpICatItems;
    CBatchLdapConnection *m_pConn;
    LPSTR m_pszSearchFilter;
    CICategorizerQueriesIMP m_CICatQueries;
    CICategorizerAsyncContextIMP m_CICatAsyncContext;
    CSimpArray<ICategorizerItemAttributes *> m_csaItemAttr;

    friend class CBatchLdapConnection;
    friend class CICategorizerAsyncContextIMP;
};
     
//------------------------------------------------------------
//
// Class CBatchLdapConnection
//
//------------------------------------------------------------
class CBatchLdapConnection : 
    public CLdapConnectionCache::CCachedLdapConnection
{
  private:
    #define SIGNATURE_CBATCHLDAPCONN            (DWORD)'oCLB'
    #define SIGNATURE_CBATCHLDAPCONN_INVALID    (DWORD)'oCLX'

  public:
    CBatchLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        CLdapConnectionCache *pCache) :
        CCachedLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCache)
    {
        m_dwSignature = SIGNATURE_CBATCHLDAPCONN;
        m_pInsertionBlock = NULL;
        InitializeListHead(&m_listhead);
        InitializeSpinLock(&m_spinlock);
        m_cInsertionContext = 0;
        if(m_nMaxSearchBlockSize == 0)
            InitializeFromRegistry();
        InitializeSpinLock(&m_spinlock_insertionrequests);
        m_dwcPendingSearches = 0;
        m_dwcReservedSearches = 0;
        InitializeListHead(&m_listhead_insertionrequests);
        InitializeListHead(&m_listhead_cancelnotifies);
    }

    ~CBatchLdapConnection()
    {
        _ASSERT(m_dwSignature == SIGNATURE_CBATCHLDAPCONN);
        m_dwSignature = SIGNATURE_CBATCHLDAPCONN_INVALID;
        _ASSERT(m_dwcPendingSearches == 0);
    }
            
    CLdapConnection *GetConnection()
    {
        return( this );
    }

    VOID GetInsertionContext()
    {
        AcquireSpinLock(&m_spinlock);
        m_cInsertionContext++;
        ReleaseSpinLock(&m_spinlock);
    }

    VOID ReleaseInsertionContext()
    {
        AcquireSpinLock(&m_spinlock);
        if((--m_cInsertionContext) == 0) {

            LIST_ENTRY listhead_dispatch;
            //
            // Remove all blocks from the insertion list and put them in the dispatch list
            //
            if(IsListEmpty(&m_listhead)) {
                // No blocks
                ReleaseSpinLock(&m_spinlock);

                InitializeListHead(&listhead_dispatch);

            } else {
                
                CopyMemory(&listhead_dispatch, &m_listhead, sizeof(LIST_ENTRY));
                listhead_dispatch.Blink->Flink = &listhead_dispatch;
                listhead_dispatch.Flink->Blink = &listhead_dispatch;
                InitializeListHead(&m_listhead);

                ReleaseSpinLock(&m_spinlock);
                //
                // Dispatch all the blocks
                //
                DispatchBlocks(&listhead_dispatch);
            }

        } else {
            
            ReleaseSpinLock(&m_spinlock);
        }
    }

    HRESULT HrInsertSearchRequest(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams,
        CCatAddr *pCCatAddr,
        LPSEARCHCOMPLETION fnSearchCompletion,
        LPVOID  ctxSearchCompletion,
        LPSTR   pszSearchFilter,
        LPSTR   pszDistinguishingAttribute,
        LPSTR   pszDistinguishingAttributeValue);

    static VOID InitializeFromRegistry();

    VOID IncrementPendingSearches()
    {
        AcquireSpinLock(&m_spinlock_insertionrequests);
        m_dwcPendingSearches++;
        ReleaseSpinLock(&m_spinlock_insertionrequests);
    }
    VOID DecrementPendingSearches(DWORD dwcSearches = 1);

    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest);

    VOID CancelAllSearches(
        HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED));

  private:
    CSearchRequestBlock *GetSearchRequestBlock();

    VOID RemoveSearchRequestBlockFromList(
        CSearchRequestBlock *pBlock)
    {
        AcquireSpinLock(&m_spinlock);
        RemoveEntryList(&(pBlock->m_listentry));
        ReleaseSpinLock(&m_spinlock);
    }

    VOID DispatchBlocks(PLIST_ENTRY listhead);

  private:
    static DWORD m_nMaxSearchBlockSize;
    static DWORD m_nMaxPendingSearches;

    DWORD m_dwSignature;
    LIST_ENTRY m_listhead;
    SPIN_LOCK m_spinlock;
    LONG m_cInsertionContext;
    CSearchRequestBlock *m_pInsertionBlock;

    SPIN_LOCK m_spinlock_insertionrequests;
    DWORD m_dwcPendingSearches;
    DWORD m_dwcReservedSearches;
    LIST_ENTRY m_listhead_insertionrequests;

    typedef struct _tagCancelNotify {
        LIST_ENTRY le;
        HRESULT hrCancel;
    } CANCELNOTIFY, *PCANCELNOTIFY;
    // This list is also protected by m_spinlock_insertionrequests
    LIST_ENTRY m_listhead_cancelnotifies;

    CExShareLock m_cancellock;

    friend class CSearchRequestBlock;
};

//------------------------------------------------------------
//
// class CBatchLdapConnectionCache
//
//------------------------------------------------------------
class CBatchLdapConnectionCache : 
    public CLdapConnectionCache
{
  public:
    HRESULT GetConnection(
        CBatchLdapConnection **ppConn,
        LPSTR szHost,                 
        DWORD dwPort,
        LPSTR szNamingContext,        
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext = NULL)
    {
        return CLdapConnectionCache::GetConnection(
            (CLdapConnection **)ppConn,
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCreateContext);
    }

    CCachedLdapConnection *CreateCachedLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext)
    {
        CCachedLdapConnection *pret;
        pret = new CBatchLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            this);

        if(pret)
            if(FAILED(pret->HrInitialize())) {
                pret->Release();
                pret = NULL;
            }
        return pret;
    }
};

//------------------------------------------------------------
//
// class CStoreListResolveContext
//
//------------------------------------------------------------
CatDebugClass(CStoreListResolveContext)
{
  public:
    CStoreListResolveContext(CEmailIDLdapStore<CCatAddr> *pStore);    
    ~CStoreListResolveContext();

    HRESULT HrInitialize(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams);
        
    HRESULT HrLookupEntryAsync(
        CCatAddr *pCCatAddr);
    VOID Cancel();

    CCfgConnection *GetConnection();

    VOID GetInsertionContext();
    VOID ReleaseInsertionContext();
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest);

  private:
    static VOID AsyncLookupCompletion(
        CCatAddr *pCCatAddr,
        LPVOID    lpContext,
        CBatchLdapConnection *pConn);

    HRESULT HrInvalidateConnectionAndRetrieveNewConnection(
        CBatchLdapConnection *pConn);

  private:
    #define SIGNATURE_CSTORELISTRESOLVECONTEXT          (DWORD)'CRLS'
    #define SIGNATURE_CSTORELISTRESOLVECONTEXT_INVALID  (DWORD)'XRLS'

    DWORD m_dwSignature;
    CCfgConnection *m_pConn;
    
    SPIN_LOCK m_spinlock;
    DWORD m_dwcInsertionContext;
    BOOL  m_fCanceled;
    DWORD m_dwcRetries;
    ISMTPServer *m_pISMTPServer;
    ICategorizerParameters *m_pICatParams;
    CEmailIDLdapStore<CCatAddr> *m_pStore;
};
    

inline CSearchRequestBlock::CSearchRequestBlock(
    CBatchLdapConnection *pConn) :
    m_CICatQueries( &m_pszSearchFilter )
{
    _ASSERT(m_dwSignature == SIGNATURE_CSEARCHREQUESTBLOCK);
    m_pISMTPServer = NULL;
    m_pICatParams = NULL;
    m_pszSearchFilter = NULL;
    m_cBlockRequestsReserved = 0;
    m_cBlockRequestsAllocated = 0;
    m_cBlockRequestsReadyForDispatch = 0;
    m_pConn = pConn;
    m_pConn->AddRef();
}            

#endif _ASYNCCTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatitemattr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitemattr.cpp
//
// Contents: Implementation of CICategorizerItemAttributesIMP
//
// Classes:
//   CLdapResultWrap
//   CICategorizerItemAttributesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/01 13:48:15: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitemattr.h"



//+------------------------------------------------------------
//
// Function: CLdapResultWrap::CLdapResultWrap
//
// Synopsis: Refcount an LDAP Message, call ldap_msg_free when all
//           references have been released
//
// Arguments:
//  pCPLDAPWrap: PLDAP to refcount
//  pMessage: the LDAPMessage to refcount
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/10/05 13:12:15: Created.
//
//-------------------------------------------------------------
CLdapResultWrap::CLdapResultWrap(
    CPLDAPWrap *pCPLDAPWrap,
    PLDAPMessage pMessage)
{
    _ASSERT(pCPLDAPWrap);
    _ASSERT(pMessage);

    m_pCPLDAPWrap = pCPLDAPWrap;
    m_pCPLDAPWrap->AddRef();
    m_pLDAPMessage = pMessage;
    m_lRefCount = 0;
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::AddRef
//
// Synopsis: Increment the ref count of this object
//
// Arguments: NONE
//
// Returns: new refcount
//
// History:
// jstamerj 1998/10/05 13:14:59: Created.
//
//-------------------------------------------------------------
LONG CLdapResultWrap::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::Release
//
// Synopsis: Decrement the ref count.  Free the object when the
//           refcount hits zero
//
// Arguments: NONE
//
// Returns: New refcount
//
// History:
// jstamerj 1998/10/05 13:26:47: Created.
//
//-------------------------------------------------------------
LONG CLdapResultWrap::Release()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedDecrement(&m_lRefCount);

    if(lNewRefCount == 0) {
        //
        // Release this ldapmessage
        //
        delete this;
        return 0;

    } else {

        return lNewRefCount;
    }
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::~CLdapResultWrap
//
// Synopsis: Release the ldap message result
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/10/05 13:31:39: Created.
//
//-------------------------------------------------------------
CLdapResultWrap::~CLdapResultWrap()
{
    m_pCPLDAPWrap->Release();
    ldap_msgfree(m_pLDAPMessage);
}



//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CICategorizerItemAttributesIMP
//
// Synopsis: Initializes member data
//
// Arguments:
//  pldap: PLDAP to use
//  pldapmessage: PLDAPMessage to serve out
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/02 12:35:15: Created.
//
//-------------------------------------------------------------
CICategorizerItemAttributesIMP::CICategorizerItemAttributesIMP(
    PLDAP pldap,
    PLDAPMessage pldapmessage,
    CLdapResultWrap *pResultWrap)
{
    m_dwSignature = CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE;

    _ASSERT(pldap);
    _ASSERT(pldapmessage);
    _ASSERT(pResultWrap);

    m_pldap = pldap;
    m_pldapmessage = pldapmessage;
    m_cRef = 0;
    m_pResultWrap = pResultWrap;
    m_pResultWrap->AddRef();
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::~CICategorizerItemAttributesIMP
//
// Synopsis: Checks to make sure signature is valid and then resets signature
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/02 12:39:45: Created.
//
//-------------------------------------------------------------
CICategorizerItemAttributesIMP::~CICategorizerItemAttributesIMP()
{
    m_pResultWrap->Release();

    _ASSERT(m_dwSignature == CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE_INVALID;
}


//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerItemAttributes
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerItemAttributes) {
        *ppv = (LPVOID) ((ICategorizerItemAttributes *) this);
    } else if (iid == IID_ICategorizerItemRawAttributes) {
        *ppv = (LPVOID) ((ICategorizerItemRawAttributes *) this);
    } else if (iid == IID_ICategorizerUTF8Attributes) {
        *ppv = (LPVOID) ((ICategorizerUTF8Attributes *) this);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerItemAttributesIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero.
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerItemAttributesIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    if(lNewRefCount == 0) {
        delete this;
        return 0;
    } else {
        return lNewRefCount;
    }
}


//+------------------------------------------------------------
//
// Function: BeginAttributeEnumeration
//
// Synopsis: Prepare to enumerate through attribute values for a specific attribute
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// History:
// jstamerj 1998/07/02 10:54:00: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginAttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginAttributeEnumeration");
    _ASSERT(pszAttributeName);
    _ASSERT(penumerator);

    penumerator->pvBase =
 penumerator->pvCurrent = ldap_get_values(
     m_pldap,
     m_pldapmessage,
     (LPSTR)pszAttributeName);

    if(penumerator->pvBase == NULL) {
        ErrorTrace((LPARAM)this, "Requested attribute %s not found", pszAttributeName);
        TraceFunctLeaveEx((LPARAM)this);
        return CAT_E_PROPNOTFOUND;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetNextAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  ppszAttributeValue: Ptr to Ptr to recieve Ptr to string of attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/07/02 11:14:54: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextAttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeValue)
{
    _ASSERT(penumerator);
    _ASSERT(ppszAttributeValue);

    *ppszAttributeValue = *((LPSTR *)penumerator->pvCurrent);

    if(*ppszAttributeValue) {
        //
        // Advance enumerator to next value
        //
        penumerator->pvCurrent = (PVOID) (((LPSTR *)penumerator->pvCurrent)+1);
        return S_OK;
    } else {
        //
        // This is the last value
        //
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
}



//+------------------------------------------------------------
//
// Function: RewindAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/06 11:22:23: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    penumerator->pvCurrent = penumerator->pvBase;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: EndAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 12:24:44: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    ldap_value_free((LPSTR *)penumerator->pvBase);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::BeginAttributeNameEnumeration
//
// Synopsis: Enumerate through the attributes returned from LDAP
//
// Arguments:
//  penumerator: Caller allocated enumerator structure to be
//  initialized by this call
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 10:49:56: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginAttributeNameEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    penumerator->pvBase =
    penumerator->pvCurrent = NULL;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::GetNextAttributeName
//
// Synopsis: enumerate through the attribute names returned
//
// Arguments:
//  penumerator: enumerator strucutre initialized in BeginAttributeNameEnumeration
//  ppszAttributeValue: out parameter for an attribute name
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/09/18 10:53:15: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextAttributeName(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeName)
{
    _ASSERT(penumerator);
    _ASSERT(ppszAttributeName);

    if(penumerator->pvCurrent == NULL) {

        *ppszAttributeName = ldap_first_attribute(
            m_pldap,
            m_pldapmessage,
            (BerElement **) &(penumerator->pvCurrent));

    } else {

        *ppszAttributeName = ldap_next_attribute(
            m_pldap,
            m_pldapmessage,
            (BerElement *) (penumerator->pvCurrent));
    }

    if(*ppszAttributeName == NULL) {
        //
        // Assume we've reached the end of the attribute name
        // enumeration
        //
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    } else {

        return S_OK;
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributeIMP::EndAttributeNameEnumeration
//
// Synopsis: Free all data held for this enumeration
//
// Arguments:
//  penumerator: enumerator strucutre initialized in BeginAttributeNameEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 11:04:37: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndAttributeNameEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    //
    // Ldap uses only buffers in the connection block for this, so we
    // don't need to explicitly free anything
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::AggregateAttributes
//
// Synopsis: Normally, accept and ICategorizerItemAttributes for aggregation
//
// Arguments:
//  pICatItemAttributes: attributes to aggregate
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 1998/07/16 14:42:16: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::AggregateAttributes(
    IN  ICategorizerItemAttributes *pICatItemAttributes)
{
    return E_NOTIMPL;
}


//+------------------------------------------------------------
//
// Function: BeginRawAttributeEnumeration
//
// Synopsis: Prepare to enumerate through attribute values for a specific attribute
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// History:
// jstamerj 1998/12/09 12:44:15: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginRawAttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginRawAttributeEnumeration");
    _ASSERT(pszAttributeName);
    _ASSERT(penumerator);

    penumerator->pvBase =
 penumerator->pvCurrent = ldap_get_values_len(
     m_pldap,
     m_pldapmessage,
     (LPSTR)pszAttributeName);

    if(penumerator->pvBase == NULL) {
        ErrorTrace((LPARAM)this, "Requested attribute %s not found", pszAttributeName);
        TraceFunctLeaveEx((LPARAM)this);
        return CAT_E_PROPNOTFOUND;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetNextRawAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  pdwcb: dword to set to the # of bytes in the pvValue buffer
//  pvValue: Ptr to recieve Ptr to raw attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/12/09 12:49:27: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextRawAttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT PDWORD pdwcb,
    OUT LPVOID *pvValue)
{
    _ASSERT(penumerator);
    _ASSERT(pdwcb);
    _ASSERT(pvValue);

    if( (*((PLDAP_BERVAL *)penumerator->pvCurrent)) != NULL) {

        *pdwcb   = (* ((PLDAP_BERVAL *)penumerator->pvCurrent))->bv_len;
        *pvValue = (* ((PLDAP_BERVAL *)penumerator->pvCurrent))->bv_val;
        //
        // Advance enumerator to next value
        //
        penumerator->pvCurrent = (PVOID)
                                 (((PLDAP_BERVAL *)penumerator->pvCurrent)+1);
        return S_OK;

    } else {
        //
        // This is the last value
        //
        *pdwcb = 0;
        *pvValue = NULL;
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
}

//+------------------------------------------------------------
//
// Function: RewindRawAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/09 12:49:23: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindRawAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    return RewindAttributeEnumeration(penumerator);
}


//+------------------------------------------------------------
//
// Function: EndRawAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/09 12:50:02: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndRawAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    ldap_value_free_len((struct berval **)penumerator->pvBase);

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::GetAllAttributeValues
//
// Synopsis: Retrieve all values for a particular attribute at once.
// This may not be optimal for attributes with a large number of
// values (enumerating through the values may be better performace wise).
//
// Arguments:
//  pszAttributeName: The name of the attribute you want
//  penumerator: A user allocated ATTRIBUTE_ENUMERATOR structure for
//               use by the ICategorizerItemAttributes implementor
//  prgpszAttributeValues: Where to return the pointer to the
//  attribute string array.  This will be a NULL terminated array of
//  pointers to strings.
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: None of those attributes exist
//
// History:
// jstamerj 1998/12/10 18:55:38: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::GetAllAttributeValues(
    LPCSTR pszAttributeName,
    PATTRIBUTE_ENUMERATOR penumerator,
    LPSTR **prgpszAttributeValues)
{
    HRESULT hr;

    TraceFunctEnter("CICategorizerItemAttributesIMP::GetAllAttributeValues");
    //
    // piggy back on BeginAttributeEnumeration
    //
    hr = BeginAttributeEnumeration(
        pszAttributeName,
        penumerator);

    if(SUCCEEDED(hr)) {
        //
        // return the array
        //
        *prgpszAttributeValues = (LPSTR *) penumerator->pvBase;
    }

    DebugTrace(NULL, "returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::ReleaseAllAttributes
//
// Synopsis: Release the attributes allocated from GetAllAttributeValues
//
// Arguments:
//  penumerator: the enumerator passed into GetAllAttributeValues
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/10 19:38:57: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::ReleaseAllAttributeValues(
    PATTRIBUTE_ENUMERATOR penumerator)
{
    HRESULT hr;
    TraceFunctEnter("CICategorizerItemAttributesIMP::ReleaseAllAttributes");

    //
    // piggy back off of endattributeenumeration
    //
    hr = EndAttributeEnumeration(
        penumerator);

    DebugTrace(NULL, "returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountAttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:36:58: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountAttributeValues(
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::CountAttributeValues");
    _ASSERT(pdwCount);
    *pdwCount = ldap_count_values((PCHAR *) penumerator->pvBase);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
} // CICategorizerItemAttributesIMP::CountAttributeValues


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountRawAttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:39:54: Created
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountRawAttributeValues(
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::CountRawAttributeValues");
    _ASSERT(pdwCount);
    *pdwCount = ldap_count_values_len((struct berval **) penumerator->pvBase);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
} // CICategorizerItemAttributesIMP::CountRawAttributeValues


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration
//
// Synopsis: Begin UTF8 attribute enumeration
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/10 11:14:35: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration");
    //
    // Piggy back raw attribute enumeration and use the pvContext
    // member of penumerator.
    //
    hr = BeginRawAttributeEnumeration(
        pszAttributeName,
        penumerator);

    penumerator->pvContext = NULL;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: GetNextAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  ppszAttributeValue: Ptr to Ptr to recieve Ptr to string of attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/07/02 11:14:54: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextUTF8AttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeValue)
{
    HRESULT hr = S_OK;
    DWORD dwcb = 0;
    LPVOID pvAttributeValue = NULL;
    LPSTR psz = NULL;

    if(penumerator->pvContext) {
        delete [] (LPSTR) penumerator->pvContext;
        penumerator->pvContext = NULL;
    }
    hr = GetNextRawAttributeValue(
        penumerator,
        &dwcb,
        &pvAttributeValue);

    if(FAILED(hr))
        return hr;

    //
    // Convert to termianted UTF8 string
    //
    psz = new CHAR[dwcb + 1];
    if(psz == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(psz, pvAttributeValue, dwcb);
    psz[dwcb] = '\0';
    *ppszAttributeValue = psz;
    penumerator->pvContext = psz;
    return hr;
}



//+------------------------------------------------------------
//
// Function: RewindAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/06 11:22:23: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindUTF8AttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    return RewindRawAttributeEnumeration(
        penumerator);
}


//+------------------------------------------------------------
//
// Function: EndAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 12:24:44: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndUTF8AttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    if(penumerator->pvContext) {
        delete [] (LPSTR) penumerator->pvContext;
        penumerator->pvContext = NULL;
    }
    return EndRawAttributeEnumeration(penumerator);
}

//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountUTF8AttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:39:54: Created
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountUTF8AttributeValues(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT DWORD *pdwCount)
{
    return CountRawAttributeValues(
        penumerator,
        pdwCount);

} // CICategorizerItemAttributesIMP::CountRawAttributeValues
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatasync.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatasync.cpp
//
// Contents: Implementation of CICategorizerAsyncContextIMP
//
// Classes: CICategorizerAsyncContextIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/16 11:25:20: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "simparray.cpp"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerAsyncContext
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerAsyncContextIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerAsyncContext) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerAsyncContextIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero. 
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerAsyncContextIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    return lNewRefCount;
}



//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::CompleteQuery
//
// Synopsis: Accept async completion from a sink
//
// Arguments:
//  pvQueryContext: pvoid query context (really a PEVENTPARAMS_SENDQUERY)
//  hrResolutionStatus: S_OK unless there was an error talking to DS
//  dwcResults: The number of ICategorizerItemAttributes returned
//  rgpItemAttributes: Array of pointers to the ICategorizerItemAttributes
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/16 11:27:47: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerAsyncContextIMP::CompleteQuery(
    IN  PVOID   pvQueryContext,
    IN  HRESULT hrResolutionStatus,
    IN  DWORD   dwcResults,
    IN  ICategorizerItemAttributes **rgpItemAttributes,
    IN  BOOL    fFinalCompletion)
{
    HRESULT hr;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerAsyncContextIMP::CompleteQuery");

    DebugTrace((LPARAM)this, "hrResolutionStatus is %08lx", hrResolutionStatus);
    DebugTrace((LPARAM)this, "dwcResults for this sink is %ld", dwcResults);
    DebugTrace((LPARAM)this, "fFinalCompletion is %d", fFinalCompletion);

    pParams = (PEVENTPARAMS_CATSENDQUERY)pvQueryContext;
    pBlock = (CSearchRequestBlock *) pParams->pblk;

    //
    // If the old hrResolutionStatus (saved in pParams) indicates failure, don't do any more work
    //
    if(SUCCEEDED(pParams->hrResolutionStatus)) {

        hr = hrResolutionStatus;

        if(SUCCEEDED(hr) && (dwcResults > 0) && (rgpItemAttributes)) {
            //
            // Add the new array of ICatItemAttrs to the existing array
            //
            hr = pBlock->AddResults(
                dwcResults,
                rgpItemAttributes);
        }

        if(FAILED(hr)) {
            //
            // Remember something failed in pParams
            //
            pParams->hrResolutionStatus = hr;
        }
    }

    if(fFinalCompletion) {

        if((pParams->pIMailTransportNotify) &&
           FAILED(pParams->hrResolutionStatus)) {

            ErrorTrace((LPARAM)this, "Stoping resoltion, error encountered: %08ld", 
                       pParams->hrResolutionStatus);
            //
            // If the resolution sink is indicating an error, set the error
            // and return S_FALSE to the SEO dispatcher so that it will stop
            // calling resolve sinks (we're going to fail now anyway, after
            // all)
            //
            hr = pParams->pIMailTransportNotify->Notify(
                S_FALSE,
                pParams->pvNotifyContext);

            _ASSERT(SUCCEEDED(hr));

        } else {

            if(pParams->pIMailTransportNotify) {
                //
                // Call the SEO dispatcher completion routine
                //
                hr = pParams->pIMailTransportNotify->Notify(
                    S_OK,
                    pParams->pvNotifyContext);

            } else {
                //
                // Events are disabled; call completion directly
                //
                hr = CSearchRequestBlock::HrSendQueryCompletion(
                    S_OK,
                    pParams);
            }
            _ASSERT(SUCCEEDED(hr));
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapconn.h ===
//
// ldapconn.h -- This file contains the class definitions for:
//      CLdapConnection
//      CLdapConnectionCache
//
// Created:
//      Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef _LDAPCONN_H_
#define _LDAPCONN_H_

#include <transmem.h>
#include "winldap.h"
#include "rwex.h"
#include "spinlock.h"
#include "catperf.h"
#include "catdefs.h"

//
// Timeout value (in seconds) to pass into ldap_result
//
#define LDAPCONN_DEFAULT_RESULT_TIMEOUT     (3*60)        // 3 Minutes

typedef VOID LDAPRESULT;
typedef PVOID PLDAPRESULT;
typedef VOID LDAPENTRY;
typedef PVOID PLDAPENTRY;

enum LDAP_BIND_TYPE {
    BIND_TYPE_NONE,
    BIND_TYPE_SIMPLE,
    BIND_TYPE_GENERIC,
    BIND_TYPE_CURRENTUSER
};

class CLdapConnection;

typedef VOID (*LPLDAPCOMPLETION)(
    LPVOID ctx,
    DWORD dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hr,
    BOOL fFinalCompletion);

DWORD WINAPI LdapCompletionThread(LPVOID ctx);

CatDebugClass(CLdapConnection)
{
    public:
        virtual HRESULT HrInitialize();

        virtual DWORD AddRef()
        {
            return InterlockedIncrement((PLONG)&m_dwRefCount);
        }
        virtual DWORD Release();
        virtual VOID ReleaseAndWaitForDestruction();
        virtual VOID FinalRelease()
        {
            CancelAllSearches();
            delete this;
        }
        virtual DWORD GetRefCount()
        {
            return m_dwRefCount;
        }
            
        virtual LPSTR GetNamingContext() {       // Return the naming context
            return( m_szNamingContext );         // of the connection
        }

        virtual LPWSTR GetNamingContextW() {
            return( m_wszNamingContext );
        }

        virtual LPSTR GetHostName() {
            return( m_szHost );
        }
    
        virtual DWORD GetPort() {
            return( m_dwPort );
        }

        virtual LPSTR GetAccount() {
            return( m_szAccount );
        }

        virtual LPSTR GetPassword() {
            return( m_szPassword );
        }

        virtual LDAP_BIND_TYPE GetBindType() {
            return( m_bt );
        }

        virtual HRESULT Search(                  // Look up objects matching
            LPCSTR szBaseDN,                     // specified criteria in the
            int nScope,                          // DS
            LPCSTR szFilter,
            LPCSTR *rgszAttributes,
            PLDAPRESULT *ppResult);

        virtual HRESULT AsyncSearch(             // Asynchronously look up
            LPCWSTR szBaseDN,                    // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCWSTR szFilter,                    // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);
        //
        // Same as above with UTF8 search filter
        //
        virtual HRESULT AsyncSearch(
            LPCWSTR szBaseDN,                    // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCSTR szFilterUTF8,                 // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);
        //
        // Same as above with UTF8 search filter and base DN
        //
        virtual HRESULT AsyncSearch(
            LPCSTR szBaseDN,                     // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCSTR szFilterUTF8,                 // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);

        virtual VOID CancelAllSearches(          // Cancels all pending searches
            HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED),
            ISMTPServer *pISMTPServer = NULL);

        VOID ProcessAsyncResult(                 // Method to process results
            PLDAPMessage pres,                   // of AsyncSearch requests
            DWORD dwLdapError,
            BOOL *pfTerminateIndicator);        

        friend DWORD WINAPI LdapCompletionThread(// Friend function to
            LPVOID ctx);                         // handle AsyncSearch
                                                 // completions.

        virtual HRESULT GetFirstEntry(           // Get first entry from the
            PLDAPRESULT pResult,                 // search result returned
            PLDAPENTRY *ppEntry);                // by ::Search

        virtual HRESULT GetNextEntry(            // Get the next entry from
            PLDAPRESULT pResult,                 // the search result
            PLDAPENTRY *ppEntry);

        virtual HRESULT GetAttributeValues(      // Get an entry's attribute
            PLDAPENTRY pEntry,                   // values
            LPCSTR szAttribute,
            LPSTR *prgszValues[]);

        static VOID FreeResult(                  // Free a search result
            PLDAPRESULT pResult);

        virtual VOID FreeValues(                 // Free values returned by
            LPSTR rgszValues[]);                 // ::GetAttributeValues

        virtual HRESULT Add(                     // Add a set of new
            LPCSTR szDN,                         // attributes to an existing
            LPCSTR *rgszAttributes,              // object in the DS
            LPCSTR *rgrgszValues[]) {

            return ( ModifyAttributes(
                        LDAP_MOD_ADD,
                        szDN,
                        rgszAttributes,
                        rgrgszValues) );

        }

        virtual HRESULT Delete(                  // Delete attributes from
            LPCSTR szDN,                         // an existing object in the
            LPCSTR *rgszAttributes) {            // DS

            return ( ModifyAttributes(
                        LDAP_MOD_DELETE,
                        szDN,
                        rgszAttributes,
                        NULL) );
        }

        virtual HRESULT Update(                  // Update attributes on an
            LPCSTR szDN,                         // existing object in the DS
            LPCSTR rgszAttributes[],
            LPCSTR *rgrgszValues[]) {

            return ( ModifyAttributes(
                        LDAP_MOD_REPLACE,
                        szDN,
                        rgszAttributes,
                        rgrgszValues) );

        }

        LPSTR SzHost()
        {
            return m_szHost;
        }
    protected:

        CLdapConnection(                         // The constructor and
            LPSTR szHost,                        // destructor are protected
            DWORD dwPort,
            LPSTR szNamingContext,               // since only derived classes
            LPSTR szAccount,                     // can create/delete these
            LPSTR szPassword,
            LDAP_BIND_TYPE BindType);

        virtual ~CLdapConnection();

        virtual HRESULT Connect();               // Create/Delete connection
                                                 // to LDAP host
        virtual VOID Disconnect();

        virtual VOID Invalidate();

        virtual BOOL IsValid();

        virtual DWORD BindToHost(
            PLDAP pldap,
            LPSTR szAccount,
            LPSTR szPassword);

        virtual BOOL IsEqual(                    // Return true if the
            LPSTR szHost,                        // object member variables
            DWORD dwPort,
            LPSTR szNamingContext,               // match the passed in
            LPSTR szAccount,                     // values
            LPSTR szPassword,
            LDAP_BIND_TYPE BindType);

        virtual HRESULT ModifyAttributes(        // Helper function for
            int nOperation,                      // ::Add, ::Delete, and
            LPCSTR szDN,                         // ::Update public functions
            LPCSTR rgszAttributes[],
            LPCSTR *rgrgszValues[]);

        virtual HRESULT LdapErrorToHr(
            DWORD dwLdapError);

        VOID SetTerminateIndicatorTrue()
        {
            BOOL *pfTerminate;

            m_fTerminating = TRUE;

            pfTerminate = (BOOL *) InterlockedExchangePointer(
                (PVOID *) &m_pfTerminateCompletionThreadIndicator,
                NULL);

            if(pfTerminate)
                *pfTerminate = TRUE;
        }

        DWORD m_dwPort;
        char m_szHost[CAT_MAX_DOMAIN];
        char m_szNamingContext[CAT_MAX_DOMAIN];
        WCHAR m_wszNamingContext[CAT_MAX_DOMAIN];
        char m_szAccount[CAT_MAX_LOGIN];
        char m_szPassword[CAT_MAX_PASSWORD];

        #define SIGNATURE_LDAPCONN              ((DWORD) 'CadL')
        #define SIGNATURE_LDAPCONN_INVALID      ((DWORD) 'XadL')
        DWORD m_dwSignature;
        DWORD m_dwRefCount;
        DWORD m_dwDestructionWaiters;
        HANDLE m_hShutdownEvent;
        LDAP_BIND_TYPE m_bt;

        PLDAP GetPLDAP()
        {
            if(m_pCPLDAPWrap)
                return m_pCPLDAPWrap->GetPLDAP();
            else
                return NULL;
        }
        CPLDAPWrap *m_pCPLDAPWrap;

        BOOL m_fDefaultNamingContext;

        //
        // Unfortunately, our RFC1823 LDAP API provides no access to the
        // socket handle which we can register with a completion port. So,
        // if one or more async search request is issued, we have to burn a
        // thread to await its completion.
        //

        //
        // This spin lock protects access to the pending request list as
        // well as m_dwStatusFlags 
        //
        SPIN_LOCK m_spinlockCompletion;

        // CRITICAL_SECTION m_cs;

        //
        // jstamerj 980501 15:56:27: 
        // Reader/writer lock so that we wait for all calls in
        // ldap_search_ext before cancelling all pending searches 
        //
        CExShareLock m_ShareLock;

        DWORD  m_idCompletionThread;

        HANDLE m_hCompletionThread;

        HANDLE m_hOutstandingRequests;

        BOOL *m_pfTerminateCompletionThreadIndicator;
        BOOL m_fTerminating;

        BOOL m_fValid;

        typedef struct _PendingRequest {
            int msgid;
            LPLDAPCOMPLETION fnCompletion;
            LPVOID ctxCompletion;
            LIST_ENTRY li;
            //
            // Parameters for paged searches
            //
            DWORD dwPageSize;
            PLDAPSearch pldap_search;

        } PENDING_REQUEST, *PPENDING_REQUEST;

        LIST_ENTRY m_listPendingRequests;

        BOOL m_fCancel;

        //
        // The following three functions must be called inside an external
        // lock (m_spinlockcompletion)
        //
        VOID NotifyCancel()
        {
            m_fCancel = TRUE;
        }
        VOID ClearCancel()
        {
            m_fCancel = FALSE;
        }
        BOOL CancelOccured()
        {
            return m_fCancel;
        }

        virtual HRESULT CreateCompletionThreadIfNeeded();

        virtual VOID SetTerminateCompletionThreadIndicator(
            BOOL *pfTerminateCompletionThreadIndicator);

        virtual VOID InsertPendingRequest(
            PPENDING_REQUEST preq);

        virtual VOID RemovePendingRequest(
            PPENDING_REQUEST preq);

        virtual VOID CallCompletion(
            PPENDING_REQUEST preq,
            PLDAPMessage pres,
            HRESULT hrStatus,
            BOOL fFinalCompletion);

        VOID AbandonRequest(
            PPENDING_REQUEST preq)
        {
            ldap_abandon(
                GetPLDAP(),
                preq->msgid);
            if(preq->pldap_search)
                ldap_search_abandon_page(
                    GetPLDAP(),
                    preq->pldap_search);

            INCREMENT_LDAP_COUNTER(AbandonedSearches);
            DECREMENT_LDAP_COUNTER(PendingSearches);
        }
};

//
// For the hash function to work correctly, the table size must be a power of
// two. This is just an efficiency trick; there is nothing fundamentally
// wrong with using some other size, except that the hash function would have
// to use an expensive MODULO operator instead of a cheap AND.
//

#define LDAP_CONNECTION_CACHE_TABLE_SIZE    256

#define MAX_LDAP_CONNECTIONS_PER_HOST_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define MAX_LDAP_CONNECTIONS_PER_HOST_VALUE "MaxLdapConnections"

class CLdapConnectionCache
{

  public:

        CLdapConnectionCache();                  // Constructor

        ~CLdapConnectionCache();                 // Destructor

        HRESULT GetConnection(                   // Given LDAP config info,
            CLdapConnection **ppConn,
            LPSTR szHost,                        // retrieve a connection to
            DWORD dwPort,
            LPSTR szNamingContext,               // the LDAP host.
            LPSTR szAccount,
            LPSTR szPassword,
            LDAP_BIND_TYPE bt,
            PVOID pCreateContext = NULL);

        VOID CancelAllConnectionSearches(
            ISMTPServer *pISMTPServer = NULL);

        //
        // It is intended for there to be a single, global, instance of
        // a CLdapConnectionCache object, serving multiple instances of
        // CEmailIDLdapStore. Each instance of CEmailIDLdapStore needs to
        // call AddRef() and Release() in its constructor/destructor, so that
        // the connection cache knows to clean up connections in the cache
        // when the ref count goes to 0.
        //

        VOID AddRef();

        VOID Release();

  private:

        //
        // An internally utility function to release a connection
        //
        VOID ReleaseConnectionInternal(
            CLdapConnection *pConnection,
            BOOL fLockRequired);

        LONG m_cRef;

  protected:
        class CCachedLdapConnection : public CLdapConnection {
            public:
                CCachedLdapConnection(
                    LPSTR szHost,
                    DWORD dwPort,
                    LPSTR szNamingContext,
                    LPSTR szAccount,
                    LPSTR szPassword,
                    LDAP_BIND_TYPE bt,
                    CLdapConnectionCache *pCache) :
                        CLdapConnection(
                            szHost,
                            dwPort,
                            szNamingContext,
                            szAccount,
                            szPassword,
                            bt)
                {
                    m_pCache = pCache;
                }

                HRESULT Connect() {
                    return( CLdapConnection::Connect() );
                }

                VOID Disconnect() {
                    CLdapConnection::Disconnect();
                }

                VOID Invalidate() {
                    CLdapConnection::Invalidate();
                }

                BOOL IsValid() {
                    return( CLdapConnection::IsValid() );
                }

                BOOL IsEqual(
                    LPSTR szHost,
                    DWORD dwPort,
                    LPSTR szNamingContext,
                    LPSTR szAccount,
                    LPSTR szPassword,
                    LDAP_BIND_TYPE BindType) {

                    return( CLdapConnection::IsEqual(
                        szHost, dwPort, szNamingContext, szAccount,
                        szPassword, BindType) );
                }

                DWORD Release();

                LIST_ENTRY li;
                CLdapConnectionCache *m_pCache;

        };

        virtual VOID RemoveFromCache(
            CCachedLdapConnection *pConn);

        virtual CCachedLdapConnection *CreateCachedLdapConnection(
            LPSTR szHost,
            DWORD dwPort,
            LPSTR szNamingContext,
            LPSTR szAccount,
            LPSTR szPassword,
            LDAP_BIND_TYPE bt,
            PVOID pCreateContext)
        {
            CCachedLdapConnection *pret;
            pret = new CCachedLdapConnection(
                szHost,
                dwPort,
                szNamingContext,
                szAccount,
                szPassword,
                bt, 
                this);

            if(pret)
                if(FAILED(pret->HrInitialize())) {
                    pret->Release();
                    pret = NULL;
                }
            return pret;
        }

  private:

        //
        // We want to support multiple connections per host, up to a maximum
        // of m_cMaxHostConnections. We achieve this in a simple way by
        // keeping a per-cache m_nConnectionSkipCount. Every time we are
        // searching for a cached connection to a host in, we skip
        // m_nNextConnectionSkipCount cached connections. Every time we
        // find a cached connection, we bump up
        // m_nNextCachedConnectionSkipCount by 1 modulo m_cMaxHostConnections.
        // This means we'll round robin through m_cMaxHostConnections
        // connections per host.
        //

        LONG m_nNextConnectionSkipCount;

        LONG m_cMaxHostConnections;

        LONG m_cCachedConnections;

        LIST_ENTRY m_rgCache[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];
        CExShareLock m_rgListLocks[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];
        LONG m_rgcCachedConnections[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];

        VOID InitializeFromRegistry();

        unsigned short Hash(
            LPSTR szConnectionName);

    friend class CLdapConnectionCache::CCachedLdapConnection;
    friend class CBatchLdapConnection;
};

#endif // _LDAPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatqueries.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatqueries.h
//
// Contents: Implementation of ICategorizerQueries
//
// Classes: CICategorizerQueriesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/15 14:11:54: Created.
//
//-------------------------------------------------------------
#ifndef __ICATQUERIES_H__
#define __ICATQUERIES_H__

CatDebugClass(CICategorizerQueriesIMP),
    public ICategorizerQueries
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerQueries
    STDMETHOD (SetQueryString) (
        IN  LPSTR  pszQueryString);
    STDMETHOD (GetQueryString) (
        OUT LPSTR *ppszQueryString);

  public:
    CICategorizerQueriesIMP(
        IN  LPSTR  *ppsz);
    ~CICategorizerQueriesIMP();

  private:
    // Internal method for setting the query string to a buffer
    // without reallocating/copying
    HRESULT SetQueryStringNoAlloc(
        IN  LPSTR  pszQueryString);

  private:

    #define SIGNATURE_CICATEGORIZERQUERIESIMP           (DWORD) 'ICaQ'
    #define SIGNATURE_CICATEGORIZERQUERIESIMP_INVALID   (DWORD) 'XCaQ'

    DWORD m_dwSignature;
    ULONG m_cRef;
    LPSTR *m_ppsz;

    friend class CSearchRequestBlock;
};


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::CICategorizerQueriesIMP
//
// Synopsis: Constructor, initialize member data
//
// Arguments:
//  ppsz: Pointer to psz to set
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/15 14:18:00: Created.
//
//-------------------------------------------------------------
inline CICategorizerQueriesIMP::CICategorizerQueriesIMP(
    IN  LPSTR *ppsz)
{
    m_dwSignature = SIGNATURE_CICATEGORIZERQUERIESIMP;
    
    _ASSERT(ppsz);
    m_ppsz = ppsz;
    m_cRef = 0;
}


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::~CICategorizerQueriesIMP
//
// Synopsis: Check signature before destroying object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/15 14:22:33: Created.
//
//-------------------------------------------------------------
inline CICategorizerQueriesIMP::~CICategorizerQueriesIMP()
{
    _ASSERT(m_cRef == 0);
    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERQUERIESIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERQUERIESIMP_INVALID;
}

#endif //__ICATQUERIES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatitemattr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitemattr.h
//
// Contents: EMailIDLdapStore implementation of ICategorizerItemAttributes
//
// Classes:
//  CLdapResultWrap
//  CICategorizerItemAttributesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/01 13:20:21: Created.
//
//-------------------------------------------------------------
#ifndef _ICATITEMATTR_H_
#define _ICATITEMATTR_H_

#include <windows.h>
#include <winldap.h>
#include "smtpevent.h"
#include <catdefs.h>
#include <ldapconn.h>

//
// The guid indicating this ICategorizerItemAttributes was generated
// by the one true categorizer (not some sink)
//
CatDebugClass(CLdapResultWrap)
{
  public:
    CLdapResultWrap(
        CPLDAPWrap  *pLDAPWrap,
        PLDAPMessage pMessage);

    LONG AddRef();
    LONG Release();

  private:
    ~CLdapResultWrap();

    LONG m_lRefCount;
    CPLDAPWrap  *m_pCPLDAPWrap;
    PLDAPMessage m_pLDAPMessage;
};




// {283430CA-1850-11d2-9E03-00C04FA322BA}
static const GUID GUID_NT5CAT =
{ 0x283430ca, 0x1850, 0x11d2, { 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba } };



#define CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE (DWORD)'ICIA'
#define CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE_INVALID (DWORD)'XCIA'

CatDebugClass(CICategorizerItemAttributesIMP),
    public ICategorizerItemAttributes,
    public ICategorizerItemRawAttributes,
    public ICategorizerUTF8Attributes
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerItemAttributes
    STDMETHOD (BeginAttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextAttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeValue);

    STDMETHOD (RewindAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (BeginAttributeNameEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextAttributeName) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeName);

    STDMETHOD (EndAttributeNameEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);


    STDMETHOD_(GUID, GetTransportSinkID) ()
    {
        return GUID_NT5CAT;
    }

    STDMETHOD (AggregateAttributes) (
        IN  ICategorizerItemAttributes *pICatItemAttributes);

    STDMETHOD (GetAllAttributeValues) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        IN  LPSTR **prgpszAttributeValues);

    STDMETHOD (ReleaseAllAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

  public:
    //ICategorizerItemRawAttributes
    STDMETHOD (BeginRawAttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextRawAttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT PDWORD pdwcb,
        OUT LPVOID *pvAttributeValue);

    STDMETHOD (RewindRawAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndRawAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountRawAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

 public:
    //ICategorizerUTF8Attributes
    STDMETHOD (BeginUTF8AttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextUTF8AttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeValue);

    STDMETHOD (RewindUTF8AttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndUTF8AttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountUTF8AttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

  private:
    CICategorizerItemAttributesIMP(
        PLDAP pldap,
        PLDAPMessage pldapmessage,
        CLdapResultWrap *pResultWrap);
    ~CICategorizerItemAttributesIMP();

    DWORD m_dwSignature;
    ULONG m_cRef;
    PLDAP m_pldap;
    PLDAPMessage m_pldapmessage;
    CLdapResultWrap * m_pResultWrap;

    friend class CLdapConnection;
};

#endif //_ICATITEMATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapdl.h ===
//
// ldapdl.cpp -- This file contains definitions for
//      CLdapDistList
//
// Created:
//      May 5, 1997   -- Milan Shah (milans)
//
// Changes:
//

#ifndef __LDAPDL_H__
#define __LDAPDL_H__

#include <windows.h>
#include <stdio.h>
#include "dlstore.h"
#include "dbgtrace.h"

class CLdapDistList : public CDistListStore {
    public:
        CLdapDistList(LPSTR szName,
            LPVOID pParameter);
        ~CLdapDistList();

        BOOL InsertMember(LPSTR szEmailID);
        BOOL DeleteMember(LPSTR szEmailID);
        BOOL Compact();
        BOOL GetFirstMember(LPSTR szEmailID);
        BOOL GetNextMember(LPSTR szEmailID);
        BOOL Sort();
        BOOL DeleteDL();

    private:

        LPSTR *m_rgszMembers;

        DWORD m_nNextMember;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapconn.cpp ===
//
// ldapconn.cpp -- This file contains the class implementation for:
//      CLdapConnection
//      CLdapConnectionCache
//
// Created:
//      Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "ldapconn.h"
#include "icatitemattr.h"
#define SECURITY_WIN32
#include "security.h"

//
// LDAP counter block
//
CATLDAPPERFBLOCK g_LDAPPerfBlock;

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CLdapConnection
//
//  Synopsis:   Constructor for a CLdapConnection object.
//
//  Arguments:  [szHost] -- The actual name of the LDAP host to connect to.
//                  If it is NULL, and we are running on an NT5 machine, we'll
//                  use the default DC
//
//              [dwPort] -- The remote tcp port to connect to.  If
//                          zero, LDAP_PORT is assumed
//
//              [szNamingContext] -- The naming context to use within the
//                  LDAP DS. If NULL, the naming context will be determined
//                  by using the default naming context of the LDAP DS.
//
//                  By allowing a naming context to be associated with an
//                  ldap connection, we can have multiple "logical" ldap
//                  connections served by the same LDAP DS. This is useful
//                  if folks want to setup mutliple virtual SMTP/POP3 servers
//                  all served by the same LDAP DS. The naming context in
//                  that case would be the name of the OU to restrict the
//                  DS operations to.
//
//              [szAccount] -- The DN of the account to log in as.
//
//              [szPassword] -- The password to use to log in.
//
//              [bt] -- The bind method to use. (none, simple, or generic)
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapConnection::CLdapConnection(
    IN LPSTR szHost,
    IN DWORD dwPort,
    IN LPSTR szNamingContext,
    IN LPSTR szAccount,
    IN LPSTR szPassword,
    IN LDAP_BIND_TYPE bt)
{
    int i;

    TraceFunctEnter( "CLdapConnection::CLdapConnection" );

    m_dwSignature = SIGNATURE_LDAPCONN;

    m_pCPLDAPWrap = NULL;
    m_fValid = TRUE;
    m_fTerminating = FALSE;

    if (szNamingContext != NULL && szNamingContext[0] != 0) {

        _ASSERT(strlen(szNamingContext) < sizeof(m_szNamingContext) );

        strcpy(m_szNamingContext, szNamingContext);

        m_fDefaultNamingContext = FALSE;

        i = MultiByteToWideChar(
            CP_UTF8,
            0,
            m_szNamingContext,
            -1,
            m_wszNamingContext,
            sizeof(m_wszNamingContext));

        _ASSERT(i > 0);

    } else {

        m_szNamingContext[0] = 0;
        m_wszNamingContext[0] = 0;

        m_fDefaultNamingContext = TRUE;
    }

    _ASSERT( (szHost != NULL) &&
             (strlen(szHost) < sizeof(m_szHost)) );

    _ASSERT( (bt == BIND_TYPE_NONE) ||
             (bt == BIND_TYPE_CURRENTUSER) ||
             ((szAccount != NULL) &&
                (szAccount[0] != 0) &&
                    (strlen(szAccount) < sizeof(m_szAccount)))
           );

    _ASSERT( (bt == BIND_TYPE_NONE) ||
             (bt == BIND_TYPE_CURRENTUSER) ||
             ((szPassword != NULL) &&
                (strlen(szPassword) < sizeof(m_szPassword))) );

    strcpy(m_szHost, szHost);

    m_dwPort = (dwPort != 0) ? dwPort : LDAP_PORT;

    if ((bt != BIND_TYPE_NONE) &&
        (bt != BIND_TYPE_CURRENTUSER)) {

        strcpy(m_szAccount, szAccount);

        strcpy(m_szPassword, szPassword);

    } else {

        m_szAccount[0] = 0;

        m_szPassword[0] = 0;

    }

    m_bt = bt;

    //
    // Initialize the async search completion structures
    //

    InitializeSpinLock( &m_spinlockCompletion );

    // InitializeCriticalSection( &m_cs );

    m_hCompletionThread = INVALID_HANDLE_VALUE;

    m_hOutstandingRequests = INVALID_HANDLE_VALUE;

    m_pfTerminateCompletionThreadIndicator = NULL;

    InitializeListHead( &m_listPendingRequests );

    m_fCancel = FALSE;

    m_dwRefCount = 1;
    m_dwDestructionWaiters = 0;
    m_hShutdownEvent = INVALID_HANDLE_VALUE;

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::~CLdapConnection
//
//  Synopsis:   Destructor for a CLdapConnection object
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

CLdapConnection::~CLdapConnection()
{
    TraceFunctEnter( "CLdapConnection::~CLdapConnection" );

    _ASSERT(m_dwSignature == SIGNATURE_LDAPCONN);
    m_dwSignature = SIGNATURE_LDAPCONN_INVALID;

    //
    // If there was an async completion thread, we need to indicate to it that
    // it should exit. That thread could be stuck at one of two points -
    // either it is waiting on the m_hOutstandingRequests semaphore to be
    // fired, or it is blocked on ldap_result(). So, we set the event and
    // close out m_pldap, then we wait for the async completion thread to
    // quit.
    //
    SetTerminateIndicatorTrue();

    if (m_hOutstandingRequests != INVALID_HANDLE_VALUE) {

        LONG nUnused;

        ReleaseSemaphore(m_hOutstandingRequests, 1, &nUnused);

    }

    if (m_pCPLDAPWrap != NULL) {
        Disconnect();
    }

    //
    // We do not wait for the LdapCompletionThread to die if it is the
    // LdapCompletionThread itself that is deleting us. If we did, it would
    // cause a deadlock.
    //
    if (m_hCompletionThread != INVALID_HANDLE_VALUE &&
            m_idCompletionThread != GetCurrentThreadId()) {

        WaitForSingleObject( m_hCompletionThread, INFINITE );

        CloseHandle( m_hCompletionThread );

    }

    if (m_hOutstandingRequests != INVALID_HANDLE_VALUE)
        CloseHandle( m_hOutstandingRequests );

    if (m_hShutdownEvent != INVALID_HANDLE_VALUE)
        CloseHandle( m_hShutdownEvent );

    // DeleteCriticalSection( &m_cs );

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Connect
//
//  Synopsis:   Establishes a connection to the LDAP host and, if a naming
//              context has not been established, asks the host for the
//              default naming context.
//
//  Arguments:  None
//
//  Returns:    TRUE if successfully connected, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::Connect()
{
    TraceFunctEnter( "CLdapConnection::Connect" );

    DWORD ldapErr = LDAP_SUCCESS;                // innocent until proven...
    LPSTR pszHost = (m_szHost[0] == '\0' ? NULL : m_szHost);
    
    if (m_pCPLDAPWrap == NULL) {

        DebugTrace(LDAP_CONN_DBG, "Connecting to [%s:%d]", 
                   pszHost ? pszHost : "NULL", 
                   m_dwPort);

        m_pCPLDAPWrap = new CPLDAPWrap( pszHost, m_dwPort);
        if((m_pCPLDAPWrap != NULL) &&
           (m_pCPLDAPWrap->GetPLDAP() == NULL)) {
            //
            // Failure to connect; release
            //
            m_pCPLDAPWrap->Release();
            m_pCPLDAPWrap = NULL;
        }


        DebugTrace(LDAP_CONN_DBG, "ldap_open returned 0x%x", m_pCPLDAPWrap);

        if (m_pCPLDAPWrap != NULL) {

            INCREMENT_LDAP_COUNTER(Connections);
            INCREMENT_LDAP_COUNTER(OpenConnections);
            //
            // First, set some options - no autoreconnect, and no chasing of
            // referrals
            //

            ULONG ulLdapOff = (ULONG)((ULONG_PTR)LDAP_OPT_OFF);
            ULONG ulLdapRequestTimeLimit = 5 * 60; // 5 minutes
            ULONG ulLdapVersion = LDAP_VERSION3;

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_REFERRALS, (LPVOID) &ulLdapOff);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_AUTO_RECONNECT, (LPVOID) &ulLdapOff);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_TIMELIMIT, (LPVOID) &ulLdapRequestTimeLimit);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_PROTOCOL_VERSION, (LPVOID) &ulLdapVersion);

            ldapErr = BindToHost( GetPLDAP(), m_szAccount, m_szPassword);

            DebugTrace(LDAP_CONN_DBG, "BindToHost returned 0x%x", ldapErr);

        } else {

            INCREMENT_LDAP_COUNTER(ConnectFailures);
            ldapErr = LDAP_SERVER_DOWN;

        }
        //
        // Figure out the naming context for this connection if none was
        // initially specified and we are using the default LDAP_PORT
        // (a baseDN of "" is acceptable on other LDAP ports such as
        // a GC)
        //
        if ((m_dwPort == LDAP_PORT) &&
            (ldapErr == LDAP_SUCCESS) && 
            (m_szNamingContext[0] == 0)) {

            PLDAPMessage pmsg = NULL, pentry;
            LPWSTR rgszAttributes[2];
            LPWSTR *rgszValues = NULL;
            int cValues;

            rgszAttributes[0] = L"defaultNamingContext";
            rgszAttributes[1] = NULL;

            ldapErr = ldap_search_sW(
                            GetPLDAP(),      // ldap binding
                            L"",                 // base DN
                            LDAP_SCOPE_BASE,     // scope of search
                            L"(objectClass=*)",  // filter,
                            rgszAttributes,      // attributes required
                            FALSE,               // attributes-only is false
                            &pmsg);

            DebugTrace(
                LDAP_CONN_DBG,
                "Search for namingContexts returned 0x%x",
                ldapErr);

            if (ldapErr == LDAP_SUCCESS &&
                    (pentry = ldap_first_entry(GetPLDAP(), pmsg)) != NULL &&
                        (rgszValues = ldap_get_valuesW(GetPLDAP(), pentry, rgszAttributes[0])) != NULL &&
                            (cValues = ldap_count_valuesW(rgszValues)) != 0) {

                //
                // Search for the default DN. The best way to do this is
                // look for the namingContext that doesn't have the literal
                // "Configuration" in it.
                //

                for (int i = 0; i < cValues; i++) {

                    if (wcsstr( rgszValues[i], L"configuration" ) == NULL &&
                            wcsstr( rgszValues[i], L"Configuration" ) == NULL &&
                                wcsstr( rgszValues[i], L"CONFIGURATION") == NULL) {

                        int j;

                        _ASSERT( wcslen(rgszValues[i]) <
                                    (sizeof(m_wszNamingContext)/sizeof(WCHAR)));

                        wcscpy(m_wszNamingContext, rgszValues[i]);

                        j = WideCharToMultiByte(
                            CP_UTF8,
                            0,
                            m_wszNamingContext,
                            -1,
                            m_szNamingContext,
                            sizeof(m_szNamingContext),
                            NULL,
                            NULL);
                        _ASSERT(j > 0);

                        break;

                    }

                }

                DebugTrace(
                    LDAP_CONN_DBG,
                    "NamingContext is [%s]",
                    m_szNamingContext);

            } else {

                ldapErr = LDAP_OPERATIONS_ERROR;

            }

            if (rgszValues != NULL)
                ldap_value_freeW( rgszValues );

            if (pmsg != NULL)
                ldap_msgfree( pmsg );

            if (ldapErr != LDAP_SUCCESS)
                Disconnect();

        } // end if port 389, successful bind and no naming context

    } else { // end if we didn't have a connection already

        DebugTrace(
            LDAP_CONN_DBG,
            "Already connected to %s:%d, pldap = 0x%x",
            m_szHost, m_dwPort, GetPLDAP());

    }

    DebugTrace(LDAP_CONN_DBG, "Connect status = 0x%x", ldapErr);

    if (ldapErr != LDAP_SUCCESS) {

        m_fValid = FALSE;

        TraceFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        TraceFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Disconnect
//
//  Synopsis:   Disconnects from the ldap host
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::Disconnect()
{

    TraceFunctEnter("CLdapConnection::Disconnect");

    if (m_pCPLDAPWrap != NULL) {

        SetTerminateIndicatorTrue();

        m_fValid = FALSE;

        m_pCPLDAPWrap->Release();
        m_pCPLDAPWrap = NULL;

        DECREMENT_LDAP_COUNTER(OpenConnections);

    }

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Invalidate
//
//  Synopsis:   Marks this connection invalid. Once this is done, it will
//              return FALSE from all calls to IsEqual, thus effectively
//              removing itself from all searches for cached connections.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::Invalidate()
{
    m_fValid = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::IsValid
//
//  Synopsis:   Returns whether the connection is valid or not.
//
//  Arguments:  None
//
//  Returns:    TRUE if valid, FALSE if a call to Invalidate has been made.
//
//-----------------------------------------------------------------------------

BOOL CLdapConnection::IsValid()
{
    return( m_fValid );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::BindToHost
//
//  Synopsis:   Creates a binding to the LDAP host using the given account
//              and password.
//
//  Arguments:  [pldap] -- The ldap connection to bind.
//              [szAccount] -- The account to use. Of the form "account-name"
//                  or "domain\account-name".
//              [szPassword] -- The password to use.
//
//  Returns:    LDAP result of bind.
//
//-----------------------------------------------------------------------------

DWORD CLdapConnection::BindToHost(
    PLDAP pldap,
    LPSTR szAccount,
    LPSTR szPassword)
{
    TraceFunctEnter( "CLdapConnection::BindToHost" );

    DWORD ldapErr;
    char szDomain[ DNLEN + 1];
    LPSTR pszDomain, pszUser;
    HANDLE hToken;                               // LogonUser modifies hToken
    BOOL fLogon = FALSE;                         // even if it fails! So, we
                                                 // have to look at the result
                                                 // of LogonUser!

    //
    // If this connection was created with anonymous access rights, there is
    // no bind action to do.
    //
    if (m_bt == BIND_TYPE_NONE) {

        ldapErr = ERROR_SUCCESS;

        goto Cleanup;

    }

    //
    // If we are supposed to use simple bind, do it now
    //
    if (m_bt == BIND_TYPE_SIMPLE) {

        ldapErr = ldap_simple_bind_s(pldap,szAccount, szPassword);

        DebugTrace(0, "ldap_simple_bind returned 0x%x", ldapErr);

        goto Cleanup;

    }

    //
    // If we are supposed to logon with current credetials, do it now.
    //
    if (m_bt == BIND_TYPE_CURRENTUSER) {
        //-------------------------------------------------------------------
        // X5: TBD
        // This is the normal case for Exchange services.  We are connecting
        // as LocalSystem, so we must use Kerberos (this is true for the LDAP
        // server as of Win2000 SP1).
        // If we cannot bind as Kerberos, LDAP_AUTH_NEGOTIATE may negotiate
        // down to NTLM, at which point we become anonymous, and the bind
        // succeeds.  Anonymous binding is useless to Exchange, so we would
        // rather force Kerberos and fail if Kerberos has a problem.  Use a
        // SEC_WINNT_AUTH_IDENTITY_EX to specify that only Kerberos auth
        // should be tried.
        //-------------------------------------------------------------------
        SEC_WINNT_AUTH_IDENTITY_EX authstructex;
        ZeroMemory (&authstructex, sizeof(authstructex));

        authstructex.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        authstructex.Length = sizeof (authstructex);
        authstructex.PackageList = (PUCHAR) MICROSOFT_KERBEROS_NAME_A;
        authstructex.PackageListLength = strlen ((PCHAR) authstructex.PackageList);
        authstructex.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

        ldapErr = ldap_bind_s(pldap, 
                              NULL, 
                              (PCHAR) &authstructex, 
                              LDAP_AUTH_NEGOTIATE);

        DebugTrace(0, "ldap_bind returned 0x%x", ldapErr);

        goto Cleanup;
    }
    //
    // Parse out the domain and user names from the szAccount parameter.
    //

    if ((pszUser = strchr(szAccount, '\\')) == NULL) {

        pszUser = szAccount;

        pszDomain = NULL;

    } else {

        ULONG cbDomain = (ULONG)(((ULONG_PTR) pszUser) - ((ULONG_PTR) szAccount));

        strncpy( szDomain, szAccount, cbDomain );

        szDomain[cbDomain] = 0;

        pszDomain = cbDomain > 0 ? szDomain : NULL;

        pszUser++;                               // Go past the backslash

    }

    //
    // Logon as the given user, impersonate, and attempt the LDAP bind.
    //

    if ((fLogon = LogonUser(pszUser, pszDomain, szPassword,
            LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &hToken)) &&
                ImpersonateLoggedOnUser(hToken)) {

        ldapErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

        DebugTrace(0, "ldap_bind returned 0x%x", ldapErr);

        RevertToSelf();

    } else {

        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
            ldapErr = LDAP_INSUFFICIENT_RIGHTS;
        else
            ldapErr = LDAP_INVALID_CREDENTIALS;

    }

Cleanup:

    if (fLogon)
        CloseHandle( hToken );

    //
    // Increment counters
    //
    if(m_bt != BIND_TYPE_NONE) {

        if(ldapErr == ERROR_SUCCESS) {

            INCREMENT_LDAP_COUNTER(Binds);

        } else {

            INCREMENT_LDAP_COUNTER(BindFailures);
        }
    }

    TraceFunctLeave();

    return( ldapErr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::IsEqual
//
//  Synopsis:   Figures out if this connection represents a connection to the
//              given Host,NamingContext,Account, and Password parameters.
//
//  Arguments:  [szHost] -- The name of the LDAP host
//              [dwPort] -- The remote tcp port # of the LDAP connection
//              [szNamingContext] -- The naming context within the DS
//              [szAccount] -- The account used to bind to the LDAP DS.
//              [szPassword] -- The password used with szAccount.
//              [BindType] -- The bind type used to connect to host.
//
//  Returns:    TRUE if this connection represents the connection to the
//              given LDAP context, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL CLdapConnection::IsEqual(
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE BindType)
{
    TraceFunctEnter("CLdapConnection::IsEqual");

    BOOL fResult = FALSE;

    _ASSERT( szHost != NULL );
    _ASSERT( szAccount != NULL );
    _ASSERT( szPassword != NULL );

    if (!m_fValid)
        return( FALSE );


    DebugTrace(
        LDAP_CONN_DBG,
        "Comparing %s:%d;%s;%s",
        szHost, dwPort, szNamingContext, szAccount);

    DebugTrace(
        LDAP_CONN_DBG,
        "With %s:%d;%s;%s; Def NC = %s",
        m_szHost, m_dwPort, m_szNamingContext, m_szAccount,
        m_fDefaultNamingContext ? "TRUE" : "FALSE");

    //
    // See if the host/port match.
    //
    fResult = (BOOL) ((lstrcmpi( szHost, m_szHost) == 0) &&
                      (m_dwPort == dwPort));

    //
    // If the host matches, see if the bind info matches.
    //
    if (fResult) {

        switch (BindType) {
        case BIND_TYPE_NONE:
        case BIND_TYPE_CURRENTUSER:
            fResult = (BindType == m_bt);
            break;

        case BIND_TYPE_SIMPLE:
        case BIND_TYPE_GENERIC:
            fResult = (BindType == m_bt) &&
                        (lstrcmpi(szAccount, m_szAccount) == 0) &&
                            (lstrcmpi(szPassword, m_szPassword) == 0);
            break;

        default:
            _ASSERT( FALSE && "Invalid Bind Type in CLdapConnection::IsEqual");
            break;
        }

    }

    if (fResult) {
        //
        // If caller specified a naming context, see if it matches. Otherwise,
        // see if we are using the Default Naming Context.
        //

        if (szNamingContext && szNamingContext[0] != 0)
            fResult = (lstrcmpi(szNamingContext, m_szNamingContext) == 0);
        else
            fResult = m_fDefaultNamingContext;

    }

    TraceFunctLeave();

    return( fResult );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Search
//
//  Synopsis:   Issues a synchronous search request. Returns the result as an
//              opaque pointer that can be passed to GetFirstEntry /
//              GetNextEntry
//
//  Arguments:  [szBaseDN] -- The DN of the container object within which to
//                  search.
//              [nScope] -- One of LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, or
//                  LDAP_SCOPE_SUBTREE.
//              [szFilter] -- The search filter to use. If NULL, a default
//                  filter is used.
//              [rgszAttributes] -- The list of attributes to retrieve.
//              [ppResult] -- The result is passed back in here.
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::Search(
    LPCSTR szBaseDN,
    int nScope,
    LPCSTR szFilter,
    LPCSTR *rgszAttributes,
    PLDAPRESULT *ppResult)
{
    TraceFunctEnter("CLdapConnection::Search");

    DWORD ldapErr = LDAP_SUCCESS;
    LPCSTR szFilterToUse = szFilter != NULL ? szFilter : "(objectClass=*)";

    if (m_pCPLDAPWrap != NULL) {

        ldapErr = ldap_search_s(
                        GetPLDAP(),          // ldap binding
                        (LPSTR) szBaseDN,        // container DN to search
                        nScope,                  // Base, 1 or multi level
                        (LPSTR) szFilterToUse,   // search filter
                        (LPSTR *)rgszAttributes, // attributes to retrieve
                        FALSE,                   // attributes-only is false
                        (PLDAPMessage *) ppResult); // return result here

    } else {

        ldapErr = LDAP_UNAVAILABLE;

    }

    if (ldapErr != LDAP_SUCCESS) {

        TraceFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        TraceFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::AsyncSearch
//
//  Synopsis:   Issues an asynchronous search request. Inserts a pending
//              request item into the m_pPendingHead queue, so that the
//              given completion routine may be called when the results are
//              available.
//
//              As a side effect, if this is the first time an async request
//              is being issued on this connection, a thread to handle search
//              completions is created.
//
//  Arguments:  [szBaseDN] -- The DN of the container object within which to
//                  search.
//              [nScope] -- One of LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, or
//                  LDAP_SCOPE_SUBTREE.
//              [szFilter] -- The search filter to use. If NULL, a default
//                  filter is used.
//              [rgszAttributes] -- The list of attributes to retrieve.
//              [dwPageSize] -- The desired page size for results.  If
//                              zero, a non-paged ldap search is performed.
//              [fnCompletion] -- The LPLDAPCOMPLETION routine to call when
//                  results are available.
//              [ctxCompletion] -- The context to pass to fnCompletion.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully issued the search request.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate working data strucs
//
//              Win32 Error from ldap_search() call if something went wrong.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::AsyncSearch(
    LPCWSTR szBaseDN,
    int nScope,
    LPCWSTR szFilter,
    LPCWSTR *rgszAttributes,
    DWORD dwPageSize,
    LPLDAPCOMPLETION fnCompletion,
    LPVOID ctxCompletion)
{
    TraceFunctEnter("CLdapConnectio::AsyncSearch");

    HRESULT hr;
    DWORD dwLdapErr;
    PPENDING_REQUEST preq;
    ULONG msgid;
    //
    // First, see if we need to create the completion thread.
    //
    hr = CreateCompletionThreadIfNeeded();
    if(FAILED(hr))
        return hr;

    //
    // Next, allocate a new PENDING_REQUEST record to represent this async
    // request.
    //

    preq = new PENDING_REQUEST;

    if (preq == NULL)
        return( HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) );

    preq->fnCompletion = fnCompletion;
    preq->ctxCompletion = ctxCompletion;
    preq->dwPageSize = dwPageSize;

    //
    // Initialize msgid to -1 so it can't possibly match any valid msgid that
    // the completion thread might be looking for in the pending request list.
    //

    preq->msgid = -1;

    //
    // 
    if(dwPageSize) {
        //
        // Init the paged search if that is what we will be doing
        //
        preq->pldap_search = ldap_search_init_pageW(
            GetPLDAP(),                     // LDAP connection to use
            (LPWSTR) szBaseDN,                  // Starting container DN
            nScope,                             // depth of search
            (LPWSTR) szFilter,                  // Search filter
            (LPWSTR *) rgszAttributes,          // Attributes array
            FALSE,                              // Attributes only?
            NULL,                               // Server controls
            NULL,                               // Client controls
            0,                                  // PageTimeLimit
            0,                                  // TotalSizeLimit
            NULL);                              // Sorting keys

        if(preq->pldap_search == NULL) {

            dwLdapErr = LdapErrorToHr(LdapGetLastError());
            ErrorTrace((LPARAM)this, "ldap_search_init_page failed with err %d (0x%x)", dwLdapErr, dwLdapErr);
            delete preq;
            return ( LdapErrorToHr(dwLdapErr));
        }

    } else {
        
        preq->pldap_search = NULL; // Not doing a paged search
    }
    //
    // We might want to abandon all of our outstanding requests at
    // some point.  Because of this, we use this sharelock to prevent
    // abandoning requests with msgid still set to -1
    //
    m_ShareLock.ShareLock();

    //
    // Link the request into the queue of pending requests so that the
    // completion thread can pick it up when a result is available.
    //

    InsertPendingRequest( preq );

    if(dwPageSize) {
        //
        // Issue an async request for the next page of matches
        //
        dwLdapErr = ldap_get_next_page(
            GetPLDAP(),                     // LDAP connection to use
            preq->pldap_search,                 // LDAP page search context
            dwPageSize,                         // page size desired
            &msgid);

    } else {
        //
        // Now, attempt to issue the async search request.
        //
        dwLdapErr = ldap_search_extW(
            GetPLDAP(),          // LDAP connection to use
            (LPWSTR) szBaseDN,       // Starting container DN
            nScope,                  // depth of search
            (LPWSTR) szFilter,       // Search filter
            (LPWSTR *)rgszAttributes, // List of attributes to get
            FALSE,                   // Attributes only?
            NULL,                    // Server controls
            NULL,                    // Client controls
            0,                       // Time limit
            0,                       // Size limit
            &msgid);
    }

    //
    // One last thing - ldap_search could fail, in which case we need to
    // remove the PENDING_REQUEST item we just inserted.
    //

    if (dwLdapErr != LDAP_SUCCESS) {             // ldap_search failed!

        DebugTrace((LPARAM)this, "DispError %d 0x%08lx conn %08lx", dwLdapErr, dwLdapErr, (PLDAP)(GetPLDAP()));

        RemovePendingRequest( preq );

        m_ShareLock.ShareUnlock();

        INCREMENT_LDAP_COUNTER(SearchFailures);

        if(preq->pldap_search) {

            INCREMENT_LDAP_COUNTER(PagedSearchFailures);
            //
            // Free the ldap page search context
            //
            ldap_search_abandon_page(
                GetPLDAP(),
                preq->pldap_search);
        }

        delete preq;

        return( LdapErrorToHr(dwLdapErr) );

    } else {

        preq->msgid = (int) msgid;

        INCREMENT_LDAP_COUNTER(Searches);
        INCREMENT_LDAP_COUNTER(PendingSearches);

        if(dwPageSize)
            INCREMENT_LDAP_COUNTER(PagedSearches);

        //
        // WARNING: preq could have been processed and free'd in the
        // completion routine at this point so it is not advisable to view
        // it!
        //
        DebugTrace((LPARAM)msgid, "Dispatched ldap search request %ld 0x%08lx conn %08lx", msgid, msgid, (PLDAP)(GetPLDAP()));

        m_ShareLock.ShareUnlock();

        ReleaseSemaphore( m_hOutstandingRequests, 1, NULL );
    }

    TraceFunctLeave();

    return( S_OK );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CancelAllSearches
//
//  Synopsis:   Cancels all pending requests to the LDAP server.
//
//  Arguments:  [hr] -- The error code to complete pending requests with.
//                  Defaults to HRESULT_FROM_WIN32(ERROR_CANCELLED)
//              [pISMTPServer] -- Interface on which to call StopHint after 
//                  every cancelled search. Defaults to NULL, in which case no
//                  StopHint is called.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::CancelAllSearches(
    HRESULT hr,
    ISMTPServer *pISMTPServer)
{
    TraceFunctEnter("CLdapConnection::CancelAllSearches");

    PLIST_ENTRY pli;
    PPENDING_REQUEST preq = NULL;
    LIST_ENTRY listCancel;

    //
    // We need to visit every node of m_listPendingRequests and call the
    // completion routine with the error. But, we want to call the
    // completion routine outside the critical section, so that calls to
    // AsyncSearch (from other threads or this thread!) won't block. So,
    // we simply transfer m_listPendingRequests to a temporary list under
    // the critical section, and then complete the temporary list outside
    // the critical section.
    //

    //
    // Transfer m_listPendingRequests to listCancel under the critical
    // section
    //

    InitializeListHead( &listCancel );

    //
    // We need exclusive access to the list (no half completed
    // searches are welcome), so get the exclusive lock
    //
    m_ShareLock.ExclusiveLock();

    // EnterCriticalSection( &m_cs );

    AcquireSpinLock( &m_spinlockCompletion );

    for (pli = m_listPendingRequests.Flink;
            pli != &m_listPendingRequests;
                pli = m_listPendingRequests.Flink) {

        preq = CONTAINING_RECORD(pli, PENDING_REQUEST, li);

        ErrorTrace(0, "Calling ldap_abandon for msgid %ld",
                   preq->msgid);

        AbandonRequest(preq);

        if (pISMTPServer) {
            pISMTPServer->ServerStopHintFunction();
        }

        RemoveEntryList( &preq->li );

        InsertTailList( &listCancel, &preq->li );

    }
    //
    // Inform ProcessAyncResult that we've cancelled everything
    //
    NotifyCancel();

    ReleaseSpinLock( &m_spinlockCompletion );
    // LeaveCriticalSection( &m_cs );

    m_ShareLock.ExclusiveUnlock();

    //
    // Cancel all pending requests outside the critical section
    //

    for (pli = listCancel.Flink;
            pli != & listCancel;
                pli = listCancel.Flink) {

        preq = CONTAINING_RECORD(pli, PENDING_REQUEST, li);

        RemoveEntryList( &preq->li );

        CallCompletion(
            preq,
            NULL,
            hr,
            TRUE);

        if (pISMTPServer) {
            pISMTPServer->ServerStopHintFunction();
        }

        delete preq;

    }
    TraceFunctLeave();
    return;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::ProcessAsyncResult
//
//  Synopsis:   Routine that LdapCompletionThread calls to process any
//              results for async searches it receives.
//
//  Arguments:  [pres] -- The PLDAPMessage to process. This routine will free
//                      this result when its done with it.
//
//              [dwLdapError] -- The status of the received message.
//
//              [pfTerminateIndicator] -- Ptr to boolean that is set
//                                        to true when we want to
//                                        shutdown 
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::ProcessAsyncResult(
    PLDAPMessage pres,
    DWORD dwLdapError,
    BOOL *pfTerminateIndicator)
{
    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::ProcessAsyncResult");

    int msgid;
    PLIST_ENTRY pli;
    PPENDING_REQUEST preq = NULL;
    LONG lOops = 0;     // It's possible we've recieved a result for a
                        // query that's was sent by ldap_search_ext
                        // currently in another thread and the msgid
                        // hasn't been stamped yet.  If this happens,
                        // we've consumed someone other request's
                        // semaphore count..keep track of these here
                        // and release them when we're done.
    BOOL fNoMsgID = FALSE;  // Set this to true if we see one or more
                            // messages with ID = -1

    BOOL fFinalCompletion = TRUE; // TRUE unless this is a partial
                                  // completion of a paged search

    _ASSERT(pfTerminateIndicator);
    //
    // If dwLdapError is LDAP_SERVER_DOWN, pres will be NULL and we simply
    // have to complete all outstanding requests with that error
    //
    if ((pres == NULL) || (dwLdapError == LDAP_SERVER_DOWN)) {

        _ASSERT(dwLdapError != 0);

        INCREMENT_LDAP_COUNTER(GeneralCompletionFailures);

        ErrorTrace(0, "Generic LDAP error %d 0x%08lx", dwLdapError, dwLdapError);
        
        CancelAllSearches( LdapErrorToHr( dwLdapError ) );

        return;
    }

    //
    // We have a search specific result, find the search request and complete
    // it.
    //

    _ASSERT( pres != NULL );

    msgid = pres->lm_msgid;

    DebugTrace(msgid, "Processing message %d 0x%08lx conn %08lx", pres->lm_msgid, pres->lm_msgid, (PLDAP)(GetPLDAP()));


    while(preq == NULL) {
        //
        // Lookup the msgid in the list of pending requests.
        //

        AcquireSpinLock( &m_spinlockCompletion );

        // EnterCriticalSection( &m_cs );

        for (pli = m_listPendingRequests.Flink;
             pli != &m_listPendingRequests && preq == NULL;
             pli = pli->Flink) {

            PPENDING_REQUEST preqCandidate;

            preqCandidate = CONTAINING_RECORD(pli, PENDING_REQUEST, li);

            if (preqCandidate->msgid == msgid) {

                preq = preqCandidate;

                RemoveEntryList( &preq->li );
                
                //
                // Clear the cancel bit here so we'll know if Cancel
                // was recently requested later in this function
                //
                ClearCancel();

            } else if (preqCandidate->msgid == -1) {

                fNoMsgID = TRUE;

            }
        }

        ReleaseSpinLock( &m_spinlockCompletion );

        // LeaveCriticalSection( &m_cs );


        if (preq == NULL) {
            if(!fNoMsgID) {
                ErrorTrace((LPARAM)this, "Couldn't find message ID %d in list of pending requests.  Ignoring it", msgid);
                //
                // If we don't find the message in our list of pending requests,
                // and we see no messages with ID == -1, it means
                // some other thread came in and cancelled the search before we could
                // process it. This is ok - just return.
                //

                //
                // It is also possible wldap32 is giving us a msgid we
                // never dispatched.  We need to re-release the
                // semaphore count we consumed if this is the case
                //
                lOops++; // For the msgid we did not find
                goto CLEANUP;
            } else {
                //
                // So this(these) messages with id==-1 could possibly be
                // the one we're looking for.  If this is so, we just
                // consumed a semaphore count of a different request.
                // Block for our semaphore and keep track of the extra
                // semaphore counts we are consuming (lOops)
                //
                lOops++;
                DebugTrace((LPARAM)this, "Couldn't find message ID %d in list of pending requests.  Waiting retry #%d", msgid, lOops);
                // Oops, we consumed a semaphore count not meant for us
                _VERIFY(WaitForSingleObject(m_hOutstandingRequests, INFINITE) ==
                        WAIT_OBJECT_0);
                if(*pfTerminateIndicator)
                    return;
                // Try again to find our request
                fNoMsgID = FALSE;
            }
        }
    }

    _ASSERT(preq);

    INCREMENT_LDAP_COUNTER(SearchesCompleted);
    DECREMENT_LDAP_COUNTER(PendingSearches);

    //
    // Determine wether or not this is the final completion call (by
    // default fFinalCompletion is TRUE)
    //
    if(preq->pldap_search != NULL) {

        INCREMENT_LDAP_COUNTER(PagedSearchesCompleted);

        if (dwLdapError == ERROR_SUCCESS) {

            ULONG ulTotalCount;

            //
            // The result is one page of the search.  Dispatch a request
            // for the next page
            //
            // First, call ldap_get_paged_count (required so wldap32 can
            // "save off the cookie that the server sent to resumt the
            // search")
            //
            dwLdapError = ldap_get_paged_count(
                GetPLDAP(),
                preq->pldap_search,
                &ulTotalCount,
                pres);

            if(dwLdapError == ERROR_SUCCESS) {
                //
                // Dispatch a search for the next page
                //
                dwLdapError = ldap_get_next_page(
                    GetPLDAP(),
                    preq->pldap_search,
                    preq->dwPageSize,
                    (PULONG) &(preq->msgid));

                if(dwLdapError == ERROR_SUCCESS) {
                    //
                    // Another request has been dispatched, so this was
                    // not the final search
                    //
                    INCREMENT_LDAP_COUNTER(Searches);
                    INCREMENT_LDAP_COUNTER(PagedSearches);
                    INCREMENT_LDAP_COUNTER(PendingSearches);

                    fFinalCompletion = FALSE;
                    
                    ReleaseSemaphore( m_hOutstandingRequests, 1, NULL );
                    
                } else if(dwLdapError == LDAP_NO_RESULTS_RETURNED) {
                    //
                    // we are handing the last search result now -- free
                    // the paged search
                    //
                    dwLdapError = ldap_search_abandon_page(
                        GetPLDAP(),
                        preq->pldap_search);

                } else {

                    INCREMENT_LDAP_COUNTER(SearchFailures);
                    INCREMENT_LDAP_COUNTER(PagedSearchFailures);
                }
            }
        }
    }
            

    //
    // Call the completion routine of the Request.
    //
    if (dwLdapError == ERROR_SUCCESS) {

        CallCompletion(
            preq,
            pres,
            S_OK,
            fFinalCompletion);

    } else {

        DebugTrace(0, "Search request %d completed with LDAP error 0x%x",
            msgid, dwLdapError);

        ErrorTrace(msgid, "ProcError %d 0x%08lx msgid %d 0x%08lx conn %08lx", dwLdapError, dwLdapError, pres->lm_msgid, pres->lm_msgid, (PLDAP)(GetPLDAP()));

        INCREMENT_LDAP_COUNTER(SearchCompletionFailures);
        if(preq->pldap_search != NULL)
            INCREMENT_LDAP_COUNTER(PagedSearchCompletionFailures);

        CallCompletion(
            preq,
            NULL,
            LdapErrorToHr( dwLdapError ),
            fFinalCompletion);
        //
        // It is unsafe to touch CLdapConnection past here -- it may
        // be deleted (or waiting in the destructor)
        //
    }

    if(fFinalCompletion) {
        //
        // We are done with this search request
        //
        delete preq;

    } else {
        //
        // If we were asked to cancel all searches between the time we
        // got the preq pointer out of the list and now, abandon the
        // pending search, and notify our caller we're cancelled
        //
        AcquireSpinLock(&m_spinlockCompletion);
        if(CancelOccured()) {

            ReleaseSpinLock(&m_spinlockCompletion);

            AbandonRequest(preq);

            CallCompletion(
                preq,
                NULL,
                HRESULT_FROM_WIN32(ERROR_CANCELLED),
                TRUE);

            delete preq;

        } else {
            //
            // we're doing another async wldap32 operation for the
            // next page.  Put preq back in the pending request list
            //
            InsertTailList(&m_listPendingRequests, &(preq->li));

            ReleaseSpinLock(&m_spinlockCompletion);
        }
    }

 CLEANUP:
    //
    // Release the extra semaphore counts we might have consumed
    //
    if((*pfTerminateIndicator == FALSE) && (lOops > 0)) {
        ReleaseSemaphore(m_hOutstandingRequests, lOops, NULL);
    }

    TraceFunctLeaveEx((LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Function:   LdapCompletionThread
//
//  Synopsis:   Friend function of CLdapConnection that handles results
//              received for requests sent via CLdapConnection::AsyncSearch.
//
//  Arguments:  [ctx] -- Opaque pointer to the CLdapConnection instance which
//                  we will service.
//
//  Returns:    Always ERROR_SUCCESS.
//
//-----------------------------------------------------------------------------

DWORD WINAPI LdapCompletionThread(
    LPVOID ctx)
{
    TraceFunctEnterEx((LPARAM)ctx, "LdapCompletionThread");

    CLdapConnection *pConn = (CLdapConnection *) ctx;
    int nResultCode = LDAP_RES_SEARCH_RESULT;
    DWORD dwError;
    PLDAPMessage pres;
    BOOL fTerminate = FALSE;

    //
    // Make sure we have a friend CLdapConnection object!
    //

    _ASSERT( pConn != NULL );

    //
    // Tell our friend to set fTerminate to true when it wants us to return.
    //

    pConn->SetTerminateCompletionThreadIndicator( &fTerminate );

    //
    // Sit in a loop waiting on results for AsyncSearch requests issued by
    // our pConn friend. Do so until our pConn friend terminates the
    // LDAP connection we are servicing.
    //

    do {

        dwError = WaitForSingleObject(
            pConn->m_hOutstandingRequests, INFINITE );

        if (dwError != WAIT_OBJECT_0 || fTerminate)
            break;

        DebugTrace((LPARAM)pConn, "Calling ldap_result now");

        nResultCode = ldap_result(
            pConn->GetPLDAP(),   // LDAP connection to use
            (ULONG) LDAP_RES_ANY,// Search msgid
            LDAP_MSG_ALL,        // Get all results
            NULL,                // Timeout
            &pres);

        if (fTerminate)
            break;


        //
        // We are supposed to call ldap_result2error to find out what the
        // result specific error code is.
        //

        dwError = ldap_result2error( pConn->GetPLDAP(), pres, FALSE );


        if ((dwError == LDAP_SUCCESS) ||
            (dwError == LDAP_RES_SEARCH_RESULT) ||
            (dwError == LDAP_REFERRAL_V2)) {
            //
            // Good, we have a search result. Tell our friend pConn to handle
            // it.
            //
            pConn->ProcessAsyncResult( pres, ERROR_SUCCESS, &fTerminate);

        } else {

            if (pres != NULL) {

                ErrorTrace(
                    (LPARAM)pConn,
                    "LdapCompletionThread - error from ldap_result() for non NULL pres -  0x%x (%d)",
                    dwError, dwError);

                pConn->ProcessAsyncResult( pres, dwError, &fTerminate);

            } else {

                ErrorTrace(
                    (LPARAM)pConn,
                    "LdapCompletionThread - generic error from ldap_result() 0x%x (%d)",
                    dwError, dwError);
                ErrorTrace(
                    (LPARAM)pConn,
                    "nResultCode = %d", nResultCode);

                dwError = LDAP_SERVER_DOWN;

                pConn->ProcessAsyncResult( NULL, dwError, &fTerminate);

            }

        }


    } while ( !fTerminate );

    TraceFunctLeaveEx((LPARAM)pConn);
    return( 0 );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetFirstEntry
//
//  Synopsis:   Retrieves the first entry from a search result. The result is
//              returned as a pointer to an opaque type; all one can do is
//              query the attribute-values of the entry using
//              GetAttributeValues
//
//  Arguments:  [pResult] -- The result set returned by Search.
//              [ppEntry] -- On successful return, pointer to first entry in
//                  result is returned here.
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetFirstEntry(
    PLDAPRESULT pResult,
    PLDAPENTRY *ppEntry)
{
    TraceFunctEnter("CLdapConnection::GetFirstEntry");

    PLDAPMessage pres = (PLDAPMessage) pResult;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( pResult != NULL );
    _ASSERT( ppEntry != NULL );

    *ppEntry = (PLDAPENTRY) ldap_first_entry(GetPLDAP(), pres);

    if (*ppEntry == NULL) {

        DebugTrace(0, "GetFirstEntry failed!");

        TraceFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        TraceFunctLeave();

        return( S_OK );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetNextEntry
//
//  Synopsis:   Retrieves the next entry from a result set.
//
//  Arguments:  [pLastEntry] -- The last entry returned.
//              [ppEntry] -- The next entry in the result set.
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetNextEntry(
    PLDAPENTRY pLastEntry,
    PLDAPENTRY *ppEntry)
{
    TraceFunctEnter("CLdapConnection::GetNextEntry");

    PLDAPMessage plastentry = (PLDAPMessage) pLastEntry;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( pLastEntry != NULL );
    _ASSERT( ppEntry != NULL );

    *ppEntry = (PLDAPENTRY) ldap_next_entry( GetPLDAP(), plastentry );

    if (*ppEntry == NULL) {

        TraceFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        TraceFunctLeave();

        return( S_OK );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetAttributeValues
//
//  Synopsis:   Retrieves the values of a specified attribute of the given
//              entry.
//
//  Arguments:  [pEntry] -- The entry whose attribute value is desired.
//              [szAttribute] -- The attribute whose value is desired.
//              [prgszValues] -- On return, contains pointer to array of
//                  string values
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetAttributeValues(
    PLDAPENTRY pEntry,
    LPCSTR szAttribute,
    LPSTR *prgszValues[])
{
    TraceFunctEnter("CLdapConnection::GetAttributeValues");

    _ASSERT(m_pCPLDAPWrap != NULL);
    _ASSERT(pEntry != NULL);
    _ASSERT(szAttribute != NULL);
    _ASSERT(prgszValues != NULL);

    *prgszValues = ldap_get_values(
        GetPLDAP(),
        (PLDAPMessage) pEntry,
        (LPSTR) szAttribute);

    if ((*prgszValues) == NULL) {

        TraceFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        TraceFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::FreeResult
//
//  Synopsis:   Frees a search result and all its entries.
//
//  Arguments:  [pResult] -- Result retrieved via Search.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::FreeResult(
    PLDAPRESULT pResult)
{
    TraceFunctEnter("CLdapConnection::FreeResult");

    _ASSERT( pResult != NULL );

    ldap_msgfree( (PLDAPMessage) pResult );

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::FreeValues
//
//  Synopsis:   Frees the attribute values retrieved from GetAttributeValues
//
//  Arguments:  [rgszValues] -- The array of values to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::FreeValues(
    LPSTR rgszValues[])
{
    TraceFunctEnter("CLdapConnection::FreeValues");

    _ASSERT( rgszValues != NULL );

    ldap_value_free( rgszValues );

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::ModifyAttributes
//
//  Synopsis:   Adds, deletes, or modifies attributes on a DS object.
//
//  Arguments:  [nOperation] -- One of LDAP_MOD_ADD, LDAP_MOD_DELETE, or
//                  LDAP_MOD_REPLACE.
//              [szDN] -- DN of the DS object.
//              [rgszAttributes] -- The list of attributes
//              [rgrgszValues] -- The list of values associated with each
//                  attribute. rgrgszValues[0] points to an array of values
//                  associated with rgszAttribute[0]; rgrgszValues[1] points
//                  to an array of values associated with rgszAttribute[1];
//                  and so on.
//
//  Returns:    TRUE if success, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::ModifyAttributes(
    int   nOperation,
    LPCSTR szDN,
    LPCSTR *rgszAttributes,
    LPCSTR *rgrgszValues[])
{
    TraceFunctEnter("CLdapConnection::ModifyAttributes");

    int i, cAttr;
    PLDAPMod *prgMods = NULL, rgMods;
    DWORD ldapErr;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( nOperation == LDAP_MOD_ADD ||
                nOperation == LDAP_MOD_DELETE ||
                    nOperation == LDAP_MOD_REPLACE );
    _ASSERT( szDN != NULL );
    _ASSERT( rgszAttributes != NULL );
    _ASSERT( rgrgszValues != NULL || nOperation == LDAP_MOD_DELETE );

    for (cAttr = 0; rgszAttributes[ cAttr ] != NULL; cAttr++) {

        // NOTHING TO DO.

    }

    //
    // Below, we allocate a single chunk of memory that contains an array
    // of pointers to LDAPMod structures. Immediately following that array is
    // the space for the LDAPMod structures themselves.
    //

    prgMods = (PLDAPMod *) new BYTE[ (cAttr+1) *
                                     (sizeof(PLDAPMod) + sizeof(LDAPMod)) ];

    if (prgMods != NULL) {

        rgMods = (PLDAPMod) &prgMods[cAttr+1];

        for (i = 0; i < cAttr; i++) {

            rgMods[i].mod_op = nOperation;
            rgMods[i].mod_type = (LPSTR) rgszAttributes[i];

            if (rgrgszValues != NULL) {
                rgMods[i].mod_vals.modv_strvals = (LPSTR *)rgrgszValues[i];
            } else {
                rgMods[i].mod_vals.modv_strvals = NULL;
            }

            prgMods[i] = &rgMods[i];

        }

        prgMods[i] = NULL;                       // Null terminate the array

        ldapErr = ldap_modify_s( GetPLDAP(), (LPSTR) szDN, prgMods );

        delete [] prgMods;

    } else {

        ldapErr = LDAP_NO_MEMORY;

    }

    if (ldapErr != LDAP_SUCCESS) {

        DebugTrace(LDAP_CONN_DBG, "Status = 0x%x", ldapErr);

        TraceFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        TraceFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::LdapErrorToWin32
//
//  Synopsis:   Converts LDAP errors to Win32
//
//  Arguments:  [dwLdapError] -- The LDAP error to convert
//
//  Returns:    Equivalent Win32 error
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::LdapErrorToHr(
    DWORD dwLdapError)
{
    DWORD dwErr;

    TraceFunctEnter("LdapErrorToWin32");

    switch (dwLdapError) {
    case LDAP_SUCCESS:
        dwErr = NO_ERROR;
        break;
    case LDAP_OPERATIONS_ERROR:
    case LDAP_PROTOCOL_ERROR:
        dwErr = CAT_E_DBFAIL;
        break;
    case LDAP_TIMELIMIT_EXCEEDED:
        dwErr = ERROR_TIMEOUT;
        break;
    case LDAP_SIZELIMIT_EXCEEDED:
        dwErr = ERROR_DISK_FULL;
        break;
    case LDAP_AUTH_METHOD_NOT_SUPPORTED:
        dwErr = ERROR_NOT_SUPPORTED;
        break;
    case LDAP_STRONG_AUTH_REQUIRED:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_ADMIN_LIMIT_EXCEEDED:
        dwErr = CAT_E_DBFAIL;
        break;
    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        dwErr = ERROR_FILE_EXISTS;
        break;
    case LDAP_NO_SUCH_OBJECT:
        dwErr = ERROR_FILE_NOT_FOUND;
        break;
    case LDAP_INAPPROPRIATE_AUTH:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_INVALID_CREDENTIALS:
        dwErr = ERROR_LOGON_FAILURE;
        break;
    case LDAP_INSUFFICIENT_RIGHTS:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_BUSY:
        dwErr = ERROR_BUSY;
        break;
    case LDAP_UNAVAILABLE:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_UNWILLING_TO_PERFORM:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_ALREADY_EXISTS:
        dwErr = ERROR_FILE_EXISTS;
        break;
    case LDAP_OTHER:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_SERVER_DOWN:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_LOCAL_ERROR:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_NO_MEMORY:
        dwErr = ERROR_OUTOFMEMORY;
        break;
    case LDAP_TIMEOUT:
        dwErr = ERROR_TIMEOUT;
        break;
    case LDAP_CONNECT_ERROR:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_NOT_SUPPORTED:
        dwErr = ERROR_NOT_SUPPORTED;
        break;
    default:
        DebugTrace(
            0,
            "LdapErrorToWin32: No equivalent for ldap error 0x%x",
            dwLdapError);
        dwErr = dwLdapError;
        break;
    }

    DebugTrace(
        LDAP_CONN_DBG,
        "LdapErrorToWin32: Ldap Error 0x%x == Win32 error %d (0x%x) == HResult %d (0x%x)",
        dwLdapError, dwErr, dwErr, HRESULT_FROM_WIN32(dwErr), HRESULT_FROM_WIN32(dwErr));

    TraceFunctLeave();

    return( HRESULT_FROM_WIN32(dwErr) );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CreateCompletionThreadIfNeeded
//
//  Synopsis:   Helper function to create a completion thread that will
//              watch for results of async ldap searches.
//
//  Arguments:  None
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::CreateCompletionThreadIfNeeded()
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::CreateCompletionThreadIfNeeded");
    //
    // Test to see if we already have a completion thread...
    //

    if (m_hCompletionThread != INVALID_HANDLE_VALUE) {
        hr = S_OK;
        goto CLEANUP;
    }

    //
    // Looks like we'll have to create a completion thread. Lets acquire
    // m_spinlockCompletion so only one of us tries to do this...
    //

    AcquireSpinLock( &m_spinlockCompletion );

    // EnterCriticalSection( &m_cs );
    fLocked = TRUE;

    //
    // Check one more time inside the lock - someone might have beaten us to
    // it.
    //
    if (m_hOutstandingRequests == INVALID_HANDLE_VALUE) {

        m_hOutstandingRequests = CreateSemaphore(NULL, 0, LONG_MAX, NULL);

        if (m_hOutstandingRequests == NULL) {
            m_hOutstandingRequests = INVALID_HANDLE_VALUE;
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
        }
    }

    if (m_hCompletionThread == INVALID_HANDLE_VALUE) {
        //
        // Create the completion thread
        //
        m_hCompletionThread =
            CreateThread(
                NULL,                // Security Attributes
                0,                   // Initial stack - default
                LdapCompletionThread,// Starting address
                (LPVOID) this,       // Param to LdapCompletionRtn
                0,                   // Create Flags
                &m_idCompletionThread);// Receives thread id

        if (m_hCompletionThread == NULL) {
            m_hCompletionThread = INVALID_HANDLE_VALUE;
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
        }
    }

 CLEANUP:
    if(fLocked) {
        ReleaseSpinLock( &m_spinlockCompletion );
        // LeaveCriticalSection( &m_cs );
    }
    
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::SetTerminateCompletionThreadIndicator
//
//  Synopsis:   Callback for our LdapCompletionThread to set a pointer to a
//              boolean that will be set to TRUE when the LdapCompletionThread
//              needs to terminate.
//
//  Arguments:  [pfTerminateCompletionThreadIndicator] -- Pointer to boolean
//              which will be set to true when the completion thread should
//              terminate.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::SetTerminateCompletionThreadIndicator(
    BOOL *pfTerminateCompletionThreadIndicator)
{
    _ASSERT(pfTerminateCompletionThreadIndicator);

    InterlockedExchangePointer(
        (PVOID *) &m_pfTerminateCompletionThreadIndicator,
        (PVOID) pfTerminateCompletionThreadIndicator);

    if(m_fTerminating) {
        //
        // We may have decided to terminate before the
        // LdapCompletionThread had the chance to call this function.
        // If this is the case, we still need to set the thread's
        // terminate indicator to true.  We call
        // SetTerminateIndicatorTrue() to accomplish this.  It uses
        // interlocked functions to ensure that the terminate
        // indicator pointer is not set to true more than once.
        // 
        SetTerminateIndicatorTrue();
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::InsertPendingRequest
//
//  Synopsis:   Inserts a new PENDING_REQUEST record in the m_pPendingHead
//              list so that the completion thread will find it when the
//              search result is available.
//
//  Arguments:  [preq] -- The PENDING_REQUEST record to insert.
//
//  Returns:    Nothing, this always succeeds.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::InsertPendingRequest(
    PPENDING_REQUEST preq)
{
    AcquireSpinLock( &m_spinlockCompletion );

    InsertTailList( &m_listPendingRequests, &preq->li );

    ReleaseSpinLock( &m_spinlockCompletion );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::RemovePendingRequest
//
//  Synopsis:   Removes a PENDING_REQUEST record from the
//              m_listPendingRequests list.
//
//  Arguments:  [preq] -- The PENDING_REQUEST record to remove
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::RemovePendingRequest(
    PPENDING_REQUEST preq)
{
    AcquireSpinLock( &m_spinlockCompletion );

    RemoveEntryList( &preq->li );

    ReleaseSpinLock( &m_spinlockCompletion );
}


//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::CLdapConnectionCache
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define MAX_HOST_CONNECTIONS        100
#define DEFAULT_HOST_CONNECTIONS    8

CLdapConnectionCache::CLdapConnectionCache()
{
    TraceFunctEnter("CLdapConnectionCache::CLdapConnectionCache");

    m_cRef = 0;

    for (DWORD i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {
        InitializeListHead( &m_rgCache[i] );
    }

    m_nNextConnectionSkipCount = 0;
    m_cMaxHostConnections = DEFAULT_HOST_CONNECTIONS;
    m_cCachedConnections = 0;
    ZeroMemory(&m_rgcCachedConnections, sizeof(m_rgcCachedConnections));

    InitializeFromRegistry();

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::InitializeFromRegistry
//
//  Synopsis:   Helper function that looks up parameters from the registry.
//              The only configurable parameter is
//              MAX_LDAP_CONNECTIONS_PER_HOST_KEY, which is read into
//              m_cMaxHostConnections.
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    cbValue = sizeof(dwValue);

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, MAX_LDAP_CONNECTIONS_PER_HOST_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_LDAP_CONNECTIONS_PER_HOST_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        RegCloseKey( hkey );

    }

    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
                dwValue > 0 && dwValue < MAX_HOST_CONNECTIONS) {

        InterlockedExchange((PLONG) &m_cMaxHostConnections, (LONG)dwValue);

    } else {

        InterlockedExchange(
            (PLONG) &m_cMaxHostConnections, (LONG) DEFAULT_HOST_CONNECTIONS);

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::~CLdapConnectionCache
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapConnectionCache::~CLdapConnectionCache()
{
    TraceFunctEnter("CLdapConnectionCache::~CLdapConnectionCache");

    unsigned short i;

    for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {
        _ASSERT( IsListEmpty( &m_rgCache[i] ) );
    }

    TraceFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::AddRef
//
//  Synopsis:   Increment the refcount on this Connection Cache object.
//              Indicates that there is one more CEmailIDLdapStore object that
//              wants to avail of our services.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::AddRef()
{
    InterlockedIncrement( &m_cRef );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::Release
//
//  Synopsis:   Decrements the refcount on this connection cache object.
//              Indicates that there is one less CEmailIDLdapStore object that
//              wants to use our services.
//
//              If the refcount drops to 0, all outstanding LDAP connections
//              are destroyed!
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::Release()
{
    unsigned short i;
    CCachedLdapConnection *pcc;
    LIST_ENTRY *pli;

    _ASSERT( m_cRef > 0 );

    if (InterlockedDecrement( &m_cRef ) == 0) {

        for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {

            m_rgListLocks[i].ExclusiveLock();

            for (pli = m_rgCache[i].Flink;
                    pli != &m_rgCache[i];
                        pli = m_rgCache[i].Flink) {

                pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

                RemoveEntryList( &pcc->li );
                //
                // Initialize li just in case someone attempts another
                // removal
                //
                InitializeListHead( &pcc->li );

                pcc->Disconnect();

                pcc->ReleaseAndWaitForDestruction();

            }
            m_rgListLocks[i].ExclusiveUnlock();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::GetConnection
//
//  Synopsis:   Gets a connection to a given LDAP host
//
//  Arguments:  [szNamingContext] -- The container within the DS. Could be
//                  null to indicate root of the DS.
//              [szHost] -- the LDAP Host
//              [dwPort] -- the remote LDAP tcp port (if zero, LDAP_PORT is assumed)
//              [szAccount] -- The account to be used to log in
//              [szPassword] -- The password to be used to log in
//              [bt] -- The bind method to use to log in
//              [pCreateContext] -- a pointer to pass to
//                                  CreateCachedLdapConnection when
//                                  we need to create a new connection.
//
//  Returns:    Pointer to Connected LDAP connection or NULL
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnectionCache::GetConnection(
    CLdapConnection **ppConn,
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE bt,
    PVOID pCreateContext)
{
    TraceFunctEnter("CLdapConnectionCache::GetConnection");

    LPSTR szConnectionName = szHost;
    unsigned short n;
    LIST_ENTRY *pli;
    CCachedLdapConnection *pcc;
    LONG nSkipCount, nTargetSkipCount;
    HRESULT hr = S_OK;

    _ASSERT( szHost != NULL );
    _ASSERT( szAccount != NULL );
    _ASSERT( szPassword != NULL );

    //
    // See if we have a cached connection already.
    //

    n = Hash( szConnectionName );

    m_rgListLocks[n].ShareLock();

    nTargetSkipCount = m_nNextConnectionSkipCount % m_cMaxHostConnections;

    for (nSkipCount = 0, pcc= NULL, pli = m_rgCache[n].Flink;
            pli != &m_rgCache[n];
                pli = pli->Flink) {

         pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

         if (pcc->IsEqual(szHost, dwPort, szNamingContext, szAccount, szPassword, bt)
                && ((nSkipCount++ == nTargetSkipCount)
                    || (pcc->GetRefCount() == 1)))
             break;
         else
             pcc = NULL;

    }

    if (pcc)
        pcc->AddRef(); // Add the caller's reference

    m_rgListLocks[n].ShareUnlock();

    DebugTrace( LDAP_CCACHE_DBG, "Cached connection is 0x%x", pcc);

    DebugTrace( LDAP_CCACHE_DBG,
        "nTargetSkipCount = %d, nSkipCount = %d",
        nTargetSkipCount, nSkipCount);

    //
    // If we don't have a cached connection, we need to create a new one.
    //

    if (pcc == NULL) {

        m_rgListLocks[n].ExclusiveLock();

        for (nSkipCount = 0, pcc = NULL, pli = m_rgCache[n].Flink;
                pli != &m_rgCache[n];
                    pli = pli->Flink) {

             pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

             if (pcc->IsEqual(szHost, dwPort, szNamingContext, szAccount, szPassword, bt)
                    && (++nSkipCount == m_cMaxHostConnections ||
                            pcc->GetRefCount() == 1))
                 break;
             else
                 pcc = NULL;

        }

        if (pcc) {

            pcc->AddRef(); // Add the caller's reference

        } else {

            pcc = CreateCachedLdapConnection(
                szHost, dwPort, szNamingContext,
                szAccount, szPassword, bt, pCreateContext);

            if (pcc != NULL) {

                hr = pcc->Connect();

                if (FAILED(hr)) {

                    ErrorTrace(LDAP_CCACHE_DBG, "Failed to connect 0x%x, hr = 0x%x", pcc, hr);

                    pcc->Release();

                    pcc = NULL;

                } else {
                    
                    pcc->AddRef(); // Reference for the connection in
                                   // the cache
                    InsertTailList( &m_rgCache[n], &pcc->li );

                    m_cCachedConnections++;
                    m_rgcCachedConnections[n]++;

                }

            } else {

                hr = E_OUTOFMEMORY;

            }

        }

        m_rgListLocks[n].ExclusiveUnlock();

        DebugTrace(LDAP_CCACHE_DBG, "New connection is 0x%x", pcc);

    }

    //
    // If we are returning a connection, then bump up the skip count so we
    // round-robin through valid connections
    //

    if (pcc != NULL) {

        InterlockedIncrement( &m_nNextConnectionSkipCount );

    }

    //
    // Done.
    //

    *ppConn = pcc;
    TraceFunctLeave();
    return( hr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::CancelAllConnectionSearches
//
//  Synopsis:   Walks through all connections and cancels any pending searches
//              on them.
//
//  Arguments:  [None]
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID CLdapConnectionCache::CancelAllConnectionSearches(
    ISMTPServer *pISMTPServer)
{
    TraceFunctEnterEx((LPARAM)this, "CLdapConnectionCache::CancelAllConnectionSearches");

    PLIST_ENTRY pli;
    DWORD i;

    DWORD dwcArraySize = 0;
    DWORD dwcArrayElements = 0;
    CCachedLdapConnection **rgpcc = NULL;
    CCachedLdapConnection *pcc = NULL;

    for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {

        m_rgListLocks[i].ExclusiveLock();
        //
        // Do we have enough space?  Realloc if necessary
        //
        if( ((DWORD) m_rgcCachedConnections[i]) > dwcArraySize) {
            
            dwcArraySize = m_rgcCachedConnections[i];
            //
            // Alloc array
            //
            rgpcc = (CCachedLdapConnection **) 
                    alloca( dwcArraySize * sizeof(CCachedLdapConnection *));
        }

        for (pli = m_rgCache[i].Flink, dwcArrayElements = 0;
                pli != &m_rgCache[i];
                    pli = pli->Flink, dwcArrayElements++) {

            //
            // If this assert fires, it means m_rgcCachedConnections[n] is
            // somehow less than the number of connections in the list.
            //
            _ASSERT(dwcArrayElements < dwcArraySize);

            pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

            //
            // Grab the connection (copy and addref the conn ptr)
            //
            rgpcc[dwcArrayElements] = pcc;
            pcc->AddRef();
        }

        m_rgListLocks[i].ExclusiveUnlock();
        //
        // Cancel all searches outside the lock
        //
        for(DWORD dwCount = 0;
            dwCount < dwcArrayElements;
            dwCount++) {

            rgpcc[dwCount]->CancelAllSearches(
                HRESULT_FROM_WIN32(ERROR_CANCELLED),
                pISMTPServer);
            rgpcc[dwCount]->Release();
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::Hash
//
//  Synopsis:   Computes a hash given a connection name. Here, we use a simple
//              xor of all the chars in the name.
//
//  Arguments:  [szConnectionName] -- Name to compute the hash of
//
//  Returns:    A value between 0 and LDAP_CONNECTION_CACHE_TABLE_SIZE-1,
//              inclusive.
//
//-----------------------------------------------------------------------------

unsigned short CLdapConnectionCache::Hash(
    LPSTR szConnectionName)
{
    TraceFunctEnter("CLdapConnectionCache::Hash");

    int i;
    unsigned short n = 0;

    _ASSERT( szConnectionName != NULL );

    for (i = 0, n = szConnectionName[i];
            szConnectionName[i] != 0;
                n ^= szConnectionName[i], i++) {

        // NOTHING TO DO

    }

    TraceFunctLeave();

    return( n & (LDAP_CONNECTION_CACHE_TABLE_SIZE-1));
}



//+------------------------------------------------------------
//
// Function: CLdapConnection::CallCompletion
//
// Synopsis: Create all the ICategorizerItemAttributes and call the
// completion routine
//
// Arguments:
//  preq: PENDING_REQUEST
//  pres: LdapMessage
//  hrStatus: Status of lookup
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
// Returns: NOTHING; calls completion routine with any error
//
// History:
// jstamerj 1998/07/02 13:57:20: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::CallCompletion(
    PPENDING_REQUEST preq,
    PLDAPMessage pres,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr = S_OK;
    ICategorizerItemAttributes **rgpIAttributes = NULL;
    BOOL fAllocatedArray = FALSE;
    int nEntries;
    PLDAPMessage pMessage;
    CLdapResultWrap *pResultWrap = NULL;

    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::CallCompletion");

    if(pres) {
        //
        // Wrap the result so that pres can be refcounted
        //
        nEntries = ldap_count_entries(GetPLDAP(), pres);

        pResultWrap = new CLdapResultWrap(m_pCPLDAPWrap, pres);

        if(pResultWrap == NULL) {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM)this, "Out of memory Allocing CLdapResultWrap");
            goto CALLCOMPLETION;
        }
        //
        // AddRef here, release at the end of this function
        //
        pResultWrap->AddRef();

    } else {
        nEntries = 0;
    }

    if(nEntries > 0) {
        //
        // Allocate array for all these ICategorizerItemAttributes
        //
        rgpIAttributes = new ICategorizerItemAttributes * [nEntries];
        if(rgpIAttributes == NULL) {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM)this, "Out of memory Allocing ICategorizerItemAttribute array failed");
            goto CALLCOMPLETION;
        }
        ZeroMemory(rgpIAttributes, nEntries * sizeof(ICategorizerItemAttributes *));

        //
        // Iterage through all the DS Objectes returned and create an
        // ICategorizerItemAttributes implementation for each of them
        //
        pMessage = ldap_first_entry(GetPLDAP(), pres);

        for(int nCount = 0; nCount < nEntries; nCount++) {
            _ASSERT(pMessage);
            rgpIAttributes[nCount] = new CICategorizerItemAttributesIMP(
                GetPLDAP(),
                pMessage,
                pResultWrap);
            if(rgpIAttributes[nCount] == NULL) {
                hr = E_OUTOFMEMORY;
                ErrorTrace((LPARAM)this, "Out of memory Allocing ICategorizerItemAttributesIMP class");
                goto CALLCOMPLETION;
            }
            rgpIAttributes[nCount]->AddRef();
            pMessage = ldap_next_entry(GetPLDAP(), pMessage);
        }
        // That should have been the last entry
        _ASSERT(pMessage == NULL);
    } else {
        //
        // nEntries is zero
        //
        rgpIAttributes = NULL;
    }

 CALLCOMPLETION:

    if(FAILED(hr)) {
        //
        // Something failed creating the above array
        // Call completion routine with error
        //
        preq->fnCompletion(
            preq->ctxCompletion,
            0,
            NULL,
            hr,
            fFinalCompletion);

    } else {
        //
        // Nothing failed in this function; call completion with
        // passed in hrStatus
        //
        preq->fnCompletion(
            preq->ctxCompletion,
            nEntries,
            rgpIAttributes,
            hrStatus,
            fFinalCompletion);
    }

    //
    // Clean up
    //
    if(rgpIAttributes) {
        for(int nCount = 0; nCount < nEntries; nCount++) {
            if(rgpIAttributes[nCount])
                rgpIAttributes[nCount]->Release();
        }
        delete rgpIAttributes;
    }

    if(pResultWrap != NULL) {

        pResultWrap->Release();

    } else if(pres) {
        //
        // We were unable to create pResultWrap, so we have to free
        // the LDAP result ourself (normally CLdapResultWrap free's
        // the ldap result when all references have been released)
        //
        FreeResult(pres);
    }
}


//+------------------------------------------------------------
//
// Function: CLdapConnection::Release
//
// Synopsis: Release a refcount to this object.  Delete this object
//           when the refcout hits zero 
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/04/01 00:09:36: Created.
//
//-------------------------------------------------------------
DWORD CLdapConnection::Release()
{
    DWORD dwNewRefCount;

    dwNewRefCount = InterlockedDecrement((PLONG) &m_dwRefCount);
    if(dwNewRefCount == 0) {

        if(m_dwDestructionWaiters) {
            //
            // Threads are waiting on the destruction event, so let
            // the last thread to wakeup delete this object
            //
            _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
            _VERIFY(SetEvent(m_hShutdownEvent));

        } else {
            //
            // Nobody is waiting, so delete this object
            //
            FinalRelease();
        }
    }
    return dwNewRefCount;
} // CLdapConnection::Release


//+------------------------------------------------------------
//
// Function: CLdapConnection::ReleaseAndWaitForDestruction
//
// Synopsis: Release a refcount and block this thread until the object
//           is destroyed
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/01 00:12:13: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::ReleaseAndWaitForDestruction()
{
    DWORD dw;

    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::ReleaseAndWaitForDestruction");

    _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
    //
    // Increment the count of threads waiting for destruction
    //
    InterlockedIncrement((PLONG)&m_dwDestructionWaiters);

    //
    // Release our refcount; if the new refcount is zero, this object
    // will NOT be deleted; instead m_hShutdownEvent will be set
    //
    Release();

    //
    // Wait for all refcounts to be released
    //
    dw = WaitForSingleObject(
        m_hShutdownEvent,
        INFINITE);

    _ASSERT(WAIT_OBJECT_0 == dw);

    //
    // Decrement the number of threads waiting for termination; if we
    // are the last thread to leave here, we need to delete this
    // object
    //
    if( InterlockedDecrement((PLONG)&m_dwDestructionWaiters) == 0)
        FinalRelease();

    TraceFunctLeaveEx((LPARAM)this);
} // CLdapConnection::ReleaseAndWaitForDestruction


//+------------------------------------------------------------
//
// Function: CLdapConnection::HrInitialize
//
// Synopsis: Initialize error prone members
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/04/01 00:17:56: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::HrInitialize()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::HrInitialize");

    m_hShutdownEvent = CreateEvent(
        NULL,       // Security attributes
        TRUE,       // fManualReset
        FALSE,      // Initial state is NOT signaled
        NULL);      // No name

    if(NULL == m_hShutdownEvent) {

        hr = HRESULT_FROM_WIN32(GetLastError());

        //
        // Remember that m_hShutdownEvent is invalid
        //
        m_hShutdownEvent = INVALID_HANDLE_VALUE;
        
        FatalTrace((LPARAM)this, "Error creating event hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::HrInitialize


//+------------------------------------------------------------
//
// Function: CLdapConnectionCache::CCachedLdapConnection::Release
//
// Synopsis: Override Release for the cached LDAP connection
//
// Arguments: NONE
//
// Returns: New refcount
//
// History:
// jstamerj 1999/04/01 00:30:55: Created.
//
//-------------------------------------------------------------
DWORD CLdapConnectionCache::CCachedLdapConnection::Release()
{
    DWORD dw;

    TraceFunctEnterEx((LPARAM)this, "CLdapConnectionCache::CCachedLdapConnection::Release");

    dw = CLdapConnection::Release();
    if((dw == 1) && (!IsValid())) {
        //
        // The ldap connection cache is the only entity that has a
        // reference to this and this is invalid -- it should be
        // removed from the cache
        //
        m_pCache->RemoveFromCache(this);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return dw;
} // CLdapConnectionCache::CCachedLdapConnection::Release


//+------------------------------------------------------------
//
// Function: CLdapConnectionCache::RemoveFromCache
//
// Synopsis: Removes an LDAP connection object from the cache
//
// Arguments:
//  pConn: the connection to remove
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/01 00:38:43: Created.
//
//-------------------------------------------------------------
VOID CLdapConnectionCache::RemoveFromCache(
    CCachedLdapConnection *pConn)
{
    BOOL fRemoved = FALSE;
    TraceFunctEnterEx((LPARAM)this, "CLdapConnectionCache::RemoveFromCache");
    DWORD dwHash = 0;

    DebugTrace((LPARAM)this, "pConn = %08lx", pConn);

    dwHash = Hash(pConn->SzHost());
    //
    // Before locking, check to see if the connection has already been removed
    //
    if(!IsListEmpty( &(pConn->li))) {

        m_rgListLocks[dwHash].ExclusiveLock();
        //
        // Check again in case the connection was removed from the
        // cache before we got the lock 
        //
        if(!IsListEmpty( &(pConn->li))) {

            RemoveEntryList( &(pConn->li) );
            //
            // Initialize li just in case someone attempts another removal
            //
            InitializeListHead( &(pConn->li) );
            fRemoved = TRUE;
            m_cCachedConnections--;
            m_rgcCachedConnections[dwHash]--;

        }

        m_rgListLocks[dwHash].ExclusiveUnlock();

        if(fRemoved)
            pConn->Release();
    }
    TraceFunctLeaveEx((LPARAM)this);
} // CLdapConnectionCache::RemoveFromCache


//+------------------------------------------------------------
//
// Function: CLdapConnection::AsyncSearch (UTF8)
//
// Synopsis: Same as AsyncSearch, accept this accepts a UTF8 search
//           filter.
//
// Arguments: See AsyncSearch
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/09 18:22:41: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::AsyncSearch(
    LPCWSTR szBaseDN,                    // objects matching specified
    int nScope,                          // criteria in the DS. The
    LPCSTR szFilterUTF8,                 // results are passed to
    LPCWSTR szAttributes[],              // fnCompletion when they
    DWORD dwPageSize,                    // Optinal page size
    LPLDAPCOMPLETION fnCompletion,       // become available.
    LPVOID ctxCompletion)
{
    HRESULT hr = S_OK;
    LPWSTR wszFilter = NULL;
    int    cchFilter = 0;
    int    i = 0;
    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::AsyncSearch");
    //
    // Convert BaseDN and Filter to unicode (from UTF8)
    //
    // calculate lengths
    //
    cchFilter = MultiByteToWideChar(
        CP_UTF8,
        0,
        szFilterUTF8,
        -1,
        NULL,
        0);
    if(cchFilter == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)this, "MultiByteToWideChar failed hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // allocate space
    //
    wszFilter = (LPWSTR) alloca(cchFilter * sizeof(WCHAR));
    if(wszFilter == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        szFilterUTF8,
        -1,
        wszFilter,
        cchFilter);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)this, "MultiByteToWideChar failed hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // Call unicode based AsyncSearch
    //
    hr = AsyncSearch(
        szBaseDN,
        nScope,
        wszFilter,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::AsyncSearch


//+------------------------------------------------------------
//
// Function: CLdapConnection::AsyncSearch
//
// Synopsis: same as above with UTF8 search filter and base DN
//
// Arguments: see above
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/09 20:50:53: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::AsyncSearch(
    LPCSTR szBaseDN,                     // objects matching specified
    int nScope,                          // criteria in the DS. The
    LPCSTR szFilterUTF8,                 // results are passed to
    LPCWSTR szAttributes[],              // fnCompletion when they
    DWORD dwPageSize,                    // Optinal page size
    LPLDAPCOMPLETION fnCompletion,       // become available.
    LPVOID ctxCompletion)
{
    HRESULT hr = S_OK;
    LPWSTR wszBaseDN = NULL;
    int    cchBaseDN = 0;
    int    i = 0;
    TraceFunctEnterEx((LPARAM)this, "CLdapConnection::AsyncSearch");
    //
    // Convert BaseDN and Filter to unicode (from UTF8)
    //
    // calculate lengths
    //
    cchBaseDN = MultiByteToWideChar(
        CP_UTF8,
        0,
        szBaseDN,
        -1,
        NULL,
        0);
    if(cchBaseDN == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)this, "MultiByteToWideChar failed hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // allocate space
    //
    wszBaseDN = (LPWSTR) alloca(cchBaseDN * sizeof(WCHAR));
    if(wszBaseDN == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        szBaseDN,
        -1,
        wszBaseDN,
        cchBaseDN);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)this, "MultiByteToWideChar failed hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // Call unicode based AsyncSearch
    //
    hr = AsyncSearch(
        wszBaseDN,
        nScope,
        szFilterUTF8,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::AsyncSearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatqueries.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatqueries.cpp
//
// Contents: CICategorizerQueriesIMP implementation
//
// Classes:
//  CICategorizerQueriesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/15 14:25:18: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerQueries
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerQueries) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerQueriesIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerQueriesIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);

    // We are allocated on the stack
    
    return lNewRefCount;
}


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::SetQueryString
//
// Synopsis: Set the query string for a batch of ICategorizerItems
//
// Arguments:
//  pszQueryString: QueryString to set or NULL to unset any query string
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/15 14:28:18: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::SetQueryString(
    IN  LPSTR  pszQueryString)
{
    DWORD dwOldLength;
    DWORD dwNewLength;

    //
    // If pszQueryString is NULL, release any existing buffer and set
    // ptr to NULL
    //
    if(pszQueryString == NULL) {
        if(*m_ppsz != NULL)
            delete *m_ppsz;
        *m_ppsz = NULL;
        return S_OK;
    }

    //
    // Get the lengths of new and old strings
    //
    dwNewLength = lstrlen(pszQueryString);

    if(*m_ppsz) {

        dwOldLength = lstrlen(*m_ppsz);

        if(dwNewLength <= dwOldLength) {
            //
            // Re-use the same buffer
            //
            lstrcpy(*m_ppsz, pszQueryString);
            return S_OK;

        } else {
            //
            // Free the existing buffer and realloc below
            //
            delete *m_ppsz;
        }
    }
    *m_ppsz = new CHAR[ dwNewLength + 1 ];

    if(*m_ppsz == NULL)
        return E_OUTOFMEMORY;

    lstrcpy(*m_ppsz, pszQueryString);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::SetQueryStringNoAlloc
//
// Synopsis: Internal method to set the query string without
//           ReAllocing the buffer
//
// Arguments:
//  pszQueryString: QueryString to set
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/15 16:08:45: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerQueriesIMP::SetQueryStringNoAlloc(
    IN  LPSTR  pszQueryString)
{
    //
    // Free the old buffer, if any
    //
    if(*m_ppsz)
        delete *m_ppsz;
    
    //
    // Set the new string to the caller's pointer
    //
    *m_ppsz = pszQueryString;

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::GetQueryString
//
// Synopsis: Retrieve pointer to the current query string.  Note that
//           this pointer will become bogus of SetQueryString is called again
//
// Arguments:
//  ppszQueryString: ptr to set to the query string ptr.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/20 15:06:34: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::GetQueryString(
    LPSTR   *ppszQueryString)
{
    _ASSERT(ppszQueryString);
    //
    // Give out our string pointer
    //
    *ppszQueryString = *m_ppsz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapstor.cpp ===
//
// ldapstor.cpp -- This file contains implementations for
//      GetEmailIDStore
//      ReleaseEmailIDStore
//
// Created:
//      December 18, 1996   -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "ldapstor.h"
#include "propstr.h"
#include "ccataddr.h"
#include "icatparam.h"
#include "cnfgmgr.h"

const DWORD CEmailIDLdapStore<CCatAddr>::Signature = (DWORD) 'IMAB';

//+----------------------------------------------------------------------------
//
//  Function:   GetEmailIDStore
//
//  Synopsis:   Instantiates an object of class
//              CEmailIDStore
//
//  Arguments:  [ppStore] -- On successful return, contains pointer to
//                  newly allocated object. Free this object using
//                  ReleaseEmailIDStore.
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT
GetEmailIDStore(
    CEmailIDStore<CCatAddr> **ppStore)
{
    HRESULT hr;
    CEmailIDLdapStore<CCatAddr> *pLdapStore;

    pLdapStore = new CEmailIDLdapStore<CCatAddr>;
    if (pLdapStore != NULL) {
        hr = S_OK;
    } else {
        hr = E_OUTOFMEMORY;
    }

    *ppStore = (CEmailIDStore<CCatAddr> *) pLdapStore;

    return( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseEmailIDStore
//
//  Synopsis:   Frees up instance of CEmailIDStore allocated by
//              GetEmailIDStore
//
//  Arguments:  [pStore] -- Pointer to CEmailIDStore to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
ReleaseEmailIDStore(
    CEmailIDStore<CCatAddr> *pStore)
{
    delete (CEmailIDLdapStore<CCatAddr> *)pStore;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::Initialize
//
//  Synopsis:   Initializes a CEmailIDLdapStore object.
//
//  Arguments:  [pICatParams] -- ICategorizerParams to set default
//                  parameters (based on szLdapInfo), and to save and
//                  query for config info
//              [pISMTPServer] -- Interface to hold onto for
//                  triggering server events
//
//  Returns:    TRUE if successfully initialized, FALSE otherwise
//
//-----------------------------------------------------------------------------

template <class T> HRESULT CEmailIDLdapStore<T>::Initialize(
    ICategorizerParametersEx *pICatParams,
    ISMTPServer *pISMTPServer)
{
    TraceFunctEnterEx((LPARAM)this, "CEmailIDLdapStore<T>::Initialize");
    HRESULT hrResult;

    _ASSERT(pICatParams);

    LPSTR pszUser;
    LPSTR pszDomain;
    ULARGE_INTEGER ulCurrentTime;

    //
    // Do not try to reinitialize more than once/5 minutes
    //
    GetSystemTimeAsFileTime((LPFILETIME)&ulCurrentTime);

    if( (ulCurrentTime.QuadPart - m_ulLastInitTime.QuadPart) <
        ((LONGLONG)CAT_LDAPSTORE_MIN_INIT_INTERVAL * 10000000)) {

        DebugTrace((LPARAM)this, "Not reinitializing for 5 minutes");
        hrResult = CAT_E_INIT_FAILED;
        goto CLEANUP;
    }


    //
    // Save and addref the interface pointers
    //
    if(m_pICatParams)
        m_pICatParams->Release();
    if(m_pISMTPServer)
        m_pISMTPServer->Release();
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    m_pICatParams = pICatParams;
    m_pISMTPServer = pISMTPServer;

    // QI for ISMTPServerEx for event logging
    if (m_pISMTPServer)
    {
        hrResult = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *)&m_pISMTPServerEx);
        if (FAILED(hrResult))
        {
            ErrorTrace((LPARAM) m_pISMTPServer,
                "Unable to QI for ISMTPServerEx 0x%08X",hrResult);
    
            m_pISMTPServerEx = NULL;
            hrResult = S_OK; //Don't treat as a fatal error
        }
    }

    m_pICatParams->AddRef();

    if(m_pISMTPServer)
        m_pISMTPServer->AddRef();

    //
    // Retrieve Host, NamingContext, Account, and Password from ICategorizerParameters
    // Initialize our domain cache.
    //

    hrResult = RetrieveICatParamsInfo(
        &m_pszHost,
        &m_dwPort,
        &m_pszNamingContext,
        &pszUser,
        &pszDomain,
        &m_pszPassword,
        &m_bt);

    if(FAILED(hrResult)) {

        FatalTrace((LPARAM)this, "RetrieveICatParamsInfo failed hr %08lx", hrResult);
        hrResult = CAT_E_INVALID_ARG;
        goto CLEANUP;
    }

    //
    // Note that NamingContext is an optional configuration.
    //
    if (((pszUser) && (pszUser[0] != 0) ||
         m_bt == BIND_TYPE_NONE ||
         m_bt == BIND_TYPE_CURRENTUSER)) {

        hrResult = AccountFromUserDomain(
            m_szAccount,
            sizeof(m_szAccount),
            pszUser,
            pszDomain);

        if(FAILED(hrResult)) {

            FatalTrace((LPARAM)this, "AccountFromuserDomain failed hr %08lx", hrResult);
            goto CLEANUP;
        }
    }
    //
    // We are a new emailIdStore initializing with a possibly
    // different config, so reset the event log stuff
    //
    ResetPeriodicEventLogs();
    //
    // Create/Initialize the connection configuration manager
    //
    // Initialize the ldap configuration manager
    // Use the automatic init if we have no specified host/port
    //
    if( ((m_pszHost == NULL) || (*m_pszHost == '\0')) &&
        (m_dwPort == 0)) {

        if(m_pCLdapCfgMgr == NULL)
            m_pCLdapCfgMgr = new CLdapCfgMgr(
                TRUE,           // fAutomaticConfigUpdate
                m_pICatParams,
                m_bt,
                m_szAccount,
                m_pszPassword,
                m_pszNamingContext);

        if(m_pCLdapCfgMgr == NULL) {
            hrResult = E_OUTOFMEMORY;
            goto CLEANUP;
        }
        hrResult = m_pCLdapCfgMgr->HrInit();

    } else {
        //
        // Initialize using the one configuration specified
        //
        LDAPSERVERCONFIG ServerConfig;
        ServerConfig.dwPort = m_dwPort;
        ServerConfig.pri = 0;
        ServerConfig.bt = m_bt;
        if(m_pszHost)
            lstrcpyn(ServerConfig.szHost, m_pszHost, sizeof(ServerConfig.szHost));
        else
            ServerConfig.szHost[0] = '\0';

        if(m_pszNamingContext)
            lstrcpyn(ServerConfig.szNamingContext, m_pszNamingContext, sizeof(ServerConfig.szNamingContext));
        else
            ServerConfig.szNamingContext[0] = '\0';

        lstrcpyn(ServerConfig.szAccount, m_szAccount, sizeof(ServerConfig.szAccount));

        if(m_pszPassword)
            lstrcpyn(ServerConfig.szPassword, m_pszPassword, sizeof(ServerConfig.szPassword));
        else
            ServerConfig.szPassword[0] = '\0';

        //
        // Create CLdapCfgMgr without the automatic config update
        // option (since one host is specified)
        //
        if(m_pCLdapCfgMgr == NULL)
            m_pCLdapCfgMgr = new CLdapCfgMgr(
                FALSE,          // fAutomaticConfigUpdate
                m_pICatParams);

        if(m_pCLdapCfgMgr == NULL) {
            hrResult = E_OUTOFMEMORY;
            goto CLEANUP;
        }

        hrResult = m_pCLdapCfgMgr->HrInit(
            1,
            &ServerConfig);
    }

    if(FAILED(hrResult)) {

        FatalTrace((LPARAM)this, "CLdapCfgMgr->HrInit failed hr %08lx", hrResult);
        m_pCLdapCfgMgr->Release();
        m_pCLdapCfgMgr = NULL;
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hrResult) &&
       (hrResult != CAT_E_INIT_FAILED)) {
        //
        // Update the last init attempt time
        //
        GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastInitTime);
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hrResult);
    TraceFunctLeaveEx((LPARAM)this);
    return hrResult;
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::InitializeResolveListContext
//
//  Synopsis:   Creates a new async context for resolving a list of email ids.
//
//  Arguments:  [puserContext] -- As each name is completed, a completion
//                      routine is called with this context parameter.
//              [pResolveListContext] -- The LPRESOLVE_LIST_CONTEXT
//                      to initialize.
//
//  Returns:    S_OK if successfully allocated context
//              E_OUTOFMEMORY if out of memory.
//
//-----------------------------------------------------------------------------

template <class T> HRESULT CEmailIDLdapStore<T>::InitializeResolveListContext(
    VOID  *pUserContext,
    LPRESOLVE_LIST_CONTEXT pResolveListContext)
{
    CStoreListResolveContext *pCStoreContext = NULL;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::InitializeResolveListContext");

    pResolveListContext->pUserContext = pUserContext;

    pCStoreContext = new CStoreListResolveContext(this);
    if(pCStoreContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    hr = pCStoreContext->HrInitialize(
        m_pISMTPServer,
        m_pICatParams);

    if (FAILED(hr)) {

        if(hr == HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE)) {

            LPCSTR pszAccount = m_szAccount;

            if (m_pISMTPServerEx) {
                m_pISMTPServerEx->TriggerLogEvent(
                    CAT_EVENT_LOGON_FAILURE,    // Event ID
                    TRAN_CAT_CATEGORIZER,       // Category
                    1,
                    &pszAccount,                // rgszSubstrings,
                    EVENTLOG_ERROR_TYPE,        // wType
                    hr,
                    LOGEVENT_LEVEL_MINIMUM,     // iDebugLevel
                    m_szAccount,                // szKey
                    LOGEVENT_FLAG_PERIODIC,     // dwOptions
                    0xffffffff, NULL            // optional params
                    );
             }

        } else {

            // Use new logging interface so that
            // we can log system generic format messages
            // rgszString[1] here will be set inside LogEvent(..)
            // as it use FormatMessageA to generate it
            const char *rgszStrings[1] = { NULL };

            if (m_pISMTPServerEx) {
                m_pISMTPServerEx->TriggerLogEvent(
                    CAT_EVENT_LDAP_CONNECTION_FAILURE,              // Message ID
                    TRAN_CAT_CATEGORIZER,                           // Category
                    1,                                              // Word count of substring
                    rgszStrings,                                    // Substring
                    EVENTLOG_ERROR_TYPE,                            // Type of the message
                    hr,                                             // error code
                    LOGEVENT_LEVEL_MINIMUM,                         // Logging level
                    NULL,                                           // key to this event
                    LOGEVENT_FLAG_PERIODIC,                         // Logging option
                    0,                                              // index of format message string in rgszStrings
                    GetModuleHandle(AQ_MODULE_NAME)                 // module handle to format a message
                );
            }
        }

        goto CLEANUP;

    } else {

        ResetPeriodicEventLogs();
    }

    pResolveListContext->pStoreContext = (LPVOID) pCStoreContext;

 CLEANUP:
    if(FAILED(hr))
        if(pCStoreContext)
            delete pCStoreContext;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::FreeResolveListContext
//
//  Synopsis:   Frees async context used for resolving list of email ids.
//
//  Arguments:  [pResolveListContext] -- The context to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

template <class T> VOID CEmailIDLdapStore<T>::FreeResolveListContext(
    LPRESOLVE_LIST_CONTEXT pResolveListContext)
{
    CStoreListResolveContext *pCStoreContext;

    pCStoreContext = (CStoreListResolveContext *) pResolveListContext->pStoreContext;

    delete pCStoreContext;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::LookupEntryAsync
//
//  Synopsis:   Issues a lookup request asynchronously. The callback function
//              is called once the result is available. This function is
//              used when a group of lookups are to be issued successively,
//              for example when looking up all recipients of a mail message.
//              By doing an asynchronous lookup, an opportunity to perform
//              group-wide optimizations (like batching a sequence of lookups
//              together) is created.
//
//  Arguments:  [pCCatAddr] -- Contains email ID to lookup and
//              HrCompletion routine to be called when lookup is complete.
//              [pListContext] -- Context associated with the group of lookups
//                  of which this lookup is a part.
//
//  Returns:    S_OK if lookup was successfully queued.
//              The callback function gets passed the result of the actual
//              lookup
//
//-----------------------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::LookupEntryAsync(
    T *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext)
{
    TraceFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::LookupEntryAsync");
    HRESULT hrResult;

    CStoreListResolveContext *pCStoreContext;
    //
    // Pick up CStoreListResolveContext object from pListContext.
    // Pass it through.
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;

    hrResult = pCStoreContext->HrLookupEntryAsync(
        pCCatAddr);

    DebugTrace((LPARAM)this, "returning %08lx", hrResult);
    TraceFunctLeaveEx((LPARAM)this);
    return hrResult;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore<T>::InsertInsertionRequest
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 15:13:55: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pListContext,
        CInsertionRequest *pCRequest)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::InsertInsertionRequest");

    CStoreListResolveContext *pCStoreContext;
    //
    // Pick up CStoreListResolveContext object from pListContext.
    // Pass it through.
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;

    hr = pCStoreContext->HrInsertInsertionRequest(
        pCRequest);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CEmailIDLdapStore<T>::InsertInsertionRequest



//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::CancelResolveList
//
// Synopsis: Cancel outstanding lookups in a list resolve
//
// Arguments:
//  pResolveListContext: list context
//  hr: Optional hresult reason to pass to completion routines
//
// Returns:
//  return value of CAsyncLookupContext::CancelPendingRequests
//
// History:
// jstamerj 1998/09/29 14:51:30: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::CancelResolveList(
    LPRESOLVE_LIST_CONTEXT pResolveListContext,
    HRESULT hr)
{
    CStoreListResolveContext *pCStoreContext;
    //
    // Cancel lookups on this resolve list context (will call their
    // lookup's completion routine with error)
    //
    pCStoreContext = (CStoreListResolveContext *) pResolveListContext->pStoreContext;
    pCStoreContext->Cancel();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::CancelAllLookups
//
//  Synopsis:   Cancels all async lookups that are pending
//
//  Arguments:  NONE
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

template <class T> VOID CEmailIDLdapStore<T>::CancelAllLookups()
{
    if(m_pCLdapCfgMgr)
        m_pCLdapCfgMgr->CancelAllConnectionSearches(
            m_pISMTPServer);
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::AsyncLookupCompletion
//
//  Synopsis:   Completion routine for
//
//  Arguments:  pCCatAddr: the address lookup being completed
//              lpContext: context passed to LdapConn
//
//  Returns:    NOTHING
//
//
//-----------------------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncLookupCompletion(
    CCatAddr *pCCatAddr,
    LPVOID lpContext)
{
    TraceFunctEnter("CEmailIDLdapStore::AsyncLookupCompletion");

    _ASSERT(pCCatAddr);
    pCCatAddr->LookupCompletion();

    pCCatAddr->Release(); // Release reference count addref'd in LookupEntryAsync

    TraceFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::HrExpandPagedDlMembers
//
// Synopsis: Start issueing async queries to retrieve all the DL members
//
// Arguments:
//  pCCatAddr: The DL item to be expanded
//  pListContext: List context initialized in
//                InitializeResolveListContext
//  CAType: The type of address of the DL members
//  pfnCompletion: Completion that will be called after returning
//                 MAILTRANSPORT_S_PENDING
//  pContext: Paramter passed to the completion routine
//
// Returns:
//  S_OK: Success, this is not a paged DL
//  MAILTRANSPORT_S_PENDING: Will call pfnCompletion with context when
//                           finished expanding the DL
//  E_OUTOFMEMORY
//  CAT_E_DBCONNECTION: palc->GetConnection returned NULL (meaning it
//                      is having problems obtaining/maintaing a connection)
//  error from HrExpandDlPage
//
// History:
// jstamerj 1998/09/23 15:57:37: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandPagedDlMembers(
    CCatAddr *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext,
    CAT_ADDRESS_TYPE CAType,
    PFN_DLEXPANSIONCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    PMEMBERRESOLVECONTEXT pMemCtx = NULL;
    CStoreListResolveContext *pCStoreContext;
    CBatchLdapConnection *pConn = NULL;

    TraceFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandPagedDlMembers");

    //
    // Use the same CLdapConnection that the rest of the list is using
    // -- this way the same thread will be servicing all the list
    // resolve requests and we don't have to worry about thread unsafe
    // problems in CAsyncLookupContext
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;
    pConn = pCStoreContext->GetConnection();
    if(pConn == NULL) {
        ErrorTrace((LPARAM)this, "Failed to get a connection to resolve paged DL");
        hr = CAT_E_DBCONNECTION;
        goto CLEANUP;
    }

    //
    // Get the attributes interface
    //
    hr = pCCatAddr->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        ErrorTrace((LPARAM)this, "Failed to get ICatItemAttr in HrExpandPagedDlMembers");
        goto CLEANUP;
    }

    //
    // Allocate/initialize a member resolution context and
    // kick things off
    //
    pMemCtx = new MEMBERRESOLVECONTEXT;
    if(pMemCtx == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //
    // First, get an ldapconn on which to issue searches
    //
    pMemCtx->pConn = pConn;

    //
    // AddRef here, release when we're done
    //
    pCCatAddr->AddRef();

    pMemCtx->pStore = this;
    pMemCtx->pCCatAddr = pCCatAddr;
    pMemCtx->CAType = CAType;
    pMemCtx->dwNextBlockIndex = 0;
    pMemCtx->pICatItemAttr = NULL;
    pMemCtx->hrResolveStatus = S_OK;
    pMemCtx->pfnCompletion = pfnCompletion;
    pMemCtx->pCompletionContext = pContext;

    hr = HrExpandDlPage(pMemCtx, pICatItemAttr);

 CLEANUP:
    if(hr != MAILTRANSPORT_S_PENDING) {

        if(pMemCtx) {
            if(pConn)
                pConn->Release();
            if(pMemCtx->pCCatAddr)
                pMemCtx->pCCatAddr->Release();
            delete pMemCtx;
        }
    }

    if(pICatItemAttr)
        pICatItemAttr->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIdLdapStore::HrExpandDlPage
//
// Synopsis: Expand one block of DL members
//
// Arguments:
//  pMemCtx: one (initialized) member resolve context
//  pICatItemAttr: The ICatItemAttributes to get the members from
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: Issued another search
//
// History:
// jstamerj 1998/09/23 17:02:05: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandDlPage(
    PMEMBERRESOLVECONTEXT pMemCtx,
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr;
    LPSTR pszMembersAttribute;
    LPSTR pszAttributeName;
    DWORD dwMembersAttributeLength;
    BOOL fEnumerating = FALSE;
    ATTRIBUTE_ENUMERATOR enumerator;

    TraceFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandDlPage");

    hr = m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
        &pszMembersAttribute);

    if(FAILED(hr))
        goto CLEANUP;

    dwMembersAttributeLength = lstrlen(pszMembersAttribute);

    //
    // Is the members attribute being paged at all?
    //
    hr = pICatItemAttr->BeginAttributeNameEnumeration(&enumerator);
    if(FAILED(hr))
        goto CLEANUP;

    fEnumerating = TRUE;

    hr = pICatItemAttr->GetNextAttributeName(
        &enumerator,
        &pszAttributeName);

    while(SUCCEEDED(hr)) {
        //
        // We'll know it's paged DL when we see an attribue named
        // "member;range=0-high"
        //
        if( (_strnicmp(pszAttributeName,
                       pszMembersAttribute,
                       dwMembersAttributeLength) == 0) &&
            (_strnicmp(pszAttributeName + dwMembersAttributeLength,
                       SZ_PAGEDMEMBERS_INDICATOR,
                       sizeof(SZ_PAGEDMEMBERS_INDICATOR) -1 ) == 0)) {
            //
            // Parse out the range numbers
            //
            CHAR  szTempBuffer[MAX_PAGEDMEMBERS_DIGITS+1];
            LPSTR pszSrc, pszDest;
            DWORD dwLow, dwHigh;

            pszSrc = pszAttributeName +
                     dwMembersAttributeLength +
                     sizeof(SZ_PAGEDMEMBERS_INDICATOR) - 1;

            pszDest = szTempBuffer;

            while((*pszSrc != '-') && (*pszSrc != '\0') &&
                  (pszDest - szTempBuffer) < (sizeof(szTempBuffer) - 1)) {
                //
                // Copy the digits into the temporary buffer
                //
                *pszDest = *pszSrc;
                pszSrc++;
                pszDest++;
            }

            if(*pszSrc != '-') {
                //
                // Error parsing this thing (no hyphen?)
                //
                ErrorTrace((LPARAM)this, "Error parsing LDAP attribute \"%s\"",
                           pszAttributeName);
                hr = E_INVALIDARG;
                goto CLEANUP;
            }
            //
            // Null terminate the temporary buffer
            //
            *pszDest = '\0';
            //
            // Convert to a dword
            //
            dwLow = atol(szTempBuffer);

            //
            // Is this the range we're looking for?
            //
            if(dwLow == pMemCtx->dwNextBlockIndex) {
                //
                // Copy the high number into the buffer
                //
                pszDest = szTempBuffer;
                pszSrc++; // Past -

                while((*pszSrc != '\0') &&
                      (pszDest - szTempBuffer) < (sizeof(szTempBuffer) - 1)) {

                    *pszDest = *pszSrc;
                    pszSrc++;
                    pszDest++;
                }
                *pszDest = '\0';

                if(szTempBuffer[0] == '*') {

                    dwHigh = 0; // we're done expanding

                } else {

                    dwHigh = atol(szTempBuffer);
                }

                hr = pMemCtx->pCCatAddr->HrExpandAttribute(
                    pICatItemAttr,
                    pMemCtx->CAType,
                    pszAttributeName,
                    NULL);

                if(SUCCEEDED(hr) && dwHigh > 0) {

                    pMemCtx->dwNextBlockIndex = dwHigh + 1;

                    hr = HrExpandNextDlPage( pMemCtx );
                }
                //
                // The job of this function is done
                //
                goto CLEANUP;
            }
        }
        hr = pICatItemAttr->GetNextAttributeName(
            &enumerator,
            &pszAttributeName);
    }
    //
    // If we did not find any members;range= attribute, assume there
    // are no more members
    //
    hr = S_OK;

 CLEANUP:
    if(fEnumerating)
        pICatItemAttr->EndAttributeNameEnumeration(&enumerator);

    return hr;
}

//+------------------------------------------------------------
//
// Function: CEmailIdLdapStore::HrExpandNextDlPage
//
// Synopsis: Issue an LDAP search to fetch the next block of members
//
// Arguments:
//  pMemCtx: The initialized MEMBERRESOLVECONTEXT
//
// Returns:
//  MAILTRANSPORT_S_PENDING: Issued the search
//  E_INVALIDARG: One of the parameters was too large to fit in the
//                  fixed size attribute buffer
//  or error from LdapConn
//
// History:
// jstamerj 1998/09/23 18:01:51: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandNextDlPage(
    PMEMBERRESOLVECONTEXT pMemCtx)
{
    HRESULT hr;
    CMembershipPageInsertionRequest *pCInsertion = NULL;

    TraceFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandNextDlPage");

    _ASSERT(pMemCtx);
    _ASSERT(pMemCtx->pCCatAddr);

    pCInsertion = new CMembershipPageInsertionRequest(
        pMemCtx);

    if(pCInsertion == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    hr = pMemCtx->pConn->HrInsertInsertionRequest(
        pCInsertion);

    //
    // If AsyncSearch succeeded, it is always pending
    //
    hr = MAILTRANSPORT_S_PENDING;

 CLEANUP:
    if(pCInsertion)
        pCInsertion->Release();

    DebugTrace((LPARAM)this, "HrExpandDlPage returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::AsyncExpandDlCompletion
//
// Synopsis: Handle completion of an async lookup for DL members
//
// Arguments:
//  ctx: pMemCtx passed to AsyncSearch
//  dwNumResults: Number of objects matching search filter
//  rgpICatItemAttrs: Array of ICatItemAttributes
//  hr: Resolution status
//  fFinalCompletion: Indicates wether this is a partial completion or
//                    the last completion call
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/24 09:28:18: Created.
//
//-------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncExpandDlCompletion(
    LPVOID ctx,
    DWORD  dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hrResolveStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr = S_OK;
    PMEMBERRESOLVECONTEXT pMemCtx = NULL;
    CBatchLdapConnection *pConn = NULL;

    TraceFunctEnter("CEmailIDLdapStore::AsyncExpandDlCompleton");

    pMemCtx = (PMEMBERRESOLVECONTEXT) ctx;
    _ASSERT(pMemCtx);

    pConn = pMemCtx->pConn;
    pConn->AddRef();

    //
    // Get/Release insertion context so that inserted queries will be batched
    //
    pConn->GetInsertionContext();

    //
    // If we had a previous failure for this resolution, do nothing
    //
    if(FAILED(pMemCtx->hrResolveStatus)) {

        hr = pMemCtx->hrResolveStatus;
        goto CLEANUP;
    }

    if(FAILED(hrResolveStatus)) {
        //
        // Handle failures in the cleanup code
        //
        hr = hrResolveStatus;
        goto CLEANUP;
    }

    //
    // If we haven't yet found our search result, look for it
    //
    if(pMemCtx->pICatItemAttr == NULL) {
        //
        // Which result is ours?
        //  We need to find the result that matches the
        //  distinguishingattribute/value.  We do not need to worry
        //  about multiple matches (the first search and match in
        //  asyncctx would have caught that)
        //
        LPSTR pszDistinguishingAttribute;
        LPSTR pszDistinguishingAttributeValue;
        DWORD dwCount;
        BOOL  fFound;
        ICategorizerItemAttributes *pICatItemAttr;

        hr = pMemCtx->pCCatAddr->GetStringAPtr(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
            &pszDistinguishingAttribute);

        if(FAILED(hr))
            goto CLEANUP;

        hr = pMemCtx->pCCatAddr->GetStringAPtr(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
            &pszDistinguishingAttributeValue);

        if(FAILED(hr))
            goto CLEANUP;
        //
        // Find the result matching the search request
        //
        for(fFound = FALSE, dwCount = 0;
            (fFound == FALSE) && (dwCount < dwNumResults);
            dwCount++) {

            ATTRIBUTE_ENUMERATOR enumerator;
            LPSTR pszObjectAttributeValue;
            pICatItemAttr = rgpICatItemAttrs[dwCount];

            hr = pICatItemAttr->BeginAttributeEnumeration(
                pszDistinguishingAttribute,
                &enumerator);

            if(SUCCEEDED(hr)) {

                hr = pICatItemAttr->GetNextAttributeValue(
                    &enumerator,
                    &pszObjectAttributeValue);

                while(SUCCEEDED(hr) && (fFound == FALSE)) {
                    if(lstrcmpi(
                        pszObjectAttributeValue,
                        pszDistinguishingAttributeValue) == 0) {

                        fFound = TRUE;
                    }

                    hr = pICatItemAttr->GetNextAttributeValue(
                        &enumerator,
                        &pszObjectAttributeValue);
                }
                hr = pICatItemAttr->EndAttributeEnumeration(
                    &enumerator);
            }
        }

        if(fFound) {
            //
            // Save the found result
            //
            pMemCtx->pICatItemAttr = pICatItemAttr;
            pMemCtx->pICatItemAttr->AddRef();
        }
    }
    //
    // Only process the members when this search is done
    //
    if(fFinalCompletion) {

        ICategorizerItemAttributes *pICatItemAttr;

        pICatItemAttr = pMemCtx->pICatItemAttr;

        if(pICatItemAttr == NULL) {

            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto CLEANUP;
        }
        //
        // Null the ICatItemAttr pointer in the context and reset
        // hrResolutionStatus before starting a new search
        //
        pMemCtx->pICatItemAttr = NULL;
        pMemCtx->hrResolveStatus = S_OK;

        //
        // Process the new members
        //
        hr = pMemCtx->pStore->HrExpandDlPage(
            pMemCtx,
            pICatItemAttr);
        //
        // If this returns MAILTRANSPORT_S_PENDING, then this
        // completion routine will be called to free pMemCtx.
        // Therefore, we can NOT use pMemCtx below here when hr ==
        // MAILTRANSPORT_S_PENDING!
        //

        //
        // Release the Attributes interface (it was Addref'd when put into pMemCtx)
        //
        pICatItemAttr->Release();

        if(FAILED(hr))
            goto CLEANUP;
    }

 CLEANUP:
    //
    // Decrement the pending lookup added from
    // CMembershipPageInsertionRequest::HrInsertSearches
    //
    if(fFinalCompletion)
        pConn->DecrementPendingSearches(1);

    if(FAILED(hr)) {
        //
        // Save the error
        //
        pMemCtx->hrResolveStatus = hr;

    }
    if((fFinalCompletion) && (hr != MAILTRANSPORT_S_PENDING)) {
        //
        // THe final completion routine of the final search, so clean up
        //

        //
        // Call the sink completion routine
        //
        pMemCtx->pfnCompletion(
            pMemCtx->hrResolveStatus,
            pMemCtx->pCompletionContext);

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pMemCtx->pConn->ReleaseInsertionContext();

        //
        // First release the connection
        //
        pMemCtx->pConn->Release();

        //
        // Release the CCatAddr object
        //
        pMemCtx->pCCatAddr->Release();

        //
        // Free the context that has served us thus far
        //
        if(pMemCtx->pICatItemAttr)
            pMemCtx->pICatItemAttr->Release();
        delete pMemCtx;

    } else {
        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pConn->ReleaseInsertionContext();
    }
    if(pConn)
        pConn->Release();
}

//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::HrExpandDynamicDlMembers
//
// Synopsis: Handle the expansion of a dynamicDL
//
// Arguments:
//  pCCatAddr: The item to expand
//  pListContext: List context initialized in
//                InitializeResolveListContext
//  pfnCompletion: A function to call upon async completion
//  pContext: Context to pass to the completion function
//
// Returns:
//  S_OK: Success, completed synchronously
//  MAILTRANSPORT_S_PENDING: Will complete async calling pfnCompletion
//  E_OUTOFMEMORY
//  CAT_E_DBCONNECTION: palc->GetConnection returned NULL (meaning it
//                      is having problems obtaining/maintaing a connection)
//
// History:
// jstamerj 1998/09/24 14:19:43: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandDynamicDlMembers(
    CCatAddr *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext,
    PFN_DLEXPANSIONCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    LPSTR pszFilterAttribute, pszFilter;
    LPSTR pszBaseDNAttribute, pszBaseDN;
    PMEMBERRESOLVECONTEXT pMemCtx = NULL;
    BOOL fEnumeratingFilter = FALSE;
    BOOL fEnumeratingBaseDN = FALSE;
    ATTRIBUTE_ENUMERATOR enumerator_filter;
    ATTRIBUTE_ENUMERATOR enumerator_basedn;
    LPWSTR *rgpszAllAttributes;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    CStoreListResolveContext *pCStoreContext;
    CBatchLdapConnection *pConn = NULL;
    ICategorizerParametersEx *pIPhatParams = NULL;
    ICategorizerRequestedAttributes *pIRequestedAttributes = NULL;

    TraceFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandDynamicDlMembers");

    //
    // Use the same CLdapConnection that the rest of the list is using
    // -- this way the same thread will be servicing all the list
    // resolve requests and we don't have to worry about thread unsafe
    // problems in CAsyncLookupContext
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;
    pConn = pCStoreContext->GetConnection();

    if(pConn == NULL) {

        ErrorTrace((LPARAM)this, "Unable to get a connection to resolve dynamic DL members");
        hr = CAT_E_DBCONNECTION;
        goto CLEANUP;
    }

    //
    // Get the attributes interface
    //
    hr = pCCatAddr->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        ErrorTrace((LPARAM)this, "Failed to get ICatItemAttr in HrExpandPagedDlMembers");
        goto CLEANUP;
    }


    hr = m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_DYNAMICFILTER,
        &pszFilterAttribute);

    if(FAILED(hr)) {
        //
        // Dynamic DLs simply aren't supported in this case
        //
        hr = S_OK;
        goto CLEANUP;
    }

    hr = m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_DYNAMICBASEDN,
        &pszBaseDNAttribute);

    if(FAILED(hr)) {
        //
        // Use the default baseDN
        //
        pszBaseDNAttribute = NULL;
        pszBaseDN = NULL;
    }

    //
    // Find the query filter string
    //
    hr = pICatItemAttr->BeginAttributeEnumeration(
        pszFilterAttribute,
        &enumerator_filter);

    if(SUCCEEDED(hr)) {

        fEnumeratingFilter = TRUE;

        hr = pICatItemAttr->GetNextAttributeValue(
            &enumerator_filter,
            &pszFilter);
    }

    if(FAILED(hr)) {
        //
        // No such attribute?  No members.
        //
        hr = S_OK;
        goto CLEANUP;
    }
    //
    // Find the base DN
    //
    if(pszBaseDNAttribute) {

        hr = pICatItemAttr->BeginAttributeEnumeration(
            pszBaseDNAttribute,
            &enumerator_basedn);

        if(SUCCEEDED(hr)) {

            fEnumeratingBaseDN = TRUE;

            hr = pICatItemAttr->GetNextAttributeValue(
                &enumerator_basedn,
                &pszBaseDN);

        }
        if(FAILED(hr)) {
            //
            // Use the default base DN
            //
            pszBaseDN = NULL;
        }
    }
    hr = m_pICatParams->QueryInterface(
        IID_ICategorizerParametersEx,
        (LPVOID *)&pIPhatParams);

    if(FAILED(hr)) {

        pIPhatParams = NULL;
        goto CLEANUP;
    }


    //
    // Fetch all the requested attributes
    //
    hr = pIPhatParams->GetRequestedAttributes(
        &pIRequestedAttributes);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRequestedAttributes->GetAllAttributesW(
        &rgpszAllAttributes);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Allocate/initialize a member resolution context and
    // kick things off
    //
    pMemCtx = new MEMBERRESOLVECONTEXT;

    if(pMemCtx == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //
    // First, get an ldapconn on which to issue searches
    //
    pMemCtx->pConn = pConn;

    //
    // AddRef here, release when we're done
    //
    pCCatAddr->AddRef();

    pMemCtx->pStore = this;
    pMemCtx->pCCatAddr = pCCatAddr;
    pMemCtx->pfnCompletion = pfnCompletion;
    pMemCtx->pCompletionContext = pContext;
    pMemCtx->fFinalCompletion = FALSE;
    pMemCtx->hrResolveStatus = S_OK;

    //
    // Now issue the search for the dynamic DL members
    //
    hr = pMemCtx->pConn->AsyncSearch(
        (LPCSTR) (pszBaseDN ? pszBaseDN : pMemCtx->pConn->GetNamingContext()),
        LDAP_SCOPE_SUBTREE,
        pszFilter,
        (LPCWSTR *)rgpszAllAttributes,
        CAT_DEFAULT_DYNAMICDL_PAGE_SIZE,
        AsyncDynamicDlCompletion,
        pMemCtx);

    if(SUCCEEDED(hr)) {
        //
        // The search is async, so return pending
        //
        hr = MAILTRANSPORT_S_PENDING;
    }

 CLEANUP:
    if(hr != MAILTRANSPORT_S_PENDING) {
        //
        // Cleanup because no completion routine will be doing so
        //
        if(fEnumeratingFilter) {

            pICatItemAttr->EndAttributeEnumeration(
                &enumerator_filter);
        }
        if(fEnumeratingBaseDN) {

            pICatItemAttr->EndAttributeEnumeration(
                &enumerator_basedn);
        }

        if(pConn) {
            pConn->Release();
        }
        if((pMemCtx) && (pMemCtx->pCCatAddr))
            pCCatAddr->Release();

        if(pMemCtx)
            delete pMemCtx;
    }

    if(pICatItemAttr)
        pICatItemAttr->Release();

    if(pIRequestedAttributes)
        pIRequestedAttributes->Release();

    if(pIPhatParams)
        pIPhatParams->Release();

    DebugTrace((LPARAM)this, "HrExpandDynamicDl returning hr %08lx", hr);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::AsyncDynamicDlCompletion
//
// Synopsis: Handle completion of an async lookup for DL members
//
// Arguments:
//  ctx: pMemCtx passed to AsyncSearch
//  dwNumResults: Number of objects matching search filter
//  rgpICatItemAttrs: Array of ICatItemAttributes
//  hr: Resolution status
//  fFinalCompletion: Indicates wether this is a partial result or not
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/24 09:28:18: Created.
//
//-------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncDynamicDlCompletion(
    LPVOID ctx,
    DWORD  dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hrResolveStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr;
    PMEMBERRESOLVECONTEXT pMemCtx;
    DWORD dwCount;
    LPSTR pszDistinguishedNameAttr;

    TraceFunctEnter("CEmailIDLdapStore::AsyncDynamicDlCompleton");

    pMemCtx = (PMEMBERRESOLVECONTEXT) ctx;
    _ASSERT(pMemCtx);
    pMemCtx->fFinalCompletion = fFinalCompletion;

    //
    // Get/Release insertion context so that inserted queries will be batched
    //
    pMemCtx->pConn->GetInsertionContext();

    if(FAILED(hrResolveStatus)) {
        //
        // Handle failures in the cleanup code
        //
        hr = hrResolveStatus;
        goto CLEANUP;
    }

    hr = pMemCtx->pStore->m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
        &pszDistinguishedNameAttr);

    if(FAILED(hr))
        goto CLEANUP;

    for(dwCount = 0; dwCount < dwNumResults; dwCount++) {
        //
        // Loop through each ICatItemAttr; each one is a DL member.
        // Add it as a dynamic DL member
        //
        hr = pMemCtx->pCCatAddr->AddDynamicDLMember(
            rgpICatItemAttrs[dwCount]);

        _ASSERT(hr != MAILTRANSPORT_S_PENDING);

        if(FAILED(hr))
            goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr))
        pMemCtx->hrResolveStatus = hr;

    if(pMemCtx->fFinalCompletion) {
        //
        // Call the sink completion routine
        //
        pMemCtx->pfnCompletion(
            pMemCtx->hrResolveStatus,
            pMemCtx->pCompletionContext);

        //
        // First release the connection
        //
        pMemCtx->pConn->Release();

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pMemCtx->pConn->ReleaseInsertionContext();

        //
        // Release CCatAddr
        //
        pMemCtx->pCCatAddr->Release();

        //
        // Free the context that has served us thus far
        //
        delete pMemCtx;

    } else {

        //
        // There are no more async completions pending, BUT the
        // emailidldapstore has more members to tell us about
        //

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pMemCtx->pConn->ReleaseInsertionContext();
    }
}





//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::RetrieveICatParamsInfo
//
//  Synopsis:   Helper routine to retrieve the info we need from
//              ICategorizerParams.  Pointers to strings in ICatParams
//              are retrieved; the strings themselves are not copied.
//              Since ICatParams is read only at this point, the
//              strings will be good as long as we have a reference to
//              ICatParams.
//
//  Arguments:  [pszHost] -- The Host parameter is returned here
//              [pdwPort] -- The remote tcp Port# is returned here
//                        (*pdwPort is set to zero if the DSPARAMTER wasn't set)
//
//              [pszNamingContext] -- The NamingContext parameter is returned
//                  here.
//              [pszAccount] -- The LDAP account parameter is returned here.
//              [pszPassword] -- The LDAP password parameter is returned here.
//              [pbt] -- The bind type to use to connect to ldap hosts.
//
//  Returns:    S_OK always -- parameters that couldn't be retrieved
//              will be set to NULL (or simple bind for bind type)
//
//-----------------------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::RetrieveICatParamsInfo(
    LPSTR *ppszHost,
    DWORD *pdwPort,
    LPSTR *ppszNamingContext,
    LPSTR *ppszAccount,
    LPSTR *ppszDomain,
    LPSTR *ppszPassword,
    LDAP_BIND_TYPE *pbt)
{
    TraceFunctEnter("CEmailIDLdapStore::RetrieveICatParamsInfo");

    LPSTR pszBindType = NULL;
    LPSTR pszPort = NULL;

    *ppszHost = NULL;
    *pdwPort = 0;
    *ppszNamingContext = NULL;
    *ppszAccount = NULL;
    *ppszDomain = NULL;
    *ppszPassword = NULL;
    *pbt = BIND_TYPE_SIMPLE;

    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPHOST,
        ppszHost);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPNAMINGCONTEXT,
        ppszNamingContext);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPACCOUNT,
        ppszAccount);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPDOMAIN,
        ppszDomain);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPPASSWORD,
        ppszPassword);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPPORT,
        &pszPort);

    if(pszPort) {
        //
        // Convert from a string to a dword
        //
        *pdwPort = atol(pszPort);
    }


    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPBINDTYPE,
        &pszBindType);

    if(pszBindType) {
        if (lstrcmpi(pszBindType, "None") == 0) {
            *pbt = BIND_TYPE_NONE;
        }
        else if(lstrcmpi(pszBindType, "CurrentUser") == 0) {
            *pbt = BIND_TYPE_CURRENTUSER;
        }
        else if (lstrcmpi(pszBindType, "Simple") == 0) {
            *pbt = BIND_TYPE_SIMPLE;
        }
        else if (lstrcmpi(pszBindType, "Generic") == 0) {
            *pbt = BIND_TYPE_GENERIC;
        }
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: AccountFromUserDomain
//
// Synopsis: Helper function.  Given a username and netbios domain
//           name, form the account name to use.
//
// Arguments:
//  pszAccount: Buffer to fill in
//  dwccAccount: Size of that buffer
//  pszUser: Username.  If NULL, pszAccount will be set to ""
//  pszDomain: Domainname.  If NULL, pszUser will be copied to pszAccount
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): dwccAccount is not
//  sufficiently large
//
// History:
// jstamerj 1998/06/25 12:06:02: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::AccountFromUserDomain(
    LPTSTR pszAccount,
    DWORD  dwccAccount,
    LPTSTR pszUser,
    LPTSTR pszDomain)
{
    TraceFunctEnterEx((LPARAM)this,"CEmailIDLdapStore::AccountFromUserDomainSchema");
    _ASSERT(pszAccount != NULL);
    _ASSERT(dwccAccount >= 1);

    pszAccount[0] = '\0';

    if(pszUser) {
        if((pszDomain == NULL) || (pszDomain[0] == '\0')) {
            //
            // If Domain is NULL, just copy user to account
            //
            if((DWORD)lstrlen(pszUser) >= dwccAccount) {
                return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            lstrcpy(pszAccount, pszUser);

        } else {
            if((DWORD)lstrlen(pszUser) + (DWORD)lstrlen(pszAccount) + 1 >=
               dwccAccount) {
                return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            lstrcpy(pszAccount, pszDomain);
            lstrcat(pszAccount, "\\");
            lstrcat(pszAccount, pszUser);
        }
    }
    DebugTrace(NULL, "Returning pszAccount = \"%s\"", pszAccount);
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CMembershipPageInsertionRequest::HrInsertSearches
//
// Synopsis: Insert the search for the next page of members
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//  *pdwcSearches: Number of searches we inserted
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/26 11:58:26: Created.
//
//-------------------------------------------------------------
HRESULT CMembershipPageInsertionRequest::HrInsertSearches(
    DWORD dwcSearches,
    DWORD *pdwcSearches)
{
    HRESULT hr = S_OK;
    LPSTR pszSearchFilter;
    LPWSTR pszMemberAttr;
    LPSTR pszDistinguishingAttribute;
    LPWSTR pwszDistinguishingAttribute;
    LPCWSTR rgpszAttributes[3];
    int i;

    WCHAR szMemberAttribute[MAX_MEMBER_ATTRIBUTE_SIZE +
                            (sizeof(WSZ_PAGEDMEMBERS_INDICATOR)/sizeof(WCHAR)) +
                            MAX_PAGEDMEMBERS_DIGITS +
                            sizeof("-*")];

    *pdwcSearches = 0;

    TraceFunctEnterEx((LPARAM)this, "CMembershipPageInsertionRequest::HrInsertSearches");

    _ASSERT(m_pMemCtx);
    _ASSERT(m_pMemCtx->pCCatAddr);

    if((dwcSearches == 0) ||
       (m_fInsertedRequest == TRUE))
        goto CLEANUP;

    //
    // Now we will either insert the request or call our completion
    // with a failure
    //
    m_fInsertedRequest = TRUE;
    //
    // Use the original search filter that found this object in the
    // first place
    //
    hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        &pszSearchFilter);

    if(FAILED(hr)) {
        //
        // It is possible that we have an item where BuildQuery was
        // never triggered (in the case of a 1000+ member DL that is a
        // member of a dynamic DL).  For this case, TriggerBuildQuery
        // and try to retrieve a query string again
        //
        DebugTrace((LPARAM)this, "No query string found on a paged DL; triggering buildquery");
        hr = m_pMemCtx->pCCatAddr->HrTriggerBuildQuery();

        if(SUCCEEDED(hr)) {
            //
            // Try to get the query string again
            //
            hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
                ICATEGORIZERITEM_LDAPQUERYSTRING,
                &pszSearchFilter);
        }

        if(FAILED(hr))
            goto CLEANUP;
    }

    hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
        &pszDistinguishingAttribute);

    if(FAILED(hr))
        goto CLEANUP;
    //
    // Convert distinguishing attribute to unicode
    //
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszDistinguishingAttribute,
        -1,
        NULL,
        0);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }
    pwszDistinguishingAttribute = (LPWSTR) alloca(i * sizeof(WCHAR));
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszDistinguishingAttribute,
        -1,
        pwszDistinguishingAttribute,
        i);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }

    hr = m_pMemCtx->pStore->m_pICatParams->GetDSParameterW(
        DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
        &pszMemberAttr);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Form the member attribute name we want
    //
    if( _snwprintf(szMemberAttribute,
                   sizeof(szMemberAttribute)/sizeof(WCHAR),
                   L"%s" WSZ_PAGEDMEMBERS_INDICATOR L"%d-*",
                   pszMemberAttr,
                   m_pMemCtx->dwNextBlockIndex) < 0) {
        //
        // There was insufficient space in the buffer
        //
        ErrorTrace((LPARAM)this, "Insufficient space to form paged member attribute name");
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    //
    // Form the attribute array
    //
    rgpszAttributes[0] = szMemberAttribute;
    rgpszAttributes[1] = pwszDistinguishingAttribute;
    rgpszAttributes[2] = NULL;

    //
    // Increment here, decrement in AsyncExpandDlCompletion
    //
    m_pMemCtx->pConn->IncrementPendingSearches();

    hr = m_pMemCtx->pConn->AsyncSearch(
        m_pMemCtx->pConn->GetNamingContextW(),
        LDAP_SCOPE_SUBTREE,
        pszSearchFilter,
        rgpszAttributes,
        0, // Not a paged search (as in dynamic DLs)
        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion,
        m_pMemCtx);

    if(FAILED(hr)) {
        m_pMemCtx->pConn->DecrementPendingSearches(1);
        goto CLEANUP;
    }
    *pdwcSearches = 1;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Call completion now instead of later when we are dequeued
        //
        _ASSERT(m_fInsertedRequest);
        //
        // AsyncExpandDlCompletion will always decrement the pending searches
        //
        m_pMemCtx->pConn->IncrementPendingSearches();

        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion(
            m_pMemCtx,      // ctx
            0,              // dwNumResults
            NULL,           // rgpICatItemAttrs
            hr,             // hrResolveStatus
            TRUE);          // fFinalCompletion
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CMembershipPageInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CMembershipPageInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that this insertion request is being dequeued
//
// Arguments:
//  hr: Reason why we are dequeueing
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/03 17:15:17: Created.
//
//-------------------------------------------------------------
VOID CMembershipPageInsertionRequest::NotifyDeQueue(
    HRESULT hr)
{
    TraceFunctEnterEx((LPARAM)this, "CMembershipPageInsertionRequest::NotifyDeQueue");
    //
    // If our request is being dequeue'd and we have not inserted our
    // request to ldapconn, then we are being cancelled
    // Notify our master of this
    //
    if(!m_fInsertedRequest) {
        //
        // AsyncExpandDlCompletion will always decrement the pending searches
        //
        m_pMemCtx->pConn->IncrementPendingSearches();

        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion(
            m_pMemCtx,      // ctx
            0,              // dwNumResults
            NULL,           // rgpICatItemAttrs
            hr,             // hrResolveStatus
            TRUE);          // fFinalCompletion
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CMembershipPageInsertionRequest::NotifyDeQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapdl.cpp ===
//
// ldapdl.cpp -- This file contains implementations for
//      CLdapDistList
//
// Created:
//      May 5, 1997   -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "ldapdl.h"

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::CLdapDistList
//
//  Synopsis:   Constructor for a LDAP server based distribution list store.
//
//  Arguments:  [szName] -- For LDAP, this points to an array of member names
//              [pParameter] -- Not used
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapDistList::CLdapDistList(
    LPSTR szName,
    LPVOID pParameter)
{
    m_rgszMembers = (LPSTR *) szName;

    m_nNextMember = 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::~CLdapDistList
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapDistList::~CLdapDistList()
{
    if (m_rgszMembers != NULL)
        ldap_value_free( m_rgszMembers );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::InsertMember
//
//  Synopsis:   Adds a new member to the distribution list.
//
//  Arguments:  [szEmailID] -- Email ID of the new member
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::InsertMember(
    LPSTR szEmailID)
{
    SetLastError(CAT_E_TRANX_FAILED);

    return( FALSE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::DeleteMember
//
//  Synopsis:   Removes the specified member from the distribution list
//
//  Arguments:  [szEmailID] -- Email ID to remove
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::DeleteMember(
    LPSTR szEmailID)
{
    SetLastError(CAT_E_TRANX_FAILED);

    return( FALSE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::Compact
//
//  Synopsis:   Compacts the DL store - nothing to do for LDAP.
//
//  Arguments:  None
//
//  Returns:    TRUE always
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::Compact()
{
    return( TRUE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::GetFirstMember()
//
//  Synopsis:   Returns the first member of the distribution list
//
//  Arguments:  [szEmailID] -- Buffer to copy email ID of member to.
//
//  Returns:    TRUE if success, FALSE if there are no members
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::GetFirstMember(
    LPSTR szEmailID)
{
    if (m_rgszMembers != NULL && m_rgszMembers[0] != NULL) {
        lstrcpy(szEmailID, m_rgszMembers[0]);
        m_nNextMember = 1;
        return(TRUE);
    } else {
        SetLastError(ERROR_NO_MORE_ITEMS);
        return(FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::GetNextMember
//
//  Synopsis:   Returns the next member in sequence of the distribution list.
//              This must be preceeded with a call to GetFirstMember or
//              GetNextMember.
//
//  Arguments:  [szEmailID] -- Buffer to copy email ID of member to.
//
//  Returns:    TRUE if success, FALSE if at end of list
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::GetNextMember(
    LPSTR szEmailID)
{
    _ASSERT(m_rgszMembers != NULL);
    _ASSERT(m_nNextMember > 0);

    if (m_rgszMembers[m_nNextMember] != NULL) {
        lstrcpy(szEmailID, m_rgszMembers[m_nNextMember]);
        m_nNextMember++;
        return(TRUE);
    } else {
        SetLastError(ERROR_NO_MORE_ITEMS);
        return( FALSE );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::Sort()
//
//  Synopsis:   Sorts the members of the distribution list.
//
//  Arguments:  None
//
//  Returns:    TRUE always
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::Sort()
{
    return( TRUE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapDistList::DeleteDL()
//
//  Synopsis:   Deletes the distribution list from the LDAP store
//
//  Arguments:  None
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOL CLdapDistList::DeleteDL()
{
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <precomp.h>

#include "precomp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapstor.h ===
//
// ldapstor.h -- This file contains the class definitions for:
//  CEmailIDLdapStore
//
// Created:
//   Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef __LDAPSTOR_H__
#define __LDAPSTOR_H__

#include <transmem.h>
#include "idstore.h"
#include "ldapconn.h"
#include "phatqmsg.h"
#include "ccataddr.h"
#include "smtpevent.h"
#include "schema.h"
#include "catglobals.h"
#include "cnfgmgr.h"

//
// CEmailIDLdapStore is a class that stores and retrieves mail information
// from an LDAP DS.
//

//
// Ideally, this should be the optimal size for wldap32 to be
// returning the search results of dynamic DL members
//
#define CAT_DEFAULT_DYNAMICDL_PAGE_SIZE             1000

//
// Do not try to initialize the store more often than this specified time
//
#define CAT_LDAPSTORE_MIN_INIT_INTERVAL             (5*60)  // 5 minutes

template <class T> class CEmailIDLdapStore;

typedef struct _tagMemberResolveContext {
    CEmailIDLdapStore<CCatAddr> *pStore;
    CCatAddr *pCCatAddr;
    CAT_ADDRESS_TYPE CAType;
    DWORD dwNextBlockIndex;
    CBatchLdapConnection *pConn;
    ICategorizerItemAttributes *pICatItemAttr;
    HRESULT hrResolveStatus;
    PFN_DLEXPANSIONCOMPLETION pfnCompletion;
    PVOID pCompletionContext;
    BOOL fFinalCompletion;
} MEMBERRESOLVECONTEXT, *PMEMBERRESOLVECONTEXT;


CatDebugClass(CMembershipPageInsertionRequest),
    public CInsertionRequest
{
  public:
    CMembershipPageInsertionRequest(
        PMEMBERRESOLVECONTEXT pMemCtx)
    {
        m_pMemCtx = pMemCtx;
        m_fInsertedRequest = FALSE;
    }

    HRESULT HrInsertSearches(
        DWORD dwcSearches,
        DWORD *pdwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);

  private:
    PMEMBERRESOLVECONTEXT m_pMemCtx;
    BOOL m_fInsertedRequest;
};


template <class T> CatDebugClass(CEmailIDLdapStore),
    public CEmailIDStore<T>
{
  public:
    CEmailIDLdapStore()
    {
        m_pICatParams = NULL;
        m_pISMTPServer = NULL;
        m_pISMTPServerEx = NULL;
        m_szAccount[0] = '\0';
        m_pCLdapCfgMgr = NULL;
        ZeroMemory(&m_ulLastInitTime, sizeof(m_ulLastInitTime));
    }

    ~CEmailIDLdapStore()
    {
        if(m_pICatParams)
            m_pICatParams->Release();
        if(m_pISMTPServer)
            m_pISMTPServer->Release();
        if(m_pISMTPServerEx)
            m_pISMTPServerEx->Release();
        if(m_pCLdapCfgMgr)
            m_pCLdapCfgMgr->Release();

    }

    //
    // Initialize the store.
    //
    virtual HRESULT Initialize(
        ICategorizerParametersEx *pICatParams,
        ISMTPServer *pISMTPServer);

    //
    // get an entry asynchronously
    //
    HRESULT InitializeResolveListContext(
        VOID *pUserContext,
        LPRESOLVE_LIST_CONTEXT pResolveListContext);

    VOID FreeResolveListContext(
        LPRESOLVE_LIST_CONTEXT pResolveListContext);

    HRESULT LookupEntryAsync(
        T *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext);

    virtual HRESULT CancelResolveList(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        HRESULT hr);

    VOID CancelAllLookups();

    static VOID AsyncLookupCompletion(
        CCatAddr *pCCatAddr,
        LPVOID lpContext);

    HRESULT HrExpandPagedDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        CAT_ADDRESS_TYPE CAType,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrExpandDynamicDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext);

    VOID GetInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext)
    {
        ((CStoreListResolveContext *)pListContext->pStoreContext)->GetInsertionContext();
    }
    VOID ReleaseInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext)
    {
        ((CStoreListResolveContext *)pListContext->pStoreContext)->ReleaseInsertionContext();
    }

    HRESULT InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pListContext,
        CInsertionRequest *pCRequest);

    HRESULT HrGetConnection(
        CCfgConnection **ppConn)
    {
        return m_pCLdapCfgMgr->HrGetConnection(ppConn);
    }

    // this will have to be defined per template instance
    static const DWORD Signature;

  private:
    char m_szAccount[CAT_MAX_DOMAIN];
    LPSTR m_pszHost;
    DWORD m_dwPort;
    LPSTR m_pszNamingContext;
    LPSTR m_pszPassword;
    LDAP_BIND_TYPE m_bt;

    HRESULT RetrieveICatParamsInfo(
        LPSTR *ppszHost,
        DWORD *pdwPort,
        LPSTR *ppszNamingContext,
        LPSTR *ppszAccount,
        LPSTR *ppszDomain,
        LPSTR *ppszPassword,
        LDAP_BIND_TYPE *pbt);

    HRESULT AccountFromUserDomain(
        LPTSTR pszAccount,
        DWORD  dwccAccount,
        LPTSTR pszUser,
        LPTSTR pszDomain);

    HRESULT HrExpandDlPage(
        PMEMBERRESOLVECONTEXT pMemCtx,
        ICategorizerItemAttributes *pICatItemAttr);

    HRESULT HrExpandAttribute(
        CCatAddr *pCCatAddr,
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers);

    HRESULT HrExpandNextDlPage(
        PMEMBERRESOLVECONTEXT pMemCtx);

    static VOID AsyncExpandDlCompletion(
        LPVOID ctx,
        DWORD  dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttrs,
        HRESULT hr,
        BOOL fFinalCompletion);

    static VOID FinishExpandItem(
        CCatAddr *pCCatAddr,
        HRESULT hrStatus);

    static VOID AsyncDynamicDlCompletion(
        LPVOID ctx,
        DWORD  dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttrs,
        HRESULT hr,
        BOOL fFinalCompletion);

    static HRESULT HrAddItemAttrMember(
        CCatAddr *pCCatAddr,
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttr);

    VOID ResetPeriodicEventLogs()
    {
        if (m_pISMTPServerEx)
        {
            m_pISMTPServerEx->ResetLogEvent(
                CAT_EVENT_LOGON_FAILURE,
                m_szAccount);

            m_pISMTPServerEx->ResetLogEvent(
                CAT_EVENT_LDAP_CONNECTION_FAILURE,
                "");
        }
    }


    ICategorizerParametersEx *m_pICatParams;
    ISMTPServer *m_pISMTPServer;
    ISMTPServerEx *m_pISMTPServerEx;
    CLdapCfgMgr *m_pCLdapCfgMgr;
    ULARGE_INTEGER m_ulLastInitTime;

    friend class CMembershipPageInsertionRequest;
};

#define SZ_PAGEDMEMBERS_INDICATOR ";range=" // String appened to
                                            // members attribute
                                            // indicating this is a
                                            // partial list
#define WSZ_PAGEDMEMBERS_INDICATOR L";range="
#define MAX_PAGEDMEMBERS_DIGITS     32 // Maximum # of digits for
                                       // range specifier values
#define MAX_MEMBER_ATTRIBUTE_SIZE   64 // Maximum size of the member
                                       // attribute name


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\cat\ldapstor
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\cat\ldapstor
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Moved to transmt 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Includes from external directories
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <dbgtrace.h>
#include <listmacr.h>
#include "spinlock.h"
#include "catdebug.h"
#include <lmcons.h>
#include <dsgetdc.h>
#include <lmapibuf.h>
#include <time.h>
#include "caterr.h"
#include "smtpevent.h"
#include <transmem.h>
#include <winldap.h>
#include <perfcat.h>
#include <catperf.h>


//Local includes
#ifdef PLATINUM
#include <ptntintf.h>
#include <ptntdefs.h>
#define AQ_MODULE_NAME "phatq"
#else //not PLATINUM
#define AQ_MODULE_NAME "aqueue"
#endif //PLATINUM
#include "idstore.h"
#include "pldapwrap.h"
#include "ccat.h"
#include "ccatfn.h"
#include "globals.h"
#include "asyncctx.h"
#include "ccataddr.h"
#include "icatasync.h"
#include <smtpseo.h>
#include "catglobals.h"
#include "catdebug.h"


#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\pldapwrap.h ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: pldapwrap.h
//
// Contents: Class to refcount a PLDAP handle
//
// Classes: 
//  CRefcountWrap: generic refcounting wrap class
//  CPLDAPWrap
//
// Functions: 
//
// History:
// jstamerj 2000/02/25 15:18:15: Created.
//
//-------------------------------------------------------------
class CRefcountWrap
{
  public:
    CRefcountWrap()
    {
        m_lRefCount = 1;
    }
    LONG AddRef()
    {
        return InterlockedIncrement(&m_lRefCount);
    }
    LONG Release()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRefCount);
        if(lRet == 0)
            FinalRelease();
        return lRet;
    }
    virtual VOID FinalRelease() = 0;
  private:
    LONG m_lRefCount;
};



CatDebugClass(CPLDAPWrap),
    public CRefcountWrap
{
  public:
    CPLDAPWrap()
    {
        m_pldap = NULL;
    }
    CPLDAPWrap(
        LPSTR pszHost,
        DWORD dwPort)
    {
        m_pldap = ldap_open(pszHost, dwPort);
    }
    VOID SetPLDAP(PLDAP pldap)
    {
        m_pldap = pldap;
    }
    VOID FinalRelease()
    {
        delete this;
    }
    operator PLDAP()
    {
        return PLDAP();
    }
    PLDAP GetPLDAP()
    {
        return m_pldap;
    }
  private:
    ~CPLDAPWrap()
    {
        if(m_pldap)
            ldap_unbind(m_pldap);
    }
 private:
    PLDAP m_pldap;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\schema.cpp ===
//
// schema.h -- This file contains the class definitions for:
//      CLDAPSchema
//
// Created:
//      April 6, 1997 -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "schema.h"
#include "ldapstr.h"

//+----------------------------------------------------------------------------
//
//  Function:   CNT5LDAPSchema::CNT5LDAPSchema
//
//  Synopsis:   Constructor
//
//  Arguments:  [szSchemaConfigDirectory] -- Ignored.
//              [pdwErr] -- Construction errors are returned here.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CNT5LDAPSchema::CNT5LDAPSchema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    m_DNAttrName = ATTR_DISTINGUISHED_NAME;
    m_RDNAttrName = ATTR_RELATIVE_DISTINGUISHED_NAME;

    m_IMSConfigClassName = CLASS_IMS_CONFIG;
    m_ChangeGuidAttrName = ATTR_DOMAIN_INFO_GUID;
    m_DomainListAttrName = ATTR_DOMAIN_INFO_LIST;
    m_ServerListAttrName = ATTR_SERVER_LIST;
    m_ConfigObjectName = OBJECT_IMS_CONFIG;
    m_ConfigObjectRDN = OBJECT_IMS_CONFIG_RDN;

    m_UserClassName = CLASS_USER;
    m_UserEmailAttrName = ATTR_EMAIL_ADDRESS;
    m_UserX400AttrName = ATTR_X400_ADDRESS;
    m_UserHomeServerAttrName = ATTR_HOMESERVER_ADDRESS;
    m_UserFwdAndDeliverName = ATTR_FWD_AND_DELIVER;
    m_UserAlternateName = ATTR_ALTERNATE_ADDRESS;
    m_UserProxyName = ATTR_PROXY_ADDRESS;
    m_UserProxyReturnedName = ATTR_PROXY_RETURNED_ADDRESS;
    m_UserLegacyEXDNName = ATTR_LEGACYEXDN_ADDRESS;

    m_UserMailboxAttrName = ATTR_IMS_MAILBOX;
    m_UserQuotaAttrName = ATTR_IMS_MAILBOXQUOTA;
    m_UserForwardAttrName = ATTR_IMS_FORWARDADDR;
    m_UserForwardAttrType = ATTR_IMS_FORWARDTYPE;
    m_UserLocalAttrName = ATTR_IMS_LOCAL;
    m_UserAutoReply = ATTR_IMS_AUTOREPLY;
    m_UserAutoReplySubject = ATTR_IMS_AUTOREPLYSUBJECT;

    m_X500DLClassName = CLASS_X500DL;
    m_X500DLMembersAttrName = ATTR_X500_MEMBERS;

    m_RFC822DLClassName = CLASS_RFC822DL;
    m_RFC822DLMembersAttrName = ATTR_RFC822_MEMBERS;

    m_DynamicDLClassName = CLASS_DYNAMICDL;
    m_DynamicDLMembersAttrName = ATTR_DYNAMIC_MEMBERS;

    m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;
    
    m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

    m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

    m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
    m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    *pdwErr = ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CNT5ExchangeSchema::CNT5ExchangSchema
//
//  Synopsis:   Constructor
//
//  Arguments:  [szSchemaConfigDirectory] -- Ignored.
//              [pdwErr] -- Construction errors are returned here.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CNT5ExchangeSchema::CNT5ExchangeSchema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    m_DNAttrName = NT5EXCHANGE_ATTR_DISTINGUISHED_NAME;
    m_RDNAttrName = NT5EXCHANGE_ATTR_RELATIVE_DISTINGUISHED_NAME;

    m_IMSConfigClassName = CLASS_IMS_CONFIG;
    m_ChangeGuidAttrName = ATTR_DOMAIN_INFO_GUID;
    m_DomainListAttrName = ATTR_DOMAIN_INFO_LIST;
    m_ServerListAttrName = ATTR_SERVER_LIST;
    m_ConfigObjectName = OBJECT_IMS_CONFIG;
    m_ConfigObjectRDN = OBJECT_IMS_CONFIG_RDN;

    m_UserClassName = NT5EXCHANGE_CLASS_USER;
    m_UserEmailAttrName = NT5EXCHANGE_ATTR_EMAIL_ADDRESS;
    m_UserX400AttrName = NT5EXCHANGE_ATTR_X400_ADDRESS;
    m_UserHomeServerAttrName = NT5EXCHANGE_ATTR_HOMESERVER;
    m_UserFwdAndDeliverName = NT5EXCHANGE_ATTR_FWD_AND_DELIVER;
    m_UserAlternateName = NT5EXCHANGE_ATTR_ALTERNATE_ADDRESS;
    m_UserProxyName = NT5EXCHANGE_ATTR_PROXY_ADDRESS;
    m_UserProxyReturnedName = NT5EXCHANGE_ATTR_PROXY_RETURNED_ADDRESS;
    m_UserLegacyEXDNName = NT5EXCHANGE_ATTR_LEGACYEXDN_ADDRESS;

    m_UserMailboxAttrName = NT5EXCHANGE_ATTR_IMS_MAILBOX;
    m_UserQuotaAttrName = NT5EXCHANGE_ATTR_IMS_MAILBOXQUOTA;
    m_UserForwardAttrName = NT5EXCHANGE_ATTR_IMS_FORWARDADDR;
    m_UserForwardAttrType = NT5EXCHANGE_ATTR_IMS_FORWARDTYPE;
    m_UserLocalAttrName = NT5EXCHANGE_ATTR_IMS_LOCAL;
    m_UserAutoReply = NT5EXCHANGE_ATTR_IMS_AUTOREPLY;
    m_UserAutoReplySubject = NT5EXCHANGE_ATTR_IMS_AUTOREPLYSUBJECT;

    m_X500DLClassName = NT5EXCHANGE_CLASS_X500DL;
    m_X500DLMembersAttrName = NT5EXCHANGE_ATTR_X500_MEMBERS;

    m_RFC822DLClassName = NT5EXCHANGE_CLASS_RFC822DL;
    m_RFC822DLMembersAttrName = NT5EXCHANGE_ATTR_RFC822_MEMBERS;

    m_DynamicDLClassName = NT5EXCHANGE_CLASS_DYNAMICDL;
    m_DynamicDLMembersAttrName = NT5EXCHANGE_ATTR_DYNAMIC_MEMBERS;

    m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

    m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

    m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
    m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    *pdwErr = ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CNT5ExchangeDLTestSchema::CNT5ExchangDLTestSchema
//
//  Synopsis:   Constructor
//
//  Arguments:  [szSchemaConfigDirectory] -- Ignored.
//              [pdwErr] -- Construction errors are returned here.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CNT5ExchangeDLTestSchema::CNT5ExchangeDLTestSchema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    // Exactly the same as NT5Exchange except for the X500DLClassName
    // attribute string 
    m_X500DLClassName = NT5EXCHANGEDLTEST_ATTR_X500DL;

    m_DNAttrName = NT5EXCHANGE_ATTR_DISTINGUISHED_NAME;
    m_RDNAttrName = NT5EXCHANGE_ATTR_RELATIVE_DISTINGUISHED_NAME;

    m_IMSConfigClassName = CLASS_IMS_CONFIG;
    m_ChangeGuidAttrName = ATTR_DOMAIN_INFO_GUID;
    m_DomainListAttrName = ATTR_DOMAIN_INFO_LIST;
    m_ServerListAttrName = ATTR_SERVER_LIST;
    m_ConfigObjectName = OBJECT_IMS_CONFIG;
    m_ConfigObjectRDN = OBJECT_IMS_CONFIG_RDN;

    m_UserClassName = NT5EXCHANGE_CLASS_USER;
    m_UserEmailAttrName = NT5EXCHANGE_ATTR_EMAIL_ADDRESS;
    m_UserX400AttrName = NT5EXCHANGE_ATTR_X400_ADDRESS;
    m_UserHomeServerAttrName = NT5EXCHANGE_ATTR_HOMESERVER;
    m_UserFwdAndDeliverName = NT5EXCHANGE_ATTR_FWD_AND_DELIVER;
    m_UserAlternateName = NT5EXCHANGE_ATTR_ALTERNATE_ADDRESS;
    m_UserProxyName = NT5EXCHANGE_ATTR_PROXY_ADDRESS;
    m_UserProxyReturnedName = NT5EXCHANGE_ATTR_PROXY_RETURNED_ADDRESS;
    m_UserLegacyEXDNName = NT5EXCHANGE_ATTR_LEGACYEXDN_ADDRESS;

    m_UserMailboxAttrName = NT5EXCHANGE_ATTR_IMS_MAILBOX;
    m_UserQuotaAttrName = NT5EXCHANGE_ATTR_IMS_MAILBOXQUOTA;
    m_UserForwardAttrName = NT5EXCHANGE_ATTR_IMS_FORWARDADDR;
    m_UserForwardAttrType = NT5EXCHANGE_ATTR_IMS_FORWARDTYPE;
    m_UserLocalAttrName = NT5EXCHANGE_ATTR_IMS_LOCAL;
    m_UserAutoReply = NT5EXCHANGE_ATTR_IMS_AUTOREPLY;
    m_UserAutoReplySubject = NT5EXCHANGE_ATTR_IMS_AUTOREPLYSUBJECT;

    m_X500DLMembersAttrName = NT5EXCHANGE_ATTR_X500_MEMBERS;

    m_RFC822DLClassName = NT5EXCHANGE_CLASS_RFC822DL;
    m_RFC822DLMembersAttrName = NT5EXCHANGE_ATTR_RFC822_MEMBERS;

    m_DynamicDLClassName = NT5EXCHANGE_CLASS_DYNAMICDL;
    m_DynamicDLMembersAttrName = NT5EXCHANGE_ATTR_DYNAMIC_MEMBERS;

    m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

    m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

    m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
    m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    *pdwErr = ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CExchange5Schema::CExchang5Schema
//
//  Synopsis:   Constructor
//
//  Arguments:  [szSchemaConfigDirectory] -- Ignored.
//              [pdwErr] -- Construction errors are returned here.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CExchange5Schema::CExchange5Schema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    m_DNAttrName = EX5_ATTR_DISTINGUISHED_NAME;
    m_RDNAttrName = EX5_ATTR_RELATIVE_DISTINGUISHED_NAME;

    m_IMSConfigClassName = CLASS_IMS_CONFIG;
    m_ChangeGuidAttrName = ATTR_DOMAIN_INFO_GUID;
    m_DomainListAttrName = ATTR_DOMAIN_INFO_LIST;
    m_ServerListAttrName = ATTR_SERVER_LIST;
    m_ConfigObjectName = OBJECT_IMS_CONFIG;
    m_ConfigObjectRDN = OBJECT_IMS_CONFIG_RDN;

    m_UserClassName = EX5_CLASS_USER;
    m_UserEmailAttrName = EX5_ATTR_EMAIL_ADDRESS;
    m_UserX400AttrName = EX5_ATTR_X400_ADDRESS;
    m_UserHomeServerAttrName = EX5_ATTR_HOMESERVER;
    m_UserFwdAndDeliverName = EX5_ATTR_FWD_AND_DELIVER;
    m_UserAlternateName = EX5_ATTR_ALTERNATE_ADDRESS;
    m_UserProxyName = EX5_ATTR_PROXY_ADDRESS;
    m_UserProxyReturnedName = EX5_ATTR_PROXY_RETURNED_ADDRESS;
    m_UserLegacyEXDNName = EX5_ATTR_LEGACYEXDN_ADDRESS;

    m_UserMailboxAttrName = EX5_ATTR_IMS_MAILBOX;
    m_UserQuotaAttrName = EX5_ATTR_IMS_MAILBOXQUOTA;
    m_UserForwardAttrName = EX5_ATTR_IMS_FORWARDADDR;
    m_UserForwardAttrType = EX5_ATTR_IMS_FORWARDTYPE;
    m_UserLocalAttrName = EX5_ATTR_IMS_LOCAL;
    m_UserAutoReply = EX5_ATTR_IMS_AUTOREPLY;
    m_UserAutoReplySubject = EX5_ATTR_IMS_AUTOREPLYSUBJECT;

    m_X500DLClassName = EX5_CLASS_X500DL;
    m_X500DLMembersAttrName = EX5_ATTR_X500_MEMBERS;

    m_RFC822DLClassName = EX5_CLASS_RFC822DL;
    m_RFC822DLMembersAttrName = EX5_ATTR_RFC822_MEMBERS;

    m_DynamicDLClassName = EX5_CLASS_DYNAMICDL;
    m_DynamicDLMembersAttrName = EX5_ATTR_DYNAMIC_MEMBERS;

    m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

    m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

    m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
    m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    *pdwErr = ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMCIS3Schema::CMCIS3Schema
//
//  Synopsis:   Constructor
//
//  Arguments:  [szSchemaConfigDirectory] -- Ignored.
//              [pdwErr] -- Construction errors are returned here.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CMCIS3Schema::CMCIS3Schema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    m_DNAttrName = MCIS3_ATTR_DISTINGUISHED_NAME;
    m_RDNAttrName = MCIS3_ATTR_RELATIVE_DISTINGUISHED_NAME;

    m_IMSConfigClassName = CLASS_IMS_CONFIG;
    m_ChangeGuidAttrName = ATTR_DOMAIN_INFO_GUID;
    m_DomainListAttrName = ATTR_DOMAIN_INFO_LIST;
    m_ServerListAttrName = ATTR_SERVER_LIST;
    m_ConfigObjectName = OBJECT_IMS_CONFIG;
    m_ConfigObjectRDN = OBJECT_IMS_CONFIG_RDN;

    m_UserClassName = MCIS3_CLASS_USER;
    m_UserEmailAttrName = MCIS3_ATTR_EMAIL_ADDRESS;
    m_UserX400AttrName = MCIS3_ATTR_X400_ADDRESS;
    m_UserHomeServerAttrName = MCIS3_ATTR_HOMESERVER;
    m_UserFwdAndDeliverName = MCIS3_ATTR_FWD_AND_DELIVER;
    m_UserAlternateName = MCIS3_ATTR_ALTERNATE_ADDRESS;
    m_UserProxyName = MCIS3_ATTR_PROXY_ADDRESS;
    m_UserProxyReturnedName = MCIS3_ATTR_PROXY_RETURNED_ADDRESS;
    m_UserLegacyEXDNName = MCIS3_ATTR_LEGACYEXDN_ADDRESS;

    m_UserMailboxAttrName = MCIS3_ATTR_IMS_MAILBOX;
    m_UserQuotaAttrName = MCIS3_ATTR_IMS_MAILBOXQUOTA;
    m_UserForwardAttrName = MCIS3_ATTR_IMS_FORWARDADDR;
    m_UserForwardAttrType = MCIS3_ATTR_IMS_FORWARDTYPE;
    m_UserLocalAttrName = MCIS3_ATTR_IMS_LOCAL;
    m_UserAutoReply = MCIS3_ATTR_IMS_AUTOREPLY;
    m_UserAutoReplySubject = MCIS3_ATTR_IMS_AUTOREPLYSUBJECT;

    m_X500DLClassName = MCIS3_CLASS_X500DL;
    m_X500DLMembersAttrName = MCIS3_ATTR_X500_MEMBERS;

    m_RFC822DLClassName = MCIS3_CLASS_RFC822DL;
    m_RFC822DLMembersAttrName = MCIS3_ATTR_RFC822_MEMBERS;

    m_DynamicDLClassName = MCIS3_CLASS_DYNAMICDL;
    m_DynamicDLMembersAttrName = MCIS3_ATTR_DYNAMIC_MEMBERS;

    m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

    m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

    m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
    m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
    m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
    m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

    m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
    m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
    m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
    m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    *pdwErr = ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CGenericSchema::CGenericSchema
//
//  Synopsis:   Constructor for a schema class that reads the schema from an
//              ini file.
//
//  Arguments:  [szSchemaConfigDirectory] -- Directory of ini file.
//              [pdwErr] -- If an error is encountered while parsing the ini
//                  file, it is returned here.
//
//  Returns:    Nothing, but pdwErr is significant.
//
//-----------------------------------------------------------------------------

CGenericSchema::CGenericSchema(
    LPSTR szSchemaConfigDirectory,
    LPDWORD pdwErr) : CLDAPSchema(szSchemaConfigDirectory, pdwErr)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD i, cItems;
    CHAR szIniFile[_MAX_PATH];

    m_UserForwardAttrType = CAT_SMTP;

    struct {
        LPCSTR szValueName;
        LPSTR  *pszValue;
    } rgRequired[] = {
        {GENERIC_CLASS_USER, &m_UserClassName},
        {GENERIC_ATTR_EMAIL_ADDRESS, &m_UserEmailAttrName},
        {GENERIC_ATTR_DISTINGUISHED_NAME, &m_DNAttrName},
        {GENERIC_ATTR_RELATIVE_DISTINGUISHED_NAME, &m_RDNAttrName}
    };

    struct {
        LPCSTR szValueName;
        LPSTR *pszValue;
    } rgOptional[] = {
        {GENERIC_ATTR_X400_ADDRESS, &m_UserX400AttrName},
        {GENERIC_ATTR_HOMESERVER, &m_UserHomeServerAttrName},
        {GENERIC_ATTR_FWD_AND_DELIVER, &m_UserFwdAndDeliverName},
        {GENERIC_ATTR_ALTERNATE_ADDRESS, &m_UserAlternateName},
        {GENERIC_ATTR_PROXY_ADDRESS, &m_UserProxyName},
        {GENERIC_ATTR_PROXY_RETURNED_ADDRESS, &m_UserProxyReturnedName},
        {GENERIC_ATTR_LEGACYEXDN_ADDRESS, &m_UserLegacyEXDNName},

        {GENERIC_ATTR_IMSMAILBOX, &m_UserMailboxAttrName},
        {GENERIC_ATTR_IMSMAILBOXQUOTA, &m_UserQuotaAttrName},
        {GENERIC_ATTR_IMSFORWARDADDR, &m_UserForwardAttrName},
        {GENERIC_ATTR_IMSAUTOREPLY, &m_UserAutoReply},
        {GENERIC_ATTR_IMSAUTOREPLYSUBJECT, &m_UserAutoReplySubject},
        {GENERIC_CLASS_X500DL, &m_X500DLClassName},
        {GENERIC_ATTR_X500_MEMBERS, &m_X500DLMembersAttrName},
        {GENERIC_CLASS_RFC822DL, &m_RFC822DLClassName},
        {GENERIC_ATTR_RFC822_MEMBERS, &m_RFC822DLMembersAttrName},
        {GENERIC_CLASS_DYNAMICDL, &m_DynamicDLClassName},
        {GENERIC_ATTR_DYNAMICDL_MEMBERS, &m_DynamicDLMembersAttrName},
        {GENERIC_NOTUSED, &m_IMSConfigClassName},
        {GENERIC_NOTUSED, &m_ChangeGuidAttrName},
        {GENERIC_NOTUSED, &m_DomainListAttrName},
        {GENERIC_NOTUSED, &m_ServerListAttrName},
        {GENERIC_NOTUSED, &m_ConfigObjectName},
        {GENERIC_NOTUSED, &m_ConfigObjectRDN},
        {GENERIC_NOTUSED, &m_UserLocalAttrName}
    };

    //
    // Innocent until proven guilty...
    //

    *pdwErr = ERROR_SUCCESS;


    //
    // Initialize all member strings to NULL, so if our initialization fails,
    // the destructor can correctly cleanup.
    //

    cItems = sizeof(rgRequired) / sizeof(rgRequired[1]);

    for (i = 0; i < cItems; i++) {
        *(rgRequired[i].pszValue) = NULL;
    }

    cItems = sizeof(rgOptional) / sizeof(rgOptional[1]);

    for (i = 0; i < cItems; i++) {
        *(rgOptional[i].pszValue) = NULL;
    }

    //
    // Construct ini file name and make sure it is there.
    //

    if (szSchemaConfigDirectory != NULL && szSchemaConfigDirectory[0] != 0) {

        DWORD dwFileAttrs;

        lstrcpy(szIniFile, szSchemaConfigDirectory);

        lstrcat(szIniFile, "\\schema.ini");

        dwFileAttrs = GetFileAttributes(szIniFile);

        if (dwFileAttrs == -1 ||
                ((dwFileAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0)) {

           *pdwErr = CAT_E_FILE_NOT_FOUND;

        }

    } else {

        *pdwErr = CAT_E_INVALID_ARG;

    }

    //
    // Get all the required values. Required values must be in the ini file.
    //

    cItems = sizeof(rgRequired) / sizeof(rgRequired[1]);

    for (i = 0; i < cItems && *pdwErr == ERROR_SUCCESS; i++) {

        dwErr = GetValueFromIniFile(
                    szIniFile,
                    rgRequired[i].szValueName,
                    rgRequired[i].pszValue,
                    NULL);

        if (dwErr == ERROR_FILE_NOT_FOUND)
            *pdwErr = CAT_E_INVALID_SCHEMA;
        else if (dwErr != ERROR_SUCCESS)
            *pdwErr = dwErr;

    }

    //
    // Get the optional values. If optional values are not specified in the
    // ini file (ERROR_FILE_NOT_FOUND returned from GetValueFromIniFile), we
    // use the default value.
    //

    cItems = sizeof(rgOptional) / sizeof(rgOptional[1]);

    for (i = 0; i < cItems && *pdwErr == ERROR_SUCCESS; i++) {

        dwErr = GetValueFromIniFile(
                    szIniFile,
                    rgOptional[i].szValueName,
                    rgOptional[i].pszValue,
                    "notUsed");

        if (dwErr != ERROR_SUCCESS)
            *pdwErr = dwErr;

    }

    //
    // If we were able to read all the attribute values so far, we need to
    // populate the arrays of attribute names.
    //

    if (*pdwErr == ERROR_SUCCESS) {

        m_rgszUserAttrNames[USER_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
        m_rgszUserAttrNames[USER_ALL_X400_INDEX] = m_UserX400AttrName;
        m_rgszUserAttrNames[USER_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
        m_rgszUserAttrNames[USER_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
        m_rgszUserAttrNames[USER_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
        m_rgszUserAttrNames[USER_ALL_PROXY_INDEX] = m_UserProxyName;
        m_rgszUserAttrNames[USER_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

        m_rgszUserAttrNames[USER_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
        m_rgszUserAttrNames[USER_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
        m_rgszUserAttrNames[USER_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
        m_rgszUserAttrNames[USER_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
        m_rgszUserAttrNames[USER_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
        m_rgszUserAttrNames[USER_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
        m_rgszUserAttrNames[USER_ALL_LAST_INDEX] = NULL;

        m_rgszDLAttrNames[DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
        m_rgszDLAttrNames[DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
        m_rgszDLAttrNames[DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
        m_rgszDLAttrNames[DL_ALL_LAST_INDEX] = NULL;

        m_rgszUserDLAttrNames[USER_DL_ALL_OBJECTCLASS_INDEX] = "objectClass";
        m_rgszUserDLAttrNames[USER_DL_ALL_EMAIL_INDEX] = m_UserEmailAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_X400_INDEX] = m_UserX400AttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_HOMESERVER_INDEX] = m_UserHomeServerAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_FWD_AND_DELIVER_INDEX] = m_UserFwdAndDeliverName;
        m_rgszUserDLAttrNames[USER_DL_ALL_ALTERNATE_INDEX] = m_UserAlternateName;
        m_rgszUserDLAttrNames[USER_DL_ALL_PROXY_INDEX] = m_UserProxyName;
        m_rgszUserDLAttrNames[USER_DL_ALL_LEGACYEXDN_INDEX] = m_UserLegacyEXDNName;

        m_rgszUserDLAttrNames[USER_DL_ALL_MAILBOX_INDEX] = m_UserMailboxAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_QUOTA_INDEX] = m_UserQuotaAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_FORWARD_INDEX] = m_UserForwardAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_LOCAL_INDEX] = m_UserLocalAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLY_INDEX] = m_UserAutoReply;
        m_rgszUserDLAttrNames[USER_DL_ALL_AUTOREPLYSUBJECT_INDEX] = m_UserAutoReplySubject;
        m_rgszUserDLAttrNames[USER_DL_ALL_X500_MEMBERS_INDEX] = m_X500DLMembersAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_RFC822_MEMBERS_INDEX] = m_RFC822DLMembersAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_DYNAMIC_MEMBERS_INDEX] = m_DynamicDLMembersAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_DN_INDEX] = m_DNAttrName;
        m_rgszUserDLAttrNames[USER_DL_ALL_LAST_INDEX] = NULL;

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CGenericSchema::~CGenericSchema
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CGenericSchema::~CGenericSchema()
{
    //
    // Delete all strings that were allocated in the constructor
    //

    if (m_DNAttrName != NULL) delete m_DNAttrName;

    if (m_IMSConfigClassName != NULL) delete m_IMSConfigClassName;
    if (m_ChangeGuidAttrName != NULL) delete m_ChangeGuidAttrName;
    if (m_DomainListAttrName != NULL) delete m_DomainListAttrName;
    if (m_ServerListAttrName != NULL) delete m_ServerListAttrName;
    if (m_ConfigObjectName != NULL) delete m_ConfigObjectName;
    if (m_ConfigObjectRDN != NULL) delete m_ConfigObjectRDN;

    if (m_UserClassName != NULL) delete m_UserClassName;
    if (m_UserEmailAttrName != NULL) delete m_UserEmailAttrName;
    if (m_UserX400AttrName != NULL) delete m_UserEmailAttrName;
    if (m_UserHomeServerAttrName != NULL) delete m_UserEmailAttrName;
    if (m_UserFwdAndDeliverName != NULL) delete m_UserFwdAndDeliverName;
    if (m_UserAlternateName != NULL) delete m_UserAlternateName;
    if (m_UserProxyName != NULL) delete m_UserProxyName;
    if (m_UserLegacyEXDNName != NULL) delete m_UserLegacyEXDNName;

    if (m_UserMailboxAttrName != NULL) delete m_UserMailboxAttrName;
    if (m_UserQuotaAttrName != NULL) delete m_UserQuotaAttrName;
    if (m_UserForwardAttrName != NULL) delete m_UserForwardAttrName;
    if (m_UserLocalAttrName != NULL) delete m_UserLocalAttrName;

    if (m_X500DLClassName != NULL) delete m_X500DLClassName;
    if (m_X500DLMembersAttrName != NULL) delete m_X500DLMembersAttrName;

    if (m_RFC822DLClassName != NULL) delete m_RFC822DLClassName;
    if (m_RFC822DLMembersAttrName != NULL) delete m_RFC822DLMembersAttrName;

    if (m_DynamicDLClassName != NULL) delete m_DynamicDLClassName;
    if (m_DynamicDLMembersAttrName != NULL) delete m_DynamicDLMembersAttrName;

}

//+----------------------------------------------------------------------------
//
//  Function:   CGenericSchema::GetValueFromIniFile
//
//  Synopsis:   Get a value from the schema.ini file
//
//  Arguments:  [szIniFile] -- Name of ini file
//              [szValueName] -- Name of value to read
//              [pszValue] -- On successful return, contains pointer to
//                  buffer holding the value specified in the ini file.
//              [szDefault] -- If non-null, this value is returned for
//                  pszValue if szValueName is not in the ini file. If this is
//                  null and szValueName is not specified,
//                  ERROR_FILE_NOT_FOUND is returned.
//
//  Returns:    [ERROR_SUCCESS] -- On successful retrieval of value
//              [ERROR_OUTOFMEMORY] -- Unable to allocate room for
//                  pszValue.
//              [ERROR_FILE_NOT_FOUND] -- szDefault is NULL, and szValueName
//                  not specified in ini file.
//
//-----------------------------------------------------------------------------

DWORD CGenericSchema::GetValueFromIniFile(
    LPCSTR szIniFile,
    LPCSTR szValueName,
    LPSTR *pszValue,
    LPCSTR szDefault)
{
    DWORD dwErr;
    DWORD cbBuffer = 32;
    DWORD cbValue;
    LPCSTR _szDefault = szDefault == NULL ? "" : szDefault;

    do {

        *pszValue = new CHAR [cbBuffer];

        if (*pszValue != NULL) {

            cbValue = GetPrivateProfileString(
                            "LDAPSchema",        // "App" name
                            (LPSTR) szValueName, // Keyname
                            (LPSTR) _szDefault,  // Default value
                            *pszValue,
                            cbBuffer,
                            (LPSTR) szIniFile);

            if (cbValue == (cbBuffer - 1)) {

                //
                // If the value didn't fit in the buffer,
                // GetPrivateProfileString returns cbBuffer - 1. We need to
                // increase buffer size and try again.
                //

                cbBuffer *= 2;

                delete *pszValue;

                dwErr = ERROR_MORE_DATA;

            } else if (cbValue == 0) {

                //
                // Caller did not specify default value, and our default value
                // was used.
                //

                dwErr = ERROR_FILE_NOT_FOUND;

            } else {

                dwErr = ERROR_SUCCESS;
            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } while ( dwErr == ERROR_MORE_DATA );

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\schema.h ===
//
// schema.h -- This file contains the class definitions for:
//      CLDAPSchema
//
// Created:
//      Feb 19, 1997 -- Milan Shah (milans)
//
// Changes:
//

#ifndef _SCHEMA_H_
#define _SCHEMA_H_

#include "cattype.h"

enum SCHEMA_TYPE {
    EXCHANGE5,
    MCIS3,
    NT5,
    GENERIC,
    NT5EXCHANGE
};

#endif //_SCHEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\simparray.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: simparray.h
//
// Contents: Simple growable array class
//
// Classes: CSimpArray
//
// Functions:
//
// History:
// jstamerj 1998/07/14 11:30:13: Created.
//
//-------------------------------------------------------------

#ifndef __SIMPARRAY_H__
#define __SIMPARRAY_H__
#include <windows.h>
#include "spinlock.h"
#include <dbgtrace.h>


//
// If you want this array to behave as follows:
//   When Inserting an array element and the allocated array size is
//   not sufficient, 
//     Alloc an array size of CSIMPARRAY_DEFAULT_INITIAL_SIZE the
//     first time
//     Double the current array size until sufficient thereafter
// Then define CSIMPARRAY_DOUBLE and CSIMPARRAY_DEFAULT_INITIAL_SIZE
//
// Otherwise, it will allocate only as much space as needed when
// needed.
//

// Define this to attempt to double the array size when reallocing is necessary
//#undef CSIMPARRAY_DOUBLE

// Default initial allocation
//#undef CSIMPARRAY_DEFAULT_INITIAL_SIZE     20



//+------------------------------------------------------------
//
// Class: CSimpArray
//
// Synopsis: Simple array class with usefull msgcat utility functions
//
// Hungarian: csa, pcsa
//
// History:
// jstamerj 1998/07/15 12:15:50: Created.
//
//-------------------------------------------------------------
template <class T> class CSimpArray
{
  public:
    CSimpArray();
    ~CSimpArray();

    // Optinal Initialize function - reserves array memory for a
    // specified array size
    HRESULT Initialize(DWORD dwSize);

    // Add one element to the array
    HRESULT Add(T Data);

    // Add a real array to this array
    HRESULT AddArray(DWORD dwSize, T *pData);

    // Number of valid elements added to the array
    DWORD Size();

    // Direct access to the array
    operator T * ();

  private:
    HRESULT AllocArrayRange(DWORD dwSize, PDWORD pdwIndex);
    HRESULT ReAllocArrayIfNecessary(DWORD dwSize);

    #define SIGNATURE_CSIMPARRAY (DWORD)'SArr'
    #define SIGNATURE_CSIMPARRAY_INVALID (DWORD) 'XArr'

    DWORD m_dwSignature;
    DWORD m_dwArrayAllocSize;
    DWORD m_dwArrayClaimedSize;
    DWORD m_dwArrayValidSize;
    T * m_rgData;

    SPIN_LOCK m_slAllocate;
};


//+------------------------------------------------------------
//
// Function: CSimpArray::CSimpArary (constructor)
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHIGN
//
// History:
// jstamerj 1998/07/14 11:39:08: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::CSimpArray()
{
    m_dwSignature = SIGNATURE_CSIMPARRAY;
    m_dwArrayAllocSize = m_dwArrayClaimedSize = m_dwArrayValidSize = 0;
    m_rgData = NULL;
    InitializeSpinLock(&m_slAllocate);
}


//+------------------------------------------------------------
//
// Function: CSimpArray::~CSimpArray (destructor)
//
// Synopsis: Free's memory
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/14 12:19:10: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::~CSimpArray()
{
    _ASSERT(m_dwSignature == SIGNATURE_CSIMPARRAY);
    m_dwSignature = SIGNATURE_CSIMPARRAY_INVALID;

    delete m_rgData;
}

    

//+------------------------------------------------------------
//
// Function: CSimpArray::operator T*
//
// Synopsis: Returns pointer to the array
//
// Arguments: NONE
//
// Returns: pointer to array of T's or NULL (if nothing is allocated)
//
// History:
// jstamerj 1998/07/14 14:15:21: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::operator T*()
{
    return m_rgData;
}


//+------------------------------------------------------------
//
// Function: CSimpArray::Size
//
// Synopsis: Returns the count of (valid) array elements.
//
// Arguments: NONE
//
// Returns: DWORD size
//
// History:
// jstamerj 1998/07/14 14:16:36: Created.
//
//-------------------------------------------------------------
template <class T> inline DWORD CSimpArray<T>::Size()
{
    return m_dwArrayValidSize;
}
#endif //__SIMPARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\spinlock.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.cpp
//
// Contents: Simple Spinlock package used by CLdapConnection
//
// Classes:
//
// Functions:
//   AcquireSpinLockSingleProc
//   AcquireSpinLockMultiProc
//   InitializeSpinLock
//   ReleaseSpinLock
//
// History:
// jstamerj 980511 17:26:26: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSpinLock
//
//  Synopsis:   Initializes a SPIN_LOCK
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to initialize
//
//  Returns:    Nothing. *psl is in released state when this functionr returns
//
//-----------------------------------------------------------------------------

VOID InitializeSpinLock(
    PSPIN_LOCK psl)
{
    *psl = 0;

    if(g_AcquireSpinLock == NULL) {
        // Determine multi or single proc
        SYSTEM_INFO si;
        GetSystemInfo(&si);
    
        if(si.dwNumberOfProcessors > 1) {
            g_AcquireSpinLock = AcquireSpinLockMultipleProc;
        } else {
            g_AcquireSpinLock = AcquireSpinLockSingleProc;
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockMultiProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for multi proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockMultipleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            ;
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockSingleProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for single proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockSingleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            Sleep(0);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseSpinLock
//
//  Synopsis:   Releases an acquired spin lock
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to release.
//
//  Returns:    Nothing. *psl is in released state when this function returns
//
//-----------------------------------------------------------------------------

VOID ReleaseSpinLock(
    PSPIN_LOCK psl)
{
    _ASSERT( *psl > 0 );

    InterlockedExchange( psl, 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\simparray.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: simparray.cpp
//
// Contents: Simple growable array class
//
// Classes: CSimpArray
//
// Functions:
//
// History:
// jstamerj 1998/07/14 11:37:25: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "simparray.h"


//+------------------------------------------------------------
//
// Function: CSimpArray::Initialize
//
// Synopsis: Initializes array to a specified size.  Only necessary to
// call if you wish to optimize usage by starting with a specified
// array size.
//
// Arguments:
//  dwSize: Initial array size
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:22:01: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::Initialize(
    DWORD dwSize)
{
    _ASSERT(m_dwArrayAllocSize == 0);
    _ASSERT(m_dwArrayClaimedSize == 0);
    _ASSERT(m_dwArrayValidSize == 0);

    _ASSERT(m_rgData == NULL);

    m_rgData = new T [dwSize];

    if(m_rgData == NULL) {

        return E_OUTOFMEMORY;

    } else {

        m_dwArrayAllocSize = dwSize;
        return S_OK;
    }
}


//+------------------------------------------------------------
//
// Function: CSimpArray::Add
//
// Synopsis: Adds one element to the array
//
// Arguments:
//  Data: Value to add to the array
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 15:50:00: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::Add(
    T Data)
{
    //
    // Same functionality as AddArray except this is an array with
    // only one element
    //
    return AddArray(1, &Data);
}


//+------------------------------------------------------------
//
// Function: CSimpArray::AddArray
//
// Synopsis: Adds an array of T's to our array
//
// Arguments:
//  dwSize: size of passed in array
//  pData:  pointer to array data
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:27:18: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::AddArray(
    DWORD dwSize,
    T * pData)
{
    HRESULT hr;
    DWORD dwCopyIndex;

    _ASSERT(dwSize);
    _ASSERT(pData);

    hr = AllocArrayRange(dwSize, &dwCopyIndex);
    if(FAILED(hr))
        return hr;

    //
    // Copy the memory from one array to another
    //
    CopyMemory(&(m_rgData[dwCopyIndex]), pData, sizeof(T) * dwSize);

    //
    // Increment array element counter
    //NOTE: This really isn't thread safe in the sense that if
    //we're in this call and someone is reading the array,
    //m_dwArrayValidSize could be invalid.
    //
    InterlockedExchangeAdd((PLONG) &m_dwArrayValidSize, dwSize);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: AllocArrayRange
//
// Synopsis: Allocates a range on the array for the caller (of unused T's)
//
// Arguments:
//  dwSize: Size of the range you'd like
//  pdwIndex: On success, starting index of your allocated range
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:37:54: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::AllocArrayRange(
    DWORD dwSize,
    PDWORD pdwIndex)
{
    HRESULT hr;

    _ASSERT(dwSize);
    _ASSERT(pdwIndex);

    AcquireSpinLock(&m_slAllocate);
 
    hr = ReAllocArrayIfNecessary(m_dwArrayClaimedSize + dwSize);

    if(SUCCEEDED(hr)) {
        *pdwIndex = m_dwArrayClaimedSize;
        m_dwArrayClaimedSize += dwSize;
    }

    ReleaseSpinLock(&m_slAllocate);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CSimpArray::ReAllocArrayIfNecessary
//
// Synopsis: Grow the array size if necessary
//           Not thread safe; locking must be done outside
//
// Arguments:
//  dwSize: New size desired
//
// Returns:
//  S_OK: Success, array grown
//  S_FALSE: Success, not necessary to grow array
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 13:56:16: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::ReAllocArrayIfNecessary(
    DWORD dwSize)
{
    DWORD dwNewSize;
    T *pNewArray;
    T *pOldArray;

    if(dwSize <= m_dwArrayAllocSize)
        return S_FALSE;

    //
    // Calculate new size desired
    //
#ifdef CSIMPARRAY_DOUBLE

    if(m_dwArrayAllocSize == 0) {

        dwNewSize = CSIMPARRAY_DEFAULT_INITIAL_SIZE;

    } else {

        dwNewSize = m_dwArrayAllocSize;

    }

    while(dwNewSize < dwSize)
        dwNewSize *= 2;

#else

    dwNewSize = dwSize;

#endif

    _ASSERT(dwNewSize >= dwSize);

    pNewArray = new T [dwNewSize];

    if(pNewArray == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(pNewArray, m_rgData, sizeof(T) * m_dwArrayAllocSize);

    //
    // pNewArray is valid.  Make the switch now.
    //
    pOldArray = m_rgData;
    m_rgData = pNewArray;
    m_dwArrayAllocSize = dwNewSize;

    //
    // Release old array memory
    //
    delete pOldArray;

    return S_OK;
}


#ifdef NEVER
//+------------------------------------------------------------
//
// Function: Cat_NeverCalled_SimpArrayTemplateDummy
//
// Synopsis: Dummy function that is never called but forces compiler
// to generate code for desired types
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 15:28:37: Created.
//
//-------------------------------------------------------------
#include "smtpevent.h"

VOID Cat_NeverCalled_SimpArrayTemplateDummy()
{
    _ASSERT(0 && "Never call this function!");
    CSimpArray<ICategorizerItem *> csaItem;
    CSimpArray<ICategorizerItemAttributes *> csaItemAttributes;

    csaItem.Initialize(0);
    csaItemAttributes.Initialize(0);
    csaItem.Add(NULL);
    csaItemAttributes.Add(NULL);
    csaItem.AddArray(0, NULL);
    csaItemAttributes.AddArray(0, NULL);
}
#endif //NEVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\address.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: address.cpp
//
// Contents: CABContext
//
// Classes:
//   CABContext
//
// Functions:
//   DllMain
//   CABContext::ChangeConfig
//
// History:
//
//-------------------------------------------------------------

#include "precomp.h"
#include "abtype.h"
#include "ccat.h"
#include "ccatfn.h"

//+------------------------------------------------------------
//
// Function: CABContext::ChangeConfig
//
// Synopsis: Changes a context's CCategorizer configuration by
//           constructing a new CCategorizer with thew new config
//
// Arguments:
//  pConfigInfo: the new config parameters.  The struct may be changed
//               -- parameters not specfied will be copied from the
//               old CCat
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  Error from CCategorizer::Init
//
// History:
// jstamerj 1998/09/02 12:13:29: Created.
//
//-------------------------------------------------------------
HRESULT CABContext::ChangeConfig(
    PCCATCONFIGINFO pConfigInfo)
{
    HRESULT hr = S_OK;
    CCategorizer *pCCatNew = NULL;
    CCategorizer *pCCatOld = NULL;
    DWORD dwItemProps, dwLRProps;
    
    _ASSERT(pConfigInfo);

    //
    // Create a new CCategorizer object for the new config
    //
    pCCatNew = new CCategorizer();
    if(pCCatNew == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //
    // The context should hold one refcount of the
    // CCategorizer
    //
    pCCatNew->AddRef();

    //
    // Swap the old CCat with the new one
    // Since we need to get old paramters from pCCatOld and pCCatNew
    // isn't ready until it's been initizled, we need to call
    // Initialize inside the lock
    //
    m_CCatLock.ExclusiveLock();

    pCCatOld = m_pCCat;
    if(pCCatOld) {
        //
        // Merge in old parameters
        //
        PCCATCONFIGINFO pConfigInfoOld;
        
        pConfigInfoOld = pCCatOld->GetCCatConfigInfo();
        _ASSERT(pConfigInfoOld);

        MergeConfigInfo(pConfigInfo, pConfigInfoOld);

        dwItemProps = pCCatOld->GetNumCatItemProps();
        dwLRProps = pCCatOld->GetNumCatListResolveProps();

    } else {
        //
        // Default parameters
        //
        dwItemProps = ICATEGORIZERITEM_ENDENUMMESS + NUM_SYSTEM_CCATADDR_PROPIDS;
        dwLRProps = 0;
    }
    //
    // Do not allow config changes if we are shutting down
    //
    if(pCCatOld && (pCCatOld->fIsShuttingDown())) {

        hr = CAT_E_SHUTDOWN;

    } else {
        //
        // Initialize the new ccategorizer
        //
        hr = pCCatNew->Initialize(
            pConfigInfo,
            dwItemProps,
            dwLRProps);
        
        if(SUCCEEDED(hr)) {

            m_pCCat = pCCatNew;
        }
    }
    m_CCatLock.ExclusiveUnlock();

    if(SUCCEEDED(hr) && pCCatOld) {
        //
        // Release the old CCat outside the lock
        //
        pCCatOld->Release();
    }

 CLEANUP:
    if(FAILED(hr) && pCCatNew) {

        pCCatNew->Release();
    }
    return hr;
}


//+------------------------------------------------------------
//
// Function: CABContext::MergeConfigInfo
//
// Synopsis: Any parameters not already specified in pConfigInfoDest
// will be copied over if they exist in pConfigInfoSrc
//
// Arguments:
//  pConfigInfoDest: config info to add to
//  pConfigInfoSrc:  config info to add from
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/15 16:43:20: Created.
//
//-------------------------------------------------------------
VOID CABContext::MergeConfigInfo(
    PCCATCONFIGINFO pConfigInfoDest,
    PCCATCONFIGINFO pConfigInfoSrc)
{
    _ASSERT(pConfigInfoDest);
    _ASSERT(pConfigInfoSrc);

    //
    // Do the same thing for each struct member...copy it if it
    // doesn't already exist
    //
    
    #define MERGEMEMBER(flag, member) \
        if( (!(pConfigInfoDest->dwCCatConfigInfoFlags & flag)) && \
            (pConfigInfoSrc->dwCCatConfigInfoFlags & flag)) { \
            pConfigInfoDest->member = pConfigInfoSrc->member; \
            pConfigInfoDest->dwCCatConfigInfoFlags |= flag; \
        }

    //
    // If CCAT_CONFIG_INFO_ALLCATVALUES is set, do NOT merge values
    // set in SMTP_SERVER_INSTANCE::GetCatInfo -- ALLCATVALUES
    // indicates all cat values have been attempted to be read...if
    // the flag is not there, it means use default values, NOT merge
    // in exsiting values
    //
    if((pConfigInfoDest->dwCCatConfigInfoFlags &
        CCAT_CONFIG_INFO_DEFAULT) == 0) {

        MERGEMEMBER( CCAT_CONFIG_INFO_ENABLE, dwEnable );
        MERGEMEMBER( CCAT_CONFIG_INFO_FLAGS, dwCatFlags );
        MERGEMEMBER( CCAT_CONFIG_INFO_PORT, dwPort );
        MERGEMEMBER( CCAT_CONFIG_INFO_ROUTINGTYPE, pszRoutingType );
        MERGEMEMBER( CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain );
        MERGEMEMBER( CCAT_CONFIG_INFO_USER, pszUser );
        MERGEMEMBER( CCAT_CONFIG_INFO_PASSWORD, pszPassword );
        MERGEMEMBER( CCAT_CONFIG_INFO_BINDTYPE, pszBindType );
        MERGEMEMBER( CCAT_CONFIG_INFO_SCHEMATYPE, pszSchemaType );
        MERGEMEMBER( CCAT_CONFIG_INFO_HOST, pszHost );
        MERGEMEMBER( CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext );
    }
    //
    // The following paramaters are not official "msgcat" parameters,
    // so we merge them in on every config change.
    //
    MERGEMEMBER( CCAT_CONFIG_INFO_DEFAULTDOMAIN, pszDefaultDomain );
    MERGEMEMBER( CCAT_CONFIG_INFO_ISMTPSERVER, pISMTPServer );
    MERGEMEMBER( CCAT_CONFIG_INFO_IDOMAININFO, pIDomainInfo );
    MERGEMEMBER( CCAT_CONFIG_INFO_VSID, dwVirtualServerID );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\cat.cpp ===
/************************************************************
 * FILE: cat.cpp
 * PURPOSE: Here lies the code for the exported function calls
 *          of the message categorizer
 * HISTORY:
 *  // jstamerj 980211 13:52:50: Created
 ************************************************************/
#include "precomp.h"
#include "catutil.h"
#include "address.h"

/************************************************************
 * FUNCTION: CatInit
 * DESCRIPTION: Initialzies a virtual Categorizer.
 * PARAMETERS:
 *   pszConfig: Indicates where to find configuration defaults
 *              Config info found in key
 *              HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
 *              \PlatinumIMC\CatSources\szConfig
 *
 *   phCat:    Pointer to a handle.  Upon successfull initializtion,
 *             handle to use in subsequent Categorizer calls will be
 *             plcaed there.
 *
 *   pAQConfig: pointer to an AQConfigInfo structure containing
 *              per virtual server message cat parameters
 *
 *   pfn: Service routine for periodic callbakcs if any time consuming
 *        operations are performed
 *
 *   pServiceContext: Context for the pfn function.
 *
 *   pISMTPServer: ISMTPServer interface to use for triggering server
 *                 events for this virtual server
 *
 *   pIDomainInfo: pointer to an interface that contains domain info
 *
 *   dwVirtualServerInstance: Virtual Server ID
 *
 * Return value: S_OK if everything is initialized okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:26: Created
 *   // jstamerj 1998/06/25 12:25:34: Added AQConfig/IMSTPServer.
 *
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatInit(
    IN  AQConfigInfo *pAQConfig,
    IN  PCATSRVFN_CALLBACK pfn,
    IN  PVOID pvServiceContext,
    IN  ISMTPServer *pISMTPServer,
    IN  IAdvQueueDomainType *pIDomainInfo,
    IN  DWORD dwVirtualServerInstance,
    OUT HANDLE *phCat)
{
    HRESULT hr;
    CCATCONFIGINFO ConfigInfo;
    CABContext *pABContext = NULL;
    BOOL fGlobalsInitialized = FALSE;

    TraceFunctEnter("CatInit");

    _ASSERT(phCat);

    hr = CatInitGlobals();
    if(FAILED(hr)) {

        FatalTrace(NULL, "CatInitGlobals failed hr %08lx", hr);
        goto CLEANUP;
    }

    fGlobalsInitialized = TRUE;

    //
    // Fill in the config info struct based on AQConfigInfo only
    //
    hr = GenerateCCatConfigInfo(
        &ConfigInfo,
        pAQConfig,
        pISMTPServer,
        pIDomainInfo,
        &dwVirtualServerInstance);

    pABContext = new CABContext;
    if(pABContext == NULL) {
        FatalTrace(NULL, "Out of memory allocating CABContext");
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    hr = pABContext->ChangeConfig(&ConfigInfo);
    if(FAILED(hr)) {
        FatalTrace(NULL, "ChangeConfig failed hr %08lx", hr);
        goto CLEANUP;
    }

    *phCat = (HANDLE) pABContext;

 CLEANUP:
    if(FAILED(hr)) {

        if(pABContext)
            delete pABContext;

        if(fGlobalsInitialized) {

            if (ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) {

                CatLogEvent(
                    ConfigInfo.pISMTPServer,
                    CAT_EVENT_CANNOT_START,     // Event ID
                    TRAN_CAT_CATEGORIZER,       // Category
                    0,                          // cSubStrings
                    NULL,                       // rgszSubstrings,
                    EVENTLOG_ERROR_TYPE,        // wType
                    hr,                         // error code
                    LOGEVENT_LEVEL_MEDIUM,      // iDebugLevel
                    "",                         // szKey
                    LOGEVENT_FLAG_ALWAYS        // dwOptions
                    );
            }

            CatDeinitGlobals();
        }
    }

    DebugTrace(NULL, "CatInit returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CatChangeConfig
//
// Synopsis: Changes the configuration of a virtual categorizer
//
// Arguments:
//   hCat: handle of virtual categorizer
//   pAQConfig: AQConfigInfo pointer
//   pISMTPServer: ISMTPServer to use
//   pIDomainInfo: interface that contains domain information
//
//   Flags for dwMsgCatFlags in AQConfigInfo
//     MSGCATFLAG_RESOLVELOCAL             0x00000001
//     MSGCATFLAG_RESOLVEREMOTE            0x00000002
//     MSGCATFLAG_RESOLVESENDER            0x00000004
//     MSGCATFLAG_RESOLVERECIPIENTS        0x00000008
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: Invalid hCat or pAQConfig
//
// History:
// jstamerj 980521 15:47:42: Created.
//
//-------------------------------------------------------------
CATEXPDLLCPP HRESULT CATCALLCONV CatChangeConfig(
    IN HANDLE hCat,
    IN AQConfigInfo *pAQConfig,
    IN ISMTPServer *pISMTPServer,
    IN IAdvQueueDomainType *pIDomainInfo)
{
    HRESULT hr;
    CCATCONFIGINFO ConfigInfo;

    TraceFunctEnterEx((LPARAM)hCat, "CatChangeConfig");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE) ||
       (pAQConfig == NULL)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    // Check to see if any cat flags are even set here...
    if(pAQConfig->dwAQConfigInfoFlags & CAT_AQ_CONFIG_INFO_CAT_FLAGS) {

        //
        // Fill in the config info struct based on AQConfigInfo only
        //
        hr = GenerateCCatConfigInfo(
            &ConfigInfo,
            pAQConfig,
            pISMTPServer,
            pIDomainInfo,
            NULL);

        if(FAILED(hr)) {
            ErrorTrace(NULL, "GenerateCCatConfigInfo returned hr %08lx", hr);
            TraceFunctLeave();
            return hr;
        }

        CABContext *pABCtx = (CABContext *) hCat;

        TraceFunctLeaveEx((LPARAM)hCat);
        return pABCtx->ChangeConfig(&ConfigInfo);

    } else {
        //
        // No revelant categorizer changes detected
        //
        return S_OK;
    }
}

/************************************************************
 * FUNCTION: CatTerm
 * DESCRIPTION: Called when user wishes to terminate categorizer
 *              opertions with this handle
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatTerm(HANDLE hCat)
{
    TraceFunctEnterEx((LPARAM)hCat, "CatTerm");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
    } else {
        CABContext *pABContext = (CABContext *) hCat;
        delete pABContext;
    }
    CatDeinitGlobals();
    TraceFunctLeave();
}

/************************************************************
 * FUNCTION: CatMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface for message to categorize
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *
 * Return value:
 *  S_OK: Success, will call async completion
 *  Other error: Unable to asynchronously complete the categorization
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatMsg(HANDLE hCat, /* IN */ IUnknown *pIMsg, PFNCAT_COMPLETION pfn, LPVOID pContext)
{
    HRESULT hr;

    CABContext *pABCtx = (CABContext *) hCat;
    CCategorizer *pCCat = NULL;
    PCATMSG_CONTEXT pCatContext = NULL;
    BOOL fAsync = FALSE;

    TraceFunctEnterEx((LPARAM)hCat, "CatMsg");

    _ASSERT(pIMsg);
    _ASSERT(pfn);

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pCCat = pABCtx->AcquireCCategorizer();
    _ASSERT(pCCat);

    if(pCCat == NULL || !pCCat->IsCatEnabled()) {

#ifdef PLATINUM
        //
        // Return retry code for benefit of store driver so that message
        // is put in the precat queue instead of being routed to the  MTA
        // that would happen if we returned hr = S_OK. This should only
        // happen in Platinum's phatq.dll and not in aqueue.dll.
        //
        hr = CAT_E_RETRY;
#else
        //
        // Categorization is disabled on this virtual server.  Just call
        // the completion routine inline.
        //
       _VERIFY( SUCCEEDED( pfn(
           S_OK,
           pContext,
           pIMsg,
           NULL)));
        hr = S_OK;
#endif

        goto CLEANUP;
    }

    //
    // Check and see if we really need to categorize this message
    //
    // Has categorization already been done?
    //
    hr = CheckMessageStatus(pIMsg);

    if(hr == S_FALSE) {

        DebugTrace((LPARAM)hCat, "This message has already been categorized.");
        //
        // Call completion routine directly
        //
        _VERIFY( SUCCEEDED( pfn(
            S_OK,
            pContext,
            pIMsg,
            NULL)));

        hr = S_OK;
        goto CLEANUP;

    } else if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "CheckMessageStatus failed hr %08lx", hr);
        goto CLEANUP;
    }


    pCatContext = new CATMSG_CONTEXT;
    if(pCatContext == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

#ifdef DEBUG
    pCatContext->lCompletionRoutineCalls = 0;
#endif

    pCatContext->pCCat = pCCat;
    pCatContext->pUserContext = pContext;
    pCatContext->pfnCatCompletion = pfn;

    hr = pCCat->AsyncResolveIMsg(
        pIMsg,
        CatMsgCompletion,
        pCatContext);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "AsyncResolveIMsg failed, hr %08lx", hr);
        goto CLEANUP;
    }
    fAsync = TRUE;
    _ASSERT(hr == S_OK);

 CLEANUP:
    //
    // If we're not async, cleanup.  Else, the CatMsgCompletion will
    // clean this stuff up
    //
    if(fAsync == FALSE) {
        //
        // Release the CCategorizer object
        //
        if(pCCat)
            pCCat->Release();
        if(pCatContext)
            delete pCatContext;
    }
    DebugTrace((LPARAM)hCat, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)hCat);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CatMsgCompletion
//
// Synopsis: This is a wrapper function for AQueue's CatCompletion.
//
// Arguments:
//
// Returns:
//  Result of completion routine
//
// History:
// jstamerj 1998/08/03 19:28:32: Created.
//
//-------------------------------------------------------------
HRESULT CatMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
  HRESULT hrResult;
  PCATMSG_CONTEXT pCatContext = (PCATMSG_CONTEXT)pContext;
#ifdef DEBUG
  _ASSERT((InterlockedIncrement(&(pCatContext->lCompletionRoutineCalls)) == 1) &&
          "Possible out of style wldap32.dll detected");
#endif
  _ASSERT(ISHRESULT(hr));

  TraceFunctEnter("CatMsgCompletion");

  hrResult = pCatContext->pfnCatCompletion(
      hr,
      pCatContext->pUserContext,
      pIMsg,
      rgpIMsg);

  //
  // Release the reference to CCategorizer added in CatMsg
  //
  pCatContext->pCCat->Release();

  delete pCatContext;

  TraceFunctLeave();
  return hrResult;
}


/************************************************************
 * FUNCTION: CatDLMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface to categorize -- each DL should be a recip
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *   fMatchOnly: Stop resolving when a match is found?
 *   CAType:   The address type of pszAddress
 *   pszAddress: THe address you are looking for
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatDLMsg (
    /* IN  */ HANDLE hCat,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ PFNCAT_DLCOMPLETION pfn,
    /* IN  */ LPVOID pUserContext,
    /* IN  */ BOOL fMatchOnly,
    /* IN  */ CAT_ADDRESS_TYPE CAType,
    /* IN  */ LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    PCATDLMSG_CONTEXT pContext = NULL;
    CABContext *pABCtx = (CABContext *) hCat;

    TraceFunctEnterEx((LPARAM)hCat, "CatDLMsg");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    pContext = new CATDLMSG_CONTEXT;
    if(pContext == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    pContext->pCCat = pABCtx->AcquireCCategorizer();
    _ASSERT(pContext->pCCat);

    pContext->pUserContext = pUserContext;
    pContext->pfnCatCompletion = pfn;
    pContext->fMatch = FALSE;

    _VERIFY(SUCCEEDED(
        pContext->pCCat->AsyncResolveDLs(
            pImsg,
            CatDLMsgCompletion,
            pContext,
            fMatchOnly,
            &(pContext->fMatch),
            CAType,
            pszAddress)));

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "calling completion with hr %08lx", hr);
        //
        // Call completion routine directly
        //
        _VERIFY( SUCCEEDED( pfn(
            hr,
            pUserContext,
            pImsg,
            FALSE)));

        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();

            delete pContext;
        }
    }
    TraceFunctLeaveEx((LPARAM)hCat);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CatDLMsgCompletion
//
// Synopsis: handle completion of a DL expansion
//
// Arguments:
//  hrStatus: resolution status
//  pContext: context passed to CatDLMsg
//  pIMsg: the categorized mailmsg
//  rgpIMsg: should always be NULL
//
// Returns:
//  the return value of the user completion routine
//
// History:
// jstamerj 1998/12/07 17:46:46: Created.
//
//-------------------------------------------------------------
HRESULT CatDLMsgCompletion(
    HRESULT hrStatus,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **prgpIMsg)
{
    HRESULT hr;
    PCATDLMSG_CONTEXT pCatContext;

    TraceFunctEnter("CatDLMsgCompletion");

    pCatContext = (PCATDLMSG_CONTEXT) pContext;

    _ASSERT(pCatContext);
    _ASSERT(prgpIMsg == NULL);

    hr = pCatContext->pfnCatCompletion(
        hrStatus,
        pCatContext->pUserContext,
        pIMsg,
        pCatContext->fMatch);

    pCatContext->pCCat->Release();

    delete pCatContext;

    DebugTrace(NULL, "returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}


/************************************************************
 * FUNCTION: CatCancel
 * DESCRIPTION: Cancels pending searches for this hCat.  User's
 *              completion routine will be called with an error for
 *              each pending message.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:52:10: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatCancel(/* IN  */ HANDLE hCat)
{
    TraceFunctEnterEx((LPARAM)hCat, "CatCancel");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    CCategorizer *pCCat;
    CABContext *pABCtx = (CABContext *) hCat;

    pCCat = pABCtx->AcquireCCategorizer();

    if(pCCat) {

      pCCat->Cancel();

      pCCat->Release();
    }
    TraceFunctLeave();
    return S_OK;
}

/************************************************************
 * FUNCTION: CatPrepareForShutdown
 * DESCRIPTION: Begin shutdown for this virtual categorizer (hCat).
 *              Stop accepting messages for categorization and cancel
 *              pending categorizations.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 1999/07/19 22:35:17: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatPrepareForShutdown(/* IN  */ HANDLE hCat)
{
    TraceFunctEnterEx((LPARAM)hCat, "CatPrepareForShutdown");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");

    } else {

        CCategorizer *pCCat;
        CABContext *pABCtx = (CABContext *) hCat;

        pCCat = pABCtx->AcquireCCategorizer();

        if(pCCat) {

            pCCat->PrepareForShutdown();
            pCCat->Release();
        }
    }
    TraceFunctLeaveEx((LPARAM)hCat);
}

/************************************************************
 * FUNCTION: CatVerifySMTPAddress
 * DESCRIPTION: Verifies a the address corresponds to a valid user or DL
 * PARAMETERS:
 *  hCat:       Categorizer handle received from CatInit
 *  szSMTPAddr  SMTP Address to lookup (ex: "user@domain")
 *
 * Return Values:
 *  S_OK            User exists
 *  CAT_I_DL        This is a distribution list
 *  CAT_I_FWD       This user has a forwarding address
 *  CAT_E_NORESULT  There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatVerifySMTPAddress(
  /* IN  */ HANDLE hCat,
  /* IN  */ LPTSTR szSMTPAddr)
{
    //$$TODO: Implement this function.
    // Pretend this is a valid user for now.
    return S_OK;
}

/************************************************************
 * FUNCTION: CatGetForwaringSMTPAddress
 * DESCRIPTION: Retreive a user's forwarding address.
 * PARAMETERS:
 *  hCat:           Categorizer handle received from CatInit
 *  szSMTPAddr:     SMTP Address to lookup (ex: "user@domain")
 *  pdwcc:          Size of forwarding address buffer in Chars
 *                  (This is set to actuall size of forwarding address
 *                   string (including NULL terminator) on exit)
 *  szSMTPForward:  Buffer where retreived forwarding SMTP address
 *                  will be copied. (can be NULL if *pdwcc is zero)
 *
 * Return Values:
 *  S_OK            Success
 *  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
 *                  *pdwcc was not large enough to hold the forwarding
 *                  address string.
 * CAT_E_DL         This is a distribution list.
 * CAT_E_NOFWD      This user does not have a forwarding address.
 * CAT_E_NORESULT   There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatGetForwardingSMTPAddress(
  /* IN  */    HANDLE  hCat,
  /* IN  */    LPCTSTR szSMTPAddr,
  /* IN,OUT */ PDWORD  pdwcc,
  /* OUT */    LPTSTR  szSMTPForward)
{
    //$$TODO: Implement this function
    // Pretend this is a valid user with no forwarding address for now.
    return CAT_E_NOFWD;
}


//+------------------------------------------------------------
//
// Function: CheckMessageStatus
//
// Synopsis: Check to see if this message has already been categorized
//
// Arguments: pIMsg: IUnknown to the mailmsg
//
// Returns:
//  S_OK: Success, not categorized yet
//  S_FALSE: Succes, already categorized
//  or error from MailMsg
//
// History:
// jstamerj 1998/08/03 19:15:49: Created.
//
//-------------------------------------------------------------
HRESULT CheckMessageStatus(
    IUnknown *pIMsg)
{
    HRESULT hr;
    IMailMsgProperties *pIProps = NULL;
    DWORD dwMsgStatus;

    _ASSERT(pIMsg);

    hr = pIMsg->QueryInterface(
        IID_IMailMsgProperties,
        (PVOID *) &pIProps);

    if(FAILED(hr))
        return hr;

    hr = pIProps->GetDWORD(
        IMMPID_MP_MESSAGE_STATUS,
        &dwMsgStatus);

    if(hr == CAT_IMSG_E_PROPNOTFOUND) {
        //
        // Assume the message has not been categorized
        //
        hr = S_OK;

    } else if(SUCCEEDED(hr)) {
        //
        // If status is >= CATEGORIZED, this message has already been categorized
        //
        if(dwMsgStatus >= MP_STATUS_CATEGORIZED) {

            hr = S_FALSE;

        } else {

            hr = S_OK;
        }
    }
    pIProps->Release();

    return hr;
}


//+------------------------------------------------------------
//
// Function: GenerateCCatConfigInfo
//
// Synopsis: Translate an AQConfigInfo and interface parameters into a
//           CCatConfigInfo.  No memory allocations are done and no
//           interfaces are AddRef'd.
//
// Arguments:
//  pCatConfig: CCATCONFIGINFO struct to fill in
//  pAQConfig: AQConfigInfo struct to get paramters from (can be NULL)
//  pISMTPServer: ISMTPServer to use (can be NULL)
//  pIDomainInfo: IAdvQueueDomainInfo to use (can be NULL)
//  pdwVSID: Pointer to DWORD containing the virtual server ID or NULL if not specified
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/14 19:14:52: Created.
//
//-------------------------------------------------------------
HRESULT GenerateCCatConfigInfo(
    PCCATCONFIGINFO pCatConfig,
    AQConfigInfo *pAQConfig,
    ISMTPServer *pISMTPServer,
    IAdvQueueDomainType *pIDomainInfo,
    DWORD *pdwVSID)
{
    HRESULT     hr      =   S_OK;

    TraceFunctEnter("GenerateCCatConfigInfo");

    _ASSERT(pCatConfig);

    ZeroMemory(pCatConfig, sizeof(CCATCONFIGINFO));

    //
    // Copy the interface pointers first
    //
    if(pISMTPServer) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_ISMTPSERVER;
        pCatConfig->pISMTPServer = pISMTPServer;
    }

    if(pIDomainInfo) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_IDOMAININFO;
        pCatConfig->pIDomainInfo = pIDomainInfo;
    }

    if(pdwVSID) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_VSID;
        pCatConfig->dwVirtualServerID = *pdwVSID;
    }

    if(pAQConfig) {
        //
        // Copy over flags without struct members
        //
        if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_DEFAULT) {
            pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_DEFAULT;
        }

        //
        // Copy over the struct members if specified
        //
        #define COPYMEMBER( AQFlag, AQMember, CatFlag, CatMember ) \
            if(pAQConfig->dwAQConfigInfoFlags & AQFlag) { \
                pCatConfig->dwCCatConfigInfoFlags |= CatFlag; \
                pCatConfig->CatMember = pAQConfig->AQMember; \
            }

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_DOMAIN, szMsgCatDomain,
                    CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_USER, szMsgCatUser,
                    CCAT_CONFIG_INFO_USER, pszUser );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_PASSWORD, szMsgCatPassword,
                    CCAT_CONFIG_INFO_PASSWORD, pszPassword );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_BINDTYPE, szMsgCatBindType,
                    CCAT_CONFIG_INFO_BINDTYPE, pszBindType );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE, szMsgCatSchemaType,
                    CCAT_CONFIG_INFO_SCHEMATYPE, pszSchemaType );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_HOST, szMsgCatHost,
                    CCAT_CONFIG_INFO_HOST, pszHost );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_PORT, dwMsgCatPort,
                    CCAT_CONFIG_INFO_PORT, dwPort);

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_FLAGS, dwMsgCatFlags,
                    CCAT_CONFIG_INFO_FLAGS, dwCatFlags );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_ENABLE, dwMsgCatEnable,
                    CCAT_CONFIG_INFO_ENABLE, dwEnable );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT, szMsgCatNamingContext,
                    CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_TYPE, szMsgCatType,
                    CCAT_CONFIG_INFO_ROUTINGTYPE, pszRoutingType );

        COPYMEMBER( AQ_CONFIG_INFO_DEFAULT_DOMAIN, szDefaultLocalDomain,
                    CCAT_CONFIG_INFO_DEFAULTDOMAIN, pszDefaultDomain );

    }

    return hr;
}


//+------------------------------------------------------------
//
// Function: CatGetPerfCounters
//
// Synopsis: Retrieve the categorizer performance counter block
//
// Arguments:
//  pCatPerfBlock: struct to fill in with counter values
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1999/02/26 14:53:21: Created.
//
//-------------------------------------------------------------
HRESULT CatGetPerfCounters(
    HANDLE hCat,
    PCATPERFBLOCK pCatPerfBlock)
{
    CABContext *pABCtx = (CABContext *) hCat;
    CCategorizer *pCCat = NULL;

    TraceFunctEnterEx((LPARAM)hCat, "CatGetPerfBlock");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE) ||
       (pCatPerfBlock == NULL)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    pCCat = pABCtx->AcquireCCategorizer();

    if(pCCat == NULL) {

        ZeroMemory(pCatPerfBlock, sizeof(CATPERFBLOCK));

    } else {

        pCCat->GetPerfCounters(
            pCatPerfBlock);
        pCCat->Release();
    }
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CatLogEvent
//
// Synopsis: Log an event to the event log
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for logging
//
// Returns:
//  S_OK: Success
//
// History:
// dbraun 2000/09/13 : Created.
//
//-------------------------------------------------------------
HRESULT CatLogEvent(
    ISMTPServer              *pISMTPServer,
    DWORD                    idMessage,
    WORD                     idCategory,
    WORD                     cSubstrings,
    LPCSTR                   *rgszSubstrings,
    WORD                     wType,
    DWORD                    errCode,
    WORD                     iDebugLevel,
    LPCSTR                   szKey,
    DWORD                    dwOptions,
    DWORD                    iMessageString,
    HMODULE                  hModule)
{
    HRESULT         hr              = S_OK;
    ISMTPServerEx   *pISMTPServerEx = NULL;

    TraceFunctEnter("CatLogEvent");

    // Get the ISMTPServerEx interface for triggering log events
    hr = pISMTPServer->QueryInterface(
        IID_ISMTPServerEx,
        (LPVOID *)&pISMTPServerEx);

    if (FAILED(hr)) {

        ErrorTrace((LPARAM)pISMTPServer, "Unable to QI for ISMTPServerEx 0x%08X",hr);

        //
        //  Don't bubble up this error.  A failure to log is not what the 
        //  caller cares about
        //
        hr = S_OK; 
        pISMTPServerEx = NULL;
    }

    if (pISMTPServerEx) {

        pISMTPServerEx->TriggerLogEvent(
                idMessage,
                idCategory,
                cSubstrings,
                rgszSubstrings,
                wType,
                errCode,
                iDebugLevel,
                szKey,
                dwOptions,
                iMessageString,
                hModule);

        pISMTPServerEx->Release();
    }

    TraceFunctLeave();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\catdebug.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catdebug.cpp
//
// Contents: Code used for debugging specific purposes
//
// Classes: None
//
// Functions:
//
// History:
// jstamerj 1999/08/05 12:02:03: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//
// Global debug lists of various objects
//
#ifdef CATDEBUGLIST
DEBUGOBJECTLIST g_rgDebugObjectList[NUM_DEBUG_LIST_OBJECTS];
#endif //CATDEBUGLIST


//+------------------------------------------------------------
//
// Function: CatInitDebugObjectList
//
// Synopsis: Initialize global debug data -- this should be called
// once before any debug objects are created (DllMain/Process Attach
// is a good place) 
// 
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/03 16:54:08: Created.
//
//-------------------------------------------------------------
VOID CatInitDebugObjectList()
{
#ifdef CATDEBUGLIST
    TraceFunctEnter("CatInitDebugObjectList");
    for(DWORD dw = 0; dw < NUM_DEBUG_LIST_OBJECTS; dw++) {
        InitializeSpinLock(&(g_rgDebugObjectList[dw].spinlock));
        InitializeListHead(&(g_rgDebugObjectList[dw].listhead));
        g_rgDebugObjectList[dw].dwCount = 0;
    }
    TraceFunctLeave();
#endif
} // CatInitDebugObjectList


//+------------------------------------------------------------
//
// Function: CatVrfyEmptyDebugObjectList
//
// Synopsis: DebugBreak if any debug objects have leaked.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/03 16:56:57: Created.
//
//-------------------------------------------------------------
VOID CatVrfyEmptyDebugObjectList()
{
#ifdef CATDEBUGLIST
    TraceFunctEnter("CatDeinitDebugObjectList");
    for(DWORD dw = 0; dw < NUM_DEBUG_LIST_OBJECTS; dw++) {
        if(g_rgDebugObjectList[dw].dwCount != 0) {

            _ASSERT(0 && "Categorizer debug object leak detected");
            ErrorTrace(0, "Categorizer debug object %ld has leaked",
                       dw);
        }
    }
    TraceFunctLeave();
#endif
} // CatDeinitDebugObjectList


//+------------------------------------------------------------
//
// Function: CatDebugBreakPoint
//
// Synopsis: THe categorizer version of DebugBreak()
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/06 16:50:47: Created.
//
//-------------------------------------------------------------
VOID CatDebugBreakPoint()
{
    //
    // Cause an AV instead of calling the real DebugBreak() (since
    // DebugBreak will put Dogfood into the kernel debugger)
    //
    ( (*((PVOID *)NULL)) = NULL);
} // CatDebugBreakPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\address.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: address.h
//
// Contents: 
//
// Classes: CABContext
//
// Functions:
//
// History:
//   jstamerj 1998/02/11 13:57:25: Copeid from routeldp project
//   jstamerj 1998/09/02 12:06:04: Removed CABWrapper/CLDWrapper
//
//-------------------------------------------------------------
#ifndef _ADDRESS_H_
#define _ADDRESS_H_


#include <transmem.h>
#include "ccat.h"
#include "rwex.h"

#define AB_CONTEXT_SIGNATURE            'TCBA'
#define AB_CONTEXT_SIGNATURE_INVALID    'XCBA'

/************************************************************
 * Class: CABContext
 ************************************************************/
//
// The handle passed into Ab functions is really a pointer to one of these
// It holds and manages a pointer to a CCategorizer (one per virtual server)
//
CatDebugClass(CABContext)
{

  public:
    CABContext() {
        m_dwSignature = AB_CONTEXT_SIGNATURE;
        m_pCCat = NULL;
    }

    ~CABContext() {
        //
        // Shutdown the virtual categorizer and wait for all
        // references to it to be released
        //
        if (m_pCCat != NULL)
            m_pCCat->ReleaseAndWaitForDestruction();

        m_dwSignature = AB_CONTEXT_SIGNATURE_INVALID;
    }
    //
    // Retrieve our internal CCategorizer
    //
    CCategorizer *AcquireCCategorizer()
    {
        CCategorizer *pCCat;

        m_CCatLock.ShareLock();
        
        pCCat = m_pCCat;
        pCCat->AddRef();

        m_CCatLock.ShareUnlock();

        return pCCat;
    }

    // change to use a new config
    HRESULT ChangeConfig(
        PCCATCONFIGINFO pConfigInfo);

    //
    // helper routine to change retain old parameters not specified in
    // a new configuration 
    //
    VOID MergeConfigInfo(
        PCCATCONFIGINFO pConfigInfoDest,
        PCCATCONFIGINFO pConfigInfoSrc);

    private:
        // our signature
        DWORD m_dwSignature;
      
        // our virtual categorizer
        CCategorizer *m_pCCat;
  
        // lock to protect multi threaded access to m_pCCat
        CExShareLock m_CCatLock;
};

#endif //_ADDRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\catglobals.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catglobals.cpp
//
// Contents: Utility functions for global variable init/deinit
//
// Functions: CatInitGlobals
//            CatDeinitGlobals
//
// History:
// jstamerj 1999/03/03 12:58:05: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//
// Global variables:
//
CExShareLock     g_InitShareLock;
DWORD            g_InitRefCount = 0;


//+------------------------------------------------------------
//
// Function: CatInitGlobals
//
// Synopsis: Initialize the global variables
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/03 12:59:21: Created.
//
//-------------------------------------------------------------
HRESULT CatInitGlobals()
{
    HRESULT hr = S_OK;
    BOOL fGlobalInit = FALSE;
    BOOL fStoreInit = FALSE;

    g_InitShareLock.ExclusiveLock();

    if(g_InitRefCount == 0) {

        fGlobalInit = TRUE;
     
        hr = CatStoreInitGlobals();
        if(FAILED(hr))
            goto CLEANUP;
        
        fStoreInit = TRUE;
    }

 CLEANUP:
    if(SUCCEEDED(hr)) {
        g_InitRefCount++;
    } else if(FAILED(hr) && fGlobalInit) {
        //
        // Deinitialize everything we initialized
        //
        if(fStoreInit) {
            CatStoreDeinitGlobals();
        }
      
        //
        // Verify that there are no lingering objects
        //
        CatVrfyEmptyDebugObjectList();
    }
    g_InitShareLock.ExclusiveUnlock();

    return hr;
}


//+------------------------------------------------------------
//
// Function: CatDeinitGlobals
//
// Synopsis: Deinitialize the global variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/03 13:02:00: Created.
//
//-------------------------------------------------------------
VOID CatDeinitGlobals()
{
    g_InitShareLock.ExclusiveLock();

    if(g_InitRefCount == 1) {
        //
        // Deinit stuff
        //
        CatStoreDeinitGlobals();

       
        //
        // Verify there are no categorizer objects left in memory
        //
        CatVrfyEmptyDebugObjectList();
    }

    g_InitRefCount--;
    
    g_InitShareLock.ExclusiveUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\catguid.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catguid.cpp
//
// Contents: Small source file where the categorizer related guids will be defined
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1999/01/30 15:44:40: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#define INITGUID
#include <guiddef.h>
#include "smtpevent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\cbifmgr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: cbifmgr.cpp
//
// Contents: Implementation of CBifurcationMgr
//
// Classes:
//   CBifurcationMgr
//
// Functions:
//   CBifurcationMgr::CBifurcationMgr
//   CBifurcationMgr::~CBifurcationMgr
//   CBifurcationMgr::Initialize
//   CBifurcationMgr::GetIMsgCatList
//   CBifurcationMgr::CommitAll
//   CBifurcationMgr::RevertAll
//   CBifurcationMgr::GetAllIMsgs
//   CBifurcationMgr::GetDefaultIMailMsgProperties
//
// History:
// jstamerj 980325 15:59:56: Created.
//
//-------------------------------------------------------------

#include "precomp.h"
#include "cbifmgr.h"


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::CBifurcationMgr
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 16:03:10: Created.
//
//-------------------------------------------------------------
CBifurcationMgr::CBifurcationMgr()
{
    ZeroMemory(m_rgpIMsg, sizeof(m_rgpIMsg));
    ZeroMemory(m_rgpIRecipsAdd, sizeof(m_rgpIRecipsAdd));
    m_dwNumIMsgs = 0;
}


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::~CBifurcationMgr
//
// Synopsis: Release all member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 16:03:35: Created.
//
//-------------------------------------------------------------
CBifurcationMgr::~CBifurcationMgr()
{
    //
    // Release any interfaces we are still holding
    //
    for(DWORD dwCount = 0; dwCount < NUM_ENCODING_PROPS; dwCount++) {
        if(m_rgpIMsg[dwCount]) {
            m_rgpIMsg[dwCount]->Release();
        }
        if(m_rgpIRecipsAdd[dwCount]) {
            m_rgpIRecipsAdd[dwCount]->Release();
        }
    }
}
            


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::Initialize
//
// Synopsis: Increments reference of primary IMsg and stores a pointer
//           to it in member data.
//
// Arguments:
//   pIMsg: pointer to original IMsg object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 16:04:42: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::Initialize(IUnknown *pIMsg)
{
    // assert check: We shouldn't have already been initialized
    _ASSERT(m_rgpIMsg[0] == NULL);
    pIMsg->AddRef();
    m_rgpIMsg[0] = pIMsg;
    m_dwNumIMsgs++; // From zero to one
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::GetIMsgCatList
//
// Synopsis: Given an encoding property, bifurcates the message if
//           necessary and returns the IMailMsgRecipientsAdd interface
//           of the appropriate IMsg
//
// Arguments:
//   encprop: Bifurcation worthy encoding prop of the IMsg the caller
//            desires
//   ppRecipsAdd: Set to a pointer to the desired
//                IMailMsgRecipientsAdd interface.  This is AddRef'd
//                for the caller, so the caller must Release it.
//
// Returns:
//   S_OK: Success
//   E_OUTOFMEMORY: duh
//   Or error from IMsg
//
// History:
// jstamerj 980325 16:11:39: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::GetIMsgCatList(
    ENCODINGPROPERTY encprop,
    IMailMsgRecipientsAdd **ppRecipsAdd)
{
    _ASSERT(encprop < NUM_ENCODING_PROPS);
    HRESULT hr;
    
    // Does IMsg need to be bifurcated?
    if(m_rgpIMsg[encprop] == NULL) {
        // Yes.
        //$$TODO: IMsg bifurcation
        _ASSERT(0 && "Not implemented.");
        m_dwNumIMsgs++;
        // Return some generic error in case someone actually calls us.
        return E_OUTOFMEMORY;
    }

    // Does IRecipsAdd interface exist yet?
    if(m_rgpIRecipsAdd[encprop] == NULL) {
        IMailMsgRecipients *pIRecips;
        IMailMsgRecipientsAdd *pIRecipsAdd;

        // 1) Get IMailMsgRecipients
        hr = m_rgpIMsg[encprop]->QueryInterface( IID_IMailMsgRecipients,
                                                 (LPVOID*)&pIRecips);
        // 2) Alloc new recipient list
        if(SUCCEEDED(hr)) {
            hr = pIRecips->AllocNewList(&pIRecipsAdd);
            m_rgpIRecipsAdd[encprop] = SUCCEEDED(hr) ? pIRecipsAdd : NULL;
        // 3) Release IMailMsgRecipients
            pIRecips->Release();
        }
        if(FAILED(hr))
            return hr;
    }
    // Okay, we either allocated or found an existing add list.
    // Addref and return it.
    *ppRecipsAdd = m_rgpIRecipsAdd[encprop];
    (*ppRecipsAdd)->AddRef();

    return hr;
}


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::CommitAll
//
// Synopsis: Commits all added recipient lists to their IMsgs
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  Or error from IMsg
//
// History:
// jstamerj 980325 16:22:53: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::CommitAll()
{
    HRESULT hr;
    // Commit IMsgs in reverse order so original IMsg will be
    // committed last.  This solves the problem of what do you do if
    // the first 2 IMsgs commit okay but the last one fails? (in this
    // case, the original IMsg has already been altered).  By
    // committing in reverse order, I'll always have the original
    // untouched IMsg until all Bifurcated IMsgs have commited okay.
    
    for(LONG lCount = NUM_ENCODING_PROPS - 1; lCount >= 0; lCount--) {
        if((m_rgpIMsg[lCount]) && (m_rgpIRecipsAdd[lCount])) {
            // Easy as 1,2,3
            // 1) Get original IMailMsgRecipients by QI'ing IMsg
            IMailMsgRecipients *pIMsgRecips;
            hr = m_rgpIMsg[lCount]->QueryInterface( IID_IMailMsgRecipients,
                                                     (LPVOID *)&pIMsgRecips);
            if(SUCCEEDED(hr)) {
                // 2) Call WriteList on IMailMsgRecipients
                hr = pIMsgRecips->WriteList(m_rgpIRecipsAdd[lCount]);
                pIMsgRecips->Release();
                if(SUCCEEDED(hr)) {
                    // 3) Release IRecipsAdd interface
                    m_rgpIRecipsAdd[lCount]->Release();
                    m_rgpIRecipsAdd[lCount] = NULL;
                }
            }
            if(FAILED(hr)) {
                // Stop and return error
                return hr;
            }
        }
    }
    // No errors fall through...
    return S_OK;
}




//+------------------------------------------------------------
//
// Function: CBifurcationMgr::RevertAll
//
// Synopsis: Releases all IMailMsgRecipientsAdd interfaces thus
//           reverting all IMsgs to their original states
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 16:28:17: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::RevertAll()
{
    for(DWORD dwCount = 1; dwCount < NUM_ENCODING_PROPS; dwCount++) {
        if(m_rgpIRecipsAdd[dwCount]) {
            m_rgpIRecipsAdd[dwCount]->Release();
            m_rgpIRecipsAdd[dwCount] = NULL;
        }
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::GetAllIMsgs
//
// Synopsis: Fills in a null terminated array of pointers to IMsgs
//           including our original IMsg and every IMsg we've bifurcated
//
// Arguments:
//   rgpIMsg pointer to array of IMsg pointers
//   cPtrs   size of rpgIMsg array in number of pointers
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): Array size was not
//  large enough
//
// History:
// jstamerj 980325 16:29:06: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::GetAllIMsgs(IUnknown **rgpIMsg, DWORD cPtrs)
{
    if(cPtrs <= m_dwNumIMsgs)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    IUnknown **ppIMsg = rgpIMsg;
    for(DWORD dwCount = 0; dwCount < NUM_ENCODING_PROPS; dwCount++) {
        if(m_rgpIMsg[dwCount]) {
                    *ppIMsg = m_rgpIMsg[dwCount];
                    ppIMsg++;
        }
    }
    // Set the Null terminator pointer
    *ppIMsg = NULL;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CBifurcationMgr::GetDefaultIMailMsgProperties
//
// Synopsis: Retreives the IMailMsgProperties interface of the
//           original IMsg
//
// Arguments:
//   ppIProps: pointer to IMailMsgProperties interface pointer to be set. 
//
// Returns:
//  S_OK: Success
//  Or error from IMsg
//
// History:
// jstamerj 980325 17:05:11: Created.
//
//-------------------------------------------------------------
HRESULT CBifurcationMgr::GetDefaultIMailMsgProperties(
    IMailMsgProperties **ppIProps)
{
    IUnknown *pIMsg;
    pIMsg = GetDefaultIMsg();
    _ASSERT(pIMsg);

    // Transfer our refcount to caller.
    return pIMsg->QueryInterface(IID_IMailMsgProperties,
                                 (LPVOID *)ppIProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccataddr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccataddr.cpp
//
// Contents: Implementation of CCatAddr methods
//
// Classes:
//   CCatAddr
//
// Functions:
//   CCatAddr::CCatAddr
//   CCatAddr::~CCatAddr
//   CCatAddr::HrDispatchQuery
//   CCatAddr::IsAddressLocal
//   CCatAddr::SwitchToAliasedDomain
//
// History:
// jstamerj 980324 19:26:50: Created.
//
//-------------------------------------------------------------

#include "precomp.h"
#include "addr821.hxx"

//+------------------------------------------------------------
//
// Function: CCatAddr::CCatAddr
//
// Synopsis: Initializes member data of CCatAddr
//
// Arguments:
//   pIRC:   pointer to IMsg resolve list context structure
//
// Returns: Nothing
//
// History:
// jstamerj 980324 19:29:07: Created.
//
//-------------------------------------------------------------

CCatAddr::CCatAddr(
    CICategorizerListResolveIMP *pCICatListResolve
)
{
    TraceFunctEnterEx((LPARAM)this,"CCatAddr::CCatAddr");
    _ASSERT(pCICatListResolve != NULL);
    _ASSERT(pCICatListResolve->GetCCategorizer() != NULL);

    m_pCICatListResolve = pCICatListResolve;
    //
    // AddRef here, release in destructor
    //
    m_pCICatListResolve->AddRef();

    m_dwlocFlags = LOCF_UNKNOWN;

    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCatAddr::~CCatAddr()
//
// Synopsis: Releases CCatAddr member data
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 980324 19:31:48: Created.
//
//-------------------------------------------------------------
CCatAddr::~CCatAddr()
{
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::~CCatAddr");
    m_pCICatListResolve->Release();
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::HrGetOrigAddress
//
// Synopsis: Fetches an original address from the IMsg object
//           Addresses are fetched with the following preference:
//           SMTP, X500, X400, Foreign addres type
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: on Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
//    dwcc needs to be at most CAT_MAX_INTERNAL_FULL_EMAIL
//
// History:
// jstamerj 1998/07/30 20:55:46: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetOrigAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    //
    // Array of possible address to retrieve in order of priority:
    //
    CAT_ADDRESS_TYPE *pCAType;
    CAT_ADDRESS_TYPE rgCAType[] = {
        CAT_SMTP,
        CAT_DN,
        CAT_X400,
        CAT_LEGACYEXDN,
        CAT_CUSTOMTYPE,
        CAT_UNKNOWNTYPE         // Must be the last element of the array
    };

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrGetOrigAddress");

    pCAType = rgCAType;

    do {

        hr = GetSpecificOrigAddress(
            *pCAType,
            psz,
            dwcc);

    } while((hr == CAT_IMSG_E_PROPNOTFOUND) && 
            (*(++pCAType) != CAT_UNKNOWNTYPE));

    if(SUCCEEDED(hr)) {

        // Pass back the type found
        *pType = *pCAType;

        DebugTrace((LPARAM)this, "found address type %d", *pType);
        DebugTrace((LPARAM)this, "found address %s", psz);
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetLookupAddresss
//
// Synopsis: Retrieve the address to be looked up in the DS -- this
//           calls HrGetOrigAddress, then switches any alias domain
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/10/28 15:44:45: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetLookupAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "HrGetLookupAddress");
    
    hr = HrGetOrigAddress(psz, dwcc, pType);
    if (FAILED(hr)){
        DebugTrace((LPARAM)this, "HrGetOrigAddress failed hr =  %08lx", hr);
        goto Exit ;
    }

    hr = HrSwitchToAliasedDomain(*pType, psz, dwcc);
    if (FAILED(hr)){
        DebugTrace((LPARAM)this, "HrSwitchToAliasedDomain failed hr =  %08lx", hr);
        goto Exit ;
    }
    //
    // Custom type addresses can contain extended characters so
    // convert ANSI 1252 -> UTF8
    //
    if (*pType == CAT_CUSTOMTYPE){
              
        hr = HrCodePageConvert (
            1252,               // source code page
            psz,                //Source address
            CP_UTF8,            // target code page
            psz,                //Target address
            (int) dwcc) ;       //cbytes of preallocated buffer for target address

        if (FAILED(hr)){
            DebugTrace((LPARAM)this, "HrCodePageConvert failed hr =  %08lx", hr);
            goto Exit ;
        }
        
    }

Exit:

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    
    return hr;
}

//
// ------------------------------------------------------------
// Async lookup/completion routines:
//


//+------------------------------------------------------------
//
// Function: CCatAddr::HrDispatchQuery()
//
// Synopsis: Dispatch a query to the store for this address
//
// Arguments: None
//
// Returns:
//  S_OK on Success, error hresult on error.
//
// History:
// jstamerj 980324 19:33:28: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrDispatchQuery()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrDispatchQuery");
    //
    // Only dispatch queries when the list resolve status is OK
    //
    hr = GetListResolveStatus();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Not dispatching lookup because list resolve has failed");
        goto CLEANUP;
    }
    //
    // Assume LookupEntryAsync will succeed and increment pending IO
    // count here
    //
    IncPendingLookups();

    hr =  m_pCICatListResolve->GetEmailIDStore()->LookupEntryAsync(
        this,
        m_pCICatListResolve->GetResolveListContext());
    
    if(FAILED(hr))
        //
        // Wrong assumption...it failed
        //
        DecrPendingLookups();

    if(SUCCEEDED(hr))

        INCREMENT_COUNTER(AddressLookups);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: HrValidateAddress
//
// Synopsis: Given an address type and address, make sure the address
//           is legal AND has a domain part
//
// Arguments:
//   CAType: The address type
//   pszAddress: The address string
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS
//
// History:
// jstamerj 1998/08/18 14:25:58: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrValidateAddress(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrValidateAddress");

    _ASSERT(pszAddress);

    if(CAType != CAT_SMTP) {
        //
        // Assume non-SMTP types are correct
        //
        hr = S_OK;

    } else {
        DWORD dwLen = lstrlen(pszAddress);

        //
        // Run it through the addr821 library
        //
        if(Validate821Address(
            pszAddress,
            dwLen)) {
            
            //
            // it's valid, but does it have a domain?
            //
            LPSTR pszDomain;

            if(Get821AddressDomain(
                pszAddress,
                dwLen,
                &pszDomain) && pszDomain) {
                //
                // Yes, it has a domian part
                //
                hr = S_OK;

            } else {
                //
                // Valid address with no domain
                //
                ErrorTrace((LPARAM)this, "Detected legal address without a domain: %s", 
                           pszAddress);
                hr = CAT_E_ILLEGAL_ADDRESS;
            }

        } else {
            //
            // Validate821Address failed
            //
            ErrorTrace((LPARAM)this, "Detected ILLEGAL address: %s",
                       pszAddress);

            hr = CAT_E_ILLEGAL_ADDRESS;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
            

//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetAddressLocFlags
//
// Synopsis: Given an address, will determine wether or not the
// address SHOULD be local (wether or not the domain is local/alias/whatnot)
//
// Arguments:
//   szAddress: Address string
//   CAType:    Address type of szAddress
//   pfloctype: Pointer to loctype enumeration to set
//   pdwDomainOffset: Pointer to dword to set to the offset of domain
//                    part of address string
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: szAdderss is not a valid CAType address
//
// History:
// jstamerj 980324 19:35:15: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetAddressLocFlags(
    LPTSTR szAddress,
    CAT_ADDRESS_TYPE CAType,
    DWORD *pdwlocflags,
    DWORD *pdwDomainOffset)
{
    HRESULT hr;
    
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::IsAddressLocal");
    _ASSERT(szAddress);
    _ASSERT(pdwlocflags);

    if(CAType == CAT_SMTP) {

        BOOL f;
        LPSTR pszDomain;
        //
        // Get the address domain
        //
        f = Get821AddressDomain(
            szAddress,
            lstrlen(szAddress),
            &pszDomain);

        if(f == FALSE) {

            ErrorTrace((LPARAM)this, "Illegal address: %s", szAddress);
            
            return CAT_E_ILLEGAL_ADDRESS;
        }

        if(pszDomain == NULL) {
            //
            // Assume any SMTP address without a domain is the same as
            // the default local domain 
            //
            DebugTrace((LPARAM)this, "Assuming \"%s\" is local", szAddress);

            pszDomain = GetCCategorizer()->GetDefaultSMTPDomain();

            *pdwDomainOffset = 0;

        } else {
            //
            // Remember the offset into the SMTP address where the domain
            // is
            //
            if(pdwDomainOffset)
                *pdwDomainOffset = (DWORD)(pszDomain - szAddress);
        }

        //
        // Lookup the domain and see if it's local
        //
        hr = HrGetSMTPDomainLocFlags(pszDomain, pdwlocflags);

        if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetSMTPDomainLocFlags failed hr %08lx", hr);

            return hr;
        }

    } else {

        DebugTrace((LPARAM)this, "Assuming \"%s\":%d is local",
                   szAddress, CAType);
        //
        //$$TODO: Check locality on other address types
        //
        *pdwlocflags = LOCF_UNKNOWNTYPE;
    }

    DebugTrace((LPARAM)this, "szAddress = %s", szAddress);
    DebugTrace((LPARAM)this, "CAType = %d", CAType);
    DebugTrace((LPARAM)this, "loctype = %08lx", *pdwlocflags);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::GetSMTPDomainLocFlags
//
// Synopsis: Figure out the local type of an SMTP domain
//
// Arguments:
//  pszDomain: SMTP domain string
//  pdwlocflags: Pointer to DWORD falgs to set
//
// Returns:
//  S_OK: Success
//  error from IAdvQueueDomainType
//
// History:
// jstamerj 1998/07/29 13:29:51: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetSMTPDomainLocFlags(
    LPTSTR pszDomain,
    DWORD *pdwlocflags)
{
    HRESULT hr;
    DWORD dwDomainInfoFlags;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::IsSMTPDomainLocal");

    _ASSERT(pszDomain);

    DebugTrace((LPARAM)this, "Domain is %s", pszDomain);

    hr = HrGetSMTPDomainFlags(
        pszDomain,
        &dwDomainInfoFlags);

    DebugTrace((LPARAM)this, "GetDomainInfoFlags returned hr %08lx", hr);

    if(SUCCEEDED(hr)) {
        //
        // Wonderfull...translate from the domain info flags to locflags
        //
        *pdwlocflags = 0;

        if(dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX) {
            
            *pdwlocflags |= LOCF_LOCALMAILBOX;

        } else if(dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP) {
            
            *pdwlocflags |= LOCF_LOCALDROP;

        } else {
            
            *pdwlocflags |= LOCF_REMOTE;
        }

        if(dwDomainInfoFlags & DOMAIN_INFO_ALIAS) {

            *pdwlocflags |= LOCF_ALIAS;
        }
        DebugTrace((LPARAM)this, "dwlocflags is %08lx", *pdwlocflags);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
    
    

//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetSMTPDomainFlags
//
// Synopsis: Given an SMTP domain, retrieive its flags.
//
// Arguments: 
//  pszDomain: SMTP domain to lookup
//  pdwFlags: DWORD flags to fill in
//
// Returns:
//  S_OK: Success
//  error from IAdvQueueDomainType
//
// History:
// jstamerj 1998/09/15 17:11:15: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetSMTPDomainFlags(
    LPTSTR pszDomain,
    PDWORD pdwFlags)
{
    HRESULT hr;
    ICategorizerDomainInfo *pIDomainInfo;
    DWORD dwDomainInfoFlags;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrGetSMTPDomainFlags");

    _ASSERT(pszDomain);
    _ASSERT(pdwFlags);

    DebugTrace((LPARAM)this, "Domain is %s", pszDomain);

    pIDomainInfo = m_pCICatListResolve->GetIDomainInfo();

    if(pIDomainInfo) {

        hr = pIDomainInfo->GetDomainInfoFlags(
            pszDomain,
            &dwDomainInfoFlags);

    } else {
        //
        // We have no domain info
        //
        dwDomainInfoFlags = 0;
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "GetDomainInfoFlags returned hr %08lx", hr);
    DebugTrace((LPARAM)this, "DomainInfoFlags %08lx", dwDomainInfoFlags);

    if(SUCCEEDED(hr)) {

        *pdwFlags = dwDomainInfoFlags;

    } else {

        *pdwFlags = 0;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::HrSwitchToAliasedDomain
//
// Synopsis: Swap the domain in pszAddress with the default local
//           domain
//
// Arguments:
//   CAType: Address type
//   pszAddress: Address string
//   dwcch: Size of the pszAddress buffer we have to work with
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: pszAddress is not a legal CAType address
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): Unable to make the
//  switch because of an insufficient buffer size
//  CAT_E_UNKNOWN_ADDRESS_TYPE: Alias domains are not supported for
//                              this type
//
// History:
// jstamerj 980324 19:39:30: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrSwitchToAliasedDomain(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress,
    DWORD dwcch)
{
    HRESULT hr;
    LPTSTR pszDefaultDomain;
    DWORD dwLocFlags;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::SwitchToAliasedDomain");
    DebugTrace((LPARAM)this, "Before switch: %s", pszAddress);

    //
    // Lookup domain info if we haven't already done so
    //
    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN) {
        hr = CAT_E_ILLEGAL_ADDRESS;
        goto CLEANUP;
    }

    if(dwLocFlags & LOCF_ALIAS) {
        //
        // We only handle alias SMTP domains
        //
        _ASSERT(CAType == CAT_SMTP);
        //
        // Assert check the '@' is where we think it is
        //
        _ASSERT(m_dwDomainOffset > 0);
        _ASSERT(dwcch > m_dwDomainOffset);
        _ASSERT(pszAddress[m_dwDomainOffset-1] == '@');

        DebugTrace((LPARAM)this, "Detected alias domain for \"%s\"", pszAddress);
        //
        // Do we have enough buffer space for the switch?
        //
        pszDefaultDomain = GetCCategorizer()->GetDefaultSMTPDomain();

        _ASSERT(pszDefaultDomain);

        if( ((DWORD) lstrlen(pszDefaultDomain)) >=
           (dwcch - m_dwDomainOffset)) {
            //
            // Not enough space
            //
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        } else {

            lstrcpy(pszAddress + m_dwDomainOffset, pszDefaultDomain);
        }
    }
 CLEANUP:

    DebugTrace((LPARAM)this, "After switch: %s", pszAddress);
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::CheckForDuplicateCCatAddr
//
// Synopsis: Checks to see if any of the addresses in the list match
//           on orig address of this CCatAddr
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: Array of address types
//  rgpsz: Array of address strings
//
// Returns:
//  S_OK: Success, no duplicate
//  CAT_IMSG_E_DUPLICATE: Duplicate collision with this CCatAddr
//  or error from GetSpecificOrigAddress
//
// History:
// jstamerj 1998/07/30 21:44:42: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckForDuplicateCCatAddr(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];

    TraceFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckForDuplicateCCatAddr");

    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {
        //
        // Check for this type of address
        //
        hr = GetSpecificOrigAddress(
            rgCAType[dwCount],
            szAddress,
            CAT_MAX_INTERNAL_FULL_EMAIL);

        if(hr == CAT_IMSG_E_PROPNOTFOUND) {
            //
            // If the address doesn't exist, it's obviously not a duplicate
            //
            hr = S_OK;

        } else if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetSpecificOrigAddress failed hr %08lx", hr);
            break;

        } else {
            //
            // Match?
            //
            if(lstrcmpi(szAddress, rgpsz[dwCount]) == 0) {

                DebugTrace((LPARAM)this, "CCatAddr detected duplicate for address %s", szAddress);

                hr = CAT_IMSG_E_DUPLICATE;

                break;
            }
        }
    }    
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::CheckAncestorsForDuplicate
//
// Synopsis: Check our ancestor parent chain for a duplicate address
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: Array of address types
//  rgpsz: Array of address strings
//  fCheckSelf: Indicates wether or not to start by checking this
//              CCatAddr (or this CCatAddr's parent)
//  ppCCatAddr: Optional pointer to a pointer to recieve the duplicate
//  CCatAddr.  On CAT_IMSG_E_DUPLICATE, the returned CCatAddr is
//  addref'd for the caller.  Otherwise, this pointer is set to NULL.
//
// Returns:
//  S_OK: Success, no duplicate
//  CAT_IMSG_E_DUPLICATE: Duplicate collision with this CCatAddr
//  or error from GetSpecificOrigAddress
//
// History:
// jstamerj 1998/07/30 21:55:41: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckAncestorsForDuplicate(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz,
    BOOL fCheckSelf,
    CCatAddr **ppCCatAddrDup)
{
    HRESULT hr = S_OK;
    CCatAddr *pCCatAddr;
    CCatAddr *pCCatAddrNew;

    TraceFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckAncestorsForDuplicate");

    if(ppCCatAddrDup) {
        *ppCCatAddrDup = NULL;
    }

    //
    // Get the initial CCatAddr
    //
    if(fCheckSelf) {
        //
        // Start with ourselves
        //
        pCCatAddr = this;
        pCCatAddr->AddRef();

    } else {
        //
        // Start with our parent
        //
        hr = GetParentAddr(&pCCatAddr);
        if(FAILED(hr))
            pCCatAddr = NULL;
    }
    //
    // Loop until something fails as it must eventually do (when there
    // are no more parents)
    //
    while(SUCCEEDED(hr)) {
        //
        // Check duplicate on this ccataddr
        //
        hr = pCCatAddr->CheckForDuplicateCCatAddr(
            dwNumAddresses,
            rgCAType,
            rgpsz);

        //
        // Advance a generation
        //
        if(SUCCEEDED(hr)) {

            hr = pCCatAddr->GetParentAddr(
                &pCCatAddrNew);

            if(SUCCEEDED(hr)) {
                
                pCCatAddr->Release();
                pCCatAddr = pCCatAddrNew;
            }
        }
    }

    if(hr == CAT_E_PROPNOTFOUND) {
        //
        // This means the parent wasn't found -- which means no
        // duplicates were found in the chain
        //  
        hr = S_OK;

    } else if((hr == CAT_IMSG_E_DUPLICATE) && (ppCCatAddrDup)) {
        //
        // If we found a duplicate, let the caller know who the duplicate is
        //
        *ppCCatAddrDup = pCCatAddr;
        //
        // Addref for the caller
        //
        pCCatAddr->AddRef();
    }

    if(pCCatAddr)
        pCCatAddr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::CheckAncestorsForDuplicate
//
// Synopsis: Just like the other CheckAncestorsForDuplicate but it
//           doesn't require any arrays.
//
// Arguments:
//  CAType: Address type
//  pszAddress: Address String
//  fCheckSelf: Check to see if the address is a duplicate of THIS
//  ccataddr as well?
//  ppCCatAddrDup: Optional pointer to recieve a pointer to the
//  CCatAddr that is the duplicate
//
// Returns:
//  S_OK: Success
//  or error from CheckAncestorsForDuplicate (above)
//
// History:
// jstamerj 1998/07/31 20:27:52: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckAncestorsForDuplicate(
    CAT_ADDRESS_TYPE        CAType,
    LPTSTR                  pszAddress,
    BOOL                    fCheckSelf,
    CCatAddr                **ppCCatAddrDup)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckAncestorsForDuplicate");

    _ASSERT(pszAddress);

    hr = CheckAncestorsForDuplicate(
        1,                  // Number of addresses
        &CAType,            // Array of address types
        &pszAddress,        // Array of address strings
        fCheckSelf,
        ppCCatAddrDup);
    
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrIsOrigAddressLocal
//
// Synopsis: CHeck to see if the original address is local (and
//           remember that fact).  If m_loct is already set, just use it's info
//
// Arguments:
//  pfLocal: ptr to Boolean to set to TRUE of domain is local, FALSE
//           for remote domains
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: Something prevented us from determining the
//                         local flags of the address
//
// History:
// jstamerj 1998/09/15 17:37:17: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrIsOrigAddressLocal(
    BOOL *pfLocal)
{
    HRESULT hr = S_OK;
    DWORD dwLocFlags;

    _ASSERT(pfLocal);

    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN)
        return CAT_E_ILLEGAL_ADDRESS;

    *pfLocal = (dwLocFlags & LOCFS_LOCAL)
               ? TRUE : FALSE;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrIsOrigAddressLocalMailbox
//
// Synopsis: CHeck to see if the original address is local mailbox
//
// Arguments:
//  pfLocal: ptr to Boolean to set to TRUE of domain is local mailbox, FALSE
//           for remote domains
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: Something prevented us from determining the
//                         local flags of the address
//
// History:
// jstamerj 1998/09/15 17:37:17: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrIsOrigAddressLocalMailbox(
    BOOL *pfLocal)
{
    HRESULT hr = S_OK;
    DWORD dwLocFlags;

    _ASSERT(pfLocal);

    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN)
        return CAT_E_ILLEGAL_ADDRESS;

    *pfLocal = (dwLocFlags & LOCF_LOCALMAILBOX)
               ? TRUE : FALSE;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: DwGetOrigAddressLocFlags
//
// Synopsis: Figure out the LocType of our original address
//
// Arguments: NONE; member data is set
//
// Returns: 
//  LOCF_UNKNOWN: An error was encountered retrieving the local flags
//  non-zero: The local flags
//
// History:
// jstamerj 1998/10/27 18:14:01: Created.
//
//-------------------------------------------------------------
DWORD CCatAddr::DwGetOrigAddressLocFlags()
{
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CAT_ADDRESS_TYPE CAType;
    HRESULT hr;

    if(m_dwlocFlags != LOCF_UNKNOWN)
        //
        // We already have the local type
        //
        return m_dwlocFlags;

    //
    // Find the domain and look it up
    //
    hr = HrGetOrigAddress(szAddress, CAT_MAX_INTERNAL_FULL_EMAIL, &CAType);
    if(SUCCEEDED(hr))
        hr = HrGetAddressLocFlags(szAddress, CAType, &m_dwlocFlags, &m_dwDomainOffset);

    return m_dwlocFlags;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::LookupCompletion
//
// Synopsis: Handle the triggering of events once this object has been
//           looked up in the DS
//
// Arguments:
//
// Returns:
//  S_OK: Success, won't call completion
//  MAILTRANSPORT_S_PENDING: will call your completion routine
//
// History:
// jstamerj 1998/09/28 15:59:01: Created.
// jstamerj 1999/03/18 10:04:33: Removed return value and async
//                               completion to asyncctx 
//
//-------------------------------------------------------------
VOID CCatAddr::LookupCompletion()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::LookupCompletion");

    DebugTrace((LPARAM)this, "Calling HrProcessItem");

    hr = HrProcessItem();

    DebugTrace((LPARAM)this, "HrProcessItem returned hr %08lx", hr);

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Calling HrExpandItem");

    hr = HrExpandItem();

    DebugTrace((LPARAM)this, "HrExpandItem returned hr %08lx", hr);

    if(FAILED(hr) || (hr == MAILTRANSPORT_S_PENDING))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Calling HrCompleteItem");

    hr = HrCompleteItem();

    DebugTrace((LPARAM)this, "HrCompleteItem returned hr %08lx", hr);

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:

    if(FAILED(hr)) {

        DebugTrace((LPARAM)this, "Failing categorization with hr %08lx", hr);
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));

        //
        // We handeled the error
        //
    }
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrProcessItem
//
// Synopsis: Trigger the processitem event
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1998/09/28 16:32:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrProcessItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrProcessItem");


    pIServer = GetISMTPServer();

    //
    // Trigger ProcessItem -- it's time to figure out these attributes
    //
    EVENTPARAMS_CATPROCESSITEM ProcessParams;
    ProcessParams.pICatParams = GetICatParams();
    ProcessParams.pICatItem   = this;
    ProcessParams.pfnDefault  = MailTransport_Default_ProcessItem;
    ProcessParams.pCCatAddr   = this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT,
            &ProcessParams);

        _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    } else {
        //
        // Events are disabled, call default processing directly
        //
        MailTransport_Default_ProcessItem(
            S_OK,
            &ProcessParams);
        hr = S_OK;
    }
    
    //
    // Fail the list resolve when triggerserveevent fails
    //
    if(FAILED(hr)) {

        DebugTrace((LPARAM)this, "TriggerServerEvent failed with hr %08lx", hr);
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }

    //
    // We handeled the error
    //
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_ProcessItem
//
// Synopsis: Do default work of ProcessItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  Whatever HrProcessItem_Default returns
//
// History:
// jstamerj 1998/07/05 18:55:00: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_ProcessItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATPROCESSITEM pParams = (PEVENTPARAMS_CATPROCESSITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrProcessItem_Default();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrProcessItem_Default
//
// Synopsis: Do the default work of ProcessItem
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/28 16:49:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrProcessItem_Default()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CCatAddr::HrProcessItem_Default");

    //
    // CHeck the recipient status
    //
    hr = GetItemStatus();

    if(SUCCEEDED(hr)) {
        //
        // Add all known addresses to the new address list
        //
        hr = HrAddNewAddressesFromICatItemAttr();

        //
        // Fail the categorization if the above call
        // failed
        //
        if(FAILED(hr)) {

            hr = SetListResolveStatus(hr);
            _ASSERT(SUCCEEDED(hr));
        }
    }
    
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrAddNewAddressesFromICatItemAttr
//
// Synopsis: Dig out each known address type from
//           ICategorizerItemAttributes, format the parameters and
//           call HrAddAddresses
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: A REQUIRED property was not found
//  return value from HrAddAddresses
//
// History:
// jstamerj 1998/09/28 17:31:39: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrAddNewAddressesFromICatItemAttr()
{
    HRESULT hr;
    DWORD  dwFound, dwTry;
    ICategorizerParameters *pICatParams;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerUTF8Attributes *pIUTF8 = NULL;
    LPSTR pszAttribute;

    //
    // These are arrays to be filled in with pointers/values of
    // addresses set on the object
    //
    CAT_ADDRESS_TYPE rgCATypes[CAT_MAX_ADDRESS_TYPES];
    LPSTR  rgpszAddrs[CAT_MAX_ADDRESS_TYPES];
    ATTRIBUTE_ENUMERATOR rgenumerators[CAT_MAX_ADDRESS_TYPES];

    //
    // These arrays define the address types to receive
    //
    DWORD rgdwAddressAttributeIds_Try[] = {
        DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP,
        DSPARAMETER_ATTRIBUTE_DEFAULT_X400,
        DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
        DSPARAMETER_ATTRIBUTE_DEFAULT_LEGACYEXDN
    };
    CAT_ADDRESS_TYPE rgCATypes_Try[] = {
        CAT_SMTP,
        CAT_X400,
        CAT_DN,
        CAT_LEGACYEXDN,
        CAT_UNKNOWNTYPE //terminator
    };


    TraceFunctEnterEx((LPARAM)this, "CCatAddr:HrAddNewAddressesFromICatItemAttr");

    //
    // Formulate the array
    //
    pICatParams = GetICatParams();
    _ASSERT(pICatParams);
    
    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);
    
    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        goto CLEANUP;
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (LPVOID *)&pIUTF8);
    if(FAILED(hr))
        goto CLEANUP;

    //
    // Start trying to fetch address.  dwTry maintains our index into
    // the _Try arrays (address prop IDs to try).  dwFound keeps track
    // of the number of addresses we've found and stored in the arrays
    //
    for(dwTry = dwFound = 0;
        rgCATypes_Try[dwTry] != CAT_UNKNOWNTYPE;
        dwTry++) {
        
        //
        // Get the attribute name for this address type
        //
        hr = pICatParams->GetDSParameterA(
            rgdwAddressAttributeIds_Try[dwTry],
            &pszAttribute);

        if(SUCCEEDED(hr)) {

            hr = pIUTF8->BeginUTF8AttributeEnumeration(
                pszAttribute,
                &rgenumerators[dwFound]);

            if(SUCCEEDED(hr)) {
                hr = pIUTF8->GetNextUTF8AttributeValue(
                    &rgenumerators[dwFound],
                    &rgpszAddrs[dwFound]);

                if(SUCCEEDED(hr)) {
                    //
                    // Found the address!  Leave it in the new array;
                    // call EndAttributeEnumeration later
                    //
                    rgCATypes[dwFound] = rgCATypes_Try[dwTry];

                    DebugTrace((LPARAM)this, "Address #%d, type %d: \"%s\"",
                               dwFound,
                               rgCATypes[dwFound],
                               rgpszAddrs[dwFound]);

                    dwFound++;

                } else {
                    //
                    // Not found; call EndAttributeEnumeration now
                    //
                    pIUTF8->EndUTF8AttributeEnumeration(&rgenumerators[dwFound]);
                }   
            }
        }
    }
    DebugTrace((LPARAM)this, "Found %d addresses on this recipient", dwFound);

    //
    // Call HrAddAddresses with the addresses we've found
    //
    hr = HrAddAddresses(
        dwFound,
        rgCATypes,
        rgpszAddrs);

    //
    // End all attribute enumerations going on
    //
    for(dwTry = 0; dwTry < dwFound; dwTry++) {

        pIUTF8->EndUTF8AttributeEnumeration(&rgenumerators[dwTry]);
    }

 CLEANUP:
    if(pIUTF8)
        pIUTF8->Release();
    if(pICatItemAttr)
        pICatItemAttr->Release();
    
    DebugTrace((LPARAM)this, "Function returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrExpandItem
//
// Synopsis: Trigger the expandItem event
//
// Arguments:
//  pfnCompletion: Async completion routine
//  lpCompletionContext: context for the completion routine
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: will call the completion routine
//  or error from SEO
//
// History:
// jstamerj 1998/09/28 18:26:49: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrExpandItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrExpandItem");

    pIServer = GetISMTPServer();

    //
    // Increment the IO count assuming this will compelete async
    //
    IncPendingLookups();

    //
    // Trigger ExpandItem
    //
    EVENTPARAMS_CATEXPANDITEM ExpandParams;
    ExpandParams.pICatParams = GetICatParams();
    ExpandParams.pICatItem = this;
    ExpandParams.pfnDefault = MailTransport_Default_ExpandItem;
    ExpandParams.pfnCompletion = MailTransport_Completion_ExpandItem;
    ExpandParams.pCCatAddr = (PVOID) this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT,
            &ExpandParams);

    } else {
        ExpandParams.pIMailTransportNotify = NULL;
        //
        // Events are disabled -- since this is an async capable event
        // we need to realloc on the heap
        //
        PEVENTPARAMS_CATEXPANDITEM pParams;
        pParams = new EVENTPARAMS_CATEXPANDITEM;

        if(pParams == NULL) {

            hr = E_OUTOFMEMORY;

        } else {

            CopyMemory(pParams, &ExpandParams, sizeof(EVENTPARAMS_CATEXPANDITEM));
            //
            // Events are disabled, call default processing directly
            //
            hr = MailTransport_Default_ExpandItem(
                S_OK,
                pParams);
        }
    }
    
    if(hr != MAILTRANSPORT_S_PENDING)
        DecrPendingLookups(); // We did not complete async

    if(FAILED(hr)) {
        //
        // Set the resolve status for this item to error
        //
        DebugTrace((LPARAM)this, "TriggerServerEvent failed with hr %08lx", hr);
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }
    //
    // If TriggerServerEvent returned pending, we must also return
    // pending.  MailTransport_Completon_ExpandItem will be called
    // when all sinks have fired.
    //
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_ExpandItem
//
// Synopsis: Wrapper to do default work of ExpandItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/05 18:58:01: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_ExpandItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrExpandItem_Default(
        MailTransport_DefaultCompletion_ExpandItem,
        pContext);

    return hr;
}


//+------------------------------------------------------------
//
// Function: MailTransport_DefaultCompletion_ExpandItem
//
// Synopsis: The completion routine called when expanding the item is done
//
// Arguments:
//  pContext: Context passed to ExpandPropsFromLdapEntry
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/23 16:09:04: Created.
//
//-------------------------------------------------------------
VOID MailTransport_DefaultCompletion_ExpandItem(
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;

    _ASSERT(pParams);

    if(pParams->pIMailTransportNotify) {
        //
        // Notify the SEO dispatcher of async completion
        //
        hr = pParams->pIMailTransportNotify->Notify(
            S_OK,
            pParams->pvNotifyContext);

    } else {
        //
        // Events are disabled
        //
        hr = MailTransport_Completion_ExpandItem(
            S_OK,
            pContext);
    }
    _ASSERT(SUCCEEDED(hr));
}


//+------------------------------------------------------------
//
// Function: MailTransport_Completion_ExpandItem
//
// Synopsis: Handle async completion of an event -- this is only
//           called when one or more ExpandItem sinks complete asynch
//
// Arguments:
//  hrStatus: status of server event
//  pContext: a PEVENTPARAMS_CATEXPANDITEM
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 18:09:56: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_ExpandItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;

    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);
    ISMTPServer *pISMTPServer;

    pISMTPServer = pCCatAddr->GetISMTPServer();
    //
    // After ExpandItem, trigger CompleteItem
    //
    hr = pCCatAddr->HrCompleteItem();

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    _ASSERT(SUCCEEDED(hr));

    if(pISMTPServer == NULL) {
        //
        // Events are disabled -- need to free eventparams
        //
        delete pParams;
    }
    //
    // Decrement the pending lookup count incremented in HrExpandItem
    //
    pCCatAddr->DecrPendingLookups();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::HrCompleteItem
//
// Synopsis: Trigger the completeitem event
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1998/09/28 16:32:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrCompleteItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrCompleteItem");

    pIServer = GetISMTPServer();
    //
    // Trigger ProcessItem -- it's time to figure out these attributes
    //
    EVENTPARAMS_CATCOMPLETEITEM CompleteParams;
    CompleteParams.pICatParams = GetICatParams();
    CompleteParams.pICatItem = this;
    CompleteParams.pfnDefault = MailTransport_Default_CompleteItem;
    CompleteParams.pCCatAddr = this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT,
            &CompleteParams);

    } else {
        //
        // Events are disabled, call default processing directly
        //
        MailTransport_Default_CompleteItem(
            S_OK,
            &CompleteParams);
        
        hr = S_OK;
    }

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    
    //
    // Fail the list resolve when triggerserveevent fails
    //
    if(FAILED(hr)) {

        DebugTrace((LPARAM)this, "TriggerServerEvent failed with hr %08lx", hr);
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }

    //
    // We handeled the any error
    //
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: MailTransport_Default_CompleteItem
//
// Synopsis: Wrapper routing to do default work of CompleteItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  Whatever HrCompleteItem_Default returns
//
// History:
// jstamerj 1998/07/05 18:58:01: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_CompleteItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATCOMPLETEITEM pParams = (PEVENTPARAMS_CATCOMPLETEITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrCompleteItem_Default();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrResolveIfNecessary
//
// Synopsis: Call DispatchQuery only if DsUseCat indicates we should
//           resolve this type of recipient
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, dispatched an async query
//  S_FALSE: It was not necessary to resolve this recipient
//  or error from HrDispatchQuery
//
// History:
// jstamerj 1998/10/27 15:31:54: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrResolveIfNecessary()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrResolveIfNecessary");
    //
    // So is it necessary?
    //
    hr = HrNeedsResolveing();

    if(hr == S_OK) {
        //  
        // It is necessary; resolve it.
        //
        hr = HrDispatchQuery();
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CCatAddr::HrTriggerBuildQuery
//
// Synopsis: Build a query for this CCatAddr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/03/23 16:00:08: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrTriggerBuildQuery()
{
    HRESULT hr = S_OK;
    ISMTPServer *pISMTPServer;
    ICategorizerParameters *pICatParams;
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrTriggerBuildQuery");

    //
    // Trigger the buildquery event
    //
    pISMTPServer = GetISMTPServer();
    pICatParams = GetICatParams();
    
    EVENTPARAMS_CATBUILDQUERY EventParams;
    EventParams.pICatParams = pICatParams;
    EventParams.pICatItem = this;
    EventParams.pfnDefault = HrBuildQueryDefault;
    EventParams.pCCatAddr = (PVOID)this;

    if(pISMTPServer) {

        hr = pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT,
            &EventParams);

    } else {

        HrBuildQueryDefault(
            S_OK,
            &EventParams);
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrTriggerBuildQuery


//+------------------------------------------------------------
//
// Function: CCatAddr::HrBuildQueryDefault
//
// Synopsis: The default sink for the buildquery event
//
// Arguments:
//  HrStatus: status of the event so far
//  pContext: Context passed to 
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:02:41: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrBuildQueryDefault(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATBUILDQUERY pParams;
    CCatAddr *pCCatAddr;

    pParams = (PEVENTPARAMS_CATBUILDQUERY) pContext;
    pCCatAddr = (CCatAddr *)pParams->pCCatAddr;

    TraceFunctEnterEx((LPARAM)pCCatAddr, "CCatAddr::HrBuildQueryDefault");
    hr = pCCatAddr->HrComposeLdapFilter();

    DebugTrace((LPARAM)pCCatAddr, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)pCCatAddr);
    return hr;
} // CCatAddr::HrBuildQueryDefault


//+------------------------------------------------------------
//
// Function: CCatAddr::HrComposeLdapFilter
//
// Synopsis: Build a query string for this CCatAddr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:08:30: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrComposeLdapFilter()
{
    HRESULT hr = S_OK;
    ICategorizerParameters *pICatParams;
    CAT_ADDRESS_TYPE CAType;
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrComposeLdapFilter");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = HrGetLookupAddress(
        szAddress,
        CAT_MAX_INTERNAL_FULL_EMAIL,
        &CAType);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetLookupAddress failed with hr %08lx", hr);
        goto CLEANUP;
    }

    switch(CAType) {
     case CAT_SMTP:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_SMTP,
             DSPARAMETER_SEARCHFILTER_SMTP,
             szAddress);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         break;

     case CAT_LEGACYEXDN:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_LEGACYEXDN,
             DSPARAMETER_SEARCHFILTER_LEGACYEXDN,
             szAddress);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         break;

     case CAT_X400:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_X400,
             DSPARAMETER_SEARCHFILTER_X400,
             szAddress);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         break;

     case CAT_CUSTOMTYPE:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_FOREIGNADDRESS,
             DSPARAMETER_SEARCHFILTER_FOREIGNADDRESS,
             szAddress);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         break;

     case CAT_X500:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_X500,
             DSPARAMETER_SEARCHFILTER_X500,
             szAddress);

         if(SUCCEEDED(hr)) {
             break;
         } else if((hr != CAT_E_PROPNOTFOUND) && FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         //
         // Special case -- we can't resolve an X500 address
         // directly.  Convert it to a DN and try here.
         //
         // Fall through to DN case
         //
     case CAT_DN:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_DN,
             DSPARAMETER_SEARCHFILTER_DN,
             szAddress);
         if(SUCCEEDED(hr)) {
             break;
         } else if((hr != CAT_E_PROPNOTFOUND) && FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }

         //
         // Special case -- we can't resolve a DN directly. Try to do
         // it by searching on RDN
         //
         // Convert DN to RDN
         TCHAR szRDN[CAT_MAX_INTERNAL_FULL_EMAIL];

         hr = HrConvertDNtoRDN(szAddress, szRDN);
         if(FAILED(hr))
             goto CLEANUP;

         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_RDN,
             DSPARAMETER_SEARCHFILTER_RDN,
             szRDN, 
             FALSE);

         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "ComposeLdapFilterForType failed with hr %08lx", hr);
             goto CLEANUP;
         }
         //
         // Set distinguishing attribute/value back to the DN since
         // RDN really isn't distinguishing
         //
         LPSTR pszDistinguishingAttributeTemp;
         hr = pICatParams->GetDSParameterA(
             DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
             &pszDistinguishingAttributeTemp);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "GetDSParamterA failed with hr %08lx", hr);
             goto CLEANUP;
         }
         hr = PutStringA(
             ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
             pszDistinguishingAttributeTemp);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "PutStringA failed with hr %08lx", hr);
             goto CLEANUP;
         }
         //
         // And set the distinguishing attribute value to the DN
         //
         hr = PutStringA(
             ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
             szAddress);
         if(FAILED(hr)) {
             ErrorTrace((LPARAM)this, "PutStringA failed with hr %08lx", hr);
             goto CLEANUP;
         }
         break;
         
     default:
         _ASSERT(0 && "Unknown address type -- not supported for MM3");
    }
    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrComposeLdapFilter


//+------------------------------------------------------------
//
// Function: CCatAddr::HrComposeLdapFilterForType
//
// Synopsis: Given an address type and address, format the filter and
//           distinguishing attribute/value strings.  Set the
//           properties on CCatAddr
//
// Arguments:
//   dwSearchAttribute: propID of search attribute in IDSParams
//   dwSearchFilter:    propID of filter attribute in IDSParams
//   pszAddress: the Address
//   fSetDistinguishing: If FALSE, do NOT set the distinguishing
//                       attribute/distinguishing attribute value
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:12:27: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrComposeLdapFilterForType(
    DWORD     dwSearchAttribute,
    DWORD     dwSearchFilter,
    LPTSTR    pszAddress,
    BOOL      fSetDistinguishing)
{
    HRESULT hr = S_OK;
    LPSTR pszTemp, pszDest, pszSrc;
    LPSTR pszDistinguishingAttribute;
    CHAR  szDistinguishingAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR  szEscapedAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR  szFilter[MAX_SEARCH_FILTER_SIZE];
    ICategorizerParameters *pICatParams;

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrComposeLdapFilterForType");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);
    //
    // Use ICategorizerDSParameters to figure out our filter
    // string
    //

    // The attribute we search on will be our distinguishing
    // attribute
    //
    hr = pICatParams->GetDSParameterA(
        dwSearchAttribute,
        &pszDistinguishingAttribute);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error retrieveing search attribute - hr %08lx", hr);
        goto CLEANUP;
    }
    if(fSetDistinguishing) {
        //
        // Now set the distinguishing attribute in ICategorizerItem
        //
        hr = PutStringA(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
            pszDistinguishingAttribute);
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Error setting distinguishing attribute value - hr %08lx", hr);
            goto CLEANUP;
        }
    }
    //
    // Get the search format string
    //
    hr = pICatParams->GetDSParameterA(
        dwSearchFilter,
        &pszTemp);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error retrieving SMTP search filter - hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // Create the distinguishingattributevalue string by
    // sprintf'ing the search format string
    //
    _snprintf(szDistinguishingAttributeValue,
              CAT_MAX_INTERNAL_FULL_EMAIL,
              pszTemp, //ICategorizerDSParameters search filter
              pszAddress);

    if(fSetDistinguishing) {
        //
        // Set the distinguishingAttributeValue in ICategorizerParameters
        //
        hr = PutStringA(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
            szDistinguishingAttributeValue);
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Error Setting distinguishing attribute value - hr %08lx", hr);
            goto CLEANUP;
        }
    }
    //
    // Escape characters required for LDAP filter strings
    //
    hr = HrEscapeFilterString(
        szDistinguishingAttributeValue,
        sizeof(szEscapedAttributeValue),
        szEscapedAttributeValue);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error escaping attribute string");
        goto CLEANUP;
    }

    //
    // Create the actual filter from the distinguishing attribute
    // and distinguishing value
    //
    pszDest = szFilter;

    *pszDest++ = '(';
    pszSrc = pszDistinguishingAttribute;
    while(*pszSrc) {
        *pszDest++ = *pszSrc++;
    }
    *pszDest++ = '=';

    pszSrc = szEscapedAttributeValue;
    while(*pszSrc) {
        *pszDest++ = *pszSrc++;
    }
    *pszDest++ = ')';
    *pszDest = '\0';

    DebugTrace((LPARAM)this, "Formatted filter: \"%s\"", szFilter);

    // Set this filter in ICategorizerItem
    hr = PutStringA(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        szFilter);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error on PutStringA, hr %08lx", hr);
        goto CLEANUP;
    }
    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrComposeLdapFilterForType



//+------------------------------------------------------------
//
// Function: CCatAddr::HrConvertDNtoRDN
//
// Synopsis: Convert a string of the format "cn=blah,cn=blah,..." to
//           "cn=blah".  No bounds checking is done on pszRDN (if it
//           is at least as big as strlen(pszDN)+1, there will be no problem)
//
// Arguments:
//  pszDN: Pointer to buffer containig DN string
//  pszRDN: Pointer to buffer to receive RDN string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: pszDN is invalid
//
// History:
// jstamerj 1998/09/29 14:48:39: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrConvertDNtoRDN(
    LPTSTR    pszDN,
    LPTSTR    pszRDN)
{
    BOOL fInsideQuote = FALSE;
    LPSTR pszSrc, pszDest;

    _ASSERT(pszDN && pszRDN);
    //
    // Copy from pszDN to pszRDN removing quoted characters (per RFC
    // 1779) until we hit the first unquoted , in pszDN 
    //
    // Find the first unquoted =
    //
    pszSrc = pszDN;

    while((*pszSrc != '\0') &&                      // Stop at a NULL terminator
          (fInsideQuote || (*pszSrc != '='))) {     // Stop at an unquoted '='

        if(*pszSrc == '\\') {
            //
            // Backslash pair detected -- take the next character (it
            // should be \, , \+, \=, \", \r, \<, \>, \#, or \; )
            //
            pszSrc++;
            if(*pszSrc == '\0')
                return E_INVALIDARG;
            pszSrc++;

        } else if(*pszSrc == '"') {

            fInsideQuote = !fInsideQuote;
            pszSrc++;

        } else {
            
            pszSrc++;
        }
    }

    if(*pszSrc == '\0')
        return E_INVALIDARG; // No unquoted '=' found

    _ASSERT(*pszSrc == '=');
    _ASSERT(fInsideQuote == FALSE);

    pszSrc++;               // Skip past '='
    pszDest = pszRDN;

    while((*pszSrc != '\0') &&                  // Stop at a null terminator
          (fInsideQuote || (*pszSrc != ','))) { // Stop at the end of
                                                // the RDN part of the DN

        if(*pszSrc == '\\') {
            //
            // Backslash pair detected -- take the next character (it
            // should be \, , \+, \=, \", \r, \<, \>, \#, or \; )
            //
            pszSrc++;
            if(*pszSrc == '\0')
                return E_INVALIDARG;
            *pszDest++ = *pszSrc++;

        } else if(*pszSrc == '"') {

            fInsideQuote = !fInsideQuote;
            pszSrc++;

        } else {
            //
            // Normal case
            //
            *pszDest++ = *pszSrc++;
        }
    }

    //
    // Termiante the RDN
    //
    *pszDest = '\0';

    //
    // If we think we did not find a matching \", this is an invalid
    // DN
    //
    if(fInsideQuote)
        return E_INVALIDARG;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrEscapeFilterString
//
// Synopsis: Copy Src to Dest, escaping LDAP characters that need to
//           be escaped as we go.
//
// Arguments:
//  pszSrcString: Source string
//  dwcchDest: Size of dest buffer
//  pszDestBuffer: Dest buffer.  Note: this can not be the same as pszSrc
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 2000/04/11 17:49:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrEscapeFilterString(
    LPSTR pszSrcString,
    DWORD dwcchDest,
    LPSTR pszDestBuffer)
{
    HRESULT hr = S_OK;
    DWORD dwcchRemain = dwcchDest;
    LPSTR pszSrc = pszSrcString;
    LPSTR pszDest = pszDestBuffer;
    CHAR szHexDigits[17] = "0123456789ABCDEF"; // 16 digits + 1
                                               // for NULL termintor

    TraceFunctEnterEx((LPARAM)this, "CCatAddr::HrEscapeFilterString");

    _ASSERT(pszSrcString);
    _ASSERT(pszDestBuffer);
    _ASSERT(pszSrcString != pszDestBuffer);

    while(*pszSrc) {
        
        switch(*pszSrc) {
            //
            // These are the characters that RFC 2254 says we must
            // escape
            //
         case '(':
         case ')':
         case '*':
         case '\\':
             //
             // We must escape this because WLDAP32 strips off
             // leading spaces
             //
         case ' ':

             if(dwcchRemain < 3) {
                 hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                 goto CLEANUP;
             }
             dwcchRemain -= 3;
             *pszDest++ = '\\';
             // High 4 bits
             *pszDest++ = szHexDigits[((*pszSrc) >> 4)];
             // Low 4 bits
             *pszDest++ = szHexDigits[((*pszSrc) & 0xF)];
             break;

         default:
             if(dwcchRemain < 1) {
                 hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                 goto CLEANUP;
             }
             dwcchRemain--;
             *pszDest++ = *pszSrc;
             break;
        }
        pszSrc++;
    }
    //
    // Add NULL termintor
    //
    if(dwcchRemain < 1) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto CLEANUP;
    }
    dwcchRemain--;
    *pszDest = '\0';

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrEscapeFilterString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccat.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1988, Microsoft Corporation
//
// FILE: ccat.cpp
//
// CONTENTS: This file contains the class members for:
//
// Classes: CCategorizer (Common categorizer code)
//
// Functions:
//
// History:
// jstamerj 980305 14:26:27: Created
//
// Changes:
//
//------------------------------------------------------------

#include "precomp.h"
#include "cbifmgr.h"
#include "icatparam.h"
#include "ldapstr.h"
#include "catglobals.h"
#include <aqerr.h>

//+------------------------------------------------------------
//
// Function: CCategorizer::AddRef
//
// Synopsis: Increase the internal refcount
//
// Arguments: None
//
// Returns: New refcount
//
// History:
// jstamerj 1998/09/08 14:58:23: Created.
//
//-------------------------------------------------------------
LONG CCategorizer::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}


//+------------------------------------------------------------
//
// Function: CCategorizer::Release()
//
// Synopsis: Decreases the internal refcount.  Delete's this object
// when refcount hits zero
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/08 14:59:11: Created.
//
//-------------------------------------------------------------
LONG CCategorizer::Release()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedDecrement(&m_lRefCount);

    if(lNewRefCount == 0) {

        if(m_lDestructionWaiters) {
            //
            // Threads are waiting on the destruction event, so let
            // the last thread to wakeup delete this object
            //
            _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
            _VERIFY(SetEvent(m_hShutdownEvent));

        } else {
            //
            // Nobody is waiting, so delete this object
            //
            delete this;
        }
    }

    return lNewRefCount;
}



//+------------------------------------------------------------
//
// Function: ReleaseAndWaitForDestruction
//
// Synopsis: Release a callers refcount and wait for the object's
// refcount to drop to zero before returning
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 1998/09/09 16:44:46: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::ReleaseAndWaitForDestruction()
{
    DWORD dw;

    TraceFunctEnterEx((LPARAM)this,
                      "CCategorizer::ReleaseAndWaitForDestruction");

    _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);

    //
    // Increment the count of threads waiting for destruction
    //
    InterlockedIncrement(&m_lDestructionWaiters);

    //
    // Release our refcount; if the new refcount is zero, this object
    // will NOT be deleted; instead m_hShutdownEvent will be set
    //
    Release();

    //
    // Wait for all refcounts to be released. Update hints every 10 seconds
    //

    do {

        dw = WaitForSingleObject(
                m_hShutdownEvent,
                10000);

        if (m_ConfigInfo.pISMTPServer != NULL) {

            m_ConfigInfo.pISMTPServer->ServerStopHintFunction();

        }

    } while ( dw == WAIT_TIMEOUT );

    _ASSERT(WAIT_OBJECT_0 == dw);

    //
    // Decrement the number of threads waiting for termination; if we
    // are the last thread to leave here, we need to delete this
    // object
    //
    if( InterlockedDecrement(&m_lDestructionWaiters) == 0) {

        delete this;
    }
}

//+------------------------------------------------------------
//
// Function: CCategorizer::Initialize
//
// Synopsis: Initialize data structures for the Categoirzer.  This is
//           done during SMTPSVC startup
//
// Arguments:
//  pConfigInfo: Cat config info structure.
//  dwICatItemPropIDs: Initial number of props/ICatItem
//  dwICatListResolvePropIDs: Initial number of props/ICatListResolve
//
// Returns:
//  S_OK: Successfully initialized
//  E_INVALIDARG: Not all required arguments specified
//  otherwise, returns error from store.
//
//-------------------------------------------------------------
HRESULT CCategorizer::Initialize(
    PCCATCONFIGINFO pConfigInfo,
    DWORD dwICatItemPropIDs,
    DWORD dwICatListResolvePropIDs)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CCategorizer::Initialize");

    m_cICatParamProps = dwICatItemPropIDs;
    m_cICatListResolveProps = dwICatListResolvePropIDs;

    m_hShutdownEvent = CreateEvent(
        NULL,       // Security attributes
        TRUE,       // fManualReset
        FALSE,      // Initial state is NOT signaled
        NULL);      // No name

    if(NULL == m_hShutdownEvent) {

        hr = HRESULT_FROM_WIN32(GetLastError());

        //
        // Remember that m_hShutdownEvent is invalid
        //
        m_hShutdownEvent = INVALID_HANDLE_VALUE;

        FatalTrace((LPARAM)this, "Error creating event hr %08lx", hr);
        goto CLEANUP;
    }

    //
    // Create an EmailIDStore
    //
    hr = ::GetEmailIDStore( &m_pStore );
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetEmailIDStore returned %08lx", hr);
        goto CLEANUP;
    }
    _ASSERT(m_pStore);
    //
    // Copy the config info structure to class structure.  Use default
    // values for anything not specified
    //
    hr = CopyCCatConfigInfo(pConfigInfo);
    if(FAILED(hr)) {

        FatalTrace((LPARAM)this, "Error copying config info, hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: DelayedInitialize
//
// Synopsis: This function will get called on the first regular
//           operation on this virtual server (ie. CatMsg).  Anything
//           that we don't want to run while SMTPSVC is starting but
//           DO want to run before any categorizations goes here
//           (ie. Triggering the Register server event).
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/09/16 10:52:20: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::DelayedInitialize()
{
    HRESULT hr = S_OK;
    CICategorizerParametersIMP *pICatParamsIMP = NULL;

    TraceFunctEnterEx((LPARAM)this, "CCategorizer::DelayedInitialize");

    if(m_pICatParams == NULL) {
        //
        // Create ICategorizerParams using our implementation, the fast way,
        // and add a refcount to it (us)
        //
        pICatParamsIMP = new CICategorizerParametersIMP(
            GetCCatConfigInfo(),
            m_cICatParamProps,
            m_cICatListResolveProps);

        if(pICatParamsIMP == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory created ICatParams");
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }

        _ASSERT(m_pICatParams == NULL);
        m_pICatParams = pICatParamsIMP;
        m_pICatParams->AddRef();

        // Use the next property after those defined in smtpevent.idl
        m_dwICatParamSystemProp_CCatAddr = ICATEGORIZERITEM_ENDENUMMESS;
    }

    if((m_dwInitFlags & INITFLAG_REGISTER) == 0) {
        //
        // Set all the ICatParams before triggereing the event so that all
        // sinks will have access to the parameters
        //
        hr = Register();
        if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "Register failed hr %08lx", hr);
            goto CLEANUP;
        }
        m_dwInitFlags |= INITFLAG_REGISTER;
    }

    if((m_dwInitFlags & INITFLAG_REGISTEREVENT) == 0) {
        //
        // Trigger OnCategorizeRegisterEvent
        //
        EVENTPARAMS_CATREGISTER Params;
        Params.pICatParams = m_pICatParams;
        Params.pfnDefault = MailTransport_Default_CatRegister;
        Params.pszSourceLine = NULL;
        Params.pvCCategorizer = (PVOID)this;
        Params.hrSinkStatus = S_OK;

        if(m_ConfigInfo.pISMTPServer) {

            hr = m_ConfigInfo.pISMTPServer->TriggerServerEvent(
                SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT,
                &Params);

        } else {
            //
            // No events, call default processing directly
            //
            MailTransport_Default_CatRegister(
                S_OK,
                &Params);
        }

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "TriggerServerEvent failed hr %08lx",
                       hr);
            goto CLEANUP;
        }

        if(FAILED(Params.hrSinkStatus)) {
            ErrorTrace((LPARAM)this, "A sink failed to initialize hr %08lx", hr);
            hr = Params.hrSinkStatus;
            goto CLEANUP;
        }
        //
        // Change ICategorizerParams to be read only
        //
        pICatParamsIMP = (CICategorizerParametersIMP *)m_pICatParams;
        pICatParamsIMP->SetReadOnly(TRUE);

        //
        // Retrieve the number of props registered and remember it
        //
        m_cICatParamProps = pICatParamsIMP->GetNumPropIds_ICatItem();

        m_cICatListResolveProps = pICatParamsIMP->GetNumPropIds_ICatListResolve();

        m_dwInitFlags |= INITFLAG_REGISTEREVENT;
    }

    if((m_dwInitFlags & INITFLAG_STORE) == 0) {
        //
        // initialize the email ID store
        //
        hr = m_pStore->Initialize(
            m_pICatParams,
            m_ConfigInfo.pISMTPServer);

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "m_pStore->Initialized returned %08lx", hr);
            goto CLEANUP;
        }
        m_dwInitFlags |= INITFLAG_STORE;
    }

 CLEANUP:
    if(FAILED(hr)) {
        LPCSTR psz;
        CHAR szErrorCode[32];

        _snprintf(szErrorCode, sizeof(szErrorCode),
                  "0x%08lx : 0x%08lx",
                  hr,
                  m_dwInitFlags);

        psz = szErrorCode;

        //
        // Event log
        //
        if (m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) {

            CatLogEvent(
                m_ConfigInfo.pISMTPServer,
                CAT_EVENT_INIT_FAILED,      // Event ID
                TRAN_CAT_CATEGORIZER,       // Category
                1,                          // cSubString
                &psz,                       // rgszSubstrings,
                EVENTLOG_WARNING_TYPE,      // wType
                hr,
                LOGEVENT_LEVEL_MEDIUM,      // iDebugLevel
                szErrorCode,                // szKey
                LOGEVENT_FLAG_PERIODIC      // dwOptions
                );
        }

        hr = CAT_E_INIT_FAILED;
    }


    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// any error-prone shutdown that we might need to do will go here
//
HRESULT CCategorizer::Shutdown() {
    TraceFunctEnter("CCategorizer::Shutdown");
    TraceFunctLeave();
    return S_OK;
}

//
// -------------------------------------------------------------------------
// --- user functions                                                    ---
// -------------------------------------------------------------------------
//

BOOL CCategorizer::VerifyStringLength(LPSTR szString, DWORD dwMaxLength)
{
    if (IsBadStringPtr(szString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (!*szString++)
            return(TRUE);
    return(FALSE);

}

//
// -------------------------------------------------------------------------
// --- resolution functions                                              ---
// -------------------------------------------------------------------------
//


//+------------------------------------------------------------
//
// Function: CCategorizer::AsyncResolveIMsg
//
// Synopsis: Accepts an IMsg for asynchronous categorization.
//
// Arguments:
//   PIMsg: IMsg to categorize
//   pfnCatCompletion: Completion routine to call when done categorizing
//   pContext: Context to call completion routine with
//
// Returns:
//  S_OK: Asyncronously categorizing message
//  error: Unable to categorize message async
//
// History:
// jstamerj 980325 17:43:48: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::AsyncResolveIMsg(
    IUnknown *pIMsg,
    PFNCAT_COMPLETION pfnCatCompletion,
    LPVOID pContext)
{
    TraceFunctEnterEx((LPARAM)this, "CCategorizer::AsyncResolveIMsg");
    HRESULT hr;
    CICategorizerListResolveIMP *pCICatListResolveIMP = NULL;
    //
    // If we are totally disabled, skip all work
    //
    if(! IsCatEnabled()) {
        //
        // Skip counter increment/decrement when we are disabled by
        // calling the completion directly
        //
        _VERIFY( SUCCEEDED( pfnCatCompletion(S_OK, pContext, pIMsg, NULL)));
        hr = S_OK;
        goto CLEANUP;
    }

    INCREMENT_COUNTER(CatSubmissions);
    INCREMENT_COUNTER(CurrentCategorizations);

    if(fIsShuttingDown()) {
        hr = CAT_E_SHUTDOWN;
        goto CLEANUP;
    }

    hr = DelayedInitializeIfNecessary();
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Delayed initialize failed", hr);
        goto CLEANUP;
    }

    //
    // Allocate pICatListResolve quick and dirty..
    //
    pCICatListResolveIMP = new (m_cICatListResolveProps) CICategorizerListResolveIMP(
        this,
        pfnCatCompletion,
        pContext);

    if(pCICatListResolveIMP == NULL) {
        ErrorTrace(0, "out of memory allocing CICategorizerListResolveIMP");
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // The constructor of ICategorizerListResolve starts with refcount 1
    //
    hr = pCICatListResolveIMP->Initialize(pIMsg);
    if(FAILED(hr)) {
        ErrorTrace(0, "CICategorizerListResolveIMP::Initialize failed with hr %08lx", hr);
        goto CLEANUP;
    }
    hr = pCICatListResolveIMP->StartMessageCategorization();
    if(FAILED(hr)) {
        ErrorTrace(0, "StartMessageCategorization failed with hr %08lx", hr);
        goto CLEANUP;

    } else if(hr == S_FALSE) {
        //
        // Nothing was necessary to resolve
        //
        CatCompletion(pfnCatCompletion, S_OK, pContext, pIMsg, NULL);
        hr = S_OK;
        goto CLEANUP;
    }

 CLEANUP:
    // Cleanup
    if(FAILED(hr)) {

        ErrorTrace(0, "AsyncResolveIMsg internal failure, hr %08lx", hr);
        //
        // If the above code came to here with a failed hr, that means
        // the store will not be calling our completion routine.
        // Therefore, we need to clean up our mem and return an error
        //
        ErrorTrace(0, "AsyncResolveIMsg calling completion routine with error %08lx", hr);
        //
        // Even 'tho we are returning an error, increment the counters
        // as if we were calling CatCompletion.  This also determines
        // wether or not hr is a retryable error.
        //
        hr = HrAdjustCompletionCounters(hr, pIMsg, NULL);
    }

    if(pCICatListResolveIMP)
        pCICatListResolveIMP->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::AsyncResolveDLs
//
// Synopsis: Accepts an IMsg for asynchronous DL categorization.
//
// Arguments:
//   PIMsg: IMsg to categorize
//   pfnCatCompletion: Completion routine to call when done categorizing
//   pContext: Context to call completion routine with
//   fMatchOnly: Do we only care about finding an address?
//   pfmatch: ptr to BOOL to set to TRUE if match is found
//   CAType: address type you're looking for
//   pszAddress: address you're looking for
//
// Returns:
//  S_OK: Successfully queued
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/07 18:58:41: Created
//
//-------------------------------------------------------------
HRESULT CCategorizer::AsyncResolveDLs(
    IUnknown *pIMsg,
    PFNCAT_COMPLETION pfnCatCompletion,
    LPVOID pContext,
    BOOL fMatchOnly,
    PBOOL pfMatch,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    TraceFunctEnter("CCategorizer::AsyncResolveDLs");
    HRESULT hr;
    CICategorizerDLListResolveIMP *pCICatListResolveIMP = NULL;

    //
    // If we are totally disabled, skip all work
    //
    if(! IsCatEnabled()) {

        _VERIFY( SUCCEEDED( pfnCatCompletion(S_OK, pContext, pIMsg, NULL)));
        hr = S_OK;
        goto CLEANUP;
    }

    INCREMENT_COUNTER(CatSubmissions);

    if(fIsShuttingDown()) {
        hr = CAT_E_SHUTDOWN;
        goto CLEANUP;
    }

    hr = DelayedInitializeIfNecessary();
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Delayed initialize failed", hr);
        goto CLEANUP;
    }

    //
    // Allocate pICatListResolve quick and dirty..
    //
    pCICatListResolveIMP = new (m_cICatListResolveProps) CICategorizerDLListResolveIMP(
        this,
        pfnCatCompletion,
        pContext);

    if(pCICatListResolveIMP == NULL) {
        ErrorTrace(0, "out of memory allocing CICategorizerListResolveIMP");
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // The constructor of ICategorizerListResolve starts with refcount 1
    //
    hr = pCICatListResolveIMP->Initialize(
        pIMsg,
        !fMatchOnly, // Expand all?
        pfMatch,
        CAType,
        pszAddress);

    if(FAILED(hr)) {
        ErrorTrace(0, "CICategorizerListResolveIMP::Initialize failed with hr %08lx", hr);
        goto CLEANUP;
    }
    hr = pCICatListResolveIMP->StartMessageCategorization();
    if(FAILED(hr)) {
        ErrorTrace(0, "StartMessageCategorization failed with hr %08lx", hr);
        goto CLEANUP;

    } else if(hr == S_FALSE) {
        //
        // Nothing was necessary to resolve
        //
        CatCompletion(pfnCatCompletion, S_OK, pContext, pIMsg, NULL);
        hr = S_OK;
        goto CLEANUP;
    }

 CLEANUP:

    // Cleanup
    if(FAILED(hr)) {

        ErrorTrace(0, "AsyncResolveIMsg internal failure, hr %08lx", hr);
        // If the above code came to here with a failed hr, that means
        // the store will not be calling our completion routine.
        // Therefore, we need to clean up our mem and call our
        // completion routine with error

        ErrorTrace(0, "AsyncResolveIMsg calling completion routine with error %08lx", hr);
        // Instead of returning an error, return S_OK and call the
        // user's completion routine

        CatCompletion(pfnCatCompletion, hr, pContext, pIMsg, NULL);
        hr = S_OK;
    }

    if(pCICatListResolveIMP)
        pCICatListResolveIMP->Release();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_CatRegister
//
// Synopsis: Wrapper to call back into CCategorizer::Register
//
// Arguments:
//  hrStatus: current status of event
//  pvContext: register event params structure
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/23 21:22:36: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_CatRegister(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Default_CatRegister");

    //
    // For the register event, do the default processing before
    // triggering the server event so all sinks will have access to
    // the config info (even those higher than default priority)
    //

    TraceFunctLeave();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::Register
//
// Synopsis: Sets initial categorizer parameters given a sourceline
//
// Arguments:
//   pszSourceLine: String of the following form:
//                  "Host=host.corp.com,Account=Administrator,Password=xx",
//                  giving the information about the LDAP server for the
//                  default domain.
//
// Returns:
//  S_OK: Success
//  or error from ParseSourceLine
//
// History:
// jstamerj 1998/06/23 19:01:57: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::Register()
{
    TraceFunctEnterEx((LPARAM)this, "CCategorizer::Register");
    HRESULT hrResult;

    //
    // Set the ICatParams based on info in m_ConfigInfo
    //
    hrResult = SetICatParamsFromConfigInfo();

    TraceFunctLeaveEx((LPARAM)this);
    return hrResult;

}


//+------------------------------------------------------------
//
// Function: CCategorizer::SetICatParamsFromConfigInfo
//
// Synopsis: Sets parameters in m_pICatParams based on values in m_ConfigInfo
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/15 15:28:55: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::SetICatParamsFromConfigInfo()
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CCategorizer::SetICatParamsFromConfigInfo");

    //
    // Run through each parameter copying them from m_ConfigInfo to ICategorizerParameters
    //
    #define PARAMCOPY( ciflag, cimember, dsparamid ) \
        if(m_ConfigInfo.dwCCatConfigInfoFlags & ciflag) { \
            hr = m_pICatParams->SetDSParameterA( \
                dsparamid, \
                m_ConfigInfo.cimember); \
            if(FAILED(hr)) \
                goto CLEANUP; \
        }

    PARAMCOPY( CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain, DSPARAMETER_LDAPDOMAIN );
    PARAMCOPY( CCAT_CONFIG_INFO_USER, pszUser, DSPARAMETER_LDAPACCOUNT );
    PARAMCOPY( CCAT_CONFIG_INFO_PASSWORD, pszPassword, DSPARAMETER_LDAPPASSWORD );
    PARAMCOPY( CCAT_CONFIG_INFO_BINDTYPE, pszBindType, DSPARAMETER_LDAPBINDTYPE );
    PARAMCOPY( CCAT_CONFIG_INFO_HOST, pszHost, DSPARAMETER_LDAPHOST );
    PARAMCOPY( CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext, DSPARAMETER_LDAPNAMINGCONTEXT );


    if(m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_PORT) {
        //
        // itoa documentation states up to 17 chars will be stored in
        // the buffer (including the NULL terminator)
        //
        CHAR szTmp[17];

        _itoa(m_ConfigInfo.dwPort, szTmp, 10 /* radix */);

        hr = m_pICatParams->SetDSParameterA(
            DSPARAMETER_LDAPPORT,
            szTmp);
        if(FAILED(hr))
            goto CLEANUP;
    }

    //
    // Register the schema specific parameters
    //
    if(m_ConfigInfo.dwCCatConfigInfoFlags &
       CCAT_CONFIG_INFO_SCHEMATYPE) {

        hr = RegisterSchemaParameters(
            m_ConfigInfo.pszSchemaType);
        if(FAILED(hr))
            goto CLEANUP;
    }

 CLEANUP:

    DebugTrace((LPARAM)this, "SetICatParamsFromConfigInfo returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CCategorizer::ParseSourceLineAndSetICatParams
//
//  Synopsis:   Helper routine to parse a setup config line and set
//              the parameters in m_pICatParams
//
//  Arguments:  [szSourceLine] -- The LDAP config info line to parse
//
//  Returns:    S_OK if successfully parsed
//              HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) on error
//
//-----------------------------------------------------------------------------

HRESULT CCategorizer::ParseSourceLineAndSetICatParams(
    LPCSTR pszSourceLine)
{
    TraceFunctEnter("CCategorizer::ParseSourceLineAndSetICatParams");
    DebugTrace(0, "sourceline = %s", pszSourceLine);
    HRESULT hr = S_OK;

    char const *p = pszSourceLine;

    while ( SUCCEEDED(hr) && (p != 0) ) {
        char szVarname[256];
        char szValue[256];
        int i;

        // skip whitespace
        while (*p == ';' || isspace(*p) && *p != 0) p++;
        if (*p == 0) break;

        // get out a varname
        for (i = 0; *p != 0 && *p != '=' && i < 255; p++) {
            if (!isspace(*p)) szVarname[i++] = *p;
        }
        szVarname[i] = 0;
        if (*p == 0) {
            FatalTrace(0, "invalid sources line (%s) passed, varname (%s) without value",
                       pszSourceLine, szVarname);
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

        // get out a value
        // we end when:
        // end of string
        // found value delimiter
        // we have overfilled szValue

        if (lstrcmpi(szVarname, "szPassword") == 0) {
            _ASSERT(*p == '=');
            p++;
            lstrcpy(szValue, p);
            p += strlen(p);
        } else {
            // skip whitespace
            while (*p == '=' || isspace(*p) && *p != 0) p++;
            if (*p == 0) {
                FatalTrace(0, "invalid source line (%s) passed, zero length varname (%s) or value (%s)",
                    pszSourceLine, szVarname, szValue);
                return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            }
            for (i = 0; *p != 0 && *p != ';' && i < 255; p++)
            {
                szValue[i++] = *p;
            }
            szValue[i] = 0;
            if (*szVarname == 0) {
                FatalTrace(0, "invalid source line (%s) passed, zero length varname (%s)",
                           pszSourceLine, szVarname, szValue);
                return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            }
        }

        DebugTrace(0, "parsed out varname = %s, value = %s from source line",
                   szVarname, szValue);

        if (lstrcmpi(szVarname, "szHost") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPHOST,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szNamingContext") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPNAMINGCONTEXT,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szAccount") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPACCOUNT,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szDomain") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPDOMAIN,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szPassword") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPPASSWORD,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szBindType") == 0)
        {
            hr = m_pICatParams->SetDSParameterA(
                DSPARAMETER_LDAPBINDTYPE,
                szValue);
        }
        else if (lstrcmpi(szVarname, "szSchemaType") == 0)
        {
            hr = RegisterSchemaParameters(szValue);
        }
    }
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::RegisterSchemaParameters
//
// Synopsis: Adds required attributes to m_pICatParams based on a schema type
//
// Arguments:
//   scht: Schema type of config
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980615 13:45:04: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::RegisterSchemaParameters(
    LPSTR pszSchema)
{
    TraceFunctEnter("CCategorizer::RegisterSchemaParameters");
    HRESULT hr = S_OK;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY *pSchemaStrings = NULL;
    LPSTR *pRequestAttributeStrings = NULL;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsNT5[] =
        SCHEMA_CONFIG_STRING_TABLE_NT5;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsMCIS3[] =
        SCHEMA_CONFIG_STRING_TABLE_MCIS3;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsExchange5[] =
        SCHEMA_CONFIG_STRING_TABLE_EXCHANGE5;

    LPSTR pRequestAttributeStringsNT5[] =
        SCHEMA_REQUEST_STRINGS_NT5;

    LPSTR pRequestAttributeStringsMCIS3[] =
        SCHEMA_REQUEST_STRINGS_MCIS3;

    LPSTR pRequestAttributeStringsExchange5[] =
        SCHEMA_REQUEST_STRINGS_EXCHANGE5;

    if(lstrcmpi(pszSchema, "NT5") == 0) {
         pSchemaStrings = pSchemaStringsNT5;
         pRequestAttributeStrings = pRequestAttributeStringsNT5;
    } else if(lstrcmpi(pszSchema, "MCIS3") == 0) {
         pSchemaStrings = pSchemaStringsMCIS3;
         pRequestAttributeStrings = pRequestAttributeStringsMCIS3;
    } else if(lstrcmpi(pszSchema, "Exchange5") == 0) {
         pSchemaStrings = pSchemaStringsExchange5;
         pRequestAttributeStrings = pRequestAttributeStringsExchange5;
    } else {
        ErrorTrace((LPARAM)this, "Unknown schema type %s", pszSchema);
    }

    if(pSchemaStrings) {
        //
        // Traverse the schema string table adding strings as we go.
        //
        SCHEMA_CONFIG_STRING_TABLE_ENTRY *pEntry;
        pEntry = pSchemaStrings;
        while(SUCCEEDED(hr) && (pEntry->DSParam != DSPARAMETER_INVALID)) {

            hr = m_pICatParams->SetDSParameterA(
                pEntry->DSParam, pEntry->pszValue);
            DebugTrace((LPARAM)this,
                       "hr = %08lx setting schemaparameter %ld to \"%s\"",
                       hr, pEntry->DSParam, pEntry->pszValue);
            pEntry++;
        }
    }
    if(pRequestAttributeStrings) {
        //
        // Traverse the requested attribute strings and add as we go.
        //
        LPSTR *ppszReqAttr;
        ppszReqAttr = pRequestAttributeStrings;
        while(SUCCEEDED(hr) && (*ppszReqAttr)) {

            hr = m_pICatParams->RequestAttributeA(
                *ppszReqAttr);
            DebugTrace((LPARAM)this, "hr = %08lx from RequestAttribute(\"%s\")",
                       hr, *ppszReqAttr);
            ppszReqAttr++;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return SUCCEEDED(hr) ? S_OK : hr;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CopyCCatConfigInfo
//
// Synopsis: Copy a passed in config structure (possibly partialled filled in)
// to the member config strucutre.  Default paramters will be set for any
// parameters not specified.
//
// Arguments: pConfigInfo: passed in struct
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/09/14 16:55:33: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::CopyCCatConfigInfo(
    PCCATCONFIGINFO pConfigInfo)
{
    TraceFunctEnterEx((LPARAM)this,
                      "CCategorizer::CopyCCatConfigInfo");

    _ASSERT(pConfigInfo);

    _ASSERT(m_ConfigInfo.dwCCatConfigInfoFlags == 0);

    //
    // Copy the virtual server ID to the new structure
    //
    m_ConfigInfo.dwVirtualServerID =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_VSID) ?
         pConfigInfo->dwVirtualServerID :
        CCAT_CONFIG_DEFAULT_VSID;

    //
    // Copy MsgCat enable/disable flag to the new structure
    //
    m_ConfigInfo.dwEnable =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ENABLE) ?
        pConfigInfo->dwEnable :
        CCAT_CONFIG_DEFAULT_ENABLE;

    //
    // Copy MsgCat flags to the new structure
    //
    m_ConfigInfo.dwCatFlags =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_FLAGS) ?
        pConfigInfo->dwCatFlags :
        CCAT_CONFIG_DEFAULT_FLAGS;

    //
    // Copy the LDAP port to the new structure
    //
    m_ConfigInfo.dwPort =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_PORT) ?
        pConfigInfo->dwPort :
        CCAT_CONFIG_DEFAULT_PORT;

    //
    // Copy/Addref the interface pointers to the new structure
    //
    if((pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) &&
       (pConfigInfo->pISMTPServer)) {

        m_ConfigInfo.pISMTPServer = pConfigInfo->pISMTPServer;
        m_ConfigInfo.pISMTPServer->AddRef();

    } else {

        m_ConfigInfo.pISMTPServer = NULL;
    }

    if((pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_IDOMAININFO) &&
        (pConfigInfo->pIDomainInfo)) {

        m_ConfigInfo.pIDomainInfo = pConfigInfo->pIDomainInfo;
        m_ConfigInfo.pIDomainInfo->AddRef();

    } else {

        m_ConfigInfo.pIDomainInfo = NULL;
    }

    //
    // Set the flags for dwEnable, dwCatFlags, dwPort, the 2 interface members,    // and the default flag
    //
    m_ConfigInfo.dwCCatConfigInfoFlags |=
        ( CCAT_CONFIG_INFO_VSID |
          CCAT_CONFIG_INFO_FLAGS |
          CCAT_CONFIG_INFO_ENABLE |
          CCAT_CONFIG_INFO_PORT |
          CCAT_CONFIG_INFO_ISMTPSERVER |
          CCAT_CONFIG_INFO_IDOMAININFO |
          CCAT_CONFIG_INFO_DEFAULT);

    //
    // To avoid cut+paste coding, define a macro that copies a string member
    // from one struct to the other; or'ing in the appropriate flag on success
    //
    #define COPYSTRING(member, flag, default) \
        m_ConfigInfo.member = pszStrdup( \
            (pConfigInfo->dwCCatConfigInfoFlags & flag) ? \
            pConfigInfo->member : \
            default); \
        if(m_ConfigInfo.member != NULL) \
            m_ConfigInfo.dwCCatConfigInfoFlags |= flag;


    COPYSTRING(pszRoutingType, CCAT_CONFIG_INFO_ROUTINGTYPE, CCAT_CONFIG_DEFAULT_ROUTINGTYPE);
    COPYSTRING(pszBindDomain, CCAT_CONFIG_INFO_BINDDOMAIN, CCAT_CONFIG_DEFAULT_BINDDOMAIN);
    COPYSTRING(pszUser, CCAT_CONFIG_INFO_USER, CCAT_CONFIG_DEFAULT_USER);
    COPYSTRING(pszPassword, CCAT_CONFIG_INFO_PASSWORD, CCAT_CONFIG_DEFAULT_PASSWORD);
    COPYSTRING(pszBindType, CCAT_CONFIG_INFO_BINDTYPE, CCAT_CONFIG_DEFAULT_BINDTYPE);
    COPYSTRING(pszSchemaType, CCAT_CONFIG_INFO_SCHEMATYPE, CCAT_CONFIG_DEFAULT_SCHEMATYPE);
    COPYSTRING(pszHost, CCAT_CONFIG_INFO_HOST, CCAT_CONFIG_DEFAULT_HOST);
    COPYSTRING(pszNamingContext, CCAT_CONFIG_INFO_NAMINGCONTEXT, CCAT_CONFIG_DEFAULT_NAMINGCONTEXT);
    COPYSTRING(pszDefaultDomain, CCAT_CONFIG_INFO_DEFAULTDOMAIN, CCAT_CONFIG_DEFAULT_DEFAULTDOMAIN);

    //
    // Make sure all flags in the structure were set.
    //
    if(m_ConfigInfo.dwCCatConfigInfoFlags != CCAT_CONFIG_INFO_ALL) {
        //
        // We must have failed because we ran out of memory
        //
        ErrorTrace((LPARAM)this, "Ran out of memory copying flags");
        TraceFunctLeaveEx((LPARAM)this);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::RelaseConfigInfo
//
// Synopsis: Release all memory and interfaces held by the configinfo struct
//
// Arguments: NONE (member variable)
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/14 17:26:06: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::ReleaseConfigInfo(
    PCCATCONFIGINFO pConfigInfo)
{
    //
    // Release interfaces
    //
    if((m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) &&
       (m_ConfigInfo.pISMTPServer)) {

        m_ConfigInfo.pISMTPServer->Release();
    }

    if((m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_IDOMAININFO) &&
       (m_ConfigInfo.pIDomainInfo)) {

        m_ConfigInfo.pIDomainInfo->Release();
    }

    //
    // Again, a handy macro instead of cut+paste coding
    //
    #define RELEASESTRING(member, flag) \
        if(m_ConfigInfo.dwCCatConfigInfoFlags & flag) \
            FreePv(m_ConfigInfo.member);

    RELEASESTRING(pszRoutingType, CCAT_CONFIG_INFO_ROUTINGTYPE);
    RELEASESTRING(pszBindDomain, CCAT_CONFIG_INFO_BINDDOMAIN);
    RELEASESTRING(pszUser, CCAT_CONFIG_INFO_USER);
    RELEASESTRING(pszPassword, CCAT_CONFIG_INFO_PASSWORD);
    RELEASESTRING(pszBindType, CCAT_CONFIG_INFO_BINDTYPE);
    RELEASESTRING(pszSchemaType, CCAT_CONFIG_INFO_SCHEMATYPE);
    RELEASESTRING(pszHost, CCAT_CONFIG_INFO_HOST);
    RELEASESTRING(pszNamingContext, CCAT_CONFIG_INFO_NAMINGCONTEXT);
    RELEASESTRING(pszDefaultDomain, CCAT_CONFIG_INFO_DEFAULTDOMAIN);

    //
    // Since we released everything, set flags to zero
    //
    m_ConfigInfo.dwCCatConfigInfoFlags = 0;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CancelAllPendingListResolves
//
// Synopsis: Set the resolve status on all pending list resolves
//
// Arguments:
//  hrReason (optional): the status to set on all list resolves
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/01/29 18:30:24: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::CancelAllPendingListResolves(
    HRESULT hrReason)
{
    PLIST_ENTRY ple;

    AcquireSpinLock(&m_PendingResolveListLock);

    for(ple = m_ListHeadPendingResolves.Flink;
        ple != &(m_ListHeadPendingResolves);
        ple = ple->Flink) {

        CICategorizerListResolveIMP *pListResolve;

        pListResolve = CONTAINING_RECORD(
            ple,
            CICategorizerListResolveIMP,
            m_li);

        pListResolve->Cancel();
    }

    ReleaseSpinLock(&m_PendingResolveListLock);
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CatCompletion
//
// Synopsis: Increment perf counters and call the next level's catcompletion
//
// Arguments:
//  hr: Status of resolution
//  pContext: user part of list resolve context
//  pIMsg: categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/02/24 16:00:11: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::CatCompletion(
    PFNCAT_COMPLETION pfnCatCompletion,
    HRESULT hrResult,
    LPVOID  pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    HRESULT hr;
    PCATMSG_CONTEXT pCatContext = (PCATMSG_CONTEXT)pContext;

    TraceFunctEnter("CCategorizer::CatCompletion");
    //
    // Increment counters AND determine wether or not hrResult is a
    // retryable error
    //
    hr = HrAdjustCompletionCounters(hrResult, pIMsg, rgpIMsg);

    _VERIFY(SUCCEEDED(pfnCatCompletion(
        hr,
        pContext,
        pIMsg,
        rgpIMsg)));

    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCategorizer::HrAdjustCompletionCounters
//
// Synopsis: Increment/Decrement the perf counters associated with a
//           CatCompletion.  Also determines wether or not a list
//           resolve error is retryable
//
// Arguments:
//  hrListResolveStatus: status of the categorization
//  pIMsg: value of the parameter to be passed to CatCompletion (the
//         message to be completed or NULL if there are multiple messages)
//  rgpIMsg: value of the parameter to be passed to CatCompletion (the
//           array of messages to be completed or NULL if there is
//           only one message)
//
// Returns: HRESULT:
//  S_OK: Categorization completed successfully
//  CAT_E_RETRY: hrListResolveStatus is a retryable error
//  hrListResolveStatus: hrListResolveStatus is a non-retryable error
//
// History:
// jstamerj 1999/06/10 11:58:43: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::HrAdjustCompletionCounters(
    HRESULT hrListResolveStatus,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    HRESULT hr = hrListResolveStatus;
    TraceFunctEnterEx((LPARAM)this, "CCategorizer::HrAdjustCompletionCounters");
    if(FAILED(hr)) {
        //
        // Is this a retryable error?
        //
        switch(hr) {

         case E_OUTOFMEMORY:
         case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):

             INCREMENT_COUNTER(RetryOutOfMemory);
             hr = CAT_E_RETRY;
             break;

         case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):

             INCREMENT_COUNTER(RetryDSLogon);
             hr = CAT_E_RETRY;
             break;

         case CAT_E_DBCONNECTION:
         case CAT_E_DBFAIL:
         case CAT_E_NO_GC_SERVERS:

             INCREMENT_COUNTER(RetryDSConnection);
             hr = CAT_E_RETRY;
             break;

         case CAT_E_RETRY:
         case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
         case HRESULT_FROM_WIN32(ERROR_DISK_FULL):

             hr = CAT_E_RETRY;
             INCREMENT_COUNTER(RetryGeneric);
             break;

         case HRESULT_FROM_WIN32(ERROR_RETRY):
         case HRESULT_FROM_WIN32(ERROR_CANCELLED):
         case CAT_E_SHUTDOWN:
         case STOREDRV_E_SHUTDOWN:
         case AQUEUE_E_SHUTDOWN:
             //
             // We are shutting down -- return a retryable error so
             // that the message is not badmailed and will get
             // enumerated/categorized again when the VS restarts
             //
             hr = CAT_E_RETRY;
             INCREMENT_COUNTER(RetryGeneric);
             break;

         case CAT_E_INIT_FAILED:
             //
             // All initialize errors are retryable
             //
             hr = CAT_E_RETRY;
             break;

         default:
             //
             // Hard error
             //
             break;
        }
        if(CAT_E_RETRY == hr) {

            CHAR szKey[16]; // Stringized HRESULT
            _snprintf(szKey, sizeof(szKey), "%08lx", hrListResolveStatus);

            ErrorTrace(0, "Categorizer failing with retryable error: %08lx", hrListResolveStatus);
            INCREMENT_COUNTER(RetryFailureCategorizations);

            //
            // Event log
            //
            // We switch to TransportLogEventEx() here in order to
            // generate system string using FormatMessage
            // note: rgszStrings[0] is set inside CEvntWrapp::LogEvent( )
            // because FormatMessageA is used inside LogEvent to generate
            // this string and assign it to rgszString[1]
            const char *rgszStrings[1] = { NULL };

            if (m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) {

                CatLogEvent(
                    m_ConfigInfo.pISMTPServer,
                    CAT_EVENT_RETRYABLE_ERROR,                      // Message ID
                    TRAN_CAT_CATEGORIZER,                           // Category
                    1,                                              // Word count of substring
                    rgszStrings,                                    // Substring
                    EVENTLOG_WARNING_TYPE,                          // Type of the message
                    hrListResolveStatus,                            // error code
                    LOGEVENT_LEVEL_MEDIUM,                          // Logging level
                    szKey,                                          // key to this event
                    LOGEVENT_FLAG_PERIODIC,                         // Logging option
                    0,                                              // index of format message string in rgszStrings
                    GetModuleHandle(AQ_MODULE_NAME)                 // module handle to format a message
                    );
            }

        } else {

            FatalTrace(0, "Categorizer failing with nonretryable error: %08lx", hr);
            INCREMENT_COUNTER(HardFailureCategorizations);
            //
            // Pass the hard error to aqueue
            //
        }

    } else {
        //
        // Successfull categorization
        //
        INCREMENT_COUNTER(SucceededCategorizations);

    }
    //
    // Success/failure, increment message counters
    //
    if(pIMsg) {

        INCREMENT_COUNTER(MessagesSubmittedToQueueing);

    } else {
        IUnknown **ppMsg = rgpIMsg;

        while(*ppMsg)
            ppMsg++;

        INCREMENT_COUNTER_AMOUNT(MessagesSubmittedToQueueing, (LONG)(ppMsg - rgpIMsg));
    }

    DECREMENT_COUNTER(CurrentCategorizations);
    INCREMENT_COUNTER(CatCompletions);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CCategorizer::HrAdjustCompletionCounters
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\comdll.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: comdll.h
//
// Contents: definitions of things needed to implement comdll.cpp
//
// Classes:
//  CCatFactory
//  CSMTPCategorizer
//
// Functions:
//
// History:
// jstamerj 1998/12/12 15:18:03: Created.
//
//-------------------------------------------------------------
#ifndef __CATCOMDLL_H__
#define __CATCOMDLL_H__

#include <windows.h>
#include <objbase.h>
#include <baseobj.h>
#include <aqinit.h>
#include "smtpevent.h"
#include "address.h"
#include "catglobals.h"

//
// These defines are relevant to the Platinum version (phatq.dll)
//
#define SZ_PHATQCAT_FRIENDLY_NAME   "Microsoft Exchange Categorizer"
#define SZ_PROGID_PHATQCAT          "Exchange.PhatQCat"
#define SZ_PROGID_PHATQCAT_VERSION  "Exchange.PhatQCat.1"

//
// These defines are relevant to the NT5 version (aqueue.dll)
//
#define SZ_CATFRIENDLYNAME "Microsoft SMTPSVC Categorizer"
#define SZ_PROGID_SMTPCAT_VERSION   "Smtp.Cat.1"

#ifdef PLATINUM
#define SZ_CATVER_FRIENDLY_NAME     SZ_PHATQCAT_FRIENDLY_NAME
#define SZ_PROGID_CATVER            SZ_PROGID_PHATQCAT
#define SZ_PROGID_CATVER_VERSION    SZ_PROGID_PHATQCAT_VERSION
#define CLSID_CATVER                CLSID_PhatQCat
#else //PLATINUM
#define SZ_CATVER_FRIENDLY_NAME     SZ_CATFRIENDLYNAME
#define SZ_PROGID_CATVER            SZ_PROGID_SMTPCAT
#define SZ_PROGID_CATVER_VERSION    SZ_PROGID_SMTPCAT_VERSION
#define CLSID_CATVER                CLSID_SmtpCat
#endif //PLATINUM


extern LONG g_cObjects;

//
// The categorizer class factory
//
class CCatFactory : 
    public IClassFactory,
    public CBaseObject
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        ULONG lRet;
        lRet = CBaseObject::Release();

        if(lRet == 0) {
            //
            // Deinit reference added from DllGetClassObject
            //
            CatDeinitGlobals();
            DllDeinitialize();
        }
        return lRet;
    }

    //IClassFactory
    STDMETHOD (CreateInstance) (
        IUnknown *pUnknownOuter,
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD (LockServer) (
        BOOL fLock);

  public:
    CCatFactory()
    {
        InterlockedIncrement(&g_cObjects);
    }
    ~CCatFactory()
    {
        InterlockedDecrement(&g_cObjects);
    }
};

//
// The ISMTPCategorizer object
//
CatDebugClass(CSMTPCategorizer),
    public ISMTPCategorizer,
    public CBaseObject
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        ULONG lRet;
        lRet = CBaseObject::Release();
        if(lRet == 0) {
            //
            // Release DLL refcount added from this object's constructor
            //
            CatDeinitGlobals();
            DllDeinitialize();
        }
        return lRet;
    }

    //ISMTPCategorizer
    STDMETHOD (ChangeConfig) (
        IN  PCCATCONFIGINFO pConfigInfo);

    STDMETHOD (CatMsg) (
        IN  IUnknown *pMsg,
        IN  ISMTPCategorizerCompletion *pICompletion,
        IN  LPVOID pContext);

    STDMETHOD (CatDLMsg) (
        IN  IUnknown *pMsg,
        IN  ISMTPCategorizerDLCompletion *pICompletion,
        IN  LPVOID pContext,
        IN  BOOL fMatchOnly,
        IN  CAT_ADDRESS_TYPE CAType,
        IN  LPSTR pszAddress);

    STDMETHOD (CatCancel) ();

    //Constructor
    CSMTPCategorizer(HRESULT *phr);
    //Destructor
    ~CSMTPCategorizer();

  private:
    static HRESULT CatMsgCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

    static HRESULT CatDLMsgCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

  private:
    CABContext m_ABCtx;
    IUnknown *m_pMarshaler;

  private:
    typedef struct _CatMsgContext {
        CCategorizer *pCCat;
        CSMTPCategorizer *pCSMTPCat;
        ISMTPCategorizerCompletion *pICompletion;
        LPVOID pUserContext;
    } CATMSGCONTEXT, *PCATMSGCONTEXT;

    typedef struct _CatDLMsgContext {
        CCategorizer *pCCat;
        CSMTPCategorizer *pCSMTPCat;
        ISMTPCategorizerDLCompletion *pICompletion;
        LPVOID pUserContext;
        BOOL fMatch;
    } CATDLMSGCONTEXT, *PCATDLMSGCONTEXT;
};
#endif //__CATCOMDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccatrecip.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatrecip.cpp
//
// Contents: Implementation of classes:
//
// Classes:
//   CIMsgRecipListAddr
//   CCatRecip
//
// Functions:
//   CIMsgRecipListAddr::CIMsgRecipListAddr
//   CIMsgRecipListAddr::~CIMsgRecipListAddr
//   CIMsgRecipListAddr::GetSpecificOrigAddress
//   CIMsgRecipListAddr::CreateNewCatAddr
//   CIMsgRecipListAddr::HrAddAddresses
//   CIMsgRecipListAddr::SetUnresolved
//   CIMsgRecipListAddr::SetDontDeliver
//   CIMsgRecipListAddr::SetMailMsgCatStatus
//
//   CCatRecip::CCatRecip
//   CCatRecip::AddDLMember
//   CCatRecip::AddForward
//   CCatRecip::HrCompletion
//   CCatRecip::HandleFailure
//
// History:
// jstamerj 980325 15:32:17: Created.
//
//-------------------------------------------------------------

#include "precomp.h"

//
// class CIMsgRecipListAddr
//

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CIMsgRecipListAddr
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore: EmailIDStore to use
//   pIRC:   per IMsg resolve list context to use
//   prlc:   store context to use
//   hLocalDomainContext: local domain context to use
//   pBifMgr: bifurcation manager to use for getting other
//            IMailMsgRecipientsAdd interaces
//   pRecipsAdd: IMailMsgRecipientsAdd of the original recipient to
//               resolve
//   dwRecipIndex: Index in pRecipsAdd of the original recipient to
//                 resolve
//   fPrimary: TRUE means original recipient was added as primary
//             FALSE means original recipient was added as secondary
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 12:54:02: Created.
//
//-------------------------------------------------------------
CIMsgRecipListAddr::CIMsgRecipListAddr(
    CICategorizerListResolveIMP    *pCICatListResolve) :
    CCatAddr(pCICatListResolve)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::CIMsgRecipListAddr");
    TraceFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::~CIMsgRecipListAddr
//
// Synopsis: Releases the IMailMsgRecipientsAdd reference
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 12:59:50: Created.
//
//-------------------------------------------------------------
CIMsgRecipListAddr::~CIMsgRecipListAddr()
{
    TraceFunctEnterEx((LPARAM)this, "CImsgRecipListAddr::~CIMsgRecipListAddr");
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::GetSpecificOrigAddress
//
// Synopsis: Attempts to retrieve a specified original address
//
// Arguments:
//  CAType: Address type to retrieve
//  psz: Buffer to receive address string
//  dwcc: Size of that buffer
//
// Returns:
//  S_OK: Success
//  CAT_IMSG_E_PROPNOTFOUND: this recipient does not have that address
//  or other error from mailmsg
//
// History:
// jstamerj 1998/07/30 20:20:22: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::GetSpecificOrigAddress(
    CAT_ADDRESS_TYPE        CAType,
    LPSTR                   psz,
    DWORD                   dwcc)
{
    HRESULT hr;
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;

    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::GetSpecificOrigAddress");

    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipInfo failed with hr %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    hr = pRecipsAdd->GetStringA(
        dwRecipIndex,
        PropIdFromCAType(CAType),
        dwcc,
        psz);

    pRecipsAdd->Release();

    DebugTrace((LPARAM)this, "Item/GetStringA returned hr %08lx", hr);

    if(psz[0] == '\0')
        hr = CAT_IMSG_E_PROPNOTFOUND;

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CreateNewCatAddr
//
// Synopsis: CCatRecip methods call this function when they need to
//           create a new CCatRecip object and a corresponding recipient
//           in the member m_pRecipsAdd with one address only.  On
//           success, the CCatAddr is returned with a refcount of
//           one.
//
// Arguments:
//   CAType: Address type of new CCatRecip object
//   pszAddress: Address string.  If NULL, a new CCatRecip object is
//               created with properties set to point to the current
//               mailmsg recipient (AddPrimary/AddSecondary is not
//               called)
//   ppCCatAddr: Pointer to pointer to CCatAddr object that is set to
//               the newly allocated CCatRecip
//   fPrimary: if TRUE, add via AddPrimary
//             if FALSE, add via AddSecondary
//
// Returns:
//   S_OK: Success
//   E_OUTOFMEMORY: duh
//   CAT_E_PROP_NOT_FOUND: a required ICategorizerItem prop was not set
//   or Error from IMsg
//
// History:
// jstamerj 980325 14:15:50: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CreateNewCatAddr(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress,
    CCatAddr **ppCCatAddr,
    BOOL   fPrimary)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::CreateNewCatAddr");
    DWORD dwNewRecipIndex;
    HRESULT hr;
    LPCTSTR psz = pszAddress;
    DWORD dwPropId;
    IMailMsgRecipientsAdd *pRecipsAdd;
    IMailMsgProperties *pIMailMsgProps;
    DWORD dwOrigIndex;
    DWORD dwLevel;

    DebugTrace((LPARAM)this, "CAType = %d", CAType);

    if(pszAddress) {
        DebugTrace((LPARAM)this, "pszAddress = %s", pszAddress);
    } else {
        DebugTrace((LPARAM)this, "pszAddress = NULL");
    }

    DebugTrace((LPARAM)this, "fPrimary = %d", fPrimary);

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwOrigIndex, NULL, &pIMailMsgProps);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipInfo failed with hr %08lx", hr);
        return hr;
    }
    //
    // Get the recipient level
    //
    dwLevel = DWLevel() + 1;
    //
    // Unknown dwLevel is -1, so -1 + 1 = 0
    // If dwLevel is unknown, new value will be zero.
    //


    if(pszAddress == NULL) {
        //
        // Create new CCatAddr pointing to the CURRENT recipient
        //
        dwNewRecipIndex = dwOrigIndex;

    } else {
        //
        // Get the equivilant mailmsg propID
        //
        dwPropId = PropIdFromCAType(CAType);

        if(fPrimary) {
            hr = pRecipsAdd->AddPrimary(
                1,
                &psz,
                &dwPropId,
                &dwNewRecipIndex,
                pRecipsAdd,
                dwOrigIndex);
            _ASSERT(hr != CAT_IMSG_E_DUPLICATE);
        } else {
            hr = pRecipsAdd->AddSecondary(
                1,
                &psz,
                &dwPropId,
                &dwNewRecipIndex,
                pRecipsAdd,
                dwOrigIndex);
        }
        DebugTrace((LPARAM)this, "AddPrimary/AddSecondary returned hr %08lx", hr);
    }

    if(SUCCEEDED(hr)) {
        //
        // Alloc an ICategorizerItem so that it can set all the necessary properties
        //
        ICategorizerItem *pICatItemNew;

        hr = m_pCICatListResolve->AllocICategorizerItem(
            SOURCE_RECIPIENT,
            &pICatItemNew);
        DebugTrace((LPARAM)this, "AllocICategorizerItem returned hr %08lx", hr);
        if(SUCCEEDED(hr)) {
            //
            // Set important ICategorizerItem props on the newborn
            //
            hr = PutIMsgRecipInfo(
                &pRecipsAdd,
                &dwNewRecipIndex,
                &fPrimary,
                &pIMailMsgProps,
                // Only set dwLevel if the old value is known
                (dwLevel == 0) ? NULL : &dwLevel,
                pICatItemNew);

            // This should never fail
            _ASSERT(SUCCEEDED(hr));

            //
            // Get the CCatAddr object
            // This should never fail as no sinks have had the chance
            // to muck with properties yet.
            //
            hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
                pICatItemNew,
                ppCCatAddr);

            _ASSERT(SUCCEEDED(hr));
        }

    } else if(hr == CAT_IMSG_E_DUPLICATE) {

        INCREMENT_COUNTER(MailmsgDuplicateCollisions);
    }


    pRecipsAdd->Release();
    pIMailMsgProps->Release();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::HrAddAddresses
//
// Synopsis: Add the addresses contained in the arrays to the IMsg
//           recipient we contain
//
// Arguments:
//  dwNumAddresses: Number of new addresses
//  rgCAType: Array of address types
//  rgpsz: Array of pointers to address strings
//
// Returns:
//  S_OK: Success
//  CAT_E_FORWARD_LOOP: One or more of the new addresses is a
//  duplicate of a recipient in the parent chain
//  CAT_E_NO_SMTP_ADDRESS: Did not add the new addresses because there
//  is no SMTP address
//
// History:
// jstamerj 980325 14:21:56: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::HrAddAddresses(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::AddAddresses");
    HRESULT hr, hrDupCheck;

    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwOrigIndex;
    BOOL fPrimary;
    DWORD dwCount;
    DWORD dwNewIndex;
    DWORD dwPropIds[CAT_MAX_ADDRESS_TYPES];
    BOOL  fSMTPAddress;
    DWORD dwSMTPAddressIdx = 0;

    _ASSERT(dwNumAddresses > 0);
    _ASSERT(dwNumAddresses <= CAT_MAX_ADDRESS_TYPES);

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwOrigIndex, &fPrimary, NULL);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipPrimaryInfo failed with hr %08lx", hr);
        return hr;
    }
    //
    // Initialize the array of address types
    //
    fSMTPAddress = FALSE;
    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {


        dwPropIds[dwCount] = PropIdFromCAType(rgCAType[dwCount]);
        if(rgCAType[dwCount] == CAT_SMTP) {
            fSMTPAddress = TRUE;
            dwSMTPAddressIdx = dwCount;
        }
    }

    if(fSMTPAddress == FALSE) {
        ErrorTrace((LPARAM)this, "Not delivering to recipient without an SMTP address");
        hr = CAT_E_NO_SMTP_ADDRESS;
        goto CLEANUP;
    }
    //
    // Validate the SMTP address
    //
    hr = HrValidateAddress(
        rgCAType[dwSMTPAddressIdx],
        rgpsz[dwSMTPAddressIdx]);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Default SMTP address is invalid: %s",
                   rgpsz[dwSMTPAddressIdx]);
        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }

    //
    // Call IMsg add with new addresses
    // If we're primary, we remain primary.
    //
    if(fPrimary) {
        //
        // We need to check for a loop here too since there could be a
        // loop where some other recipient is forwarding to one of our
        // non-default proxy addresses (bug #70220)
        //
        hr = CheckForLoop(
            dwNumAddresses,
            rgCAType,
            rgpsz,
            FALSE); // No need to check ourself for a duplicate

        if(SUCCEEDED(hr)) {

            hr = pRecipsAdd->AddPrimary(
                dwNumAddresses,
                (LPCSTR *)rgpsz,
                dwPropIds,
                &dwNewIndex,
                pRecipsAdd,
                dwOrigIndex);
            _ASSERT(hr != CAT_IMSG_E_DUPLICATE);
        }

    } else {

        hr = pRecipsAdd->AddSecondary(
            dwNumAddresses,
            (LPCSTR *)rgpsz,
            dwPropIds,
            &dwNewIndex,
            pRecipsAdd,
            dwOrigIndex);

        if(hr == CAT_IMSG_E_DUPLICATE) {

            INCREMENT_COUNTER(MailmsgDuplicateCollisions);
            //
            // The duplicate might be us (the recipient in the mailmsg
            // before resolution)
            //
            hrDupCheck = CheckForDuplicateCCatAddr(
                dwNumAddresses,
                rgCAType,
                rgpsz);

            if(hrDupCheck == CAT_IMSG_E_DUPLICATE) {
                //
                // So we do collide with our parent.
                // Remove if from duplicate detection and try again.
                //
                hr = RemoveFromDuplicateRejectionScheme(TRUE);

                if(SUCCEEDED(hr)) {
                    hr = pRecipsAdd->AddSecondary(
                        dwNumAddresses,
                        (LPCSTR *)rgpsz,
                        dwPropIds,
                        &dwNewIndex,
                        pRecipsAdd,
                        dwOrigIndex);

                    if(hr == CAT_IMSG_E_DUPLICATE)
                        INCREMENT_COUNTER(MailmsgDuplicateCollisions);

                }

            } else if(FAILED(hrDupCheck)) {
                //
                // Return the error
                //
                hr = hrDupCheck;
            }

            if(hr == CAT_IMSG_E_DUPLICATE) {
                //
                // If hr is STILL Duplicate, check to see if it's a loop
                // we've encountered
                //
                hrDupCheck = CheckForLoop(
                    dwNumAddresses,
                    rgCAType,
                    rgpsz,
                    FALSE); // No need to check ourself for a
                            // duplicate

                if(FAILED(hrDupCheck)) {
                    //
                    // Return the error -- this could be
                    // CAT_E_FORWARD_LOOP
                    //
                    hr = hrDupCheck;
                }
            }
        }
    }

    DebugTrace((LPARAM)this, "AddPrimary/AddSecondary returned hr %08lx", hr);

    if(SUCCEEDED(hr)) {
        // Since we were just adding addresses for the same recipient,
        // always mark the old recipient as "Don't deliver"
        hr = SetDontDeliver(TRUE);
        if(SUCCEEDED(hr)) {
            //
            // Relase old Recipient, update this to point to the new
            // recipient
            // IMailMsgRecipients and fPrimary always remain the same
            // for default processing
            //
            hr = PutIMailMsgRecipientsAddIndex(dwNewIndex, this);
        }
    }
 CLEANUP:
    pRecipsAdd->Release();
    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::SetUnresolved
//
// Synopsis: Sets recipient property on IMsg indicating this recipient
//           could not be resolved -- this will cause NDR generation for the
//           recipient
//
// Arguments:
//  HrReason: Reason why address is unresolved
//
// Returns:
//  S_OK: Success
//  Or error from IMsg
//
// History:
// jstamerj 980325 14:29:45: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::SetUnresolved(
    HRESULT HrStatus)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetUnresolved");
    HRESULT hr;
    IMailMsgRecipientsAdd *pRecipsAdd;
    IMailMsgProperties *pIMailMsgProps;
    DWORD dwRecipIndex;
    DWORD dwFlags = 0;

    INCREMENT_COUNTER(NDRdRecipients);

    switch(HrStatus) {

     case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
         INCREMENT_COUNTER(UnresolvedRecipients);
         break;

     case CAT_E_MULTIPLE_MATCHES:
         INCREMENT_COUNTER(AmbiguousRecipients);
         break;

     case CAT_E_ILLEGAL_ADDRESS:
         INCREMENT_COUNTER(IllegalRecipients);
         break;

     case CAT_E_FORWARD_LOOP:
         INCREMENT_COUNTER(LoopRecipients);
         break;

     default:
         INCREMENT_COUNTER(GenericFailureRecipients);
         break;
    }

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, &pIMailMsgProps);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipPrimaryInfo failed with hr %08lx", hr);
        return hr;
    }

    hr = pRecipsAdd->GetDWORD(dwRecipIndex,
                              IMMPID_RP_RECIPIENT_FLAGS,
                              &dwFlags);
    if(SUCCEEDED(hr) || (hr == CAT_IMSG_E_PROPNOTFOUND)) {

        dwFlags |= (RP_ERROR_CONTEXT_CAT | RP_UNRESOLVED);

        hr = pRecipsAdd->PutDWORD(dwRecipIndex,
                                  IMMPID_RP_RECIPIENT_FLAGS,
                                  dwFlags);

        if(SUCCEEDED(hr)) {

            hr = pRecipsAdd->PutDWORD(
                dwRecipIndex,
                IMMPID_RP_ERROR_CODE,
                HrStatus);

            if(SUCCEEDED(hr)) {

                hr = SetMailMsgCatStatus(
                    pIMailMsgProps,
                    CAT_W_SOME_UNDELIVERABLE_MSGS);
            }
        }
    }
    pRecipsAdd->Release();
    pIMailMsgProps->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::SetDontDeliver
//
// Synopsis: Sets the IMsg property on a recipient that indicates this
//           recipient should be removed upon a call to WriteList
//
// Arguments:
//   fDontDeliver: TRUE means remove recipient on a WriteList
//                 FALSE means clear DontDeliver property, don't
//                 remove on a WriteList
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:34:44: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::SetDontDeliver(BOOL fDontDeliver)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetDontDeliver");
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;
    HRESULT hr;

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipPrimaryInfo failed with hr %08lx", hr);
        return hr;
    }

    hr = pRecipsAdd->PutBool(dwRecipIndex,
                             IMMPID_RPV_DONT_DELIVER,
                             fDontDeliver);
    pRecipsAdd->Release();
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::RemoveFromDuplicateRejectionScheme
//
// Synopsis: Sets the IMsg property to indicate this recipient's names
//           should be ignored for duplicate detection
//
// Arguments:
//   fRemove: TRUE means remove recipient for dup detection
//            FALSE means clear property, don't remove recip for dup detection.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:34:44: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::RemoveFromDuplicateRejectionScheme(BOOL fRemove)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetDontDeliver");
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;
    HRESULT hr;

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMsgRecipPrimaryInfo failed with hr %08lx", hr);
        return hr;
    }

    hr = pRecipsAdd->PutBool(dwRecipIndex,
                             IMMPID_RPV_NO_NAME_COLLISIONS,
                             fRemove);
    pRecipsAdd->Release();
    TraceFunctLeave();
    return hr;
}

//
// class CCatRecip
//

//+------------------------------------------------------------
//
// Function: CCatRecip::CCatRecip
//
// Synopsis: initialize member data
//
// Arguments:
//   See CIMsgRecipListAddr::CIMsgRecipListAddr
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 14:36:30: Created.
//
//-------------------------------------------------------------
CCatRecip::CCatRecip(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CCatExpandableRecip(pCICatListResolve)
{
    TraceFunctEnterEx((LPARAM)this, "CCatRecip::CCatRecip");

    INCREMENT_COUNTER(RecipsInMemory);

    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCatRecip::~CCatRecip
//
// Synopsis: Decrement count of recips in memory
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/02/24 19:26:01: Created.
//
//-------------------------------------------------------------
CCatRecip::~CCatRecip()
{
    DECREMENT_COUNTER(RecipsInMemory);
}



//+------------------------------------------------------------
//
// Function: CCatRecip::AddDLMember
//
// Synopsis: EmailIDStore calls this function once for every DL Member
//           when setting properties on a DL.  It is called before
//           CCatRecip::HrCompletion
//
// Arguments:
//   CAType: Known address type of the DL Member
//   pszAddress: pointer to the address string
//
// Returns:
//  S_OK: Success, issued a pending LDAP search
//  S_FALSE: Success, did not issue a search
//  Or, error from IMsg
//
// History:
// jstamerj 980325 14:39:20: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)
{
    HRESULT hr;
    CCatAddr *pMember = NULL;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::AddDLMember");
    DebugTrace((LPARAM)this, "CAType: %d", CAType);
    DebugTrace((LPARAM)this, "pszAddress: %s", pszAddress);

    hr = GetListResolveStatus();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Not adding DL member since list resolve failed");
        // Signal to ldapstor to stop resolution
        goto CLEANUP;
    }

    //
    // Validate the new address first
    //
    hr = HrValidateAddress(CAType, pszAddress);
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Invalid member address");
        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }


    // Create a new CCatAddr to handle resolution of this DL Member
    hr = CreateNewCatAddr(
        CAType,
        pszAddress,
        &pMember,
        FALSE);

    if(hr == CAT_IMSG_E_DUPLICATE) {
        DebugTrace((LPARAM)this, "Resolution failed with e_duplicate");
        // Fine, DL member was a duplicate so we won't be
        // re-resolving it.  Let it be.
    } else if(SUCCEEDED(hr)) {

        // Great....dispatch the query to the store
        hr = pMember->HrResolveIfNecessary();
        pMember->Release();
    }

 CLEANUP:
    if(hr == CAT_IMSG_E_DUPLICATE)
        hr = S_FALSE;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCatRecip::AddDynamicDlMember
//
// Synopsis: Add a DL member that has already been looked up in the DS
//
// Arguments:
//  pICatItemAttr: the attributes of the DL member
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: doing an async operation, will call your
//  completion routine when I am finished
//
// History:
// jstamerj 1998/09/29 21:30:26: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddDynamicDLMember(
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr;
    CCatAddr *pMember = NULL;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::AddDynamicDlMember");

    _ASSERT(pICatItemAttr);

    hr = GetListResolveStatus();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Not adding DL member since list resolve failed");
        // Signal to ldapstor to stop resolution
        goto CLEANUP;
    }
    //
    // Create a new CCatAddr for this member -- pass in NULL for
    // pszAddress so the new CCatAddr properties will point to the DL itself
    //
    hr = CreateNewCatAddr(
        CAT_UNKNOWNTYPE,
        NULL,
        &pMember,
        FALSE);

    _ASSERT(hr != CAT_IMSG_E_DUPLICATE);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "CreateNewCatAddr failed with hr %08lx", hr);
        goto CLEANUP;
    }
    //
    // Since we've already looked up the attributes, just set the
    // ICatItemAttr property of the new guy and trigger
    // ProcessItem/ExpandItem/CompleteItem
    //
    hr = pMember->PutHRESULT(
        ICATEGORIZERITEM_HRSTATUS,
        S_OK);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pMember->PutICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        pICatItemAttr);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Simulate DS completion
    //
    IncPendingLookups();
    pMember->LookupCompletion();
    hr = S_OK;

 CLEANUP:
    if(pMember)
        pMember->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}




//+------------------------------------------------------------
//
// Function: CCatRecip::AddForward
//
// Synopsis: EMailIDStore calls this function once for every
//           forwarding address the recipient has.  It is called before
//           CCatRecip::HrCompletion.  On any unhandleable errors,
//           this function sets a list resolve error (instead of
//           returning an error)
//
// Arguments:
//   CAType: Known address type of the forwarding address
//   szForwardingAddres: The forwarding address
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:48:49: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddForward(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR szForwardingAddress)
{
    TraceFunctEnterEx((LPARAM)this, "CCatRecip::AddForward");
    DebugTrace((LPARAM)this, "CAType: %d", CAType);
    DebugTrace((LPARAM)this, "szForwardingAddress: %s", szForwardingAddress);
    HRESULT hr;
    CCatAddr *pCCatAddr;
    BOOL fPrimary;

    //
    // Is the forwarding address valid?
    //
    hr = HrValidateAddress(CAType, szForwardingAddress);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Forwarding address string is invalid");

        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }


    hr = GetFPrimary(&fPrimary);

    if(FAILED(hr)) {
        //
        // We're dead..
        //
        ErrorTrace((LPARAM)this, "fPrimary property not set on ICatItem hr %08lx", hr);
        goto CLEANUP;
    }

    //
    // jstamerj 1998/07/31 19:58:53:
    //  If we're in the primary chain, we MUST check to see if we're
    //  in a forwarding loop before we call AddPrimary
    //  This is the place to do it
    //
    if(fPrimary) {
        //
        // Check for a loop before adding the forwarding address
        //
        hr = CheckForLoop(
            CAType,
            szForwardingAddress,
            TRUE);  // Check this object too (you could forward to yourself)

        if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "CheckForLoop failed hr %08lx", hr);
            goto CLEANUP;
        }
    }

    // Create the new address object with the address we know about
    hr = CreateNewCatAddr(CAType,
                          szForwardingAddress,
                          &pCCatAddr,
                          fPrimary);

    if(hr == CAT_IMSG_E_DUPLICATE) {

        _ASSERT(fPrimary == FALSE);
        DebugTrace((LPARAM)this, "Duplicate from CreateNewCatAddr, checking for a loop");

        //
        // Did we hit duplicate because we're in a loop?
        //
        hr = CheckForLoop(
            CAType,
            szForwardingAddress,
            TRUE);  // CHeck this object too

    } else if(SUCCEEDED(hr)) {
        //
        // Since this is forwarding, we need to set the parent
        // ICatItem pointer (to be able to do loop detection)
        //
        hr = PutICategorizerItemParent(
            this,
            pCCatAddr);

        _ASSERT(SUCCEEDED(hr));

        //
        // Resolve the new address
        //
        hr = pCCatAddr->HrResolveIfNecessary();

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Unable to dispatch query for forwarding address");
        }
        pCCatAddr->Release();
    }
 CLEANUP:
    if(FAILED(hr) && (hr != CAT_E_FORWARD_LOOP)) {

        ErrorTrace((LPARAM)this, "Setting the list resolve error:%08lx", hr);
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrCompleteItem_Default
//
// Synopsis: Handle the CompleteItem call; finally make decisions
// about what to do concerning HrStatus failures.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 18:50:01: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrCompleteItem_Default()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HrCompleteItem_Default");

    hr = GetItemStatus();
    //
    // Try to handle failures
    //
    if(FAILED(hr)) {

        hr = HandleFailure(hr);
        //
        // If we couldn't handle the recipient failure, fail the whole message
        // categorization
        //
        if(FAILED(hr)) {
            _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CCatRecip::HandleFailure
//
// Synopsis: When a completion happens with a failure status, this is
// the helper routine to handle the failure.  If the failure can be
// handeled, S_OK is returned.  If not, the failure itself is returned
//
// Arguments:
//  HrFailure: the failure error code
//
// Returns:
//  S_OK: Success
//  or error from Mailmsg
//
// History:
// jstamerj 1998/07/21 18:00:47: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HandleFailure(
    HRESULT HrFailure)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HandleFailure");

    _ASSERT(FAILED(HrFailure));

    switch(HrFailure) {

     case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
     {
         //
         // Address was not found but it is not a local address anyway
         //
         DebugTrace((LPARAM)this, "Remote address not found in DS");

         hr = S_OK;
     }

     case CAT_E_FORWARD_LOOP:
     case CAT_IMSG_E_DUPLICATE:
     case CAT_E_NO_SMTP_ADDRESS:
     {
         //
         // This guy was either a failed resolve where it turns out we
         // already resolved the recipient (in another place in the
         // recip list) or a recipient in a detected loop.  Don't do
         // anything here, DSN flags were/will be set in HandleLoopHead
         //
         hr = S_OK;
         break;
     }

     case CAT_E_BAD_RECIPIENT:
     {
         //
         // A generic recipient error code that indicates this
         // recipient should be NDR'd.  An optional reason can be set
         // in the ICATEGORIZERITEM_HRNDR property
         //
         HRESULT hrReason;
         hr = GetHRESULT(
             ICATEGORIZERITEM_HRNDRREASON,
             &hrReason);

         if(FAILED(hr)) {
             //
             // Use the generic error code for the NDR reason also
             //
             hrReason = CAT_E_BAD_RECIPIENT;
         }

         ErrorTrace((LPARAM)this, "NDRing recipient with error code %08lx",
                    hrReason);

         hr = SetUnresolved(hrReason);
         break;
     }
     case CAT_E_DELETE_RECIPIENT:
     {
         //
         // Don't deliver to this recipient
         //
         hr = SetDontDeliver(TRUE);
         break;
     }

     default:
     {
         //
         // EmailIDStore is informing us of an unrecoverable error
         // There's nothing we can do to handle this error except
         // return it (HrCompletion will then SetListResolveStatus)
         //
         ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", HrFailure);
         hr = HrFailure;
         break;
     }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CheckForLoop
//
// Synopsis: Helper routine to check for a loop in our ancestors
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: array of address types
//  rgpsz: array of string pointers
//  fCheckSelf: Check for a dupicate with this CCatAddr?
//
// Returns:
//  S_OK: Success, no loops
//  CAT_E_FORWARD_LOOP: Detected a loop and called HandleLoopHead
//  successfully
//  or error from CheckAncestorsForDuplicate/HandleLoopHead
//
// History:
// jstamerj 1998/08/01 16:05:51: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CheckForLoop(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPSTR *rgpsz,
    BOOL fCheckSelf)
{
    HRESULT hr;
    CCatAddr *pCCatAddrDup;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::CheckForLoop");

    hr = CheckAncestorsForDuplicate(
        dwNumAddresses,
        rgCAType,
        rgpsz,
        fCheckSelf,
        &pCCatAddrDup);

    if (hr == CAT_IMSG_E_DUPLICATE) {
        //
        // We've got a loop!
        //
        ErrorTrace((LPARAM)this, "Loop detected!");

        //
        // Generate the DSN on the CCatAddr at the top of the loop
        //
        hr = pCCatAddrDup->HandleLoopHead();
        if(SUCCEEDED(hr)) {
            //
            // Return error to caller
            //
            hr = CAT_E_FORWARD_LOOP;
        }
        pCCatAddrDup->Release();
    }
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CheckForLoop
//
// Synopsis: Same as above with different style parameters
//
// Arguments:
//  CAType: Addres type of pszAddress
//  pszAddress: Address string
//  fCheckSelf: Check this CCatAddr for a duplicate as well?
//
// Returns:
//  S_OK: Success
//  CAT_E_FORWARD_LOOP: Detected a loop and called HandleLoopHead
//  successfully
//  or error from CheckAncestorsForDuplicate/HandleLoopHead
//
// History:
// jstamerj 1998/08/01 16:10:28: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CheckForLoop(
    CAT_ADDRESS_TYPE        CAType,
    LPTSTR                  pszAddress,
    BOOL                    fCheckSelf)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CCatRecip::CheckForLoop");

    hr = CheckForLoop(
        1,              // Number of addresses
        &CAType,        // TYpe array
        &pszAddress,    // String ptr array
        fCheckSelf);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HandleLoopHead
//
// Synopsis: This is called when it is determined that this CCatAddr
// is the first in a loop chain.  It ensures an NDR will be generated
// for this recipient
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  or error from MailMsg
//
// History:
// jstamerj 1998/08/01 16:41:44: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HandleLoopHead()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HandleLoopHead");

    //
    // Set the status on this recipient to loop error, and UNSET Don't
    // Deliver so an NDR gets generated
    //
    hr = SetRecipientStatus(
        CAT_E_BAD_RECIPIENT);

    if(SUCCEEDED(hr)) {
        //
        // Set the reason
        //
        hr = SetRecipientNDRCode(
            CAT_E_FORWARD_LOOP);

        if(SUCCEEDED(hr)) {
            //
            // Set DSN flags
            //
            hr = SetUnresolved(CAT_E_FORWARD_LOOP);

            if(SUCCEEDED(hr)) {
                //
                // Make sure DSN will be generated even if we previously
                // wern't planning to deliver to this recipient
                //
                hr = SetDontDeliver(FALSE);
            }
        }
    }
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrHandleInvalidAddress
//
// Synopsis: Do what needs to be done when an invalid address is
// detected (either forwarding to an invalid address or a DL member
// with an invalid address or a new address that is invalid)
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/08/18 18:53:45: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrHandleInvalidAddress()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HandleInvalidAddress");

    //
    // Set the status on this recipient to casue an NDR
    //
    hr = SetRecipientStatus(
        CAT_E_BAD_RECIPIENT);

    //
    // That should never fail
    //
    _ASSERT(SUCCEEDED(hr));

    //
    // Set the status on this recipient to invalid address error
    //
    hr = SetRecipientNDRCode(
        CAT_E_ILLEGAL_ADDRESS);

    //
    // That should never fail
    //
    _ASSERT(SUCCEEDED(hr));

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::LookupCompletion
//
// Synopsis: Lookup completion routine for a recipient.  Implement
//           defer logic so that RecipLookupCompletion is called after the
//           sender is resolved.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 10:10:47: Created.
//
//-------------------------------------------------------------
VOID CCatRecip::LookupCompletion()
{
    TraceFunctEnterEx((LPARAM)this, "CCatRecip::LookupCompletion");

    INCREMENT_COUNTER(AddressLookupCompletions);

    m_pCICatListResolve->ResolveRecipientAfterSender(this);

    TraceFunctLeaveEx((LPARAM)this);
} // CCatRecip::LookupCompletion


//+------------------------------------------------------------
//
// Function: CCatRecip::RecipLookupCompletion
//
// Synopsis: Handle lookup completion from the emailidstore
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/01 14:36:08: Created.
// jstamerj 1999/03/18 10:08:26: Removed return value, removed async
//                               completion to asyncctx.  Renamed to
//                               RecipLookupCompletion and removed
//                               defer logic
//
//-------------------------------------------------------------
VOID CCatRecip::RecipLookupCompletion()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::RecipLookupCompletion");

    hr = GetItemStatus();

    if(FAILED(hr)) {
        //
        // Recipient status indicates failure -- decide now if we
        // should NDR
        //
        switch(hr) {

         case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
         {
             //
             // Address was not found.  Determine if the original
             // address we looked up looks local mailbox or not.
             //
             INCREMENT_COUNTER(AddressLookupsNotFound);

             DebugTrace((LPARAM)this, "Address was not found in DS.  Checking locality");

             BOOL fNDR;
             hr = HrNdrUnresolvedRecip(&fNDR);

             if(SUCCEEDED(hr) && fNDR) {
                 //
                 // It's local and we need to NDR this recip
                 //
                 ErrorTrace((LPARAM)this, "Address appears to be local but was not found in DS.  Setting unresolved property.");
                 //
                 // Set NDR Status and the reason
                 //
                 hr = SetRecipientStatus(CAT_E_BAD_RECIPIENT);
                 if(SUCCEEDED(hr)) {

                     hr = SetRecipientNDRCode(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
                 }
             }
             break;
         }

         case CAT_E_MULTIPLE_MATCHES:
         case CAT_E_ILLEGAL_ADDRESS:
         case CAT_E_NO_FILTER:
         {
             //
             // Multiple entries for this guy exist in the DS or this guy
             // has an illegal address/forwards to an illegal address
             //
             ErrorTrace((LPARAM)this, "NDRing recipient, reason%08lx",
                        hr);

             hr = SetRecipientNDRCode(hr);
             if(SUCCEEDED(hr)) {

                 hr = SetRecipientStatus(CAT_E_BAD_RECIPIENT);
             }
             break;
         }
         case CAT_E_BAD_RECIPIENT:
         {
             //
             // We processed this recipient earlier and returned defer
             //
             hr = S_OK;
             break;
         }
         default:
         {
             //
             // EmailIDStore is informing us of an unrecoverable error
             // There's nothing we can do to handle this error except
             // fail the entire message categorization
             //
             ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", hr);
             break;
         }
        }
    }

    //
    // If we handeled the error, go ahead and trigger events.
    // Otherwise, we're failing the message categorization so forget
    // it
    //
    if(SUCCEEDED(hr)) {

        CCatAddr::LookupCompletion();
    }

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "failing msg categorization hr %08lx", hr);
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    TraceFunctLeaveEx((LPARAM)this);
}




//+------------------------------------------------------------
//
// Function: CCatRecip::HrProcessItem_Default
//
// Synopsis: The default sink code for the ProcessItem event.
//           Override CCatAddr's implementation so that we can catch
//           and handle errors from AddAddresses
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
// jstamerj 1998/12/01 14:47:15: //
// History:
// jstamerj 980325 14:57:05: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrProcessItem_Default()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HrProcessItem_Default");

    //
    // CHeck the recipient status
    //
    hr = GetItemStatus();

    if(SUCCEEDED(hr)) {
        //
        // Add all known addresses to the new address list
        //
        hr = HrAddNewAddressesFromICatItemAttr();

        if((hr == CAT_IMSG_E_DUPLICATE) || (hr == CAT_E_FORWARD_LOOP) ||
           (hr == CAT_E_NO_SMTP_ADDRESS) || (hr == CAT_E_DELETE_RECIPIENT)) {

            DebugTrace((LPARAM)this, "AddAddresses failed, removing recip, hr %08lx", hr);
            //
            // Set the recip status to an error so we don't do
            // anything stupid later (like spinning off a resolve for
            // an alternate recipient later)
            //
            hr = SetRecipientStatus(hr);
            if(SUCCEEDED(hr)) {
                //
                // Don't deliver to this partialy resolved recipient
                //
                hr = SetDontDeliver(TRUE);
            }
        }
        //
        // Fail the categorization if the above calls failed
        //
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Setting list resolve error %08lx", hr);
            hr = SetListResolveStatus(hr);
            _ASSERT(SUCCEEDED(hr));
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrExpandItem_Default
//
// Synopsis: Handle the ExpandItem event
//
// Arguments:
//  pfnCompletion: Async completion routine
//  pContext: Context to pass to async completion
//
// Returns:
//  S_OK: Success, will NOT call async completion
//  MAILTRANSPORT_S_PENDING: Will call async completion
//
// History:
// jstamerj 1998/07/31 18:29:57: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrExpandItem_Default(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    HRESULT hrRet = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CCatRecip::HrExpandItem_Default");

    //
    // CHeck the recipient status
    //
    hr = GetItemStatus();

    if(SUCCEEDED(hr)) {
        //
        // Call AddDlMember/AddForward once per DL member or
        // forwarding address
        //
        hr = HrAddDlMembersAndForwardingAddresses(
            pfnCompletion,
            pContext);

        DebugTrace((LPARAM)this, "HrAddDlMembersAndForwardingAddresses returned hr %08lx", hr);
        //
        // if hr is a failure value, something must have failed; so we fail
        // the whole message categorization
        //
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Setting list resolve error %08lx", hr);
            _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));

        } else {
            //
            // Return the status returned from HrAddDlMembers...
            // It could be S_OK or S_PENDING
            //
            hrRet = hr;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hrRet;
}


//+------------------------------------------------------------
//
// Function: CCatRecipient::HrNeedsResolving
//
// Synopsis: Determines if this recipient should be resolved or not
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, it needs resolving
//  S_FALSE: Success, it doesn't need to be resolved
//
// History:
// jstamerj 1998/10/27 15:45:22: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrNeedsResolveing()
{
    DWORD dwFlags;
    HRESULT hr;

    dwFlags = GetCatFlags();

    //
    // Do we resolve recipients at all?
    //
    if(! (dwFlags & SMTPDSFLAG_RESOLVERECIPIENTS))
        return S_FALSE;

#define ISTRUE( x ) ( (x) != 0 ? TRUE : FALSE )
    //
    // Do we need to check if the address is local or not?
    //
    if( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) !=
        ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE)) {
        //
        // We're resolving either local or remote (not both)
        //
        BOOL fLocal;

        hr = HrIsOrigAddressLocal(&fLocal);

        if(FAILED(hr))
            return hr;
        //
        // Resolve if it's local and we're resolving local addrs
        //
        if( (dwFlags & SMTPDSFLAG_RESOLVELOCAL) &&
            (fLocal))
            return S_OK;
        //
        // Resolve if it's remote and we're resolving remote addrs
        //
        if( (dwFlags & SMTPDSFLAG_RESOLVEREMOTE) &&
            (!fLocal))
            return S_OK;
        //
        // else Don't resolve
        //
        return S_FALSE;
    }
    //
    // 2 possabilities -- local and remote bits are on OR local and
    // remote bits are off
    //
    _ASSERT( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) ==
             ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE));

    if(dwFlags & SMTPDSFLAG_RESOLVELOCAL) {
        //
        // Both bits are on; Resolve
        //
       _ASSERT(dwFlags & SMTPDSFLAG_RESOLVEREMOTE);

        return S_OK;

    } else {
        //
        // local and remote are disabled; don't resolve
        //
        return S_FALSE;
    }
}

//
// class CCatExpandableRecip
//

//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses
//
// Synopsis: Dig through the ICatItemAttr and figure out wether to
//           call HrAddDlMembers or HrAddForwardingAddresses
//
// Arguments:
//  PFN_EXPANDITEMCOMPLETION pfnCompletion: Async completion routine
//  PVOID pContext: completion routine context
//
// Returns:
//  S_OK: Success, will not call completion routine
//  MAILTRANSPORT_S_PENDING: Will call completion routine
//  or error from mailmsg/icatitem/HrAddDlMembers/HrAddForwardingAddresses
//
// History:
// jstamerj 1998/09/29 11:28:54: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerParameters *pICatParams;
    LPSTR pszX500DL = NULL;
    LPSTR pszSMTPDL = NULL;
    LPSTR pszDynamicDL = NULL;
    LPSTR pszObjectClassAttribute;
    LPSTR pszObjectClass;
    DLOBJTYPE dlt;
    ATTRIBUTE_ENUMERATOR enumerator;

    TraceFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        goto CLEANUP;
    }

    //
    // Fetch DL objectclasses from IDSParams
    //  On failure, the LPSTR will remain pointed to NULL
    //
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_X500,
        &pszX500DL);
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_SMTP,
        &pszSMTPDL);
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_DYNAMIC,
        &pszDynamicDL);

    //
    // Fetch objectclass attribute string from IDSParams
    //
    hr = pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_OBJECTCLASS,
        &pszObjectClassAttribute);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Now, try to match a DL objectClass with something in
    // pICatItemAttr
    //
    hr = pICatItemAttr->BeginAttributeEnumeration(
        pszObjectClassAttribute,
        &enumerator);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pICatItemAttr->GetNextAttributeValue(
        &enumerator,
        &pszObjectClass);

    for (dlt = DLT_NONE; SUCCEEDED(hr) && (dlt == DLT_NONE);) {
        if (pszX500DL && (lstrcmpi(pszObjectClass, pszX500DL) == 0)) {

            dlt = DLT_X500;

        } else if (pszSMTPDL && (lstrcmpi(pszObjectClass, pszSMTPDL) == 0)) {

            dlt = DLT_SMTP;

        } else if (pszDynamicDL && (lstrcmpi(pszObjectClass, pszDynamicDL) == 0)) {

            dlt = DLT_DYNAMIC;
        }
        hr = pICatItemAttr->GetNextAttributeValue(
            &enumerator,
            &pszObjectClass);
    }
    pICatItemAttr->EndAttributeEnumeration(
        &enumerator);

    //
    // Call the appropriate routine
    //
    if(dlt == DLT_NONE) {

        hr = HrAddForwardingAddresses();
        _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    } else {

        hr = HrAddDlMembers(
            dlt,
            pfnCompletion,
            pContext);
    }

 CLEANUP:
    if(pICatItemAttr)
        pICatItemAttr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddForwardingAddresses
//
// Synopsis: Call AddForward once for every forwarding address found
//           in ICatItemAttr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/29 13:56:37: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddForwardingAddresses()
{
    HRESULT hr;
    ICategorizerParameters *pICatParams;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ATTRIBUTE_ENUMERATOR enumerator;
    LPSTR pszForwardingSMTPAttribute;
    LPSTR pszForwardingSMTPAddress;
    BOOL fForwarding = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddForwardingAddresses");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        goto CLEANUP;
    }

    //
    // Get the Forwarding address(es)
    //
    hr = pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_FORWARD_SMTP,
        &pszForwardingSMTPAttribute);
    if(SUCCEEDED(hr)) {
        hr = pICatItemAttr->BeginAttributeEnumeration(
            pszForwardingSMTPAttribute,
            &enumerator);
        if(SUCCEEDED(hr)) {
            hr = pICatItemAttr->GetNextAttributeValue(
                &enumerator,
                &pszForwardingSMTPAddress);
            while(SUCCEEDED(hr)) {
                //
                // jstamerj 980317 15:53:34: Adding support for multiple
                // forwarding addresses -- send to all of them.
                //
                _VERIFY(SUCCEEDED(
                    AddForward( CAT_SMTP,
                                pszForwardingSMTPAddress )));
                //
                // Remember that we're forwarding to at least one address
                //
                fForwarding = TRUE;

                hr = pICatItemAttr->GetNextAttributeValue(
                    &enumerator,
                    &pszForwardingSMTPAddress);

            }
            pICatItemAttr->EndAttributeEnumeration(&enumerator);
        }
    }
    //
    // Check our recipient status -- if it's a failure, that means
    // we're NDRing this recipient due to an invalid address,
    // forward loop, etc.  In this case, we don't want to mark
    // "Don't Deliver"
    //
    if(fForwarding && SUCCEEDED(GetItemStatus())) {
        //
        // Don't deliver to the original recipient when we're
        // forwarding
        //
        hr = SetDontDeliver(TRUE);

    } else {
        //
        // Don't return errors from attribute enumeration calls
        //
        hr = S_OK;
    }

 CLEANUP:
    if(pICatItemAttr)
        pICatItemAttr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddDlMembers
//
// Synopsis: Call AddDlMember (or AddDynamicDlMember) once for every
//           DlMember
//
// Arguments:
//  dlt: The type of the DL we're expanding
//  PFN_EXPANDITEMCOMPLETION pfnCompletion: Async completion routine
//  PVOID pContext: completion routine context
//
// Returns:
//  S_OK: Success, will not call completion routine
//  MAILTRANSPORT_S_PENDING: Will call completion routine
//  or error from mailmsg/icatitem
//
// History:
// jstamerj 1998/09/29 14:09:56: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddDlMembers(
    DLOBJTYPE dlt,
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    DWORD dwNumMembers = 0;
    PDLCOMPLETIONCONTEXT pDLContext = NULL;

    TraceFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddDlMembers");
    //
    // Since we're a DL, don't deliver to the DL object
    //
    hr = SetDontDeliver(TRUE);
    if(FAILED(hr))
        goto CLEANUP;

    switch(dlt) {

     case DLT_X500:
     case DLT_SMTP:
     {
         LPSTR pszMemberAttribute;
         ICategorizerParameters *pICatParams;

         pICatParams = GetICatParams();
         _ASSERT(pICatParams);

         hr = pICatParams->GetDSParameterA(
             DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
             &pszMemberAttribute);

         if(SUCCEEDED(hr)) {

             hr = HrExpandAttribute(
                 NULL,
                 (dlt == DLT_X500) ? CAT_DN : CAT_SMTP,
                 pszMemberAttribute,
                 &dwNumMembers);

             if(SUCCEEDED(hr) && (dwNumMembers == 0)) {
                 //
                 // This might be a paged DL
                 //  Since paged DLs require additional special LDAP
                 //  lookups, use a store function to expand it -- it will
                 //  return S_PENDING and call AddDLMember once per member
                 //
                 pDLContext = AllocDlCompletionContext(this, pfnCompletion, pContext);
                 if(pDLContext == NULL) {

                     hr = E_OUTOFMEMORY;

                 } else {

                     hr = GetCCategorizer()->GetEmailIDStore()->HrExpandPagedDlMembers(
                         this,
                         GetResolveListContext(),
                         (dlt == DLT_X500) ? CAT_DN : CAT_SMTP,
                         DlExpansionCompletion,
                         pDLContext);
                 }
             }
         }
         break;
     }

     case DLT_DYNAMIC:
         //
         // Since dynamic DLs require additional special LDAP lookups,
         // use a store function to expand them.  It will return
         // S_PENDING and call AddDynamicDLMember once per member
         //
         pDLContext = AllocDlCompletionContext(this, pfnCompletion, pContext);
         if(pDLContext == NULL) {

             hr = E_OUTOFMEMORY;

         } else {
             hr = GetCCategorizer()->GetEmailIDStore()->HrExpandDynamicDlMembers(
                 this,
                 GetResolveListContext(),
                 DlExpansionCompletion,
                 pDLContext);
         }
    }

 CLEANUP:
    if((hr != MAILTRANSPORT_S_PENDING) && (pDLContext != NULL))
        delete pDLContext;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::DlExpansionCompletion
//
// Synopsis: Handle completion of the expansion of a paged/dynamic DL
//
// Arguments:
//  hrStatus: Status of the expansion
//  pContext: Our context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/01/29 21:17:46: Created.
//
//-------------------------------------------------------------
VOID CCatExpandableRecip::DlExpansionCompletion(
    HRESULT hrStatus,
    PVOID pContext)
{
    PDLCOMPLETIONCONTEXT pDLContext;

    TraceFunctEnterEx((LPARAM)pContext, "CCatExpandableRecip::DlExpansionCompletion");

    pDLContext = (PDLCOMPLETIONCONTEXT)pContext;
    _ASSERT(pDLContext);

    DebugTrace((LPARAM)pContext, "hrStatus %08lx", hrStatus);

    if(FAILED(hrStatus)) {

        ErrorTrace((LPARAM)pContext, "DlExpansion failed hr %08lx", hrStatus);

        _VERIFY(SUCCEEDED(pDLContext->pCCatAddr->SetListResolveStatus(hrStatus)));
    }
    //
    // Notify that the expanditem event is complete
    //
    pDLContext->pfnCompletion(pDLContext->pContext);

    delete pDLContext;

    TraceFunctLeaveEx((LPARAM)pContext);
}



//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrExpandAttribute
//
// Synopsis: Call AddDlMember(CAType, *) for every attribute value
//
// Arguments:
//  pICatItemAttr: Optional ICategorizerItemAttribute to use (if NULL,
//                 will attempt retrieval from ICatItem)
//  CAType: The address type of the DL.
//  pszAttributeName: Attribute name to use
//  pdwNumberMembers: optional pointer to a DWORD to increment once
//                    per member added (not initialized here)
//
// Returns:
//  S_OK: Success
//  or error from ICatItemAttr
//
// History:
// jstamerj 1998/09/23 17:54:57: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrExpandAttribute(
    ICategorizerItemAttributes *pICatItemAttrIN,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAttributeName,
    PDWORD pdwNumberMembers)
{
    HRESULT hr;
    CMembersInsertionRequest *pCInsertionRequest = NULL;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerUTF8Attributes *pIUTF8 = NULL;
    ATTRIBUTE_ENUMERATOR enumerator;
    DWORD dwcMembers;
    BOOL fEndEnumeration = FALSE;

    TraceFunctEnterEx((LPARAM)this,
                      "CCatExpandableRecip::HrExpandAttribute");

    _ASSERT(pszAttributeName);

    if(pICatItemAttrIN) {
        //
        // Use specified attributes interface
        //
        pICatItemAttr = pICatItemAttrIN;
        pICatItemAttr->AddRef();

    } else {
        //
        // Use default attribute interface
        //
        hr = GetICategorizerItemAttributes(
            ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
            &pICatItemAttr);

        if(FAILED(hr)) {
            pICatItemAttr = NULL;
            goto CLEANUP;
        }
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (LPVOID *) &pIUTF8);
    if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Attribute name: %s", pszAttributeName);

    hr = pIUTF8->BeginUTF8AttributeEnumeration(
        pszAttributeName,
        &enumerator);

    if(FAILED(hr))
        goto CLEANUP;

    fEndEnumeration = TRUE;
    //
    // Get the count of values (members)
    //
    hr = pIUTF8->CountUTF8AttributeValues(
        &enumerator,
        &dwcMembers);

    if(FAILED(hr))
        goto CLEANUP;

    if(pdwNumberMembers)
        (*pdwNumberMembers) += dwcMembers;

    if(dwcMembers > 0) {

        pCInsertionRequest = new CMembersInsertionRequest(
            this,
            pIUTF8,
            &enumerator,
            CAType);
        if(pCInsertionRequest == NULL) {
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }
        //
        // The destructor of CMembersInseritonRequest will now end the
        // attribute enumeration
        //
        fEndEnumeration = FALSE;

        hr = HrInsertInsertionRequest(
            pCInsertionRequest);
        if(FAILED(hr))
            goto CLEANUP;
    }

 CLEANUP:
    //
    // Don't return prop not found errors
    //
    if((hr == CAT_E_PROPNOTFOUND) ||
       (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))

       hr = S_OK;

    if(fEndEnumeration)
        pICatItemAttr->EndAttributeEnumeration(&enumerator);
    if(pIUTF8)
        pIUTF8->Release();
    if(pICatItemAttr)
        pICatItemAttr->Release();
    if(pCInsertionRequest)
        pCInsertionRequest->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::CCatDLRecip
//
// Synopsis: Construct the DL recipient
//
// Arguments:
//  pIListResolve: the list resolve object to handle expanding this DL
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 16:15:20: Created.
//
//-------------------------------------------------------------
CCatDLRecip::CCatDLRecip(
    CICategorizerDLListResolveIMP *pIListResolve) :
    CCatRecip(pIListResolve)
{
    _ASSERT(pIListResolve);
    m_pIListResolve = pIListResolve;
    m_pIListResolve->AddRef();
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::~CCatDLRecip
//
// Synopsis: release references held by this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 16:19:47: Created.
//
//-------------------------------------------------------------
CCatDLRecip::~CCatDLRecip()
{
    if(m_pIListResolve)
        m_pIListResolve->Release();
}




//+------------------------------------------------------------
//
// Function: CCatDLRecip::LookupCompletion
//
// Synopsis: Handle the DS lookup completion of a recipient we're only expanding for
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 15:51:13: Created.
// jstamerj 1999/03/18 10:14:35: Removed return value; removed async
//                               completion to asyncctx
//
//-------------------------------------------------------------
VOID CCatDLRecip::LookupCompletion()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatDLRecip::HrLookupCompletion");

    hr = GetItemStatus();

    if(FAILED(hr)) {

        switch(hr) {
         case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // This object was not in the DS.  We do nothing
            //
            hr = S_OK;
            break;

         case CAT_E_MULTIPLE_MATCHES:
         case CAT_E_ILLEGAL_ADDRESS:
             //
             // These are caused by DS misconfiguration.  Instead of
             // failing the entire expand, we'll just ignore the
             // recipients that have these problems.
             //
             hr = S_OK;
             break;
         default:
             //
             // We have no choice but to fail the list resolve for any
             // other error
             //
             ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", hr);
             break;
        }

    } else {
        //
        // Original recipient status was SUCCESS
        //
        // Call HrAddNewAddressesFromICatItemAttr -- it will dig out all
        // the addresses from ICatItemAttr and call
        // CCatDLRecip::HrAddAddresses -- here we will notify the
        // DLListResolve of the new addresses
        //
        hr = HrAddNewAddressesFromICatItemAttr();

        if(SUCCEEDED(hr) || (hr == CAT_E_NO_SMTP_ADDRESS)) {
            //
            // Should we keep resolving?
            //
            hr = m_pIListResolve->HrContinueResolve();
            if(hr == S_OK) {
                //
                // Assume async operation
                //
                IncPendingLookups();

                //
                // Go ahead and expand this if it's a DL
                //
                hr = HrAddDlMembersAndForwardingAddresses(
                    ExpansionCompletion,
                    this);

                if(hr != MAILTRANSPORT_S_PENDING)
                    DecrPendingLookups();
                //
                // MUST preserve return code: MAILTRANSPORT_S_PENDING
                //
            } else if(hr == S_FALSE) {
                hr = S_OK;
            }
        }


        if((hr == CAT_IMSG_E_DUPLICATE) || (hr == CAT_E_FORWARD_LOOP)) {

            DebugTrace((LPARAM)this, "Duplicate collision on AddAddresses hr %08lx", hr);
            //
            // We're just trying to expand DL -- we don't care about
            // loops and such.  However, let's not leave a partially
            // resolved recipient in the recip list
            //
            hr = SetDontDeliver(TRUE);
        }
    }
    //
    // Fail the DL expansion if any of the above fails
    //
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Setting list resolve error %08lx", hr);
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
    }
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::HrAddAddresses
//
// Synopsis: Catch the default AddAddresses and notify m_pIListResolve
//
// Arguments:
//  dwNumAddresses: the number of addresses found
//  rgCAType: array of address types
//  rgpsz: array of address strings
//
// Returns:
//  S_OK: Success
//  return value from CIMsgRecipListAddr::HrAddAddresses
//
// History:
// jstamerj 1998/12/05 16:42:12: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::HrAddAddresses(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatDLRecip::HrAddAddresses");

    hr = m_pIListResolve->HrNotifyAddress(
        dwNumAddresses,
        rgCAType,
        rgpsz);

    if(SUCCEEDED(hr)) {
        //
        // Add addresses to mailmsg
        //
        hr = CIMsgRecipListAddr::HrAddAddresses(
            dwNumAddresses,
            rgCAType,
            rgpsz);
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::AddForward
//
// Synopsis: Catch the AddForward call.  Since we do not care about
//           forwarding addresses, do nothing
//
// Arguments:
//  CAType: addresses type of the forwarding address
//  pszForwardingAddress: the address string
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/05 16:52:58: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::AddForward(
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszForwardingAddress)
{
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::AddDLMember
//
// Synopsis: Kick off a resolve after we discover this object is a DL
//
// Arguments:
//  CAType: address type we have for this DL member
//  pszAddress: address we have for this DL member
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/05 16:54:47: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::AddDLMember(
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatDLRecip:AddDlMember");
    //
    // Notify the DLListResolve about the new address
    //
    hr = m_pIListResolve->HrNotifyAddress(
        1,
        &CAType,
        &pszAddress);

    //
    // Do we keep resolving?
    //
    if(hr == S_OK) {
        //
        // kick off async resolve
        //
        hr = CCatRecip::AddDLMember(
            CAType,
            pszAddress);

    } else if(SUCCEEDED(hr)) {
        //
        // Remove S_FALSE
        //
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::ExpansionCompletion
//
// Synopsis: Handle async DL expansion completion
//
// Arguments:
//  pContext: a CCatDLRecip in disguise
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 13:26:20: Created.
//
//-------------------------------------------------------------
VOID CCatDLRecip::ExpansionCompletion(
    PVOID pContext)
{
    CCatDLRecip *pRecip;

    TraceFunctEnterEx((LPARAM)pContext, "CCatDLRecip::ExpansionCompletion");

    pRecip = (CCatDLRecip *)pContext;
    pRecip->DecrPendingLookups();

    TraceFunctLeaveEx((LPARAM)pContext);
} // CCatDLRecip::ExpansionCompletion


//+------------------------------------------------------------
//
// Function: CMembersInsertionRequest::HrInsertSearches
//
// Synopsis: Insert LDAP searches for the next few DL members
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//  pdwcSearches: Out param for the number of searches we inserted
//
// Returns:
//  S_OK: Success
//  error: Stop calling HrInsertSearches
//
// History:
// jstamerj 1999/03/25 13:56:46: Created.
//
//-------------------------------------------------------------
HRESULT CMembersInsertionRequest::HrInsertSearches(
    DWORD dwcSearches,
    DWORD *pdwcSearches)
{
    HRESULT hr = S_OK;
    LPSTR pszMember = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMembersInsertionRequest::HrInsertSearches");

    *pdwcSearches = 0;
    while(SUCCEEDED(hr) && (*pdwcSearches < dwcSearches)) {

        hr = m_pUTF8Attributes->GetNextUTF8AttributeValue(
            &m_enumerator,
            &pszMember);

        if(SUCCEEDED(hr)) {
            hr = m_pDLRecipAddr->AddDLMember(m_CAType, pszMember);
            if(hr == S_OK)
                (*pdwcSearches)++;
            else if(FAILED(hr))
                _VERIFY(SUCCEEDED(m_pDLRecipAddr->SetListResolveStatus(hr)));
        }
    }

    if(FAILED(hr))
        m_hr = hr;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CMembersInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CMemberInsertionRequest::NotifyDeQueue
//
// Synopsis: Callback to notify us that our request is being removed
//           from the store's queue
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 14:11:12: Created.
//
//-------------------------------------------------------------
VOID CMembersInsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CMemberInsertionRequest::NotifyDeQueue");
    //
    // If we still have things left to resolve, reinsert this
    // insertion request
    //
    hr = hrReason;
    if(SUCCEEDED(m_hr)) {
        if( (hr == CAT_E_DBCONNECTION) || (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))) {

            hr = m_pDLRecipAddr->HrInsertInsertionRequest(
                this);
        }

        if(FAILED(hr))
            _VERIFY(SUCCEEDED(m_pDLRecipAddr->SetListResolveStatus(hr)));
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CMemberInsertionRequest::NotifyDeQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatitem.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.cpp
//
// Contents: Implementation of ICategorizerItemIMP
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:42:59: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitem.h"


//+------------------------------------------------------------
//
// Function:  CICategorizerItemIMP::CICategorizerItemIMP
//
// Synopsis: Set initial values of member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 18:26:07: Created.
//
//-------------------------------------------------------------
CICategorizerItemIMP::CICategorizerItemIMP() :

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

    CICategorizerPropertiesIMP((ICategorizerItem *)this)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

{
    m_dwSignature = CICATEGORIZERITEMIMP_SIGNATURE;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemIMP::~CICategorizerItemIMP
//
// Synopsis: Release all of our data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 20:15:14: Created.
//
//-------------------------------------------------------------
CICategorizerItemIMP::~CICategorizerItemIMP()
{
    _ASSERT(m_dwSignature == CICATEGORIZERITEMIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERITEMIMP_SIGNATURE_FREE;
}


//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerListResolve
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerItem) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerProperties) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatlistresolve.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatlistresolve.cpp
//
// Contents: Implementation of CICategorizerListResolveIMP
//
// Classes: CICategorizerListResolveIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 17:41:17: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerListResolve
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerListResolve) {
        *ppv = (LPVOID) ((ICategorizerListResolve *) this);
    } else if (iid == IID_ICategorizerProperties) {
        *ppv = (LPVOID) ((ICategorizerProperties *) this);
    } else if (iid == IID_ICategorizerMailMsgs) {
        *ppv = (LPVOID) ((ICategorizerMailMsgs *) &m_CICategorizerMailMsgs);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::AllocICategorizerItem
//
// Synopsis: Creates a CCatAddr object and an ICategorizerItem
//           property bag
//
// Arguments:
//  eSourceType: Specifies source type of Sender, Recipient, or Verify
//  ppICatItem:  ICategorizerItem created
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/25 17:59:38: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::AllocICategorizerItem(
    eSourceType SourceType,
    ICategorizerItem **ppICatItem)
{
    _ASSERT(ppICatItem);

    CCatAddr *pCCatAddr;
    switch(SourceType) {
     case SOURCE_RECIPIENT:
         pCCatAddr = new (GetNumCatItemProps()) CCatRecip(this);
         break;

     case SOURCE_SENDER:
         pCCatAddr = new (GetNumCatItemProps()) CCatSender(this);
         break;

     default:
         return E_INVALIDARG;
    }

    if(pCCatAddr == NULL) {
        return E_OUTOFMEMORY;
    }
    //
    // The constructor for CCatRecip/Sender starts with a refcount of 1
    //

    //
    // Set the CCatAddr property so that we can get back the
    // CCatAddr from an ICategorizerItem later.
    //
    _VERIFY(SUCCEEDED(pCCatAddr->PutPVoid(
        m_pCCat->GetICatItemCCatAddrPropId(),
        (PVOID)pCCatAddr)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutDWORD(
        ICATEGORIZERITEM_SOURCETYPE,
        SourceType)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerListResolve(
        ICATEGORIZERITEM_ICATEGORIZERLISTRESOLVE,
        this)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerMailMsgs(
        ICATEGORIZERITEM_ICATEGORIZERMAILMSGS,
        &m_CICategorizerMailMsgs)));

    *ppICatItem = pCCatAddr;
    
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::ResolveICategorizerItem
//
// Synopsis: Accepts an ICategorizerItem for resolving
//
// Arguments:
//  pICatItem: Item to resolve
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 18:53:22: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::ResolveICategorizerItem(
    ICategorizerItem *pICatItem)
{
    HRESULT hr;
    CCatAddr *pCCatAddr;

    if(pICatItem == NULL)
        return E_INVALIDARG;

    hr = GetCCatAddrFromICategorizerItem(
        pICatItem,
        &pCCatAddr);

    if(FAILED(hr))
        return hr;

    //
    // Insert the CCatAddr into the pending resolve list
    //
    m_CSinkInsertionRequest.InsertItem(pCCatAddr);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::SetListResolveStatus
//
// Synopsis: Sets the list resolve status -- the status of
//           categorization.  If hrStatus is S_OK, the resolve status
//           will be reset (to S_OK).  Otherwise if hrStatus is less
//           severe than the current status, it will be ignored.
//
// Arguments:
//  hrStatus: status to set
//
// Returns:
//  S_OK: Success, new status set
//  S_FALSE: Success, but we already have a more or equally severe status
//
// History:
// jstamerj 1998/06/25 19:06:59: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::SetListResolveStatus(
    HRESULT hrStatus)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::SetListResolveStatus");
    //
    // CAT_W_SOME_UNDELIVERABLE_MSGS should no longer be the list
    // resolve error
    //
    _ASSERT(hrStatus != CAT_W_SOME_UNDELIVERABLE_MSGS);

    //
    // Is hrStatus more severe than m_hrListResolveStatus ?
    //
    if( (hrStatus == S_OK) ||
        ((unsigned long)(hrStatus & 0xC0000000) >
         (unsigned long)(m_hrListResolveStatus & 0xC0000000))) {
        m_hrListResolveStatus = hrStatus;

        DebugTrace((LPARAM)this, "Setting new list resolve error %08lx",
                   m_hrListResolveStatus);

        return S_OK;
    }
    return S_FALSE;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::GetListResolveStatus
//
// Synopsis: Retrieve the current list resolve status
//
// Arguments:
//  phrStatus: ptr to hresult to set to the current status
//
// Returns:
//  S_OK: Success, new status set
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/17 22:22:24: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::GetListResolveStatus(
    HRESULT *phrStatus)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::GetListResolveStatus");

    if(phrStatus == NULL) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    *phrStatus = m_hrListResolveStatus;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::Initialize
//
// Synopsis: Initializes member data
//
// Arguments:
//  pIMsg: Origianl IMsg for this resolution
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 19:28:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::Initialize(
    IUnknown *pIMsg)
{
    HRESULT hr;
    hr = m_CICategorizerMailMsgs.Initialize(pIMsg);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::CompleteMessageCategorization
//
// Synopsis: Master completion routine of an IMsg Categorization
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success (any errors passed to completion function)
//
// History:
// jstamerj 1998/06/26 10:46:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::CompleteMessageCategorization()
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolve::CompelteMessageCategorization");
    HRESULT hr = m_hrListResolveStatus;
    HRESULT hrEvent;

    IUnknown **rgpIMsg = NULL;
    DWORD cIMsgs = 1;
    ISMTPServer *pIServer;

    pIServer = GetISMTPServer();

    //
    // Remove ourselves from the pending listresolve list
    //
    m_pCCat->RemovePendingListResolve(this);

    DebugTrace(0, "CompleteMessageCategorization called with hrListResolveError %08lx", m_hrListResolveStatus);

    //
    // Now that we have our context, we are done with the store's
    // context
    //
    m_pCCat->GetEmailIDStore()->FreeResolveListContext(&m_rlc); //WOW!

    cIMsgs = m_CICategorizerMailMsgs.GetNumIMsgs();

    // Prepare for completion call
    if(SUCCEEDED(hr) && (cIMsgs > 1)) {
        //
        // Allocate array space if there is more than one message
        //
        rgpIMsg = new IUnknown *[cIMsgs+1];
        if(rgpIMsg == NULL) {
            ErrorTrace(0, "Out of memory allocating array of pointers to IMsgs for bifurcation callback");
            hr = E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr)) {
        //
        // WriteList/Commit our resolved addresses
        //
        hr = m_CICategorizerMailMsgs.HrPrepareForCompletion();
        DebugTrace(0, "m_CICategorizerMailMsgs.PrepareForCompletion returned %08lx", hr);
    }
    //
    // Set list resolve status if something failed above
    //
    if(FAILED(hr)) {
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }

    if(pIServer) {
        //
        // Now that we've determined the status for this categorization,
        // trigger OnCategorizeEnd
        //
        EVENTPARAMS_CATEND EventParams;
        EventParams.pICatMailMsgs = &m_CICategorizerMailMsgs;
        EventParams.hrStatus = m_hrListResolveStatus;
        hrEvent = GetISMTPServer()->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT,
            &EventParams);
        if(FAILED(hrEvent)) {
            ErrorTrace((LPARAM)this, "TriggerServerEvent failed with hr %08lx", hr);
            _VERIFY(SUCCEEDED(SetListResolveStatus(hrEvent)));
        }
    }

    if(FAILED(m_hrListResolveStatus)) {
        ErrorTrace(0, "Categorization for this IMsg failed with hr %08lx", 
                   m_hrListResolveStatus);
        // If we failed, revert all changes
        _VERIFY(SUCCEEDED(m_CICategorizerMailMsgs.RevertAll()));

        // Call completion routine with original IMsg and error
        CallCompletion( 
            m_hrListResolveStatus,
            m_pCompletionContext,
            m_CICategorizerMailMsgs.GetDefaultIUnknown(),
            NULL);
    } else {
        // Noraml case we will succeed!
        if(rgpIMsg) {
            _VERIFY( SUCCEEDED(
                m_CICategorizerMailMsgs.GetAllIUnknowns(rgpIMsg, cIMsgs+1)));

            // Use the original list resolve hr (might be cat_w_something)
            CallCompletion( 
                m_hrListResolveStatus,
                m_pCompletionContext,
                NULL,
                rgpIMsg);

        } else {
            CallCompletion( 
                m_hrListResolveStatus,
                m_pCompletionContext,
                m_CICategorizerMailMsgs.GetDefaultIUnknown(),
                NULL);
        }
    }

    //
    // Common cleanup code
    // Release reference to ourself added in StartMessageCategorization
    //
    Release();

    if(rgpIMsg)
        delete rgpIMsg;
    
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICateogirzerListResolveIMP::StartMessageCategorization
//
// Synopsis: Kicks off first level categorization
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, async resolution in progress
//  S_FALSE: Nothing needed to be resolved
//  error: will not call your completion routine, could not kick off
//  async categorize
//
// History:
// jstamerj 1998/06/26 11:05:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::StartMessageCategorization()
{
    IMailMsgProperties    *pIMailMsgProperties = NULL;
    IMailMsgRecipients    *pIMailMsgRecipients = NULL;
    IMailMsgRecipientsAdd *pICatRecipList  = NULL;
    HRESULT hr;
    ISMTPServer *pIServer;
    BOOL fStoreListResolveContext = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::StartCategorization");

    pIServer = GetISMTPServer();
    //
    // Retrieve the interfaces we need -- these routines do NOT Addref
    // the interfaces for the caller
    //
    pIMailMsgProperties = m_CICategorizerMailMsgs.GetDefaultIMailMsgProperties();
    _ASSERT(pIMailMsgProperties);

    pIMailMsgRecipients = m_CICategorizerMailMsgs.GetDefaultIMailMsgRecipients();
    _ASSERT(pIMailMsgRecipients);

    pICatRecipList = m_CICategorizerMailMsgs.GetDefaultIMailMsgRecipientsAdd();
    _ASSERT(pICatRecipList);

    //
    // Start out with the message status set to S_OK
    //
    hr = SetMailMsgCatStatus(pIMailMsgProperties, S_OK);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "SetMailMsgCatStatus failed hr %08lx", hr);
        goto CLEANUP;
    }

    //
    // Increment pending lookups here so that we can't possibly
    // finish the list resolve until we are finished starting the list
    // resolve
    //
    IncPendingLookups();

    // Let the store initialize it's resolve context so that it knows
    // how many address to expect for the first search.
    hr = m_pCCat->GetEmailIDStore()->InitializeResolveListContext(
        (LPVOID)this,
        &m_rlc);

    if(FAILED(hr)) {
        ErrorTrace(0, "m_pStore->InitializeResolveListConitext failed with hr %08lx", hr);
        goto CLEANUP;
    }

    fStoreListResolveContext = TRUE;

    if(pIServer) {
        //
        // Trigger OnCategorizerBegin event
        //
        EVENTPARAMS_CATBEGIN EventParams;
        EventParams.pICatMailMsgs = &m_CICategorizerMailMsgs;
        hr = GetISMTPServer()->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT,
            &EventParams);
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "TriggerServerEvent failed hr %08lx",
                       hr);
            goto CLEANUP;
        }
    }
    //
    // TriggerServerEvent could return S_FALSE.  However, we are okay
    // to go for async resolution, so we will return S_OK
    //
    hr = S_OK;

    //
    // Since everything has suceeded thus far, we are go for async
    // resolution
    // AddRef here, release in completion
    //
    AddRef();

    //
    // Great, we're doing an async categorization.  Add the list
    // resolve to the list of pending list resolves
    //
    m_pCCat->AddPendingListResolve(
        this);

    //
    // Call CreateBeginItemResolves
    //
    _VERIFY(SUCCEEDED(BeginItemResolves(
        pIMailMsgProperties,
        pIMailMsgRecipients,
        pICatRecipList)));

    //
    // Decrement the pending count incremented above (which calls
    // completion if necessary)
    //
    DecrPendingLookups();

 CLEANUP:
    if(FAILED(hr)) {

        if(fStoreListResolveContext) {
            //
            // Need to release the store list resolve context that we
            // initialized
            // 
            m_pCCat->GetEmailIDStore()->FreeResolveListContext(&m_rlc);
        }
    }
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::BeginItemResolves
//
// Synopsis: kick off resolves
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 20:24:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::BeginItemResolves(
    IMailMsgProperties *pIMailMsgProperties,
    IMailMsgRecipients *pOrigRecipList,
    IMailMsgRecipientsAdd *pCatRecipList)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this,
                      "CICatListResolveIMP::BeginItemResolves");

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pOrigRecipList);
    _ASSERT(pCatRecipList);

    m_CTopLevelInsertionRequest.BeginItemResolves(
        pIMailMsgProperties,
        pOrigRecipList,
        pCatRecipList);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetMailMsgCatStatus
//
// Synopsis: Set the categorization status on the mailmsg
//
// Arguments:
//  pIMailMsgProps: IMailMsgProperties interface
//  hrStatus: The status to set
//
// Returns:
//  The return code from mailmsgprop's PutDWord
//
// History:
// jstamerj 1998/07/29 12:22:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::SetMailMsgCatStatus(
    IMailMsgProperties *pIMailMsgProps, 
    HRESULT hrStatus)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerListResolve::SetMailMsgCatStatus");
    DebugTrace((LPARAM)this, "Status is %08lx", hrStatus);

    _ASSERT(pIMailMsgProps);

    hr = pIMailMsgProps->PutDWORD(
        IMMPID_MP_HR_CAT_STATUS,
        hrStatus);
    
    DebugTrace((LPARAM)this, "PutDWORD returned hr %08lx", hr);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetMailMsgCatStatus
//
// Synopsis: Same as the other SetMailMsgCatStatus but QI for
//           IMailMsgProperties first
//
// Arguments:
//  pIMsg: an IUnknown interface
//  hrStatus: Status to set
//
// Returns:
//  S_OK: Success
//  or error from QI
//  or error from PutDWORD
//
// History:
// jstamerj 1998/07/29 12:27:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::SetMailMsgCatStatus(
    IUnknown *pIMsg,
    HRESULT hrStatus)
{
    HRESULT hr;
    IMailMsgProperties *pIMailMsgProperties;

    _ASSERT(pIMsg);

    hr = pIMsg->QueryInterface(
        IID_IMailMsgProperties,
        (PVOID *) &pIMailMsgProperties);

    if(SUCCEEDED(hr)) {

        hr = SetMailMsgCatStatus(
            pIMailMsgProperties,
            hrStatus);

        pIMailMsgProperties->Release();
    }

    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP
//
// Synopsis: Construct the list resolve object for only resolving DLs
//
// Arguments:
//  pCCat: the CCategorizer object for this virtual server
//  pfnCatCompeltion: the completion routine to call when finished
//  pContext: the context to pass pfnCatCompletion
//  pfMatch: ptr to bool to set to TRUE or FALSE on address match
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/07 11:16:50: Created.
//
//-------------------------------------------------------------
CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP(
    CCategorizer *pCCat,
    PFNCAT_COMPLETION pfnCatCompletion,
    PVOID pContext) :
    CICategorizerListResolveIMP(
        pCCat,
        pfnCatCompletion,
        pContext)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP");

    m_fExpandAll = FALSE;
    m_CAType = CAT_UNKNOWNTYPE;
    m_pszAddress = NULL;
    m_pfMatch = NULL;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::Initialize
//
// Synopsis: Initialize error prone things with this object
//
// Arguments:
//  fExpandAll: expand the entire DL?
//  pfMatch: ptr to Bool to set when a match is detected
//  CAType: (optinal) the address type to match
//  pszAddress: (optinal) the address to match
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/07 11:46:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::Initialize(
    IUnknown *pMsg,
    BOOL fExpandAll,
    PBOOL pfMatch,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    IMailMsgProperties *pIProps = NULL;

    TraceFunctEnterEx((LPARAM)this, "CICategoriezrDLListResolveIMP::Initialize");

    m_fExpandAll = fExpandAll;
    m_CAType = CAType;

    if(pfMatch) {
        *pfMatch = FALSE;
        m_pfMatch = pfMatch;
    }
        
    if(pszAddress) {
        
        m_pszAddress = TrStrdupA(pszAddress);
        if(m_pszAddress == NULL) {

            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }
    }

    hr = CICategorizerListResolveIMP::Initialize(
        pMsg);
        
 CLEANUP:
    if(pIProps)
        pIProps->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}




//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::~CICategorizerDLListResolveIMP
//
// Synopsis: destroy this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/07 11:44:05: Created.
//
//-------------------------------------------------------------
CICategorizerDLListResolveIMP::~CICategorizerDLListResolveIMP()
{
    if(m_pszAddress)
        TrFree(m_pszAddress);
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::AllocICategorizerItem
//
// Synopsis: override the
// CICategorizerListResolveIMP::AllocICategorizerItem -- alloc
// CCatDLRecip's instead of CCatRecips
//
// Arguments:
//  eSourceType: Specifies source type of Sender, Recipient, or Verify
//  ppICatItem:  ICategorizerItem created
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/07 13:27:56: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerDLListResolveIMP::AllocICategorizerItem(
    eSourceType SourceType,
    ICategorizerItem **ppICatItem)
{
    CCatAddr *pCCatAddr;

    _ASSERT(ppICatItem);

    if(SourceType != SOURCE_RECIPIENT)
        return CICategorizerListResolveIMP::AllocICategorizerItem(
            SourceType,
            ppICatItem);

    pCCatAddr = new (GetNumCatItemProps()) CCatDLRecip(this);
    if(pCCatAddr == NULL) {
        return E_OUTOFMEMORY;
    }
    //
    // The constructor for CCatRecip/Sender starts with a refcount of 1
    //

    //
    // Set the CCatAddr property so that we can get back the
    // CCatAddr from an ICategorizerItem later.
    //
    _VERIFY(SUCCEEDED(pCCatAddr->PutPVoid(
        GetCCategorizer()->GetICatItemCCatAddrPropId(),
        (PVOID)pCCatAddr)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutDWORD(
        ICATEGORIZERITEM_SOURCETYPE,
        SourceType)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerListResolve(
        ICATEGORIZERITEM_ICATEGORIZERLISTRESOLVE,
        this)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerMailMsgs(
        ICATEGORIZERITEM_ICATEGORIZERMAILMSGS,
        GetCICategorizerMailMsgs())));

    *ppICatItem = pCCatAddr;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::HrContinueResolve
//
// Synopsis: Answer the question "should the resolve continue?"
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continue the resolve
//  S_FALSE: Success, stop the resolve
//
// History:
// jstamerj 1998/12/07 13:46:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::HrContinueResolve()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerDLListResolveIMP::HrContinueResolve");

    //
    // If we're not supposed to expand everything AND we've already
    // found a match, stop resolving
    //
    if((m_fExpandAll == FALSE) &&
       (m_pfMatch) && (*m_pfMatch == TRUE))
        hr = S_FALSE;
    else
        hr = S_OK;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::HrNotifyAddress
//
// Synopsis: We're being notified about a resolved user's addresses.
//           Check against what we're looking for if we care.
//
// Arguments:
//  dwNumAddresses: size of the address array
//  rgCAType: type array
//  rgpszAddress: address string ptr array
//
// Returns:
//  S_OK: Success, continue resolving
//  S_FALSE: Thanks for the info.  You can stop resolving now.
//
// History:
// jstamerj 1998/12/07 13:50:04: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::HrNotifyAddress(
    DWORD               dwNumAddresses,
    CAT_ADDRESS_TYPE    *rgCAType,
    LPSTR               *rgpszAddress)
{
    HRESULT hr = S_OK;
    
    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerDLListResolveIMP::HrNotifyAddress");

    //
    // Do we care what matches?
    //
    if((m_pfMatch) && (m_pszAddress)) {
        //
        // Have we not yet found a match?
        //
        if(*m_pfMatch == FALSE) {
            //
            // Is this a match?
            //
            for(DWORD dwCount = 0, hr = S_OK; 
                (dwCount < dwNumAddresses) && (hr == S_OK);
                dwCount++) {

                if((rgCAType[dwCount] == m_CAType) &&
                   (lstrcmpi(m_pszAddress, rgpszAddress[dwCount]) == 0)) {
                    //
                    // Match
                    //
                    *m_pfMatch = TRUE;
                }
            }
        }
    }
    return HrContinueResolve();
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetSenderResolved
//
// Synopsis: Sets the sender resolved bit...when setting to TRUE, call
//           recip completions of all the recipients whose queries completed
//           from LDAP earlier
//
// Arguments:
//  fResolved: Wether to set the sender as resolved or not
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/17 15:37:26: Created.
//
//-------------------------------------------------------------
VOID CICategorizerListResolveIMP::SetSenderResolved(
    BOOL fResolved)
{
    BOOL fFirstSender = FALSE;
    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::SetSenderResolved");

    AcquireSpinLock(&m_spinlock);
    //
    // If we are change m_fSenderResolved from FALSE to TRUE, then
    // this is the first sender to be resolved.
    //
    fFirstSender =  ((!m_fSenderResolved) && fResolved);
    m_fSenderResolved = fResolved;
    ReleaseSpinLock(&m_spinlock);
    //
    // Traverse the delayed recip list after the first sender has
    // resolved.  Do not traverse it for later senders.
    // Due to sinks completing queries synchronously, it is possible
    // for pRecip->RecipLookupCompletion() to eventually call back
    // into SetSenderResolved.  For example, RecipLookupCompletion of
    // a DL with report to owner may bifurcate a message, alloc
    // CCatSender corresponding to that DL's owner, resolve the owner
    // synchronously, and call SetSendreResolved.
    // We will do nothing here unless we are processing the first
    // sender to resolve.
    //
    if(fFirstSender && (!IsListEmpty(&m_listhead_recipients))) {
        //
        // Resolve all recip objects that were waiting for the
        // sender resolve to finish
        //
        PLIST_ENTRY ple;
        for(ple = m_listhead_recipients.Flink;
            ple != &m_listhead_recipients;
            ple = m_listhead_recipients.Flink) {
            
            CCatRecip *pRecip;
            pRecip = CONTAINING_RECORD(ple, CCatRecip, m_le);

            pRecip->RecipLookupCompletion();
            RemoveEntryList(ple);
            pRecip->Release();
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CICategorizerListResolveIMP::SetSenderResolved


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::ResolveRecipientAfterSender
//
// Synopsis: Calls pRecip->RecipLookupCompletion after the sender
//           lookup completion is finished.  One of two things can
//           happen:
//           1) RecipLookupCompletion is called immediately if the
//           sender lookup is finished or if we're not looking up the
//           sender
//           2) This recip is added to a queue and called later when
//           after the sender lookup is finished
//
// Arguments:
//  pRecip: the recip object
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 09:58:56: Created.
//
//-------------------------------------------------------------
VOID CICategorizerListResolveIMP::ResolveRecipientAfterSender(
    CCatRecip *pRecip)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::ResolveRecipientAfterSender");

    AcquireSpinLock(&m_spinlock);
    if(IsSenderResolveFinished()) {
        ReleaseSpinLock(&m_spinlock);
        //
        // Sender has been resolved, call recip lookup completion
        //
        pRecip->RecipLookupCompletion();

    } else {
        //
        // Sender has not been resolved, queue up in a list until
        // the sender resolve is finished 
        //
        InsertTailList(&m_listhead_recipients, &(pRecip->m_le));
        pRecip->AddRef();
        ReleaseSpinLock(&m_spinlock);
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CICategorizerListResolveIMP::ResolveRecipientAfterSender


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::HrInsertSearches
//
// Synopsis: This is the callback routine from LdapConn requesting
//           that we insert search requests now.
//
// Arguments:
//  dwcSearches: Number of searches we are allowed to insert
//  pdwcSearches: Return paramter for the number of searches we
//                actually inserted
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 20:00:25: Created.
//
//-------------------------------------------------------------
HRESULT CSinkInsertionRequest::HrInsertSearches(
    DWORD dwcSearches,
    DWORD *pdwcSearches)
{
    HRESULT hr = S_OK;
    HRESULT hrFailure = S_OK;
    LIST_ENTRY listhead;
    PLIST_ENTRY ple;

    TraceFunctEnterEx((LPARAM)this,
                      "CSinkInsertionRequest::HrInsertSearches");
    _ASSERT(pdwcSearches);
    *pdwcSearches = 0;

    //
    // Grab the pending list
    //
    AcquireSpinLock(&m_spinlock);

    if(!IsListEmpty(&m_listhead)) {
        CopyMemory(&listhead, &m_listhead, sizeof(LIST_ENTRY));
        InitializeListHead(&m_listhead);
        //
        // Fix list pointers
        //
        listhead.Flink->Blink = &listhead;
        listhead.Blink->Flink = &listhead;
    } else {
        InitializeListHead(&listhead);
    }
    ReleaseSpinLock(&m_spinlock);

    //
    // Insert items on the list
    //
    for(ple = listhead.Flink;
        (ple != &listhead) && (*pdwcSearches < dwcSearches);
        ple = listhead.Flink) {
        
        CCatAddr *pCCatAddr;
        pCCatAddr = CONTAINING_RECORD(ple, CCatAddr, m_listentry);

        if(SUCCEEDED(hr)) {
            hr = pCCatAddr->HrResolveIfNecessary();
            if(hr == S_OK)
                (*pdwcSearches)++;
        }
        RemoveEntryList(&(pCCatAddr->m_listentry));
        pCCatAddr->Release();
        m_pCICatListResolve->DecrPendingLookups();
    }

    if(!IsListEmpty(&listhead)) {
        
        _ASSERT(SUCCEEDED(hr));
        _ASSERT(*pdwcSearches == dwcSearches);
        //
        // Link our remaining blocks to the head of the list
        //
        AcquireSpinLock(&m_spinlock);
        listhead.Flink->Blink = &m_listhead;
        listhead.Blink->Flink = m_listhead.Flink;
        m_listhead.Flink->Blink = listhead.Blink;
        m_listhead.Flink = listhead.Flink;
        ReleaseSpinLock(&m_spinlock);
        
        InsertInternalInsertionRequest();
    }

    if(FAILED(hr))
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSinkInsertionRequest::HrInsertSearches



//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that our insertion request is being removed
//           from the LDAPConn queue
//
// Arguments:
//  hr: THe reason why we are being dequeue'd
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 13:04:59: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::NotifyDeQueue(
    HRESULT hr)
{
    TraceFunctEnterEx((LPARAM)this, "CSinkInsertionRequest::NotifyDeQueue");

    //
    // Reinsert the block if necessary
    //
    InsertInternalInsertionRequest(TRUE);

    TraceFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::NotifyDeQueue


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::InsertInternalInsertionRequest
//
// Synopsis: Inserts this object's internal insertion request if necessary
//
// Arguments:
//  fReinsert: if TRUE, this is the notification that we are being
//             un-inserted and should reinsert if necessary 
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 15:21:06: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::InsertInternalInsertionRequest(
    BOOL fReinsert)
{
    HRESULT hr = S_OK;
    BOOL fNeedToInsert;

    TraceFunctEnterEx((LPARAM)this,
                      "CSinkInsertionRequest::InsertInternalInsertionRequest");
    
    //
    // Decide if we need to insert the request or not
    //
    AcquireSpinLock(&m_spinlock);

    if(fReinsert)
        m_fInserted = FALSE;

    if(IsListEmpty(&m_listhead) || 
       (m_fInserted == TRUE)) {
        
        fNeedToInsert = FALSE;

    } else {
        //
        // We have a non-empty list and our insertion context has not
        // been inserted.  We need to insert it.
        //
        fNeedToInsert = TRUE;
        m_fInserted = TRUE; // Do not allow another thread to insert
                            // at the same time
    }
    ReleaseSpinLock(&m_spinlock);

    if(fNeedToInsert) {

        hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
        if(FAILED(hr)) {
            LIST_ENTRY listhead;
            PLIST_ENTRY ple;
        
            _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
            AcquireSpinLock(&m_spinlock);
            
            if(!IsListEmpty(&m_listhead)) {
                CopyMemory(&listhead, &m_listhead, sizeof(LIST_ENTRY));
                listhead.Blink->Flink = &listhead;
                listhead.Flink->Blink = &listhead;
                InitializeListHead(&m_listhead);
            } else {
                InitializeListHead(&listhead);
            }
            m_fInserted = FALSE;
            ReleaseSpinLock(&m_spinlock);
                       
            //
            // Empty out the list
            //
            for(ple = listhead.Flink;
                ple != &listhead;
                ple = listhead.Flink) {
        
                CCatAddr *pCCatAddr;
                pCCatAddr = CONTAINING_RECORD(ple, CCatAddr, m_listentry);

                RemoveEntryList(&(pCCatAddr->m_listentry));
                pCCatAddr->Release();
                m_pCICatListResolve->DecrPendingLookups();
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::InsertInternalInsertionRequest


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::InsertItem
//
// Synopsis: Inserts one item into the pending queue of CCatAddrs to
//           be resolved
//
// Arguments:
//  pCCatAddr: the item to be inserted
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 10:46:59: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::InsertItem(
    CCatAddr *pCCatAddr)
{
    TraceFunctEnterEx((LPARAM)this, "CSinkInsertionRequest::InsertItem");

    //
    // Put this thing in our queue
    //
    _ASSERT(pCCatAddr);
    pCCatAddr->AddRef();
    m_pCICatListResolve->IncPendingLookups();
    AcquireSpinLock(&m_spinlock);
    InsertTailList(&m_listhead, &(pCCatAddr->m_listentry));
    ReleaseSpinLock(&m_spinlock);
    //
    // Insert the InsertionContext if necessary
    //
    InsertInternalInsertionRequest();

    TraceFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::InsertItem



//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::HrInsertSearches
//
// Synopsis: Insert the top level categorizer searches
//
// Arguments:
//  dwcSearches: Number of searches we are allowed to insert
//  pdwcSearches: Out param for the number of searches we actually inserted
//
// Returns:
//  S_OK: Success
//  error: Stop inserting
//
// History:
// jstamerj 1999/03/25 23:30:50: Created.
//
//-------------------------------------------------------------
HRESULT CTopLevelInsertionRequest::HrInsertSearches(
    DWORD dwcSearches,
    DWORD *pdwcSearches)
{
    HRESULT hr = S_OK;
    CCatAddr *pCCatAddr = NULL;
    ICategorizerItem *pICatItemNew = NULL;
    DWORD dwCatFlags;

    TraceFunctEnterEx((LPARAM)this, "CTopLevelInsertionRequest::HrInsertSearches");

    _ASSERT(pdwcSearches);
    *pdwcSearches = 0;

    if(FAILED(m_hr))
        goto CLEANUP;

    if(dwcSearches == 0)
        goto CLEANUP;

    //
    // Resolve the sender?
    //
    dwCatFlags = m_pCICatListResolve->GetCatFlags();

    if(!m_fSenderFinished) {
        //
        // Perf shortcut; skip creating an ICatItem if we know we don't
        // resolve senders
        //
        if(dwCatFlags & SMTPDSFLAG_RESOLVESENDER) {
        
            // Create sender address object
            hr = m_pCICatListResolve->AllocICategorizerItem(
                SOURCE_SENDER,
                &pICatItemNew);
            if(FAILED(hr))
                goto CLEANUP;
            //
            // Set required ICategorizerItem props
            //
            _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgProperties(
                ICATEGORIZERITEM_IMAILMSGPROPERTIES,
                m_pIMailMsgProperties)));

            hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
                pICatItemNew,
                &pCCatAddr);

            if(FAILED(hr))
                goto CLEANUP;
            
            hr = pCCatAddr->HrResolveIfNecessary();
            if(hr == S_OK) {
                (*pdwcSearches)++;
            } else if(FAILED(hr))
                goto CLEANUP;

            pICatItemNew->Release();
            pICatItemNew = NULL;
        }
        //
        // How many recips do we have?
        //
        hr = m_pOrigRecipList->Count(&m_dwcRecips);
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "RecipientCount failed with hr %08lx", hr);
            goto CLEANUP;
        }
        //
        // Increment the pre-cat recip count
        //
        INCREMENT_COUNTER_AMOUNT(PreCatRecipients, m_dwcRecips);
        m_fSenderFinished = TRUE;
    }
    //
    // m_dwNextRecip is initialized in the class constructor
    //
    for(; 
        (m_dwNextRecip < m_dwcRecips) && (*pdwcSearches < dwcSearches); 
        m_dwNextRecip++) {
        // Create the container for this recipient
        DWORD dwNewIndex;

        hr = m_pCatRecipList->AddPrimary(
            0,
            NULL,
            NULL,
            &dwNewIndex,
            m_pOrigRecipList,
            m_dwNextRecip);
        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "AddPrimary failed hr %08lx", hr);
            goto CLEANUP;
        }

        hr = m_pCICatListResolve->AllocICategorizerItem(
            SOURCE_RECIPIENT,
            &pICatItemNew);
        if(FAILED(hr))
            goto CLEANUP;

        //
        // Set required ICatItem props
        //
        _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            m_pIMailMsgProperties)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            m_pCatRecipList)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            dwNewIndex)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutBool(
            ICATEGORIZERITEM_FPRIMARY,
            TRUE)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            0)));

        hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
            pICatItemNew,
            &pCCatAddr);

        if(FAILED(hr))
            goto CLEANUP;
            
        hr = pCCatAddr->HrResolveIfNecessary();
        if(hr == S_OK) {
            (*pdwcSearches)++;
        } else if(FAILED(hr))
            goto CLEANUP;

        pICatItemNew->Release();
        pICatItemNew = NULL;
    }

 CLEANUP:
    if(pICatItemNew)
        pICatItemNew->Release();

    if(FAILED(hr)) {
        ErrorTrace(0, "Something failed during query dispatch phase with hr %08lx - canceling all dispatched lookups", hr);
        // On any errors in here, cancel all pending searches.
        // -- their completion routines will be called with errors
        // as well as our master completion routine (by the store).
        // It, not us, will notify caller that there was an error.

        // Set the list resolve error just in case no CCatAddr objets
        // were dispatched (which normally set the list resolve error)
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
        m_hr = hr;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CTopLevelInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that the insertion request is being dequeued
//
// Arguments:
//  hrReason: THe reason why we were dequeue'd
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 23:50:08: Created.
//
//-------------------------------------------------------------
VOID CTopLevelInsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    HRESULT hr = hrReason;
    BOOL fReinserted = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CTopLevelInsertionRequest::NotifyDeQueue");

    if( ((hr == CAT_E_DBCONNECTION) || (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))) &&
        (!fTopLevelInsertionFinished())) {
        //
        // We have more to issue, so reinsert this request
        //
        hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
        if(SUCCEEDED(hr))
            fReinserted = TRUE;
    }

    if(FAILED(hr))
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));

    if(!fReinserted)
        m_pCICatListResolve->DecrPendingLookups();

    TraceFunctLeaveEx((LPARAM)this);
} // CTopLevelInsertionRequest::NotifyDeQueue


//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::BeginItemResolves
//
// Synopsis: Inserts the insertion request for the top level item resolves
//
// Arguments: Interfaces to use for the top level recipients
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/26 01:07:20: Created.
//
//-------------------------------------------------------------
VOID CTopLevelInsertionRequest::BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList) 
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this,
                      "CTopLevelInsertionRequest::BeginItemResolves");

    m_pIMailMsgProperties = pIMailMsgProperties;
    m_pOrigRecipList = pOrigRecipList;
    m_pCatRecipList = pCatRecipList;
    m_pCICatListResolve->IncPendingLookups();

    hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
    if(FAILED(hr)) {
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
        m_pCICatListResolve->DecrPendingLookups();
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CTopLevelInsertionRequest::BeginItemResolves
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccatsender.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatsender.cpp
//
// Contents: Implamentation of:
//
// Classes:
//   CIMsgSenderAddr
//   CCatSender
//
// Functions:
//   CIMsgSenderAddr::CIMsgSenderAddr
//   CIMsgSenderAddr::HrGetOrigAddress
//   CIMsgSenderAddr::GetSpecificOrigAddress
//   CIMsgSenderAddr::HrAddAddresses
//
//   CCatSender::CCatSender
//   CCatSender::AddDLMember
//   CCatSender::AddForward
//   CCatSender::HrCompletion
//   
// History:
// jstamerj 980325 15:54:02: Created.
//
//-------------------------------------------------------------

//
// ccataddr.cpp -- This file contains the implementations of:
// CCatAddr
//      CLdapRecip
//      CLdapSender
//
// jstamerj 980305 15:37:21: Created
//
// Changes:
//

#include "precomp.h"
#include "address.hxx"

//
// class CIMsgSenderAddr
//


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::CIMsgSenderAddr
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore:  Pointer to CEmailIDStore to use for queries
//   pIRC:    Pointer to our per IMsg Resolve list context
//   prlc:    Pointer to store's resolve list context
//   hLocalDomainContext: Domain context to use
//   pBifMgr: Bifurcation object
//
// Returns: Nothing
//
// History:
// jstamerj 980325 11:48:13: Created.
//

//-------------------------------------------------------------
CIMsgSenderAddr::CIMsgSenderAddr(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CCatAddr(pCICatListResolve)
{
    TraceFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::CIMsgSenderAddr");
    _ASSERT(pCICatListResolve != NULL);
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::HrGetOrigAddress
//
// Synopsis: Fetches an original address from the IMsg object
//           Addresses are fetched with the following preference:
//           SMTP, X500, X400, Foreign addres type
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.  For now, must be
//        at least CAT_MAX_INTERNAL_FULL_EMAIL
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: on Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
//    dwcc needs to be at least CAT_MAX_INTERNAL_FULL_EMAIL
//  CAT_E_ILLEGAL_ADDRESS: Somehow, the original address retreived is
//    not legal for it's type
//  Or an error code from IMsg
//
// History:
// jstamerj 980325 11:50:49: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::HrGetOrigAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::HrGetOrigAddress");

    hr = CCatAddr::HrGetOrigAddress(
        psz,
        dwcc,
        pType);

    if(hr == CAT_IMSG_E_PROPNOTFOUND) {

        IMailMsgProperties *pIMsgProps;
        //
        // No sender address properties set.  Let's set a NULL sender SMTP address
        //
        // Make sure there is enough room...
        //
        if(sizeof(CAT_NULL_SENDER_ADDRESS_SMTP) > dwcc) {

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        } else {

            hr = GetIMailMsgProperties(&pIMsgProps);

            if(SUCCEEDED(hr)) {

                // Set up passed in parameters
                *pType = CAT_SMTP;
                lstrcpy(psz, CAT_NULL_SENDER_ADDRESS_SMTP);

                // Now set the info on the mailmsg
                DebugTrace((LPARAM)this, 
                           "No sender address found; Setting SMTP sender address to \"%s\"",
                           psz);

                hr = pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, psz);

                pIMsgProps->Release();
            }
        }
    }

    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error retrieving sender address %08lx",
                   hr);
        TraceFunctLeave();
        return hr;
    }

    TraceFunctLeave();

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::GetSpecificOrigAddress
//
// Synopsis: Attempt to retrieve a specific type of address
//
// Arguments:
//  CAType: Address type to retrieve
//  psz: Buffer to receive address string
//  dwcc: Size of that buffer
//
// Returns:
//  S_OK: Success
//  CAT_IMSG_E_PROPNOTFOUND: this recipient does not have that address
//  or other error from mailmsg
//
// History:
// jstamerj 1998/07/30 20:47:59: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::GetSpecificOrigAddress(
    CAT_ADDRESS_TYPE    CAType,
    LPTSTR              psz,
    DWORD               dwcc)
{
    HRESULT hr;
    IMailMsgProperties *pIMsgProps;

    TraceFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::GetSpecificOrigAddress");

    // Use default(original) IMsg
    hr = GetIMailMsgProperties(&pIMsgProps);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMailMsgProperties failed, hr %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    hr = pIMsgProps->GetStringA(
        PropIdFromCAType(CAType),
        dwcc,
        psz);

    pIMsgProps->Release();

    DebugTrace((LPARAM)this, "GetStringA returned hr %08lx", hr);

    if(psz[0] == '\0')
        hr = CAT_IMSG_E_PROPNOTFOUND;

    return hr;
}
    

//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::AddAddresses
//
// Synopsis: Add the addresses contained in the arrays
//           to the IMsg object we contain
//
// Arguments:
//  dwNumAddresses: Number of new addresses
//  rgCAType: Array of address types
//  rgpsz: Array of pointers to address strings
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//
// History:
// jstamerj 980325 12:14:45: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::HrAddAddresses(
    DWORD dwNumAddresses, 
    CAT_ADDRESS_TYPE *rgCAType, 
    LPTSTR *rgpsz)
{
    HRESULT hr;
    DWORD dwCount;
    IMailMsgProperties *pIMsgProps;

    TraceFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::AddAddresses");
    _ASSERT(dwNumAddresses > 0);

    // Get the IMailMsgProperties and reset the new sender address properties
    hr = GetIMailMsgProperties(&pIMsgProps);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "GetIMailMsgProperties failed with hr %08lx", hr);
        return hr;
    }

    //
    // Add the new addresses from the array
    //
    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {
        //
        // Get the Sender propID for this type
        //
        DWORD dwPropId = PropIdFromCAType(rgCAType[dwCount]);
        //
        // Set the property
        //
        hr = pIMsgProps->PutStringA(dwPropId, rgpsz[dwCount]);

        DebugTrace((LPARAM)this, "Adding address type %d", rgCAType[dwCount]);
        DebugTrace((LPARAM)this, "Adding address %s", rgpsz[dwCount]);

        if(FAILED(hr)) {
            pIMsgProps->Release();
            ErrorTrace((LPARAM)this, "Error putting address property %08lx", hr);
            TraceFunctLeave();
            return hr;
        }
    }
    pIMsgProps->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//
// class CCatSender
//


//+------------------------------------------------------------
//
// Function: CCatSender::CCatSender
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore: CEmailIDStore to use
//   pIRC:   per IMsg resolve context to use
//   prlc:   Resolve list context to use
//   hLocalDomainContext: local domain context to use
//   pBifMgr: BifMgr object from which to get IMsg interfaces
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 12:28:31: Created.
//
//-------------------------------------------------------------
CCatSender::CCatSender(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CIMsgSenderAddr(pCICatListResolve)
{
    TraceFunctEnterEx((LPARAM)this, "CCatSender::CCatSender");
    // Nothing to do.
    TraceFunctLeave();
}
    


//+------------------------------------------------------------
//
// Function: CCatSender::AddDLMember
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments:
//   CAType: Known address type of the DL Member
//   pszAddress: pointer to the address string
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 980325 12:37:02: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------
//
// Function: CCatSender::AddDynamicDLMember
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments: doesn't matter
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 1998/09/29 21:14:48: 
//
//-------------------------------------------------------------
HRESULT CCatSender::AddDynamicDLMember(
    ICategorizerItemAttributes *pICatItemAttr)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------
//
// Function: CCatSender::AddForward
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments:
//   CAType: Known address type of the forwarding address
//   szForwardingAddres: The forwarding address
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 980325 12:39:18: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress)
{
    return E_NOTIMPL;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrExpandItem
//
// Synopsis: ExpandItem processing
//
// Arguments:
//  HrStatus: Status of resolution
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 19:29:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrExpandItem_Default(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    //
    // We don't expand anything for the sender
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrCompelteItem
//
// Synopsis: CompleteItem processing; handle any error status here
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 19:29:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrCompleteItem_Default()
{
    HRESULT HrStatus;

    TraceFunctEnterEx((LPARAM)this, "CCatSender::HrCompleteItem_Default");

    INCREMENT_COUNTER(AddressLookupCompletions);

    HrStatus = GetItemStatus();

    if(FAILED(HrStatus)) {

        INCREMENT_COUNTER(UnresolvedSenders);

        if(HrStatus == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            // No problem.  If we don't find our sender in the DS,
            // just leave him alone.
            DebugTrace((LPARAM)this, "Sender not found in the DS, but who cares?");
            INCREMENT_COUNTER(AddressLookupsNotFound);

        } else if(HrStatus == CAT_E_MULTIPLE_MATCHES) {
            //
            // There are multiple user in the DS with our orig
            // address...
            //
            DebugTrace((LPARAM)this, "More than one sender found in the DS...");
            INCREMENT_COUNTER(AmbiguousSenders);
            
        } else {

            DebugTrace((LPARAM)this, "Fatal error from EmailIDStore, setting list resolve error %08lx", HrStatus);
            _VERIFY(SUCCEEDED(SetListResolveStatus(HrStatus)));
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrNeedsResolving
//
// Synopsis: Determines if this sender should be resolved or not
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, it needs resolving
//  S_FALSE: Success, it doesn't need to be resolved
//
// History:
// jstamerj 1998/10/27 15:45:22: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrNeedsResolveing()
{
    DWORD dwFlags;
    HRESULT hr;

    dwFlags = GetCatFlags();

    //
    // Do we resolve senders at all?
    //
    if(! (dwFlags & SMTPDSFLAG_RESOLVESENDER))
        return S_FALSE;

#define ISTRUE( x ) ( (x) != 0 ? TRUE : FALSE )
    //
    // Do we need to check if the address is local or not?
    //
    if( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) !=
        ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE)) {
        //
        // We're resolving either local or remote (not both)
        //
        BOOL fLocal;

        hr = HrIsOrigAddressLocal(&fLocal);

        if(FAILED(hr))
            return hr;
            
        if( (dwFlags & SMTPDSFLAG_RESOLVELOCAL) &&
            (fLocal))
            return S_OK;

        if( (dwFlags & SMTPDSFLAG_RESOLVEREMOTE) &&
            (!fLocal))
            return S_OK;
        //
        // else Don't resolve
        //
        return S_FALSE;
    }
    //
    // 2 possabilities -- local and remote bits are on OR local and
    // remote bits are off
    //
    _ASSERT( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) ==
             ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE));

    if(dwFlags & SMTPDSFLAG_RESOLVELOCAL) {
        //
        // Both bits are on; Resolve
        //
        _ASSERT(dwFlags & SMTPDSFLAG_RESOLVEREMOTE);

        return S_OK;

    } else {
        //
        // local and remote are disabled; don't resolve
        //
        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: CCatSender::LookupCompletion
//
// Synopsis: Handle lookup completion from the emailidstore
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/14 16:19:38: Created.
//
//-------------------------------------------------------------
VOID CCatSender::LookupCompletion()
{
    TraceFunctEnterEx((LPARAM)this, "CCatSender::LookupCompletion");

    if(GetItemStatus() == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        INCREMENT_COUNTER(AddressLookupsNotFound);

    //
    // DO the normal event stuff
    //
    CCatAddr::LookupCompletion();

    //
    // Tell list resolve that the sender has been resolved
    //
    SetSenderResolved(TRUE);
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrDispatchQuery
//
// Synopsis: Dispatch an LDAP query for the sender
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from CCatAddr::HrDispatchQuery
//
// History:
// jstamerj 1999/01/27 13:00:09: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrDispatchQuery()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CCatSender::HrDispatchQuery");

    hr = CCatAddr::HrDispatchQuery();

    if(SUCCEEDED(hr))
        SetResolvingSender(TRUE);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\comdll.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: comdll.cpp
//
// Contents: DLL entry points needed for COM
//
// Classes: 
//  CCatFactory
//  CSMTPCategorizer
//
// Functions:
//
// History:
// jstamerj 1998/12/12 15:17:12: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "registry.h"
#include "comdll.h"
#include <smtpguid.h>

//
// Globals
//
// g_cObjects: count of active objects
// g_cServerLocks: count of server locks
// g_hInstance: DLL module handle
//
LONG g_cObjects = 0;
LONG g_cServerLocks = 0;
HINSTANCE g_hInstance = NULL;
BOOL g_fInitialized = FALSE;



//+------------------------------------------------------------
//
// Function: CatDllMain
//
// Synopsis: Handle what cat needs to do in DLLMain
//
// Arguments:
//  hInstance
//  dwReason: Why are you calling me?
//  lpReserved
//
// Returns: TRUE
//
// History:
// jstamerj 1998/12/12 23:06:08: Created.
//
//-------------------------------------------------------------
BOOL WINAPI CatDllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */)
{
    switch(dwReason) {

     case DLL_PROCESS_ATTACH:
         //
         // Save hInstance
         //
         g_hInstance = hInstance;
         //
         // Initialize global debug lists
         //
         CatInitDebugObjectList();
         break;

     case DLL_PROCESS_DETACH:
         //
         // Verify all Cat objects are destroyed
         //
         CatVrfyEmptyDebugObjectList();
         break;
    }
    return TRUE;
}


//+------------------------------------------------------------
//
// Function: RegisterCatServer
//
// Synopsis: Register the categorizer com objects
//
// Arguments:
//  hInstance: the hInstance passed to DllMain or WinMain
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:07:20: Created.
//
//-------------------------------------------------------------
STDAPI RegisterCatServer()
{
    _ASSERT(g_hInstance != NULL);
    return RegisterServer(
        g_hInstance,
        CLSID_CATVER,
        SZ_CATVER_FRIENDLY_NAME,
        SZ_PROGID_CATVER,
        SZ_PROGID_CATVER_VERSION);
}



//+------------------------------------------------------------
//
// Function: UnregisterCatServer
//
// Synopsis: Unregister the categorizer com objects
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:08:09: Created.
//
//-------------------------------------------------------------
STDAPI UnregisterCatServer()
{
    return UnregisterServer(
        CLSID_CATVER,
        SZ_PROGID_CATVER,
        SZ_PROGID_CATVER_VERSION);
}


//+------------------------------------------------------------
//
// Function: DllCanUnloadCatNow
//
// Synopsis: Return to COM wether it's okay or not to unload our dll
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, can unload
//  S_FALSE: Success, do not unload
//
// History:
// jstamerj 1998/12/12 15:09:02: Created.
//
//-------------------------------------------------------------
STDAPI DllCanUnloadCatNow()
{
    if((g_cObjects == 0) && (g_cServerLocks == 0)) {

        return S_OK;

    } else {

        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: DllGetCatClassObject
//
// Synopsis: Return the class factory object (an interface to it)
//
// Arguments:
//  clsid: The CLSID of the object you want a class factory for
//  iid: the interface you want
//  ppv: out param to set to the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: don't support that interface
//  CLASS_E_CLASSNOTAVAILABLE: don't support that clsid
//
// History:
// jstamerj 1998/12/12 15:11:48: Created.
//
//-------------------------------------------------------------
STDAPI DllGetCatClassObject(
    const CLSID& clsid,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    BOOL fDllInit = FALSE;
    BOOL fCatInitGlobals = FALSE;
    CCatFactory *pFactory = NULL;

    if(clsid != CLSID_CATVER) {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto CLEANUP;
    }

    //
    // Call init once for every class factory object created
    // (CCatFactory will release this reference in its destructor)
    //
    hr = HrDllInitialize();
    if(FAILED(hr))
        goto CLEANUP;

    fDllInit = TRUE;

    hr = CatInitGlobals();
    if(FAILED(hr))
        goto CLEANUP;

    fCatInitGlobals = TRUE;

    pFactory = new CCatFactory;
    //
    // Refcount of pFactory starts at 1
    //
    if(pFactory == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // CCatFactory will call DllDeinitialize and CatDeinitGlobals in
    // its final release call
    //
    fDllInit = fCatInitGlobals = FALSE;

    //
    // Get the requested interface
    //
    hr = pFactory->QueryInterface(
        iid,
        ppv);

    //
    // Release our refcount
    //
    pFactory->Release();

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Deinit what was initialized
        //
        if(fCatInitGlobals)
            CatDeinitGlobals();

        if(fDllInit)
            DllDeinitialize();
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CCatFactory::QueryInterface
//
// Synopsis: return interface pointers that this object inplements
//
// Arguments:
//  iid: Interface you want
//  ppv: out pointer to where to place the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: we don't support that interface
//
// History:
// jstamerj 1998/12/12 22:19:38: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CCatFactory::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    if((iid == IID_IUnknown) ||
       (iid == IID_IClassFactory)) {

        *ppv = (IClassFactory *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatFactory::CreateInstance
//
// Synopsis: Create an object
//
// Arguments:
//  pUnknownOuter: aggreation pointer
//  iid: Interface ID you'd like
//  ppv: place to return the interface ptr
//
// Returns:
//  S_OK: Success
//  CLASS_E_NOAGGREATION: Sorry, no.
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/12 22:25:00: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CCatFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    REFIID iid,
    LPVOID *ppv)
{
    HRESULT hr;

    if(pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    //
    // Create the new object
    //
    CSMTPCategorizer *pCat = new CSMTPCategorizer(&hr);

    if(pCat == NULL)
        return E_OUTOFMEMORY;

    if(FAILED(hr)) {
        delete pCat;
        return hr;
    }

    hr = pCat->QueryInterface(iid, ppv);

    // Release IUnknown ptr...if QI failed, this will delete the object
    pCat->Release();

    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatFactory::LockServer
// 
// Synopsis: Lock the server (keep the DLL loaded)
//
// Arguments:
//  fLock: TRUE, lock the server.  FALSE, unlock.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:29:48: Created.
//
//-------------------------------------------------------------
HRESULT CCatFactory::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement(&g_cServerLocks);
    else
        InterlockedDecrement(&g_cServerLocks);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::QueryInterface
//
// Synopsis: Get any interface on the public categorizer interface
//
// Arguments:
//  iid: Interface ID
//  ppv: ptr to where to place the interface ptr
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support this interface
//
// History:
// jstamerj 1998/12/12 22:31:43: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CSMTPCategorizer::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    if((iid == IID_IUnknown) ||
        (iid == IID_ISMTPCategorizer)) {

        *ppv = (ISMTPCategorizer *)this;

    } else if(iid == IID_IMarshal) {

        _ASSERT(m_pMarshaler);
        return m_pMarshaler->QueryInterface(iid, ppv);

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::ChangeConfig
//
// Synopsis: Change the configuration of this categorizer
//
// Arguments:
//  pConfigInfo: the config info structure
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/12 22:35:21: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::ChangeConfig(
    IN  PCCATCONFIGINFO pConfigInfo)
{
    return m_ABCtx.ChangeConfig(
        pConfigInfo);
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatMsg
//
// Synopsis: Categorizer a message
//
// Arguments:
//  pMsg: the mailmsg to categorize
//  pICompletion: the completion interface
//  pUserContext: a user supplied context
//
// Returns:
//  S_OK: Success, will complete async
//  E_INVALIDARG
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/12/12 22:37:57: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatMsg(
    IN  IUnknown *pMsg,
    IN  ISMTPCategorizerCompletion *pICompletion,
    IN  LPVOID pUserContext)
{
    HRESULT hr = S_OK;
    PCATMSGCONTEXT pContext = NULL;

    if((pMsg == NULL) ||
       (pICompletion == NULL)) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pContext = new CATMSGCONTEXT;
    if(pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    ZeroMemory(pContext, sizeof(CATMSGCONTEXT));

    pContext->pCCat = m_ABCtx.AcquireCCategorizer();

    if(pContext->pCCat) {

        pContext->pCSMTPCat = this;
        pContext->pICompletion = pICompletion;
        pContext->pUserContext = pUserContext;

        pICompletion->AddRef();
        AddRef();

        hr = pContext->pCCat->AsyncResolveIMsg(
                pMsg,
                CatMsgCompletion,
                pContext);
        if(FAILED(hr))
            goto CLEANUP;

    } else {
        //
        // If pCCat is NULL, initialization did not happen
        //
        hr = CAT_E_INIT_FAILED;
        goto CLEANUP;
    }
    hr = S_OK;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup context when failing
        //
        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();
            if(pContext->pCSMTPCat)
                pContext->pCSMTPCat->Release();
            if(pContext->pICompletion)
                pContext->pICompletion->Release();
            delete pContext;
        }
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatMsgCompletion
//
// Synopsis: Called upon categorizer completion
//
// Arguments:
//  hr: Status of categorization
//  pContext: our context
//  pIMsg: the categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:50:26: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    _ASSERT(pContext);

    PCATMSGCONTEXT pMyContext = (PCATMSGCONTEXT)pContext;

    //
    // Release the virtual cat reference (ccategorizer)
    //
    pMyContext->pCCat->Release();
    pMyContext->pCSMTPCat->Release();

    _VERIFY(SUCCEEDED(pMyContext->pICompletion->CatCompletion(
        hr,
        pMyContext->pUserContext,
        pIMsg,
        rgpIMsg)));

    //
    // Release user's completion interface
    //
    pMyContext->pICompletion->Release();

    delete pMyContext;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatDLMsg
//
// Synopsis: Categorizer a message just to expand DLs
//
// Arguments:
//  pMsg: the mailmsg to categorize
//  pICompletion: the completion interface
//  pUserContext: a user supplied context
//  fMatchOnly: stop resolution when a match is found?
//  CAType: address type you're looking for
//  pszAddress: address string you're looking for
//
// Returns:
//  S_OK: Success, will complete async
//  E_INVALIDARG
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/12/12 22:55:40: Created
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatDLMsg(
    IN  IUnknown *pMsg,
    IN  ISMTPCategorizerDLCompletion *pICompletion,
    IN  LPVOID pUserContext,
    IN  BOOL fMatchOnly,
    IN  CAT_ADDRESS_TYPE CAType,
    IN  LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    PCATDLMSGCONTEXT pContext = NULL;

    if((pMsg == NULL) ||
       (pICompletion == NULL)) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pContext = new CATDLMSGCONTEXT;

    if(pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    ZeroMemory(pContext, sizeof(CATDLMSGCONTEXT));

    pContext->pCCat = m_ABCtx.AcquireCCategorizer();

    if(pContext->pCCat) {

        pContext->pCSMTPCat = this;
        pContext->pICompletion = pICompletion;
        pContext->pUserContext = pUserContext;
        pContext->fMatch = FALSE;
        pICompletion->AddRef();
        AddRef();

        hr = pContext->pCCat->AsyncResolveDLs(
            pMsg,
            CatDLMsgCompletion,
            pContext,
            fMatchOnly,
            &(pContext->fMatch),
            CAType,
            pszAddress);
        if(FAILED(hr))
            goto CLEANUP;

    } else {
        //
        // Init must have failed
        //
        hr = CAT_E_INIT_FAILED;
        goto CLEANUP;
    }
    hr = S_OK;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup context when failing
        //
        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();
            if(pContext->pCSMTPCat)
                pContext->pCSMTPCat->Release();
            if(pContext->pICompletion)
                pContext->pICompletion->Release();
            delete pContext;
        }
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatDLMsgCompletion
//
// Synopsis: Called upon categorizer completion
//
// Arguments:
//  hr: Status of categorization
//  pContext: our context
//  pIMsg: the categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:50:26: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatDLMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    _ASSERT(pContext);

    PCATDLMSGCONTEXT pMyContext = (PCATDLMSGCONTEXT)pContext;

    _ASSERT(rgpIMsg == NULL);

    //
    // Release the virtual cat reference (ccategorizer)
    //
    pMyContext->pCCat->Release();
    pMyContext->pCSMTPCat->Release();

    _VERIFY(SUCCEEDED(pMyContext->pICompletion->CatDLCompletion(
        hr,
        pMyContext->pUserContext,
        pIMsg,
        pMyContext->fMatch)));

    //
    // Release user's completion interface
    //
    pMyContext->pICompletion->Release();
    delete pMyContext;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatCancel
//
// Synopsis: Cancel pending resolves
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/13 00:07:47: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatCancel()
{
    CCategorizer *pCCat;

    pCCat = m_ABCtx.AcquireCCategorizer();

    if(pCCat) {

        pCCat->Cancel();
        pCCat->Release();
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CSMTPCategorizer
//
// Synopsis: constructor -- initialize Cat with a default config
//
// Arguments:
//  phr: pointer to hresult to set to status
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/13 00:10:15: Created.
//
//-------------------------------------------------------------
CSMTPCategorizer::CSMTPCategorizer(
    HRESULT *phr)
{
    #define STATUS_DLLINIT     0x1
    #define STATUS_GLOBINIT    0x2
    DWORD dwStatus = 0;
    CCATCONFIGINFO ConfigInfo;
    CHAR szBindType[] = "CurrentUser";

    InterlockedIncrement(&g_cObjects);

    _ASSERT(phr);

    m_pMarshaler = NULL;

    //
    // Call HrDllInitialize once for every CSMTPCategorizer object created
    //
    *phr = HrDllInitialize();
    if(FAILED(*phr))
        goto CLEANUP;

    dwStatus |= STATUS_DLLINIT;
    //
    // Call CatInitGlobals once for every CSMTPCategorizer object created
    //
    *phr = CatInitGlobals();
    if(FAILED(*phr))
        goto CLEANUP;

    dwStatus |= STATUS_GLOBINIT;

    *phr = CoCreateFreeThreadedMarshaler(
        (IUnknown *)this,
        &m_pMarshaler);
    if(FAILED(*phr))
        goto CLEANUP;

    //
    // Bind as currentUser until we are told differently
    //
    ConfigInfo.dwCCatConfigInfoFlags = CCAT_CONFIG_INFO_FLAGS |
                                       CCAT_CONFIG_INFO_ENABLE |
                                       CCAT_CONFIG_INFO_BINDTYPE;
        
                                       
    ConfigInfo.dwCatFlags = SMTPDSFLAG_ALLFLAGS;
    ConfigInfo.dwEnable = SMTPDSUSECAT_ENABLED;
    ConfigInfo.pszBindType = szBindType;

    *phr = m_ABCtx.ChangeConfig(&ConfigInfo);

 CLEANUP:
    if(FAILED(*phr)) {

        if(dwStatus & STATUS_GLOBINIT)
            CatDeinitGlobals();

        if(dwStatus & STATUS_DLLINIT)
            DllDeinitialize();
    }
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::~CSMTPCategorizer
//
// Synopsis: Release data/references held by this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/15 17:53:58: Created.
//
//-------------------------------------------------------------
CSMTPCategorizer::~CSMTPCategorizer()
{
    if(m_pMarshaler)
        m_pMarshaler->Release();
    InterlockedDecrement(&g_cObjects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <precomp.h>

#include "precomp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatmailmsgs.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatmailmsgs.cpp
//
// Contents: Implementation of CICategorizerMailMsgsIMP
//
// Classes: CICategorizerMailMsgsIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/30 13:35:09: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatmailmsgs.h"

//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP constructor
//
// Synopsis: Initialize member data
//
// Arguments:
//  pCICatListResolve: backpointer for QI/AddRef/Release
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/30 13:35:56: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::CICategorizerMailMsgsIMP(
    CICategorizerListResolveIMP *pCICatListResolveIMP)
{
    m_dwSignature = SIGNATURE_CICATEGORIZERMAILMSGSIMP;

    _ASSERT(pCICatListResolveIMP);

    InitializeListHead(&m_listhead);
    m_dwNumIMsgs = 0;
    m_pCICatListResolveIMP = pCICatListResolveIMP;
    m_pIUnknown = (IUnknown *)((ICategorizerListResolve *)pCICatListResolveIMP);
    InitializeCriticalSection(&m_cs);
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::~CICategorizerMailMsgsIMP
//
// Synopsis: Release/delete member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/30 14:47:13: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::~CICategorizerMailMsgsIMP()
{
    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERMAILMSGSIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERMAILMSGSIMP_INVALID;
    //
    // Everything should be cleaned up in FinalRelease()
    //
    _ASSERT(IsListEmpty(&m_listhead));

    DeleteCriticalSection(&m_cs);
}

//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::FinalRelease
//
// Synopsis: Release all mailmsg references from this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/14 14:09:08: Created.
//
//-------------------------------------------------------------
VOID CICategorizerMailMsgsIMP::FinalRelease()
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::FinalRelease");

    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = m_listhead.Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(pIE->pIUnknown)
            pIE->pIUnknown->Release();
        if(pIE->pIMailMsgProperties)
            pIE->pIMailMsgProperties->Release();
        if(pIE->pIMailMsgRecipients)
            pIE->pIMailMsgRecipients->Release();
        if(pIE->pIMailMsgRecipientsAdd)
            pIE->pIMailMsgRecipientsAdd->Release();
        RemoveEntryList(ple);
        delete pIE;
    }
    TraceFunctLeaveEx((LPARAM)this);
} // CICategorizerMailMsgsIMP::FinalRelease


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::CreateIMSGEntry
//
// Synopsis: Allocates an IMSGENTRY and initializes interface data members
//
// Arguments:
//  ARG_pIUnknown: Optional Original IMsg IUnknown for this categorization
//  ARG_pIMailMsgProperties: Optional IMailMsgProperties interface to use
//  ARG_pIMailMsgRecipients: Optional IMailMsgRecipients to use
//  ARG_pIMailMsgRecipientsAdd: Optional IMailMsgRecipientsAdd to use
//  fBoundToStore: wether or not the message is bound to a store backing
//
//  NOTE: One of pIUnknown/pIMailMsgProperties/pIMailMsgRecipients MUST be
//  provided
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/30 13:48:47: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::CreateIMsgEntry(
    PIMSGENTRY *ppIE,
    IUnknown *ARG_pIUnknown,
    IMailMsgProperties *ARG_pIMailMsgProperties,
    IMailMsgRecipients *ARG_pIMailMsgRecipients,
    IMailMsgRecipientsAdd *ARG_pIMailMsgRecipientsAdd,
    BOOL fBoundToStore)
{
    HRESULT hr = S_OK;
    PIMSGENTRY pIE = NULL;
    IUnknown *pValidIMailMsgInterface = NULL;
    IUnknown *pIUnknown = NULL;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL;

    _ASSERT(ppIE);

    //
    // Allocate IMSGENTRY
    //
    pIE = new IMSGENTRY;
    if(pIE == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //
    // Figure out what interface we can QI with
    //
    if(ARG_pIUnknown) {
        pValidIMailMsgInterface = ARG_pIUnknown;
    } else if(ARG_pIMailMsgProperties) {
        pValidIMailMsgInterface = ARG_pIMailMsgProperties;
    } else if(ARG_pIMailMsgRecipients) {
        pValidIMailMsgInterface = ARG_pIMailMsgRecipients;
    } else {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    //
    // Get all the interfaces if necessary
    // Copy interface pointers and addref them if passed in
    // QI for interfaces not passed in
    // Here's a macro to do that:
    //

#define QI_IF_NECESSARY(ARG_pInterface, IID_Interface, ppDestInterface) \
    if(ARG_pInterface) { \
        (*(ppDestInterface)) = (ARG_pInterface); \
        (*(ppDestInterface))->AddRef(); \
    } else { \
        hr = pValidIMailMsgInterface->QueryInterface( \
            (IID_Interface), \
            (PVOID*)(ppDestInterface)); \
        if(FAILED(hr)) \
            goto CLEANUP; \
    }

    QI_IF_NECESSARY(ARG_pIUnknown, IID_IUnknown, &pIUnknown)
    QI_IF_NECESSARY(ARG_pIMailMsgProperties, IID_IMailMsgProperties, &pIMailMsgProperties)
    QI_IF_NECESSARY(ARG_pIMailMsgRecipients, IID_IMailMsgRecipients, &pIMailMsgRecipients)

    //
    // Set/create an IMailMsgRecipientsAdd
    //
    if(ARG_pIMailMsgRecipientsAdd) {
        pIMailMsgRecipientsAdd = ARG_pIMailMsgRecipientsAdd;
        pIMailMsgRecipientsAdd->AddRef();
    } else {
        hr = pIMailMsgRecipients->AllocNewList(&pIMailMsgRecipientsAdd);
        if(FAILED(hr)) {
            pIMailMsgRecipientsAdd = NULL;
            goto CLEANUP;
        }
    }
    //
    // Success!  Initialize pIE members
    //
    pIE->pIUnknown = pIUnknown;
    pIE->pIMailMsgProperties = pIMailMsgProperties;
    pIE->pIMailMsgRecipients = pIMailMsgRecipients;
    pIE->pIMailMsgRecipientsAdd = pIMailMsgRecipientsAdd;
    pIE->fBoundToStore = fBoundToStore;

    *ppIE = pIE;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup everything
        //
        if(pIE)
            delete pIE;
        if(pIUnknown)
            pIUnknown->Release();
        if(pIMailMsgProperties)
            pIMailMsgProperties->Release();
        if(pIMailMsgRecipients)
            pIMailMsgRecipients->Release();
        if(pIMailMsgRecipientsAdd)
            pIMailMsgRecipientsAdd->Release();
    }
    return hr;
}


//+------------------------------------------------------------
//
// Function: CreateAddIMsgEntry
//
// Synopsis: Creates/Adds an IMSGENTRY struct to the class list
//
// Arguments:
//   dwId: The Id to set on the list entry
//   ARG_pIUnknown: Optional Original IMsg IUnknown for this categorization
//   ARG_pIMailMsgProperties: Optional IMailMsgProperties interface to use
//   ARG_pIMailMsgRecipients: Optional IMailMsgRecipients to use
//   ARG_pIMailMsgRecipientsAdd: Optional IMailMsgRecipientsAdd to use
//   fBoundToStore: Wether or not the message is bound to a store backing
//
//  NOTE: One of pIUnknown/pIMailMsgProperties/pIMailMsgRecipients MUST be
//  provided
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/30 14:02:46: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::CreateAddIMsgEntry(
    DWORD dwId,
    IUnknown *pIUnknown,
    IMailMsgProperties *pIMailMsgProperties,
    IMailMsgRecipients *pIMailMsgRecipients,
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd,
    BOOL fBoundToStore)
{
    HRESULT hr;
    PIMSGENTRY pIE;
    
    hr = CreateIMsgEntry(
        &pIE, 
        pIUnknown, 
        pIMailMsgProperties,
        pIMailMsgRecipients,
        pIMailMsgRecipientsAdd,
        fBoundToStore);

    if(FAILED(hr))
        return hr;

    pIE->dwId = dwId;
    InsertTailList(&m_listhead, &(pIE->listentry));
    m_dwNumIMsgs++;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: Initialize
//
// Synopsis: Adds the first, original IMsg entry
//
// Arguments:
//  pIMsg: Original IMsg of categorization
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/30 14:05:37: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::Initialize(
    IUnknown *pIMsg)
{
    HRESULT hr;

    hr = CreateAddIMsgEntry(
        ICATEGORIZERMAILMSGS_DEFAULTIMSGID, 
        pIMsg,
        NULL,
        NULL,
        NULL,
        TRUE);

    return hr;
}


//+------------------------------------------------------------
//
// Function: FindIMsgEntry
//
// Synopsis: Retrieves a PIMSGENTRY with the matching dwId
//
// Arguments:
//  dwId: Id to find
//
// Returns:
//  NULL: not found
//  else pointer to an IMSGENTRY
//
// History:
// jstamerj 1998/06/30 14:08:42: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::PIMSGENTRY CICategorizerMailMsgsIMP::FindIMsgEntry(
    DWORD dwId)
{
    //
    // Traverse the list, look for our PIMSGEntry
    //
    PLIST_ENTRY ple;
    PIMSGENTRY pIE_Found = NULL;
    PIMSGENTRY pIE_Compare;

    for(ple = m_listhead.Flink; ple != &m_listhead; ple = ple->Flink) {
        pIE_Compare = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(pIE_Compare->dwId == dwId) {
            pIE_Found = pIE_Compare;
            break;
        }
    }
    return pIE_Found;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMsg
//
// Synopsis: Get the original messages IUnknown
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IUnknown * CICategorizerMailMsgsIMP::GetDefaultIUnknown()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIUnknown;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgProperties
//
// Synopsis: Get the original messages IMailMsgProperties
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgProperties * CICategorizerMailMsgsIMP::GetDefaultIMailMsgProperties()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgProperties;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgRecipients
//
// Synopsis: Get the original messages IMailMsgRecipients
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgRecipients * CICategorizerMailMsgsIMP::GetDefaultIMailMsgRecipients()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgRecipients;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgRecipientsAdd
//
// Synopsis: Get the original messag's IMailMsgRecipientsAdd
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgRecipientsAdd * CICategorizerMailMsgsIMP::GetDefaultIMailMsgRecipientsAdd()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgRecipientsAdd;
}


//+------------------------------------------------------------
//
// Function: WriteListAll
//
// Synopsis: Calls WriteList on all contained mailmsgs
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  Error from writelist
//
// History:
// jstamerj 1998/06/30 14:30:12: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::WriteListAll()
{
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IMailMsgProperties *pIMailMsgProperties_Default;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::WriteListAll");

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
    //
    // First double check that all messages are bound to a store backing
    //
    for(ple = m_listhead.Flink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(! (pIE->fBoundToStore)) {

            hr = pIE->pIMailMsgProperties->RebindAfterFork(
                pIMailMsgProperties_Default,
                NULL); // Backing store -- use orignal store

            if(FAILED(hr)) {
                ErrorTrace((LPARAM)this, "ReBindAfterFork failed hr %08lx", hr);
                goto CLEANUP;
            }
            pIE->fBoundToStore = TRUE;
        }
    }

    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgRecipients->WriteList(pIE->pIMailMsgRecipientsAdd);

        if(SUCCEEDED(hr)) {
            
            DWORD dwcRecips;
            //
            // If the resulting message has zero recipients, set the
            // message status to MP_STATUS_ABORT so that aqueue won't
            // throw it in badmail 
            //
            hr = pIE->pIMailMsgRecipients->Count(&dwcRecips);
            if(SUCCEEDED(hr)) {

                if(dwcRecips == 0) {
                
                    DebugTrace((LPARAM)this, "Deleting post-categorized message with 0 recips");
                    hr = pIE->pIMailMsgProperties->PutDWORD(
                        IMMPID_MP_MESSAGE_STATUS,
                        MP_STATUS_ABORT_DELIVERY);

                    if(SUCCEEDED(hr))
                        INCREMENT_COUNTER(MessagesAborted);

                } else {
                    //
                    // Increment post-cat recip count
                    //
                    INCREMENT_COUNTER_AMOUNT(PostCatRecipients, dwcRecips);
                }
            }
        }
    }
 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: RevertAll
//
// Synopsis: Release all IMailMsgRecipientsAdd thus reverting all messages to their original state
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/30 14:40:22: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::RevertAll()
{
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        pIE->pIMailMsgRecipientsAdd->Release();
        pIE->pIMailMsgRecipientsAdd = NULL;
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetAllIUnknowns
//
// Synopsis: Fills in a null terminated array of pointers to IMsgs
//           including our original IMsg and every IMsg we've bifurcated
//
// Arguments:
//   rgpIMsg pointer to array of IMsg pointers
//   cPtrs   size of rpgIMsg array in number of pointers
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): Array size was not
//  large enough
//
// History:
// jstamerj 1998/06/30 14:43:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::GetAllIUnknowns(
    IUnknown **rgpIMsg,
    DWORD cPtrs)
{
    if(cPtrs <= m_dwNumIMsgs)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IUnknown **ppIUnknown = rgpIMsg;

    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        *ppIUnknown = pIE->pIUnknown;
        ppIUnknown++;
    }
    *ppIUnknown = NULL;
    return S_OK;
}    


//+------------------------------------------------------------
//
// Function: GetMailMsg
//
// Synopsis: Retrieve interface pointers for a particular ID.
//           Bifurcate if necessary
//
// Arguments:
//  dwId: ID for the message you want
//  ppIMailMsgProperties: interface pointer to recieve
//  ppIMailMsgRecipientsAdd: interface pointer to recieve
//  pfCreated: Set to TRUE if just now bifurcated.  FALSE otherwise
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 1998/06/30 15:12:41: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::GetMailMsg(
    IN  DWORD                   dwId,
    OUT IMailMsgProperties      **ppIMailMsgProperties,
    OUT IMailMsgRecipientsAdd   **ppIMailMsgRecipientsAdd,
    OUT BOOL                    *pfCreated)
{
    PIMSGENTRY pIE;
    _ASSERT(ppIMailMsgProperties);
    _ASSERT(ppIMailMsgRecipientsAdd);
    _ASSERT(pfCreated);
    //
    // If two threads come in here at the same time with the same
    // dwId, we only want to create one message (and set *pfCreated =
    // TRUE for one of the threads).  We accomplish this by searching
    // for an exsting message and creating the new message inside a
    // critical section.
    //
    EnterCriticalSection(&m_cs);
    //
    // Find an existing IMsg
    //
    pIE = FindIMsgEntry(dwId);
    if(pIE != NULL) {
        (*ppIMailMsgProperties) = pIE->pIMailMsgProperties;
        (*ppIMailMsgProperties)->AddRef();
        (*ppIMailMsgRecipientsAdd) = pIE->pIMailMsgRecipientsAdd;
        (*ppIMailMsgRecipientsAdd)->AddRef();
        *pfCreated = FALSE;
        LeaveCriticalSection(&m_cs);
        return S_OK;

    } else {
        HRESULT hr;
        //
        // Not found, so bifurcate/create a new message
        //
        IMailMsgProperties *pIMailMsgProperties_Default;
        IMailMsgProperties *pIMailMsgProperties_New;
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd_New;
        pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
        _ASSERT(pIMailMsgProperties_Default);

        //
        // Bifurcate
        //
        hr = pIMailMsgProperties_Default->ForkForRecipients(
            &pIMailMsgProperties_New,
            &pIMailMsgRecipientsAdd_New);

        if(SUCCEEDED(hr)) {

            INCREMENT_COUNTER(MessagesCreated);
            //
            // Save this bifurcated message
            //
            hr = CreateAddIMsgEntry(
                dwId,
                NULL,
                pIMailMsgProperties_New,
                NULL,
                pIMailMsgRecipientsAdd_New,
                FALSE); // not bound to store
            
            if(SUCCEEDED(hr)) {
                // Transfer our creation refcount to the caller
                (*ppIMailMsgProperties) = pIMailMsgProperties_New;
                (*ppIMailMsgRecipientsAdd) = pIMailMsgRecipientsAdd_New;
                *pfCreated = TRUE;

            } else {
                // Release our creation refcount - we're failing
                pIMailMsgProperties_New->Release();
                pIMailMsgRecipientsAdd_New->Release();
            }
        }
        LeaveCriticalSection(&m_cs);
        return hr;
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::ReBindMailMsg
//
// Synopsis: Bind a message recieved via GetMailMsg to a store backing
//
// Arguments:
//  dwFlags: Flags passed into GetMailMsg
//  pStoreDriver: the store driver to bind it to
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//  error from mailmsg
//
// History:
// jstamerj 1999/02/06 21:51:42: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::ReBindMailMsg(
    DWORD dwFlags,
    IUnknown *pStoreDriver)
{
    HRESULT hr;
    PIMSGENTRY pEntry;
    IMailMsgProperties *pIMailMsgProperties_Default;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::ReBindMailMsg");

    DebugTrace((LPARAM)this, "dwFlags: %08lx", dwFlags);

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();

    //
    // Find our mailmsg
    //
    pEntry = FindIMsgEntry(dwFlags);
    if(pEntry == NULL) {
        
        ErrorTrace((LPARAM)this, "Did not find this bifid");
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto CLEANUP;
    }
    
    _ASSERT(pEntry->fBoundToStore == FALSE);
    //
    // bind the message to a store driver
    //
    hr = pEntry->pIMailMsgProperties->RebindAfterFork(
        pIMailMsgProperties_Default,
        pStoreDriver);
    
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "RebindAfterFork failed hr %08lx", hr);
        goto CLEANUP;
    }

    pEntry->fBoundToStore = TRUE;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
        


//+------------------------------------------------------------
//
// Function: SetMsgStatusAll
//
// Synopsis: Sets the message status property of all mailmsgs
//
// Arguments:
//  dwMsgStatus: Status to set
//
// Returns:
//  S_OK: Success
//  Error from mailmsg
//
// History:
// jstamerj 1998/06/30 14:30:12: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::SetMsgStatusAll(
    DWORD dwMsgStatus)
{
    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgProperties->PutDWORD(
            IMMPID_MP_MESSAGE_STATUS,
            dwMsgStatus);
    }
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::BeginMailMsgEnumeration
//
// Synopsis: Initialize mailmsg enumerator
//
// Arguments:
//  penumerator: data to use to keep track of enumeration
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: I'm not touching a null pointer
//
// History:
// jstamerj 1998/12/17 15:12:31: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::BeginMailMsgEnumeration(
    IN  PCATMAILMSG_ENUMERATOR penumerator)
{
    //  
    // Initialize the pvoid enumeator to our listhead
    //
    if(penumerator == NULL)
        return E_INVALIDARG;

    *penumerator = (CATMAILMSG_ENUMERATOR) &m_listhead;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::GetNextMailMsg
//
// Synopsis: Return info on the next mailmsg in an enumeration
//
// Arguments:
//  penumerator: enumerator initialized by BeginMailMsgEnumeration()
//  pdwFlags: to recieve the next mailmsg's flags
//  ppIMailMsgProperties: to recieve the next mailmsg's properties interface
//  ppIMailMsgRecipientsAdd: to recieve the next mailmsg's recip list interface
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/12/17 15:15:29: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::GetNextMailMsg(
    IN  PCATMAILMSG_ENUMERATOR penumerator,
    OUT DWORD *pdwFlags,
    OUT IMailMsgProperties **ppIMailMsgProperties,
    OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd)
{
    HRESULT hr;
    PIMSGENTRY pIE;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::GetNextMailMsg");

    _ASSERT(ppIMailMsgProperties);
    _ASSERT(ppIMailMsgRecipientsAdd);

    if(penumerator == NULL) {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    
    pIE = (PIMSGENTRY) ((PLIST_ENTRY)(*penumerator))->Flink;

    if((PVOID)&m_listhead == (PVOID)pIE) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto CLEANUP;
    }

    //  
    // AddRef and return pointers
    //
    (*ppIMailMsgProperties) = pIE->pIMailMsgProperties;
    (*ppIMailMsgProperties)->AddRef();
    (*ppIMailMsgRecipientsAdd) = pIE->pIMailMsgRecipientsAdd;
    (*ppIMailMsgRecipientsAdd)->AddRef();
    *pdwFlags = pIE->dwId;
    // remember our new position
    *penumerator = pIE;
    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::GetPerfBlock()
//
// Synopsis: Get the perf block for this virtual server
//
// Arguments: NONE
//
// Returns: Perf block pointer
//
// History:
// jstamerj 1999/02/24 18:38:07: Created.
//
//-------------------------------------------------------------
inline PCATPERFBLOCK CICategorizerMailMsgsIMP::GetPerfBlock()
{
    return m_pCICatListResolveIMP->GetPerfBlock();
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgs::HrPrepareForCompletion
//
// Synopsis: Call WriteList/SetMessageStatus/Commit on all messages
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 1999/06/10 10:39:14: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::HrPrepareForCompletion()
{
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IMailMsgProperties *pIMailMsgProperties_Default;
    TraceFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::HrPrepareForCompletion");

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
    //
    // First double check that all messages are bound to a store backing
    //
    for(ple = m_listhead.Flink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(! (pIE->fBoundToStore)) {

            hr = pIE->pIMailMsgProperties->RebindAfterFork(
                pIMailMsgProperties_Default,
                NULL); // Backing store -- use orignal store

            if(FAILED(hr)) {
                ErrorTrace((LPARAM)this, "ReBindAfterFork failed hr %08lx", hr);
                goto CLEANUP;
            }
            pIE->fBoundToStore = TRUE;
        }
    }
    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    // For each message, do the following:
    //  1) WriteList
    //  2) Set message status
    //  3) Commit (exception: not necessary for the original message)
    // 
    // If Commit fails, then delete all the bifurcated messages
    //
    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        DWORD dwcRecips;

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgRecipients->WriteList(pIE->pIMailMsgRecipientsAdd);
        if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "WriteList failed hr %08lx", hr);
            goto CLEANUP;
        }
        //
        // If the resulting message has zero recipients, set the
        // message status to MP_STATUS_ABORT so that aqueue won't
        // throw it in badmail 
        //
        hr = pIE->pIMailMsgRecipients->Count(&dwcRecips);
        if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "Count failed hr %08lx", hr);
            goto CLEANUP;
        }
        if(dwcRecips == 0) {
                
            DebugTrace((LPARAM)this, "Deleting post-categorized message with 0 recips");
            hr = pIE->pIMailMsgProperties->PutDWORD(
                IMMPID_MP_MESSAGE_STATUS,
                MP_STATUS_ABORT_DELIVERY);

            if(FAILED(hr)) {

                ErrorTrace((LPARAM)this, "PutDWORD failed hr %08lx", hr);
                goto CLEANUP;
            }

            INCREMENT_COUNTER(MessagesAborted);
            //
            // Do no bother to commit messages with zero recipients
            // (after all, who cares if a zero recipient message gets
            // lost?) 
            //

        } else {
            //
            // Increment post-cat recip count
            //
            INCREMENT_COUNTER_AMOUNT(PostCatRecipients, dwcRecips);
            //
            // Set the message status to Categorized
            //
            hr = pIE->pIMailMsgProperties->PutDWORD(
                IMMPID_MP_MESSAGE_STATUS,
                MP_STATUS_CATEGORIZED);

            if(FAILED(hr)) {

                ErrorTrace((LPARAM)this, "PutDWORD failed hr %08lx", hr);
                goto CLEANUP;
            }
            //
            // We must commit all bifurcated messages to prevent
            // loosing mail
            //
            if(pIE->dwId != 0) {

                hr = pIE->pIMailMsgProperties->Commit(NULL);

                if (hr == E_FAIL) hr = CAT_E_RETRY;

                if(FAILED(hr)) {

                    ErrorTrace((LPARAM)this, "Commit failed hr %08lx",
                               hr);
                    goto CLEANUP;
                }
            }
        }
    }

 CLEANUP:
    //
    //$$TODO: Delete bifurcated messages on failure
    //
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CICategorizerMailMsgsIMP::HrPrepareForCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatprops.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.cpp
//
// Contents: Implementation of CICategorizerPropertiesIMP
//
// Classes: CICategorizerPropertiesIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:42:59: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitem.h"


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::operator new
//
// Synopsis: Allocate memory for this and all the propIds contiguously
//
// Arguments:
//  size: Normal size of object
//  dwNumProps: Number of props desired in this object
//
// Returns: ptr to allocated memory or NULL
//
// History:
// jstamerj 1998/06/25 21:11:12: Created.
//
//-------------------------------------------------------------
void * CICategorizerPropertiesIMP::operator new(
    size_t size,
    DWORD dwNumProps)
{
    size_t cbSize;
    CICategorizerPropertiesIMP *pCICatItem;

    //
    // Calcualte size in bytes required
    //
    cbSize = size + (dwNumProps*sizeof(PROPERTY));

    pCICatItem = (CICategorizerPropertiesIMP *) new BYTE[cbSize];

    if(pCICatItem == NULL)
        return NULL;

    //
    // Set some member data in this catitem
    //
    pCICatItem->m_dwSignature = CICATEGORIZERPROPSIMP_SIGNATURE;
    pCICatItem->m_dwNumPropIds = dwNumProps;
    pCICatItem->m_rgProperties = (PPROPERTY) ((PBYTE)pCICatItem + size);
    return pCICatItem;
}


//+------------------------------------------------------------
//
// Function:  CICategorizerPropertiesIMP::CICategorizerPropertiesIMP
//
// Synopsis: Set initial values of member data
//
// Arguments:
//  pIUnknown: back pointer to use for QI
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 18:26:07: Created.
//
//-------------------------------------------------------------
CICategorizerPropertiesIMP::CICategorizerPropertiesIMP(
    IUnknown *pIUnknown)
{
    // Make sure we were created with our custom new operator
    _ASSERT(m_dwSignature == CICATEGORIZERPROPSIMP_SIGNATURE &&
            "PLEASE USE MY CUSTOM NEW OPERATOR!");

    _ASSERT(pIUnknown);

    m_pIUnknown = pIUnknown;

    // Initialize property data
    _VERIFY(SUCCEEDED(Initialize()));
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::~CICategorizerPropertiesIMP
//
// Synopsis: Release all of our data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 20:15:14: Created.
//
//-------------------------------------------------------------
CICategorizerPropertiesIMP::~CICategorizerPropertiesIMP()
{
    _ASSERT(m_dwSignature == CICATEGORIZERPROPSIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERPROPSIMP_SIGNATURE_FREE;

    if(m_rgProperties) {
        for(DWORD dwIdx = 0; dwIdx < m_dwNumPropIds; dwIdx++) {
            UnSetPropId(dwIdx);
        }
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::Initialize
//
// Synopsis: Initialize member property data
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/20 18:31:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::Initialize()
{
    if(m_dwNumPropIds) {
        //
        // Initialize all propstatus to PROPSTATUS_UNSET
        //
        _ASSERT(PROPSTATUS_UNSET == 0);
        ZeroMemory(m_rgProperties, m_dwNumPropIds * sizeof(PROPERTY));
    }
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetStringA
//
// Synopsis: Retrieves a string property
//
// Arguments:
//   
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 1998/06/20 18:38:15: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetStringA(
    DWORD dwPropId,
    DWORD cch,
    LPSTR pszValue)
{
    _ASSERT(pszValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_STRINGA) {
        return CAT_E_PROPNOTFOUND;
    }
    if(((DWORD)lstrlenA(m_rgProperties[dwPropId].PropValue.pszValue)) >= cch) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    lstrcpy(pszValue, m_rgProperties[dwPropId].PropValue.pszValue);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetStringAPtr
//
// Synopsis: Retrieves a pointer to the internal string attribute.
//           Note this memory will be free'd the next time this propID
//           is set or when all references to ICatItem are released
//
// Arguments:
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 1998/07/01 10:39:40: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetStringAPtr(
    DWORD dwPropId,
    LPSTR *ppsz)
{
    _ASSERT(ppsz);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_STRINGA) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppsz = m_rgProperties[dwPropId].PropValue.pszValue;
    return S_OK;
}    



//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutStringA
//
// Synopsis: Copies string buffer and sets property
//
// Arguments:
//   dwPropId: Property to set
//   pszValue: String to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 18:59:13: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutStringA(
    DWORD dwPropId,
    LPSTR pszValue)
{
    LPSTR pszCopy;

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    pszCopy = m_strdup(pszValue);

    if(pszCopy == NULL)
        return E_OUTOFMEMORY;

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_STRINGA;
    m_rgProperties[dwPropId].PropValue.pszValue = pszCopy;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetDWORD
//
// Synopsis:
//   Retrieve a DWORD property
//
// Arguments:
//   dwPropId: propId to retrieve
//   pdwValue: out parameter
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:14:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetDWORD(
    DWORD dwPropId,
    DWORD *pdwValue)
{
    _ASSERT(pdwValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_DWORD) {
        return CAT_E_PROPNOTFOUND;
    }
    *pdwValue = m_rgProperties[dwPropId].PropValue.dwValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutDWORD
//
// Synopsis: Set a dword property
//
// Arguments:
//   dwPropId: prop to set
//   dwValue:  value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:18:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutDWORD(
    DWORD dwPropId,
    DWORD dwValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_DWORD;
    m_rgProperties[dwPropId].PropValue.dwValue = dwValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetHRESULT
//
// Synopsis:
//   Retrieve a HRESULT property
//
// Arguments:
//   dwPropId: propId to retrieve
//   pdwValue: out parameter
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:14:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetHRESULT(
    DWORD dwPropId,
    HRESULT *pdwValue)
{
    _ASSERT(pdwValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_HRESULT) {
        return CAT_E_PROPNOTFOUND;
    }
    *pdwValue = m_rgProperties[dwPropId].PropValue.dwValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutHRESULT
//
// Synopsis: Set a HRESULT property
//
// Arguments:
//   dwPropId: prop to set
//   dwValue:  value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:18:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutHRESULT(
    DWORD dwPropId,
    HRESULT dwValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_HRESULT;
    m_rgProperties[dwPropId].PropValue.dwValue = dwValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetBool
//
// Synopsis: Retrieves a boolean property
//
// Arguments:
//   dwPropId: propID to retrieve
//   pfValue: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:22:28: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetBool(
    DWORD dwPropId,
    BOOL  *pfValue)
{
    _ASSERT(pfValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_BOOL) {
        return CAT_E_PROPNOTFOUND;
    }
    *pfValue = m_rgProperties[dwPropId].PropValue.fValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutBool
//
// Synopsis: Sets a boolean property
//
// Arguments:
//   dwPropId: property id to set
//   fValue: value of boolean to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutBool(
    DWORD dwPropId,
    BOOL  fValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_BOOL;
    m_rgProperties[dwPropId].PropValue.fValue = fValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetPVoid
//
// Synopsis: Retrieve a pvoid property
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppValue: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetPVoid(
    DWORD dwPropId,
    PVOID *ppValue)
{
    _ASSERT(ppValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_PVOID) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppValue = m_rgProperties[dwPropId].PropValue.pvValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutPVoid
//
// Synopsis: Sets a boolean property
//
// Arguments:
//   dwPropId: property id to set
//   pvValue: prop value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutPVoid(
    DWORD dwPropId,
    PVOID pvValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_PVOID;
    m_rgProperties[dwPropId].PropValue.pvValue = pvValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIUnknown
//
// Synopsis: Retrieve an IUnknown property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppUnknown: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIUnknown(
    DWORD dwPropId,
    IUnknown  **ppUnknown)
{
    _ASSERT(ppUnknown);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IUNKNOWN) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppUnknown = m_rgProperties[dwPropId].PropValue.pIUnknownValue;
    (*ppUnknown)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIUnknown
//
// Synopsis: Sets an IUnknown property
//
// Arguments:
//   dwPropId: property id to set
//   pUnknown: IUnknown to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIUnknown(
    DWORD dwPropId,
    IUnknown *pUnknown)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IUNKNOWN;
    m_rgProperties[dwPropId].PropValue.pIUnknownValue = pUnknown;

    //
    // Hold a reference to this IUnknown
    //
    pUnknown->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIMailMsgProperties
//
// Synopsis: Retrieve an IMailMsgProperties property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppIMsg: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIMailMsgProperties(
    DWORD dwPropId,
    IMailMsgProperties  **ppIMailMsgProperties)
{
    _ASSERT(ppIMailMsgProperties);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IMAILMSGPROPERTIES) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppIMailMsgProperties = m_rgProperties[dwPropId].PropValue.pIMailMsgPropertiesValue;
    (*ppIMailMsgProperties)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIMailMsgProperties
//
// Synopsis: Sets an IMailMsgProperties property
//
// Arguments:
//   dwPropId: property id to set
//   pIMsg: IMailMsgProperties to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIMailMsgProperties(
    DWORD dwPropId,
    IMailMsgProperties *pIMailMsgProperties)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IMAILMSGPROPERTIES;
    m_rgProperties[dwPropId].PropValue.pIMailMsgPropertiesValue = pIMailMsgProperties;

    //
    // Hold a reference to this IUnknown
    //
    pIMailMsgProperties->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppIMailMsgRecipientsAdd: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd(
    DWORD dwPropId,
    IMailMsgRecipientsAdd  **ppIMailMsgRecipientsAdd)
{
    _ASSERT(ppIMailMsgRecipientsAdd);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IMAILMSGRECIPIENTSADD) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppIMailMsgRecipientsAdd = m_rgProperties[dwPropId].PropValue.pIMailMsgRecipientsAddValue;
    (*ppIMailMsgRecipientsAdd)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd
//
// Synopsis: Sets an IMailMsgRecipientsAdd property
//
// Arguments:
//   dwPropId: property id to set
//   pIMailMsgRecipientsAdd: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd(
    DWORD dwPropId,
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IMAILMSGRECIPIENTSADD;
    m_rgProperties[dwPropId].PropValue.pIMailMsgRecipientsAddValue = pIMailMsgRecipientsAdd;

    //
    // Hold a reference to this interface
    //
    pIMailMsgRecipientsAdd->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerListResolve
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerListResolve: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerListResolve(
    DWORD dwPropId,
    ICategorizerListResolve  **ppICategorizerListResolve)
{
    _ASSERT(ppICategorizerListResolve);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerListResolve = m_rgProperties[dwPropId].PropValue.pICategorizerListResolveValue;
    (*ppICategorizerListResolve)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerListResolve
//
// Synopsis: Sets an ICategorizerListResolve property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerListResolve: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerListResolve(
    DWORD dwPropId,
    ICategorizerListResolve *pICategorizerListResolve)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE;
    m_rgProperties[dwPropId].PropValue.pICategorizerListResolveValue = pICategorizerListResolve;

    //
    // Hold a reference to this interface
    //
    pICategorizerListResolve->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerItemAttributes
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerItemAttributes: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerItemAttributes(
    DWORD dwPropId,
    ICategorizerItemAttributes  **ppICategorizerItemAttributes)
{
    _ASSERT(ppICategorizerItemAttributes);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerItemAttributes = m_rgProperties[dwPropId].PropValue.pICategorizerItemAttributesValue;
    (*ppICategorizerItemAttributes)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerItemAttributes
//
// Synopsis: Sets an ICategorizerItemAttributes property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerItemAttributes: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerItemAttributes(
    DWORD dwPropId,
    ICategorizerItemAttributes *pICategorizerItemAttributes)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES;
    m_rgProperties[dwPropId].PropValue.pICategorizerItemAttributesValue = pICategorizerItemAttributes;

    //
    // Hold a reference to this interface
    //
    pICategorizerItemAttributes->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerMailMsgs
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerMailMsgs: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerMailMsgs(
    DWORD dwPropId,
    ICategorizerMailMsgs  **ppICategorizerMailMsgs)
{
    _ASSERT(ppICategorizerMailMsgs);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERMAILMSGS) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerMailMsgs = m_rgProperties[dwPropId].PropValue.pICategorizerMailMsgsValue;
    (*ppICategorizerMailMsgs)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerMailMsgs
//
// Synopsis: Sets an ICategorizerMailMsgs property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerMailMsgs: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerMailMsgs(
    DWORD dwPropId,
    ICategorizerMailMsgs *pICategorizerMailMsgs)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERMAILMSGS;
    m_rgProperties[dwPropId].PropValue.pICategorizerMailMsgsValue = pICategorizerMailMsgs;

    //
    // Hold a reference to this interface
    //
    pICategorizerMailMsgs->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerItem
//
// Synopsis: Retrieve an ICategorizerItem property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerItem: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerItem(
    DWORD dwPropId,
    ICategorizerItem  **ppICategorizerItem)
{
    _ASSERT(ppICategorizerItem);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERITEM) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerItem = m_rgProperties[dwPropId].PropValue.pICategorizerItemValue;
    (*ppICategorizerItem)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerItem
//
// Synopsis: Sets an ICategorizerItem property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerItem: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerItem(
    DWORD dwPropId,
    ICategorizerItem *pICategorizerItem)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERITEM;
    m_rgProperties[dwPropId].PropValue.pICategorizerItemValue = pICategorizerItem;

    //
    // Hold a reference to this interface
    //
    pICategorizerItem->AddRef();
    
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::UnsetPropId
//
// Synopsis: Release the propId if allocated
//
// Arguments:
//   dwPropId: Property to release
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 19:10:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::UnSetPropId(
    DWORD dwPropId)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    switch(m_rgProperties[dwPropId].PropStatus) {
     default:
         //
         // Do nothing
         //
         break;

     case PROPSTATUS_SET_STRINGA:
         //
         // Free the string
         //
         delete m_rgProperties[dwPropId].PropValue.pszValue;
         break;
         
     case PROPSTATUS_SET_IUNKNOWN:
     case PROPSTATUS_SET_IMAILMSGPROPERTIES:
     case PROPSTATUS_SET_IMAILMSGRECIPIENTSADD:
     case PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES:
     case PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE:
     case PROPSTATUS_SET_ICATEGORIZERMAILMSGS:
     case PROPSTATUS_SET_ICATEGORIZERITEM:
         //
         // Release the interface
         //
         (m_rgProperties[dwPropId].PropValue.pIUnknownValue)->Release();
         break;
    }
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_UNSET;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\cat\src
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Moved to transmt
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Includes from external directories
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <listmacr.h>
#include <dbgtrace.h>
#include "aqinit.h"
#include "spinlock.h"
#include "catdebug.h"
#include <lmcons.h>
#include <dsgetdc.h>
#include <lmapibuf.h>
#include <time.h>
#include "caterr.h"
#include <rwex.h>
#include "smtpevent.h"
#include <transmem.h>
#include <winldap.h>
#include <perfcat.h>
#include <catperf.h>
#include <cpool.h>
#include <mailmsgprops.h>
#include <phatqmsg.h>
#include <mailmsg.h>
#include <phatqcat.h>


//Local includes
#include "CodePageConvert.h"
#ifdef PLATINUM
#include <ptntintf.h>
#include <ptntdefs.h>
#define AQ_MODULE_NAME "phatq"
#else //not PLATINUM
#define AQ_MODULE_NAME "aqueue"
#endif //PLATINUM
#include "cat.h"
#include "ccat.h"
#include "ccatfn.h"
#include "address.h"
#include "catconfig.h"
#include "propstr.h"
#include "catglobals.h"
#include "ccataddr.h"
#include "ccatsender.h"
#include "ccatrecip.h"
#include "idstore.h"
#include <smtpseo.h>
#include "icatlistresolve.h"
#include "catdefs.h"

//Wrappers for transmem macros
#include <aqmem.h>
#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\cat\src
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"

//DEFINE_GUID does not play well with pre-compiled headers
#include "initguid.h"
#include <phatqcat.h>

DEFINE_GUID(CLSID_SmtpCat,
            0xb23c35b7, 0x9219, 0x11d2,
            0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatparam.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatdsparam.cpp
//
// Contents: Implementation of ICategorizerParameters
//
// Classes:
//   CICategorizerParametersIMP
//
// Functions:
//   CICategorizerParameters
//   ~CICategorizerParameters
//   QueryInterface
//   AddRef
//   Release
//
// History:
// jstamerj 980611 16:20:27: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatparam.h"

//+------------------------------------------------------------
//
// Function: CICategorizerParameters::CICategorizerParameters
//
// Synopsis: Initialize private member data
//
// Arguments:
//  pCCatConfigInfo: pointer to the config info for this virtual
//                   categorizer
//  dwInitialICatItemProps: Initailly reserved ICategorizerItem properties
//  dwInitialICatListReesolveProps: Initially reserved
//                                  ICategorizerListResolve properties
// Returns: NOTHING
//
// History:
// jstamerj 980611 20:02:35: Created.
//
//-------------------------------------------------------------
CICategorizerParametersIMP::CICategorizerParametersIMP(
    PCCATCONFIGINFO pCCatConfigInfo,
    DWORD dwInitialICatItemProps,
    DWORD dwInitialICatListResolveProps)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerParameters::CICategorizerParameters");
    m_dwSignature = SIGNATURE_CICategorizerParametersIMP;
    m_cRef = 0;

    m_fReadOnly = FALSE;

    ZeroMemory(m_rgszDSParameters, sizeof(m_rgszDSParameters));
    ZeroMemory(m_rgwszDSParameters, sizeof(m_rgwszDSParameters));

    m_dwCurPropId_ICatItem = dwInitialICatItemProps;
    m_dwCurPropId_ICatListResolve = dwInitialICatListResolveProps;

    m_pCCatConfigInfo = pCCatConfigInfo;
    m_pCIRequestedAttributes = NULL;
    m_pICatLdapConfigInfo = NULL;
    //
    // HrDllInitialize should always succeed here (since the DLL is
    // already initialized, it will just increment the refcount)
    //
    _VERIFY(SUCCEEDED(HrDllInitialize()));
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CICategorizerParameters::~CICategorizerParameters
//
// Synopsis: Release all allocateded data
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 980611 20:04:08: Created.
//
//-------------------------------------------------------------
CICategorizerParametersIMP::~CICategorizerParametersIMP()
{
    LONG lCount;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerParameters::~CICategorizerParameters");
    _ASSERT(m_cRef == 0);
    _ASSERT(m_dwSignature == SIGNATURE_CICategorizerParametersIMP);

    m_dwSignature = SIGNATURE_CICategorizerParametersIMP_Invalid;

    //
    // Free all string parameters
    //
    for(lCount = 0; lCount < DSPARAMETER_ENDENUMMESS; lCount++) {
        if(m_rgszDSParameters[lCount])
            delete m_rgszDSParameters[lCount];
        if(m_rgwszDSParameters[lCount])
            delete m_rgwszDSParameters[lCount];
    }
    if(m_pCIRequestedAttributes)
        m_pCIRequestedAttributes->Release();

    if(m_pICatLdapConfigInfo)
        m_pICatLdapConfigInfo->Release();

    DllDeinitialize();
    TraceFunctLeaveEx((LPARAM)this);
}

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerParameters
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerParameters) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerParametersEx) {
        *ppv = (LPVOID) ((ICategorizerParametersEx *)this);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerParametersIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero.
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerParametersIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    if(lNewRefCount == 0) {
        delete this;
        return 0;
    } else {
        return lNewRefCount;
    }
}



//+------------------------------------------------------------
//
// Function: GetDSParameterA
//
// Synopsis: Retrieves pointer to DSParameter string
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   ppszValue: pointer to pointer to recieve value string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 980611 20:28:02: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetDSParameterA(
    DWORD   dwDSParameter,
    LPSTR  *ppszValue)
{
    TraceFunctEnterEx((LPARAM)this, "GetDSParamterA");

    if(dwDSParameter >= DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        TraceFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    if(ppszValue == NULL) {
        ErrorTrace((LPARAM)this, "Invalid ppszValue (NULL)");
        TraceFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    *ppszValue = m_rgszDSParameters[dwDSParameter];
    TraceFunctLeaveEx((LPARAM)this);
    return (*ppszValue) ? S_OK : CAT_E_PROPNOTFOUND;
}


//+------------------------------------------------------------
//
// Function: GetDSParameterA
//
// Synopsis: Retrieves pointer to DSParameter string
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   ppszValue: pointer to pointer to recieve value string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1999/12/09 20:23:24: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetDSParameterW(
    DWORD   dwDSParameter,
    LPWSTR *ppszValue)
{
    TraceFunctEnterEx((LPARAM)this, "GetDSParamterA");

    if(dwDSParameter >= DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        TraceFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    if(ppszValue == NULL) {
        ErrorTrace((LPARAM)this, "Invalid ppszValue (NULL)");
        TraceFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    *ppszValue = m_rgwszDSParameters[dwDSParameter];
    TraceFunctLeaveEx((LPARAM)this);
    return (*ppszValue) ? S_OK : CAT_E_PROPNOTFOUND;
}


//+------------------------------------------------------------
//
// Function: SetDSParameterA
//
// Synopsis: Copies string and sets DS Parameter
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   pszValue: pointer to string to copy/set
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_ACCESSDENIED
//
// History:
// jstamerj 980611 20:47:53: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::SetDSParameterA(
    DWORD dwDSParameter,
    LPCSTR pszValue)
{
    HRESULT hr = S_OK;
    LPSTR pszNew = NULL;
    LPSTR pszOld = NULL;
    LPWSTR pwszNew = NULL;
    LPWSTR pwszOld = NULL;
    int   cch, i;

    TraceFunctEnterEx((LPARAM)this, "SetDSParamterA");

    if(dwDSParameter >= DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    if(m_fReadOnly) {
        ErrorTrace((LPARAM)this, "Error: we are read only");
        hr = E_ACCESSDENIED;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Setting parameter %ld to \"%s\"",
               dwDSParameter, pszValue ? pszValue : "NULL");

    if(pszValue) {
        pszNew = new CHAR[lstrlen(pszValue) + 1];
        if(pszNew == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory copying string");
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }
        lstrcpy(pszNew, pszValue);
        //
        // Convert to unicode
        //
        cch = MultiByteToWideChar(
            CP_UTF8,
            0,
            pszValue,
            -1,
            NULL,
            0);
        if(cch == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
        }
        pwszNew = new WCHAR[cch];
        if(pwszNew == NULL) {
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }
        i = MultiByteToWideChar(
            CP_UTF8,
            0,
            pszValue,
            -1,
            pwszNew,
            cch);
        if(cch == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
        }
    }
    pszOld = m_rgszDSParameters[dwDSParameter];
    m_rgszDSParameters[dwDSParameter] = pszNew;
    pwszOld = m_rgwszDSParameters[dwDSParameter];
    m_rgwszDSParameters[dwDSParameter] = pwszNew;

    if(pszOld)
        delete [] pszOld;
    if(pwszOld)
        delete [] pwszOld;

 CLEANUP:
    if(FAILED(hr)) {

        if(pszNew)
            delete [] pszNew;
        if(pwszNew)
            delete [] pwszNew;
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: RequestAttributeA
//
// Synopsis: Adds an attribute to the array
//
// Arguments:
//   pszName: name of attribute to add
//
// Returns:
//  S_OK: Success
//  S_FALSE: Yeah, we already have that attribute
//  E_OUTOFMEMORY: duh
//  E_ACCESSDENIED: we are read only
//  HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
//
// History:
// jstamerj 980611 20:08:07: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::RequestAttributeA(
    LPCSTR pszName)
{
    HRESULT hr;
    BOOL fExclusiveLock = FALSE;
    LPSTR *rgsz;
    LPSTR *ppsz;
    CICategorizerRequestedAttributesIMP *pCIRequestedAttributes = NULL;

    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerParametersIMP::RequestAttributeA");
    _ASSERT(pszName);
    if(pszName == NULL) {
        ErrorTrace((LPARAM)this, "RequestAttributeA called with NULL pszName");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUP;
    }

    m_sharelock.ExclusiveLock();
    fExclusiveLock = TRUE;
    //
    // Create the ICategorizerRequestedAttributes object if it does
    // not exist yet
    //
    if(m_pCIRequestedAttributes == NULL) {

        m_pCIRequestedAttributes = new CICategorizerRequestedAttributesIMP();
        if(m_pCIRequestedAttributes == NULL) {
            //
            // Out of memory
            //
            hr = E_OUTOFMEMORY;
            goto CLEANUP;

        } else {
            //
            // One reference from this object
            //
            m_pCIRequestedAttributes->AddRef();
        }
    }
    //
    // Don't add the attribute if it is alrady in the list
    //
    if(SUCCEEDED(m_pCIRequestedAttributes->FindAttribute(pszName))) {
        DebugTrace((LPARAM)this, "Already added attribute %s", pszName);
        hr = S_FALSE;
        goto CLEANUP;
    }

    //
    // There are two paths we can go down here.
    // 1) If have the only reference to m_pCIRequestedAttributes, we
    //    safely direcly add the attribute to the existing
    //    RequestedAttributes object (we will not give out the object
    //    until we release the exclusivelock below).
    // 2) If someone else does have a reference to
    // m_pCIRequestedAttributes, we need to construct a new
    // RequestedAttributes object and copy all of the old
    // RequestedAttributes to the new object.
    //
    if(m_pCIRequestedAttributes->GetReferenceCount() != 1) {
        //
        // Construct a new object
        //
        pCIRequestedAttributes = new CICategorizerRequestedAttributesIMP();
        if(pCIRequestedAttributes == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }

        pCIRequestedAttributes->AddRef();

        //
        // Copy all the attributes
        //
        hr = m_pCIRequestedAttributes->GetAllAttributes(
            &rgsz);

        if(FAILED(hr))
            goto CLEANUP;

        if(rgsz) {
            ppsz = rgsz;
            while((*ppsz) && SUCCEEDED(hr)) {

                hr = pCIRequestedAttributes->AddAttribute(
                    *ppsz);
                ppsz++;
            }
            if(FAILED(hr)) {
                ErrorTrace((LPARAM)this, "AddAttribute failed hr %08lx", hr);
                goto CLEANUP;
            }
        }
        //
        // Release the old interface; switch to using the new one
        //
        m_pCIRequestedAttributes->Release();
        m_pCIRequestedAttributes = pCIRequestedAttributes;
        pCIRequestedAttributes = NULL;
    }
    //
    // Now add the new attribute
    //
    hr = m_pCIRequestedAttributes->AddAttribute(pszName);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "AddAttribute failed hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    if(fExclusiveLock)
        m_sharelock.ExclusiveUnlock();

    if(FAILED(hr)) {
        if(pCIRequestedAttributes)
            pCIRequestedAttributes->Release();
    }
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: GetRequetedAttributes
//
// Synopsis: Retrieve interface ptr that can be used to get all attributes
//
// Arguments:
//  ppIRequestedAttributes: Out paramter to receive ptr to the
//                          attributes interface.  This must be
//                          released by the caller
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND): No attributes have been
//  requested to date.
//
// History:
// jstamerj 980611 20:57:08: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetRequestedAttributes(
    OUT  ICategorizerRequestedAttributes **ppIRequestedAttributes)
{
    HRESULT hr = S_OK;
    _ASSERT(ppIRequestedAttributes);
    m_sharelock.ShareLock();

    if(m_pCIRequestedAttributes == NULL) {

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    } else {

        *ppIRequestedAttributes = m_pCIRequestedAttributes;
        (*ppIRequestedAttributes)->AddRef();
    }
    m_sharelock.ShareUnlock();
    return hr;
}


//+------------------------------------------------------------
//
// Function: ReserveICatItemPropIds
//
// Synopsis: Register a range of PropIds to use
//
// Arguments:
//   dwNumPropIdsRequested: how many props do you want?
//   pdwBeginningRange: pointer to dword to recieve your first propId
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/26 18:32:51: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::ReserveICatItemPropIds(
    DWORD dwNumPropIdsRequested,
    DWORD *pdwBeginningPropId)
{
    if(pdwBeginningPropId == NULL) {
        return E_INVALIDARG;
    }

    *pdwBeginningPropId = InterlockedExchangeAdd(
        (PLONG) &m_dwCurPropId_ICatItem,
        (LONG) dwNumPropIdsRequested);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: ReserveICatListResolvePropIds
//
// Synopsis: Register a range of PropIds to use
//
// Arguments:
//   dwNumPropIdsRequested: how many props do you want?
//   pdwBeginningRange: pointer to dword to recieve your first propId
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/11/11 19:51:19: created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::ReserveICatListResolvePropIds(
    DWORD dwNumPropIdsRequested,
    DWORD *pdwBeginningPropId)
{
    if(pdwBeginningPropId == NULL) {
        return E_INVALIDARG;
    }

    *pdwBeginningPropId = InterlockedExchangeAdd(
        (PLONG) &m_dwCurPropId_ICatListResolve,
        (LONG) dwNumPropIdsRequested);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerParametersIMP::GetCCatConfigInfo
//
// Synopsis: Return a pointer to the ccatconfiginfo structure
//
// Arguments:
//  ppCCatConfigInfo: ptr to the ptr to set to the CCatConfigInfo ptr
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/14 11:53:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerParametersIMP::GetCCatConfigInfo(
    PCCATCONFIGINFO *ppCCatConfigInfo)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this,
                      "CICategorizerParametersIMP::GetCCatConfigInfo");


    if(ppCCatConfigInfo == NULL)
        hr = E_INVALIDARG;
    else
        *ppCCatConfigInfo = m_pCCatConfigInfo;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: RegisterCatLdapConfigInterface
//
// Synopsis: In order to allow the user to customize which LDAP
//  servers are to be used by the Categorizer, we provide this
//  function to Register a config-interface with the categorizer.
//  The config-interface can be queried to retrieve a list of LDAP
//  servers. Currently PhatCat implements the config-interface and
//  registers it with categorizer.
//
// Arguments:
//   pICatLdapConfigInfo: Ptr to the callback interface
//
// Returns:
//  S_OK: Success
//
// History:
//  gpulla created
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::RegisterCatLdapConfigInterface(
    ICategorizerLdapConfig *pICatLdapConfigInfo)
{
    ICategorizerLdapConfig *pICatLdapConfigInfoOld = NULL;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerParametersIMP::RegisterCatLdapConfigInterface");

    DebugTrace((LPARAM)this, "Registering ldap config info interface");

    if(pICatLdapConfigInfo)
        pICatLdapConfigInfo->AddRef();

    pICatLdapConfigInfoOld = (ICategorizerLdapConfig *)
        InterlockedExchangePointer((void**)&m_pICatLdapConfigInfo, pICatLdapConfigInfo);

    if(pICatLdapConfigInfoOld)
        pICatLdapConfigInfoOld->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: GetCatLdapConfigInterface
//
// Synopsis: A simple "Get" function to obtain the config-interface
//  registered by RegisterCatLdapConfigInterface(). The config-interface
//  returned is valid as long as CICategorizerParametersIMP has not been
//  destroyed.
//
// Arguments:
//   ppICatLdapConfigInfo: Returned ptr to callback interface.
//                         Gets Released with CICategorizerParametersIMP
//
// Returns:
//  S_OK: Success
//
// History:
//  gpulla created
//-------------------------------------------------------------
STDMETHODIMP  CICategorizerParametersIMP::GetLdapConfigInterface(
    OUT  ICategorizerLdapConfig **ppICatLdapConfigInfo)
{
   *ppICatLdapConfigInfo = m_pICatLdapConfigInfo;
   return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/08 14:41:51: Created.
//
//-------------------------------------------------------------
CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP()
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP");

    m_dwSignature = SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP;

    m_lAttributeArraySize = 0;
    m_rgszAttributeArray  = NULL;
    m_rgwszAttributeArray = NULL;
    m_lNumberAttributes   = 0;
    m_ulRef = 0;

    TraceFunctLeaveEx((LPARAM)this);
} // CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP



//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP
//
// Synopsis: Clean up member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/08 15:01:17: Created.
//
//-------------------------------------------------------------
CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP()
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP");

    if(m_rgszAttributeArray) {
        _ASSERT(m_rgwszAttributeArray);
        //
        // Free attribute array
        //
        for(LONG lCount = 0; lCount < m_lNumberAttributes; lCount++) {
            delete m_rgszAttributeArray[lCount];
            delete m_rgwszAttributeArray[lCount];
        }
        delete m_rgszAttributeArray;
        delete m_rgwszAttributeArray;
    }

    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP


//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::QueryInterface
//
// Synopsis: Get interfaces supported by this object
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 1999/07/08 15:04:35: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerRequestedAttributes) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
} // CICategorizerRequestedAttributesIMP::QueryInterface


//+------------------------------------------------------------
//
// Function: ReAllocArrayIfNecessary
//
// Synopsis: Reallocate the parameter string pointer array if necessary
//
// Arguments:
//   lNewAttributeCount: number of attribute we want to add right now
//
// Returns:
//  S_OK: Success
//  S_FALSE: Success, no realloc was necessary
//  E_OUTOFMEMORY: duh
//
// History:
// jstamerj 980611 16:55:36: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::ReAllocArrayIfNecessary(
    LONG lNewAttributeCount)
{
    TraceFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::ReAllocArrayIfNecessary");

    if(m_lNumberAttributes + lNewAttributeCount >= m_lAttributeArraySize) {
        //
        // Grow the array by DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE
        //
        LPSTR *rgTemp;
        LPWSTR *rgwTemp;
        LONG lNewSize = m_lAttributeArraySize + DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE;

        DebugTrace((LPARAM)this, "Attempting realloc, new size = %d", lNewSize);

        rgTemp = new LPSTR[lNewSize];
        if(rgTemp == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory reallocing array");
            return E_OUTOFMEMORY;
        }

        rgwTemp = new LPWSTR[lNewSize];
        if(rgwTemp == NULL) {
            delete [] rgTemp;
            ErrorTrace((LPARAM)this, "Out of memory reallocing array");
            return E_OUTOFMEMORY;
        }

        if(m_rgszAttributeArray) {
            _ASSERT(m_rgwszAttributeArray);
            //
            // Copy old ptr array to new
            //
            CopyMemory(rgTemp, m_rgszAttributeArray, sizeof(LPSTR) * m_lNumberAttributes);
            CopyMemory(rgwTemp, m_rgwszAttributeArray, sizeof(LPWSTR) * m_lNumberAttributes);
            //
            // Zero the rest of the memory (keep the LPSTR array NULL termianted)
            //
            ZeroMemory(rgTemp + m_lNumberAttributes,
                       (lNewSize - m_lNumberAttributes) * sizeof(LPSTR));
            ZeroMemory(rgwTemp + m_lNumberAttributes,
                       (lNewSize - m_lNumberAttributes) * sizeof(LPWSTR));
            //
            // Release old array
            //
            LPSTR *rgTempOld = m_rgszAttributeArray;
            LPWSTR *rgwTempOld = m_rgwszAttributeArray;
            m_rgszAttributeArray = rgTemp;
            m_rgwszAttributeArray = rgwTemp;
            delete [] rgTempOld;
            delete [] rgwTempOld;

        } else {
            //
            // This is the first time we've alloc'd the array
            //
            ZeroMemory(rgTemp, lNewSize * sizeof(LPSTR));
            ZeroMemory(rgwTemp, lNewSize * sizeof(LPWSTR));
            m_rgszAttributeArray = rgTemp;
            m_rgwszAttributeArray = rgwTemp;
        }

        m_lAttributeArraySize = lNewSize;

        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;

    } else {
        //
        // No realloc required
        //
        DebugTrace((LPARAM)this, "No realloc required");
        TraceFunctLeaveEx((LPARAM)this);
        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: FindAttribute
//
// Synopsis: Checks to see if our array contains an attribute string
//
// Arguments:
//  pszAttribute: The attribute you're looking for
//
// Returns:
//  S_OK: Found it
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//
// History:
// jstamerj 980611 20:34:51: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::FindAttribute(
    LPCSTR pszAttribute)
{
    for(LONG lCount = 0; lCount < m_lNumberAttributes; lCount++) {
        if(lstrcmpi(pszAttribute, m_rgszAttributeArray[lCount]) == 0) {
            return S_OK;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}


//+------------------------------------------------------------
//
// Function: AddAttribute
//
// Synopsis: Adds an attribute to the attribute array.  Allocs and
//           copies the string.
//
// Arguments:
//   pszAttribute: pointer to string to copy and add to array
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY: duh
//
// History:
// jstamerj 980611 17:15:40: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::AddAttribute(
    LPCSTR pszAttribute)
{
    HRESULT hr = S_OK;
    DWORD cchAttributeUTF8;
    int i;
    LONG lIndex = -1;

    TraceFunctEnterEx((LPARAM)this, "CICategorizerParametersIMP::AddAttribute");

    _ASSERT(pszAttribute);

    //
    // Make sure there is room in the array
    //
    hr = ReAllocArrayIfNecessary(1);
    if(FAILED(hr))
        goto CLEANUP;

    lIndex = m_lNumberAttributes++;
    m_rgszAttributeArray[lIndex] = NULL;
    m_rgwszAttributeArray[lIndex] = NULL;
    //
    // Calc lengths
    //
    cchAttributeUTF8 = lstrlen(pszAttribute) + 1;
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszAttribute,
        cchAttributeUTF8,
        NULL,
        0);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }
    m_rgwszAttributeArray[lIndex] = new WCHAR[i];
    if(m_rgwszAttributeArray[lIndex] == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // Convert
    //
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszAttribute,
        cchAttributeUTF8,
        m_rgwszAttributeArray[lIndex],
        i);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }

    m_rgszAttributeArray[lIndex] = new CHAR[lstrlen(pszAttribute) + 1];
    if(m_rgszAttributeArray[lIndex] == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    lstrcpy(m_rgszAttributeArray[lIndex], pszAttribute);

 CLEANUP:
    if(FAILED(hr)) {
        if(lIndex != -1) {
            if(m_rgszAttributeArray[lIndex]) {
                delete [] m_rgszAttributeArray[lIndex];
                m_rgszAttributeArray[lIndex] = NULL;
            }
            if(m_rgwszAttributeArray[lIndex]) {
                delete [] m_rgwszAttributeArray[lIndex];
                m_rgwszAttributeArray[lIndex] = NULL;
            }
            //
            // Obviously, this is not thread safe.
            //
            m_lNumberAttributes--;
            _ASSERT(lIndex == m_lNumberAttributes);
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: GetAllAttributes
//
// Synopsis: Retrieve pointer to the array of attributes
//
// Arguments:
//   pprgszAllAttributes: Ptr to ptr to recieve array of attributes
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980611 20:57:08: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerRequestedAttributesIMP::GetAllAttributes(
    LPTSTR **pprgszAllAttributes)
{
    _ASSERT(pprgszAllAttributes);
    *pprgszAllAttributes = m_rgszAttributeArray;
    return S_OK;
}
//
// Wide version of above
//
STDMETHODIMP CICategorizerRequestedAttributesIMP::GetAllAttributesW(
    LPWSTR **pprgszAllAttributes)
{
    _ASSERT(pprgszAllAttributes);
    *pprgszAllAttributes = m_rgwszAttributeArray;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\catcntrs\perfcat.cpp ===
/************************************************************
 * FILE: perfab.cpp
 * PURPOSE: This file implements Abook counters using the perfshar library
 * HISTORY:
 *   // t-JeffS 970810 18:24:07: Created
 ************************************************************/

#include "perfcc.h"
#include "sym.h"

// I am doing this because I can't seem to export
// functions from my DLL that were linked in from a static library.
#include "perfskel.cpp"


// t-JeffS 970811 12:42:39: For reference, here is the perf object
// type definition cut+pasted from winperf.h

#ifdef FOR_REFERENCE_FROM_WINPERF_H
//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
#ifdef _WIN64
    DWORD           ObjectNameTitle;
#else
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
#ifdef _WIN64
    DWORD           ObjectHelpTitle;
#else
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)

#endif //FOR_REFERENCE_FROM_WINPERF_H

// Basic definition block to use
CATPERF_DATA_DEFINITION g_DataDef = {
	{
		sizeof(CATPERF_DATA_DEFINITION) + SIZE_OF_CAT_PERFORMANCE_DATA,
		sizeof(CATPERF_DATA_DEFINITION),
		sizeof(PERF_OBJECT_TYPE),
		CATOBJ, // readjusted at runtime
		0,
		CATOBJ, // readjusted at runtime
		0,
		PERF_DETAIL_NOVICE,
        NUM_COUNTERS,
		1,
		PERF_NO_INSTANCES,
		0
	},

// t-JeffS 970811 12:43:46: For reference, I've cut+pasted the counter
// definition struct from winldap.h here.

#ifdef FOR_REFERENCE_FROM_WINLDAP_H
//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//

typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterNameTitle;
#else
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterHelpTitle;
#else
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

#endif //FOR_REFERENCEFROM_WINDLAP_H

   {
	{
		sizeof(PERF_COUNTER_DEFINITION),
		CAT_SUBMITTED,
		0,
		CAT_SUBMITTED,
		0,
		-2, // Default scale 1
		PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
		CATPERF_SUBMITTED_OFFSET
	},
	{	sizeof(PERF_COUNTER_DEFINITION),
		CAT_SUBMITTEDPERSEC,
		0,
        CAT_SUBMITTEDPERSEC,
		0,
		0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
        CATPERF_SUBMITTED_OFFSET // Can use same offset as rawcount
                                 // instead of our assigned space
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
		CAT_SUBMITTEDOK,
		0,
		CAT_SUBMITTEDOK,
		0,
		-2, // Default scale: 1
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
		CATPERF_SUBMITTEDOK_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_SUBMITTEDFAILED,
		0,
        CAT_SUBMITTEDFAILED,
		0,
		0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_SUBMITTEDFAILED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
		CAT_SUBMITTEDUSERSOK,
		0,
        CAT_SUBMITTEDUSERSOK,
		0,
		-2, // Default scale: 1
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_SUBMITTEDUSERSOK_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZED,
		0,
        CAT_CATEGORIZED,
		0,
		-2,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_CATEGORIZED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDPERSEC,
		0,
        CAT_CATEGORIZEDPERSEC,
		0,
        0, // Default scale: 1
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
        CATPERF_CATEGORIZED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDSUCCESS,
		0,
        CAT_CATEGORIZEDSUCCESS,
		0,
		-2,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDSUCCESS_OFFSET,
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDSUCCESSPERSEC,
		0,
        CAT_CATEGORIZEDSUCCESSPERSEC,
		0,
		0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDSUCCESS_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDUNRESOLVED,
		0,
        CAT_CATEGORIZEDUNRESOLVED,
		0,
		0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDUNRESOLVED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDUNRESOLVEDPERSEC,
		0,
        CAT_CATEGORIZEDUNRESOLVEDPERSEC,
		0,
		-2,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDUNRESOLVED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDFAILED,
		0,
        CAT_CATEGORIZEDFAILED,
		0,
		0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDFAILED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDFAILEDPERSEC,
		0,
        CAT_CATEGORIZEDFAILEDPERSEC,
		0,
        0,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_COUNTER,
		sizeof(DWORD),
        CATPERF_CATEGORIZEDFAILED_OFFSET
	},
	{
		sizeof(PERF_COUNTER_DEFINITION),
        CAT_CATEGORIZEDUSERS,
		0,
        CAT_CATEGORIZEDUSERS,
		0,
		-2,
		PERF_DETAIL_NOVICE,
		PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD),
		CATPERF_CATEGORIZEDUSERS_OFFSET
	},
    {
       sizeof(PERF_COUNTER_DEFINITION),
       CAT_CATEGORIZEDUSERSPERSEC,
       0,
       CAT_CATEGORIZEDUSERSPERSEC,
       0,
       0, // Default scale: .01
       PERF_DETAIL_NOVICE,
       PERF_COUNTER_COUNTER,
       sizeof(DWORD),
       CATPERF_CATEGORIZEDUSERS_OFFSET
    },
    {
       sizeof(PERF_COUNTER_DEFINITION),
       CAT_OUTSTANDINGMSGS,
       0,
       CAT_OUTSTANDINGMSGS,
       0,
       0, // Default scale: 1
       PERF_DETAIL_NOVICE,
       PERF_COUNTER_RAWCOUNT,
       sizeof(DWORD),
       CATPERF_OUTSTANDINGMSGS_OFFSET
    }
   }
};

///////////////////////////////////////////////////////////////////////////////
// 	
//	Function:		DllEntryPoint()
// 
//	Description:	This is the DLL entry point.  Here is where we call Initialize on g_cperfman
// 
//	Parameters:		hInstance - Handle to the instance of the process that
//								called this function.
//					fdwReason - Reason why the process called this function (load/unload/etc)
//					lbvReserved - not used.
//
//	History: // t-JeffS 970801 19:57:23: Created
///////////////////////////////////////////////////////////////////////////////

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD fdwReason, LPVOID lbvReserved)
{
	
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH :
           g_cperfman.Initialize(SZ_APPNAME, &g_DataDef, NUM_COUNTERS);
           break;
			
		case DLL_PROCESS_DETACH :
           break;
			
		default:
           break;	
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\registry.h ===
//+------------------------------------------------------------
//
// File: registry.h -- copied from "Inside COM" by Dale Rogerson
//       Chapter 7 sample code, a Microsoft Press book.
//
// History:
// jstamerj 1998/12/12 23:26:48: Copied.
//
//-------------------------------------------------------------
#ifndef __Registry_H__
#define __Registry_H__
#include <windows.h>

//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\catcntrs\perfcc.h ===
/*++
	Header file for CatCons extensible object data definitions

	This file contains definitions to construct the dynamic
	data which is returned by the configuration registry.
--*/

#ifndef _DATAAB_H_
#define _DATAABH_

#include <windows.h>
#include <winperf.h>

#pragma pack(4)


// t-JeffS 970811 11:03:39: These indexes will be used by the abook
// side only to set shared memory values
#define CATPERF_SUBMITTED_NDX                       0
#define CATPERF_SUBMITTED_OFFSET                    sizeof(DWORD)
#define CATPERF_SUBMITTEDPERSEC_NDX                 1
#define CATPERF_SUBMITTEDPERSEC_OFFSET              2*sizeof(DWORD)
#define CATPERF_SUBMITTEDOK_NDX                     2
#define CATPERF_SUBMITTEDOK_OFFSET                  3*sizeof(DWORD)
#define CATPERF_SUBMITTEDFAILED_NDX                 3
#define CATPERF_SUBMITTEDFAILED_OFFSET              4*sizeof(DWORD)
#define CATPERF_SUBMITTEDUSERSOK_NDX                4
#define CATPERF_SUBMITTEDUSERSOK_OFFSET             5*sizeof(DWORD)
#define CATPERF_CATEGORIZED_NDX                     5
#define CATPERF_CATEGORIZED_OFFSET                  6*sizeof(DWORD)
#define CATPERF_CATEGORIZEDPERSEC_NDX               6
#define CATPERF_CATEGORIZEDPERSEC_OFFSET            7*sizeof(DWORD)
#define CATPERF_CATEGORIZEDSUCCESS_NDX              7
#define CATPERF_CATEGORIZEDSUCCESS_OFFSET           8*sizeof(DWORD)
#define CATPERF_CATEGORIZEDSUCCESSPERSEC_NDX        8
#define CATPERF_CATEGORIZEDSUCCESSPERSEC_OFFSET     9*sizeof(DWORD
#define CATPERF_CATEGORIZEDUNRESOLVED_NDX           9
#define CATPERF_CATEGORIZEDUNRESOLVED_OFFSET        10*sizeof(DWORD)
#define CATPERF_CATEGORIZEDUNRESOLVEDPERSEC_NDX     10
#define CATPERF_CATEGORIZEDUNRESOLVEDPERSEC_OFFSET  11*sizeof(DWORD)
#define CATPERF_CATEGORIZEDFAILED_NDX               11
#define CATPERF_CATEGORIZEDFAILED_OFFSET            12*sizeof(DWORD)
#define CATPERF_CATEGORIZEDFAILEDPERSEC_NDX         12
#define CATPERF_CATEGORIZEDFAILEDPERSEC_OFFSET      13*sizeof(DWORD)
#define CATPERF_CATEGORIZEDUSERS_NDX                13
#define CATPERF_CATEGORIZEDUSERS_OFFSET             14*sizeof(DWORD)
#define CATPERF_CATEGORIZEDUSERSPERSEC_NDX          14
#define CATPERF_CATEGORIZEDUSERSPERSEC_OFFSET       15*sizeof(DWORD)
#define CATPERF_OUTSTANDINGMSGS_NDX                 15
#define CATPERF_OUTSTANDINGMSGS_OFFSET              16*sizeof(DWORD)
#define NUMBER_OF_CAT_COUNTERS                      16
#define SIZE_OF_CAT_PERFORMANCE_DATA				17*sizeof(DWORD)


//
// This is the counter structure returned by AB
//
typedef struct _CATPERF_DATA_DEFINITION {
	PERF_OBJECT_TYPE		CatObjType;
	PERF_COUNTER_DEFINITION	CAT_Counter_Definitions[NUMBER_OF_CAT_COUNTERS];
}	CATPERF_DATA_DEFINITION, *PCATPERF_DATA_DEFINITION;

#define SZ_APPNAME "CatCons"
#define NUM_COUNTERS NUMBER_OF_CAT_COUNTERS

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\registry.cpp ===
//+------------------------------------------------------------
//
// File: registry.cpp -- copied from "Inside COM" by Dale Rogerson
//       Chapter 7 sample code, a Microsoft Press book.
//
// History:
// jstamerj 1998/12/12 23:25:11: Copied.
//
//-------------------------------------------------------------


#include "precomp.h"
#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue,
                    const char* szName = NULL) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, "InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, "InprocServer32", "Free", "ThreadingModel") ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue,
                    const char* szName)
{
	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szName, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\catcntrs\sym.h ===
/*++
	Offset definition file for extensible counter objects
	and counters.

	This file is used by the extensible counter DLL code
	as well as the counter name and Explain test definition
	file (.ini) file that is used by lodctr to load the names
	into the registry.
--*/

#define CATOBJ 0
#define CAT_SUBMITTED                       2
#define CAT_SUBMITTEDPERSEC                 4
#define CAT_SUBMITTEDOK                     6
#define CAT_SUBMITTEDFAILED                 8
#define CAT_SUBMITTEDUSERSOK                10
#define CAT_CATEGORIZED                     12
#define CAT_CATEGORIZEDPERSEC               14
#define CAT_CATEGORIZEDSUCCESS              16
#define CAT_CATEGORIZEDSUCCESSPERSEC        18
#define CAT_CATEGORIZEDUNRESOLVED           20
#define CAT_CATEGORIZEDUNRESOLVEDPERSEC     22
#define CAT_CATEGORIZEDFAILED               24
#define CAT_CATEGORIZEDFAILEDPERSEC         26
#define CAT_CATEGORIZEDUSERS                28
#define CAT_CATEGORIZEDUSERSPERSEC          30
#define CAT_OUTSTANDINGMSGS                 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\catcntrs\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\setup\catsetup.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catsetup.cpp
//
// Contents: Setup program for categorizer unit test
//
// Classes:
//
// Functions:
//   main
//
// History:
// jstamerj 980416 08:36:36: Created.
//
//-------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dsgetdc.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <transmem.h>
#include "ldaptest.h"
#include "catsetup.h"

/************************************************************
  Globals
 ************************************************************/
HANDLE g_hTransHeap; // For transmem


//+------------------------------------------------------------
//
// Function: main
//
// Synopsis: THE entry point
//
// Arguments: standard argc/argv
//
// Returns:
//  0: success
//  1: failure
//
// History:
// jstamerj 980416 08:37:23: Created.
//
//-------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    DWORD dw;
    PDOMAIN_CONTROLLER_INFO pdci;
    LPTSTR pszDC;
    PLDAP pldap;
    int i, j;
    long lNumUsers = 0;
    TCHAR szNamingContext[MAX_DN_SIZE];

    TrHeapCreate();

    if(argc == 1) {
        lNumUsers = DEFAULT_NUM_USERS;
    } else if(argc == 2) {
        lNumUsers = atol(argv[1]);
    }

    if(lNumUsers <= 0) {
        OutputStuff(0, "Usage: %s <number of users (default: %ld)>",
                argv[0], DEFAULT_NUM_USERS);
        return 1;
    }


    //
    // Setting categorizer registry entries
    //
    HRESULT hr;
    OutputStuff(5, "Setting up categorizer registry entries...");
    hr = SetupRegistry(pszDC);
    if(FAILED(hr)) {
        OutputStuff(0, "Error setting registry entries hr %08lx\n", hr);
    } else {
        OutputStuff(5, "Done.\n");
    }


    OutputStuff(5, "Attempting to locate domain controller...");

    dw = DsGetDcName(
        NULL,   // Computer name
        NULL,   // Domain name
        NULL,   // Domain GUID,
        NULL,   // Sitename
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_WRITABLE_REQUIRED,
        &pdci);

    if(dw != NO_ERROR) {
        OutputStuff(0, "\nUnable to find DC for this domain:\n"
                    "  DsGetDcName returned error %ld (0x%08lx)\n",
                    dw, dw);
        return 1;
    } else {
        // Strip off the leading backslash backslash
        if(strncmp(pdci->DomainControllerName, "\\\\", 2) == 0) {
            pszDC = pdci->DomainControllerName + 2;
        } else {
            pszDC = pdci->DomainControllerName;
        }
        OutputStuff(5, "Done\n"
                    "Found domain controller \"%s\"\n",
                    pszDC);
    }
    //
    // Attempt connection to this server
    //
    OutputStuff(5, "Attempting to connect to directory server (LDAP)...");
    fflush(stdout);
    pldap = BindToLdapServer(pszDC);
    NetApiBufferFree(pdci);
    if(pldap == NULL) {
        OutputStuff(0, "\nError binding to ldap server.\n");
        return 1;
    }  else {
        OutputStuff(5, "Done.\n");
    }

    OutputStuff(5, "Retreiving base DN...\n");

    i = GetNamingContextDN(pldap, szNamingContext);
    if(i != LDAP_SUCCESS) {
        OutputStuff(0, "\nError retreiving defaultNamingContext %d (0x%08x)\n", i, i);
        return 1;
    } else {
        OutputStuff(5, "Done.\nDefault naming context: \"%s\"\n",
                    szNamingContext);
    }

    OutputStuff(7, "Createing a container CatPerf...\n");

    i = CreateContainer(pldap, CATCONTAINERDN, szNamingContext);
    if(i == LDAP_ALREADY_EXISTS) {
        OutputStuff(7, "Already Done.\n");
    } else if(i != LDAP_SUCCESS) {
        OutputStuff(0, "\nError creating container: %d (0x%08x)\n", i, i);
        return 1;
    } else {
        OutputStuff(7, "Done.\n");
    }


    //
    // Create a distribution list
    //
    OutputStuff(7, "Createing group distribution list...");
    
    i = CreateCatDL(pldap, CATGROUPDL, szNamingContext);
    if(i == LDAP_ALREADY_EXISTS) {
        OutputStuff(7, "Already Done.\n");
    } else if(i != NO_ERROR) {
        OutputStuff(0, "\nError createing group DL: %d (0x%08x)\n", i, i);
        return 1;
    } else {
        OutputStuff(7, "Done.\n");
    }
    
    //
    // Create a distribution list
    //
    OutputStuff(7, "Createing group distribution list...");
    
    i = CreateCatDL(pldap, CATGROUP100DL, szNamingContext);
    if(i == LDAP_ALREADY_EXISTS) {
        OutputStuff(7, "Already Done.\n");
    } else if(i != NO_ERROR) {
        OutputStuff(0, "\nError createing group DL: %d (0x%08x)\n", i, i);
        return 1;
    } else {
        OutputStuff(7, "Done.\n");
    }
    
    //
    // Create all of our users
    //
    OutputStuff(7, "Creating %ld users.\n", lNumUsers);
    for(i = 0; i < lNumUsers; i++) {
        TCHAR szUser[MAX_DN_SIZE];
        BOOL fAlreadyExists = FALSE;

        sprintf(szUser, "CatUser%06ld", i);
        OutputStuff(7, "Adding user %d...", i);

        j = CreateCatUser(pldap, szUser, szNamingContext);
        if(j == LDAP_ALREADY_EXISTS) {
            OutputStuff(7, "Already Done\n");
            fAlreadyExists = TRUE;
        } else if(j != NO_ERROR) {
            OutputStuff(0, "\nError adding user: %d (0x%08x)\n", j, j);
            return 1;
        } else {
            OutputStuff(7, "Done.\n");
        }

        OutputStuff(7, "Adding user %d to group DL...", i);
        j = AddToDistList(pldap, CATGROUPDL, szUser, szNamingContext);
        if(fAlreadyExists && (j == LDAP_CONSTRAINT_VIOLATION)) {
            OutputStuff(7, "Already Done\n");
        } else if(j != NO_ERROR) {
            OutputStuff(0, "\nError adding user to DL: %d (0x%08x)\n", j, j);
            return 1;
        } else {
            OutputStuff(7, "Done.\n");
        }
            
        if(i < 100) {
            OutputStuff(7, "Adding user %d to group 100 DL...", i);
            j = AddToDistList(pldap, CATGROUP100DL, szUser, szNamingContext);
            if(fAlreadyExists && (j == LDAP_CONSTRAINT_VIOLATION)) {
                OutputStuff(7, "Already Done\n");
            } else if(j != NO_ERROR) {
                OutputStuff(0, "\nError adding user to DL: %d (0x%08x)\n", j, j);
                return 1;
            } else {
                OutputStuff(7, "Done.\n");
            }
        }
    }
    
    OutputStuff(5, "Finished adding users.  Closing connection...");
    CloseLdapConnection(pldap);
    OutputStuff(5, "Done.\n");

    TrHeapDestroy();
    return 0;
}

int CreateContainer(PLDAP pldap, LPTSTR pszDN, LPTSTR pszBaseDN)
{
    LPTSTR args[3];
    TCHAR  szCN[MAX_DN_SIZE];
    TCHAR  szDN[MAX_DN_SIZE];

    sprintf(szDN, "%s,%s", pszDN, pszBaseDN);

    strncpy(szCN, pszDN, MAX_DN_SIZE);
    strtok(szCN, ",");

    args[0] = szDN;
    args[1] = SCHEMA_CONTAINER;
    args[2] = szCN;

    return AddObject(pldap, 3, args);
}

int CreateCatUser(PLDAP pldap, LPTSTR pszUser, LPTSTR pszBaseDN)
{
    LPTSTR args[9];
    TCHAR szDN[MAX_DN_SIZE];
    TCHAR szCN[MAX_DN_SIZE];
    TCHAR szMail[MAX_DN_SIZE];
    TCHAR szProxy[MAX_DN_SIZE];
    TCHAR szsAMAccountName[MAX_DN_SIZE];
    TCHAR szuserAccountControl[MAX_DN_SIZE];
    TCHAR szpwdLastSet[MAX_DN_SIZE];
    TCHAR szmailnickname[MAX_DN_SIZE];
    TCHAR szlegacyExchangeDN[MAX_DN_SIZE];


#ifdef GUESS_ORG
    TCHAR szOrg[MAX_DN_SIZE];
    // jstamerj 980416 11:28:55: Anyone know how to use strnicmp?
    if((strncmp(pszBaseDN, "dc=", 3) == 0) ||
       (strncmp(pszBaseDN, "DC=", 3) == 0)) {
        LPTSTR ptrDest = szOrg;
        LPTSTR ptrSrc = pszBaseDN + 3;
        while((*ptrSrc) && (*ptrSrc != ',')) {
            *ptrSrc++ = *ptrDest++;
        }
        *ptrDest = '\0';
    } else {
        lstrcpy(szOrg, DEFAULTORG);
    }
#endif

    sprintf(szDN, "cn=%s,%s,%s", pszUser, CATCONTAINERDN, pszBaseDN);
    sprintf(szCN, "cn=%s", pszUser);
    sprintf(szMail, "mail=%s@%s", pszUser, CATSMTPDOMAIN);
    sprintf(szProxy, "ProxyAddresses=SMTP:%s@%s", pszUser, CATSMTPDOMAIN);
    sprintf(szsAMAccountName, "sAMAccountName=%s", pszUser);
    sprintf(szuserAccountControl, "userAccountControl=66080");
    sprintf(szpwdLastSet, "pwdLastSet=-1");
    sprintf(szlegacyExchangeDN, "legacyExchangeDN=/o=%s/ou=FirstSite/cn=Recipients/cn=%s",
#ifdef GUESS_ORG
            szOrg,
#else
            DEFAULTORG,
#endif
            pszUser);

    
    args[0] = szDN;
    args[1] = SCHEMA_USER;
    args[2] = szCN;
    args[3] = szMail;
    args[4] = szProxy;
    args[5] = szsAMAccountName;
    args[6] = szuserAccountControl;
    args[7] = szpwdLastSet;
    args[8] = szlegacyExchangeDN;

    return AddObject(pldap, 9, args);
}

int CreateCatDL(PLDAP pldap, LPTSTR pszName, LPTSTR pszBaseDN)
{
    LPTSTR args[8];
    TCHAR szDN[MAX_DN_SIZE];
    TCHAR szCN[MAX_DN_SIZE];
    TCHAR szMail[MAX_DN_SIZE];
    TCHAR szProxy[MAX_DN_SIZE];
    TCHAR szsAMAccountName[MAX_DN_SIZE];
    TCHAR szlegacyExchangeDN[MAX_DN_SIZE];
    TCHAR szGroupType[MAX_DN_SIZE];

#ifdef GUESS_ORG
    TCHAR szOrg[MAX_DN_SIZE];
    // jstamerj 980416 11:29:37: Anyone know how to use strnicmp?
    if((strncmp(pszBaseDN, "dc=", 3) == 0) ||
       (strncmp(pszBaseDN, "DC=", 3) == 0)) {
        LPTSTR ptrDest = szOrg;
        LPTSTR ptrSrc = pszBaseDN + 3;
        while((*ptrSrc) && (*ptrSrc != ',')) {
            *ptrSrc++ = *ptrDest++;
        }
        *ptrDest = '\0';
    } else {
        lstrcpy(szOrg, DEFAULTORG);
    }
#endif

    sprintf(szDN, "cn=%s,%s,%s", pszName, CATCONTAINERDN, pszBaseDN);
    sprintf(szCN, "cn=%s", pszName);
    sprintf(szMail, "mail=%s@%s", pszName, CATSMTPDOMAIN);
    sprintf(szProxy, "ProxyAddresses=SMTP:%s@%s", pszName, CATSMTPDOMAIN);
    sprintf(szsAMAccountName, "sAMAccountName=%s", pszName);
    sprintf(szlegacyExchangeDN, "legacyExchangeDN=/o=%s/ou=FirstSite/cn=Recipients/cn=%s",
#ifdef GUESS_ORG
            szOrg,
#else
            DEFAULTORG,
#endif
            pszName);
    sprintf(szGroupType, "groupType=-2147483644");
    
    args[0] = szDN;
    args[1] = SCHEMA_GROUP;
    args[2] = szCN;
    args[3] = szMail;
    args[4] = szProxy;
    args[5] = szsAMAccountName;
    args[6] = szlegacyExchangeDN;
    args[7] = szGroupType;
    return AddObject(pldap, 8, args);
}    

int AddToDistList(PLDAP pldap, LPTSTR pszDLName, LPTSTR pszUser, LPTSTR pszBaseDN)
{
    LPTSTR args[2];
    TCHAR szDLDN[MAX_DN_SIZE];
    TCHAR szUserDN[MAX_DN_SIZE];

    sprintf(szDLDN, "cn=%s,%s,%s", pszDLName, CATCONTAINERDN, pszBaseDN);
    sprintf(szUserDN, "member=cn=%s,%s,%s", pszUser, CATCONTAINERDN, pszBaseDN);

    args[0] = szDLDN;
    args[1] = szUserDN;
    return AddObjectAttribute(pldap, 2, args);
}

HRESULT SetupRegistry(LPTSTR pszHost)
{
    HKEY hKeyServices, hKeyPlatinumIMC, hKeyCatSources, hKeyCatSources1;
    LONG lRet;
    lRet = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Services",
        &hKeyServices);

    if(lRet != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRet);
    }

    lRet = RegCreateKey(
        hKeyServices,
        "PlatinumIMC",
        &hKeyPlatinumIMC);
    if(lRet == ERROR_FILE_EXISTS) {
        lRet = RegOpenKey(
            hKeyServices,
            "PlatinumIMC",
            &hKeyPlatinumIMC);
    }
    RegCloseKey(hKeyServices);
    if(lRet != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRet);
    }


    lRet = RegCreateKey(
        hKeyPlatinumIMC,
        "CatSources",
        &hKeyCatSources);
    if(lRet == ERROR_FILE_EXISTS) {
        lRet = RegOpenKey(
            hKeyPlatinumIMC,
            "CatSources",
            &hKeyCatSources);
    }
    RegCloseKey(hKeyPlatinumIMC);
    if(lRet != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRet);
    }

    lRet = RegCreateKey(
        hKeyCatSources,
        "1",
        &hKeyCatSources1);
    if(lRet == ERROR_FILE_EXISTS) {
        lRet = RegOpenKey(
            hKeyCatSources,
            "1",
            &hKeyCatSources1);
    }
    RegCloseKey(hKeyCatSources);
    if(lRet != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRet);
    }

    lRet = RegDeleteValue(
        hKeyCatSources1,
        "Host");
    if((lRet != ERROR_SUCCESS) && (lRet != ERROR_FILE_NOT_FOUND)) {
        return HRESULT_FROM_WIN32(lRet);
    }

    lRet = RegDeleteValue(
        hKeyCatSources1,
        "Bind");
    if((lRet != ERROR_SUCCESS) && (lRet != ERROR_FILE_NOT_FOUND)) {
        return HRESULT_FROM_WIN32(lRet);
    }

    lRet = RegSetValueEx(
        hKeyCatSources1,
        "Host",
        0L,
        REG_SZ,
        (CONST BYTE *)pszHost,
        (lstrlen(pszHost)+1) * sizeof(TCHAR));
    if(lRet != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRet);

    lRet = RegSetValueEx(
        hKeyCatSources1,
        "Bind",
        0L,
        REG_SZ,
        (CONST BYTE *)CATBINDTYPE,
        sizeof(CATBINDTYPE));
    RegCloseKey(hKeyCatSources1);
    return HRESULT_FROM_WIN32(lRet);
}

DWORD g_dwDebugOutLevel = 0;

//+------------------------------------------------------------
//
// Function: OutputStuff
//
// Synopsis: Print out a debug string if dwLevel <= g_dwDebugOutLevel
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/21 19:33:49: Created.
//
//-------------------------------------------------------------
VOID OutputStuff(DWORD dwLevel, char *szFormat, ...)
{
    if(dwLevel <= g_dwDebugOutLevel) {
        va_list ap;
        va_start(ap, szFormat);

        vfprintf(stdout, szFormat, ap);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\catcons.cpp ===
#include "catcons.h"
#include "aqueue.h"
#include "ismtpsvr.h"
#include "mailmsg_i.c"
#include "ccdomain.h"

HANDLE g_hTransHeap = NULL;
CSharedMem  g_cPerfMem;
DWORD g_dwDebugOutLevel = 9;

int __cdecl main(int argc, char **argv)
{
  COMMANDLINE cl;
  PHANDLE rgThreads;
  HRESULT hr;

  // jstamerj 980218 17:31:19: Traceing support.
  InitAsyncTrace();

  TraceFunctEnter("main");

  hr = CoInitialize(NULL);
  if(FAILED(hr))
    {
      OutputStuff(1,"CoInitialize failed - 0x%08lx\n", hr);
      return 1;
    }

  // Initialize transmem
  if(!TrHeapCreate())
    {
      OutputStuff(1, "TrHeapCreate() failed\n");
    }

  if(!ParseCommandLineInfo(argc, argv, &cl))
    {
      ShowUsage();
      return 1;
    }

  if(! g_cPerfMem.Initialize( SZ_APPNAME, FALSE, NUM_COUNTERS * sizeof(DWORD)))
    {
      OutputStuff(1, "Perf initialization failed!\n");
      return 1;
    }

  //
  // Reset perf counters always
  //
  g_cPerfMem.Zero();

  rgThreads = new HANDLE[cl.lThreads];
  if(rgThreads == NULL) {
      OutputStuff(1, "memalloc failed for rgThreads\n");
      return 1;
  }

  CISMTPServerIMP *pISMTPServer;
  pISMTPServer = new CISMTPServerIMP();
  if(pISMTPServer == NULL) {
      OutputStuff(1, "alloc failed for CISMTPServerIMP\n");
      return 1;
  }
  //
  // Initialize CISMTPServer
  //
  hr = pISMTPServer->Init( cl.pszCatProgID );
  if(FAILED(hr)) {
      OutputStuff(1, "failed to create specified categorizer sink\n");
      return 1;
  }

  //
  // Explicity add a reference for ourself
  //
  pISMTPServer->AddRef();

  //
  // Create/Initialize a fake IAdvQueueDomainInfo
  //
  CDomainInfoIMP *pIDomainInfo;
  pIDomainInfo = new CDomainInfoIMP();
  if(pIDomainInfo == NULL) {
      OutputStuff(1, "alloc failed for CIDomainInfo\n");
      return 1;
  }

  pIDomainInfo->AddRef();
 

  // Signal categorizer to enable...
  AQConfigInfo AQConfig;
  SetAQConfigFromRegistry(&AQConfig);

  // Intialize categorizer
  hr = CatInit(&AQConfig, NULL, NULL, pISMTPServer, pIDomainInfo, 1, &cl.hCat);
  pISMTPServer->Release();
  pIDomainInfo->Release();
  FreeAQConfigInfo(&AQConfig);

  if(FAILED(hr)) {
      OutputStuff(1, "CatInit Failed!, error = %08lx\n", hr);
      return 1;
  }

  cl.lOutstandingRequests = 0;

  for(long lCount = 0; lCount < cl.lThreads; lCount++) {
      DWORD dwThreadID;
      rgThreads[lCount] = CreateThread(
          NULL,
          0,
          SubmitThread,
          (LPVOID)&cl,
          0,
          &dwThreadID);
      if(rgThreads[lCount] == NULL) {
          OutputStuff(1, "CreateThread failed, GetLastError() = %ld (0x%lx)\n",
                       GetLastError(), GetLastError());
          return 1;
      }
  }

  OutputStuff(5, "%ld submit threads created.  Beginning the test.\n", cl.lThreads);
  DebugTrace(NULL, "%ld submit threads created.  Beginning the test.", cl.lThreads);

  //
  // Wait for some thread to tell us all messages have been
  // categorized
  //
  WaitForSingleObject(cl.hShutdownEvent, INFINITE);
  DebugTrace(NULL, "Shutdown event set.  Waiting for all threads to exit.");
  OutputStuff(5, "Shutdown event set.  Waiting for all threads to exit.\n");
  
  //
  // Wait for all threads to exit
  //

  _VERIFY(WaitForMultipleObjects(cl.lThreads, rgThreads, TRUE, INFINITE) !=
          WAIT_FAILED);

  DebugTrace(NULL, "All threads exited.  Calling CatTerm.");
  OutputStuff(5, "All threads exited.  Calling CatTerm.\n");
  
  DebugTrace((LPARAM)cl.hCat, "Calling CatTerm");

  CatTerm(cl.hCat);

  PrintPerf(&(cl.cpi));

  delete rgThreads;
  FreeCommandLineInfo(&cl);

  if(!TrHeapDestroy())
    {
      OutputStuff(1, "TrHeapDestroy() failed\n");
    }
  TraceFunctLeave();

  return 0;
}

HRESULT CatCompletion(HRESULT hr, PVOID pContext, IUnknown *pImsg, IUnknown **rgpImsg)
{
  PCOMMANDLINE pcl = (PCOMMANDLINE)pContext;

  g_cPerfMem.IncrementDW(CATPERF_CATEGORIZED_NDX);
  g_cPerfMem.DecrementDW(CATPERF_OUTSTANDINGMSGS_NDX);

  if(hr == CAT_W_SOME_UNDELIVERABLE_MSGS) {
      OutputStuff(6, "Warning: CatCompletion called with CAT_W_SOME_UNDELIVERABLE_MSGS\n");
      g_cPerfMem.IncrementDW(CATPERF_CATEGORIZEDUNRESOLVED_NDX);
  } else if(FAILED(hr)) {
      OutputStuff(2, "Warning: CatCompletion called with error hr %08lx\n", hr);
      g_cPerfMem.IncrementDW(CATPERF_CATEGORIZEDFAILED_NDX);
      InterlockedIncrement(&(pcl->cpi.lFailures));
      _ASSERT(pcl->fNoAssert && "Message categorization failed.");
      pImsg->Release();
      goto CLEANUP;
  } else {
      OutputStuff(7, "CatCompletion called, hr = %08lx, pContext = %08lx, pImsg = %08lx, rgpImsg = %08lx\n", hr, pContext, pImsg, rgpImsg);
      g_cPerfMem.IncrementDW(CATPERF_CATEGORIZEDSUCCESS_NDX);
  }

  if(pImsg != NULL) {
      DWORD dwRecips;
      if(g_dwDebugOutLevel >= 7) {
          OutputStuff(7, "IMsg:\n");
          dwRecips = PrintRecips(pImsg) + 1;
      } else {
          IMailMsgRecipients *pRecips;
          hr = pImsg->QueryInterface(IID_IMailMsgRecipients,
                                     (LPVOID *)&pRecips);
          if(FAILED(hr)) {
              OutputStuff(2, "QI failed for IMailMsgRecipients, hr = %08x\n", hr);
              InterlockedIncrement(&(pcl->cpi.lFailures));
              _ASSERT(pcl->fNoAssert && "QI failed");
              dwRecips = 0;
          } else {
              hr = pRecips->Count(&dwRecips);
              pRecips->Release();
              dwRecips++; // Sender
          }
      }
      g_cPerfMem.ExchangeAddDW( CATPERF_CATEGORIZEDUSERS_NDX, dwRecips);

      if(pcl->fDelete) {
          // hr = pImsg->Delete();
          // if(FAILED(hr)) {
          // OutputString(stdout, "IMsg->Delete() failed, hr %08lx\n",
          // hr);
          // _ASSERT(pcl->fNoAssert && "IMsg->Delete failed");
          // }
      }
      pImsg->Release();
    }
  else
    {
      if(g_dwDebugOutLevel >= 7) {
          IUnknown **ppImsg = rgpImsg;
          DWORD dwCount = 0;
          while(*ppImsg) {
              OutputStuff(7, "Bifurcated IMsg %ld:\n", dwCount);
              PrintRecips(*ppImsg);
              (*ppImsg)->Release();
              ppImsg++;
              dwCount++;
          }
      }
    }

 CLEANUP:
  // Release outstanding request semaphore object
  _VERIFY(ReleaseSemaphore(pcl->hRequestSemaphore, 1, NULL));

  if(InterlockedDecrement(&(pcl->lOutstandingRequests)) == 0) {
      // The test is finished.  Save the time.
      pcl->cpi.dwFinishTime = GetTickCount();
      SetEvent(pcl->hShutdownEvent);
  }
  return S_OK;
}

DWORD PrintRecips(IUnknown *pImsg)
{
  IMailMsgRecipients *pRecips;
  HRESULT hr;

  hr = pImsg->QueryInterface(IID_IMailMsgRecipients,
                             (LPVOID *)&pRecips);
  if(FAILED(hr)) {
      OutputStuff(2, "QI failed for IMailMsgRecipients, hr = %08x\n",
                   hr);
      _ASSERT(0 && "QI failed");
  }
  
  DWORD dwRecips;
  hr = pRecips->Count(&dwRecips);
  if(FAILED(hr)) {
      OutputStuff(2, "pRecipList->Count failed, error %08lx\n", hr);
      _ASSERT(0 && "Count failed.");
      return 0;
  }
  for(DWORD dw = 0; dw < dwRecips; dw++) {
      OutputStuff(7, "\n\tReturned Recipient #%ld\n", dw+1);
      CHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];

      hr = pRecips->GetStringA(dw, IMMPID_RP_ADDRESS_SMTP,
                               CAT_MAX_INTERNAL_FULL_EMAIL, szAddress);
      if(hr == CAT_IMSG_E_PROPNOTFOUND) {
          OutputStuff(7, "\t\tSMTP: NONE\n");
      } else if(SUCCEEDED(hr)) {
          OutputStuff(7, "\t\tSMTP: %s\n", szAddress);
      } else {
          OutputStuff(7, "\t\tSMTP: ERROR\n");
          //_ASSERT(pcl->fNoAssert && "Error retrieving prop");
      }
      hr = pRecips->GetStringA(dw, IMMPID_RP_ADDRESS_X500,
                               CAT_MAX_INTERNAL_FULL_EMAIL, szAddress);
      if(hr == CAT_IMSG_E_PROPNOTFOUND) {
          OutputStuff(7, "\t\tX500: NONE\n");
      } else if(SUCCEEDED(hr)) {
          OutputStuff(7, "\t\tX500: %s\n", szAddress);
      } else {
          OutputStuff(7, "\t\tX500: ERROR\n");
          //_ASSERT(pcl->fNoAssert && "Error retrieving prop");
      }

      hr = pRecips->GetStringA(dw, IMMPID_RP_ADDRESS_X400,
                               CAT_MAX_INTERNAL_FULL_EMAIL, szAddress);
      if(hr == CAT_IMSG_E_PROPNOTFOUND) {
          OutputStuff(7, "\t\tX400: NONE\n");
      } else if(SUCCEEDED(hr)) {
          OutputStuff(7, "\t\tX400: %s\n", szAddress);
      } else {
          OutputStuff(7, "\t\tX400: ERROR\n");
          //_ASSERT(pcl->fNoAssert && "Error retrieving prop");
      }

      hr = pRecips->GetStringA(dw, IMMPID_RP_LEGACY_EX_DN,
                               CAT_MAX_INTERNAL_FULL_EMAIL, szAddress);
      if(hr == CAT_IMSG_E_PROPNOTFOUND) {
          OutputStuff(7, "\t\tLegacyEXDN: NONE\n");
      } else if(SUCCEEDED(hr)) {
          OutputStuff(7, "\t\tLegacyEXDN: %s\n", szAddress);
      } else {
          OutputStuff(7, "\t\tLegacyEXDN: ERROR\n");
          //_ASSERT(pcl->fNoAssert && "Error retrieving prop");
      }

      HRESULT hrRecipError;
      hr = pRecips->GetDWORD(dw, IMMPID_RP_ERROR_CODE, (PDWORD)&hrRecipError);
      if(SUCCEEDED(hr) && (hr != CAT_IMSG_E_PROPNOTFOUND)) {
          OutputStuff(7,"\t\tRP_ERROR_CODE property set to %08lx\n", hrRecipError);
      }
      hr = pRecips->GetStringA(dw, IMMPID_RP_ERROR_STRING, sizeof(szAddress), szAddress);
      if(SUCCEEDED(hr) && (hr != CAT_IMSG_E_PROPNOTFOUND)) {
          OutputStuff(7,"\t\tRP_ERROR_STRING property set to \"%s\"\n", szAddress);
      }
  }
  pRecips->Release();
  return dwRecips;
}


BOOL ParseCommandLineInfo(int argc, char **argv, PCOMMANDLINE pcl)
{

  if(!InitializeCL(pcl)) {
      return FALSE;
  }

  // Parse everything up to smtp addr
  int nArg = 1;
  while(nArg < argc)
    {
      if(argv[nArg][0] != '-')
        {
            PRECIPIENT pRecip = new RECIPIENT;
            InitializeListHead(&(pRecip->listhead_Addresses));
            InsertTailList(&(pcl->listhead_Recipients), &(pRecip->listentry));

            PADDRESS pAddr = new ADDRESS;
            InsertTailList(&(pRecip->listhead_Addresses), &(pAddr->listentry));
            pAddr->CAType = CAT_SMTP;
            lstrcpy(pAddr->szAddress, argv[nArg]);
            
            pcl->cpi.lRecipientsPerMessage++;
            nArg++;
        } else {
            switch(tolower(argv[nArg][1]))
                {
                 case 'a':
                 {
                     pcl->fNoAssert = FALSE;
                     nArg++;
                     break;
                 }
                 case 'c':
                 {
                     pcl->fPreCreate = TRUE;
                     nArg++;
                     break;
                 }
                 case 'd':
                 {
                     pcl->fDelete = FALSE;
                     nArg++;
                     break;
                 }
                 case 'f':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     _ASSERT(lstrlen(argv[nArg+1]) < CAT_MAX_INTERNAL_FULL_EMAIL);
                     lstrcpy(pcl->szSenderAddress,argv[nArg+1]);
                     nArg += 2;
                     break;
                     
                 case 'h':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     if( (pcl->dwSubmitDelay = atol(argv[nArg+1])) == 0) {
                         OutputStuff(1, "Invalid submit delay (\"%s\")\n",
                                 argv[nArg+1]);
                         return FALSE;
                     }
                     nArg += 2;
                     break;

                 case 'i':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     // Set # of iterations
                     if( (pcl->lIterations = atol(argv[nArg+1])) == 0)
                         {
                             OutputStuff(1, "Invalid number of iterations (\"%s\").\n",
                                     argv[nArg+1]);
                             return FALSE;
                         }
                     nArg += 2;
                     break;
                 case 'l':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     if(pcl->pszCatProgID) {
                         return FALSE;
                     }
                     pcl->pszCatProgID = new WCHAR[
                         lstrlen(argv[nArg+1]) + 1];
                     _ASSERT(pcl->pszCatProgID);
                     swprintf(pcl->pszCatProgID, L"%S", argv[nArg+1]);
                     nArg += 2;
                     break;


                 case 'm':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     // Set max outstanding requests
                     if( (pcl->lMaxOutstandingRequests = atol(argv[nArg+1])) ==
                         0)
                         {
                             OutputStuff(1, "Invalid number for MaxOutstaingRequests (\"%s\").\n",
                                     argv[nArg+1]);
                             return FALSE;
                         }
                     nArg += 2;
                     break;

                 case 'p':
                     // Prompt
                     pcl->fPrompt = TRUE;
                     nArg += 1;
                     break;

                 case 'r':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     // Random generation
                     if( (pcl->dwRandom = atol(argv[nArg+1])) == 0) {
                         OutputStuff(1, "Invalid random range (\"%s\")\n",
                                 argv[nArg+1]);
                         return FALSE;
                     }
                     nArg += 2;
                     break;

                 case 's':
                     // Set verbose level
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     g_dwDebugOutLevel = atol(argv[nArg+1]);
                     nArg += 2;
                     break;

                 case 't':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     if( (pcl->lThreads = atol(argv[nArg+1])) == 0) {
                         OutputStuff(1, "Invalid number of threads (\"%s\")\n", argv[nArg+1]);
                         return FALSE;
                     }
                     nArg += 2;
                     break;

                 case 'v':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     delete pcl->pszIMsgProgID;
                     pcl->pszIMsgProgID = new WCHAR[
                         lstrlen(argv[nArg+1]) + 1];
                     _ASSERT(pcl->pszIMsgProgID);
                     swprintf(pcl->pszIMsgProgID, L"%S", argv[nArg+1]);
                     nArg += 2;
                     break;
                     
                 case 'w':
                     if((nArg + 2) > argc) {
                         return FALSE;
                     }
                     if( (pcl->dwStartingDelay = (atol(argv[nArg+1]) * 1000)) == 0) {
                         OutputStuff(1, "Invalid starting delay (\"%s\")\n",
                                 argv[nArg+1]);
                         return FALSE;
                     }
                     nArg += 2;
                     break;

                 default:
                     // Unknown option
                     OutputStuff(1, "Unknown option (\"%s\").\n", argv[nArg]);
                     return FALSE;
                }
        }
    }
  if(nArg > argc)
    return FALSE;

  pcl->hRequestSemaphore = CreateSemaphore(NULL,
                                           pcl->lMaxOutstandingRequests,
                                           pcl->lMaxOutstandingRequests,
                                           NULL);
  if(pcl->fPrompt)
      return ParseInteractiveInfo(pcl);
  return TRUE;
}

BOOL ParseInteractiveInfo(PCOMMANDLINE pcl)
{
    CHAR szType[CAT_MAX_ADDRESS_TYPE_STRING];

    OutputStuff(2,"\n------------------------------------------------------------");
    OutputStuff(2,"\n                           Sender:");
    OutputStuff(2,"\n------------------------------------------------------------\n");
    pcl->CATSender = CAT_UNKNOWNTYPE;
    while(pcl->CATSender == CAT_UNKNOWNTYPE) {
        OutputStuff(2,"Enter the sender's address type (SMTP, X500, X400, or LegacyEXDN): ");
        while(gets(szType) && (!(*szType))) {
            OutputStuff(2,"\nI SAID ENTER THE FRIGGIN' SENDER ADDRESS TYPE NOW!: ");
        }
        pcl->CATSender = CATypeFromString(szType);
    }

    OutputStuff(2,"\nEnter the sender's adddress: ");
    while(gets(pcl->szSenderAddress) && (!(*(pcl->szSenderAddress)))) {
        OutputStuff(2,"\nI SAID ENTER THE FRIGGIN' SENDER ADDRESS NOW!: ");
    }
    

    BOOL fMoreRecipients = TRUE;
    DWORD dwRecipNum = 1;
    while(fMoreRecipients) {
        OutputStuff(2,"\n------------------------------------------------------------");
        OutputStuff(2,"\n                    Recipient #%ld", dwRecipNum);
        OutputStuff(2,"\n------------------------------------------------------------\n");

        BOOL fMoreAddresses = TRUE;
        PRECIPIENT pRecip = NULL;

        while(fMoreAddresses) {
            PADDRESS pAddr;
            OutputStuff(2,"Enter an address type for this recipient (SMTP, X500, X400, or LegacyEXDN): ");
            if(gets(szType) && *szType) {
                if(pRecip == NULL) {
                    pRecip = new RECIPIENT;
                    InitializeListHead(&(pRecip->listhead_Addresses));
                    InsertTailList(&(pcl->listhead_Recipients),
                                   &(pRecip->listentry));
                    pcl->cpi.lRecipientsPerMessage++;
                }
                pAddr = new ADDRESS;
                pAddr->CAType = CATypeFromString(szType);
                if(pAddr->CAType == CAT_UNKNOWNTYPE) {
                    OutputStuff(2,"\nUnknown address type\n");
                    delete pAddr;
                } else {
                    OutputStuff(2,"\nEnter the address: ");
                    while(gets(pAddr->szAddress) && (!(*(pAddr->szAddress)))) {
                        OutputStuff(2,"\nI SAID, ENTER THE FRIGGIN' ADDRESS!  NOW!: ");
                    }
                    InsertTailList(&(pRecip->listhead_Addresses), &(pAddr->listentry));
                }
            } else {
                // Scan of type failed.  Assume user is done typing addresses for this recipient
                fMoreAddresses = FALSE;
                if(pRecip == NULL)
                    // Recip with no addresses?  Assume user is done entering recipients
                    fMoreRecipients = FALSE;
            }
        }
        dwRecipNum++;
    }
    OutputStuff(2,"\n");
    return TRUE;
}

CAT_ADDRESS_TYPE CATypeFromString(LPTSTR szType)
{
    if(lstrcmpi(szType, RP_ADDRESS_TYPE_SMTP) == 0) {
        return CAT_SMTP;
    } else if(lstrcmpi(szType, "X500") == 0) {
        return CAT_X500;
    } else if(lstrcmpi(szType, RP_ADDRESS_TYPE_X400) == 0) {
        return CAT_X400;
    } else if(lstrcmpi(szType, RP_ADDRESS_TYPE_LEGACY_EX_DN) == 0) {
        return CAT_LEGACYEXDN;
    } else {
        return CAT_UNKNOWNTYPE;
    }
}

LPCSTR SzTypeFromCAType(CAT_ADDRESS_TYPE CAType)
{
    if(CAType == CAT_SMTP) {
        return RP_ADDRESS_TYPE_SMTP;
    } else if(CAType == CAT_X500) {
        return RP_ADDRESS_TYPE_X500;
    } else if(CAType == CAT_X400) {
        return RP_ADDRESS_TYPE_X400;
    } else if(CAType == CAT_LEGACYEXDN) {
        return RP_ADDRESS_TYPE_LEGACY_EX_DN;
    } else {
        return "Unknown address type";
    }
}

HRESULT SetIMsgPropsFromCL(IUnknown *pIMsg, PCOMMANDLINE pcl)
{
    IMailMsgProperties *pIMsgProps = NULL;
    IMailMsgRecipients *pRecips = NULL;
    IMailMsgRecipientsAdd *pRecipsAdd = NULL;
    PLIST_ENTRY ple_recip;
    HRESULT hr;

    hr = pIMsg->QueryInterface(IID_IMailMsgProperties,
                               (LPVOID *)&pIMsgProps);
    if(FAILED(hr)) {
        pIMsgProps = NULL;
        goto CLEANUP;
    }

    if(pcl->dwRandom) {
        TCHAR szSenderAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
        _snprintf(
            szSenderAddress,
            CAT_MAX_INTERNAL_FULL_EMAIL,
            pcl->szSenderAddress,
            GenRandomDWORD());

        // Set sender address with random substitution done
        hr = pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, szSenderAddress);
    } else {

        // Set sender property
        hr = pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, pcl->szSenderAddress);
    }
    if(FAILED(hr))
        goto CLEANUP;
#if 0
    hr = pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_TYPE, SzTypeFromCAType(pcl->CATSender));
    if(FAILED(hr))
        goto CLEANUP;
#endif
    hr = pIMsg->QueryInterface(IID_IMailMsgRecipients, (LPVOID *)&pRecips);
    if(FAILED(hr)) {
        pRecips = NULL;
        goto CLEANUP;
    }
    hr = pRecips->AllocNewList(&pRecipsAdd);
    if(FAILED(hr)) {
        pRecipsAdd = NULL;
        goto CLEANUP;
    }
    for(ple_recip = pcl->listhead_Recipients.Flink; 
        ple_recip != &(pcl->listhead_Recipients);
        ple_recip = ple_recip->Flink) {
        PRECIPIENT pRecip = CONTAINING_RECORD(ple_recip, RECIPIENT, listentry);

        DWORD dwNumAddresses = 0;
        LPTSTR rgpsz[CAT_MAX_ADDRESS_TYPES];
        DWORD rgdw[CAT_MAX_ADDRESS_TYPES];
        PLIST_ENTRY ple_addr;
        for(ple_addr = pRecip->listhead_Addresses.Flink;
            ple_addr != &(pRecip->listhead_Addresses);
            ple_addr = ple_addr->Flink) {

            PADDRESS pAddr = CONTAINING_RECORD(ple_addr, ADDRESS, listentry);
            _ASSERT(dwNumAddresses < CAT_MAX_ADDRESS_TYPES);

            if(pcl->dwRandom) {
                // Need to allocate then free buffers
                rgpsz[dwNumAddresses] = new TCHAR[CAT_MAX_INTERNAL_FULL_EMAIL];
                _ASSERT(rgpsz[dwNumAddresses]);
                _snprintf(rgpsz[dwNumAddresses], 
                          CAT_MAX_INTERNAL_FULL_EMAIL, 
                          pAddr->szAddress, 
                          GenRandomDWORD() % pcl->dwRandom);
            } else {
                rgpsz[dwNumAddresses] = pAddr->szAddress;
            }

            rgdw[dwNumAddresses] = PropIdFromCAType(pAddr->CAType);
            dwNumAddresses++;

        }
        DWORD dwNewIndex;
        hr = pRecipsAdd->AddPrimary(dwNumAddresses, (LPCSTR *)rgpsz, rgdw, &dwNewIndex, NULL, 0);
        if(pcl->dwRandom) {
            // Need to free allocated buffers
            for(DWORD dwCount = 0; dwCount < dwNumAddresses; dwCount++)
                delete rgpsz[dwCount];
        }

        if(FAILED(hr)) {
            OutputStuff(2, "AddPrimary failed with hr 0x%08lx (%ld)\n",
                         hr, hr);
            goto CLEANUP;
        }
    }
    // Success!  Write the new list
    hr = pRecips->WriteList(pRecipsAdd);

 CLEANUP:
    if(pIMsgProps)
        pIMsgProps->Release();
    if(pRecips)
        pRecips->Release();
    if(pRecipsAdd)
        pRecipsAdd->Release();
    return hr;
}

DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType)
{
    switch(CAType) {
     case CAT_SMTP:
         return IMMPID_RP_ADDRESS_SMTP;
     case CAT_X500:
         return IMMPID_RP_ADDRESS_X500;
     case CAT_X400:
         return IMMPID_RP_ADDRESS_X400;
     case CAT_LEGACYEXDN:
         return IMMPID_RP_LEGACY_EX_DN;
     case CAT_CUSTOMTYPE:
         _ASSERT(0 && "Custom address types not yet supported");
         break;
     default:
         _ASSERT(0 && "Unknown address type");
         break;
    }
    return 0;
}

VOID ShowUsage()
{
  OutputStuff(1,   "\nUsage: catcons <options> [stmp address]\n"
                    "Options:       -a Assert when categorizer returns any error\n"
                    "               -c Create all IMsgs before starting Cat Performance Test\n"
                    "               -d Don't delete IMsgs\n"
                    "               -f [SMTP ADDRESS] Sender address (default jeff@stam.com)\n"
                    "               -h [Milliseconds] Sleep time in threads between CatMsg calls\n"
                    "               -i [ITERATIONS] Number of iterations (default: 1)\n"
                    "               -l [ProgID] ProgID of Categorizer to use (default: none)\n"
                    "               -m [MAX] Maximum outstanding requests (default: 1)\n"
                    "               -p Prompt for address info\n"
                    "               -r [MAX] Generate random addresses\n"
                    "               -s [0-9] Verbosity level, 0 = silent (default = 9)\n"
                    "               -t threads\n"
                    "               -v [ProgID] ProgID of IMsg to use (default: %S)\n"
                    "               -w [SECONDS] Wait time before beginning Cat test (default: 0)\n",
          IMSG_PROGID
          );
}

DWORD WINAPI SubmitThread(LPVOID arg)
{
  PCOMMANDLINE pcl = (PCOMMANDLINE)arg;
  HRESULT hr;
  LIST_ENTRY listhead_IMsgs;

  InitializeListHead(&listhead_IMsgs);

  hr = CoInitialize(NULL);
  if(FAILED(hr))
    {
      OutputStuff(1,"CoInitialize failed - 0x%08lx\n", hr);
      return 1;
    }

  srand((int)GetCurrentThreadId() + time(NULL));

  if(pcl->fPreCreate) {
      PIMSGLISTENTRY pile;
      //
      // Build a list of IMsgs so we aren't creating them during categorization
      //
      for(long lCount = 0; lCount < pcl->lIterations; lCount++) {
          pile = new IMSGLISTENTRY;
          _ASSERT(pile);

          if(SUCCEEDED(CreateMessage(pcl, &(pile->pImsg)))) {
              InsertTailList(&listhead_IMsgs, &(pile->listentry));
          } else {
              delete pile;
          }
      }
  }              

  //
  // Increment outstanding request count by one so that outstanding
  // requests won't hit zero when we are in our submit loop
  //
  InterlockedIncrement(&(pcl->lOutstandingRequests));

  if(InterlockedIncrement(&(pcl->lThreadsReady)) == 
     pcl->lThreads) {
      //
      // We're the last thread ready
      // Signal other threads they may begin after any delay specified
      //
      if(pcl->dwStartingDelay) {
          OutputStuff(7, "Sleeping %ld seconds before beginning test...\n",
                           pcl->dwStartingDelay / 1000);
          Sleep(pcl->dwStartingDelay);
      }
      OutputStuff(5, "Starting Categorizer test NOW!!!!!\n");

      // 
      // Save the time for perf measurement
      //
      pcl->cpi.dwStartTime = GetTickCount();

      SetEvent(pcl->hStartYourEnginesEvent);

  } else {
      //
      // Starting line: wait for StartYourEngines event
      //
      WaitForSingleObject(pcl->hStartYourEnginesEvent, INFINITE);
  }

  if(pcl->fPreCreate) {
      // Walk the list
      for(PLIST_ENTRY ple = listhead_IMsgs.Flink;
          ple != &(listhead_IMsgs);
          ple = ple->Flink) {
          
          PIMSGLISTENTRY pile;
          pile = CONTAINING_RECORD(ple,
                                   IMSGLISTENTRY,
                                   listentry);
          if(FAILED(SubmitMessage(pcl, pile->pImsg))) {
              InterlockedIncrement(&(pcl->cpi.lFailures));
              _ASSERT(pcl->fNoAssert && "SubmitMessage failed");
          }
          if(pcl->dwSubmitDelay) {
              Sleep(pcl->dwSubmitDelay);
          }
      }

  } else {
      // Okay, loop for # of iterations
      for(long lCount = 0;
          lCount < pcl->lIterations;
          lCount++) {

          IUnknown *pImsg;
          hr = CreateMessage(
              pcl,
              &pImsg);

          if (FAILED(hr)) {
              OutputStuff(2, "Failed to create IMsg instance - HR 0x%x\n", hr);
              InterlockedIncrement(&(pcl->cpi.lFailures));
              _ASSERT(pcl->fNoAssert && "CreateMessage failed");
          } else {
              if(FAILED(SubmitMessage(pcl, pImsg))) {
                  InterlockedIncrement(&(pcl->cpi.lFailures));
                  _ASSERT(pcl->fNoAssert && "SubmitMessage failed");
              }
              pImsg->Release();
              if(pcl->dwSubmitDelay) {
                  Sleep(pcl->dwSubmitDelay);
              }
          }
      }
  }

  //
  // Since we incremented the outstandingrequest above, decrement it
  // here.  If everything is categorized, outstanding requests will
  // now be zero
  // 
  if(InterlockedDecrement(&(pcl->lOutstandingRequests)) == 0) {
      // The test is finished.  Save the time.
      pcl->cpi.dwFinishTime = GetTickCount();
      SetEvent(pcl->hShutdownEvent);
  } else {
      WaitForSingleObject(pcl->hShutdownEvent, INFINITE);
  }
  //
  // Clean up our list if we need to do so
  //
  if(pcl->fPreCreate) {
      for(PLIST_ENTRY ple = listhead_IMsgs.Flink;
          ple != &(listhead_IMsgs);
          ple = listhead_IMsgs.Flink) {

          PIMSGLISTENTRY pile;
          pile = CONTAINING_RECORD(ple,
                                   IMSGLISTENTRY,
                                   listentry);
          pile->pImsg->Release();
          RemoveEntryList(ple);
          delete pile;
      }
  }
  
  return 0;
}

VOID PrintPerf(PCATPERFINFO pci)
{
    OutputStuff(1, "\n\n---CATCONS SUMMARY STATISTICS---\n");
    OutputStuff(1, "Number of categorized messages: %9ld\n", pci->lMessagesSubmitted);
    OutputStuff(1, "Number of failures:             %9ld\n", pci->lFailures);
    OutputStuff(1, "Time elapsed during test:       %13.3lf\n", 
                 (double)(pci->dwFinishTime - pci->dwStartTime) / 1000);
    OutputStuff(1, "Assumed Addresses per IMsg:     %9ld\n",
                 pci->lRecipientsPerMessage);
    if(pci->dwFinishTime == pci->dwStartTime) {
        OutputStuff(1, "Avg resolved msgs per second:   INFINITE! Wow, what a categorizer!!!");
        OutputStuff(1, "Avg resolved recips per second: INFINITE! Wow, what a categorizer!!!");
    } else {
        OutputStuff(1, "Avg resolved msgs per second:   %13.3lf\n",
                     (double)pci->lMessagesSubmitted /
                     ((double)(pci->dwFinishTime - pci->dwStartTime) /
                      1000));
        OutputStuff(1, "Avg resolved recips per second: %13.3lf\n",
                     (double)(pci->lMessagesSubmitted *
                              pci->lRecipientsPerMessage) /
                     ((double)(pci->dwFinishTime - pci->dwStartTime) /
                      1000));
    }
    OutputStuff(1, "---CATCONS PERF STATISTICS---\n\n");

    if(pci->lFailures) {
        OutputStuff(1, "Test Failed; %ld failures occured during the test.\n\n", 
                    pci->lFailures);

    } else {
        OutputStuff(1, "Test Passed; no failures occured during the test.\n\n");
    }
}

DWORD GenRandomDWORD()
{
    return (rand() << 16) | rand();
}

BOOL InitializeCL(PCOMMANDLINE pcl)
{
  // Set defaults
  lstrcpy(pcl->szSenderAddress, "jeff@stam.com");
  pcl->CATSender = CAT_SMTP;
  InitializeListHead(&pcl->listhead_Recipients);
  pcl->lIterations = 1;
  pcl->lMaxOutstandingRequests = 1;
  pcl->fDelete = TRUE;
  pcl->fNoAssert = TRUE;
  pcl->lThreads = 1;
  pcl->lThreadsReady = 0;
  pcl->hCat = NULL;
  pcl->fPrompt = FALSE;
  pcl->dwRandom = 0;
  pcl->hShutdownEvent = INVALID_HANDLE_VALUE;
  pcl->hRequestSemaphore = INVALID_HANDLE_VALUE;
  pcl->lOutstandingRequests = 0;
  pcl->fPreCreate = FALSE;
  pcl->dwStartingDelay = 0;
  pcl->dwSubmitDelay = 0;

  pcl->cpi.lMessagesSubmitted = 0;
  pcl->cpi.lRecipientsPerMessage = 1; // Start with 1 (for the sender)
  pcl->cpi.lFailures = 0;

  pcl->hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

  pcl->hStartYourEnginesEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

  pcl->hRequestSemaphore = NULL;
  pcl->pszCatProgID = NULL;

  pcl->pszIMsgProgID = new WCHAR[(sizeof(IMSG_PROGID)/sizeof(WCHAR))+1];
  if(pcl->pszIMsgProgID == NULL) {
      OutputStuff(1, "Alloc failed\n");
      return FALSE;
  }
  lstrcpyW(pcl->pszIMsgProgID, IMSG_PROGID);

  if((pcl->hShutdownEvent == NULL) || 
     (pcl->hStartYourEnginesEvent == NULL)) {
      OutputStuff(1, "CreateEvent failed - 0x%08ld\n", GetLastError());
      return FALSE;
  }
  return TRUE;
}

VOID FreeCommandLineInfo(PCOMMANDLINE pcl)
{
    PLIST_ENTRY ple = pcl->listhead_Recipients.Flink;

    while(ple != &(pcl->listhead_Recipients)) {

        PRECIPIENT pRecip = 
          CONTAINING_RECORD(ple, RECIPIENT, listentry);
        
        PLIST_ENTRY pleAddr = pRecip->listhead_Addresses.Flink;
        
        while(pleAddr != &(pRecip->listhead_Addresses)) {
            
            PADDRESS pAddr =
              CONTAINING_RECORD(pleAddr, ADDRESS, listentry);
            pleAddr = pleAddr->Flink;
            delete pAddr;
        }
        
        ple = ple->Flink;
        delete pRecip;
    }    
    if(pcl->hShutdownEvent)
        CloseHandle(pcl->hShutdownEvent);
    if(pcl->hStartYourEnginesEvent)
        CloseHandle(pcl->hStartYourEnginesEvent);
    if(pcl->hRequestSemaphore)
        CloseHandle(pcl->hRequestSemaphore);

    delete pcl->pszIMsgProgID;

    if(pcl->pszCatProgID)
        delete pcl->pszCatProgID;
}


//+------------------------------------------------------------
//
// Function: SetAQConfigFromRegistry
//
// Synopsis: Dig out old registry values, pass them into categorizer
//
// Arguments:
//   pAQConfig: AQConfig structure to fill in
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/18 20:10:38: Created.
//
//-------------------------------------------------------------
HRESULT SetAQConfigFromRegistry(AQConfigInfo *pAQConfig)
{
    TCHAR szRegValueBuf[CAT_MAX_REGVALUE_SIZE];
    LPSTR pszHeapString;

    REGCONFIGENTRY pRegConfigTable[] = 
        REGCONFIGTABLE;

    // Set Enable
    pAQConfig->dwAQConfigInfoFlags = AQ_CONFIG_INFO_MSGCAT_FLAGS;
    pAQConfig->dwMsgCatFlags = 0xFFFFFFFF;

    pAQConfig->dwAQConfigInfoFlags = AQ_CONFIG_INFO_MSGCAT_ENABLE;
    pAQConfig->dwMsgCatEnable = 0xFFFFFFFF;

    PREGCONFIGENTRY pRegConfigEntry = pRegConfigTable;
    while(pRegConfigEntry->pszRegValueName != NULL) {
        
        if(GetRegConfigString(
            IMC_SERVICE_REG_KEY_MSGCAT,
            pRegConfigEntry->pszRegValueName,
            szRegValueBuf,
            CAT_MAX_REGVALUE_SIZE)) {
            
            pszHeapString = new CHAR[lstrlen(szRegValueBuf) + 1];
            if(pszHeapString == NULL) {
                FreeAQConfigInfo(pAQConfig);
                return E_OUTOFMEMORY;
            }
            lstrcpy(pszHeapString, szRegValueBuf);

            pAQConfig->dwAQConfigInfoFlags |= pRegConfigEntry->dwAQConfigInfoFlag; 

            switch(pRegConfigEntry->dwAQConfigInfoFlag) {
             case AQ_CONFIG_INFO_MSGCAT_DOMAIN:
                 pAQConfig->szMsgCatDomain = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_USER:
                 pAQConfig->szMsgCatUser = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_PASSWORD:
                 pAQConfig->szMsgCatPassword = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_BINDTYPE:
                 pAQConfig->szMsgCatBindType = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE:
                 pAQConfig->szMsgCatSchemaType = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_HOST:
                 pAQConfig->szMsgCatHost = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT:
                 pAQConfig->szMsgCatNamingContext = pszHeapString;
                 break;

             case AQ_CONFIG_INFO_MSGCAT_TYPE:
                 pAQConfig->szMsgCatType = pszHeapString;
                 break;

             default:
                 _ASSERT(0 && "Developer error");
            }
        }
        pRegConfigEntry++;
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: FreeAQConfigInfo
//
// Synopsis: Frees memory allocated in AQConfig
//
// Arguments:
//   pAQConfig: AQConfig structure with strings to free
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/18 20:09:24: Created.
//
//-------------------------------------------------------------
VOID FreeAQConfigInfo(
    AQConfigInfo *pAQConfig)
{
    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_DOMAIN)
        delete pAQConfig->szMsgCatDomain;
    
    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_USER)
        delete pAQConfig->szMsgCatUser;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_PASSWORD)
        delete pAQConfig->szMsgCatPassword;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_BINDTYPE)
        delete pAQConfig->szMsgCatBindType;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE)
        delete pAQConfig->szMsgCatSchemaType;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_HOST)
        delete pAQConfig->szMsgCatHost;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT)
        delete pAQConfig->szMsgCatNamingContext;

    if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_TYPE)
        delete pAQConfig->szMsgCatType;
}
    

//+------------------------------------------------------------
//
// Function: GetRegConfigString
//
// Synopsis: Attempts to retrieve Categorizer config string from
//           registry -- needed for unit test currently
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980521 18:36:48: Created.
//
//-------------------------------------------------------------
LPTSTR GetRegConfigString(
    LPTSTR pszConfig, 
    LPTSTR pszName, 
    LPTSTR pszBuffer, 
    DWORD dwcch)
{
  TraceFunctEnter("GetRegConfigString");
  _ASSERT(pszName != NULL);
  _ASSERT(pszBuffer != NULL);

  // Local variables
  LPTSTR pszKey = NULL;
  HKEY hRegKey = NULL;
  DWORD dwError;
  DWORD dwcb;

  if(pszConfig == NULL) {
      // You're not getting any values from the registry then...
      return NULL;
  }

  // Retrieve registry keys for config...
  // Build subkey string
  pszKey = new TCHAR[
    sizeof(IMC_SERVICE_REG_KEY) + 1 +
    sizeof(IMC_SERVICE_REG_CATSOURCES) + 1 +
    lstrlen(pszConfig) + 1];
  if(pszKey == NULL) {
      ErrorTrace(NULL, "Out of memory allocating pszKey");
      TraceFunctLeave();
      return NULL;
  }

  lstrcpy(pszKey, IMC_SERVICE_REG_KEY);
  lstrcat(pszKey, TEXT("\\"));
  lstrcat(pszKey, IMC_SERVICE_REG_CATSOURCES);
  lstrcat(pszKey, TEXT("\\"));
  lstrcat(pszKey, pszConfig);

  dwError = RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hRegKey);

  if(dwError != ERROR_SUCCESS) {
      ErrorTrace((LPARAM)NULL, "Error opening regkey HKEY_LOCAL_MACHINE\\%s", pszKey);
      delete pszKey;
      return NULL;
  }

  delete pszKey;

  dwcb = dwcch * sizeof(TCHAR);
  DWORD dwType;
  dwError = RegQueryValueEx(
      hRegKey,
      pszName,
      NULL,
      &dwType,
      (LPBYTE)pszBuffer,
      &dwcb);

  RegCloseKey(hRegKey);

  if((dwError != ERROR_SUCCESS) ||
     (dwType != REG_SZ)) {
      return NULL;
  } else {
      return pszBuffer;
  }
}

//+------------------------------------------------------------
//
// Function: OutputStuff
//
// Synopsis: Print out a debug string if dwLevel <= g_dwDebugOutLevel
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/21 19:33:49: Created.
//
//-------------------------------------------------------------
VOID OutputStuff(DWORD dwLevel, char *szFormat, ...)
{
    if(dwLevel <= g_dwDebugOutLevel) {
        va_list ap;
        va_start(ap, szFormat);

        vfprintf(stdout, szFormat, ap);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\catcons.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catcons.h
//
// Contents: Big header file for cat unit test: catcons
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/07/28 13:17:31: Created.
//
//-------------------------------------------------------------
#ifndef _CATCONS_H_
#define _CATCONS_H_

#include <stdio.h>
#include <time.h>
#include <windows.h>
#include <transmem.h>
#include <ole2.h>
#include <initguid.h>
#include "propstr.h"
#include "imcplat.h"
#include "cat.h"
#include "caterr.h"
#include "cattype.h"
#include "catdefs.h"
#include <listmacr.h>
#include "mailmsg.h"
#include "mailmsgprops.h"
#include "csharmem.h"
#include "perfcc.h"



#define IMSG_PROGID L"Exchange.MailMsg"

typedef struct _tagCatPerfInfo
{
  long   lFailures;
  long   lMessagesSubmitted;
  long   lRecipientsPerMessage;
  DWORD  dwStartTime;
  DWORD  dwFinishTime;
} CATPERFINFO, *PCATPERFINFO;


typedef struct _tagCommandLine
{
  CHAR   szSenderAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
  CAT_ADDRESS_TYPE CATSender;
  LIST_ENTRY listhead_Recipients;
  long   lIterations;
  long   lMaxOutstandingRequests;
  BOOL   fDelete;
  BOOL   fNoAssert;
  BOOL   fPrompt;
  DWORD  dwRandom;
  HANDLE hStartYourEnginesEvent;
  HANDLE hShutdownEvent;
  HANDLE hRequestSemaphore;
  LONG   lOutstandingRequests;
  LONG   lThreads;
  LONG   lThreadsReady;
  HANDLE hCat;
  CATPERFINFO cpi;
  BOOL   fPreCreate;
  DWORD  dwStartingDelay;
  DWORD  dwSubmitDelay;
  LPWSTR pszIMsgProgID;
  LPWSTR pszCatProgID;
} COMMANDLINE, *PCOMMANDLINE;

typedef struct _tagRecipient
{
  LIST_ENTRY listentry;
  LIST_ENTRY listhead_Addresses;
} RECIPIENT, *PRECIPIENT;

typedef struct _tagAddress
{
  LIST_ENTRY listentry;
  CAT_ADDRESS_TYPE CAType;
  TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
} ADDRESS, *PADDRESS;


typedef struct _tagIMsgList {
    IUnknown *pImsg;
    LIST_ENTRY listentry;
} IMSGLISTENTRY, *PIMSGLISTENTRY;
      
typedef struct _tagRegConfigEntry {
    DWORD dwAQConfigInfoFlag;
    LPSTR pszRegValueName;
} REGCONFIGENTRY, *PREGCONFIGENTRY;

#define REGCONFIGTABLE { \
    { AQ_CONFIG_INFO_MSGCAT_DOMAIN,     "Domain" }, \
    { AQ_CONFIG_INFO_MSGCAT_USER,       "Account" }, \
    { AQ_CONFIG_INFO_MSGCAT_PASSWORD,   "Password" }, \
    { AQ_CONFIG_INFO_MSGCAT_BINDTYPE,   "Bind" }, \
    { AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE, "SchemaType" }, \
    { AQ_CONFIG_INFO_MSGCAT_HOST,       "Host" }, \
    { AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT, "NamingContext" }, \
    { AQ_CONFIG_INFO_MSGCAT_TYPE,       "Type" }, \
    { 0, NULL } \
}


HRESULT CatCompletion(HRESULT hr, PVOID pContext, IUnknown *pImsg, IUnknown **rgpImsg);
DWORD PrintRecips(IUnknown *pImsg);
VOID PrintPerf(PCATPERFINFO pci);

BOOL ParseCommandLineInfo(int argc, char **argv, PCOMMANDLINE pcl);
VOID FreeCommandLineInfo(PCOMMANDLINE pcl);
BOOL ParseInteractiveInfo(PCOMMANDLINE pcl);
CAT_ADDRESS_TYPE CATypeFromString(LPTSTR szType);
LPCSTR SzTypeFromCAType(CAT_ADDRESS_TYPE CAType);
HRESULT SetIMsgPropsFromCL(IUnknown *pIMsg, PCOMMANDLINE pcl);
DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType);
DWORD GenRandomDWORD();
VOID ShowUsage();
DWORD WINAPI SubmitThread(LPVOID);
BOOL InitializeCL(PCOMMANDLINE pcl);
HRESULT SetAQConfigFromRegistry(AQConfigInfo *pAQConfig);
VOID FreeAQConfigInfo(AQConfigInfo *pAQConfig);
LPTSTR GetRegConfigString(
    LPTSTR pszConfig, 
    LPTSTR pszName, 
    LPTSTR pszBuffer, 
    DWORD dwcch);
VOID OutputStuff(DWORD dwLevel, char *szFormat, ...);
extern CSharedMem  g_cPerfMem;


inline HRESULT SubmitMessage(PCOMMANDLINE pcl, IUnknown *pImsg)
{
    HRESULT hr;

    // Control the number of outstanding requests we can
    // have
    WaitForSingleObject(pcl->hRequestSemaphore, INFINITE);

    //
    // Add a reference to IMsg object for the categorizer (this reference will be released in the completion routine)
    //
    pImsg->AddRef();

    // Increase search count in case completion routine
    // is called before CatMsg returns
    InterlockedIncrement(&(pcl->lOutstandingRequests));
    hr = CatMsg(pcl->hCat, pImsg, CatCompletion, (LPVOID)pcl);
    g_cPerfMem.IncrementDW(CATPERF_SUBMITTED_NDX);
    if(SUCCEEDED(hr)) {

        g_cPerfMem.IncrementDW(CATPERF_SUBMITTEDOK_NDX);
        g_cPerfMem.ExchangeAddDW(CATPERF_SUBMITTEDUSERSOK_NDX,
                                 pcl->cpi.lRecipientsPerMessage);
        g_cPerfMem.IncrementDW(CATPERF_OUTSTANDINGMSGS_NDX);

        InterlockedIncrement(&(pcl->cpi.lMessagesSubmitted));

    } else {
        //
        // Release reference added above
        //
        pImsg->Release();

        g_cPerfMem.IncrementDW(CATPERF_SUBMITTEDFAILED_NDX);
        InterlockedDecrement(&(pcl->lOutstandingRequests));
        OutputStuff(2, "CatMsg failed, error %08lx\n", hr);
        // jstamerj 980303 17:05:42: Trap!
        _ASSERT(pcl->fNoAssert && "CatMsg failed");
    }
    return hr;
}
    
inline HRESULT CreateMessage(PCOMMANDLINE pcl, IUnknown **ppImsg)
{
    _ASSERT(pcl);
    _ASSERT(ppImsg);
    CLSID clsidIMsg;
    HRESULT hr;

    *ppImsg = NULL;

    hr = CLSIDFromProgID(pcl->pszIMsgProgID, &clsidIMsg);
    if (FAILED(hr)) {
        OutputStuff(2, "Failed to get clsid of IMsg 0x%x.\n"
                    "Is MailMsg.dll registered on this machine?\n",
                     hr);
        _ASSERT(pcl->fNoAssert && "CLSIDFromProgID failed");
        return 0;
    }
    hr = CoCreateInstance(
        clsidIMsg,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IUnknown,
        (LPVOID *) ppImsg);

    if (FAILED(hr)) {
        OutputStuff(2, "Failed to create IMsg instance - HR 0x%x\n", hr);
        _ASSERT(pcl->fNoAssert && "CoCreateInstance failed");
        return hr;
    }

    hr = SetIMsgPropsFromCL(*ppImsg, pcl);
    if(FAILED(hr)) {
        OutputStuff(2, "SetIMsgPropsFromCL failed\n");
        _ASSERT(pcl->fNoAssert && "SetIMsgPropsFromCL failed");

        (*ppImsg)->Release();
        *ppImsg = NULL;
        return hr;
    }
    return S_OK;
}

#endif _CATCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\setup\catsetup.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catsetup.h
//
// Contents:
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980416 09:33:00: Created.
//
//-------------------------------------------------------------
#define DEFAULT_NUM_USERS 100


#define SCHEMA_CONTAINER TEXT("container")
#define SCHEMA_USER      TEXT("user")
#define SCHEMA_MAIL      TEXT("mail")
#define SCHEMA_PROXY     TEXT("ProxyAddresses")
#define SCHEMA_GROUP     TEXT("group")

#define CATCONTAINERDN TEXT("cn=CatPerf,cn=Users")
#define CATSMTPDOMAIN  TEXT("perf.test.cat.com")
#define DEFAULTORG     TEXT("DefaultOrg")
#define CATGROUPDL     TEXT("CatUsers")
#define CATGROUP100DL  TEXT("Cat100")

#define CATBINDTYPE    TEXT("CurrentUser")

int CreateContainer(PLDAP pldap, LPTSTR pszDN, LPTSTR pszBaseDN);
int CreateCatUser(PLDAP pldap, LPTSTR pszUser, LPTSTR pszBaseDN);
int CreateCatDL(PLDAP pldap, LPTSTR pszName, LPTSTR pszBaseDN);
int AddToDistList(PLDAP pldap, LPTSTR pszDLName, LPTSTR pszUser, LPTSTR pszBaseDN);
HRESULT SetupRegistry(LPTSTR pszHost);

VOID OutputStuff(DWORD dwLevel, char *szFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\ccdomain.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccdomain.cpp
//
// Contents: Implementation of CDomainInfo
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/07/28 13:00:16: Created.
//
//-------------------------------------------------------------
#include "ccdomain.h"
#include "catcons.h"
#include "aqueue_i.c"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ISMTPServer
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CDomainInfoIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_IAdvQueueDomainType) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CDomainInfoIMP::AddRef()
{
    return ++m_cRef;
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero. 
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CDomainInfoIMP::Release()
{
    if(--m_cRef == 0) {
        delete this;
        return 0;
    } else {
        return m_cRef;
    }
}


//+------------------------------------------------------------
//
// Function: CDomainInfoIMP::GetDomainInfoFlags
//
// Synopsis: Pretend we know what's local and what's remote
//
// Arguments: 
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/28 13:07:45: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CDomainInfoIMP::GetDomainInfoFlags(
    LPSTR szDomainName,
    DWORD *pdwFlags)
{
    OutputStuff(8, "GetDomainInfoFlags called with domain %s\n", szDomainName);

    *pdwFlags = 0L;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\setup\ldaptest.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       ldaptest.cpp
//
//  Contents:   General purpose program to add, delete, and lookup objects
//              in an ldap enabled directory server. This program is suitable
//              for extending the schema in an NT5 DS.
//
//              Usage:
//                  ldaptest addattrib <name> <syntax>
//                  ldaptest addclass <name> <subclassof>
//                  ldaptest addclassattrib <classname> <attribname> <must | may>
//                  ldaptest addobject <objectname> <classname> <attrib=value>*
//                  ldaptest addobjectattr <objectname> <attrib=value>*
//                  ldaptest delattrib <name>
//                  ldaptest delclass <class>
//                  ldaptest delclassattr <class> <attrib> <must | may>
//                  ldaptest delobjectattr <object> <attrib>
//                  ldaptest delobject <object>
//
//  Classes:    None
//
//  Functions:  main
//
//  History:    December 3, 1996    Milans created
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <winldap.h>
#include "ldaptest.h"

//
// Array describing all the program operations. Useful for parsing command
// line parameters.
//

OP_DEF rgOpDefs[] = {
    {ADD_NEW_ATTRIBUTE, "addattrib", 2, AddAttribute},
    {ADD_NEW_CLASS, "addclass", 2, AddClass},
    {ADD_NEW_CLASS_ATTRIBUTE, "addclassattrib", 3, AddClassAttribute},
    {ADD_NEW_OBJECT, "addobject", 2, AddObject},
    {ADD_NEW_OBJECT_ATTRIBUTE, "addobjectattrib", 2, AddObjectAttribute},
    {DEL_ATTRIBUTE, "delattrib", 1, DeleteAttribute},
    {DEL_CLASS, "delclass", 1, DeleteClass},
    {DEL_CLASS_ATTRIBUTE, "delclassattrib", 3, DeleteClassAttribute},
    {DEL_OBJECT_ATTRIBUTE, "delobjectattrib", 2, DeleteObjectAttribute},
    {DEL_OBJECT, "delobject", 1, DeleteObject}
};


//+----------------------------------------------------------------------------
//
//  Function:   BindToLdapServer
//
//  Synopsis:   Establishes a binding to an ldap server so that an ldap
//              operation can be attempted.
//
//  Arguments:  None
//
//  Returns:    NULL or pointer to LDAP binding structure
//
//-----------------------------------------------------------------------------

PLDAP BindToLdapServer(LPTSTR szHost)
{
    PLDAP pldap;
    int err;

    pldap = ldap_open(szHost, LDAP_PORT);

    if (pldap != NULL) {

        err = ldap_bind_s( pldap, NULL, NULL, LDAP_AUTH_SSPI );

        if (err != LDAP_SUCCESS) {

            fprintf(stderr, "ldap_bind failed with error 0x%x\n", err);

            ldap_unbind( pldap );

            pldap = NULL;

        }

    }

    return( pldap );
}

//+----------------------------------------------------------------------------
//
//  Function:   CloseLdapConnection
//
//  Synopsis:   Destroys binding created by BindToLdapServer
//
//  Arguments:  [pldap] -- Pointer to binding structure
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CloseLdapConnection(
    PLDAP pldap)
{

    ldap_unbind( pldap );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetSchemaContainerDN
//
//  Synopsis:   Gets the DN of the container that contains
//
//  Arguments:  [pldap] -- The ldap connection to use
//              [pszDN] -- On entry, points to a buffer of sufficient length
//                      to hold the DN. On successful return, contains DN of
//                      schema container.
//
//  Returns:    error from ldap operation
//
//-----------------------------------------------------------------------------

int GetSchemaContainerDN(
    IN PLDAP pldap,
    OUT LPSTR pszDN)
{
    int err;
    char *rgszAttrs[] = {
            "subschemaSubentry",
            NULL};
    PLDAPMessage pldapMsg;

    //
    // Get the operational attribute subschemaSubentry. This is done by doing
    // an ldap_search on base = "", scope = BASE.
    //

    err = ldap_search_s(
                pldap,                           // ldap binding
                "",                              // base DN
                LDAP_SCOPE_BASE,                 // scope
                "(objectClass=*)",               // filter
                rgszAttrs,                       // attributes we want to read
                FALSE,                           // FALSE means read value
                &pldapMsg);                      // return results here

    if (err == LDAP_SUCCESS) {

        PLDAPMessage pEntry;
        char **rgszValues;
        int i, cValues;

        if ((pEntry = ldap_first_entry(pldap, pldapMsg)) != NULL &&
                (rgszValues = ldap_get_values(pldap, pEntry, rgszAttrs[0])) != NULL &&
                    (cValues = ldap_count_values(rgszValues)) == 1) {

            //
            // The returned string looks like "CN=Aggregate,CN=Schema..."
            // giving the DN of the subschema subentry. We need to strip off
            // the "CN=Aggregate" part to get at the DN of the schema
            // container.
            //

            for (i = 3;
                    rgszValues[0][i] != ',' && rgszValues[0][i] != 0;
                        i++) {

                NOTHING;
            }

            if (rgszValues[0][i] == 0) {

                fprintf(
                    stderr,
                    "Unexpected value for subschemaSubentry [%s]\n",
                    rgszValues[0]);

                err = LDAP_OTHER;

            } else {

                strcpy(pszDN, &rgszValues[0][i+1]);

            }

        } else {

            fprintf(stderr, "Unexpected error reading subschemaSubentry\n");

            err = LDAP_OTHER;

        }

        if (rgszValues != NULL)
            ldap_value_free(rgszValues);

        ldap_msgfree(pldapMsg);

    } else {

        fprintf(stderr, "GetSchemaContainerDN failed ldap error 0x%x\n", err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetNamingContextDN
//
//  Synopsis:   Gets the DN of the naming context of the DS Server. This is
//              the DN under which all "interesting" objects are found.
//
//  Arguments:  [pldap] -- The ldap connection to use
//              [pszDN] -- On entry, points to a buffer of sufficient length
//                      to hold the DN. On successful return, contains DN of
//                      the DS server's naming context.
//
//  Returns:
//
//-----------------------------------------------------------------------------

int GetNamingContextDN(
    IN PLDAP pldap,
    OUT LPSTR pszDN)
{
    int err;
    char *rgszAttrs[] = {
            "defaultNamingContext",
            NULL};
    PLDAPMessage pldapMsg;

    //
    // Get the operational attribute namingContexts. This is done by doing
    // an ldap_search on base = "", scope = BASE.
    //

    err = ldap_search_s(
                pldap,                           // ldap binding
                "",                              // base DN
                LDAP_SCOPE_BASE,                 // scope
                "(objectClass=*)",               // filter
                rgszAttrs,                       // attributes we want to read
                FALSE,                           // FALSE means read value
                &pldapMsg);                      // return results here

    if (err == LDAP_SUCCESS) {

        PLDAPMessage pEntry;
        char **rgszValues;
        int i, cValues;

        if ((pEntry = ldap_first_entry(pldap, pldapMsg)) != NULL &&
                (rgszValues = ldap_get_values(pldap, pEntry, rgszAttrs[0])) != NULL &&
                    (cValues = ldap_count_values(rgszValues)) != 0) {

            //
            // There is really no way to figure out which namingContext is the
            // interesting one. Here, we pick the first one that doesn't have
            // the word "Configuration" in it, since typically, the
            // Configuration and the normal namingContexts are the only two
            // contexts supported by a DS.
            //

            for (i = 0; i < cValues; i++) {

                if (strstr( rgszValues[i], "Configuration" ) == NULL) {
                    strcpy(pszDN, rgszValues[i]);
                    break;
                }
            }

            if (i == cValues) {

                fprintf(stderr,"Unexpected values for namingContexts\n");

                for (i = 0; i < cValues; i++)
                    fprintf(stderr, "\t%s\n", rgszValues[i]);

                err = LDAP_OTHER;

            }

        } else {

            fprintf(stderr, "Unexpected error reading namingContexts\n");

            err = LDAP_OTHER;

        }

        if (rgszValues != NULL)
            ldap_value_free(rgszValues);

        ldap_msgfree(pldapMsg);

    } else {

        fprintf(stderr, "GetNamingContextDN failed ldap error 0x%x\n", err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddSchemaObject
//
//  Synopsis:   Creates an object of the specified name and type in the
//              schema container, thus extending the DS schema.
//
//  Arguments:  [pldap] -- Ldap Connection.
//              [szObject] -- Name of schema ext.; looks like "MySchemaObj"
//              [rgAttrs] -- array of pointers to LDAPMod structs describing
//                  the attributes that this schema object has.
//
//  Returns:    Result of operation
//
//-----------------------------------------------------------------------------

int AddSchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[])
{
    int err;
    char szSchemaContainer[MAX_DN_SIZE];
    char szObjectDN[MAX_DN_SIZE];

    //
    // Get SchemaContainerDN
    // Form DN of attribute schema object
    // Call ldap_add
    //

    err = GetSchemaContainerDN(pldap, szSchemaContainer);

    if (err == LDAP_SUCCESS) {

        sprintf(szObjectDN, "CN=%s,%s", szObject, szSchemaContainer);

        err = ldap_add_s(
                    pldap,
                    szObjectDN,
                    rgAttrs);

        if (err != LDAP_SUCCESS)
            fprintf(
                stderr,
                "AddSchemaObject failed for [%s] with ldap error 0x%x",
                szObjectDN,
                err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   ModifySchemaObject
//
//  Synopsis:   Creates an object of the specified name and type in the
//              schema container, thus extending the DS schema.
//
//  Arguments:  [pldap] -- Ldap Connection.
//              [szObject] -- Name of schema extension; looks like "MySchemaObj"
//              [rgAttrs] -- array of pointers to LDAPMod structs describing
//                  the attributes that need to be modified.
//
//  Returns:    Result of operation
//
//-----------------------------------------------------------------------------

int ModifySchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[])
{
    int err;
    char szSchemaContainer[MAX_DN_SIZE];
    char szObjectDN[MAX_DN_SIZE];

    //
    // Get SchemaContainerDN
    // Form DN of attribute schema object
    // Call ldap_modify
    //

    err = GetSchemaContainerDN(pldap, szSchemaContainer);

    if (err == LDAP_SUCCESS) {

        sprintf(szObjectDN, "CN=%s,%s", szObject, szSchemaContainer);

        err = ldap_modify_s(
                    pldap,
                    szObjectDN,
                    rgAttrs);

        if (err != LDAP_SUCCESS)
            fprintf(
                stderr,
                "ModifySchemaObject for [%s] failed with ldap error 0x%x",
                szObjectDN,
                err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteSchemaObject
//
//  Synopsis:   Deletes a schema definition object from the DS.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int DeleteSchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject)
{
    int err;
    char szSchemaContainer[MAX_DN_SIZE];
    char szObjectDN[MAX_DN_SIZE];

    //
    // Get SchemaContainerDN
    // Form the DN of the schema definition object
    // Call ldap_delete
    //

    err = GetSchemaContainerDN(pldap, szSchemaContainer);

    if (err == LDAP_SUCCESS) {

        sprintf(szObjectDN, "CN=%s,%s", szObject, szSchemaContainer);

        err = ldap_delete_s(
                    pldap,
                    szObjectDN);

        if (err != LDAP_SUCCESS)
            fprintf(
                stderr,
                "DeleteSchemaObject for [%s] failed with ldap error 0x%x",
                szObjectDN,
                err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddDSObject
//
//  Synopsis:   Creates an object of the specified name and type in the
//              DS container.
//
//  Arguments:  [pldap] -- Ldap Connection.
//              [szObject] -- Name of DS object; looks like "MyDSObj"
//              [rgAttrs] -- array of pointers to LDAPMod structs describing
//                  the attributes that this DS object has.
//
//  Returns:    Result of operation
//
//-----------------------------------------------------------------------------

int AddDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[])
{
    int err;

    err = ldap_add_s(
        pldap,
        szObject,
        rgAttrs);

#ifdef VERBOSE
    if (err != LDAP_SUCCESS)
        fprintf(
            stderr,
            "AddDSObject failed for [%s] with ldap error 0x%x",
            szObject,
            err);
#endif

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   ModifyDSObject
//
//  Synopsis:   Modifies an object of the specified name in the
//              DS container, thus extending the DS DS.
//
//  Arguments:  [pldap] -- Ldap Connection.
//              [szObject] -- Name of DS object; looks like "MyDSObj"
//              [rgAttrs] -- array of pointers to LDAPMod structs describing
//                  the attributes that need to be modified.
//
//  Returns:    Result of operation
//
//-----------------------------------------------------------------------------

int ModifyDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[])
{
    int err;

    err = ldap_modify_s(
        pldap,
        szObject,
        rgAttrs);

#ifdef VERBOSE
    if (err != LDAP_SUCCESS)
        fprintf(
            stderr,
            "ModifyDSObject for [%s] failed with ldap error 0x%x",
            szObject,
            err);
#endif
    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteDSObject
//
//  Synopsis:   Deletes a DS object.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int DeleteDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject)
{
    int err;
    char szContainer[MAX_DN_SIZE];
    char szObjectDN[MAX_DN_SIZE];

    //
    // Get NamingContextDN
    // Form the DN of the DS definition object
    // Call ldap_delete
    //

    err = GetNamingContextDN(pldap, szContainer);

    if (err == LDAP_SUCCESS) {

        sprintf(szObjectDN, "CN=%s,%s", szObject, szContainer);

        err = ldap_delete_s(
                    pldap,
                    szObjectDN);

        if (err != LDAP_SUCCESS)
            fprintf(
                stderr,
                "DeleteDSObject for [%s] failed with ldap error 0x%x",
                szObjectDN,
                err);

    }

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddAttribute
//
//  Synopsis:   Adds a new attribute to the DS Schema
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int AddAttribute(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szAttributeName;
    LPSTR szSyntax;
    int err, i, c;
    struct {
        LPSTR szSyntaxName;
        LPSTR szAttributeSyntaxValue;
        LPSTR szOMSyntaxValue;
    } *pSyntaxType, rgSyntaxTypes[] = {
        {"BOOLEAN", "2.5.5.8", "1"},
        {"INTEGER", "2.5.5.9", "2"},
        {"BINARY", "2.5.5.10", "4"},
        {"UNICODESTRING", "2.5.5.12", "64"}
    };
    struct {
        LPSTR szAttr;
        LPSTR szValue;
    } rgAttrValuePairs[] = {
        {"objectClass", "ATTRIBUTE-SCHEMA"},
        {"isSingleValued", "TRUE"},
        {"attributeSyntax", ""},
        {"OM-Syntax", ""}
    };
    #define OBJECT_CLASS_INDEX      0            // These must be kept in
    #define IS_SINGLE_VALUED_INDEX  1            // sync with rgAttrValuePairs
    #define ATTRIBUTE_SYNTAX_INDEX  2            // above.
    #define OM_SYNTAX_INDEX         3
    #define ATTRIBUTE_NUM_PROPS     4
    SINGLE_VALUED_LDAPMod rgMods[ATTRIBUTE_NUM_PROPS+1];
    PLDAPMod rgAttrs[ATTRIBUTE_NUM_PROPS+1];

    //
    // Figure out syntax of attribute
    // Create list of must-have attributes listed below
    //      objectClass
    //      isSingleValued
    //      attributeSyntax
    //      OM-Syntax
    // Create schema object
    //

    if (cArg != 2)
        return( 1 );

    szAttributeName = szArg[0];
    szSyntax = szArg[1];
    c = sizeof(rgSyntaxTypes) / sizeof(rgSyntaxTypes[0]);

    //
    // Figure out the syntax of the attribute
    //

    for (i = 0; i < c; i++) {

        if (_stricmp(szSyntax, rgSyntaxTypes[i].szSyntaxName) == 0) {

            pSyntaxType = &rgSyntaxTypes[i];

            break;
        }

    }

    if (i == c) {

        printf("<syntax> must be one of the following:\n");

        for (i = 0; i < c; i++)
            printf("\t%s\n", rgSyntaxTypes[i].szSyntaxName);

        return( 1 );

    }

    //
    // Fill out the list of must-have attributes
    //

    rgAttrValuePairs[ATTRIBUTE_SYNTAX_INDEX].szValue =
        pSyntaxType->szAttributeSyntaxValue;

    rgAttrValuePairs[OM_SYNTAX_INDEX].szValue =
        pSyntaxType->szOMSyntaxValue;

    for (i = 0; i < ATTRIBUTE_NUM_PROPS; i++) {

        rgMods[i].mod.mod_op = LDAP_MOD_ADD;
        rgMods[i].mod.mod_type = rgAttrValuePairs[i].szAttr;
        rgMods[i].rgszValues[0] = rgAttrValuePairs[i].szValue;
        rgMods[i].rgszValues[1] = NULL;
        rgMods[i].mod.mod_vals.modv_strvals = rgMods[i].rgszValues;

        rgAttrs[i] = &rgMods[i].mod;

    }

    rgAttrs[i] = NULL;

    //
    // Create Schema Object
    //

    err = AddSchemaObject( pldap, szAttributeName, rgAttrs );

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddClass
//
//  Synopsis:   Adds a new class to the DS Schema
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int AddClass(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szClassName;
    LPSTR szSuperiorClass;
    int err, i;
    struct {
        LPSTR szAttr;
        LPSTR szValue;
    } rgAttrValuePairs[] = {
        {"objectClass", "CLASS-SCHEMA"},
        {"Object-Class-Category", "0"},
        {"lDAPDisplayName", ""},
        {"subClassOf", ""}
    };
    #define OBJECT_CLASS_INDEX      0            // These must be kept in
    #define OBJECT_CLASS_CATEGORY_INDEX  1       // sync with rgAttrValuePairs
    #define LDAP_NAME_INDEX         2            // above
    #define SUB_CLASS_OF_INDEX      3
    #define CLASS_NUM_PROPS     4
    SINGLE_VALUED_LDAPMod rgMods[CLASS_NUM_PROPS+1];
    PLDAPMod rgAttrs[CLASS_NUM_PROPS+1];

    //
    // Parse out class name
    // Parse out class to inherit from
    // Create list of must-have attributes
    //      objectClass
    //      Object-Class-Category
    //      subClassOf
    //      lDAPDisplayName
    // Create schema object
    //

    if (cArg != 2) {
        return( 1 );
    }

    //
    // Parse out the class and superion class names
    //
    szClassName = szArg[0];
    szSuperiorClass = szArg[1];

    //
    // Create list of attributes...
    //

    rgAttrValuePairs[ LDAP_NAME_INDEX ].szValue = szClassName;
    rgAttrValuePairs[ SUB_CLASS_OF_INDEX ].szValue = szSuperiorClass;

    for (i = 0; i < CLASS_NUM_PROPS; i++) {

        rgMods[i].mod.mod_op = LDAP_MOD_ADD;
        rgMods[i].mod.mod_type = rgAttrValuePairs[i].szAttr;
        rgMods[i].rgszValues[0] = rgAttrValuePairs[i].szValue;
        rgMods[i].rgszValues[1] = NULL;
        rgMods[i].mod.mod_vals.modv_strvals = rgMods[i].rgszValues;

        rgAttrs[i] = &rgMods[i].mod;

    }

    rgAttrs[i] = NULL;

    //
    // Add the class definition schema object.
    //

    err = AddSchemaObject( pldap, szClassName, rgAttrs );

    return( err );
}

//+----------------------------------------------------------------------------
//
//  Function:   AddClassAttribute
//
//  Synopsis:   Adds a new attribute to a DS Schema class.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int AddClassAttribute(
        IN PLDAP pldap,
        IN int cArg,
        IN char *szArg[])
{
    LPSTR szClassName, szAttributeName, szMustOrMay;
    SINGLE_VALUED_LDAPMod svMod;
    PLDAPMod rgAttr[2];
    int err;

    //
    // Parse out class name
    // Parse out attribute name and either "must" or "may"
    // Create list of attributes to be added to Schema object for class
    //      (mustHave or mayHave attributes)
    // Modify schema object
    //

    if (cArg != 3) {
        return( 1 );
    }

    //
    // Parse out class name, attribute name, and must or may
    //

    szClassName = szArg[0];
    szAttributeName = szArg[1];

    if (_stricmp(szArg[2], "must") == 0) {
        szMustOrMay = "mustContain";
    } else if (_stricmp(szArg[2], "may") == 0) {
        szMustOrMay = "mayContain";
    } else {
        return( 1 );
    }

    //
    // Create list of attributes to be added to Schema object for class
    //

    svMod.mod.mod_op = LDAP_MOD_ADD;
    svMod.mod.mod_type = szMustOrMay;
    svMod.rgszValues[0] = szAttributeName;
    svMod.rgszValues[1] = NULL;
    svMod.mod.mod_vals.modv_strvals = svMod.rgszValues;

    rgAttr[0] = &svMod.mod;
    rgAttr[1] = NULL;

    //
    // Modify the schema object
    //

    err = ModifySchemaObject( pldap, szClassName, rgAttr );

    return( err );
}

//+----------------------------------------------------------------------------
//
//  Function:   ParameterToAttributeValue
//
//  Synopsis:   Breaks a string of the form "attr=value" into two strings,
//              "attr" and "value". It does this by replacing the first =
//              with a NULL.
//
//  Arguments:  [szParameter] -- The parameter to parse.
//              [pszAttribute] -- On return, pointer to the attribute name.
//              [pszValue] -- On return, pointer to the value
//
//  Returns:    TRUE if successfully parsed szParameter, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
ParameterToAttributeValue(
    IN LPSTR szParameter,
    OUT LPSTR *pszAttribute,
    OUT LPSTR *pszValue)
{
    BOOLEAN fOk = FALSE;
    int i;

    if (szParameter != NULL) {

        for (i = 0; szParameter[i] != '=' && szParameter[i] != 0; i++) {

            NOTHING;

        }

        if (szParameter[i] == '=') {

            szParameter[i] = 0;

            *pszAttribute = szParameter;

            *pszValue = &szParameter[i+1];

            fOk = TRUE;

        }

    }

    return( fOk );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddObject
//
//  Synopsis:   Creates an object in the DS of the specified class and
//              with the specified attribute values
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int AddObject(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szObjectName, szClassName;
    SINGLE_VALUED_LDAPMod *rgMods = NULL;
    PLDAPMod *rgAttrs = NULL;
    int err, i;

    //
    // Parse out object and class name
    // Parse out list of attributes and their values
    // Build list of attributes for object
    // Create DS object
    //

    if (cArg < 2) {
        return( 1 );
    }

    szObjectName = szArg[0];
    szClassName = szArg[1];

    cArg -= 2;                                   // Consume the above 2 args
    szArg += 2;

    rgMods = (SINGLE_VALUED_LDAPMod *)
                malloc( (cArg+1) * sizeof(SINGLE_VALUED_LDAPMod));

    rgAttrs = (PLDAPMod *) malloc( (cArg+2) * sizeof(PLDAPMod));

    if (rgMods == NULL || rgAttrs == NULL) {

        fprintf(
            stderr,
            "Unable to allocate %d bytes\n",
            rgMods == NULL ?
                (cArg + 2) * sizeof(SINGLE_VALUED_LDAPMod) :
                (cArg + 2) * sizeof(PLDAPMod)
            );

        err = 2;

        goto Cleanup;

    }

    for (i = 0; i < cArg; i++) {

        BOOLEAN fParsed;

        rgMods[i].mod.mod_op = LDAP_MOD_ADD;

        fParsed = ParameterToAttributeValue(
                    szArg[i],
                    &rgMods[i].mod.mod_type,
                    &rgMods[i].rgszValues[0]);

        if (!fParsed) {

            fprintf(stderr, "Invalid argument %s\n", szArg[i]);

            err = 1;

            goto Cleanup;

        }

        rgMods[i].rgszValues[1] = NULL;

        rgMods[i].mod.mod_vals.modv_strvals = rgMods[i].rgszValues;

        rgAttrs[i] = &rgMods[i].mod;
    }

    //
    // Add the objectClass attribute
    //

    rgMods[i].mod.mod_op = LDAP_MOD_ADD;
    rgMods[i].mod.mod_type = "objectClass";
    rgMods[i].rgszValues[0] = szClassName;
    rgMods[i].rgszValues[1] = NULL;
    rgMods[i].mod.mod_vals.modv_strvals = rgMods[i].rgszValues;

    rgAttrs[i] = &rgMods[i].mod;
    rgAttrs[i+1] = NULL;


    //
    // Add the DS object
    //

    err = AddDSObject( pldap, szObjectName, rgAttrs );

Cleanup:

    if (rgMods != NULL)
        free(rgMods);

    if (rgAttrs != NULL)
        free(rgAttrs);

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   AddObjectAttribute
//
//  Synopsis:   Adds a new attribute to an existing object
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int AddObjectAttribute(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szObjectName;
    SINGLE_VALUED_LDAPMod svMod;
    PLDAPMod rgAttrs[2];
    BOOLEAN fParsed;
    int err;

    //
    //  Parse out object name
    //  Parse out attribute name and value
    //  Build list of attribute-values

    //  Modify DS object
    //

    if (cArg != 2) {
        return( 1 );
    }

    szObjectName = szArg[0];

    fParsed = ParameterToAttributeValue(
                    szArg[1],
                    &svMod.mod.mod_type,
                    &svMod.rgszValues[0]);

    if (!fParsed) {
        return( 1 );
    }

    svMod.mod.mod_op = LDAP_MOD_ADD;
    svMod.mod.mod_vals.modv_strvals = svMod.rgszValues;
    svMod.rgszValues[1] = NULL;

    rgAttrs[0] = &svMod.mod;
    rgAttrs[1] = NULL;

    err = ModifyDSObject( pldap, szObjectName, rgAttrs );

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteAttribute
//
//  Synopsis:   Deletes an attribute definition from DS schema
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int DeleteAttribute(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    int err;

    //
    // Parse out name of attribute to delete
    // Delete schema object
    //

    if (cArg != 1) {
        return( 1 );
    }

    err = DeleteSchemaObject( pldap, szArg[0] );

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteClass
//
//  Synopsis:   Deletes an class definition from DS schema
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int DeleteClass(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    int err;

    //
    // Parse out name of class to delete
    // Delete schema object
    //

    if (cArg != 1) {
        return( 1 );
    }

    err = DeleteSchemaObject( pldap, szArg[0] );

    return( 0 );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteClassAttribute
//
//  Synopsis:   Deletes an attribute from a class definition.
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int DeleteClassAttribute(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szClassName, szAttributeName, szMustOrMay;
    SINGLE_VALUED_LDAPMod svMod;
    PLDAPMod rgAttrs[2];
    int err;

    //
    // Parse out the name of the class
    // Parse out the attribute
    // Modify schema object
    //

    if (cArg != 3) {
        return( 1 );
    }

    szClassName = szArg[0];
    szAttributeName = szArg[1];

    if (_stricmp(szArg[2], "must") == 0) {
        szMustOrMay = "mustContain";
    } else if (_stricmp(szArg[2], "may") == 0) {
        szMustOrMay = "mayContain";
    } else {
        return( 1 );
    }


    svMod.mod.mod_op = LDAP_MOD_DELETE;
    svMod.mod.mod_type = szMustOrMay;
    svMod.rgszValues[0] = szAttributeName;
    svMod.rgszValues[1] = NULL;
    svMod.mod.mod_vals.modv_strvals = svMod.rgszValues;

    rgAttrs[0] = &svMod.mod;
    rgAttrs[1] = NULL;

    err = ModifySchemaObject( pldap, szClassName, rgAttrs );

    return( err );

}


//+----------------------------------------------------------------------------
//
//  Function:   DeleteObjectAttribute
//
//  Synopsis:   Deletes an attribute from a DS object
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int DeleteObjectAttribute(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    LPSTR szObjectName, szAttributeName;
    SINGLE_VALUED_LDAPMod svMod;
    PLDAPMod rgAttrs[2];
    int err;

    //
    // Parse out the name of the object
    // Parse out the attribute
    // Modify DS object
    //

    if (cArg != 2) {
        return( 1 );
    }

    szObjectName = szArg[0];
    szAttributeName = szArg[1];

    svMod.mod.mod_op = LDAP_MOD_DELETE;
    svMod.mod.mod_type = szAttributeName;
    svMod.rgszValues[0] = NULL;
    svMod.mod.mod_vals.modv_strvals = svMod.rgszValues;

    rgAttrs[0] = &svMod.mod;
    rgAttrs[1] = NULL;

    err = ModifyDSObject( pldap, szObjectName, rgAttrs );

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteObject
//
//  Synopsis:   Deletes an object from the DS
//
//  Arguments:  [pldap] -- LDAP connection to use
//              [cArg] -- Count of operation specific cmd line arguments
//              [szArg] -- Array of operation specific cmd line arguments
//
//  Returns:    LDAP result of operation
//
//-----------------------------------------------------------------------------

int DeleteObject(
    IN PLDAP pldap,
    IN int cArg,
    IN char *szArg[])
{
    int err;

    //
    // Parse out name of object
    // Delete DS Object
    //

    if (cArg != 1) {
        return( 1 );
    }

    err = DeleteDSObject( pldap, szArg[0] );

    return( err );

}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Prints out usage parameters
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void Usage()
{
    printf("Usage: ldaptest <parameters>\n");
    printf("\tWhere syntax of parameters is one of the below\n");
    printf("\t  addattrib <name> <syntax>\n");
    printf("\t  addclass <name> <subclassof>\n");
    printf("\t  addclassattrib <classname> <attributename> <must | may>\n");
    printf("\t  addobject <objectname> <classname> <attribute=value>*\n");
    printf("\t  addobjectattrib <objectname> <attribute=value>\n");
    printf("\t  delattrib <name>\n");
    printf("\t  delclass <name>\n");
    printf("\t  delclassattrib <classname> <attributename> <must | may>\n");
    printf("\t  delobjectattrib <objectname> <attributename>\n");
    printf("\t  delobject <objectname>\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\setup\ldaptest.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ldaptest.h
//
// Contents:
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980416 08:54:59: Created.
//
//-------------------------------------------------------------

#ifndef __LDAPTEST_H__
#define __LDAPTEST_H__


#include <winldap.h>

//
// Enumeration listing all valid program operations
//

typedef enum eOpCode {
    ADD_NEW_ATTRIBUTE = 1,
    ADD_NEW_CLASS = 2,
    ADD_NEW_CLASS_ATTRIBUTE = 3,
    ADD_NEW_OBJECT = 4,
    ADD_NEW_OBJECT_ATTRIBUTE = 5,
    DEL_ATTRIBUTE = 10,
    DEL_CLASS = 11,
    DEL_CLASS_ATTRIBUTE = 12,
    DEL_OBJECT_ATTRIBUTE = 13,
    DEL_OBJECT = 14
} E_OPCODE;

typedef int (*POPERATION_HANDLER)(PLDAP pldap, int cArgs, char *szArg[]);

//
// Structure describing all valid program operations
//

typedef struct {
    E_OPCODE opCode;
    LPSTR szOpName;
    USHORT cMinOpArgs;
    POPERATION_HANDLER pfnOpHandler;
} OP_DEF;

//
// A convenience structure for constructing single valued LDAPMod records.
//

typedef struct {
    LDAPMod mod;
    LPSTR rgszValues[2];
} SINGLE_VALUED_LDAPMod;

//
// Maximum length, including terminating NULL of an LDAP DN
//

#define MAX_DN_SIZE     256

//
// Useful for loops with no body
//

#define NOTHING



PLDAP BindToLdapServer(LPTSTR pszHost = NULL);

VOID CloseLdapConnection(
        PLDAP pldap);

int GetSchemaContainerDN(
    IN PLDAP pldap,
    OUT LPSTR pszDN);

int GetNamingContextDN(
    IN PLDAP pldap,
    OUT LPSTR pszDN);

int AddSchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[]);

int ModifySchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[]);

int DeleteSchemaObject(
    IN PLDAP pldap,
    IN LPSTR szObject);

int AddDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[]);

int ModifyDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject,
    IN PLDAPMod rgAttrs[]);

int DeleteDSObject(
    IN PLDAP pldap,
    IN LPSTR szObject);

int AddAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int AddClass(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int AddClassAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int AddObject(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int AddObjectAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int DeleteAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int DeleteClass(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int DeleteClassAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int DeleteObjectAttribute(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

int DeleteObject(
        PLDAP pldap,
        int cArg,
        char *szArg[]);

void Usage();

#endif //__LDAPTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\ccdomain.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccdomain.h
//
// Contents: CatCons Domain Info 
//
// Classes: CDomainInfoIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/28 12:41:11: Created.
//
//-------------------------------------------------------------
#include <windows.h>
#include <dbgtrace.h>
#include "aqueue.h"

class CDomainInfoIMP : public IAdvQueueDomainType
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //IAdvQueueDomainType
    STDMETHOD (GetDomainInfoFlags) (
        IN  LPSTR szDomainName,
        OUT DWORD *pdwDomainInfoFlags);

  public:
    CDomainInfoIMP()
    {
        m_cRef = 0;
    }
    ~CDomainInfoIMP()
    {
        _ASSERT(m_cRef == 0);
    }
  private:  
    ULONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\ismtpsvr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ismtpsvr.cpp
//
// Contents: class to implement ISMTPServer and fake out categorizer
//
// Classes: CISMTPServerIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 12:58:26: Created.
//
//-------------------------------------------------------------
#include "catcons.h"
#include "ismtpsvr.h"
#include "smtpseo.h"
#include "smtpevent_i.c"

CIMailTransportNotifyIMP g_CIMailTransportNotify;

//+------------------------------------------------------------
//
// Function: CISMTPServerIMP constructor
//
// Synopsis: Initialize refcount
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/25 13:07:34: Created.
//
//-------------------------------------------------------------
CISMTPServerIMP::CISMTPServerIMP()
{
    m_lRef = 0;
    m_dwSignature = SIGNATURE_CISMTPSERVER;
    m_pICatSink = NULL;
}


//+------------------------------------------------------------
//
// Function: CISMTPServerIMP::~CISMTPServerIMP
//
// Synopsis:
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/09 22:27:11: Created.
//
//-------------------------------------------------------------
CISMTPServerIMP::~CISMTPServerIMP()
{
    if(m_pICatSink)
        m_pICatSink->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CISMTPSERVER);
    m_dwSignature = SIGNATURE_CISMTPSERVER_INVALID;
}

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ISMTPServer
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CISMTPServerIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ISMTPServer) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CISMTPServerIMP::AddRef()
{
    return InterlockedIncrement((LPLONG)&m_lRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero. 
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CISMTPServerIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((LPLONG)&m_lRef);

    if(lNewRefCount == 0) {
        delete this;
        return 0;
    } else {
        return lNewRefCount;
    }
}


//+------------------------------------------------------------
//
// Function: TriggerServerEvent
//
// Synopsis: Fake out categorizer
//
// Arguments:
//   dwEventID: ID of event to trigger
//   pvContext: data specific to event ID
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 13:12:13: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CISMTPServerIMP::TriggerServerEvent(
    DWORD dwEventID,
    PVOID pvContext)
{
    HRESULT hr = S_OK;

    switch(dwEventID) {
     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
     {
         OutputStuff(7, "OnCategorizerRegister server event triggered.\n");
         PEVENTPARAMS_CATREGISTER pParams = (PEVENTPARAMS_CATREGISTER)pvContext;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->Register(
                 pParams->pICatParams);
             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         } else {
             hr = S_OK;
         }

         if(hr != S_FALSE) {
             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }

         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
     {
         PEVENTPARAMS_CATBEGIN pParams = (PEVENTPARAMS_CATBEGIN)pvContext;

         OutputStuff(7, "OnCategorizerBegin server event triggered.\n");
         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->BeginMessageCategorization(
                 pParams->pICatMailMsgs);
             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
     {
         PEVENTPARAMS_CATEND pParams = (PEVENTPARAMS_CATEND)pvContext;

         OutputStuff(7, "OnCategorizeEnd server event triggered.\n");
         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->EndMessageCategorization(
                 pParams->pICatMailMsgs,
                 pParams->hrStatus);
             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
     {
         OutputStuff(7, "OnCategorizeBuildQuery server event triggered.\n");
         PEVENTPARAMS_CATBUILDQUERY pParams = (PEVENTPARAMS_CATBUILDQUERY)pvContext;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->BuildQuery(
                 pParams->pICatParams,
                 pParams->pICatItem);
             OutputStuff(7, "Sink returned hr %08lx\n", hr);

         } else {

             hr = S_OK;
         }

         if(hr != S_FALSE) {

             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }

         HRESULT hr;
         CHAR szQuery[1024];
         hr = pParams->pICatItem->GetStringA(
             ICATEGORIZERITEM_LDAPQUERYSTRING,
             1024,
             szQuery);
         if(SUCCEEDED(hr)) {
             OutputStuff(9, "Query built: %s\n", szQuery);
         } else {
             OutputStuff(7, "Warning: no query string set, hr %08lx\n", hr);
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
     {
         OutputStuff(7, "OnCategorizerBuildQueries server event triggered.\n");
         PEVENTPARAMS_CATBUILDQUERIES pParams = (PEVENTPARAMS_CATBUILDQUERIES)pvContext;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->BuildQueries(
                 pParams->pICatParams,
                 pParams->dwcAddresses,
                 pParams->rgpICatItems,
                 pParams->pICatQueries);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);

         } else {

             hr = S_OK;
         }

         if(hr != S_FALSE) {

             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }

         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
     {
         OutputStuff(7, "OnCategorizerSendQuery server event triggered.\n");
         PASYNCEVENTPARAMS pAEParams;
         PEVENTPARAMS_CATSENDQUERY pSQParams;

         pAEParams = (PASYNCEVENTPARAMS) new BYTE[sizeof(ASYNCEVENTPARAMS) + sizeof(EVENTPARAMS_CATSENDQUERY)];

         if(pAEParams == NULL) {
             OutputStuff(3, "Out of memory allocating EVENTPARAMS_CATSENDQUERY; returning error\n");
             return E_OUTOFMEMORY;
         }

         pSQParams = (PEVENTPARAMS_CATSENDQUERY) (pAEParams + 1);

         pAEParams->dwEventType = SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT;
         pAEParams->fDefaultProcessingCalled = FALSE;
         CopyMemory(pSQParams, pvContext, sizeof(EVENTPARAMS_CATSENDQUERY));

         //
         // Fill in SMTP SEO dispatcher part of pParams
         //
         pSQParams->pIMailTransportNotify = &g_CIMailTransportNotify;
         pSQParams->pvNotifyContext = pAEParams;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->SendQuery(
                 pSQParams->pICatParams,
                 pSQParams->pICatQueries,
                 pSQParams->pICatAsyncContext,
                 pSQParams);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         } else {
             hr = S_OK;
         }
         if((hr != S_FALSE) && (hr != MAILTRANSPORT_S_PENDING)) {

             OutputStuff(7, "Calling Default processing\n");
             pAEParams->fDefaultProcessingCalled = TRUE;
             hr = (*pSQParams->pfnDefault)(S_OK, pSQParams);
             OutputStuff(7, "Default processing returned hr %08lx\n", hr);
         }
         if(hr != MAILTRANSPORT_S_PENDING) {

             delete pAEParams;
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
     {
         OutputStuff(7, "OnCategorizerSortQueryResult server event triggered.\n");
         PEVENTPARAMS_CATSORTQUERYRESULT pParams = (PEVENTPARAMS_CATSORTQUERYRESULT)pvContext;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->SortQueryResult(
                 pParams->pICatParams,
                 pParams->hrResolutionStatus,
                 pParams->dwcAddresses,
                 pParams->rgpICatItems,
                 pParams->dwcResults,
                 pParams->rgpICatItemAttributes);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);

         } else {

             hr = S_OK;
         }

         if(hr != S_FALSE) {
             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
     {
         OutputStuff(7, "OnCategorizerProcessItem server event triggered.\n");
         PEVENTPARAMS_CATPROCESSITEM pParams = (PEVENTPARAMS_CATPROCESSITEM)pvContext;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->ProcessItem(
                 pParams->pICatParams,
                 pParams->pICatItem);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         }
         
         if(hr != S_FALSE) {
             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
     {
         OutputStuff(7, "OnCategorizerExpandItem server event triggered.\n");
         PASYNCEVENTPARAMS pAEParams;
         PEVENTPARAMS_CATEXPANDITEM pEIParams;

         pAEParams = (PASYNCEVENTPARAMS) new BYTE[sizeof(ASYNCEVENTPARAMS) + sizeof(EVENTPARAMS_CATEXPANDITEM)];

         if(pAEParams == NULL) {
             OutputStuff(3, "Out of memory allocating EVENTPARAMS_CATEXPANDITEM; returning error\n");
             return E_OUTOFMEMORY;
         }

         pEIParams = (PEVENTPARAMS_CATEXPANDITEM) (pAEParams + 1);

         pAEParams->dwEventType = SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT;
         pAEParams->fDefaultProcessingCalled = FALSE;
         CopyMemory(pEIParams, pvContext, sizeof(EVENTPARAMS_CATEXPANDITEM));

         //
         // Fill in SMTP SEO dispatcher part of pParams
         //
         pEIParams->pIMailTransportNotify = &g_CIMailTransportNotify;
         pEIParams->pvNotifyContext = pAEParams;

         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->ExpandItem(
                 pEIParams->pICatParams,
                 pEIParams->pICatItem,
                 &g_CIMailTransportNotify,
                 pAEParams);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         } else {
             hr = S_OK;
         }
         if((hr != S_FALSE) && (hr != MAILTRANSPORT_S_PENDING)) {
             OutputStuff(7, "Calling Default processing\n");
             pAEParams->fDefaultProcessingCalled = TRUE;
             hr = (*pEIParams->pfnDefault)(S_OK, pEIParams);
             OutputStuff(7, "Done calling default processing\n");
         }
         if(hr != MAILTRANSPORT_S_PENDING) {

             delete pAEParams;
         }
         break;
     }
     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
     {
         OutputStuff(7, "OnCategorizerCompleteitem server event triggered.\n");
         PEVENTPARAMS_CATCOMPLETEITEM pParams = (PEVENTPARAMS_CATCOMPLETEITEM)pvContext;
         
         if(m_pICatSink) {
             OutputStuff(7, "Calling sink processing\n");
             hr = m_pICatSink->CompleteItem(
                 pParams->pICatParams,
                 pParams->pICatItem);

             OutputStuff(7, "Sink returned hr %08lx\n", hr);
         }

         if(hr != S_FALSE) {
             OutputStuff(7, "Calling Default processing\n");
             (*pParams->pfnDefault)(S_OK, pParams);
             OutputStuff(7, "Done calling default processing\n");
         }
         break;
     }
     default:
     {
         OutputStuff(7, "Unknown server event %ld (0x%08lx) triggered\n", dwEventID, dwEventID);
     }
    }
    return (hr == MAILTRANSPORT_S_PENDING ? MAILTRANSPORT_S_PENDING : S_OK);
}

//
// CIMailTransportNotifyIMP
//

//+------------------------------------------------------------
//
// Function: CIMailTransportNotify constructor
//
// Synopsis: Initialize refcount
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/25 13:07:34: Created.
//
//-------------------------------------------------------------
CIMailTransportNotifyIMP::CIMailTransportNotifyIMP()
{
    m_lRef = 0;
    m_dwSignature = SIGNATURE_CIMAILTRANSPORTNOTIFYIMP;
}


//+------------------------------------------------------------
//
// Function: CIMailTransportNotify::~CIMailTransportNotify()
//
// Synopsis: 
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/09 22:27:11: Created.
//
//-------------------------------------------------------------
CIMailTransportNotifyIMP::~CIMailTransportNotifyIMP()
{
    _ASSERT(m_lRef == 0);

    _ASSERT(m_dwSignature == SIGNATURE_CIMAILTRANSPORTNOTIFYIMP);
    m_dwSignature = SIGNATURE_CIMAILTRANSPORTNOTIFYIMP_INVALID;
}

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ISMTPServer
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CIMailTransportNotifyIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        OutputStuff(7, "QI on IMailTransportNotify for IUnknown\n");
        *ppv = (LPVOID) this;
    } else if (iid == IID_IMailTransportNotify) {
        OutputStuff(7, "QI on IMailTransportNotify for IMailTransportNotify\n");
        *ppv = (LPVOID) this;
    } else {
        OutputStuff(3, "QI on IMailTransportNotify for unknown interface!\n");
        return E_NOINTERFACE;
    }

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CIMailTransportNotifyIMP::AddRef()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedIncrement(&m_lRef);

    OutputStuff(9, "AddRef called on IMailTransportNotify, count %ld\n", lNewRefCount);
    return lNewRefCount;
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero. 
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CIMailTransportNotifyIMP::Release()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedDecrement(&m_lRef);

    OutputStuff(9, "Release called on IMailTransportNotify, new refcount: %ld\n", lNewRefCount);

    if(lNewRefCount == 0) {
        return 0;
    } else {
        return lNewRefCount;
    }
}



//+------------------------------------------------------------
//
// Function: CIMailTransportNotifyIMP::Notify
//
// Synopsis: async completion of server event sink
//
// Arguments:
//  hrCompletion: S_FALSE: stop calling sinks, other: continue
//  pvContext: Context passed into sink
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/16 16:35:53: Created.
//
//-------------------------------------------------------------
HRESULT CIMailTransportNotifyIMP::Notify(
        IN  HRESULT hrCompletion,
        IN  PVOID pvContext)
{
    OutputStuff(7, "Notify called with hresult %08lx\n", hrCompletion);

    HRESULT hr = S_OK;
    PASYNCEVENTPARAMS pAEParams = (PASYNCEVENTPARAMS) pvContext;

    if((hrCompletion == S_OK) && (pAEParams->fDefaultProcessingCalled == FALSE)) {
        //
        // Call default processing
        //
        pAEParams->fDefaultProcessingCalled = TRUE;

        switch(pAEParams->dwEventType) {

         case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
         {
             PEVENTPARAMS_CATSENDQUERY pSQParams;
             pSQParams = (PEVENTPARAMS_CATSENDQUERY) (pAEParams + 1);

             OutputStuff(7, "Calling default processing for sendquery event\n");

             hr = (*pSQParams->pfnDefault) (S_OK, pSQParams);
             OutputStuff(7, "Default sendquery processing returned hr %08lx\n", hr);
             break;

         }

         case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
         {
             PEVENTPARAMS_CATEXPANDITEM pEIParams;
             pEIParams = (PEVENTPARAMS_CATEXPANDITEM) (pAEParams + 1);

             OutputStuff(7, "Calling default processing for expanditem event\n");

             hr = (*pEIParams->pfnDefault) (S_OK, pEIParams);
             OutputStuff(7, "Default expanditem processing returned hr %08lx\n", hr);
             break;
         }
         default:
             _ASSERT(0 && "Developer error");
        }
    }

    if(hr != MAILTRANSPORT_S_PENDING) {
        //
        // No more sinks to call, Call async completion routine of server event
        //
        switch(pAEParams->dwEventType) {

         case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
         {
             PEVENTPARAMS_CATSENDQUERY pSQParams;
             pSQParams = (PEVENTPARAMS_CATSENDQUERY) (pAEParams + 1);

             OutputStuff(7, "Calling sendquery completion routine\n");
             hr = (*pSQParams->pfnCompletion) (S_OK, pSQParams);
             OutputStuff(7, "sendquery completion returned hr %08lx\n", hr);
             break;

         }

         case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
         {
             PEVENTPARAMS_CATEXPANDITEM pEIParams;
             pEIParams = (PEVENTPARAMS_CATEXPANDITEM) (pAEParams + 1);

             OutputStuff(7, "Calling expanditem completion routine\n");
             hr = (*pEIParams->pfnCompletion) (S_OK, pEIParams);
             OutputStuff(7, "expanditem completion returned hr %08lx\n", hr);
             break;
         }
         default:
             _ASSERT(0 && "Developer error");
        }
        //
        // Release memory
        //
        delete pAEParams;
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CISMTPServerIMP::Init
//
// Synopsis: Load one categorizer sink and simulate firing events
//
// Arguments:
//  pszWCatProgID: ProgID of sink to load
//
// Returns:
//  S_OK: Success
//  or COM error
//
// History:
// jstamerj 1998/07/20 20:11:36: Created.
//
//-------------------------------------------------------------
HRESULT CISMTPServerIMP::Init(
    LPWSTR pszWCatProgID)
{
    HRESULT hr;
    CLSID clsidSink;

    if(pszWCatProgID) {

        hr = CLSIDFromProgID(pszWCatProgID, &clsidSink);

        if(FAILED(hr)) {

            OutputStuff(2, "Failed to get clised of sink hr %08lx\n"
                            "is %S registered on this machine?\n",
                        hr, pszWCatProgID);
            return hr;
        }

        hr = CoCreateInstance(
            clsidSink,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMailTransportCategorize,
            (LPVOID *) &m_pICatSink);

        if(FAILED(hr)) {

            m_pICatSink = NULL;
            OutputStuff(2, "Failed to create Sink - HR %08lx\n", hr);
            return hr;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\imsgerr.h $(O)\imsgerr.rc $(O)\msg00001.bin: $(STAXINC)\export\imsgerr.mc
    copy /a $(STAXINC)\export\imsgerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\imsgerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\imsgerr.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\cperfman.h ===
/************************************************************
 * FILE: cperfman.h
 * PURPOSE: Definition of the CPerfMan class.
 * HISTORY:
 *   // t-JeffS 970810 15:14:36: Created
 ************************************************************/
#ifndef _CPERFMAN_H
#define _CPERFMAN_H

#include <windows.h>
#include <winperf.h>
#include "csharmem.h"

/************************************************************
 * CLASS: CPerfMan
 * PURPOSE: Perform all the generic work an NT perf DLL normaly does.
 ************************************************************/
class CPerfMan {
 private:
   CSharedMem               m_cShare;
   DWORD                    m_dwNumCounters;
   LPTSTR                   m_pszAppName;
   LONG                     m_lRefCount;
   PPERF_OBJECT_TYPE        m_pObjectType;
   PPERF_COUNTER_DEFINITION m_pCounterDefs;
   DWORD                    m_cbDataDef;
   CRITICAL_SECTION         m_cs;

   BOOL      SetOffsets();
   ULONG     SizeOfPerformanceData() { return (m_dwNumCounters + 1)*sizeof(DWORD); }
   
 public:

   CPerfMan();
   ~CPerfMan();

   BOOL  Initialize( LPTSTR szAppName, PVOID pDataDef, DWORD dwNumCounters );
   DWORD OpenPerformanceData( LPWSTR lpDeviceNames );
   DWORD CollectPerformanceData( IN     LPWSTR  lpValueName,
                                 IN OUT LPVOID  *lppData,
                                 IN OUT LPDWORD lpcbTotalBytes,
                                 IN OUT LPDWORD lpNumObjectTypes);
   DWORD ClosePerformanceData();
};

#endif //_CPERFMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\cperfman.cpp ===
/************************************************************
 * FILE: CPerfMan.cpp
 * PURPOSE: Implementation of the CPerfMan class
 * HISTORY:
 *   // t-JeffS 970810 15:14:43: Created
 ************************************************************/

#include <windows.h>
#include <crtdbg.h>
#include "cperfman.h"
#include "perfskel.h"

extern "C" {
#include "perfutil.h"
}

/************************************************************
 * CLASS: CPerfMan
 * PURPOSE: Perform all the generic work an NT perf DLL normaly does.
 ************************************************************/


/************************************************************
 * FUNCTION: CPerfMan::CPerfMan
 * PURPOSE:  Initialize CPerfMan private data
 * HISTORY:
 *   // t-JeffS 970810 15:15:44: Created
 ************************************************************/
CPerfMan::CPerfMan() :
   m_dwNumCounters(0),
   m_pszAppName(NULL),
   m_lRefCount(0),
   m_pObjectType(NULL),
   m_pCounterDefs(NULL),
   m_cbDataDef(0)
{
   InitializeCriticalSection( &m_cs );
}

/************************************************************
 * FUNCTION: CPerfMan::~CPerfMan
 * PURPOSE:  Cleanup member data
 * HISTORY:
 *   // t-JeffS 970810 15:15:44: Created
 ************************************************************/
CPerfMan::~CPerfMan()
{
   DeleteCriticalSection( &m_cs );
   if( m_pszAppName )
      {
         delete m_pszAppName;
      }
}

/************************************************************
 * FUNCTION: CPerfMan::Initialize
 * PURPOSE:  Initialize and be ready for perf calls
 * PARAMETERS: szAppName: Unique name for each user of this class
 *             pDataDef:  Pointer to a skeleton data definition struct
 *                        for this group of counters.  See below for
 *                        general form of this struct
 *             dwNumCounters: Number of perf counters for this object.
 *        
 *             example data definition struct:
 *             typedef struct _AB_DATA_DEFINITON {
 *               PERF_OBJECT_TYPE        ABObjType;
 *               PERF_COUNTER_DEFINITION AB_Resolves_Counter;
 *               PERF_COUNTER_DEFINITION AB_ResolveCalls_Counter;
 *               PERF_COUNTER_DEFINITION AB_PassCalls_Counter;
 *               PERF_COUNTER_DEFINITION AB_FailCalls_Counter;
 *             };
 *             And in this case, dwNumCounters = 4;
 *             Caller should initialize all offsets in
 *             PERF_COUNTER_DEFINITION blocks to be relative to object
 *             type (see dataab.h/dataab.cpp in abook for an example)
 *             Also assumes each counter size is sizeof(DWORD)
 * HISTORY:
 *   // t-JeffS 970810 15:15:44: Created
 ************************************************************/
BOOL CPerfMan::Initialize( LPTSTR szAppName, PVOID pDataDef, DWORD dwNumCounters )
{
   _ASSERT( szAppName );
   _ASSERT( pDataDef  );
   _ASSERT( dwNumCounters > 0 );

   m_pszAppName = new TCHAR[ lstrlen( szAppName) + 1];
   if(! m_pszAppName )
      {
         // Set error out of memory
         return FALSE;
      }
   lstrcpy( m_pszAppName, szAppName );

   m_dwNumCounters = dwNumCounters;
   m_pObjectType  = (PPERF_OBJECT_TYPE) pDataDef;
   m_pCounterDefs = (PPERF_COUNTER_DEFINITION) &m_pObjectType[1];
   m_cbDataDef = sizeof(PERF_OBJECT_TYPE) + (dwNumCounters *
                                             sizeof(PERF_COUNTER_DEFINITION));
   return SetOffsets();
}

/************************************************************
 * Function: CPerfMan::SetOffsets()
 * Purpose:  Increment offsets in data definition block
 * Arguments: None; uses member data.
 * History:
 *   // t-JeffS 970810 15:40:33: Created
 ************************************************************/
BOOL CPerfMan::SetOffsets()
{
   // Get stuff from registry

   // get counter and help index base values from registry
   //		Open key to registry entry
   //		read First Counter and First Help values
   //		update static data structures by adding base to
   //			offset value in structure

   HKEY hRegKey;
   TCHAR  szRegKey[256];
   lstrcpy(szRegKey, TEXT("SYSTEM\\CurrentControlSet\\Services\\"));
   lstrcat(szRegKey, m_pszAppName );
   lstrcat(szRegKey, TEXT("\\Performance"));

   if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                     szRegKey,
                     0L,
                     KEY_ALL_ACCESS,
                     &hRegKey ) !=
       ERROR_SUCCESS)
      {
         return FALSE;
      }

   DWORD dwFirstCounter;
   DWORD dwFirstHelp;
   DWORD dwsize = sizeof(DWORD);
   DWORD dwtype;
   if( RegQueryValueEx(	hRegKey,
                        TEXT("First Counter"),
                        0L,
                        &dwtype,
                        (LPBYTE)&dwFirstCounter,
                        &dwsize	) !=
       ERROR_SUCCESS)
      {
         return FALSE;
      }

   dwsize = sizeof(DWORD);
   if( RegQueryValueEx(	hRegKey,
                        "First Help",
                        0L,
                        &dwtype,
                        (LPBYTE)&dwFirstHelp,
                        &dwsize	) !=
       ERROR_SUCCESS)
      {
         return FALSE;
      }

   //
   // Now adjust the perf datadef structure
   //

   m_pObjectType->ObjectNameTitleIndex += dwFirstCounter;
   m_pObjectType->ObjectHelpTitleIndex += dwFirstHelp;

   DWORD dwCount;
   for(dwCount = 0; dwCount < m_dwNumCounters; dwCount++)
      {
         m_pCounterDefs[dwCount].CounterNameTitleIndex += dwFirstCounter;
         m_pCounterDefs[dwCount].CounterHelpTitleIndex += dwFirstHelp;
      }
   RegCloseKey(hRegKey);
   return TRUE;
}


/************************************************************
 * FUNCTION: CPerfMan::OpenPerformanceData
 * PURPOSE:  Do leg work of a generic openperfdata call
 * ARGUMENTS: lpDeviceNames: 
 * HISTORY:	Pointer to object ID of each device to be opened ( not used here)
 *   // t-JeffS 970810 16:19:10: Created
 ************************************************************/
DWORD CPerfMan::OpenPerformanceData( LPWSTR lpDeviceNames )
{
   //EnterCriticalSection( &m_cs );

   if( m_lRefCount == 0)
      { // We're the first instance to use this, initialize stuff
         if( ! m_cShare.Initialize( m_pszAppName, FALSE, m_dwNumCounters * sizeof(DWORD)) )
            {
               // Init failed
               //LeaveCriticalSection( &m_cs );
               return ERROR_SERVICE_DOES_NOT_EXIST;
            }
         
      }
   m_lRefCount++;
   //LeaveCriticalSection( &m_cs );

   return ERROR_SUCCESS;
}

/************************************************************
 * FUNCTION:  CPerfMan::CollectPerformanceData
 * PURPOSE:   Do leg work of collecting performance data from shared mem
 * ARGUMENTS: lpValueName: The name of the value to retrieve
 *            lppData: On entry contains a pointer to the buffer to
 *                     receive the completed PerfDataBlock & subordinate
 *                     structures.  On exit, points to the first bytes
 *                     *after* the data structures added by this routine.
 *            lpcbTotalBytes: On entry contains a pointer to the
 *                     size (in BYTEs) of the buffer referenced by lppData.
 *                     On exit, contains the number of BYTEs added by this
 *                     routine.
 *            lpNumObjectTypes: Receives the number of objects added
 *                              by this routine.
 ************************************************************/
DWORD CPerfMan::CollectPerformanceData( 
   IN LPWSTR  lpValueName,
   IN OUT LPVOID  *lppData,
   IN OUT LPDWORD lpcbTotalBytes,
   OUT LPDWORD lpNumObjectTypes)
{
   DWORD dwQueryType;
   dwQueryType = GetQueryType(lpValueName);

   if (dwQueryType == QUERY_FOREIGN ) {
      
      // this routine doesn't service requests for data from
      // foreign computers
      
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_SUCCESS;
   }

   //
   // check to see if this object is requested
   //
   if (dwQueryType == QUERY_ITEMS) {
      if ( !(IsNumberInUnicodeList(	m_pObjectType->ObjectNameTitleIndex,
                                    lpValueName ) ) ) 
         {
			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes = (DWORD) 0;
			return ERROR_SUCCESS;
         }
   }
   ULONG ulSpaceNeeded = m_cbDataDef + ( SizeOfPerformanceData() );

   if ( *lpcbTotalBytes < ulSpaceNeeded ) {
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_MORE_DATA;
   }

   // 
   // have a local pointer point to the buffer
   //
   PVOID pDataDef = *lppData;
   
   //
   // copy the pre-prepared constant data to the buffer
   //
   CopyMemory(  pDataDef, m_pObjectType, m_cbDataDef);

   //
   // Format and collect data from shared memory
   //
   PPERF_COUNTER_BLOCK pPerfCounterBlock = (PERF_COUNTER_BLOCK *) ((PBYTE)pDataDef + m_cbDataDef);
   pPerfCounterBlock->ByteLength = SizeOfPerformanceData();
   PBYTE pbCounter = (PBYTE)(&pPerfCounterBlock[1]);

   // Get all the counters direct from shared memory
   if( !m_cShare.GetMem( 0, pbCounter, SizeOfPerformanceData() - sizeof(DWORD) ))
      {
         return GetLastError(); // some error
      }
   // Update arguments before returning
   *lppData = (PVOID) (pbCounter + SizeOfPerformanceData() - sizeof(DWORD));
   *lpNumObjectTypes = 1;
   *lpcbTotalBytes = (PBYTE) *lppData - (PBYTE) pDataDef;

   return ERROR_SUCCESS;
}

/************************************************************
 * FUNCTION: CPerfMan::ClosePerformanceData
 * PURPOSE:  Do the leg work of closing performance data
 * ARGUMENTS: None
 * HISTORY:
 *   // t-JeffS 970810 17:00:03: Created
 ************************************************************/
DWORD CPerfMan::ClosePerformanceData()
{
   //EnterCriticalSection( &m_cs );

   if( m_lRefCount == 1)
      {
         // Clean up.
         // okay...uh...nothing to do.
      }
   m_lRefCount--;

   //LeaveCriticalSection( &m_cs );
   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\perfskel.cpp ===
/************************************************************
 * FILE: perfskel.cpp
 * PURPOSE: Provide a basic skeleton for an app using CPerfMan
 * HISTORY:
 *   // t-JeffS 970810 18:09:07: Created
 ************************************************************/

#include <windows.h>

#include "perfskel.h"
//
// Function Prototypes
//
//		These are used to insure that the data collection functions
//		accessed by Perflib will have the correct calling format
//

DWORD APIENTRY
OpenPerformanceData( LPWSTR lpDeviceNames )
/*
Routine Description

	This routine will open and map the memory used by the counter
	to pass performance data in.

Arguments:

	Pointer to object ID of each device to be opened ( not used here)

Returned Value:

	None.
--*/
{
	return g_cperfman.OpenPerformanceData( lpDeviceNames );
}

DWORD APIENTRY
CollectPerformanceData(	IN		LPWSTR	lpValueName,
                        IN OUT	LPVOID	*lppData,
                        IN OUT	LPDWORD	lpcbTotalBytes,
                        IN OUT	LPDWORD	lpNumObjectTypes	)
/*
Routine Description

	This routine will return the data for the counters

Arguments:

	lpValueName - The name of the value to retrieve.

    lppData - On entry contains a pointer to the buffer to
              receive the completed PerfDataBlock & subordinate
              structures.  On exit, points to the first bytes
              *after* the data structures added by this routine.

    lpcbTotalBytes - On entry contains a pointer to the
              size (in BYTEs) of the buffer referenced by lppData.
              On exit, contains the number of BYTEs added by this
              routine.

    lpNumObjectTypes - Receives the number of objects added
              by this routine.

Returned Value:

	ERROR_MORE_DATA if buffer passed is too small to hold data
	ERRROR_SUCCESS	if success

--*/
{
	return g_cperfman.CollectPerformanceData( lpValueName, lppData, lpcbTotalBytes, lpNumObjectTypes );
}

DWORD APIENTRY
ClosePerformanceData()
{
	return g_cperfman.ClosePerformanceData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\catcons\src\ismtpsvr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ismtpsvr.h
//
// Contents: Class to fake out categorizer and implement ISMTPServer
//
// Classes: CISMTPServerIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 12:59:15: Created.
//
//-------------------------------------------------------------
#include "mailmsg.h"
#include <smtpevent.h>
#include <smtpseo.h>

#define SIGNATURE_CISMTPSERVER         (DWORD)'ISSE'
#define SIGNATURE_CISMTPSERVER_INVALID (DWORD)'XSSE'

class CISMTPServerIMP : public ISMTPServer
{
  public:
    CISMTPServerIMP();
    ~CISMTPServerIMP();

  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ISMTPServer
    STDMETHOD(AllocMessage)(
        OUT  IMailMsgProperties **ppMsg)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(SubmitMessage)(
        IN   IMailMsgProperties *pMsg)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(TriggerLocalDelivery)(
        IN    IMailMsgProperties *pMsg,
        IN    DWORD dwRecipientCount,
        IN    DWORD *pdwRecipIndexes)
    {
        return E_NOTIMPL;
    }

	STDMETHOD(ReadMetabaseString)(
        IN     DWORD MetabaseId, 
        IN OUT unsigned char * Buffer, 
        IN OUT DWORD * BufferSize, 
        IN     BOOL fSecure)
    {
        return E_NOTIMPL;
    }

	STDMETHOD(ReadMetabaseDword)(
        IN     DWORD MetabaseId, 
        OUT    DWORD * dwValue)
    {
        return E_NOTIMPL;
    }

	STDMETHOD(ServerStartHintFunction) ()
    {
        return E_NOTIMPL;
    }
	STDMETHOD(ServerStopHintFunction) ()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(TriggerServerEvent)(
        IN     DWORD dwEventID,
        IN     PVOID pvContext);

    STDMETHOD(WriteLog)(
        IN     LPMSG_TRACK_INFO pMsgTrackInfo,
        IN     IMailMsgProperties *pMsg,
        IN     LPEVENT_LOG_INFO pEventLogInfo,
        IN     LPSTR pszProtocolLog)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(ReadMetabaseData)(
        IN     DWORD MetabaseId,
        OUT    BYTE *Buffer,
        IN OUT DWORD * BufferSize)
    {
        return E_NOTIMPL;
    }

  public:
    // CatCons useage functions
    HRESULT Init(LPWSTR pszWCatProgID);

  private:
    DWORD m_dwSignature;
    LONG m_lRef;
    
    IMailTransportCategorize *m_pICatSink;
};

    
class CIMailTransportNotifyIMP : public IMailTransportNotify
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //IMailTransportNotify
    STDMETHOD (Notify) (
        IN  HRESULT hrCompletion,
        IN  PVOID pvContext);

  public:
    CIMailTransportNotifyIMP();
    ~CIMailTransportNotifyIMP();

  private:
    #define SIGNATURE_CIMAILTRANSPORTNOTIFYIMP          (DWORD) 'MTNo'
    #define SIGNATURE_CIMAILTRANSPORTNOTIFYIMP_INVALID  (DWORD) 'XTNo'

    DWORD m_dwSignature;
    LONG m_lRef;
};

typedef struct _tagAsyncEventParams {

    DWORD dwEventType;
    BOOL fDefaultProcessingCalled;

} ASYNCEVENTPARAMS, *PASYNCEVENTPARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\csharmem.h ===
/************************************************************
 * FILE: perf.h: Definition of CPerfShare class
 * HISTORY:
 *   // t-JeffS 970810 13:40:06: Created
 ************************************************************/

#ifndef _CSHAREMEM_H
#define _CSHAREMEM_H

#include <windows.h>


/************************************************************
 * Class: CPerfShare
 * Purpose: Handles shared memory for abook perfdata
 * History:
 *   // t-JeffS 970810 13:40:37: Created
 ************************************************************/

class CSharedMem {

 private:
   BOOL                 m_fInitOkay;

   HANDLE               m_hSharedMemory;
   PBYTE                m_pbMem;         // Ptr to mapped memory
   HANDLE               m_hMutex;
   DWORD                m_dwSize;        // Size of memory in block

 public:
   CSharedMem();
   ~CSharedMem();

   VOID Zero() {
       ZeroMemory( m_pbMem, m_dwSize );
   }

   BOOL Initialize( LPTSTR szName, BOOL bExists, DWORD dwSize);
   BOOL GetMem( DWORD dwOffset, PBYTE pb, DWORD dwSize);
   BOOL SetMem( DWORD dwOffset, PBYTE pb, DWORD dwSize);

   BOOL SetDWORD( DWORD dwOffset, DWORD dwVal )
   {
      return SetMem( dwOffset * sizeof(DWORD), (PBYTE)&dwVal, sizeof(DWORD));
   }
   BOOL GetDWORD( DWORD dwOffset, PDWORD pdwVal )
   {
      return GetMem( dwOffset * sizeof(DWORD), (PBYTE)pdwVal, sizeof(DWORD));
   }
   // Increment DWORD.  NOTE: Offset is offset in dwords, not bytes.
   LONG IncrementDW( DWORD dwOffset )
   {
      return InterlockedIncrement( (LPLONG) m_pbMem + dwOffset );
   }
   // Decrement DWORD.  NOTE: Offset is offset in dwords, not bytes.
   LONG DecrementDW( DWORD dwOffset )
   {
      return InterlockedDecrement( (LPLONG) m_pbMem + dwOffset );
   }
   // Add a value to a dword
   LONG ExchangeAddDW( DWORD dwOffset, LONG lInc )
   {
      return InterlockedExchangeAdd( (LPLONG) m_pbMem + dwOffset, lInc);
   }

};

#endif //_CSHAREMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\csharmem.cpp ===
/************************************************************
 * FILE: perf.h: Implementation of CSharedMem class
 * HISTORY:
 *   // t-JeffS 970810 13:40:06: Created
 ************************************************************/

#include <windows.h>
#include <crtdbg.h>


/************************************************************
 * Class: CSharedMem
 * Purpose: Handles shared memory for abook perfdata
 * History:
 *   // t-JeffS 970810 13:40:37: Created
 ************************************************************/

#include "csharmem.h"

/************************************************************
 * Function: CSharedMem::CSharedMem
 * Purpose:  Initialize member variables to default values
 * History:
 *   // t-JeffS 970810 13:47:49: Created
 ************************************************************/

CSharedMem::CSharedMem() :
   m_fInitOkay(FALSE),
   m_hSharedMemory(NULL),
   m_pbMem(NULL),
   m_hMutex(NULL),
   m_dwSize(0)
{
}

/************************************************************
 * Function: CSharedMem::~CSharedMem
 * Purpose:  Clean up.
 * History:
 *   // t-JeffS 970810 13:50:24: Created
 ************************************************************/
CSharedMem::~CSharedMem()
{
   if( m_pbMem )
      {
         UnmapViewOfFile( (PVOID) m_pbMem );
         CloseHandle( m_hSharedMemory );
         CloseHandle( m_hMutex );
      }
}

/************************************************************
 * Function: CSharedMem::Initialize
 * Purpose:  Open shared memory, return status
 * Parameters: szName: Name everyone who uses this shared memory will
 *                     provide.
 *             bExists: If TRUE, Shared mem is assumed to already
 *                      exist, fail if it doesn't.
 *             dwSize: Amount of shared memory to use, in bytes.
 *
 * History:
 *   // t-JeffS 970810 13:51:16: Created
 ************************************************************/
BOOL CSharedMem::Initialize( LPTSTR szName, BOOL bExists, DWORD dwSize )
{
   _ASSERT( szName );
   LPTSTR szMutexName;
   BOOL   bWeCreated = FALSE;

   szMutexName = new TCHAR[ lstrlen(szName) + 6];
   if( ! szMutexName )
      {
         SetLastError( ERROR_OUTOFMEMORY );
         return FALSE;
      }
   lstrcpy( szMutexName, szName );
   lstrcat( szMutexName, "Mutex");

   //
   // Open mutex object, when this dll is loaded and run in
   // the perfmon's process, the AB object should already
   // exist and the mutex object should already exist
   //
   m_hMutex = CreateMutex(	NULL,
                            FALSE,
                            szMutexName	);
   if ( !m_hMutex )
      {
         delete szMutexName;
         return FALSE;
      }
   if( GetLastError() != ERROR_ALREADY_EXISTS)
      {
         if( bExists )
            {
               // mutex didn't already exist, so fail.
               delete szMutexName;
               SetLastError(ERROR_FILE_NOT_FOUND);
               return FALSE;
            }
         bWeCreated = TRUE;
      }
   delete szMutexName;
   
   // Shared memory time
   LPTSTR szSharedMemName;

   szSharedMemName = new TCHAR[ lstrlen(szName) + 4];
   if( !szSharedMemName )
      {
         SetLastError(ERROR_OUTOFMEMORY);
         return FALSE;
      }
   lstrcpy( szSharedMemName, szName );
   lstrcat( szSharedMemName, "Map");

   m_hSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                        NULL,
                                        PAGE_READWRITE,
                                        0,
                                        dwSize,
                                        szSharedMemName );

   if ( m_hSharedMemory == NULL ) 
      {
         delete szSharedMemName;
         return FALSE;
      }

   delete szSharedMemName;

   //
   // map pointer to the memory
   //
   m_pbMem = (PBYTE)
             MapViewOfFile(	m_hSharedMemory,
                            FILE_MAP_ALL_ACCESS,
                            0,
                            0,
                            0	);
   if ( m_pbMem == NULL ) 
      {
         return FALSE;
      }

   m_dwSize = dwSize;

   // If we created this thing, initialize all bytes to zero.
   // Possible race condition, but harmless.
   if( bWeCreated )
      {
         Zero();
      }

   m_fInitOkay = TRUE;

   return TRUE;
}

/************************************************************
 * Function: CSharedMem::GetMem
 * Purpose:  Reads from Shared memory
 * Parameters: dwOffset: offset in bytes from beginning of block
 *             pb: buffer to copy data to
 *             dwSize: how many bytes to copy
 * History:
 *   // t-JeffS 970810 13:51:16: Created
 ************************************************************/
BOOL CSharedMem::GetMem( DWORD dwOffset, PBYTE pb, DWORD dwSize)
{
   if( ! m_fInitOkay ) return FALSE;

   if( dwOffset + dwSize > m_dwSize )
      {
         SetLastError(ERROR_BAD_COMMAND);
         // Set error, out of bounds
         return FALSE;
      }
   if( WaitForSingleObject( m_hMutex, INFINITE ) == WAIT_FAILED )
      {
         // Set error, mutex died
         return FALSE;
      }
   CopyMemory( pb, m_pbMem + dwOffset, dwSize );
   ReleaseMutex( m_hMutex );

   return TRUE;
}

/************************************************************
 * Function: CSharedMem::SetMem
 * Purpose:  Writes to Shared memory
 * Parameters: dwOffset: offset in bytes from beginning of block
 *             pb: buffer to copy data from
 *             dwSize: how many bytes to copy
 * History:
 *   // t-JeffS 970810 13:51:16: Created
 ************************************************************/
BOOL CSharedMem::SetMem( DWORD dwOffset, PBYTE pb, DWORD dwSize )
{
   if( ! m_fInitOkay ) return FALSE;

   if( dwOffset + dwSize > m_dwSize )
      {
         SetLastError(ERROR_BAD_COMMAND);
         // Set error, out of bounds
         return FALSE;
      }
   if( WaitForSingleObject( m_hMutex, INFINITE ) == WAIT_FAILED )
      {
         // Set error, mutex died
         return FALSE;
      }
   CopyMemory( m_pbMem + dwOffset, pb, dwSize );
   ReleaseMutex( m_hMutex );

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\perfskel.h ===
/************************************************************
 * FILE: perfskel.h
 * PURPOSE: Provide a basic skeleton for apps using CPerfMan
 * HISTORY:
 *   // t-JeffS 970810 18:11:10: Created
 ************************************************************/
#ifndef _PERFSKEL_H
#define _PERFSKEL_H

#include "cperfman.h"

// Global CPerfMan object used in our 3 Calls
// Created here as a global, but user of this lib MUST call Initialize
// on it before it is used (ie. do it in DllMain)

#ifdef PERFSHAR_LIB
CPerfMan g_cperfman;
#else
extern CPerfMan g_cperfman;
#endif

PM_OPEN_PROC	OpenabPerformanceData;
PM_COLLECT_PROC CollectabPerformanceData;
PM_CLOSE_PROC	CloseabPerformanceData;

extern DWORD APIENTRY OpenPerformanceData( LPWSTR lpDeviceNames );
extern DWORD APIENTRY CollectPerformanceData(
	IN		LPWSTR	lpValueName,
    IN OUT	LPVOID	*lppData,
    IN OUT	LPDWORD	lpcbTotalBytes,
    IN OUT	LPDWORD	lpNumObjectTypes	);
extern DWORD APIENTRY ClosePerformanceData();


#endif //_PERFSKEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\b64octet.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: b64octet.cpp 
//
//  Description:  Implementation of Base64 encoding stream designed for use
//      with UTF7 encoding.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//Alphabet for BASE64 encoding as defined in RFC1421 and RFC1521
CHAR g_rgchBase64[64] = 
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const DWORD BASE64_OCTET_STATE_0_BITS   = 0;
const DWORD BASE64_OCTET_STATE_2_BITS   = 1;
const DWORD BASE64_OCTET_STATE_4_BITS   = 2;
const DWORD BASE64_NUM_STATES           = 3;

//---[ CBase64OctetStream::CBase64OctetStream ]--------------------------------
//
//
//  Description: 
//      Default contructor for CBase64OctetStream
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CBase64OctetStream::CBase64OctetStream()
{
    m_dwSignature = BASE64_OCTET_SIG;
    m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
    m_bCurrentLeftOver = 0;
}

//---[ CBase64OctetStream::NextState ]------------------------------------------
//
//
//  Description: 
//      Moves the internal state machine to the next state
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CBase64OctetStream::NextState()
{
    m_dwCurrentState++;
    if (BASE64_NUM_STATES == m_dwCurrentState)
    {
        m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
        m_bCurrentLeftOver = 0;
    }
}

//---[ CBase64OctetStream::ResetState ]----------------------------------------
//
//
//  Description: 
//      Resets the internal state machine
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CBase64OctetStream::ResetState()
{
    m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
    m_bCurrentLeftOver = 0;
}

//---[ CBase64OctetStream::fProcessWideChar ]----------------------------------
//
//
//  Description: 
//      Processes a single wide character and stores the results in its 
//      buffer.  It will also ensure that there is always enough room to 
//      safely calll TerminateStream.
//  Parameters:
//      IN      wch     UNICODE character to process
//  Returns:
//      TRUE    if there is enough room in the buffer to convert this char
//      FALSE   if there is not enough room to conver this char safely
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fProcessWideChar(WCHAR wch)
{
    BYTE   bHigh = HIBYTE(wch);
    BYTE   bLow  = LOBYTE(wch);
    //At most... a single WCHAR will generate 3 base64 characters evenly or 2
    //base64 characters plus a remainder which can be expanded to 
    //3 more characters (with trailing "==")
    if (m_CharBuffer.cSpaceLeft() < 5)
        return FALSE;

    //We know we have enough room to safely convert this character.... we 
    //will _VERIFY all PushChar's.

    //Loop through bytes in WCHAR
    _VERIFY(fProcessSingleByte(bHigh));
    _VERIFY(fProcessSingleByte(bLow));
    return TRUE;
}

//---[ CBase64OctetStream::fProcessSingleByte ]--------------------------------
//
//
//  Description: 
//      Does the actual work of converting a single byte to the appropriate 
//      base64 char(s).  Also keeps track of state.
//  Parameters:
//      IN b   BYTE to convert
//  Returns:
//      TRUE if there is enough room for the conversion
//      FALSE otherwise
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fProcessSingleByte(BYTE b)
{
    const BYTE BASE64_MASK = 0x3F; //can only use 6 bits in Base64

    BOOL fRet = TRUE;
    if (m_CharBuffer.fIsFull())
        return FALSE;

    switch (m_dwCurrentState)
    {
        case BASE64_OCTET_STATE_0_BITS:
            //There were no bits left from previous state
            m_bCurrentLeftOver = b & 0x03; //there will now be 2 bits left over
            m_bCurrentLeftOver <<= 4; //shift to MSB in six bits
            _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & (b >> 2)]));
            NextState();
            break;
        case BASE64_OCTET_STATE_2_BITS:
            //There were 2 bits left from previous state.. 
            m_bCurrentLeftOver += (0x0F & (b >> 4));
            _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & m_bCurrentLeftOver]));

            //we will leave 4 low bits over
            m_bCurrentLeftOver = 0x0F & b;
            m_bCurrentLeftOver <<= 2; //shift to MSB is six bit grouping
            NextState();
            break;
        case BASE64_OCTET_STATE_4_BITS:
            //There were 4 bits left over
            if (m_CharBuffer.cSpaceLeft() < 2)
            {
                //There is not enough room for both characters we would push...
                //so don't process byte at all. 
                //Do not move to the next state... do not collection $200.
                fRet = FALSE;
            }
            else
            {
                m_bCurrentLeftOver += (0x03 & (b >> 6));
                _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & m_bCurrentLeftOver]));
                m_bCurrentLeftOver = 0;
                _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & b]));
                NextState();
            }
            break;
        default:
            _ASSERT(0 && "Invalid State");
    }
    return fRet;
}

//---[ CBase64OctetStream::cTerminateStream ]----------------------------------
//
//
//  Description: 
//      Used to signal the termination of the current stream.  Resets the 
//      state as performs any padding necessary
//  Parameters:
//      IN  fUTF7Encoded    TRUE if the stream is UTF7 encoded (does not 
//                          require '=' padding).
//  Returns:
//      TRUE if there is anything left in the buffer.
//      FALSE if there are no characters left to convert
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fTerminateStream(BOOL fUTF7Encoded)
{
    if (BASE64_OCTET_STATE_0_BITS != m_dwCurrentState)
    {
        //There should always be space left to do this
        _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[m_bCurrentLeftOver]));
        if (!fUTF7Encoded)
        {
            switch(m_dwCurrentState)
            {
                case BASE64_OCTET_STATE_2_BITS:
                    //There are 2 bits in this byte we did not use... which 
                    //means that there are 2 more base64 chars to fill 24 bits
                    //+ => Used bits
                    //- => Unused (but parsed) bits
                    //? => Unseed bits to fill out to 24 bits
                    //++++ ++-- ???? ???? ???? ????
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    break;
                case BASE64_OCTET_STATE_4_BITS:
                    //In these chase there is only 1 extra base64 char needed
                    //++++ ++++ ++++ ---- ???? ????
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    break;
            }
        }
    }
    ResetState();
    return (!m_CharBuffer.fIsEmpty());
}

//---[ CBase64OctetStream::fNextValidChar ]------------------------------------
//
//
//  Description: 
//      Iterates over buffered converted characters
//  Parameters:
//      OUT pch     Next buffer char
//  Returns:
//      TRUE    If there is a character to get
//      FALSE   If there were no characters to get
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fNextValidChar(CHAR *pch)
{
    _ASSERT(pch);
    return m_CharBuffer.fPopChar(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\b64octet.h ===
//-----------------------------------------------------------------------------
//
//
//  File: B64Octet.h
//
//  Description:  Octet-Stream based processing of UNICODE characters. 
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __B64OCTET_H__
#define __B64OCTET_H__

#include <windows.h>
#include <dbgtrace.h>

//Buffer size to store conversions... 
//should be no less than 6... multples of 8
//Reasons... we need to be able to fit an entire wide character in buffer.
//Each wide character coverts to 2 1/3 base64 'digits'... plus the possibility
//of 2 more filler characters.  We need 5 characters plus a buffer char to 
//store a single wide char. A 'even' number of WCHAR is 3 (2 1/3 * 3 = 7), 
//which requires 7 base64 digits to encode (plus buffer).
#define BASE64_OCTET_BUFFER_SIZE    9
#define BASE64_OCTET_SIG            '46Bc'
#define BASE64_INVALID_FILL_CHAR    '!'

class CBase64CircularBuffer
{
  private:
    DWORD       m_iHead;
    DWORD       m_iTail;
    CHAR        m_rgchBuffer[BASE64_OCTET_BUFFER_SIZE];
  public:
    CBase64CircularBuffer();
    DWORD       cSize();
    DWORD       cSpaceLeft();
    BOOL        fIsFull();
    BOOL        fIsEmpty();
    BOOL        fPushChar(CHAR ch);
    BOOL        fPopChar(CHAR *pch);
};

class CBase64OctetStream
{
  protected:
    DWORD                   m_dwSignature;
    DWORD                   m_dwCurrentState;
    BYTE                    m_bCurrentLeftOver;
    CBase64CircularBuffer   m_CharBuffer;
    void                    NextState();
    void                    ResetState();
  public:
    CBase64OctetStream();

    //returns FALSE when buffer is full
    BOOL                    fProcessWideChar(WCHAR wch); 
    BOOL                    fProcessSingleByte(BYTE b);

    //The following will terminate the stream a zero-fill any remaining chars
    BOOL                    fTerminateStream(BOOL fUTF7Encoded);

    //returns FALSE when buffer is empty
    BOOL                    fNextValidChar(CHAR *pch) ;
};


//inline functions that implement circular buffer
inline CBase64CircularBuffer::CBase64CircularBuffer()
{
    m_iHead = 0;
    m_iTail = 0;
    memset(&m_rgchBuffer, BASE64_INVALID_FILL_CHAR, BASE64_OCTET_BUFFER_SIZE);
}

inline DWORD CBase64CircularBuffer::cSize()
{
    if (m_iHead <= m_iTail)
        return m_iTail - m_iHead;
    else
        return m_iTail + BASE64_OCTET_BUFFER_SIZE - m_iHead;
}

inline DWORD CBase64CircularBuffer::cSpaceLeft()
{
    return BASE64_OCTET_BUFFER_SIZE - cSize() - 1;
}

inline BOOL CBase64CircularBuffer::fIsFull()
{
    return ((BASE64_OCTET_BUFFER_SIZE-1) == cSize());
}

inline BOOL CBase64CircularBuffer::fIsEmpty() 
{
    return (m_iHead == m_iTail);
}

inline BOOL CBase64CircularBuffer::fPushChar(CHAR ch)
{
    if (fIsFull())
        return FALSE;
    
    m_rgchBuffer[m_iTail] = ch;
    m_iTail++;
    m_iTail %= BASE64_OCTET_BUFFER_SIZE;
    return TRUE;
}

inline BOOL CBase64CircularBuffer::fPopChar(CHAR *pch)
{
    _ASSERT(pch);
    if (fIsEmpty())
        return FALSE;
    
    *pch = m_rgchBuffer[m_iHead];
    _ASSERT(BASE64_INVALID_FILL_CHAR != *pch);
    m_rgchBuffer[m_iHead] = BASE64_INVALID_FILL_CHAR;
    m_iHead++;
    m_iHead %= BASE64_OCTET_BUFFER_SIZE;
    return TRUE;
}

#endif //__B64OCTET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\utest\perfshar\perfutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.c

   Abstract:

      This file implements the utility routines used for all perfmon 
       interface dlls in the internet services group.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Nov-1995  
          Pulled from  perfmon interface common code.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();
        VOID  MonBuildInstanceDefinition();

   Revision History:

       Sophia Chung (sophiac)  05-Nov-1996
          Added routine to support multiple instances

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include "winperf.h"
#include "perfutil.h"



/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


/************************************************************
 *    Functions 
 ************************************************************/



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}



BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    )
/*++

MonBuildInstanceDefinition  

    Build an instance of an object

Arguments:

    OUT pBuffer         -   pointer to buffer where instance is to
                            be constructed

    OUT pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

    IN  ParentObjectTitleIndex
                        -   Title Index of parent object type; 0 if
                            no parent object

    IN  ParentObjectInstance
                        -   Index into instances of parent object
                            type, starting at 0, for this instances
                            parent object instance

    IN  UniqueID        -   a unique identifier which should be used
                            instead of the Name for identifying
                            this instance

    IN  Name            -   Name of this instance

Return Value:

    None.

--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    return;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnbuff.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnbuff
//
//  Description: Header file for CDSNBuffer.  Class used to abstract writting
//      DSN buffers to P2 file.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNBUFF_H__
#define __DSNBUFF_H__

#include <windows.h>
#include <dbgtrace.h>
#include "filehc.h"
#include "dsnconv.h"

#define DSN_BUFFER_SIG  'BNSD'
#define DSN_BUFFER_SIZE 1000  

class CDSNBuffer 
{
  public:
    DWORD       	m_dwSignature;
    OVERLAPPED  	m_overlapped;
    DWORD       	m_cbOffset;
    DWORD       	m_cbFileSize;
    DWORD       	m_cFileWrites;
    PFIO_CONTEXT	m_pDestFile;
    BYTE        	m_pbFileBuffer[DSN_BUFFER_SIZE];

    CDSNBuffer();
    ~CDSNBuffer();
    HRESULT     HrInitialize(PFIO_CONTEXT hDestFile);
    HRESULT     HrWriteBuffer(BYTE *pbInputBuffer, DWORD cbInputBuffer);
    HRESULT     HrFlushBuffer(OUT DWORD *pcbFileSize);
    HRESULT     HrSeekForward(IN DWORD cbBytesToSeek, OUT DWORD *pcbFileSize);

    //Used to set (and reset) custom conversion contexts.  This feature was
    //designed explitily for UTF7 encoding of DSN content, but could also
    //be used to enforce:
    //  - RFC822 header formats
    //  - RFC822 content restricts
    void        SetConversionContext(CResourceConversionContext *presconv)
    {
        _ASSERT(presconv);
        m_presconv = presconv;
    }
    
    //Used to reset to the defaut memcopy
    void        ResetConversionContext() {m_presconv = &m_defconv;};
    HRESULT     HrWriteResource(WORD wResourceId, LANGID LangId);

    //Encapsulates the functionality of (the nonexistant) LoadStringEx
    HRESULT     HrLoadResourceString(WORD wResourceId, LANGID LangId, 
                                     LPWSTR *pwszResource, DWORD *pcbResource);
   protected:
    CDefaultResourceConversionContext   m_defconv;
    CResourceConversionContext          *m_presconv;
    HRESULT     HrPrivWriteBuffer(BOOL fASCII, BYTE *pbInputBuffer, 
                                  DWORD cbInputBuffer);
    HRESULT     HrWriteBufferToFile();
};

//---[ CDSNBuffer::CDSNBuffer ]------------------------------------------------
//
//
//  Description: 
//      Inlined default constructor for CDSNBuffer
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline CDSNBuffer::CDSNBuffer()
{
    m_dwSignature = DSN_BUFFER_SIG;
    m_overlapped.Offset = 0;
    m_overlapped.OffsetHigh = 0;
    m_overlapped.hEvent = NULL;
    m_cbOffset = 0;
    m_cbFileSize = 0;
    m_cFileWrites = 0;
    m_pDestFile = NULL;
    m_presconv = &m_defconv;
}

//---[ CDSNBuffer::HrFlushBuffer ]---------------------------------------------
//
//
//  Description: 
//      Flushes remaining buffers to File and returns the total number of bytes
//      written to the file.
//  Parameters:
//      OUT pcbFileSize     The size (in bytes) of the file written
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline HRESULT CDSNBuffer::HrFlushBuffer(OUT DWORD *pcbFileSize)
{
    HRESULT hr = HrWriteBufferToFile();

    _ASSERT(pcbFileSize);
    *pcbFileSize = m_cbFileSize;
    
    return hr;
}

#endif //__DSNBUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnbuff.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnbuff.cpp
//
//  Description:  Implementation of CDSNBuffer... class that abstracts writes
//      of DSN information to P2 file.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//---[ CDSNBuffer::~CDSNBuffer ]-----------------------------------------------
//
//
//  Description: 
//      Destructor for CDSNBuffer.  Does NOT close file handle (caller is
//      responisble for that).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDSNBuffer::~CDSNBuffer()
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::~CDSNBuffer");

    DebugTrace((LPARAM) this, "INFO: %d File writes needed by CDSNBuffer", m_cFileWrites);

    //make sure we don't pass in 1 bit
    if (m_overlapped.hEvent)
    {
        _VERIFY(CloseHandle((HANDLE) (((DWORD_PTR) m_overlapped.hEvent) & -2)));
    }
    TraceFunctLeave();
}

//---[ CDSNBuffer::HrInitialize ]----------------------------------------------
//
//
//  Description: 
//      Initialize CDSNBuffer object.
//          - Associates destination file handle with object (will not close it)
//          - Creates an event for synchronizing file operations
//  Parameters:
//      hDestFile   - Destination File Handle (must be opend with FILE_FLAG_OVERLAPPED)
//  Returns:
//      S_OK    on success
//      E_INVALIDARG if handle invalid is passed in
//      E_FAIL if CreateEvent fails for an unknown reason
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrInitialize(PFIO_CONTEXT pDestFile)
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::HrInitialize");
    HRESULT hr = S_OK;

    _ASSERT(pDestFile);

    if (!pDestFile)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_pDestFile = pDestFile;

    //allow this to act as reset
    m_overlapped.Offset = 0;
    m_overlapped.OffsetHigh = 0;
    m_cbOffset = 0;
    m_cbFileSize = 0;
    m_cFileWrites = 0;

    m_overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!m_overlapped.hEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "ERROR: Unable to create DSNBuffer event - hr 0x%08X", hr);
        goto Exit;
    }

    //Set low bit stop ATQ completion routine from being called
    m_overlapped.hEvent = ((HANDLE) (((DWORD_PTR) m_overlapped.hEvent) | 0x00000001)); 

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDSNBuffer::HrWriteBuffer ]---------------------------------------------
//
//
//  Description: 
//      Writes the given buffer, will call write file if needed
//  Parameters:
//      pbInputBuffer   Buffer to write
//      cbInputBuffer   Number of bytes to write
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//      10/21/98 - MikeSwa Updated to support resource conversion
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteBuffer(BYTE *pbInputBuffer, DWORD cbInputBuffer)
{
    return HrPrivWriteBuffer(TRUE, pbInputBuffer, cbInputBuffer);
}

//---[ CDSNBuffer::HrPrivWriteBuffer ]-----------------------------------------
//
//
//  Description: 
//      Private function to handle writing UNICODE and ASCII buffers
//  Parameters:
//      fASCII          TRUE if buffer is ASCII
//      pbInputBuffer   Buffer to write
//      cbInputBuffer   #of bytes to write
//  Returns:
//      S_OK on success
//      Any errors returned from flushing buffer to disk
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrPrivWriteBuffer(BOOL fASCII, BYTE *pbInputBuffer, 
                                      DWORD cbInputBuffer)
{
    HRESULT hr = S_OK;
    BOOL    fDone = FALSE;
    BYTE    *pbCurrentInput = pbInputBuffer;
    DWORD   cbInputRead = 0;
    DWORD   cbTotalInputRead = 0;
    DWORD   cbOutputWritten = 0;
    DWORD   cTimesThruLoop = 0;
    
    _ASSERT(NULL != m_pDestFile);

    while (!fDone)
    {
        cTimesThruLoop++;

        //the buffer can't be *that* large... this will hopfully catch infinite loops
        _ASSERT(cTimesThruLoop < 100); 
        fDone = m_presconv->fConvertBuffer(fASCII, pbCurrentInput, 
                    cbInputBuffer-cbTotalInputRead, m_pbFileBuffer+m_cbOffset,
                    DSN_BUFFER_SIZE - m_cbOffset, &cbOutputWritten, 
                    &cbInputRead);

        m_cbOffset += cbOutputWritten;
        _ASSERT(m_cbOffset <= DSN_BUFFER_SIZE);

        if (!fDone)
        {
            //Update vars passed to fConvertBuffer
            cbTotalInputRead += cbInputRead;
            pbCurrentInput += cbInputRead;

            _ASSERT(cbTotalInputRead <= cbInputBuffer);

            hr = HrWriteBufferToFile();
            if (FAILED(hr))
                goto Exit;
        }
    }

  Exit:
    return hr;
}

//---[ CDSNBuffer::HrWriteBufferToFile ]---------------------------------------
//
//
//  Description: 
//      Write the current buffer contents to the fils
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteBufferToFile()
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::HrWriteBufferToFile");
    HRESULT hr = S_OK;
    DWORD   cbWritten = 0;
    DWORD   dwError = 0;


    if (m_cbOffset) //there is stuff to write
    {
        //fix up overlapped
        if (!WriteFile(m_pDestFile->m_hFile, m_pbFileBuffer, m_cbOffset, &cbWritten, &m_overlapped))
        {
            dwError = GetLastError();
            if (ERROR_IO_PENDING != dwError)
            {
                hr = HRESULT_FROM_WIN32(dwError);
                goto Exit;
            }

            //Wait for result, so we don't overwrite buffer and overlapped
            if (!GetOverlappedResult(m_pDestFile->m_hFile, &m_overlapped, &cbWritten, TRUE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            DebugTrace((LPARAM) this, "INFO: Async write pending for FIOContext 0x%08X", m_pDestFile);
        }
        
        _ASSERT(m_cbOffset == cbWritten);
        m_cbOffset = 0;
        m_cbFileSize += cbWritten;
        m_overlapped.Offset += cbWritten;
        m_cFileWrites++;
    }
     
  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDSNBuffer::SeekForward ]-----------------------------------------------
//
//
//  Description: 
//      Seeks buffers place in file forward specified number of bytes.  Flushes
//      Buffer in process of doing so.
//  Parameters:
//      cbBytesToSeek       Number of bytes to seek forward
//      pcbFileSize         Returns old file size
//  Returns:
//      S_OK on succedd
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrSeekForward(IN DWORD cbBytesToSeek,OUT DWORD *pcbFileSize)
{
    _ASSERT(pcbFileSize);
    HRESULT hr = HrWriteBufferToFile();
    if (FAILED(hr))
        return hr;

    *pcbFileSize = m_cbFileSize;

    m_cbFileSize += cbBytesToSeek;
    m_overlapped.Offset += cbBytesToSeek;

    return S_OK;
}

//---[ CDSNBuffer::HrLoadResourceString ]--------------------------------------
//
//
//  Description: 
//      Encapsulates the functionality of LoadString... but allows you to
//      specify a LangId, returns read only data
//  Parameters:
//      IN  wResourceId     ID of the resource
//      IN  LangId          LangID to get resource for
//      OUT pwszResource    Read-only UNICODE resource (not NULL terminated)
//      OUT pcbResource     Size (in bytes) of UNICODE String
//  Returns:
//      S_OK on success
//      HRESULTS from errors trying to get load resources
//  History:
//      10/22/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrLoadResourceString(WORD wResourceId, LANGID LangId, 
                                        LPWSTR *pwszResource, DWORD *pcbResource)
{
    HRESULT hr = S_OK;
    HINSTANCE hModule = GetModuleHandle(DSN_RESOUCE_MODULE_NAME);
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    WORD    wStringIndex = wResourceId & 0x000F;
    LPWSTR  wszResData = NULL;
    WCHAR   wchLength = 0; //character representing current length

    _ASSERT(pwszResource);
    _ASSERT(pcbResource);

    *pwszResource = NULL;
    *pcbResource = NULL;

    if (NULL == hModule)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(0 && "Unable to load resource DLL");
        goto Exit;
    }

    //Find handle to string table segment
    hResInfo = FindResourceEx(hModule, RT_STRING,
                            MAKEINTRESOURCE(((WORD)((USHORT)wResourceId >> 4) + 1)),
                            LangId);

    if (NULL == hResInfo)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(0 && "Failed to find resource for requested LangId");
        goto Exit;
    }


    hResData = LoadResource(hModule, hResInfo);

    if (NULL == hResData)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Get pointer to string table segement data
    wszResData = (LPWSTR) LockResource(hResData);

    if (NULL == wszResData)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
   
    //OK Now we have a pointer to the string table segment
    //Lets use some code from LoadStringOrError to handle this
    //There are 16 strings in a segment, which means we can look at
    //The low 4 bits of the wResourceId (wStringIndex)

    //String Table segment format
    //PASCAL like string count first UTCHAR is count if TCHARs
    //A zero length string (ie resource 0) is simply the WORD 0x0000...
    //This loop handles both the same... when loop is done.
    //  wszResData  - Ptr to UNICODE string
    //  wchLenght   - Length of that string (in WCHARS)
    while (TRUE) 
    {
        wchLength = *((WCHAR *)wszResData++);
        if (0 == wStringIndex--)
            break;
        // Step to start if next string... 
        wszResData += wchLength;                
    }

    *pwszResource = wszResData;
    *pcbResource = (DWORD) wchLength*sizeof(WCHAR);

  Exit:
    return hr;
}

//---[ CDSNBuffer::HrWriteResource ]-------------------------------------------
//
//
//  Description: 
//      Gets resource for specified language ID, and dumps UNICODE to DSN 
//      content using current conversion context.
//
//      It will assert if the resource cannot be found for the given language
//      ID.
//  Parameters:
//      dwResourceID        The resouce ID of the resource to get
//      LandId              The language ID to use
//  Returns:
//      S_OK on success
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteResource(WORD wResourceId, LANGID LangId)
{
    HRESULT hr = S_OK;
    LPWSTR  wszResource = NULL;
    DWORD   cbResource = NULL;

    hr = HrLoadResourceString(wResourceId, LangId, &wszResource, &cbResource);
    if (FAILED(hr))
    {
        _ASSERT(0 && "Unable to load resources");
        //Fail silently in retail
        hr = S_OK;
    }
    
    //OK... now we have everything we need to write the buffer
    hr = HrPrivWriteBuffer(FALSE /*not ASCII */,
                           (BYTE *) wszResource, cbResource);

    //$$REVIEW: Do we need to do any special cleanup here?
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnconv.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnconv.h
//
//  Description:  Base classes for DSN resource conversion
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNCONV_H__
#define __DSNCONV_H__

//---[ CResourceConversionContext ]----------------------------------------------
//
//
//  Description: 
//      Class used to abstract the various types of content conversion we 
//      may be forced to do to support charsets other than US-ASCII.
//  Hungarian: 
//      resconv, presconv
//  
//-----------------------------------------------------------------------------
class CResourceConversionContext
{
  public:
      //Used to convert a UNICODE/ASCII resource to DSN body text
      //This additional abstraction (UNICODE vs ASCII)
      //is require for supporting potential additions like without messing with
      //the mainline buffer code
      //    - guaranteed line length
      //    - handling special ASCII characters in RFC822 headers
      //    - Provides single code path for all buffer writes
      virtual BOOL fConvertBuffer(
          IN BOOL   fASCII, 
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead) = 0;
};

//---[ CDefaultResourceConversionContext ]-------------------------------------
//
//
//  Description: 
//      Default resource conversion object... simple memcpy for base case
//  Hungarian: 
//      defconv, pdefconv
//  
//-----------------------------------------------------------------------------
class CDefaultResourceConversionContext : public CResourceConversionContext
{
  public:
    BOOL fConvertBuffer(
          IN BOOL   fASCII, 
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);
};


//---[ CDefaultResourceConversionContext::fConvertBuffer ]----------------------
//
//
//  Description: 
//      Default Resource conversion for DSNs 
//  Parameters:
//      IN  fASCII              TRUE if buffer is ASCII 
//                                  (*must* be TRUE for default)
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if done converting
//      FALSE if needs more output buffer
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline BOOL CDefaultResourceConversionContext::fConvertBuffer(
                                          IN BOOL   fASCII, 
                                          IN PBYTE  pbInputBuffer,
                                          IN DWORD  cbInputBuffer,
                                          IN PBYTE  pbOutputBuffer,
                                          IN DWORD  cbOutputBuffer,
                                          OUT DWORD *pcbWritten,
                                          OUT DWORD *pcbRead)
{
    _ASSERT(pcbWritten);
    _ASSERT(pcbRead);
    _ASSERT(fASCII);

    if (cbInputBuffer <= cbOutputBuffer)
    {
        //everything can fit in current buffer
        memcpy(pbOutputBuffer, pbInputBuffer, cbInputBuffer);
        *pcbRead = cbInputBuffer;
        *pcbWritten = cbInputBuffer;
        return TRUE;
    }
    else
    {
        //we need to write in chunks
        memcpy(pbOutputBuffer, pbInputBuffer, cbOutputBuffer);
        *pcbRead = cbOutputBuffer;
        *pcbWritten = cbOutputBuffer;
        return FALSE;
    }
}

#endif //__DSNCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsntext.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsntext.h
//
//  Description:  Defines DSN test
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNTEXT_H__
#define __DSNTEXT_H__

#ifdef PLATINUM
#define DSN_RESOUCE_MODULE_NAME     "phatq.dll"
#else //PLATINUM
#define DSN_RESOUCE_MODULE_NAME     "aqueue.dll"
#endif //PLATINUM

//822 DSN Message headers
#define TO_HEADER                   "\r\nTo: "
#define BCC_HEADER                  "\r\nBcc: "
#define DSN_CONTEXT_HEADER          "\r\nX-DSNContext: "
#define MIME_HEADER                 "\r\nMIME-Version: 1.0\r\n" \
                                    "Content-Type: multipart/report; " \
                                    "report-type=delivery-status;\r\n" \
                                    "\tboundary="
#define DATE_HEADER                 "\r\nDate: "
#define SUBJECT_HEADER              "\r\nSubject: "
#define MSGID_HEADER                "\r\nMessage-ID: "
#define MIME_DELIMITER              "--"
#define DSN_MAIL_FROM               "<>"
#define DSN_FROM_HEADER             "From: "
#define DSN_SENDER_ADDRESS_PREFIX   "postmaster@"
#define DSN_RFC822_SENDER           DSN_FROM_HEADER DSN_SENDER_ADDRESS_PREFIX
#define BLANK_LINE                  "\r\n\r\n"
#define DSN_INDENT                  "       "
#define DSN_CRLF                    "\r\n"

//822 DSN Headers used when copying original message... since we do not
//know if we will have a preceeeding property, these do not include the
//preceeeding CRLF.
#define DSN_FROM_HEADER_NO_CRLF     "From: "
#define SUBJECT_HEADER_NO_CRLF      "Subject: "
#define MSGID_HEADER_NO_CRLF        "Message-ID: "


//DSN Report fields
#define MIME_CONTENT_TYPE           "\r\nContent-Type: "
#define DSN_HEADER_TYPE_DELIMITER   ";"
#define DSN_MIME_TYPE               "message/delivery-status"
#define DSN_HUMAN_READABLE_TYPE     "text/plain"
#define DSN_MIME_CHARSET_HEADER     "; charset="
#define DSN_RFC822_TYPE             "message/rfc822"
#define DSN_HEADER_ENVID            "\r\nOriginal-Envelope-Id: "
#define DSN_HEADER_REPORTING_MTA    "\r\nReporting-MTA: dns;"
#define DSN_HEADER_DSN_GATEWAY      "\r\nDSN-Gateway: "
#define DSN_HEADER_RECEIVED_FROM    "\r\nReceived-From-MTA: dns;"
#define DSN_HEADER_ARRIVAL_DATE     "\r\nArrival-Date: "

#define DSN_RP_HEADER_ORCPT         "\r\nOriginal-Recipient: "
#define DSN_RP_HEADER_FINAL_RECIP   "\r\nFinal-Recipient: "
#define DSN_RP_HEADER_ACTION        "\r\nAction: "
#define DSN_RP_HEADER_ACTION_FAILURE "failed"
#define DSN_RP_HEADER_ACTION_DELAYED "delayed"
#define DSN_RP_HEADER_ACTION_DELIVERED "delivered"
#define DSN_RP_HEADER_ACTION_RELAYED "relayed"
#define DSN_RP_HEADER_ACTION_EXPANDED "expanded"
#define DSN_RP_HEADER_STATUS        "\r\nStatus: "
#define DSN_RP_HEADER_REMOTE_MTA    "\r\nRemote-MTA: dns;"
#define DSN_RP_HEADER_DIAG_CODE     "\r\nDiagnostic-Code: smtp;"
#define DSN_RP_HEADER_LAST_ATTEMPT  "\r\nLast-Attempt-Date: "
#define DSN_RP_HEADER_FINAL_LOG     "\r\nFinal-Log-Id: "
#define DSN_RP_HEADER_RETRY_UNTIL   "\r\nWill-Retry-Until: "

//status codes 
#define DSN_STATUS_CH_DELIMITER     '.'
#define DSN_STATUS_CH_INVALID       '\0'
#define DSN_STATUS_CH_GENERIC       '0'
//generic status codes
#define DSN_STATUS_FAILED           "5.0.0"
#define DSN_STATUS_DELAYED          "4.0.0"
#define DSN_STATUS_SUCCEEDED        "2.0.0"

//Class (first) digit of status codes
#define DSN_STATUS_CH_CLASS_SUCCEEDED   '2'
#define DSN_STATUS_CH_CLASS_TRANSIENT   '4'
#define DSN_STATUS_CH_CLASS_FAILED      '5'

//Subject (second) digit(s) of status codes
#define DSN_STATUS_CH_SUBJECT_GENERAL   '0'
#define DSN_STATUS_CH_SUBJECT_ADDRESS   '1'
#define DSN_STATUS_CH_SUBJECT_MAILBOX   '2'
#define DSN_STATUS_CH_SUBJECT_SYSTEM    '3'
#define DSN_STATUS_CH_SUBJECT_NETWORK   '4'
#define DSN_STATUS_CH_SUBJECT_PROTOCOL  '5'
#define DSN_STATUS_CH_SUBJECT_CONTENT   '6'
#define DSN_STATUS_CH_SUBJECT_POLICY    '7'

//Detail (third) digit(s) of status codes
#define DSN_STATUS_CH_DETAIL_GENERAL    '0'

//This part appears before the first MIME part and is intended for non-MIME 
//clients.  It *cannot* be localized since it is not actually part of any MIME
//part and must be 100% US-ASCII
#define MESSAGE_SUMMARY         "This is a MIME-formatted message.  \r\n" \
                                "Portions of this message may be unreadable without a MIME-capable mail program."

//String that can be localized are located in dsnlang.h and aqueue.rc


#endif //__DSNTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnsink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnsink.cpp
//
//  Description: Implementation of default DSN Generation sink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/30/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"
#ifdef PLATINUM
#include "ptntdefs.h"
#endif //PLATINUM

//
//  This length is inspired by the other protocols that we deal with.  The 
//  default address limit is 1024, but the MTA can allow 1024 + 834  for the
//  OR address.  We'll define out default buffer size to allow this large
//  of an address.
//
#define PROP_BUFFER_SIZE 1860

#ifdef DEBUG
#define DEBUG_DO_IT(x) x
#else
#define DEBUG_DO_IT(x) 
#endif  //DEBUG

//min sizes for valid status strings
#define MIN_CHAR_FOR_VALID_RFC2034  10
#define MIN_CHAR_FOR_VALID_RFC821   3

#define MAX_RFC822_DATE_SIZE 35
void FileTimeToLocalRFC822Date(const FILETIME & ft, char achReturn[MAX_RFC822_DATE_SIZE]);

static  char  *s_rgszMonth[ 12 ] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

static  char *s_rgszWeekDays[7] = 
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

#define MAX_RFC_DOMAIN_SIZE         64

//String used in generation of MsgID
static char g_szBoundaryChars [] = "0123456789abcdefghijklmnopqrstuvwxyz"
                                   "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

static LONG g_cDSNMsgID = 0;

//Address types to check for, and their corresponding address types.
const DWORD   g_rgdwSenderPropIDs[] = {
                IMMPID_MP_SENDER_ADDRESS_SMTP,
                IMMPID_MP_SENDER_ADDRESS_X400,
                IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,
                IMMPID_MP_SENDER_ADDRESS_X500,
                IMMPID_MP_SENDER_ADDRESS_OTHER};

const DWORD   g_rgdwRecipPropIDs[] = {
                IMMPID_RP_ADDRESS_SMTP,
                IMMPID_RP_ADDRESS_X400,
                IMMPID_RP_LEGACY_EX_DN,
                IMMPID_RP_ADDRESS_X500,
                IMMPID_RP_ADDRESS_OTHER};

const DWORD   NUM_DSN_ADDRESS_PROPERTIES = 5;

const CHAR    *g_rgszAddressTypes[] = {
                "rfc822",
                "x-x400",
                "x-ex",
                "x-x500",
                "unknown"};

//---[ fLanguageAvailable ]----------------------------------------------------
//
//
//  Description: 
//      Checks to see if resources for a given language are available.
//  Parameters:
//      LangId      Language to check for
//  Returns:
//      TRUE    If localized resources for requested language are available
//      FALSE   If resources for that language are not available.
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fLanguageAvailable(LANGID LangId)
{
    TraceFunctEnterEx((LPARAM) LangId, "fLanguageAvailable");
    HINSTANCE hModule = GetModuleHandle(DSN_RESOUCE_MODULE_NAME);
    HRSRC hResInfo = NULL;
    BOOL  fResult = FALSE;

    if (NULL == hModule)
    {
        _ASSERT( 0 && "Cannot get resource module handle");
        return FALSE;
    }

    //Find handle to string table segment
    hResInfo = FindResourceEx(hModule, RT_STRING,
                            MAKEINTRESOURCE(((WORD)((USHORT)GENERAL_SUBJECT >> 4) + 1)),
                            LangId);

    if (NULL != hResInfo)
        fResult = TRUE;
    else
        ErrorTrace((LPARAM) LangId, "Unable to load DSN resources for language");
    
    TraceFunctLeave();
    return fResult;

}

//---[ fIsValidMIMEBoundaryChar ]----------------------------------------------
//
//
//  Description: 
//
//      Checks to see if the given character is a valid as described by the 
//      RFC2046 BNF for MIME Boundaries:
//          boundary := 0*69<bchars> bcharsnospace
//          bchars := bcharsnospace / " "
//          bcharsnospace := DIGIT / ALPHA / "'" / "(" / ")" /
//                         "+" / "_" / "," / "-" / "." /
//                         "/" / ":" / "=" / "?"
//  Parameters:
//      ch      Char to check
//  Returns:
//      TRUE if VALID
//      FALSE otherwise
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fIsValidMIMEBoundaryChar(CHAR ch)
{
    if (isalnum(ch))
        return TRUE;

    //check to see if it is one of the special case characters
    if (('\'' == ch) || ('(' == ch) || (')' == ch) || ('+' == ch) || 
        ('_' == ch) || (',' == ch) || ('_' == ch) || ('.' == ch) ||
        ('/' == ch) || (':' == ch) || ('=' == ch) || ('?' == ch))
        return TRUE;
    else
        return FALSE;
}

//---[ GenerateDSNMsgID ]------------------------------------------------------
//
//
//  Description: 
//      Generates a unique MsgID string
//
//      The format is:
//          <random-unique-string>@<domain>
//  Parameters:
//      IN  szDomain            Domain to generate MsgID for
//      IN  cbDomain            Domain to generate MsgID for
//      IN OUT  szBuffer        Buffer to write MsgID in
//      IN  cbBuffer            Size of buffer to write MsgID in
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      3/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fGenerateDSNMsgID(LPSTR szDomain,DWORD cbDomain, 
                      LPSTR szBuffer, DWORD cbBuffer)
{
    TraceFunctEnterEx((LPARAM) NULL, "fGenerateDSNMsgID");
    _ASSERT(szDomain);
    _ASSERT(cbDomain);
    _ASSERT(szBuffer);
    _ASSERT(cbBuffer);

    // insert the leading <
    if (cbBuffer >= 1) {
        *szBuffer = '<';
        szBuffer++;
        cbBuffer--;
    }
    
    const CHAR szSampleFormat[] = "00000000@"; // sample format string
    const DWORD cbMsgIdLen = 20;  //default size of random string 
    LPSTR szStop = szBuffer + cbMsgIdLen;
    LPSTR szCurrent = szBuffer;
    DWORD cbCurrent = 0;
    
    //minimize size for *internal* static buffer
    _ASSERT(cbBuffer > MAX_RFC_DOMAIN_SIZE + cbMsgIdLen); 

    if (!szDomain || !cbDomain || !szBuffer || !cbBuffer || 
        (cbBuffer <= MAX_RFC_DOMAIN_SIZE + cbMsgIdLen))
        return FALSE;

    //We want to figure how much room we have for random characters
    //We will need to fit the domain name, the '@', and the 8 character unique
    //number
    // awetmore - add 1 for the trailing >
    if(cbBuffer < cbDomain + cbMsgIdLen + 1)
    {
        //Fall through an allow for 20 characaters and part of domain name
        //We want to catch this in debug builds
        _ASSERT(0 && "Buffer too small for MsgID");
    }
    
    //this should have been caught in parameter checking
    _ASSERT(cbBuffer > cbMsgIdLen);

    szStop -= (sizeof(szSampleFormat) + 1);
    while (szCurrent < szStop)
    {
        *szCurrent = g_szBoundaryChars[rand() % (sizeof(g_szBoundaryChars) - 1)];
        szCurrent++;
    }

    //Add unique number 
    cbCurrent = sprintf(szCurrent, "%8.8x@", InterlockedIncrement(&g_cDSNMsgID));
    _ASSERT(sizeof(szSampleFormat) - 1 == cbCurrent);

    //Figure out how much room we have and add domain name
    szCurrent += cbCurrent;
    cbCurrent = (DWORD) (szCurrent-szBuffer);

    //unless I've messed up the logic this is always true
    _ASSERT(cbCurrent < cbBuffer); 

    //Add domain part to message id
    strncat(szCurrent-1, szDomain, cbBuffer - cbCurrent - 1);

    _ASSERT(cbCurrent + cbDomain < cbBuffer); 

    // Add the trailing >.  we accounted for the space above check for
    // cbBuffer size
    strncat(szCurrent, ">", cbBuffer - cbCurrent - cbDomain - 1);

    DebugTrace((LPARAM) NULL, "Generating DSN Message ID %s", szCurrent);
    TraceFunctLeave();
    return TRUE;
}

#ifdef DEBUG
#define _ASSERT_RECIP_FLAGS  AssertRecipFlagsFn
#define _VERIFY_MARKED_RECIPS(a, b, c) VerifyMarkedRecips(a, b, c)
#define _ASSERT_MIME_BOUNDARY(szMimeBoundary) AssertMimeBoundary(szMimeBoundary)

//---[ AssertRecipFlagsFn ]----------------------------------------------------
//
//
//  Description: 
//      ***DEBUG ONLY***
//      Asserts that the recipient flags defined in mailmsgprops.h are correct
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/2/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void AssertRecipFlagsFn()
{
    DWORD i, j;
    DWORD rgdwFlags[] = {RP_DSN_NOTIFY_SUCCESS, RP_DSN_NOTIFY_FAILURE, 
        RP_DSN_NOTIFY_DELAY, RP_DSN_NOTIFY_NEVER, RP_DELIVERED, 
        RP_DSN_SENT_NDR, RP_FAILED, RP_UNRESOLVED, RP_EXPANDED,
        RP_DSN_SENT_DELAYED, RP_DSN_SENT_EXPANDED, RP_DSN_SENT_RELAYED,
        RP_DSN_SENT_DELIVERED, RP_REMOTE_MTA_NO_DSN, RP_ERROR_CONTEXT_STORE,
        RP_ERROR_CONTEXT_CAT, RP_ERROR_CONTEXT_MTA};
    DWORD cFlags = sizeof(rgdwFlags)/sizeof(DWORD);

    for (i = 0; i < cFlags;i ++)
    {
        for (j = i+1; j < cFlags; j++)
        {
            //make sure all have some unique bits
            if (rgdwFlags[i] & rgdwFlags[j])
            {
                _ASSERT((rgdwFlags[i] & rgdwFlags[j]) != rgdwFlags[j]);
                _ASSERT((rgdwFlags[i] & rgdwFlags[j]) != rgdwFlags[i]);
            }
        }
    }

    //Verify that handled bit is used correctly
    _ASSERT(RP_HANDLED & RP_DELIVERED);
    _ASSERT(RP_HANDLED & RP_DSN_SENT_NDR);
    _ASSERT(RP_HANDLED & RP_FAILED);
    _ASSERT(RP_HANDLED & RP_UNRESOLVED);
    _ASSERT(RP_HANDLED & RP_EXPANDED);
    _ASSERT(RP_HANDLED ^ RP_DELIVERED);
    _ASSERT(RP_HANDLED ^ RP_DSN_SENT_NDR);
    _ASSERT(RP_HANDLED ^ RP_FAILED);
    _ASSERT(RP_HANDLED ^ RP_UNRESOLVED);
    _ASSERT(RP_HANDLED ^ RP_EXPANDED);

    //Verify that DSN-handled bit is used correctly
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_NDR);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_EXPANDED);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_RELAYED);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_DELIVERED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_NDR);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_EXPANDED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_RELAYED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_DELIVERED);

    //Verify that general failure bit is used correctly
    _ASSERT(RP_GENERAL_FAILURE & RP_FAILED);
    _ASSERT(RP_GENERAL_FAILURE & RP_UNRESOLVED);
    _ASSERT(RP_GENERAL_FAILURE ^ RP_FAILED);
    _ASSERT(RP_GENERAL_FAILURE ^ RP_UNRESOLVED);

}

//---[ VerifyMarkedRecips ]----------------------------------------------------
//  
//  ***DEBUG ONLY***
//
//  Description: 
//      Verifies that all recipients have been marked as appropriate
//  Parameters:
//      pIMailMsgRecipients     Recipients object to check for
//      dwStartDomain           Starting domain for context
//      dwDSNAction             DSN actions requested
//  Returns:
//      -
//  History:
//      7/2/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDefaultDSNSink::VerifyMarkedRecips(IMailMsgRecipients *pIMailMsgRecipients, 
                                         DWORD dwStartDomain,DWORD dwDSNActions)
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentRecipFlags= 0;
    DWORD   iCurrentRecip = 0;
    RECIPIENT_FILTER_CONTEXT rpfctxt;
    BOOL    fContextInit = FALSE;
    DWORD   dwCurrentDSNAction = 0;
    hr = pIMailMsgRecipients->InitializeRecipientFilterContext(&rpfctxt, 
                                        dwStartDomain, 0, 0);
    if (FAILED(hr))
        goto Exit;

    fContextInit = TRUE;

    hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
    while (SUCCEEDED(hr))
    {
        hr = pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_RECIPIENT_FLAGS, &dwCurrentRecipFlags);
        if (FAILED(hr))
        {
            _ASSERT(0 && "GetDWORD for IMMPID_RP_RECIPIENT_FLAGS FAILED");
            goto Exit;
        }

        if (!(dwCurrentRecipFlags & (RP_DSN_HANDLED | RP_DSN_NOTIFY_NEVER)))
        {
            if (fdwGetDSNAction(dwDSNActions, &dwCurrentRecipFlags, &dwCurrentDSNAction))
            {
                _ASSERT(0 && "Recipient not marked correctly by DSN code");
            }
        }

        hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
            
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;

  Exit:
    if (fContextInit)
    {
        hr = pIMailMsgRecipients->TerminateRecipientFilterContext(&rpfctxt);
        _ASSERT(SUCCEEDED(hr) && "TerminateRecipientFilterContext FAILED");
    }
}

//---[ AssertMimeBoundary ]----------------------------------------------------
//
//  ***DEBUG ONLY***
//  Description: 
//      Asserts that the given MIME boundary is NULL-terminated and has only
//      Valid characters
//  Parameters:
//      szMimeBoundary      NULL-terminated MIME Boundary string
//  Returns:
//      -
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void AssertMimeBoundary(LPSTR szMimeBoundary)
{
    CHAR *pcharCurrent = szMimeBoundary;
    DWORD cChars = 0;
    while ('\0' != *pcharCurrent)
    {
        cChars++;
        _ASSERT(cChars <= MIME_BOUNDARY_RFC2046_LIMIT);
        _ASSERT(fIsValidMIMEBoundaryChar(*pcharCurrent));
        pcharCurrent++;
    }
}

#else //not DEBUG
#define _ASSERT_RECIP_FLAGS()
#define _VERIFY_MARKED_RECIPS(a, b, c)
#define _ASSERT_MIME_BOUNDARY(szMimeBoundary)
#endif //DEBUG

//---[ fIsMailMsgDSN ]---------------------------------------------------------
//
//
//  Description: 
//      Determines if a mailmsg is a DSN.
//  Parameters:
//      IN  pIMailMsgProperties
//  Returns:
//      TRUE if the orinal message is a DSN
//      FALSE if it is not a DSN
//  History:
//      2/11/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fIsMailMsgDSN(IMailMsgProperties *pIMailMsgProperties)
{
    CHAR    szSenderBuffer[sizeof(DSN_MAIL_FROM)];
    DWORD   cbSender = 0;
    HRESULT hr = S_OK;
    BOOL    fIsDSN = FALSE; //unless proven otherwise... it is not a DSN

    _ASSERT(pIMailMsgProperties);

    szSenderBuffer[0] = '\0';
    //Get the sender of the original message
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_SENDER_ADDRESS_SMTP, 
            sizeof(szSenderBuffer), &cbSender, (BYTE *) szSenderBuffer);
    if (SUCCEEDED(hr) &&
        ('\0' == szSenderBuffer[0] || !strcmp(DSN_MAIL_FROM, szSenderBuffer)))
    {
        //If the sender is a NULL string... or "<>"... then it is a DSN
        fIsDSN = TRUE;
    }

    return fIsDSN;
}

//---[ HrResetRecipientFilter ]------------------------------------------------
//
//
//  Description: 
//      Resets the recipient filter conext
//  Parameters:
//      IN  pIMailMsgRecipients     Msg to reset context on
//      IN  prpfctxt                Recip filter context
//      IN  dwStartDomain           StartDomain
//      IN  dwRecipFilterMask       Bit mask of recipient flags we care about
//      IN  dwRecipFilterFlags      Values of flags that we are looking for
//      IN OUT pfContextInit        TRUE if the prpfctxt has been initialized
//  Returns:
//      S_OK on success
//      Error code from IMailMsgProperties on failure
//  History:
//      2/11/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT HrResetRecipientFilter(IMailMsgRecipients *pIMailMsgRecipients,
                               RECIPIENT_FILTER_CONTEXT *prpfctxt,
                               DWORD dwStartDomain,
                               DWORD dwRecipFilterMask, 
                               DWORD dwRecipFilterFlags,
                               BOOL *pfContextInit)
{
    _ASSERT(pIMailMsgRecipients);
    _ASSERT(prpfctxt);
    _ASSERT(pfContextInit);
    HRESULT hr = S_OK;

    if (*pfContextInit)
    {
        //recycle context
        *pfContextInit = FALSE;
        hr = pIMailMsgRecipients->TerminateRecipientFilterContext(prpfctxt);
        _ASSERT(SUCCEEDED(hr) && "TerminateRecipientFilterContext FAILED!!!!");
        if (FAILED(hr))
            goto Exit;
    }

    hr = pIMailMsgRecipients->InitializeRecipientFilterContext(prpfctxt, dwStartDomain, 
                                    dwRecipFilterMask, dwRecipFilterFlags);
    _ASSERT(SUCCEEDED(hr) && "InitializeRecipientFilterContext FAILED after succeeding once!!!!");
    if (FAILED(hr))
        goto Exit;
    
    *pfContextInit = TRUE; //now context is valid again

  Exit:
    return hr;
}

//---[ CDefaultDSNSink::CDefaultDSNSink ]--------------------------------------
//
//
//  Description: 
//      CDefaultDSNSink constructor
//  Parameters:
//      -
//  Returns:    
//
//  History:
//      6/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDefaultDSNSink::CDefaultDSNSink()
{
    FILETIME ftStartTime;
    _ASSERT_RECIP_FLAGS();
    m_fInit = FALSE;
    m_dwSignature = DSN_SINK_SIG;
    m_cDSNsRequested = 0;

    //Init string for MIME headers
    GetSystemTimeAsFileTime(&ftStartTime);
    wsprintf(m_szPerInstanceMimeBoundary, "%08X%08X", 
        ftStartTime.dwHighDateTime, ftStartTime.dwLowDateTime);

}

//---[ CDefaultDSNSink::HrInitialize ]-----------------------------------------
//
//
//  Description: 
//      Performs initialization...
//          - Sets init flag
//          - Currently nothing else
//  Parameters:
//      -
//  Returns:
//      S_OK on SUCCESS
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrInitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrInitialize");
    HRESULT hr = S_OK;

    m_fInit = TRUE;
    srand(GetTickCount());
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::~CDefaultDSNSink ]-------------------------------------
//
//
//  Description: 
//
//  Parameters:
//
//  Returns:
//
//  History:
//      6/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDefaultDSNSink::~CDefaultDSNSink()
{
    m_dwSignature = DSN_SINK_SIG_FREED;

}

//---[ CDefaultDSNSink::QueryInterface ]---------------------------------------
//
//
//  Description: 
//      Implements IUnknown::QueryInterface for CDefaultDSNSink
//  Parameters:
//      IN  riid    GUID of interface looking for
//      OUT ppvObj  Returned object
//  Returns:
//      S_OK onsuccess
//      E_INVALIDARG if ppvObj is NULL
//      E_NOINTERFACE if interface is not supported
//  History:
//      6/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDefaultDSNSink::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!m_fInit)
    {
        hr = AQUEUE_E_NOT_INITIALIZED;
        goto Exit;
    }

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IDSNGenerationSink *>(this);
    }
    else if (IID_IDSNGenerationSink == riid)
    {
        *ppvObj = static_cast<IDSNGenerationSink *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CDefaultDSNSink::GenerateDSN ]------------------------------------------
//
//
//  Description: 
//      Implements IDSNGenerationSink::GenerateDSN.  Generates a DSN
//      IMailMsgProperties and 
//  Parameters: 
//      pISMTPServer            Interface used to generate DSN
//      pIMailMsgProperties     IMailMsg to generate DSN for
//      dwStartDomain           Domain to start recip context
//      dwDSNActions            DSN action to perform
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//      szDefaultDomain         Default domain (used to create FROM address)
//      cbDefaultDomain         string length of szDefaultDomain
//      szReportingMTA          Name of MTA requesting DSN generation
//      cbReportingMTA          string length of szReportingMTA
//      szReportingMTAType      Type of MTA requestiong DSN (SMTP is "dns"
//      cbReportingMTAType      string length of szReportingMTAType
//      PreferredLangId         Language to generate DSN in
//      dwDSNOptions            Options flags as defined in aqueue.idl
//      szCopyNDRTo             SMTP Address to copy NDR to
//      cbCopyNDRTo             string lengtt of szCopyNDRTo
//      ppIMailMsgPeropertiesDSN Generated DSN.
//      pdwDSNTypesGenerated    Describes the type(s) of DSN's generated
//      pcRecipsDSNd            # of recipients that were DSN'd for this message
//      pcIterationsLeft        # of times remaining that this function needs
//                              to be called to generate all requested DSNs.
//                              First-time caller should initialize to zero
//  Returns:
//      S_OK on success
//      AQUEUE_E_NDR_OF_DSN if attempting to NDR a DSN
//  History:
//      6/30/98 - MikeSwa Created 
//      12/14/98 - MikeSwa Modified (Added pcIterationsLeft)
//      10/13/1999 - MikeSwa Modified (Added szDefaultDomain)
//
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDefaultDSNSink::GenerateDSN(
                           ISMTPServer *pISMTPServer,
                           IMailMsgProperties *pIMailMsgProperties,
                           DWORD dwStartDomain,
                           DWORD dwDSNActions,
                           DWORD dwRFC821Status,
                           HRESULT hrStatus,
                           LPSTR szDefaultDomain,
                           DWORD cbDefaultDomain,
                           LPSTR szReportingMTA,
                           DWORD cbReportingMTA,
                           LPSTR szReportingMTAType,
                           DWORD cbReportingMTAType,
                           LPSTR szDSNContext,
                           DWORD cbDSNContext,
                           DWORD dwPreferredLangId,
                           DWORD dwDSNOptions,
                           LPSTR szCopyNDRTo,
                           DWORD cbCopyNDRTo,
                           IMailMsgProperties **ppIMailMsgPropertiesDSN,
                           DWORD *pdwDSNTypesGenerated,
                           DWORD *pcRecipsDSNd,
                           DWORD *pcIterationsLeft)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::GenerateDSN");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    BOOL    fContextInit = FALSE;
    BOOL    fDSNNeeded = FALSE;
    DWORD   iCurrentRecip = 0;
    DWORD   dwCurrentRecipFlags = 0x00000000;
    DWORD   dwRecipFilterMask = 0x00000000;
    DWORD   dwRecipFilterFlags = 0x00000000;
    DWORD   dwCurrentDSNAction = 0;
    DWORD   dwDSNActionsNeeded = 0; //the type of DSNs that will actually be sent
    IMailMsgRecipients  *pIMailMsgRecipients = NULL;
    IMailMsgProperties *pIMailMsgPropertiesDSN = NULL;
    ISMTPServerInternal *pISMTPServerInternal = NULL;
    PFIO_CONTEXT  pDSNBody = NULL;
    RECIPIENT_FILTER_CONTEXT rpfctxt;
    CDSNBuffer  dsnbuff;
    CHAR    szMimeBoundary[MIME_BOUNDARY_SIZE];
    DWORD   cbMimeBoundary = 0;
    FILETIME ftExpireTime;
    DWORD   cbCurrentSize = 0; //used to get size of returned property
    CHAR    szExpireTimeBuffer[MAX_RFC822_DATE_SIZE];
    LPSTR   szExpireTime = NULL; //will point to szExpireTimeBuffer if found
    DWORD   cbExpireTime = 0;

    _ASSERT(ppIMailMsgPropertiesDSN);
    _ASSERT(pISMTPServer);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(pdwDSNTypesGenerated);
    _ASSERT(pcRecipsDSNd);
    _ASSERT(pcIterationsLeft);

    *pcRecipsDSNd = 0;
    *ppIMailMsgPropertiesDSN = NULL;
    *pdwDSNTypesGenerated = 0;
    GetCurrentMimeBoundary(szReportingMTA, cbReportingMTA, szMimeBoundary, &cbMimeBoundary);


    //Get Recipients interface
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, 
                                    (PVOID *) &pIMailMsgRecipients);
    if (FAILED(hr))
        goto Exit;

    //Use recipient context to loop over recipients
    hr = HrGetFilterMaskAndFlags(dwDSNActions, &dwRecipFilterFlags, &dwRecipFilterMask);
    if (FAILED(hr))
        goto Exit;

    hr = HrResetRecipientFilter(pIMailMsgRecipients, &rpfctxt, dwStartDomain, 
                                dwRecipFilterMask, dwRecipFilterFlags, &fContextInit);
    if (FAILED(hr))
        goto Exit;



    //Loop over recipients to make sure we can need to allocate a message
    hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
    while (SUCCEEDED(hr))
    {
        hr = pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_RECIPIENT_FLAGS, &dwCurrentRecipFlags);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, 
                "Failure 0x%08X to get flags for recip %d",
                hr, iCurrentRecip);
            goto Exit;
        }

        DebugTrace((LPARAM) this, 
            "Recipient %d with flags 0x%08X found",
            iCurrentRecip, dwCurrentRecipFlags);

        if (fdwGetDSNAction(dwDSNActions, &dwCurrentRecipFlags, &dwCurrentDSNAction))
            fDSNNeeded = TRUE;

        //keep track of the types of DSN's we will be generating
        dwDSNActionsNeeded |= dwCurrentDSNAction;

        hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
            
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;  //we just reached the end of the context
    else if (FAILED(hr))
        ErrorTrace((LPARAM) this, "GetNextRecipient failed with 0x%08X",hr);

    if (!fDSNNeeded)
    {
        DebugTrace((LPARAM) this, 
                "Do not need to generate a 0x%08X DSN",
                dwDSNActions, pIMailMsgProperties);
        *pcIterationsLeft = 0;
        goto Exit; //don't create a message object if we don't have to 
    }

    //Check if message is a DSN (we will not genrate a DSN of a DSN)
    //This must be checked after we run through the recipients, because
    //we need to check them to keep from badmailing this message
    //multiple times.
    if (fIsMailMsgDSN(pIMailMsgProperties))
    {
        DebugTrace((LPARAM) pIMailMsgProperties, "Message is a DSN");
        *pcIterationsLeft = 0;
        if (dwDSNActions & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL))
        {
            //NDR of DSN... return special error code
            hr = AQUEUE_E_NDR_OF_DSN;

            //mark all the appropriate recipient flags so we don't 
            //generate 2 badmails
            HrMarkAllRecipFlags(dwDSNActions, pIMailMsgRecipients,
                                &rpfctxt);
        }
        goto Exit;
    }

    //if we can generate a failure DSN and the orginal request was for
    //fail *all* make sure dwDSNActionNeeded reflects this
    if ((DSN_ACTION_FAILURE & dwDSNActionsNeeded) && 
        (DSN_ACTION_FAILURE_ALL & dwDSNActions))
        dwDSNActionsNeeded |= DSN_ACTION_FAILURE_ALL;
        
    GetCurrentIterationsDSNAction(&dwDSNActionsNeeded, pcIterationsLeft);
    if (!dwDSNActionsNeeded)
    {
        fDSNNeeded = FALSE;
        *pcIterationsLeft = 0;
        goto Exit; //don't create a message object if we don't have to 
    }

    //recycle context
    hr = HrResetRecipientFilter(pIMailMsgRecipients, &rpfctxt, dwStartDomain, 
                         dwRecipFilterMask, dwRecipFilterFlags, &fContextInit);
    if (FAILED(hr))
        goto Exit;

    hr = pISMTPServer->QueryInterface(IID_ISMTPServerInternal, (void **) &pISMTPServerInternal);
    if (FAILED(hr))
        goto Exit;

    hr = pISMTPServerInternal->AllocBoundMessage(&pIMailMsgPropertiesDSN, &pDSNBody);
    if (FAILED(hr))
        goto Exit;

    //workaround to handle AllocBoundMessage on shutdown
    if (NULL == pDSNBody)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES);
        ErrorTrace((LPARAM) this, "ERROR: AllocBoundMessage failed silently");
        goto Exit;
    }

    //Associate file handle with CDSNBuffer
    hr = dsnbuff.HrInitialize(pDSNBody);
    if (FAILED(hr))
        goto Exit;

    //Get MsgExpire Time
    //Write DSN_RP_HEADER_RETRY_UNTIL using expire FILETIME
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_NDR, 
            sizeof(FILETIME), &cbCurrentSize, (BYTE *) &ftExpireTime);
    if (SUCCEEDED(hr))
    {
        _ASSERT(sizeof(FILETIME) == cbCurrentSize);
        //convert to internet standard
        szExpireTime = szExpireTimeBuffer;

        FileTimeToLocalRFC822Date(ftExpireTime, szExpireTime); 
        cbExpireTime = lstrlen(szExpireTime);

    }
    else if (MAILMSG_E_PROPNOTFOUND == hr)
        hr = S_OK;
    else
        goto Exit;

    hr = HrWriteDSNP1AndP2Headers(dwDSNActionsNeeded,
                                pIMailMsgProperties, pIMailMsgPropertiesDSN,
                                &dsnbuff, szDefaultDomain, cbDefaultDomain,
                                szReportingMTA, cbReportingMTA,
                                szDSNContext, cbDSNContext,
                                szCopyNDRTo, hrStatus,
                                szMimeBoundary, cbMimeBoundary, dwDSNOptions);
    if (FAILED(hr)) 
        goto Exit;

    hr = HrWriteDSNHumanReadable(pIMailMsgPropertiesDSN, pIMailMsgRecipients, 
                                &rpfctxt, dwDSNActionsNeeded, 
                                &dsnbuff, dwPreferredLangId,
                                szMimeBoundary, cbMimeBoundary, hrStatus);
    if (FAILED(hr))
        goto Exit;

    hr = HrWriteDSNReportPerMsgProperties(pIMailMsgProperties,
                                &dsnbuff, szReportingMTA, cbReportingMTA, 
                                szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;


    //recycle context again (may be used during generation of human readable)
    hr = HrResetRecipientFilter(pIMailMsgRecipients, &rpfctxt, dwStartDomain, 
                         dwRecipFilterMask, dwRecipFilterFlags, &fContextInit);
    if (FAILED(hr))
        goto Exit;

    //$$REVIEW - Do we need to keep an "undo" list... or perhaps reverse 
    //engineer what the previous value was in case of a failure
    hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
    while (SUCCEEDED(hr))
    {
        hr = pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_RECIPIENT_FLAGS, &dwCurrentRecipFlags);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, 
                "Failure 0x%08X to get flags for recip %d (per-recip pass)",
                hr, iCurrentRecip);
            goto Exit;
        }

        DebugTrace((LPARAM) this, 
            "Recipient %d with flags 0x%08X found (per-recip pass)",
            iCurrentRecip, dwCurrentRecipFlags);

        if (fdwGetDSNAction(dwDSNActionsNeeded, &dwCurrentRecipFlags, &dwCurrentDSNAction))
        {
            *pdwDSNTypesGenerated |= (dwCurrentDSNAction & DSN_ACTION_TYPE_MASK);
            (*pcRecipsDSNd)++;
            hr = HrWriteDSNReportPreRecipientProperties(pIMailMsgRecipients, &dsnbuff,
                    dwCurrentRecipFlags, iCurrentRecip, szExpireTime, cbExpireTime,
                    dwCurrentDSNAction, dwRFC821Status, hrStatus);
            if (FAILED(hr))
                goto Exit;

            hr = pIMailMsgRecipients->PutDWORD(iCurrentRecip,
                    IMMPID_RP_RECIPIENT_FLAGS, dwCurrentRecipFlags);
            _ASSERT(SUCCEEDED(hr) && "PutDWORD for IMMPID_RP_RECIPIENT_FLAGS FAILED on 2nd pass");
            if (FAILED(hr))
                goto Exit;
        }

        hr = pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
            
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;

    if (!(*pcRecipsDSNd))
        goto Exit; //no work to do

    _VERIFY_MARKED_RECIPS(pIMailMsgRecipients, dwStartDomain, dwDSNActionsNeeded);

    hr = HrWriteDSNClosingAndOriginalMessage(pIMailMsgProperties, 
                        pIMailMsgPropertiesDSN, &dsnbuff, pDSNBody, 
                        dwDSNActionsNeeded, szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgPropertiesDSN->Commit(NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: IMailMsg::Commit failed - hr 0x%08X", hr);
        goto Exit;
    }

    *ppIMailMsgPropertiesDSN = pIMailMsgPropertiesDSN;
    pIMailMsgPropertiesDSN = NULL;

  Exit:
    if (pIMailMsgRecipients)
    {
        if (fContextInit)
        {
            hrTmp = pIMailMsgRecipients->TerminateRecipientFilterContext(&rpfctxt);
            if (FAILED(hrTmp))
            {
                _ASSERT(0 && "TerminateRecipientFilterContext Failed");
                ErrorTrace((LPARAM) this, "ERROR: TerminateRecipientFilterContext failed - hr 0x%08X", hrTmp);
                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
        pIMailMsgRecipients->Release();
    }

    if (pIMailMsgPropertiesDSN)
    {
        IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
        //if non-NULL, then we should not be returning any value
        _ASSERT(NULL == *ppIMailMsgPropertiesDSN);
        //Check for alloc bound message failure
        if (HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) != hr)
        {
            if (SUCCEEDED(pIMailMsgPropertiesDSN->QueryInterface(IID_IMailMsgQueueMgmt, 
                        (void **) &pIMailMsgQueueMgmt)))
            {
                _ASSERT(pIMailMsgQueueMgmt);
                pIMailMsgQueueMgmt->Delete(NULL);
                pIMailMsgQueueMgmt->Release();
            }
        }
        pIMailMsgPropertiesDSN->Release();
    }

    if (pISMTPServerInternal)
        pISMTPServerInternal->Release();

    if (FAILED(hr))
        *pcIterationsLeft = 0;

    //workaround for alloc bound message
    if (HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) == hr)
    {
        hr = S_OK;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::GetFilterMaskAndFlags ]--------------------------------
//
//
//  Description: 
//      Determines what the appropriate mask and flags for a recip serch filter
//      are based on the given actions.
//
//      It may not be possible to constuct a perfectly optimal search (ie Failed
//      and delivered).... this function will attempt to find the "most optimal"
//      search possible.
//  Parameters:
//      dwDSNActions        Requested DSN generation operations
//      pdwRecipMask        Mask to pass to InitializeRecipientFilterContext
//      pdwRecipFlags       Flags to pass to InitializeRecipientFilterContext
//  Returns:
//      S_OK on success
//      E_INVALIDARG if invalid combinations are given
//  History:
//      7/1/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetFilterMaskAndFlags(IN DWORD dwDSNActions, 
                                            OUT DWORD *pdwRecipMask, 
                                            OUT DWORD *pdwRecipFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetFilterMaskAndFlags");
    HRESULT hr = S_OK;
    _ASSERT(pdwRecipMask);
    _ASSERT(pdwRecipFlags);

    //in general we are only interested in un-DSN'd recipients
    *pdwRecipFlags  = 0x00000000;
    *pdwRecipMask   = RP_DSN_HANDLED | RP_DSN_NOTIFY_NEVER;


    //Note these searches are just optimizations... so we don't look at 
    //recipients we don't need to.  However, it may not be possible to 
    //limit the search precisely
    if (DSN_ACTION_FAILURE == dwDSNActions)
    {
        //We are interested in hard failures
        *pdwRecipMask |= RP_GENERAL_FAILURE;
        *pdwRecipFlags |= RP_GENERAL_FAILURE;
    }

    if (!((DSN_ACTION_DELIVERED | DSN_ACTION_RELAYED) & dwDSNActions))
    {
        //are not interested in delivered
        if ((DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED) & dwDSNActions)
        {
            //it is safe to check only undelivered
            *pdwRecipMask |= (RP_DELIVERED ^ RP_HANDLED); //must be un-set
            _ASSERT(!(*pdwRecipFlags & (RP_DELIVERED ^ RP_HANDLED)));
        }
    }
    else
    {
        //$$TODO - can narrow this search more
        //we are interested in delivered
        if (!((DSN_ACTION_FAILURE_ALL | DSN_ACTION_FAILURE| DSN_ACTION_DELAYED) 
            & dwDSNActions))
        {
            //it is safe to check only delivered
            *pdwRecipMask |= RP_DELIVERED;
            *pdwRecipFlags |= RP_DELIVERED;
        }
    }

    DebugTrace((LPARAM) this, 
        "DSN Action 0x%08X, Recip mask 0x%08X, Recip flags 0x%08X",
        dwDSNActions, pdwRecipMask, pdwRecipFlags);
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::fdwGetDSNAction ]--------------------------------------
//
//
//  Description: 
//      Determines what DSN action needs to happen on a recipient based on 
//      the requested DSN actions and the recipient flags
//  Parameters:
//      IN     dwDSNAction          The requested DSN actions
//      IN OUT pdwCurrentRecipFlags The flags for current recipient... set to
//                                  what there new value should be
//      OUT    pdwCurrentDSNAction  The DSN action that needs to be performed
//                                  On this recipient (DSN_ACTION_FAILURE is
//                                  used to denote sending a NDR)
//  Returns:
//      TRUE if some DSN action must be taken for this recipient
//      FALSE if no DSN action is need
//  History:
//      7/2/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CDefaultDSNSink::fdwGetDSNAction(IN DWORD dwDSNAction, 
                                      IN OUT DWORD *pdwCurrentRecipFlags,
                                      OUT DWORD *pdwCurrentDSNAction)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::fdwGetDSNAction");
    _ASSERT(pdwCurrentRecipFlags);
    BOOL    fResult = FALSE;
    DWORD   dwOriginalRecipFlags = *pdwCurrentRecipFlags;
    DWORD   dwFlags = 0;

    //This should never be hit because of the filter
    _ASSERT(!(*pdwCurrentRecipFlags & (RP_DSN_HANDLED | RP_DSN_NOTIFY_NEVER)));
    
    if (DSN_ACTION_FAILURE & dwDSNAction)
    {
        if ((RP_GENERAL_FAILURE & *pdwCurrentRecipFlags) &&
            ((RP_DSN_NOTIFY_FAILURE & *pdwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & *pdwCurrentRecipFlags))))

        {
            DebugTrace((LPARAM) this, "Recipient matched for FAILURE DSN");
            fResult = TRUE;
            *pdwCurrentRecipFlags |= RP_DSN_SENT_NDR;
            *pdwCurrentDSNAction = DSN_ACTION_FAILURE;
            goto Exit;
        }
    }
    
    if (DSN_ACTION_FAILURE_ALL & dwDSNAction)
    {
        //Fail all non-delivered that we haven't sent notifications for
        if (((!((RP_DSN_HANDLED | (RP_DELIVERED ^ RP_HANDLED)) & *pdwCurrentRecipFlags))) &&
            ((RP_DSN_NOTIFY_FAILURE & *pdwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & *pdwCurrentRecipFlags))))
        {
            //Don't send failures for expanded DL;s
            if (RP_EXPANDED != (*pdwCurrentRecipFlags & RP_EXPANDED))
            {
                DebugTrace((LPARAM) this, "Recipient matched for FAILURE (all) DSN");
                fResult = TRUE;
                *pdwCurrentRecipFlags |= RP_DSN_SENT_NDR;
                *pdwCurrentDSNAction = DSN_ACTION_FAILURE;
                goto Exit;
            }
        }
    }

    if (DSN_ACTION_DELAYED & dwDSNAction)
    {
        //send at most 1 delay DSN
        //Also send only if DELAY was requested or no specific instructions were
        //specified
        if ((!((RP_DSN_SENT_DELAYED | RP_HANDLED) & *pdwCurrentRecipFlags)) &&
            ((RP_DSN_NOTIFY_DELAY & *pdwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & *pdwCurrentRecipFlags))))
        {
            DebugTrace((LPARAM) this, "Recipient matched for DELAYED DSN");
            fResult = TRUE;
            *pdwCurrentRecipFlags |= RP_DSN_SENT_DELAYED;
            *pdwCurrentDSNAction = DSN_ACTION_DELAYED;
            goto Exit;
        }
    }
        
    if (DSN_ACTION_RELAYED & dwDSNAction)
    {
        //send relay if it was delivered *and* DSN not supported by remote MTA
        //*and* notification of success was explicitly requested
        dwFlags = (RP_DELIVERED ^ RP_HANDLED) | 
                   RP_REMOTE_MTA_NO_DSN | 
                   RP_DSN_NOTIFY_SUCCESS;
        if ((dwFlags & *pdwCurrentRecipFlags) == dwFlags)
        {
            DebugTrace((LPARAM) this, "Recipient matched for RELAYED DSN");
            fResult = TRUE;
            *pdwCurrentRecipFlags |= RP_DSN_SENT_RELAYED;
            *pdwCurrentDSNAction = DSN_ACTION_RELAYED;
            goto Exit;
        }
    }

    if (DSN_ACTION_DELIVERED & dwDSNAction)
    {
        //send delivered if it was delivered *and* no DSN sent yet
        dwFlags = (RP_DELIVERED ^ RP_HANDLED) | RP_DSN_NOTIFY_SUCCESS;
        _ASSERT(!(*pdwCurrentRecipFlags & RP_DSN_HANDLED)); //should be filtered out
        if ((dwFlags & *pdwCurrentRecipFlags) == dwFlags)
        {
            DebugTrace((LPARAM) this, "Recipient matched for SUCCESS DSN");
            fResult = TRUE;
            *pdwCurrentRecipFlags |= RP_DSN_SENT_DELIVERED;
            *pdwCurrentDSNAction = DSN_ACTION_DELIVERED;
            goto Exit;
        }
    }

    if (DSN_ACTION_EXPANDED & dwDSNAction)
    {
        //Send expanded if the recipient is marked as expanded and 
        //NOTIFY=SUCCESS was requested
        if ((RP_EXPANDED == (*pdwCurrentRecipFlags & RP_EXPANDED)) && 
            (*pdwCurrentRecipFlags & RP_DSN_NOTIFY_SUCCESS) && 
            !(*pdwCurrentRecipFlags & RP_DSN_SENT_EXPANDED))
        {
            DebugTrace((LPARAM) this, "Recipient matched for EXPANDED DSN");
            fResult = TRUE;
            *pdwCurrentRecipFlags |= RP_DSN_SENT_EXPANDED;
            *pdwCurrentDSNAction = DSN_ACTION_EXPANDED;
            goto Exit;
        }
    }

  Exit:
    if (!fResult)
    {
        DebugTrace((LPARAM) this, 
            "Recip with flags 0x%08X will not generate DSN for action 0x%08X",
            dwOriginalRecipFlags, dwDSNAction);
    }
    TraceFunctLeave();
    return fResult;
}

//---[ CDefaultDSNSink::GetCurrentMimeBoundary ]-------------------------------
//
//
//  Description: 
//      Creates unique MIME-boundary for message.
//
//      Format we are using for boundary is string versions of the following:
//          MIME_BOUNDARY_CONSTANT 
//          FILETIME at start
//          DWORD count of DSNs Requested
//          16 bytes of our virtual server's domain name
//  Parameters:
//      IN     szReportingMTA   reporting MTA
//      IN     cbReportingMTA   String length of reporting MTA
//      IN OUT szMimeBoundary   Buffer to put boundary in (size is MIME_BOUNDARY_SIZE)
//      OUT    cbMimeBoundary   Amount of buffer used for MIME Boundary
//  Returns:
//      -
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDefaultDSNSink::GetCurrentMimeBoundary(
                    IN LPSTR szReportingMTA,
                    IN DWORD cbReportingMTA,
                    IN OUT CHAR szMimeBoundary[MIME_BOUNDARY_SIZE],
                    OUT DWORD *pcbMimeBoundary)
{
    _ASSERT(MIME_BOUNDARY_RFC2046_LIMIT >= MIME_BOUNDARY_SIZE);

    DWORD   iCurrentOffset = 0;
    szMimeBoundary[MIME_BOUNDARY_SIZE-1] = '\0';
    CHAR    *pcharCurrent = NULL;
    CHAR    *pcharStop = NULL;

    memcpy(szMimeBoundary+iCurrentOffset, MIME_BOUNDARY_CONSTANT, 
            sizeof(MIME_BOUNDARY_CONSTANT)-1);

    iCurrentOffset += sizeof(MIME_BOUNDARY_CONSTANT)-1;

    memcpy(szMimeBoundary+iCurrentOffset, m_szPerInstanceMimeBoundary,
            MIME_BOUNDARY_START_TIME_SIZE);

    iCurrentOffset += MIME_BOUNDARY_START_TIME_SIZE;

    wsprintf(szMimeBoundary+iCurrentOffset, "%08X", 
            InterlockedIncrement((PLONG) &m_cDSNsRequested));

    iCurrentOffset += 8;

    if (cbReportingMTA >= MIME_BOUNDARY_SIZE-iCurrentOffset)
    {
        memcpy(szMimeBoundary+iCurrentOffset, szReportingMTA,
            MIME_BOUNDARY_SIZE-iCurrentOffset - 1);
        *pcbMimeBoundary = MIME_BOUNDARY_SIZE-1;
    }
    else
    {
        memcpy(szMimeBoundary+iCurrentOffset, szReportingMTA,
            cbReportingMTA);
        szMimeBoundary[iCurrentOffset + cbReportingMTA] = '\0';
        *pcbMimeBoundary = iCurrentOffset + cbReportingMTA;
    }

    //Now we need to verify that the passed in string can be part of a valid
    //MIME Header
    pcharStop = szMimeBoundary + *pcbMimeBoundary;
    for (pcharCurrent = szMimeBoundary + iCurrentOffset; 
         pcharCurrent < pcharStop; 
         pcharCurrent++)
    {
      if (!fIsValidMIMEBoundaryChar(*pcharCurrent))
        *pcharCurrent = '?';  //turn it into a valid character
    }

    _ASSERT_MIME_BOUNDARY(szMimeBoundary);

    _ASSERT('\0' == szMimeBoundary[MIME_BOUNDARY_SIZE-1]);
}

//---[ CDefaultDSNSink::HrWriteDSNP1AndP2Headers ]-----------------------------
//
//
//  Description: 
//      Writes global DSN P1 Properties to IMailMsgProperties
//  Parameters:
//      dwDSNAction             DSN action specified for sink
//      pIMailMsgProperties     Msg that DSN is being generated for
//      pIMailMsgPropertiesDSN  DSN being generated
//      psndbuff                Buffer to write  to
//      szDefaultDomain         Default domain - used from postmaster from address
//      cbDefaultDomain         strlen of szDefaultDomain
//      szReportingMTA          Reporting MTA as passed to event sink
//      cbReportingMTA          strlen of szReportingMTA
//      szDSNConext             Debug File and line number info passed in
//      cbDSNConext             strlen of szDSNContext
//      szCopyNDRTo             SMTP Address to copy NDR to
//      hrStatus                Status to record in DSN context
//      szMimeBoundary          MIME boundary string
//      cbMimeBoundary          strlen of MIME boundary
//      dwDSNOptions            DSN Options flags
//  Returns:
//      S_OK on success
//  History:
//      7/5/98 - MikeSwa Created 
//      8/14/98 - MikeSwa Modified - Added DSN context headers
//      11/9/98 - MikeSwa Added copy NDR to functionality
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNP1AndP2Headers(
                                  IN DWORD dwDSNAction,
                                  IN IMailMsgProperties *pIMailMsgProperties,
                                  IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                  IN CDSNBuffer *pdsnbuff,
                                  IN LPSTR szDefaultDomain,
                                  IN DWORD cbDefaultDomain,
                                  IN LPSTR szReportingMTA,
                                  IN DWORD cbReportingMTA,
                                  IN LPSTR szDSNContext,
                                  IN DWORD cbDSNContext,
                                  IN LPSTR szCopyNDRTo,
                                  IN HRESULT hrStatus,
                                  IN LPSTR szMimeBoundary,
                                  IN DWORD cbMimeBoundary,
                                  IN DWORD dwDSNOptions)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteDSNP1AndP2Headers");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    CHAR  szBuffer[512];
    LPSTR szSender = (LPSTR) szBuffer; //tricks to avoid AV'ing in AddPrimary
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    DWORD dwRecipAddressProp = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwSMTPAddressProp = IMMPID_RP_ADDRESS_SMTP;
    DWORD iCurrentAddressProp = 0;
    DWORD dwDSNRecipient = 0;
    DWORD cbPostMaster = 0;
    CHAR  szDSNAction[15];
    FILETIME ftCurrentTime;
    CHAR    szCurrentTimeBuffer[MAX_RFC822_DATE_SIZE];

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pIMailMsgPropertiesDSN);
    _ASSERT(pdsnbuff);

    szBuffer[0] = '\0';
    
    //Get and write Message tracking properties
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SERVER_VERSION,
            sizeof(szBuffer), szBuffer);
    if (SUCCEEDED(hr))
    {   
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_SERVER_VERSION, szBuffer);
        if (FAILED(hr))
            DebugTrace((LPARAM) this, 
                "Warning: Unable to write version to msg - 0x%08X", hr);
        hr = S_OK;
    }
    else
    {
        DebugTrace((LPARAM) this, 
            "Warning: Unable to get server version from msg - 0x%08X", hr);
        hr = S_OK; //ignore this non-fatal error
    }

    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SERVER_NAME,
            sizeof(szBuffer), szBuffer);
    if (SUCCEEDED(hr))
    {   
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_SERVER_NAME, szBuffer);
        if (FAILED(hr))
            DebugTrace((LPARAM) this, 
                "Warning: Unable to write server name to msg - 0x%08X", hr);
        hr = S_OK;
    }
    else
    {
        DebugTrace((LPARAM) this, 
            "Warning: Unable to get server name from msg - 0x%08X", hr);
        hr = S_OK; //ignore this non-fatal error
    }

    //Set the type of message
    if (dwDSNAction & 
            (DSN_ACTION_EXPANDED | DSN_ACTION_RELAYED | DSN_ACTION_DELIVERED)) {
        hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSGCLASS, 
                                                MP_MSGCLASS_DELIVERY_REPORT);
    } else if (dwDSNAction & 
           (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED)) {
        hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSGCLASS, 
                                                MP_MSGCLASS_NONDELIVERY_REPORT);
    }

    if (FAILED(hr)) {
        DebugTrace((LPARAM) this,
            "Warning: Unable to set msg class for dsn - 0x%08X", hr);
        hr = S_OK;
    }

    for (iCurrentAddressProp = 0; 
         iCurrentAddressProp < NUM_DSN_ADDRESS_PROPERTIES;
         iCurrentAddressProp++)
    {
        szBuffer[0] = '\0';
        //Get the sender of the original message
        hr = pIMailMsgProperties->GetStringA(
                g_rgdwSenderPropIDs[iCurrentAddressProp], 
                sizeof(szBuffer), szBuffer);
        if (FAILED(hr) && (MAILMSG_E_PROPNOTFOUND != hr))
        {
            ErrorTrace((LPARAM) this,
                "ERROR: Unable to get 0x%X sender of IMailMsg %p",
                g_rgdwSenderPropIDs[iCurrentAddressProp], pIMailMsgProperties);
            goto Exit;
        }
        
        //
        //  If we have found an address break
        //
        if (SUCCEEDED(hr))
            break;
    }

    //
    //  If we failed to get a property... bail
    //
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "ERROR: Unable to get any sender of IMailMsg 0x%08X",
            pIMailMsgProperties);
        goto Exit;
    }

    //write DSN Sender (P1) 
    hr = pIMailMsgPropertiesDSN->PutProperty(IMMPID_MP_SENDER_ADDRESS_SMTP, 
        sizeof(DSN_MAIL_FROM), (BYTE *) DSN_MAIL_FROM);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, 
            "ERROR: Unable to write P1 DSN sender for IMailMsg 0x%08X", 
            pIMailMsgProperties);
        goto Exit;
    }

    //write DSN Recipient
    hr = pIMailMsgPropertiesDSN->QueryInterface(IID_IMailMsgRecipients, 
                                           (void **) &pIMailMsgRecipients);

    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgRecipients failed");

    if (FAILED(hr))
        goto Exit;
    
    hr = pIMailMsgRecipients->AllocNewList(&pIMailMsgRecipientsAdd);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, 
            "ERROR: Unable to Alloc List for DSN generation of IMailMsg 0x%08X", 
            pIMailMsgProperties);
        goto Exit;
    }

    dwRecipAddressProp = g_rgdwRecipPropIDs[iCurrentAddressProp];
    hr = pIMailMsgRecipientsAdd->AddPrimary(
                    1,
                    (LPCSTR *) &szSender,
                    &dwRecipAddressProp,
                    &dwDSNRecipient,
                    NULL,
                    0);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, 
            "ERROR: Unable to write DSN recipient for IMailMsg 0x%p hr - 0x%08X", 
            pIMailMsgProperties, hr);
        goto Exit;
    }


    //Write Address to copy NDR to (NDRs only)
    if (szCopyNDRTo && 
        (dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL)))
    {
        hr = pIMailMsgRecipientsAdd->AddPrimary(
                        1,
                        (LPCSTR *) &szCopyNDRTo,
                        &dwSMTPAddressProp,
                        &dwDSNRecipient,
                        NULL,
                        0);

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, 
                "ERROR: Unable to write DSN recipient for IMailMsg 0x%08X", 
                pIMailMsgProperties);
            goto Exit;
        }
    }

    //write P2 DSN sender 
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RFC822_SENDER, sizeof(DSN_RFC822_SENDER)-1);
    if (FAILED(hr))
        goto Exit;
 
    hr = pdsnbuff->HrWriteBuffer((BYTE *) szDefaultDomain, cbDefaultDomain);
    if (FAILED(hr))
        goto Exit;

    //
    //  If we do not have a SMTP address, write a blank BCC instead of 
    //  a TO address (since we do not have a address we can write in the 822.
    //  This is similar to what we do with the pickup dir when we have no TO
    //  headers.
    //
    if (IMMPID_MP_SENDER_ADDRESS_SMTP == g_rgdwSenderPropIDs[iCurrentAddressProp])
    {

        //Write P2 "To:" header (using the szSender value we determined above)
        hr = pdsnbuff->HrWriteBuffer((BYTE *) TO_HEADER, sizeof(TO_HEADER)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szSender, lstrlen(szSender));
        if (FAILED(hr))
            goto Exit;

        //Save recipient (original sender) for Queue Admin/Message Tracking
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_TO_ADDRESS, szSender);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) BCC_HEADER, sizeof(BCC_HEADER)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //Use szBuffer to construct 822 from to set for Queue Admin/Msg Tracking
    //"Postmaster@" + max of 64 characters should be less than 1/2 K!!
    _ASSERT(sizeof(szBuffer) > sizeof(DSN_SENDER_ADDRESS_PREFIX) + cbReportingMTA);
    memcpy(szBuffer, DSN_SENDER_ADDRESS_PREFIX, sizeof(DSN_SENDER_ADDRESS_PREFIX));
    strncat(szBuffer, szDefaultDomain, sizeof(szBuffer) - sizeof(DSN_SENDER_ADDRESS_PREFIX));
    hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_FROM_ADDRESS, szSender);
    if (FAILED(hr))
        goto Exit;

    //Write P2 "Date:" header
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DATE_HEADER, sizeof(DATE_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //Get current time 
    GetSystemTimeAsFileTime(&ftCurrentTime);
    FileTimeToLocalRFC822Date(ftCurrentTime, szCurrentTimeBuffer);

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szCurrentTimeBuffer, lstrlen(szCurrentTimeBuffer));
    if (FAILED(hr))
        goto Exit;

    //Write the MIME header
    hr = pdsnbuff->HrWriteBuffer( (BYTE *) MIME_HEADER, sizeof(MIME_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) "\"", sizeof(CHAR));
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) "\"", sizeof(CHAR));
    if (FAILED(hr))
        goto Exit;

    //write x-DSNContext header
    if (DSN_OPTIONS_WRITE_CONTEXT & dwDSNOptions)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CONTEXT_HEADER, 
                                     sizeof(DSN_CONTEXT_HEADER)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNContext, cbDSNContext);
        if (FAILED(hr))
            goto Exit;

        wsprintf(szDSNAction, " (0x%08X)", dwDSNAction);
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNAction, 13);
        if (FAILED(hr))
            goto Exit;

        wsprintf(szDSNAction, " (0x%08X)", hrStatus);
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNAction, 13);
        if (FAILED(hr))
            goto Exit;
    }

    //Get and write the message ID
    if (fGenerateDSNMsgID(szReportingMTA, cbReportingMTA, szBuffer, sizeof(szBuffer)))
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) MSGID_HEADER, sizeof(MSGID_HEADER)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, strlen(szBuffer));
        if (FAILED(hr))
            goto Exit;

        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_MSG_ID,
                                                szBuffer);
        if (FAILED(hr))
            goto Exit;
    }
  Exit:

    if (pIMailMsgRecipients)
    {
        if (pIMailMsgRecipientsAdd)
        {
            hrTmp = pIMailMsgRecipients->WriteList( pIMailMsgRecipientsAdd );
            _ASSERT(SUCCEEDED(hrTmp) && "Go Get Keith");

            if (FAILED(hrTmp) && SUCCEEDED(hr))
                hr = hrTmp;
        }

        pIMailMsgRecipients->Release();
    }

    if (pIMailMsgRecipientsAdd)
        pIMailMsgRecipientsAdd->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteDSNHumanReadable ]------------------------------
//
//
//  Description: 
//      Write human readable portion of DSN (including subject header)
//  Parameters:
//      pIMailMsgProperties     Message DSN is being generated for
//      pIMailMsgREcipeints     Recip Interface for Message 
//      prpfctxt                Delivery context that DSN's are being generated for
//      dwDSNActions            DSN actions being taken (after looking at recips)
//                              So we can generate a reasonable subject
//      pdsnbuff                DSN Buffer to write content to
//      PreferredLangId         Preferred language to generate DSN in
//      szMimeBoundary          MIME boundary string
//      cbMimeBoundary          strlen of MIME boundary
//      hrStatus                Status to use to decide which text to display
//  Returns:
//      S_OK on success
//  History:
//      7/5/98 - MikeSwa Created 
//      12/15/98 - MikeSwa Added list of recipients & fancy human readable
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNHumanReadable(
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN RECIPIENT_FILTER_CONTEXT *prpfctxt,
                                IN DWORD dwDSNActions,
                                IN CDSNBuffer *pdsnbuff,
                                IN DWORD dwPreferredLangId,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                IN HRESULT hrStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteDSNHumanReadable");
    HRESULT hr = S_OK;
    DWORD dwDSNType = (dwDSNActions & DSN_ACTION_TYPE_MASK);
    LANGID LangID = (LANGID) dwPreferredLangId;
    CUTF7ConversionContext utf7conv(FALSE);
    CUTF7ConversionContext utf7convSubject(TRUE);
    BOOL   fWriteRecips = TRUE;
    WORD   wSubjectID = GENERAL_SUBJECT;
    LPWSTR wszSubject = NULL;
    LPWSTR wszStop    = NULL;
    DWORD  cbSubject = 0;
    LPSTR  szSubject = NULL;
    LPSTR  szSubjectCurrent = NULL;

    if (!fLanguageAvailable(LangID))
    {
        //Use default of server
        LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) SUBJECT_HEADER, sizeof(SUBJECT_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //Set conversion context to UTF7 for RFC1522 subject
    pdsnbuff->SetConversionContext(&utf7convSubject);

    //Write subject with useful info
    if (((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & dwDSNType) == dwDSNType)
        wSubjectID = FAILURE_SUBJECT;
    else if (DSN_ACTION_RELAYED == dwDSNType)
        wSubjectID = RELAY_SUBJECT;
    else if (DSN_ACTION_DELAYED == dwDSNType)
        wSubjectID = DELAY_SUBJECT;
    else if (DSN_ACTION_DELIVERED == dwDSNType)
        wSubjectID = DELIVERED_SUBJECT;
    else if (DSN_ACTION_EXPANDED == dwDSNType)
        wSubjectID = EXPANDED_SUBJECT;

    hr = pdsnbuff->HrWriteResource(wSubjectID, LangID);
    if (FAILED(hr))
        goto Exit;

    //Write *English* subject for Queue Admin/Message tracking
    //Use english, becuase we return a ASCII string to queue admin
    hr = pdsnbuff->HrLoadResourceString(wSubjectID, 
                            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), 
                            &wszSubject, &cbSubject);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "Unable to get resource for english subject 0x%08X", hr);
    }
    else
    {
        //We need to convert from UNICODE to ASCII... remember resource is not 
        //NULL terminated
        szSubject = (LPSTR) pvMalloc(cbSubject/sizeof(WCHAR) + 1);
        wszStop = wszSubject + (cbSubject/sizeof(WCHAR));
        if (szSubject)
        {
            szSubjectCurrent = szSubject;
            while ((wszSubject < wszStop) && *wszSubject)
            {
                wctomb(szSubjectCurrent, *wszSubject);
                szSubjectCurrent++;
                wszSubject++;
            }
            *szSubjectCurrent = '\0';
            pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_MSG_SUBJECT, szSubject);
            FreePv(szSubject);
        }

    }



    pdsnbuff->ResetConversionContext();

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //write summary saying that this is a MIME message
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MESSAGE_SUMMARY, sizeof(MESSAGE_SUMMARY)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    //Write content type
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE, sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HUMAN_READABLE_TYPE, sizeof(DSN_HUMAN_READABLE_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_MIME_CHARSET_HEADER, sizeof(DSN_MIME_CHARSET_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //For now... we do our encoding as UTF7.... put that as the charset
    hr = pdsnbuff->HrWriteBuffer((BYTE *) UTF7_CHARSET, sizeof(UTF7_CHARSET)-1);
    if (FAILED(hr))
        goto Exit;
    
    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //Set conversion context to UTF7
    pdsnbuff->SetConversionContext(&utf7conv);

    hr = pdsnbuff->HrWriteResource(DSN_SUMMARY, LangID);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //Describe the type of DSN
    if (((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & dwDSNType) == dwDSNType)
    {
        //See if we have a failure-specific message
        switch(hrStatus)
        {
#ifdef NEVER
            //CAT can generate errors other than unresolved recipeints
            //We will use the generic DSN failure message rather than confuse 
            //recipients
            case CAT_W_SOME_UNDELIVERABLE_MSGS:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_MAILBOX, LangID);
                break;
#endif //NEVER
           case AQUEUE_E_MAX_HOP_COUNT_EXCEEDED:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_HOP, LangID);
                break;
            case AQUEUE_E_MSG_EXPIRED:
            case AQUEUE_E_HOST_NOT_RESPONDING:
            case AQUEUE_E_CONNECTION_DROPPED:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_EXPIRE, LangID);
                break;
            default:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY, LangID);
        }
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_RELAYED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(RELAY_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_DELAYED == dwDSNType)
    {
        //UE want this three line warning.
        hr = pdsnbuff->HrWriteResource(DELAY_WARNING, LangID);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteResource(DELAY_DO_NOT_SEND, LangID);
        if (FAILED(hr))
            goto Exit;
        
        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteResource(DELAY_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_DELIVERED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(DELIVERED_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_EXPANDED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(EXPANDED_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //In retail this will cause an extra blank line to appear in the DSN, 
        _ASSERT(0 && "Unsupported DSN Action");
        fWriteRecips = FALSE;
    }

    //Write a list of recipients for this DSN
    if (fWriteRecips)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = HrWriteHumanReadableListOfRecips(pIMailMsgRecipients, prpfctxt,
                                              dwDSNType, pdsnbuff);

        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;
    }



    //Extra space to have nicer formatting in Outlook 97.
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Reset resource conversion context to default
    pdsnbuff->ResetConversionContext();


  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteDSNReportPerMsgProperties ]---------------------
//
//
//  Description: 
//      Write the per-msg portion of the DSN Report
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pdsnbuff                CDSNBuffer to write content to
//      szReportingMTA          MTA requesting DSN
//      cbReportingMTA          String length of reporting MTA
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNReportPerMsgProperties(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szReportingMTA,
                                IN DWORD cbReportingMTA,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    HRESULT hr = S_OK;
    CHAR szPropBuffer[PROP_BUFFER_SIZE];
    _ASSERT(szReportingMTA && cbReportingMTA);


    //Write properly formatted MIME boundary and report type
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, 
            sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE, 
            sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_MIME_TYPE, sizeof(DSN_MIME_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_HEADER_ENVID if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_DSN_ENVID_VALUE, 
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_ENVID, 
                    sizeof(DSN_HEADER_ENVID)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else 
            goto Exit;
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_REPORTING_MTA, 
                sizeof(DSN_HEADER_REPORTING_MTA)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szReportingMTA, cbReportingMTA);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_HEADER_RECEIVED_FROM if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_HELO_DOMAIN, 
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_RECEIVED_FROM, 
                    sizeof(DSN_HEADER_RECEIVED_FROM)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else 
            goto Exit;
    }

    //Write DSN_HEADER_ARRIVAL_DATE if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_ARRIVAL_TIME, 
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_ARRIVAL_DATE, 
                    sizeof(DSN_HEADER_ARRIVAL_DATE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else 
            goto Exit;
    }

  Exit:
    return hr;
}


//---[ CDefaultDSNSink::HrWriteDSNReportPreRecipientProperties ]---------------
//
//
//  Description: 
//      Write a per-recipient portion of the DSN Report
//  Parameters:
//      pIMailMsgRecipients     IMailMsgProperties that DSN is being generated for
//      pdsnbuff                CDSNBuffer to write content to
//      dwRecipFlags            Recipient flags that we be we for this recipient
//      iRecip                  Recipient to generate report for
//      szExpireTime            Time (if known) when message expires
//      cbExpireTime            size of string
//      dwDSNAction             DSN Action to take for this recipient
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//  Returns:
//      S_OK on success
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNReportPreRecipientProperties(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN CDSNBuffer *pdsnbuff,
                                IN DWORD dwRecipFlags,
                                IN DWORD iRecip,
                                IN LPSTR szExpireTime,
                                IN DWORD cbExpireTime,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status,
                                IN HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    CHAR szBuffer[PROP_BUFFER_SIZE];
    CHAR szStatus[STATUS_STRING_SIZE];
    BOOL fFoundDiagnostic = FALSE;
    CHAR szAddressType[PROP_BUFFER_SIZE];

    //Write blank line between recipient reports (recip fields start with \n)
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_RP_HEADER_ORCPT if we have it
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_DSN_ORCPT_VALUE, 
        PROP_BUFFER_SIZE, szBuffer);
    if (S_OK == hr) //prop was found
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ORCPT, sizeof(DSN_RP_HEADER_ORCPT)-1);
        if (FAILED(hr))
            goto Exit;

        //write address value - type should be included in this property
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else 
            goto Exit;
    }

    //Write DSN_RP_HEADER_FINAL_RECIP
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_FINAL_RECIP, sizeof(DSN_RP_HEADER_FINAL_RECIP)-1);
    if (FAILED(hr))
        goto Exit;

    //Check for IMMPID_RP_DSN_PRE_CAT_ADDRESS first
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_DSN_PRE_CAT_ADDRESS, 
        PROP_BUFFER_SIZE, szBuffer);
    if (S_OK == hr) //prop was found
    {
        //write address value - type should be included in this property
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else //we need to use IMMPID_RP_ADDRESS_SMTP instead
    {
        hr = HrGetRecipAddressAndType(pIMailMsgRecipients, iRecip, PROP_BUFFER_SIZE,
                                      szBuffer, sizeof(szAddressType), szAddressType);

        if (SUCCEEDED(hr))
        {
            //write address type
            hr = pdsnbuff->HrWriteBuffer((BYTE *) szAddressType, lstrlen(szAddressType));
            if (FAILED(hr))
                goto Exit;

            hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_TYPE_DELIMITER, sizeof(DSN_HEADER_TYPE_DELIMITER)-1);
            if (FAILED(hr))
                goto Exit;

            //write address value
            hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
            if (FAILED(hr))
                goto Exit;
        }
        else
        {
            _ASSERT(SUCCEEDED(hr) && "Recipient address *must* be present");
        }


    }

    //Write DSN_RP_HEADER_ACTION
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION, sizeof(DSN_RP_HEADER_ACTION)-1);
    if (FAILED(hr))
        goto Exit;

    if (dwDSNAction & DSN_ACTION_FAILURE)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_FAILURE, 
                        sizeof(DSN_RP_HEADER_ACTION_FAILURE)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_DELAYED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_DELAYED, 
                        sizeof(DSN_RP_HEADER_ACTION_DELAYED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_RELAYED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_RELAYED, 
                        sizeof(DSN_RP_HEADER_ACTION_RELAYED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_DELIVERED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_DELIVERED, 
                        sizeof(DSN_RP_HEADER_ACTION_DELIVERED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_EXPANDED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_EXPANDED, 
                        sizeof(DSN_RP_HEADER_ACTION_EXPANDED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        _ASSERT(0 && "No DSN Action requested");
    }


    //Write DSN_RP_HEADER_STATUS
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_STATUS, 
                    sizeof(DSN_RP_HEADER_STATUS)-1);
    if (FAILED(hr))
        goto Exit;

    //Get status code
    hr = HrGetStatusCode(pIMailMsgRecipients, iRecip, dwDSNAction,
            dwRFC821Status, hrStatus, 
            dwRecipFlags, PROP_BUFFER_SIZE, szBuffer, szStatus);
    if (FAILED(hr))
        goto Exit;
    if (S_OK == hr)
    {
        //found diagnostic code
        fFoundDiagnostic = TRUE;
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szStatus, lstrlen(szStatus));
    if (FAILED(hr))
        goto Exit;

    if (fFoundDiagnostic)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_DIAG_CODE, 
                        sizeof(DSN_RP_HEADER_DIAG_CODE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
        if (FAILED(hr))
            goto Exit;

    }

    //Write DSN_RP_HEADER_RETRY_UNTIL using expire time if delay
    if (szExpireTime && (DSN_ACTION_DELAYED & dwDSNAction))
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_RETRY_UNTIL, 
                        sizeof(DSN_RP_HEADER_RETRY_UNTIL)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szExpireTime, cbExpireTime);
        if (FAILED(hr))
            goto Exit;
    }
  
  Exit:
    return hr;
}

//---[ CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage ]------------------
//
//
//  Description: 
//      Writes the closing of the DSN as well as the end of the 
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      dwDSNAction             DSN actions for this DSN
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//
//  History:
//      7/6/98 - MikeSwa Created 
//      1/6/2000 - MikeSwa Modified to add RET=HDRS support
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN DWORD   dwDSNAction,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage");
    HRESULT hr = S_OK;
    BOOL    fHeadersOnly = FALSE;
    BOOL    fRetSpecified = FALSE;
    CHAR    szRET[] = "FULL";

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    //Write Body content type MIME_CONTENT_TYPE = rfc822
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE, sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RFC822_TYPE, sizeof(DSN_RFC822_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //Determine if we want to return the full message or minimal headers.
    //The logic for this is:
    //  - Obey explicit RET (IMMPID_MP_DSN_RET_VALUE) values
    //  - Default to HDRS for all non-error DSNs
    //  - Default to FULL on errors
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_DSN_RET_VALUE, sizeof(szRET),
                                         szRET);
    if (SUCCEEDED(hr))
    {
        fRetSpecified = TRUE;
        if(!_strnicmp(szRET, (char * )"FULL", 4))
            fHeadersOnly = FALSE;
        else if (!_strnicmp(szRET, (char * )"HDRS", 4))
            fHeadersOnly = TRUE;
        else
            fRetSpecified = FALSE;
    }
    else
        hr = S_OK; //treat has if property not specified
    
    if (!fRetSpecified)
    {
        if ((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED) 
             & dwDSNAction)
            fHeadersOnly = FALSE;
        else
            fHeadersOnly = TRUE;
    }

    //
    //  $$NOTE$$
    //  Due to interop problems, we are removing support for HDRS, since
    //  it is causing malformed DSNs to appear.
    //
    fHeadersOnly = FALSE;

    if (fHeadersOnly)
    {
        hr = HrWriteOriginalMessageHeaders(pIMailMsgProperties, pIMailMsgPropertiesDSN,
                    pdsnbuff, pDestFile, szMimeBoundary, cbMimeBoundary);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        hr = HrWriteOriginalMessageFull(pIMailMsgProperties, pIMailMsgPropertiesDSN,
                    pdsnbuff, pDestFile, szMimeBoundary, cbMimeBoundary);
        if (FAILED(hr))
            goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteOriginalMessageFull ]---------------------------
//
//
//  Description: 
//      Writes the entire original message to the DSN
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//  History:
//      1/6/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteOriginalMessageFull(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteOriginalMessageFull");
    HRESULT hr = S_OK;
    DWORD   dwFileSize = 0;
    DWORD   dwOrigMsgSize = 0;
    DWORD   dwDontCare = 0;

    //Get the content size, so we know were we can start writing at
    hr = pIMailMsgProperties->GetContentSize(&dwOrigMsgSize, NULL);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrSeekForward(dwOrigMsgSize, &dwFileSize);
    if (FAILED(hr))
        goto Exit;

    //Set size hint property on DSN for Queue Admin/Message Tracking
    hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSG_SIZE_HINT, 
                                       dwOrigMsgSize + dwFileSize);
    if (FAILED(hr))
    {
        //We really don't care too much about a failure with this
        ErrorTrace((LPARAM) this, "Error writing size hint 0x%08X", hr);
        hr = S_OK;
    }

    //Write at end of file - *before* file handle is lost to IMailMsg,
    hr = HrWriteMimeClosing(pdsnbuff, szMimeBoundary, cbMimeBoundary, &dwDontCare);
    if (FAILED(hr))
        goto Exit;

    //write body
    hr = pIMailMsgProperties->CopyContentToFileAtOffset(pDestFile, dwFileSize, NULL);
    if (FAILED(hr))
        goto Exit;
  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteOriginalMessageHeaders ]------------------------
//
//
//  Description: 
//      Writes only the headers of the original message to the DSN
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//  History:
//      1/6/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteOriginalMessageHeaders(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteOriginalMessageHeaders");
    HRESULT hr = S_OK;
    DWORD   dwFileSize = 0;
    CHAR    szPropBuffer[1026] = "";
    DWORD   cbPropSize = 0;


    //Loop through the 822 properties that we care about and write them
    //to the message.  A truely RFC-compliant version would re-parse the 
    //messages... and return all the headers
    
    //
    // From header 
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_FROM_ADDRESS,
                          sizeof(szPropBuffer), &cbPropSize, (PBYTE) szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)DSN_FROM_HEADER_NO_CRLF, 
                                sizeof(DSN_FROM_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //
    // Message ID
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_ID,
                          sizeof(szPropBuffer), &cbPropSize, (PBYTE) szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)MSGID_HEADER_NO_CRLF, 
                                     sizeof(MSGID_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //
    // Subject header
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_SUBJECT,
                        sizeof(szPropBuffer), &cbPropSize, (PBYTE)szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)SUBJECT_HEADER_NO_CRLF, 
                                     sizeof(SUBJECT_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }

    hr = HrWriteMimeClosing(pdsnbuff, szMimeBoundary, cbMimeBoundary, &dwFileSize);
    if (FAILED(hr))
        goto Exit;

    //Set size hint property on DSN for Queue Admin/Message Tracking
    hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSG_SIZE_HINT, dwFileSize);
    if (FAILED(hr))
    {
        //We really don't care too much about a failure with this
        ErrorTrace((LPARAM) this, "Error writing size hint 0x%08X", hr);
        hr = S_OK;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteMimeClosing ]-----------------------------------
//
//
//  Description: 
//      Write the MIME closing of the DSN after the 3rd MIME part.
//  Parameters:
//      pdsnbuff                CDSNBuffer to write content to
//      szReportingMTA          MTA requesting DSN
//      cbReportingMTA          String length of reporting MTA
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//      Failure code from CDSNBuffer on failure
//  History:
//      1/6/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteMimeClosing(
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                OUT DWORD *pcbDSNSize)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteMimeClosing");
    HRESULT hr = S_OK;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //flush buffers
    hr = pdsnbuff->HrFlushBuffer(pcbDSNSize);
    if (FAILED(hr)) 
        goto Exit;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusCode ]---------------------------------------
//
//
//  Description: 
//      Determines the status code (and diagnostic code) for a recipient.  Will
//      check the following (in order) to determine the status code to return:
//          IMMPID_RP_SMTP_STATUS_STRING (per-recipient diagnostic code)
//          Combination of:
//              dwRecipFlags (determine who set the error)
//              IMMPID_RP_ERROR_CODE (per-recipient HRESULT error code)
//              dwDSNAction - kind of DSN being sent
//          Combination of:
//              dwRecipFlags (determine who set the error)
//              dwRFC821Status - per message status code
//              dwDSNAction - kind of DSN being sent
//          Combination of:
//              dwRecipFlags (determine who set the error)
//              hrStatus - per message HRESULT failure    
//              dwDSNAction - kind of DSN being sent
//      Status codes are defined in RFC 1893 as follows:
//          status-code = class "." subject "." detail
//          class = "2"/"4"/"5"
//          subject = 1*3digit
//          detail = 1*3digit
//
//          Additionally, the class of "2", "4", and "5" correspond to success,
//          transient failure, and hard failure respectively
//  Parameters:
//      pIMailMsgRecipients     IMailMsgRecipients of message being DSN'd
//      iRecip                  The index of the recipient we are looking at
//      dwDSNAction             The action code returned by fdwGetDSNAction
//      dwRFC821Status          RFC821 Status code returned by SMTP
//      hrStatus                HRESULT error if SMTP status is unavailable
//      dwRecipFlags            Per-recipient flags for this recipient
//      cbExtendedStatus        Size of buffer for diagnostic code
//      szExtendedStatus        Buffer for diagnostic code
//      szStatus                Buffer for "n.n.n" formatted status code
//  Returns:
//      S_OK    Success - found diagnostic code as well
//      S_FALSE Success - but no diagnostic code
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusCode(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN DWORD iRecip,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status, 
                                IN HRESULT hrStatus,
                                IN DWORD dwRecipFlags,
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetStatusCode");
    HRESULT hr = S_OK;
    HRESULT hrPerRecipStatus = S_OK;
    BOOL fFoundDiagnostic = FALSE;

    //Check for IMMPID_RP_SMTP_STATUS_STRING on recipient and try to get
    //status code from there
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_SMTP_STATUS_STRING, 
        cbExtendedStatus, szExtendedStatus);
    if (SUCCEEDED(hr)) //prop was found
    {
        fFoundDiagnostic = TRUE;

        hr = HrGetStatusFromStatus(cbExtendedStatus, szExtendedStatus, 
                        szStatus);

        if (S_OK == hr)
            goto Exit;
        else if (S_FALSE == hr)
            hr = S_OK; //not really an error... just get code from someplace else
        else
            goto Exit; //other failure

    }
    else if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Not really a hard error
        _ASSERT(!fFoundDiagnostic);
        hr = S_OK;
    }
    else
    {
        goto Exit;
    }

    //Get Per Recipient HRESULT
    DEBUG_DO_IT(hrPerRecipStatus = 0xFFFFFFFF);
    hr = pIMailMsgRecipients->GetDWORD(iRecip, IMMPID_RP_ERROR_CODE, (DWORD *) &hrPerRecipStatus);
    if (SUCCEEDED(hr))
    {
        _ASSERT((0xFFFFFFFF != hrPerRecipStatus) && "Property not returned by MailMsg!!!");

        hr = HrGetStatusFromContext(hrPerRecipStatus, dwRecipFlags, dwDSNAction, szStatus);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //There is no per-recip status
        if (MAILMSG_E_PROPNOTFOUND != hr)
            goto Exit;

        hr = HrGetStatusFromRFC821Status(dwRFC821Status, szStatus);
        if (FAILED(hr))
            goto Exit;

        if (S_OK == hr) //got status code from dwRFC821Status
            goto Exit;

        //If all else fails Get status code using global HRESULT & context
        hr = HrGetStatusFromContext(hrStatus, dwRecipFlags, dwDSNAction, szStatus);
        if (FAILED(hr))
            goto Exit;
    }

    

  Exit:

    if (SUCCEEDED(hr))
    {
        if (fFoundDiagnostic)
            hr = S_OK;
        else 
            hr = S_FALSE;
    }
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusFromStatus ]--------------------------------
//
//
//  Description: 
//      Parse status code from RFC2034 extended status code string
//
//      If string is not a complete RFC2034 extended status string, this 
//      function will attempt to parse the RFC821 SMTP return code and 
//      turn it into an extended status string.
//  Parameters:
//      IN     cbExtendedStatus     Size of extended status buffer
//      IN     szExtendedStatus     Extended status buffer
//      IN OUT szStatus             RFC1893 formatted status code
//  Returns:
//      S_OK on success
//      S_FALSE if could not be parsed
//      FAILED if other error occurs
//  History:
//      7/7/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromStatus(
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetStatusFromStatus");
    HRESULT hr = S_OK;
    DWORD   dwRFC821Status = 0;
    BOOL fFormattedCorrectly = FALSE;
    CHAR *pchStatus = NULL;
    CHAR *pchDiag = NULL; //ptr to status string supplied by SMTP
    DWORD cNumDigits = 0;
    int i = 0;

    //copy status code from diagnostic string in to status code
    pchStatus = szStatus;
    pchDiag = szExtendedStatus;

    //there must be at least 3 characters to attempt parsing
    if (cbExtendedStatus < MIN_CHAR_FOR_VALID_RFC821)
    {
        hr = S_FALSE;
        goto Exit;
    }

    //check RFC822
    if (!((DSN_STATUS_CH_CLASS_SUCCEEDED == *pchDiag) || 
          (DSN_STATUS_CH_CLASS_TRANSIENT == *pchDiag) ||
          (DSN_STATUS_CH_CLASS_FAILED == *pchDiag)))
    {
        //Doesn't start with RFC822... can't be valid
        hr = S_FALSE;
        goto Exit;
    }
     
    //RFC2034 must have at least RFC822 + " " + "x.x.x" = 10 chanracters
    if (cbExtendedStatus >= MIN_CHAR_FOR_VALID_RFC2034)
    {
        pchDiag += MIN_CHAR_FOR_VALID_RFC821; //format is "xxx x.x.x"
        //Find first digit
        while(isspace(*pchDiag) && pchDiag < (szExtendedStatus + cbExtendedStatus))
            pchDiag++;

        if ((DSN_STATUS_CH_CLASS_SUCCEEDED == *pchDiag) || 
            (DSN_STATUS_CH_CLASS_TRANSIENT == *pchDiag) ||
            (DSN_STATUS_CH_CLASS_FAILED == *pchDiag))
        {
            //copy status code class
            *pchStatus = *pchDiag;
            pchStatus++;
            pchDiag++;
            
            //Next character must be a DSN_STATUS_CH_DELIMITER
            if (DSN_STATUS_CH_DELIMITER == *pchDiag)
            {
                *pchStatus = DSN_STATUS_CH_DELIMITER;
                pchStatus++;
                pchDiag++;

                //now parse this 1*3digit "." 1*3digit part
                for (i = 0; i < 3; i++)
                {
                    *pchStatus = *pchDiag;
                    if (!isdigit(*pchDiag))
                    {
                        if (DSN_STATUS_CH_DELIMITER != *pchDiag)
                        {
                            fFormattedCorrectly = FALSE;
                            break;
                        }
                        //copy delimiter
                        *pchStatus = *pchDiag;
                        pchStatus++;
                        pchDiag++;
                        break;
                    }
                    pchStatus++;
                    pchDiag++;
                    fFormattedCorrectly = TRUE; //hace first digit
                }

                if (fFormattedCorrectly) //so far.. so good
                {
                    fFormattedCorrectly = FALSE;
                    for (i = 0; i < 3; i++)
                    {
                        *pchStatus = *pchDiag;
                        if (!isdigit(*pchDiag))
                        {
                            if (!isspace(*pchDiag))
                            {
                                fFormattedCorrectly = FALSE;
                                break;
                            }
                            break;
                        }
                        pchStatus++;
                        pchDiag++;
                        fFormattedCorrectly = TRUE;
                    }

                    //If we have found a good status code... go to exit
                    if (fFormattedCorrectly)
                    {
                        *pchStatus = '\0'; //make sure last CHAR is a NULL
                        goto Exit;
                    }
                }
            }
        }
    }
    
    //We haven't been able to parse the extended status code, but we
    //know we have at least a valid RFC822 response string

    //convert to DWORD
    for (i = 0; i < MIN_CHAR_FOR_VALID_RFC821; i++)
    {
        dwRFC821Status *= 10;
        dwRFC821Status += szExtendedStatus[i] - '0';
    }

    hr = HrGetStatusFromRFC821Status(dwRFC821Status, szStatus);

    _ASSERT(S_OK == hr); //this cannot possibly fail

    //The code *should* be valid at this point
    _ASSERT((DSN_STATUS_CH_CLASS_SUCCEEDED == szStatus[0]) || 
            (DSN_STATUS_CH_CLASS_TRANSIENT == szStatus[0]) ||
            (DSN_STATUS_CH_CLASS_FAILED == szStatus[0]));

    hr = S_OK;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusFromContext ]--------------------------------
//
//
//  Description: 
//      Determine status based on supplied context information 
//  Parameters:
//      hrRecipient     HRESULT for this recipient
//      dwRecipFlags    Flags for this recipient
//      dwDSNAction     DSN Action for this recipient
//      szStatus        Buffer to return status in
//  Returns:
//      S_OK    Was able to get a valid status code
//  History:
//      7/7/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromContext(
                                IN HRESULT hrRecipient,
                                IN DWORD   dwRecipFlags,
                                IN DWORD   dwDSNAction,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    HRESULT hr = S_OK;
    BOOL    fValidHRESULT = FALSE;
    BOOL    fRecipContext = FALSE;
    int     iStatus = 0;
    int     i = 0;
    CHAR    chStatusClass = DSN_STATUS_CH_INVALID;
    CHAR    rgchStatusSubject[3] = {DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID};
    CHAR    rgchStatusDetail[3] = {DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID};

    //check to make sure that HRESULT is set according to the type of DSN happening
    if (dwDSNAction & DSN_ACTION_FAILURE)
    {
        if (FAILED(hrRecipient)) //must be a failure code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
    }
    else if (dwDSNAction & DSN_ACTION_DELAYED)
    {
        if (FAILED(hrRecipient)) //must be a failure code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
    }
    else if ((dwDSNAction & DSN_ACTION_RELAYED) ||
             (dwDSNAction & DSN_ACTION_DELIVERED) ||
             (dwDSNAction & DSN_ACTION_EXPANDED))
    {
        if (SUCCEEDED(hrRecipient)) //must be a success code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_SUCCEEDED;
    }
    else
    {
        _ASSERT(0 && "No DSN Action specified");
    }

    //special case HRESULTS
    if (fValidHRESULT)
    {
        switch (hrRecipient)
        {
            case CAT_E_GENERIC: // 5.1.0 - General Cat failure.
            case CAT_E_BAD_RECIPIENT: //5.1.0 - general bad address error
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '0';
                goto Exit;
            case CAT_E_ILLEGAL_ADDRESS: //5.1.3 - bad address syntax
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case CAT_W_SOME_UNDELIVERABLE_MSGS:  //5.1.1 - recipient could not be resolved
            case (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)):
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case CAT_E_MULTIPLE_MATCHES:  //5.1.4 - amiguous address
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '4';
                goto Exit;
            case AQUEUE_E_MAX_HOP_COUNT_EXCEEDED: //4.4.6
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
            case CAT_E_FORWARD_LOOP: //5.4.6
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '6';
                goto Exit;
            case AQUEUE_E_LOOPBACK_DETECTED: //5.3.5
                //server is configured to loop back on itself
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_SYSTEM;
                rgchStatusDetail[0] = '5';
                goto Exit;
            case AQUEUE_E_MSG_EXPIRED: //4.4.7
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '7';
                goto Exit;
            case AQUEUE_E_HOST_NOT_RESPONDING: //4.4.1
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case AQUEUE_E_CONNECTION_DROPPED: //4.4.2
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '2';
                goto Exit;
            case AQUEUE_E_TOO_MANY_RECIPIENTS: //5.5.3
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_PROTOCOL;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case AQUEUE_E_LOCAL_MAIL_REFUSED: //5.2.1
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case AQUEUE_E_MESSAGE_TOO_LARGE: //5.2.3
            case AQUEUE_E_LOCAL_QUOTA_EXCEEDED: //5.2.3
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case AQUEUE_E_ACCESS_DENIED: //5.7.1
            case AQUEUE_E_SENDER_ACCESS_DENIED: //5.7.1
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_POLICY;
                rgchStatusDetail[0] = '1';
                goto Exit;
        }
    }

    if ((RP_ERROR_CONTEXT_STORE | RP_ERROR_CONTEXT_CAT | RP_ERROR_CONTEXT_MTA) &
         dwRecipFlags)
        fRecipContext = TRUE;

    
    //Now look at the context on recipient flags
    //$$TODO - Use HRESULT's for these case as well
    if ((RP_ERROR_CONTEXT_STORE & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_STORE & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else if ((RP_ERROR_CONTEXT_CAT & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_CAT & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else if ((RP_ERROR_CONTEXT_MTA & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_MTA & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_PROTOCOL;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_GENERAL;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }

  Exit:
    if (SUCCEEDED(hr))
    {
        //compose szStatus
        _ASSERT(DSN_STATUS_CH_INVALID != chStatusClass);
        _ASSERT(DSN_STATUS_CH_INVALID != rgchStatusSubject[0]);
        _ASSERT(DSN_STATUS_CH_INVALID != rgchStatusDetail[0]);

        szStatus[iStatus] = chStatusClass;
        iStatus++;
        szStatus[iStatus] = DSN_STATUS_CH_DELIMITER;
        iStatus++;
        for (i = 0; 
            (i < 3) && (DSN_STATUS_CH_INVALID != rgchStatusSubject[i]); 
            i++)
        {
            szStatus[iStatus] = rgchStatusSubject[i];
            iStatus++;
        }
        szStatus[iStatus] = DSN_STATUS_CH_DELIMITER;
        iStatus++;
        for (i = 0; 
            (i < 3) && (DSN_STATUS_CH_INVALID != rgchStatusDetail[i]); 
             i++)
        {
            szStatus[iStatus] = rgchStatusDetail[i];
            iStatus++;
        }
        szStatus[iStatus] = '\0';
        hr = S_OK;
    }
    return hr;
}


//---[ CDefaultDSNSink::HrGetStatusFromRFC821Status ]--------------------------
//
//
//  Description: 
//      Attempts to generate a DSN status code from a integer version of a 
//      RFC821 response
//  Parameters:
//      IN     dwRFC821Status   Integer version of RFC821Status
//      IN OUT szStatus         Buffer to write status string to
//  Returns:
//      S_OK   if valid status that could be converted to dsn status code
//      S_FALSE if status code cannot be converted
//  History:
//      7/9/98 - MikeSwa Created 
//
//  Note:
//      Eventually, there may be a way to pass extended information in the
//      DWORD to this event.  We *could* also encode RFC1893  (x.xxx.xxx format)
//      in a DWORD (in dwRFC821Status) as follows:
//
//         0xF 0 000 000
//           | | \-/ \-/
//           | |  |   +----- detail portion of status code
//           | |  +--------- subject portion of status code
//           | +------------ class portion of status code
//           +-------------- mask to distinguish from RFC821 status code
//
//      For example "2.1.256" could be encoded as 0xF2001256
//
//      If we do this, we will probably need to expose public functions to 
//      compress/uncompress.
//
//      Yet another possiblity would be to expose an HRESULT facility "RFC1893"
//      Use success, warning, and failed bits to denote the class, and then
//      use the error code space to encode the status codes
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromRFC821Status(
                                IN DWORD    dwRFC821Status,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    HRESULT hr = S_OK;
    //For now, there will be a very simple implementation just converts
    //to 2.0.0, 4.0.0, or 5.0.0, but this function is designed to be 
    //the central place that converts RFC821 status codes to DSN (RFC1893)
    //status codes

    _ASSERT((!dwRFC821Status) || 
            (((200 <= dwRFC821Status) && (299 >= dwRFC821Status)) ||
             ((400 <= dwRFC821Status) && (599 >= dwRFC821Status))) &&
             "Invalid Status Code");

    //For now have simplistic mapping of RFC821 status codes
    if ((200 <= dwRFC821Status) && (299 >= dwRFC821Status)) //200 level error
    {
        strcpy(szStatus, DSN_STATUS_SUCCEEDED);
    }
    else if ((400 <= dwRFC821Status) && (499 >= dwRFC821Status)) //400 level error
    {
        strcpy(szStatus, DSN_STATUS_DELAYED);
    }
    else if ((500 <= dwRFC821Status) && (599 >= dwRFC821Status)) //500 level error
    {
        strcpy(szStatus, DSN_STATUS_FAILED);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

//---[ FileTimeToLocalRFC822Date ]---------------------------------------------
//
//
//  Description: 
//      Converts filetime to RFC822 compliant date
//  Parameters:
//      ft          Filetime to generate date for
//      achReturn   Buffer for filetime
//  Returns:
//      -   
//  History:
//      8/19/98 - MikeSwa Modified from various timeconv.cxx functions written 
//                  by      Lindsay Harris  - lindasyh
//                          Carl Kadie [carlk]
//
//-----------------------------------------------------------------------------
void FileTimeToLocalRFC822Date(const FILETIME & ft, char achReturn[MAX_RFC822_DATE_SIZE])
{
    FILETIME ftLocal;
    SYSTEMTIME  st;
    char    chSign;                         // Sign to print.
    DWORD   dwResult;
    int     iBias;                          // Offset relative to GMT.
    TIME_ZONE_INFORMATION   tzi;            // Local time zone data.

    dwResult = GetTimeZoneInformation( &tzi );

    _ASSERT(achReturn); //real assert

    FileTimeToLocalFileTime(&ft, &ftLocal);

    FileTimeToSystemTime(&ftLocal, &st);

    //  Calculate the time zone offset.
    iBias = tzi.Bias;
    if( dwResult == TIME_ZONE_ID_DAYLIGHT )
        iBias += tzi.DaylightBias;
    
    /*
     *   We always want to print the sign for the time zone offset, so
     *  we decide what it is now and remember that when converting.
     *  The convention is that west of the 0 degree meridian has a
     *  negative offset - i.e. add the offset to GMT to get local time.
     */

    if( iBias > 0 )
    {
        chSign = '-';       // Yes, I do mean negative.
    }
    else
    {
        iBias = -iBias;
        chSign = '+';
    }

    /*
     *    No major trickery here.  We have all the data, so simply
     *  format it according to the rules on how to do this.
     */

    wsprintf( achReturn, "%s, %d %s %04d %02d:%02d:%02d %c%02d%02d",
            s_rgszWeekDays[st.wDayOfWeek],
            st.wDay, s_rgszMonth[ st.wMonth - 1 ],
            st.wYear,
            st.wHour, st.wMinute, st.wSecond, chSign,
            (iBias / 60) % 100, iBias % 60 );

    _ASSERT(lstrlen(achReturn) < MAX_RFC822_DATE_SIZE);

}

//---[ CDefaultDSNSink::GetCurrentIterationsDSNAction ]------------------------
//
//
//  Description: 
//      This function will select one of the pdwActualDSNAction to generate
//      DSNs on during this call to the DSN generation sink.
//  Parameters:
//      IN OUT  pdwActionDSNAction      DSN Actions that can/will be used.
//      IN OUT  pcIterationsLeft        Approximate # of times needed to call 
//                                      DSN generation
//  Returns:
//      -
//  History:
//      12/14/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDefaultDSNSink::GetCurrentIterationsDSNAction(
                                IN OUT DWORD   *pdwActualDSNAction,
                                IN OUT DWORD   *pcIterationsLeft)
{
    _ASSERT(pdwActualDSNAction);
    _ASSERT(pcIterationsLeft);
    const DWORD MAX_DSN_ACTIONS = 6;

    //In the following array FAILURE_ALL must come first or else we will
    //generate separate failure DSNs for hard failures and undelivereds.
    DWORD rgPossibleDSNActions[MAX_DSN_ACTIONS] = {DSN_ACTION_FAILURE_ALL,
                                                   DSN_ACTION_FAILURE, 
                                                   DSN_ACTION_DELAYED, 
                                                   DSN_ACTION_RELAYED, 
                                                   DSN_ACTION_DELIVERED,
                                                   DSN_ACTION_EXPANDED};
    DWORD i = 0;
    DWORD iLastMatch = MAX_DSN_ACTIONS;
    DWORD iFirstMatch = MAX_DSN_ACTIONS;
    DWORD iStartIndex = 0;

    //Since the possible DSNs to generate may change from call to call (because
    //we are updating the pre-recipient flags), we need to generate and maintain
    //pcIterationsLeft based on the possible Actions (which will not be changing
    //from call to call).

    _ASSERT(*pcIterationsLeft < MAX_DSN_ACTIONS);

    //Figure out where we should start if this is not the 
    if (*pcIterationsLeft)
        iStartIndex = MAX_DSN_ACTIONS-*pcIterationsLeft;

    //Loop through possible DSN actions (that we haven't seen) and determine
    //the first and last
    for (i = iStartIndex; i < MAX_DSN_ACTIONS; i++)
    {
        if (rgPossibleDSNActions[i] & *pdwActualDSNAction)
        {
            iLastMatch = i;
            if (MAX_DSN_ACTIONS == iFirstMatch)
                iFirstMatch = i;
        }
    }

    if (MAX_DSN_ACTIONS == iLastMatch)
    {
        //No matches... we are done
        *pdwActualDSNAction = 0;
        *pcIterationsLeft = 0;
        return;
    }

    //If this is possible after the above check... then I've screwed up
    _ASSERT(MAX_DSN_ACTIONS != iFirstMatch);

    *pdwActualDSNAction = rgPossibleDSNActions[iFirstMatch];
    if ((iLastMatch == iFirstMatch) || 
       ((rgPossibleDSNActions[iFirstMatch] == DSN_ACTION_FAILURE_ALL) && 
        (rgPossibleDSNActions[iLastMatch] == DSN_ACTION_FAILURE)))
    {
        //This is our last time through
        *pcIterationsLeft = 0;
    }
    else
    {
        *pcIterationsLeft = MAX_DSN_ACTIONS-1-iFirstMatch;
    }
}


//---[ CDefaultDSNSink::HrWriteHumanReadableListOfRecips ]---------------------
//
//
//  Description: 
//      Writes a list of recipients to the human readable portion
//  Parameters:
//      IN  pIMailMsgRecipients     Recipients interface
//      IN  prpfctxt                Recipient filter context for this DSN
//      IN  dwDSNActionsNeeded      Type of DSN that we are generating
//      IN  pdsnbuff                DSN buffer to write DSN to
//  Returns:
//      S_OK on success
//  History:
//      12/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteHumanReadableListOfRecips(
                            IN IMailMsgRecipients *pIMailMsgRecipients,
                            IN RECIPIENT_FILTER_CONTEXT *prpfctxt,
                            IN DWORD dwDSNActionsNeeded,
                            IN CDSNBuffer *pdsnbuff)
{
    HRESULT  hr = S_OK;
    DWORD   iCurrentRecip = 0;
    DWORD   dwCurrentRecipFlags = 0;
    DWORD   dwCurrentDSNAction = 0;
    CHAR    szBuffer[PROP_BUFFER_SIZE];
    CHAR    szAddressType[PROP_BUFFER_SIZE];

    hr = pIMailMsgRecipients->GetNextRecipient(prpfctxt, &iCurrentRecip);
    while (SUCCEEDED(hr))
    {
        hr = pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_RECIPIENT_FLAGS, &dwCurrentRecipFlags);
        if (FAILED(hr))
            goto Exit;

        //If the recipient matches our actions... print it
        if (fdwGetDSNAction(dwDSNActionsNeeded, &dwCurrentRecipFlags, &dwCurrentDSNAction))
        {
            hr = HrGetRecipAddressAndType(pIMailMsgRecipients, iCurrentRecip, 
                                          PROP_BUFFER_SIZE, szBuffer, 
                                          sizeof(szAddressType), szAddressType);

            if (SUCCEEDED(hr))
            {
                //write address value
                hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_INDENT, sizeof(DSN_INDENT)-sizeof(CHAR));
                if (FAILED(hr))
                    goto Exit;

                hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
                if (FAILED(hr))
                    goto Exit;

                
#ifdef NEVER
                //Print the recipient flags as well
                wsprintf(szBuffer, " (0x%08X)", dwCurrentRecipFlags);
                pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
#endif //NEVER

                hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-sizeof(CHAR));
                if (FAILED(hr))
                    goto Exit;
            }
            else
            {
                //move along... these are not the error results you are interested in.
                hr = S_OK;
            }

        }

        hr = pIMailMsgRecipients->GetNextRecipient(prpfctxt, &iCurrentRecip);
            
    }

  Exit:
    return hr;
}


//---[ CDefaultDSNSink::HrGetRecipAddressAndType ]-----------------------------
//
//
//  Description: 
//      Gets the recipient address and returns a pointer to the appropriate 
//      string constant for the address type.
//  Parameters:
//      IN     pIMailMsgRecipients      Ptr To recipients interface
//      IN     iRecip                   Index of the recipient of interest
//      IN     cbAddressBuffer          Size of buffer for address
//      IN OUT pbAddressBuffer          Address buffer to dump address in
//      IN     cbAddressType            Size of buffer for address type
//      IN OUT pszAddressType           Buffer for address type.
//  Returns:
//      S_OK on success
//      MAILMSG_E_PROPNOTFOUND if no address properties could be found
//  History:
//      12/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetRecipAddressAndType(
                                IN     IMailMsgRecipients *pIMailMsgRecipients,
                                IN     DWORD iRecip,
                                IN     DWORD cbAddressBuffer,
                                IN OUT LPSTR szAddressBuffer,
                                IN     DWORD cbAddressType,
                                IN OUT LPSTR szAddressType)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetRecipAddressAndType");
    HRESULT hr = S_OK;
    BOOL    fFoundAddress = FALSE;
    DWORD   i = 0;
    LPSTR   szDelimiterLocation = NULL;
    CHAR    szXDash[] = "x-";
    CHAR    chSave = '\0';

    _ASSERT(szAddressType);
    _ASSERT(cbAddressType);
    _ASSERT(cbAddressBuffer);
    _ASSERT(szAddressBuffer);
    _ASSERT(pIMailMsgRecipients);

    szAddressType[0] = '\0';
    szAddressBuffer[0] = '\0';
    for (i = 0; i < NUM_DSN_ADDRESS_PROPERTIES; i ++)
    {
        hr = pIMailMsgRecipients->GetStringA(iRecip, g_rgdwRecipPropIDs[i], 
                                                cbAddressBuffer, szAddressBuffer);

        if (SUCCEEDED(hr))
        {
            fFoundAddress = TRUE;
            strncpy(szAddressType, g_rgszAddressTypes[i], cbAddressType);
            break;
        }
    }

    if (!fFoundAddress)
    {
        hr = MAILMSG_E_PROPNOTFOUND;
        ErrorTrace((LPARAM) this, 
            "Unable to find recip %d address for message", iRecip);
    }
    else if (IMMPID_RP_ADDRESS_OTHER == g_rgdwRecipPropIDs[i])
    {
        //Handle special case of IMMPID_RP_ADDRESS_OTHER... we should attempt to 
        //parse out address from "type:address" format of IMMPID_RP_ADDRESS_OTHER
        //property
        szDelimiterLocation = strchr(szAddressBuffer, ':');
        if (szDelimiterLocation && cbAddressType > sizeof(szXDash))
        {
            chSave = *szDelimiterLocation;
            *szDelimiterLocation = '\0';
            DebugTrace((LPARAM) this, 
                "Found Address type of %s", szAddressBuffer);
            strncpy(szAddressType, szXDash, cbAddressType);
            strncat(szAddressType, szAddressBuffer, 
                cbAddressType - (sizeof(szXDash)-sizeof(CHAR)));
            *szDelimiterLocation = chSave;
        }
        else
        {
            ErrorTrace((LPARAM) this, 
                "Unable to find address type for address %s", szAddressBuffer);
        }
    }

    DebugTrace((LPARAM) this, 
        "Found recipient address %s:%s for recip %d (propery %i:%x)",
            szAddressType, szAddressBuffer, iRecip, i, g_rgdwRecipPropIDs[i]);
    TraceFunctLeave();
    return hr;

}


//---[ CDefaultDSNSink::HrMarkAllRecipFlags ]----------------------------------
//
//
//  Description: 
//      Marks all recipient according to the DSN action.  Used when an NDR of
//      an NDR is found and we will not be generating a DSN, but need to mark 
//      the recips so we can not generate 2 badmail events.
//  Parameters:
//      IN dwDSNAction          The current DSN action
//      IN pIMailMsgProperties  The mailmsg
//      IN prpfctxt             Recipient filter context
//  Returns:
//      S_OK on success
//  History:
//      1/11/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT  CDefaultDSNSink::HrMarkAllRecipFlags(
                                IN DWORD dwDSNAction,
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN RECIPIENT_FILTER_CONTEXT *prpfctxt)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrMarkAllRecipFlags");
    HRESULT hr = S_OK;
    DWORD   iCurrentRecip = 0;
    DWORD   dwCurrentRecipFlags = 0;
    DWORD   dwCurrentDSNAction = 0;

    _ASSERT(pIMailMsgRecipients);

    hr = pIMailMsgRecipients->GetNextRecipient(prpfctxt, &iCurrentRecip);
    while (SUCCEEDED(hr))
    {
        hr = pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_RECIPIENT_FLAGS, &dwCurrentRecipFlags);
        if (FAILED(hr))
            goto Exit;

        if (fdwGetDSNAction(dwDSNAction, &dwCurrentRecipFlags, &dwCurrentDSNAction))
        {
            hr = pIMailMsgRecipients->PutDWORD(iCurrentRecip,
                    IMMPID_RP_RECIPIENT_FLAGS, dwCurrentRecipFlags);
        }

        hr = pIMailMsgRecipients->GetNextRecipient(prpfctxt, &iCurrentRecip);

    }

  Exit:
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\imsgerr.h $(O)\imsgerr.rc $(O)\msg00001.bin: $(STAXINC)\export\imsgerr.mc
    copy /a $(STAXINC)\export\imsgerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\imsgerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\imsgerr.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsn_utf7.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsn_utf7
//
//  Description:  Implementations of UTF-7 based unicode character encoding
//      methods for DSN generation.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/20/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSN_UTF7_H__
#define __DSN_UTF7_H__

#include <windows.h>
#include <dbgtrace.h>
#include "b64octet.h"
#include "dsnconv.h"

#define UTF7_CHARSET "unicode-1-1-utf-7"

#define UTF7_CONTEXT_SIG '7FTU'

#define UTF7_START_STREAM_CHAR  '+'
#define UTF7_STOP_STREAM_CHAR   '-'
#define UTF7_RFC1522_ENCODE_START "=?" UTF7_CHARSET "?Q?+"
#define UTF7_RFC1522_ENCODE_STOP  "?="
#define UTF7_RFC1522_PHRASE_SEPARATOR  " \r\n\t"
#define UTF7_RFC1522_MAX_LENGTH 76


class CUTF7ConversionContext : public CDefaultResourceConversionContext
{
  protected:
    DWORD   m_dwSignature;
    DWORD   m_cBytesSinceCRLF;
    DWORD   m_dwCurrentState;
    CHAR    chNeedsEncoding(WCHAR wch);
    CBase64OctetStream m_Base64Stream;

    //State Description enum flags
    enum
    {
        UTF7_INITIAL_STATE              = 0x00000000, //Initial state
        UTF7_ENCODING_RFC1522_SUBJECT   = 0x80000000, //encoding RFC1522 subject
        UTF7_ENCODING_WORD              = 0x00000001, //In process of encoding a word
        UTF7_WORD_CLOSING_PENDING       = 0x00000002, //Needs a '-'
        UTF7_RFC1522_CHARSET_PENDING    = 0x00000004, //=?charset?Q?+ pending
        UTF7_RFC1522_CLOSING_PENDING    = 0x00000008, //needs '=?'
        UTF7_RFC1522_CURRENTLY_ENCODING = 0x00000010, //Currently encoding RFC1522 phrase
        UTF7_FOLD_HEADER_PENDING        = 0x00000020, //Need to fold head before encoding
                                                      //more
        UTF7_FLUSH_BUFFERS              = 0x00000040, //Need to flush conversion buffers

        //Used to determine if subject needs to be encoded
        UTF7_SOME_INVALID_RFC822_CHARS  = 0x40000000, //Contains some invalid RFC822 chars
        UFT7_ALL_VALID_RFC822_CHARS     = 0x20000000, //All characters are valid RFC822 chars
    };

    void WriteChar(IN CHAR ch, IN OUT BYTE ** ppbBuffer, IN OUT DWORD *pcbWritten);
    BOOL fWriteString(IN LPSTR szString, IN DWORD cbString, IN DWORD cbBuffer,
                      IN OUT BYTE ** ppbBuffer, IN OUT DWORD *pcbWritten);
    BOOL fSubjectNeedsEncoding(IN BYTE *pbBuffer, IN DWORD cbBuffer);

    BOOL fUTF7EncodeBuffer(
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);

    BOOL fConvertBufferTo7BitASCII(
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);

  public:
    CUTF7ConversionContext(BOOL fIsRFC1522Subject = FALSE);
    BOOL fConvertBuffer(
          IN BOOL   fASCII,
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);
};

#endif //__DSN_UTF7_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/15/99 - MikeSwa Created 
//      7/15/99 - MikeSwa Moved to transmt 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Includes from external directories
#include "dsnsink.h"
#include <transmem.h>
#include <dbgtrace.h>
#include <mailmsgprops.h>
#include <aqerr.h>
#include <caterr.h>
#include <time.h>
#include <stdio.h>
#include "dsnbuff.h"
#include "dsntext.h"
#include "dsnlang.h"
#include "dsn_utf7.h"

//Wrappers for transmem macros
#include <aqmem.h>

#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqmem.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmem.h
//
//  Description:  Header file with memory macros required to build AQUEUE
//      in the platinum build environment.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQMEM_H__
#define __AQMEM_H__

//Wrappers for transmem macros
#ifndef PvMalloc
#define PvMalloc(x) TrMalloc(x)
#endif  //PvMalloc

#ifndef PvRealloc
#define PvRealloc(x) TrRealloc(x)
#endif  //PvRealloc

#ifndef FreePv
#define FreePv(x) TrFree(x)
#endif  //FreePv

#endif //__AQMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqincs.h ===
//-----------------------------------------------------------------------------
//
//
//    File: aqincs.h
//
//    Description:  The base header file for transport advanced queueing.
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _AQINCS_H_
#define _AQINCS_H_

//General and windows headers

//Define WINSOCKAPI, so atq,h will compile
#define _WINSOCKAPI_

#include <atq.h>
#include <ole2.h>
#include <mapicode.h>
#include <stdio.h>
#include <string.h>

// Transport specific headers - every component should use these
#include "transmem.h"
#include "baseobj.h"
#include <dbgtrace.h>
#include <rwnew.h>
#include <mailmsg.h>

//can be used to mark signatures as deleted
//will shift the signature over 1 character and prepend a '!'
#define MARK_SIG_AS_DELETED(x) {x <<= 8; x |= 0x00000021;}

#ifndef MAXDWORD
#define MAXDWORD    0xffffffff
#endif //MAXDWORD

//my own special Assert
//place holder for MCIS _ASSERT, until I bring code over
#ifdef DEBUG
#undef  Assert
#define Assert(x)   _ASSERT(x)
#else 
#undef Assert
#define Assert(x)
#endif //DEBUG

#ifdef DEBUG
#define DEBUG_DO_IT(x) x
#else
#define DEBUG_DO_IT(x) 
#endif  //DEBUG

_declspec(selectany) HINSTANCE g_hAQInstance = NULL;

#endif //_AQINCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsn_utf7.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsn_utf7.cpp
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/20/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//---[ CUTF7ConversionContext::chNeedsEncoding ]--------------------------------
//
//
//  Description: 
//      Determines if a character needs to be encoded... returns it's ASCII 
//      equivalent if not.
//  Parameters:
//      wch     Wide character to check
//  Returns:
//      0, if the character needs encoding
//      The ASCII equivalent if not.
//  History:
//      10/23/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CHAR CUTF7ConversionContext::chNeedsEncoding(WCHAR wch)
{
    CHAR    ch = 0;
    //First look for characters that are a straight ASCII conversion for all 
    //cases.  This is Set D and Set O in the RFC1642
    if (((L'a' <= wch) && (L'z' >= wch)) ||
        ((L'A' <= wch) && (L'Z' >= wch)) ||
        ((L'0' <= wch) && (L'9' >= wch)) ||
        ((L'!'<= wch) && (L'*' >= wch)) ||
        ((L',' <= wch) && (L'/' >= wch)) ||
        ((L';' <= wch) && (L'@' >= wch)) ||
        ((L']' <= wch) && (L'`' >= wch)) ||
        ((L'{' <= wch) && (L'}' >= wch)) ||
        (L' ' == wch) || (L'\t' == wch) ||
        (L'[' == wch))
    {
        ch = (CHAR) wch & 0x00FF;
    }
    //Check things are not converted for content, but are for headers
    else if (!(UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState))
    {
        //Handle whitespace
        if ((L'\r' == wch) || (L'\n' == wch))
            ch = (CHAR) wch & 0x00FF;
    }

    //NOTE - We not not want to handle UNICODE <LINE SEPARATOR> (0x2028)
    //and <PARAGRAPH SEPARATOR> (0x2029)... which should ideally be 
    //converted to CRLF. We will consider this a mal-formed resource.  ASSERT
    //in Debug and encode as UNICODE on retail.
    _ASSERT((0x2028 != wch) && "Malformed Resource String");
    _ASSERT((0x2029 != wch) && "Malformed Resource String");


    return ch;
}


//---[ UTF7ConversionContext::CUTF7ConversionContext ]-------------------------
//
//
//  Description: 
//      Constuctor for UTF7ConversionContext object
//  Parameters:
//      IN  fIsRFC1522Subject   TRUE if we need to worry about converting
//                              to an RFC1522 Subject (defaults to FALSE)
//  Returns:
//      -
//  History:
//      10/20/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CUTF7ConversionContext::CUTF7ConversionContext(BOOL fIsRFC1522Subject)
{
    m_dwSignature = UTF7_CONTEXT_SIG;
    m_dwCurrentState = UTF7_INITIAL_STATE;
    if (fIsRFC1522Subject)
        m_dwCurrentState |= UTF7_ENCODING_RFC1522_SUBJECT;

    m_cBytesSinceCRLF = 0;
}

//---[ <function> ]------------------------------------------------------------
//
//
//  Description: 
//      Writes a single character to the output buffer... used by 
//      fConvertBuffer.  Also updates relevant member vars/
//  Parameters:
//      IN      ch          Character to write
//      IN OUT  ppbBuffer   Buffer to write it to
//      IN OUT  pcbWritten  Running total of bytes written
//  Returns:
//      -
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline void CUTF7ConversionContext::WriteChar(IN CHAR ch, 
                                              IN OUT BYTE ** ppbBuffer, 
                                              IN OUT DWORD *pcbWritten)
{
    _ASSERT(ppbBuffer);
    _ASSERT(*ppbBuffer);
    _ASSERT(pcbWritten);

    **ppbBuffer = (BYTE) ch;
    (*ppbBuffer)++;
    (*pcbWritten)++;
    m_cBytesSinceCRLF++;

    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
        _ASSERT(UTF7_RFC1522_MAX_LENGTH >= m_cBytesSinceCRLF);

}

//---[ CUTF7ConversionContext::fWriteString ]----------------------------------
//
//
//  Description: 
//      Used by fConvertBuffer to write a string to the outputt buffer.  
//      Updates m_cBytesSinceCRLF in the process.
//  Parameters:
//      IN      szString    String to write
//      IN      cbString    Size of string
//      IN      cbBuffer    Total size of output buffer
//      IN OUT  ppbBuffer   Buffer to write it to
//      IN OUT  pcbWritten  Running total of bytes written
//  Returns:    
//      
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline BOOL CUTF7ConversionContext::fWriteString(IN LPSTR szString, IN DWORD cbString,
                                          IN DWORD cbBuffer, 
                                          IN OUT BYTE ** ppbBuffer, 
                                          IN OUT DWORD *pcbWritten)
{
    _ASSERT(szString);
    _ASSERT(ppbBuffer);
    _ASSERT(*ppbBuffer);
    _ASSERT(pcbWritten);

    if (cbString > (cbBuffer - *pcbWritten))
        return FALSE;  //There is not enough room to write our buffer

    memcpy(*ppbBuffer, szString, cbString);
    (*ppbBuffer) += cbString;
    (*pcbWritten) += cbString;
    m_cBytesSinceCRLF += cbString;

    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
        _ASSERT(UTF7_RFC1522_MAX_LENGTH >= m_cBytesSinceCRLF);

    return TRUE;
}

//---[ CUTF7ConversionContext::fSubjectNeedsEncodin ]--------------------------
//
//
//  Description: 
//      Determines if a subject needs to be UTF7 encoded... or can be 
//      transmitted as is.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//  Returns:
//      TRUE if we need to encode the buffer
//      FALSE if we do not
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fSubjectNeedsEncoding(IN BYTE *pbBuffer, 
                                                   IN DWORD cbBuffer)
{
    LPWSTR wszBuffer = (LPWSTR) pbBuffer;
    LPWSTR wszBufferEnd = (LPWSTR) (pbBuffer + cbBuffer);
    WCHAR  wch = L'\0';

    while (wszBuffer < wszBufferEnd)
    {
        wch = *wszBuffer;
        if ((127 < wch) || (L'\r' == wch) || (L'\n' == wch))
        {
            //Encountered a non-valid char... must encode
            return TRUE;
        }
        wszBuffer++;
    }
    return FALSE;
}

//---[ UTF7ConversionContext::fConvertBufferTo7BitASCII ]----------------------
//
//
//  Description: 
//      Converts a buffer that is UNICODE contianing only 7bit ASCII characters
//      to an ASCII buffer.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fConvertBufferTo7BitASCII(          
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    LPWSTR wszBuffer = (LPWSTR) pbInputBuffer;
    LPWSTR wszBufferEnd = (LPWSTR) (pbInputBuffer + cbInputBuffer);
    WCHAR  wch = L'\0';
    BYTE  *pbCurrentOut = pbOutputBuffer;

    _ASSERT(pbCurrentOut);
    while ((*pcbWritten < cbOutputBuffer) && (wszBuffer < wszBufferEnd))
    {
        _ASSERT(!(0xFF80 & *wszBuffer)); //must be only 7-bit
        WriteChar((CHAR) *wszBuffer, &pbCurrentOut, pcbWritten);
        wszBuffer++;
        *pcbRead += sizeof(WCHAR);
    }

    return (wszBuffer == wszBufferEnd);
}

//---[ CUTF7ConversionContext::fUTF7EncodeBuffer ]------------------------------
//
//
//  Description: 
//      Converts buffer to UTF7 Encoding
//
//      This function implements the main state machine for UTF7 encoding.  It 
//      handles encoding of both RFC1522 subject encoding as well as regular
//      UTF7 content-encoding.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fUTF7EncodeBuffer(          
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    LPWSTR wszBuffer = (LPWSTR) pbInputBuffer;
    WCHAR  wch = L'\0';
    CHAR   ch = '\0';
    BYTE  *pbCurrentOut = pbOutputBuffer;
    BOOL   fDone = FALSE;

    //Use loop to make sure we never exceed our buffers
    while (*pcbWritten < cbOutputBuffer)
    {
        //See if we need to handle any state that does not require reading
        //from the input buffer.
        if (UTF7_FLUSH_BUFFERS & m_dwCurrentState)
        {
            //We have converted characters buffered up... we need to write them
            //to the output buffer
            if (!m_Base64Stream.fNextValidChar(&ch))
            {
                //Nothing left to write
                m_dwCurrentState ^= UTF7_FLUSH_BUFFERS;
                continue;
            }
            WriteChar(ch, &pbCurrentOut, pcbWritten);
        }
        else if (UTF7_RFC1522_CHARSET_PENDING & m_dwCurrentState)
        {
            //We need to start with the =?charset?Q?+ stuff
            if (!fWriteString(UTF7_RFC1522_ENCODE_START, 
                              sizeof(UTF7_RFC1522_ENCODE_START)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
                    
            m_dwCurrentState ^= UTF7_RFC1522_CHARSET_PENDING;
            m_dwCurrentState |= (UTF7_ENCODING_WORD | UTF7_RFC1522_CURRENTLY_ENCODING);
        }
        else if (UTF7_WORD_CLOSING_PENDING & m_dwCurrentState)
        {
            //Need to write closing '-'
            m_dwCurrentState ^= UTF7_WORD_CLOSING_PENDING;
            WriteChar(UTF7_STOP_STREAM_CHAR, &pbCurrentOut, pcbWritten);
        }
        else if (UTF7_RFC1522_CLOSING_PENDING & m_dwCurrentState)
        {
            if (!fWriteString(UTF7_RFC1522_ENCODE_STOP, 
                              sizeof(UTF7_RFC1522_ENCODE_STOP)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
            m_dwCurrentState ^= (UTF7_RFC1522_CLOSING_PENDING | UTF7_FOLD_HEADER_PENDING);
        }
        else if (UTF7_FOLD_HEADER_PENDING & m_dwCurrentState)
        {
            if (*pcbRead >= cbInputBuffer) //there is no more text to read.. we don't need to wrap
            {
                fDone = TRUE;
                m_dwCurrentState ^= UTF7_FOLD_HEADER_PENDING;
                break;
            }
            m_cBytesSinceCRLF = 0;  //We're writing a CRLF now
            if (!fWriteString(UTF7_RFC1522_PHRASE_SEPARATOR, 
                              sizeof(UTF7_RFC1522_PHRASE_SEPARATOR)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
            
            m_cBytesSinceCRLF = sizeof(CHAR);//set count to leading tab
            m_dwCurrentState ^= UTF7_FOLD_HEADER_PENDING;
        }
        else if (*pcbRead >= cbInputBuffer)
        {
            //We have read our entire input buffer... now we need to handle 
            //any sort of cleanup.
            if (m_Base64Stream.fTerminateStream(TRUE))
            {
                _ASSERT(UTF7_ENCODING_WORD & m_dwCurrentState);
                m_dwCurrentState |= UTF7_FLUSH_BUFFERS;
            }
            else if (UTF7_ENCODING_WORD & m_dwCurrentState)
            {
                //We have already written everything to output.. but we 
                //still need to write the close of the stream
                _ASSERT(!(UTF7_WORD_CLOSING_PENDING & m_dwCurrentState));
                m_dwCurrentState ^= (UTF7_ENCODING_WORD | UTF7_WORD_CLOSING_PENDING);
            }
            else if (UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState)
            {
                //Need to write closing ?=
                m_dwCurrentState |= UTF7_RFC1522_CLOSING_PENDING;
            }
            else
            {
                fDone = TRUE;
                break; //We're done
            }
        }
        else //need to process more of the input buffer
        {
            wch = *wszBuffer;
            ch = chNeedsEncoding(wch);
            //Are we at the end of a RFC1522 phrase? (ch will be 0)
            if ((UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState) &&
                !ch && iswspace(wch))
            {
                //reset state 
                if (UTF7_ENCODING_WORD & m_dwCurrentState)
                    m_dwCurrentState |= UTF7_WORD_CLOSING_PENDING;  //need to write -

                m_dwCurrentState |= UTF7_RFC1522_CLOSING_PENDING;
                m_dwCurrentState &= ~(UTF7_ENCODING_WORD |
                                      UTF7_RFC1522_CURRENTLY_ENCODING);
                
                //eat up any extra whitespace
                do
                {
                     wszBuffer++;
                     *pcbRead += sizeof(WCHAR);
                     if (*pcbRead >= cbInputBuffer)
                        break;
                    wch = *wszBuffer;
                } while (iswspace(wch));
            }
            else if (UTF7_ENCODING_WORD & m_dwCurrentState)
            {
                if (ch) //we need to stop encoding
                {
                    m_Base64Stream.fTerminateStream(TRUE);
                   _ASSERT(!(UTF7_WORD_CLOSING_PENDING & m_dwCurrentState));
                    m_dwCurrentState ^= (UTF7_ENCODING_WORD | UTF7_WORD_CLOSING_PENDING | UTF7_FLUSH_BUFFERS);
                }
                else if (!m_Base64Stream.fProcessWideChar(wch))
                {
                    //flush our buffers and then continue on as we were
                    m_dwCurrentState |= UTF7_FLUSH_BUFFERS;
                }
                else
                {
                    //The write worked... 
                    wszBuffer++;
                    *pcbRead += sizeof(WCHAR);
                }
            }
            else if (!ch)
            {
                //we need to start encoding
                if ((UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState) &&
                    !(UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState))
                {
                    //We need to start with the =?charset?Q?+ stuff
                    m_dwCurrentState |= UTF7_RFC1522_CHARSET_PENDING;
                }
                else
                {
                    //We are either not encoding RFC1522... or are already
                    //in the middle of a RFC1522 encoded phrase.. in this case
                    //we only need to write the '+'
                    WriteChar(UTF7_START_STREAM_CHAR, &pbCurrentOut, pcbWritten);
                    m_dwCurrentState |= UTF7_ENCODING_WORD;
                }
            }
            else
            {
                //we are not encoding... and character can be written normally
                WriteChar(ch, &pbCurrentOut, pcbWritten);
                wszBuffer++;
                *pcbRead += sizeof(WCHAR);

                //if it was a space... and we are doing headers... lets fold
                //the header
                if ((UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
                    && isspace(ch))
                {
                    //eat up any extra whitespace
                    while (iswspace(*wszBuffer))
                    {
                         wszBuffer++;
                         *pcbRead += sizeof(WCHAR);
                         if (*pcbRead >= cbInputBuffer)
                            break;
                    }
                    m_dwCurrentState |= UTF7_FOLD_HEADER_PENDING;
                }
            }
        }
    }

    return fDone;
}

//---[ CUTF7ConversionContext::fConvertBuffer ]--------------------------------
//
//
//  Description: 
//      Converts UNICODE string to UTF7
//  Parameters:
//      IN  fASCII              TRUE if buffer is ASCII
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fConvertBuffer(
          IN BOOL   fASCII,
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    _ASSERT(pcbWritten);
    _ASSERT(pcbRead);
    _ASSERT(pbInputBuffer);
    _ASSERT(pbOutputBuffer);
    
    //Let the default implementation handle straight ASCII
    if (fASCII)
    {
        return CDefaultResourceConversionContext::fConvertBuffer(fASCII,
                pbInputBuffer, cbInputBuffer, pbOutputBuffer, cbOutputBuffer,
                pcbWritten, pcbRead);
    }

    //Now we know it is UNICODE... cbInputBuffer should be a multiple of sizeof(WCHAR)
    _ASSERT(0 == (cbInputBuffer % sizeof(WCHAR)));

    //If we are encoding the subject, and we haven't classified it yet,
    //we need to check to see if it needs encoding
    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState &&
        !((UTF7_SOME_INVALID_RFC822_CHARS | UFT7_ALL_VALID_RFC822_CHARS) &
          m_dwCurrentState))
    {
        if (fSubjectNeedsEncoding(pbInputBuffer, cbInputBuffer))
            m_dwCurrentState |= UTF7_SOME_INVALID_RFC822_CHARS;
        else
            m_dwCurrentState |= UFT7_ALL_VALID_RFC822_CHARS;
    }

    *pcbWritten = 0;
    *pcbRead = 0;

    if (UFT7_ALL_VALID_RFC822_CHARS & m_dwCurrentState)
    {
        return fConvertBufferTo7BitASCII(pbInputBuffer, cbInputBuffer, pbOutputBuffer,
                                        cbOutputBuffer, pcbWritten, pcbRead);
    }
    else //we must convert
    {
        return fUTF7EncodeBuffer(pbInputBuffer, cbInputBuffer, pbOutputBuffer,
                                        cbOutputBuffer, pcbWritten, pcbRead);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqinit.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: aqinit.h
//
// Contents: Declarations of functions shared between aqueue and cat
//           to initialize/deinitialize
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/12/16 17:29:49: Created.
//
//-------------------------------------------------------------

//
// Refcounted initialize of exchmem and tracing
//
HRESULT HrDllInitialize();
//
// Refcounted deinitialize of exchmem and tracing
//
VOID DllDeinitialize();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\dsnlang.h ===
//----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:      dsnlang.h
//
//  Contents:  Resource IDs for localizable DSN strings
//
//  Owner:   mikeswa
//
//-----------------------------------------------------------------------------

#ifndef __DSNLANG_H__
#define __DSNLANG_H__


//various subjects
#define FAILURE_SUBJECT         1
#define FALURE_RELAY_SUBJECT    2
#define FAILURE_RELAY_SUBJECT   3
#define DELAY_SUBJECT           4
#define GENERAL_SUBJECT         5
#define RELAY_SUBJECT           6
#define DELIVERED_SUBJECT       7
#define EXPANDED_SUBJECT        8
//Next group of ID's reserved for future localized subjects

//Human readable portions of DSN
#define DSN_SEE_ATTACHMENTS     10
#define FAILURE_SUMMARY         11
#define FAILURE_RELAY_SUMMARY   12
#define DELAY_SUMMARY           13
#define DSN_SUMMARY             14
#define RELAY_SUMMARY           15
#define DELIVERED_SUMMARY       16
#define EXPANDED_SUMMARY        17
#define FAILURE_SUMMARY_MAILBOX 18
#define FAILURE_SUMMARY_HOP     19
#define FAILURE_SUMMARY_EXPIRE  20
#define DELAY_WARNING           21
#define DELAY_DO_NOT_SEND       22
//helpful descriptions of the type of DSN being sent
#endif //__DSNLANG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\cat.h ===
/************************************************************
 * FILE: cat.h
 * PURPOSE: API for Categorizing IMsg objects.
 * HISTORY:
 *  // jstamerj 980211 13:53:44: Created
 ************************************************************/
#ifndef __CAT_H__
#define __CAT_H__

#include <windows.h>
#include <mailmsg.h>
#include <aqueue.h>

#define CATCALLCONV

#define CATEXPDLLCPP extern "C"

/************************************************************
 * FUNCTION: CatInit
 * DESCRIPTION: Initialzies Categorizer.
 * PARAMETERS:
 *   pszConfig: Indicates where to find configuration defaults
 *              Config info found in key
 *              HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
 *              \PlatinumIMC\CatSources\szConfig
 *
 *   phCat:    Pointer to a handle.  Upon successfull initializtion,
 *             handle to use in subsequent Categorizer calls will be
 *             plcaed there.
 *
 *   pAQConfig: pointer to an AQConfigInfo structure containing
 *              per virtual server message cat parameters
 *
 *   pfn: Service routine for periodic callbakcs if any time consuming
 *        operations are performed
 *
 *   pServiceContext: Context for the pfn function.
 *
 *   pISMTPServer: ISMTPServer interface to use for triggering server
 *                 events for this virtual server
 *
 *   pIDomainInfo: pointer to an interface that contains domain info routines
 *
 *   dwVirtualServerInstance: Virtual Server ID
 *
 * Return value: S_OK if everything is initialized okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:26: Created
 *   // jstamerj 1998/06/25 12:25:34: Added AQConfig/IMSTPServer.
 *
 ************************************************************/
typedef void (*PCATSRVFN_CALLBACK)(PVOID);
CATEXPDLLCPP HRESULT CATCALLCONV CatInit(
    IN  AQConfigInfo *pAQConfig,
    IN  PCATSRVFN_CALLBACK pfn,
    IN  PVOID pvServiceContext,
    IN  ISMTPServer *pISMTPServer,
    IN  IAdvQueueDomainType *pIDomainInfo,
    IN  DWORD dwVirtualServerInstance,
    OUT HANDLE *phCat);

//+------------------------------------------------------------
//
// Function: CatChangeConfig
//
// Synopsis: Changes the configuration of a virtual categorizer
//
// Arguments:
//   hCat: handle of virtual categorizer
//   pAQConfig: AQConfigInfo pointer
//   pISMTPServer: ISMTPServer to use
//   pIDomainInfo: interface that contains domain information
//
//   Flags for dwMsgCatFlags in AQConfigInfo
#define MSGCATFLAG_RESOLVELOCAL             0x00000001
#define MSGCATFLAG_RESOLVEREMOTE            0x00000002
#define MSGCATFLAG_RESOLVESENDER            0x00000004
#define MSGCATFLAG_RESOLVERECIPIENTS        0x00000008
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: Invalid hCat or pAQConfig
//
// History:
// jstamerj 980521 15:47:42: Created.
//
//-------------------------------------------------------------
CATEXPDLLCPP HRESULT CATCALLCONV CatChangeConfig(
    IN HANDLE hCat,
    IN AQConfigInfo *pAQConfig,
    IN ISMTPServer *pISMTPServer,
    IN IAdvQueueDomainType *pIDomainInfo);



/************************************************************
 * FUNCTION: PFNCAT_COMPLETION (User supplied)
 * DESCRIPTION: Completion routine called to accept a categorized IMsg
 * PARAMETERS:
 *   hr:       S_OK unless message categorization was not finished.
 *             CAT_W_SOME_UNDELIVERABLE_MSGS if one or more
 *             recipient should not be delivered to...
 *   pContext: User's value passed into CatMsg
 *   pImsg:    IMsg interface of categorized object -- if message was
 *             bifurcated this parameter will be NULL
 *   rpgImsg:  NULL unless IMsg was bifurcated -- if message was
 *             bifurcated, this will be a NULL termianted array of
 *             ptrs to IMsg interfaces.
 * NOTE: Either pImsg or rgpImsg will always be NULL (but never both).
 *
 * Return Value: S_OK if everything is okay (Categorizer will assert
 *                                           check this value)
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
typedef HRESULT (CATCALLCONV *PFNCAT_COMPLETION)(/* IN  */ HRESULT hr,
                                                 /* IN  */ PVOID pContext,
                                                 /* IN  */ IUnknown *pImsg,
                                                 /* IN  */ IUnknown **rgpImsg);


/************************************************************
 * FUNCTION: CatMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface for message to categorize
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatMsg (/* IN  */ HANDLE hCat,
                                         /* IN  */ IUnknown *pImsg,
                                         /* IN  */ PFNCAT_COMPLETION pfn,
                                         /* IN  */ LPVOID pContext);

/************************************************************
 * FUNCTION: PFNCAT_DLCOMPLETION (User supplied)
 * DESCRIPTION: Completion routine called to accept a categorized message
 * PARAMETERS:
 *   hr:       S_OK unless message categorization was not finished.
 *   pContext: User's value passed into CatMsg
 *   pImsg:    IMsg interface of categorized object (with expanded recipients)
 *   fMatch:   TRUE if your user was found
 *
 * Return Value: S_OK if everything is okay (Categorizer will assert
 *                                           check this value)
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
typedef HRESULT (CATCALLCONV *PFNCAT_DLCOMPLETION)(
    /* IN  */ HRESULT hr,
    /* IN  */ PVOID pContext,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ BOOL fMatch);


/************************************************************
 * FUNCTION: CatDLMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface to categorize -- each DL should be a recip
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *   fMatchOnly: Stop resolving when a match is found?
 *   CAType:   The address type of pszAddress
 *   pszAddress: THe address you are looking for
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatDLMsg (
    /* IN  */ HANDLE hCat,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ PFNCAT_DLCOMPLETION pfn,
    /* IN  */ LPVOID pContext,
    /* IN  */ BOOL fMatchOnly = FALSE,
    /* IN  */ CAT_ADDRESS_TYPE CAType = CAT_UNKNOWNTYPE,
    /* IN  */ LPSTR pszAddress = NULL);


/************************************************************
 * FUNCTION: CatTerm
 * DESCRIPTION: Called when user wishes to terminate categorizer
 *              opertions with this handle
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatTerm(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatCancel
 * DESCRIPTION: Cancels pending searches for this hCat.  User's
 *              completion routine will be called with an error for
 *              each pending message.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:52:10: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatCancel(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatPrepareForShutdown
 * DESCRIPTION: Begin shutdown for this virtual categorizer (hCat).
 *              Stop accepting messages for categorization and cancel
 *              pending categorizations.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 1999/07/19 22:35:17: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatPrepareForShutdown(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatVerifySMTPAddress
 * DESCRIPTION: Verifies a the address corresponds to a valid user or DL
 * PARAMETERS:
 *  hCat:       Categorizer handle received from CatInit
 *  szSMTPAddr  SMTP Address to lookup (ex: "user@domain")
 *
 * Return Values:
 *  S_OK            User exists
 *  CAT_I_DL        This is a distribution list
 *  CAT_I_FWD       This user has a forwarding address
 *  CAT_E_NORESULT  There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatVerifySMTPAddress(
  /* IN  */ HANDLE hCat,
  /* IN  */ LPTSTR szSMTPAddr);


/************************************************************
 * FUNCTION: CatGetForwaringSMTPAddress
 * DESCRIPTION: Retreive a user's forwarding address.
 * PARAMETERS:
 *  hCat:           Categorizer handle received from CatInit
 *  szSMTPAddr:     SMTP Address to lookup (ex: "user@domain")
 *  pdwcc:          Size of forwarding address buffer in Chars
 *                  (This is set to actuall size of forwarding address
 *                   string (including NULL terminator) on exit)
 *  szSMTPForward:  Buffer where retreived forwarding SMTP address
 *                  will be copied. (can be NULL if *pdwcc is zero)
 *
 * Return Values:
 *  S_OK            Success
 *  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
 *                  *pdwcc was not large enough to hold the forwarding
 *                  address string.
 * CAT_E_DL         This is a distribution list.
 * CAT_E_NOFWD      This user does not have a forwarding address.
 * CAT_E_NORESULT   There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatGetForwardingSMTPAddress(
  /* IN  */    HANDLE  hCat,
  /* IN  */    LPCTSTR szSMTPAddr,
  /* IN,OUT */ PDWORD  pdwcc,
  /* OUT */    LPTSTR  szSMTPForward);

//
// Com support functions for COM categorizer objects
//


//+------------------------------------------------------------
//
// Function: CatDllMain
//
// Synopsis: Handle what cat needs to do in DLLMain
//
// Arguments:
//  hInstance: instance of this DLL
//  dwReason: Why are you calling me?
//  lpReserved
//
// Returns: TRUE
//
// History:
// jstamerj 1998/12/12 23:06:08: Created.
//
//-------------------------------------------------------------
BOOL WINAPI CatDllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */);




//+------------------------------------------------------------
//
// Function: RegisterCatServer
//
// Synopsis: Register the categorizer com objects
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:07:20: Created.
//
//-------------------------------------------------------------
STDAPI RegisterCatServer();


//+------------------------------------------------------------
//
// Function: UnregisterCatServer
//
// Synopsis: Unregister the categorizer com objects
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:08:09: Created.
//
//-------------------------------------------------------------
STDAPI UnregisterCatServer();


//+------------------------------------------------------------
//
// Function: DllCanUnloadCatNow
//
// Synopsis: Return to COM wether it's okay or not to unload our dll
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, can unload
//  S_FALSE: Success, do not unload
//
// History:
// jstamerj 1998/12/12 15:09:02: Created.
//
//-------------------------------------------------------------
STDAPI DllCanUnloadCatNow();


//+------------------------------------------------------------
//
// Function: DllGetCatClassObject
//
// Synopsis: Return the class factory object (an interface to it)
//
// Arguments:
//  clsid: The CLSID of the object you want a class factory for
//  iid: the interface you want
//  ppv: out param to set to the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: don't support that interface
//  CLASS_E_CLASSNOTAVAILABLE: don't support that clsid
//
// History:
// jstamerj 1998/12/12 15:11:48: Created.
//
//-------------------------------------------------------------
STDAPI DllGetCatClassObject(
    const CLSID& clsid,
    const IID& iid,
    void **ppv);


//+------------------------------------------------------------
//
// Function: CatGetPerfCounters
//
// Synopsis: Retrieve the categorizer performance counter block
//
// Arguments:
//  hCat: Categorizer handle returned from CatInit
//  pCatPerfBlock: struct to fill in with counter values
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/02/26 14:53:21: Created.
//
//-------------------------------------------------------------
HRESULT CatGetPerfCounters(
    HANDLE hCat,
    PCATPERFBLOCK pCatPerfBlock);


//+------------------------------------------------------------
//
// Function: CatLogEvent
//
// Synopsis: Log an event to the event log
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for logging
//
// Returns:
//  S_OK: Success
//
// History:
// dbraun 2000/09/13 : Created.
//
//-------------------------------------------------------------
HRESULT CatLogEvent(
    ISMTPServer              *pISMTPServer,
    DWORD                    idMessage,
    WORD                     idCategory,
    WORD                     cSubstrings,
    LPCSTR                   *rgszSubstrings,
    WORD                     wType,
    DWORD                    errCode,
    WORD                     iDebugLevel,
    LPCSTR                   szKey,
    DWORD                    dwOptions,
    DWORD                    iMessageString = 0xffffffff,
    HMODULE                  hModule = NULL);

#endif // __CAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\dsnsink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnsink.h
//
//  Description: Header file for CDefaultDSNSink - Default DSN Generation Sink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/30/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNSINK_H__
#define __DSNSINK_H__

#include <aqintrnl.h>
#include <baseobj.h>

#define DSN_SINK_SIG 'sNSD'
#define DSN_SINK_SIG_FREED 'NSD!'

class CDSNBuffer;

//Limit on the MIME boundary string set by RFC2046
#define MIME_BOUNDARY_RFC2046_LIMIT 70

//RFCs 2045-2048 suggests that we inlcude "=_" somewhere in the MIME Boundry
#define MIME_BOUNDARY_CONSTANT "9B095B5ADSN=_"
#define MIME_BOUNDARY_START_TIME_SIZE 16*sizeof(CHAR) //Size of string with file-time
#define MIME_BOUNDARY_SIZE MIME_BOUNDARY_START_TIME_SIZE + \
            sizeof(MIME_BOUNDARY_CONSTANT) + \
            24*sizeof(CHAR) //room for 8 char count and portion of host name

//needs room for "x.xxx.xxx", plus an optional comment
#define MAX_STATUS_COMMENT_SIZE 50
#define STATUS_STRING_SIZE      10+MAX_STATUS_COMMENT_SIZE

#define DSN_OPTIONS_WRITE_CONTEXT 0x40000000

//---[ CDefaultDSNSink ]-------------------------------------------------------
//
//
//  Description: 
//      Default DSN Generation sink... implements IDSNGenerationSink
//  Hungarian: 
//      dsnsink, pdsnsink
//  
//-----------------------------------------------------------------------------
class CDefaultDSNSink :
    public IDSNGenerationSink,
    public CBaseObject
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_cDSNsRequested;
    CHAR        m_szPerInstanceMimeBoundary[MIME_BOUNDARY_START_TIME_SIZE + 1];
    BOOL        m_fInit;
    HRESULT     HrGetFilterMaskAndFlags(IN DWORD dwDSNActions, 
                                OUT DWORD *pdwRecipMask, OUT DWORD *pdwRecipFlags);
    BOOL        fdwGetDSNAction(IN DWORD dwDSNAction, 
                                IN OUT DWORD *pdwCurrentRecipFlags,
                                OUT DWORD *pdwCurrentDSNAction);

    void        GetCurrentMimeBoundary(
                                IN LPSTR szReportingMTA,
                                IN DWORD cbReportingMTA,
                                IN OUT CHAR szMimeBoundary[MIME_BOUNDARY_SIZE],
                                OUT DWORD *pcbMimeBoundary);

    //Used to mark all recipient flags, when there is no per recip processing 
    //happening (like NDR of DSN).
    HRESULT     HrMarkAllRecipFlags(
                                IN DWORD dwDSNAction,
                                IN IMailMsgRecipients *IMailMsgRecipients,
                                IN RECIPIENT_FILTER_CONTEXT *prpfctxt);

    //Writes global DSN P1 Properties to IMailMsgProperties and P2 headers to content
    HRESULT     HrWriteDSNP1AndP2Headers(
                                IN DWORD dwDSNAction,
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szDefaultDomain,
                                IN DWORD cbDefaultDomain,
                                IN LPSTR szReportingMTA,
                                IN DWORD cbReportingMTA,
                                IN LPSTR szDSNContext,
                                IN DWORD cbDSNContext,
                                IN LPSTR szCopyNDRTo,
                                IN HRESULT hrStatus,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                IN DWORD dwDSNOptions);

    //Write human readable portion of DSN
    HRESULT     HrWriteDSNHumanReadable(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN RECIPIENT_FILTER_CONTEXT *prpfctxt,
                                IN DWORD dwDSNActions,
                                IN CDSNBuffer *pdsnbuff,
                                IN DWORD dwPreferredLangId,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                IN HRESULT hrStatus);

    //Write the per-msg portion of the DSN Report
    HRESULT     HrWriteDSNReportPerMsgProperties(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szReportingMTA,
                                IN DWORD cbReportingMTA,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary);

    //Write a per-recipient portion of the DSN Report
    HRESULT     HrWriteDSNReportPreRecipientProperties(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN CDSNBuffer *pdsnbuff,
                                IN DWORD dwRecipFlags,
                                IN DWORD iRecip,
                                IN LPSTR szExpireTime,
                                IN DWORD cbExpireTime,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status,
                                IN HRESULT hrStatus);

    //Writes last mime-headers, flush dsnbuffer, and copy original message 
    HRESULT     HrWriteDSNClosingAndOriginalMessage(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN DWORD   dwDSNAction,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary);

    //Writes the original full message to the third DSN part
    HRESULT     HrWriteOriginalMessageFull(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary);

    //Write only the headers of the orignal message to the third DSN part
    HRESULT     HrWriteOriginalMessageHeaders(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary);

    //Write MIME headers to finish message
    HRESULT     HrWriteMimeClosing(
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                OUT DWORD *pcbDSNSize);

    //Gets the per-recipient DSN status code 
    HRESULT     HrGetStatusCode(IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN DWORD iRecip,
                                IN DWORD dwDSNAction,
                                IN DWORD dwStatus, 
                                IN HRESULT hrStatus, 
                                IN DWORD dwRecipFlags,
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    //Parse status code from RFC2034 extended status code string
    HRESULT     HrGetStatusFromStatus(
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    //Determine status based on supplied context information
    HRESULT     HrGetStatusFromContext(
                                IN HRESULT hrRecipient,
                                IN DWORD   dwRecipFlags,
                                IN DWORD   dwDSNAction,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    HRESULT     HrGetStatusFromRFC821Status(
                                IN DWORD    dwRFC821Status,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    void        GetCurrentIterationsDSNAction(
                                IN OUT DWORD   *pdwActualDSNAction,
                                IN OUT DWORD   *pcIterationsLeft);

    //Writes a list of recipients being DSN'd... one per line
    HRESULT     HrWriteHumanReadableListOfRecips(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN RECIPIENT_FILTER_CONTEXT *prpfctxt,
                                IN DWORD dwDSNActionsNeeded,
                                IN CDSNBuffer *pdsnbuff);

    //Get the recipient address and type... checks multple mailmsg props
    HRESULT     HrGetRecipAddressAndType(
                                IN     IMailMsgRecipients *pIMailMsgRecipients,
                                IN     DWORD iRecip,
                                IN     DWORD cbAddressBuffer,
                                IN OUT LPSTR szAddressBuffer,
                                IN     DWORD cbAddressType,
                                IN OUT LPSTR szAddressType);

#ifdef DEBUG
    void VerifyMarkedRecips(IMailMsgRecipients *pIMailMsgRecipients, 
                       DWORD dwStartDomain,DWORD dwDSNActions);
#endif //DEBUG
  public:
    CDefaultDSNSink();
    HRESULT HrInitialize();
    ~CDefaultDSNSink();
  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};
  public: //IDSNGenerationSink
    STDMETHOD(GenerateDSN)(ISMTPServer *pISMTPServer,
                           IMailMsgProperties *pIMailMsgProperties,
                           DWORD dwStartDomain,
                           DWORD dwDSNActions,
                           DWORD dwRFC821Status,
                           HRESULT hrStatus,
                           LPSTR szDefaultDomain,
                           DWORD cbDefaultDomain,
                           LPSTR szReportingMTA,
                           DWORD cbReportingMTA,
                           LPSTR szReportingMTAType,
                           DWORD cbReportingMTAType,
                           LPSTR szDSNContext,
                           DWORD cbDSNContext,
                           DWORD dwPreferredLangId,
                           DWORD dwDSNOptions,
                           LPSTR szCopyNDRTo,
                           DWORD cbCopyNDRTo,
                           IMailMsgProperties **ppIMailMsgPropertiesDSN,
                           DWORD *pdwDSNTypesGenerated,
                           DWORD *pcRecipsDSNd,
                           DWORD *pcIterationsLeft);
};

#endif //__DSNSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\fifoq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoq.h
//
//  Description:    
//      FifoQueue class definition.  Provides a high-speed memory 
//      efficient growable FIFO queue for COM-style objects that 
//      support addref and release.
//
//  Author:         mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _FIFOQ_H_
#define _FIFOQ_H_

#include <aqincs.h>
#include <rwnew.h>

#define FIFOQ_SIG   'euQF'
template<class PQDATA>
class CFifoQueuePage;

//---[ CFifoQueue ]------------------------------------------------------------
//
//
//    Hungarian: fq, pfq
//
//  Implements a FIFO Queue for COM objects (or any objects that supports 
//  addref and release).  Provides the ability to peek, requeue, and maintain a 
//  cursor into the queue in addition to the normal queue operations.
//
//-----------------------------------------------------------------------------
template<class PQDATA>
class CFifoQueue
{
public:
    typedef HRESULT (*MAPFNAPI)(PQDATA, PVOID, BOOL*, BOOL*); //function type for MapFn

    CFifoQueue();
    ~CFifoQueue();

    //static startup and shutdown operations
    //These are ref counted and can be called multiple times
    //Eventually we might decide to modify the size of the free list based
    //on the number of references.
    static  void       StaticInit();
    static  void       StaticDeinit();

    //Normal Queue operations
    HRESULT HrEnqueue(IN PQDATA pqdata);   //Data to enqueue
    HRESULT HrDequeue(OUT PQDATA *ppqdata); //Data dequeued
               

    //Insert at the front of the queue
    HRESULT HrRequeue(IN PQDATA pqdata); //Data to requeue
                
    
    //Return the data at the head of the queue without dequeuing
    HRESULT HrPeek(OUT PQDATA *ppqdata); //Data peeked
                
    
    //returns the number of entries in the queue
    DWORD   cGetCount() {return m_cQueueEntries;};  

    //Advances the secondary cursor until supplied function  returns FALSE
    //  The pFunc parameter must be a function with the following prototype:
    //
    //      HRESULT pvFunc(
    //                 IN  PQDATA pqdata,  //ptr to data on queue
    //                 IN  PVOID pvContext, //context passed to function
    //                 OUT BOOL *pfContinue, //TRUE if we should continue
    //                 OUT BOOL *pfDelete);  //TRUE if item should be deleted
    //   pFunc must NOT release pqdata.. if it is no longer valid, it should
    //   return TRUE in pfDelete, and the calling code will remove it from
    //   the queue and release it. 
    //   NOTE: the MAPFNAPI is CFifoQueue<PQDATA>::MAPFNAPI and is 
    //   specific to the type of template
    HRESULT HrMapFn(
                IN MAPFNAPI pFunc,          //ptr to function to map
                IN PVOID    pvContext,      //context to pass to function
                OUT DWORD *pcItems);        //number of items mapped
    
protected:
#ifdef DEBUG
    void           AssertQueueFn(BOOL fHaveLocks = FALSE);
#endif //DEBUG
    typedef        CFifoQueuePage<PQDATA>  FQPAGE;
    DWORD          m_dwSignature;
    DWORD          m_cQueueEntries;  //Count of entries in queue
    FQPAGE        *m_pfqpHead;       //First Queue Page
    FQPAGE        *m_pfqpTail;       //Tail Page of queue
    FQPAGE        *m_pfqpCursor;     //Page that the cursor is on
    PQDATA        *m_ppqdataHead;    //Next item to be grabbed
    PQDATA        *m_ppqdataTail;    //First free space available
    PQDATA        *m_ppqdataCursor;  //secondary queue cursor that is
                                              //between the head and the tail 
                                              //of the queue 
    CShareLockNH   m_slTail; //CS for updating tail ptr & page
    CShareLockNH   m_slHead; //CS for updating head ptr & page
    
    //Adjusts head  ptr for dequeue and peek
    HRESULT HrAdjustHead(); 

    //Static Methods and variables to manage a free list of queue pages
    volatile static  FQPAGE    *s_pfqpFree;      //Pointer to free page list
    static  DWORD               s_cFreePages;    //Count of pages on free list
    static  DWORD               s_cFifoQueueObj; //Count of queue objects
    static  DWORD               s_cStaticRefs;   //# of calls to HrStaticInit
    static  CRITICAL_SECTION    s_csAlloc;       //Protect against ABA in alloc

    static  HRESULT         HrAllocQueuePage(
                                OUT FQPAGE **ppfqp); //allocated page
    static  void            FreeQueuePage(FQPAGE *pfqp);
    static  void            FreeAllQueuePages(); //Free all pages at shutdown

#ifdef DEBUG
    //use when making changes to do basic tracking of memory leaks
    static  DWORD           s_cAllocated;       //Count of allocated queue pages
    static  DWORD           s_cDeleted;         //Count of deleted queue pages
    static  DWORD           s_cFreeAllocated;   //allocations from free list
    static  DWORD           s_cFreeDeleted;     //number of calls to add to free list
#endif //DEBUG

};

//Example HrMapFn Function that will clear the queue.
template <class PQDATA>
HRESULT HrClearQueueMapFn(IN PQDATA pqdata, OUT BOOL *pfContinue, OUT BOOL *pfDelete);


#endif // _FIFOQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\imcplat.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       imcplat.h
//
//  Contents:   Main header file for IMC service executable.
//              Shared out so setup can pick up service names etc.
//
//  Classes:    None
//
//  Functions:  None
//
//  History:    Dec 3, 1997 - Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _IMCPLAT_H_
#define _IMCPLAT_H_

// Legacy Exchange IMC service key names
#define EXCHANGE_IMC_SERVICE_REG_KEY "System\\CurrentControlSet\\Services\\MSExchangeIMC"
#define EXCHANGE_IMC_SERVICE_REG_KEY_W L"System\\CurrentControlSet\\Services\\MSExchangeIMC"

// New Platinum IMC service key names
#define IMC_SERVICE_NAME            "PlatinumIMC"
#define IMC_SERVICE_DISPLAY_NAME    "Exchange Platinum IMC"

#define IMC_SERVICE_LEGACY_KEY      "System\\CurrentControlSet\\Services\\MSExchangeIMC"
#define IMC_SERVICE_LEGACY_KEY_W    L"System\\CurrentControlSet\\Services\\MSExchangeIMC"
#define IMC_SERVICE_REG_KEY         "System\\CurrentControlSet\\Services\\PlatinumIMC"
#define IMC_SERVICE_REG_KEY_W       L"System\\CurrentControlSet\\Services\\PlatinumIMC"
#define IMC_SERVICE_REG_PARAMETERS  "Parameters"
#define IMC_SERVICE_REG_PARAMETERS_W L"Parameters"
#define IMC_SERVICE_REG_SITE_DN     "SiteDN"
#define IMC_SERVICE_REG_SITE_DN_W   L"SiteDN"
#define IMC_SERVICE_REG_COMMON_NAME "CommonName"
#define IMC_SERVICE_REG_COMMON_NAME_W L"CommonName"
#define IMC_SERVICE_REG_LOCALDOMAIN "LocalDomain"
#define IMC_SERVICE_REG_LOCALDOMAIN_W L"LocalDomain"
#define IMC_SERVICE_REG_DROPDIR     "DropDirectory"
#define IMC_SERVICE_REG_DROPDIR_W   L"DropDirectory"
#define IMC_SERVICE_REG_PICKUPDIR   "PickupDirectory"
#define IMC_SERVICE_REG_PICKUPDIR_W L"PickupDirectory"

// jstamerj 980216 18:12:09: Categorizer keys
#define IMC_SERVICE_REG_CATSOURCES   TEXT("CatSources")
#define IMC_SERVICE_REG_CATSOURCES_A "CatSources"
#define IMC_SERVICE_REG_CATSOURCES_W L"CatSources"

//Message Cat instance keys 
#define IMC_SERVICE_REG_KEY_MSGCAT          "1"   //Assumes virtual service #1
#define IMC_SERVICE_REG_KEY_MSGCAT_W        L"1"
#define IMC_SERVICE_REG_MSGCAT_BIND         "Bind"
#define IMC_SERVICE_REG_MSGCAT_BIND_W       L"Bind"
#define IMC_SERVICE_REG_MSGCAT_ACCOUNT      "Account"
#define IMC_SERVICE_REG_MSGCAT_ACCOUNT_W    L"Account"
#define IMC_SERVICE_REG_MSGCAT_PASSWORD     "Password"
#define IMC_SERVICE_REG_MSGCAT_PASSWORD_W   L"Password"
#define IMC_SERVICE_REG_MSGCAT_LOCALDOMAINS "LocalDomains"
#define IMC_SERVICE_REG_MSGCAT_LOCALDOMAINS_W L"LocalDomains"
#define IMC_SERVICE_REG_MSGCAT_TMP          "TMPDIRECTORY"
#define IMC_SERVICE_REG_MSGCAT_TMP_W        L"TMPDIRECTORY"
#define IMC_SERVICE_REG_MSGCAT_SCHEMA       "Schema"
#define IMC_SERVICE_REG_MSGCAT_SCHEMA_W     L"Schema"
#define IMC_SERVICE_REG_MSGCAT_NAMINGCONTEXT    "NamingContext"
#define IMC_SERVICE_REG_MSGCAT_NAMINGCONTEXT_W  L"NamingContext"

#define IMC_SERVICE_DEFAULT_BIND            "Simple"
#define IMC_SERVICE_DEFAULT_BIND_W          L"Simple"
#define IMC_SERVICE_DEFAULT_SCHEMA          "Exchange5"
#define IMC_SERVICE_DEFAULT_SCHEMA_W        L"Exchange5"

//Partial DN... 
//full DN is of the form "<SiteDN>/cn=Configuration/cn=Connections/cn=<CommonName>"
#define IMC_SERVICE_PARTIAL_GATEWAY_DN      "/cn=Configuration/cn=Connections/cn="
#define IMC_SERVICE_PARTIAL_GATEWAY_DN_W    L"/cn=Configuration/cn=Connections/cn="
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\hshroute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: hshroute.h
//
//  Description: Hash Routing functions.  In many cases, domains are
//      identified by domain *and* routing informtion.  This additional
//      information is identified by router GUID and a DWORD idenitfier.
//      This header provides macros to create unique domain-name-like strings
//      from the domain name and additional routing information.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/24/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __HSHROUTE_H__
#define __HSHROUTE_H__

#include <dbgtrace.h>

//The following is a list of 1 character "types" that can be used to identify
//the type of routing information hashed.  It is unlikely that this list will
//grow significantly (or even at all).
typedef enum
{
    //Be sure to update FIRST_ROUTE_HASH_TYPE if you change the first type
    ROUTE_HASH_MESSAGE_TYPE = 0,
    ROUTE_HASH_SCHEDULE_ID,
    ROUTE_HASH_NUM_TYPES,
} eRouteHashType;
#define FIRST_ROUTE_HASH_TYPE ROUTE_HASH_MESSAGE_TYPE

_declspec (selectany) CHAR g_rgHashTypeChars[ROUTE_HASH_NUM_TYPES+1] =
{
    'M', //ROUTE_HASH_MESSAGE_TYPE
    'S', //ROUTE_HASH_SCHEDULE_ID
    '\0' //End of list
};

//---[ dwConvertHexChar ]------------------------------------------------------
//
//
//  Description:
//      Converts Hex character into an int from 0 to 15.
//  Parameters:
//      chHex   Hex character to convert
//  Returns:
//      DWORD value between 0 and 15
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwConvertHexChar(CHAR chHex)
{
    DWORD dwValue = 0;
    if (('0' <= chHex) && ('9' >= chHex))
        dwValue = chHex-'0';
    else if (('a' <= chHex) && ('f' >= chHex))
        dwValue = 10 + chHex-'a';
    else if (('A' <= chHex) && ('F' >= chHex))
        dwValue = 10 + chHex-'A';
    else
        _ASSERT(0 && "Invalid hex character");

    _ASSERT(15 >= dwValue);
    return dwValue;
}


//Format is <type>.GUID.DWORD... each byte takes 2 chars to encode in HEX
//  eg - M.00112233445566778899AABBCCDDEEFF.00112233.foo.com

//Offsets are defined to be used in ptr arith or array offsets
#define ROUTE_HASH_CHARS_IN_DWORD   (2*sizeof(DWORD))
#define ROUTE_HASH_CHARS_IN_GUID    (2*sizeof(GUID))
#define ROUTE_HASH_TYPE_OFFSET      0
#define ROUTE_HASH_GUID_OFFSET      2
#define ROUTE_HASH_DWORD_OFFSET     (3 + ROUTE_HASH_CHARS_IN_GUID)
#define ROUTE_HASH_DOMAIN_OFFSET    (4 + ROUTE_HASH_CHARS_IN_GUID + ROUTE_HASH_CHARS_IN_DWORD)
#define ROUTE_HASH_PREFIX_SIZE      sizeof(CHAR)*ROUTE_HASH_DOMAIN_OFFSET

//---[ erhtGetRouteHashType ]---------------------------------------------------
//
//
//  Description:
//      For a given hashed domain, will return the assocaiated eRouteHashType
//  Parameters:
//      IN  szHashedDomain  Hashed domain
//  Returns:
//      eRouteHashType of hashed domain
//      ROUTE_HASH_NUM_TYPES (and asserts) if domain is not a valid route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline eRouteHashType erhtGetRouteHashType(LPSTR szHashedDomain)
{
    eRouteHashType erthRet = FIRST_ROUTE_HASH_TYPE;
    PCHAR pchRouteHashType = g_rgHashTypeChars;
    CHAR  chRouteHashType = szHashedDomain[ROUTE_HASH_TYPE_OFFSET];

    while (('\0' != *pchRouteHashType) &&
           (*pchRouteHashType != chRouteHashType))
    {
        pchRouteHashType++;
        erthRet = (eRouteHashType) (erthRet + 1);

        //we should not get to end of list
        _ASSERT(ROUTE_HASH_NUM_TYPES > erthRet);
    }

    return erthRet;
}

//---[ szGetDomainFromRouteHash ]----------------------------------------------
//
//
//  Description:
//      Returns the string of the unhashed domain from the hashed domain
//      string.  Do *NOT* attempt to free this string.
//  Parameters:
//      IN  szHashedDomain  Hashed domain
//  Returns:
//      Original... unhashed domain
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline LPSTR szGetDomainFromRouteHash(LPSTR szHashedDomain)
{
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DOMAIN_OFFSET-1]);
    return (szHashedDomain + ROUTE_HASH_DOMAIN_OFFSET);
}

//---[ guidGetGUIDFromRouteHash ]----------------------------------------------
//
//
//  Description:
//      Extracts the guid from the route hash
//  Parameters:
//      IN     szHashedDomain   Hashed domain
//      IN OUT pguid            Extracted GUID
//  Returns:
//      -
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline void GetGUIDFromRouteHash(LPSTR szHashedDomain, IN OUT GUID *pguid)
{
    DWORD *pdwGuid = (DWORD *) pguid;
    LPSTR szGUIDString = szHashedDomain+ROUTE_HASH_GUID_OFFSET;

    _ASSERT(sizeof(GUID)/sizeof(DWORD) == 4); //should be 4 DWORDs in GUID

    //Reverse operation of hash... convert to array of 4 DWORDs
    for (int i = 0; i < 4; i++)
    {
        pdwGuid[i] = 0;
        for (int j = 0;j < ROUTE_HASH_CHARS_IN_DWORD; j++)
        {
            pdwGuid[i] *= 16;
            pdwGuid[i] += dwConvertHexChar(*szGUIDString);
            szGUIDString++;
        }
    }
    _ASSERT('.' == *szGUIDString);
}

//---[ dwGetIDFromRouteHash ]--------------------------------------------------
//
//
//  Description:
//      Extracts DWORD ID from route hash
//  Parameters:
//      IN     szHashedDomain   Hashed domain
//  Returns:
//      DWORD ID encoded in route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwGetIDFromRouteHash(LPSTR szHashedDomain)
{
    _ASSERT(szHashedDomain);
    LPSTR szDWORDString = szHashedDomain+ROUTE_HASH_DWORD_OFFSET;
    DWORD dwID = 0;

    for (int i = 0; i < ROUTE_HASH_CHARS_IN_DWORD; i++)
    {
        dwID *= 16;
        dwID += dwConvertHexChar(*szDWORDString);
        szDWORDString++;
    }

    _ASSERT('.' == *szDWORDString);
    return dwID;
}

//---[ dwGetSizeForRouteHash ]--------------------------------------------------
//
//
//  Description:
//      Returns the required sizeof the hash buffer from the string
//      length of the domain
//  Parameters:
//      IN  cbDomainName    string length of domain name (in bytes)
//  Returns:
//      size (in bytes) of buffer required to create route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwGetSizeForRouteHash(DWORD cbDomainName)
{
    //include prefix size and NULL char
    return (cbDomainName + sizeof(CHAR) + ROUTE_HASH_PREFIX_SIZE);
}

//---[ CreateRouteHash ]-------------------------------------------------------
//
//
//  Description:
//      Creates a route-hashed domain name from a given domain name and
//      routing information.
//  Parameters:
//      IN     cbDomainName     string length of domain name (in bytes)
//      IN     szDomainName     Name of domain to hash
//      IN     pguid            Ptr to GUID of router
//      IN     dwRouterID       ID Provided by router
//      IN OUT szHashedDomain   Buffer that is filled with route-hashed domain
//                              name
//  Returns:
//      -
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline void CreateRouteHash(IN     DWORD cbDomainName,
                            IN     const LPSTR szDomainName,
                            IN     eRouteHashType erhtType,
                            IN     GUID *pguidRouter,
                            IN     DWORD dwRouterID,
                            IN OUT LPSTR szHashedDomain)
{
    _ASSERT(ROUTE_HASH_NUM_TYPES > erhtType);
    _ASSERT(pguidRouter);
    _ASSERT(sizeof(GUID) == 16);
    DWORD *pdwGuids = (DWORD *) pguidRouter;
    wsprintf(szHashedDomain, "%c.%08X%08X%08X%08X.%08X.%s",
            g_rgHashTypeChars[erhtType], pdwGuids[0], pdwGuids[1], pdwGuids[2],
            pdwGuids[3], dwRouterID, szDomainName);
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_GUID_OFFSET-1]);
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DWORD_OFFSET-1]);
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DOMAIN_OFFSET-1]);
}


#endif //__HSHROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\inc\retrsink.h ===
////////////////////////////////////////////////////////////////////////////////////////////////
// FILE: retrsink.h
// PURPOSE: Lib for handling retries of failed outbound connections
// HISTORY:
//  NimishK 05-14-98 Created
///////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __RETRSINK_H__
#define __RETRSINK_H__

#include <baseobj.h>

//function used for retry callback
typedef VOID (*RETRFN)(PVOID pvContext);
#define CALLBACK_DOMAIN "!callback"

////////////////////////////
//Temporary stuff, till we get this all into the event interface IDL file
typedef struct RetryData
{
   BOOL   fRetryDelay;
   DWORD   dwRetryDelay;
} RETRY_DATA, *PRETRY_DATA;

typedef struct RetryConfigData
{
    DWORD    dwRetryThreshold;
    DWORD    dwGlitchRetrySeconds;
    DWORD    dwFirstRetrySeconds;
    DWORD    dwSecondRetrySeconds;
    DWORD    dwThirdRetrySeconds;
    DWORD    dwFourthRetrySeconds;

} RETRYCONFIG, *PRETRYCONFIG;

enum SINK_STATUS {EVT_IGNORED, EVT_HANDLED, SKIP_ALL};
///////////////////////////

#define DOMAIN_ENTRY_RETRY 0x00000002
#define DOMAIN_ENTRY_SCHED 0x00000004
#define DOMAIN_ENTRY_FORCE_CONN 0x00000008
#define DOMAIN_ENTRY_ETRNTURN 0x00000040

//Forward declaration
class CRETRY_HASH_ENTRY;
class CRETRY_HASH_TABLE;
class CRETRY_Q;


////////////////////////////////////////////////////////////////////////////////////////////////
// class CSMTP_RETRY_HANDLER
//      This class provides the retry functionality that is needed when SMTP server fails to
//      send messages to the remote host.
//      It is considered the default retry handler - meaning in absence of any other entity 
//      taking care of retries, this handler will do it. For additional information look up
//      docs on the ServerEvent framework for AQUEUE.
//      Whenever SMTP acks a connection, this handler gets called. If the connection failed, the 
//      handler keeps track of the "NextHop" name that failed. It will disable the link corres-
//      ponding to the "NextHop" and reactivate it later based on the retry interval specified
//      the administrator. 
//      The main components are - a "NextHop" name hash table to keep track of links we know 
//      about, a queue with entries sorted by the retry time of a link and a dedicated thread 
//      that will be responsible for retrying entries based on the queue
//      This class will be initialized during the ConnectionManager initialization and deiniti-
//      alized during ConnectionManager Deinit.
//      It gets signalled whenever there is change in the config data ( retry interval )
//      
///////////////////////////////////////////////////////////////////////////////////////////////
class CSMTP_RETRY_HANDLER : 
    public IConnectionRetrySink, 
    public CBaseObject
{

   // CSMTP_RETRY_HANDLER
   public:
      CSMTP_RETRY_HANDLER()
      {
         m_RetryEvent = NULL;
         m_fHandlerShuttingDown = FALSE;
      }
      ~CSMTP_RETRY_HANDLER()
      {
         TraceFunctEnterEx((LPARAM)this, "~CSMTP_RETRY_HANDLER");

         TraceFunctLeaveEx((LPARAM)this);
      }
      
      //Init / denit called during ConnMan inits
      HRESULT HrInitialize(IN IConnectionRetryManager *pIConnectionRetryManager);
      HRESULT HrDeInitialize(void);
      
      //Config data change notifier - called by ConnMan whenver relevant
      //data in metabase changes
      void UpdateRetryData(PRETRYCONFIG pRetryConfig)
      { 
          m_dwRetryThreshold = pRetryConfig->dwRetryThreshold;
          m_dwGlitchRetrySeconds = pRetryConfig->dwGlitchRetrySeconds;
          m_dwFirstRetrySeconds =  pRetryConfig->dwFirstRetrySeconds;
          m_dwSecondRetrySeconds = pRetryConfig->dwSecondRetrySeconds;
          m_dwThirdRetrySeconds = pRetryConfig->dwThirdRetrySeconds;
          m_dwFourthRetrySeconds = pRetryConfig->dwFourthRetrySeconds;

          //Update all the queue entries with the new config data.
          //
          UpdateAllEntries();
      }

      //Wait for dedicated thread to exit during Deinit
      void WaitForQThread(void)
      {
         DWORD ThreadExit;
         ThreadExit = WaitForSingleObject(m_ThreadHandle,INFINITE);
      }

      //Wait for all ConnectionReleased threads to go away 
      //during deinit
      void WaitForShutdown(void)
      {
         DWORD ThreadExit;
         ThreadExit = WaitForSingleObject(m_ShutdownEvent,INFINITE);
      }

      //Set event to control the dedicated thread
      void SetQueueEvent(void)
      {
         _ASSERT(m_RetryEvent != NULL);

         SetEvent(m_RetryEvent);
      }

      //wrapper for calls to enable/disable a link using IConnectionRetryManager
      //Called by Dedicated thread or connection release thread
      BOOL ReleaseForRetry(IN char * szHashedDomainName);
      BOOL HoldForRetry(IN char * szHashedDomainName);

      CRETRY_HASH_TABLE* GetTablePtr(){return m_pRetryHash;}
      CRETRY_Q* GetQueuePtr(){return m_pRetryQueue;}
      
      HANDLE GetRetryEventHandle(void) const {return m_RetryEvent;}

      BOOL IsShuttingDown(void){ return m_fHandlerShuttingDown;}
      void SetShuttingDown(void){ m_fHandlerShuttingDown = TRUE;}

      //Called by the RetryThreadRoutine whenever it comes across a link entry that 
      // can be retried. Currently does not do much. Only Enables the link
      void ProcessEntry(CRETRY_HASH_ENTRY* pRHEntry);

      //The dedicated thread that keeps track of next link to be retried and wakes up and 
      //does that
      static DWORD WINAPI RetryThreadRoutine(void * ThisPtr);
        
      //Aqueue DLL wide ( cross instance ) init deinit
      static DWORD dwInstanceCount;

      //Will call back after the appropriate time has elapsed.
      HRESULT SetCallbackTime(IN RETRFN   pCallbackFn,
                              IN PVOID    pvContext,
                              IN DWORD    dwCallbackMinutes);

   public: //IConnectionRetrySink
      STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) {return E_NOTIMPL;};
      STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
      STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

      //Will be called by ConnectionManger every time a connection is released
      STDMETHOD(ConnectionReleased)( 
                           IN  DWORD cbDomainName,
                           IN  CHAR  szDomainName[],
                           IN  DWORD dwDomainInfoFlags,
                           IN  DWORD dwScheduleID,
                           IN  GUID  guidRouting,
                           IN  DWORD dwConnectionStatus,  
                           IN  DWORD cFailedMessages, 
                           IN  DWORD cTriedMessages,  
                           IN  DWORD cConsecutiveConnectionFailures,
                           OUT BOOL* pfAllowImmediateRetry,
                           OUT FILETIME *pftNextRetryTime);

   private :
      CRETRY_HASH_TABLE     *m_pRetryHash;
      CRETRY_Q              *m_pRetryQueue;
      DWORD                 m_dwRetryMilliSec;      // Retry interval based on config data
      IConnectionRetryManager *m_pIRetryManager;   // Interface to enable/disable link
      HANDLE                m_RetryEvent;           // Retry Release timeout event
      HANDLE                m_ShutdownEvent;      // Shutdown event
      HANDLE                m_ThreadHandle;         // Retry Thread handle
      BOOL                  m_fHandlerShuttingDown; // Shutdown flag
      BOOL                  m_fConfigDataUpdated;
      LONG                  m_ThreadsInRetry;      // Number of ConnectionManager threads
      
      DWORD                 m_dwRetryThreshold;
      DWORD                 m_dwGlitchRetrySeconds;
      DWORD                 m_dwFirstRetrySeconds;
      DWORD                 m_dwSecondRetrySeconds;
      DWORD                 m_dwThirdRetrySeconds;
      DWORD                 m_dwFourthRetrySeconds;



      //Calculates the time a link needs to be released for retry.
      //The time is based on the current time and the configured interval and
      //the history of connection failures for this particular host
      FILETIME CalculateRetryTime(DWORD cFailedConnections, FILETIME* InsertedTime);

      //Insert or remove domains from the retry handler ( hash table and the queue ) 
      //based on the Connection released call
      BOOL InsertDomain(char * szDomainName, 
                        IN  DWORD cbDomainName, //String length (in bytes) of domain name
                        IN  DWORD dwConnectionStatus,		//eConnectionStatus
                        IN  DWORD dwScheduleID,
                        IN  GUID  *pguidRouting,
                        IN  DWORD cConnectionFailureCount, 
                        IN  DWORD cTriedMessages, 	//# of untried messages in queue
						IN  DWORD cFailedMessages,		//# of failed message for *this* connection
                        OUT FILETIME *pftNextRetry  //next retry
						);
      BOOL RemoveDomain(char * szDomainName);
      BOOL UpdateAllEntries(void);


#ifdef DEBUG
    public :
      void DumpAll(void);
#endif


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\hashentr.h ===
////////////////////////////////////////////////////////////////////////////////////////////////
// FILE: hashentr.h
// PURPOSE: hash entry in the retry hash table
// HISTORY:
//  NimishK 05-14-98 Created
///////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __HASHENTR_H__
#define __HASHENTR_H__

#include <hshroute.h>

#define	MAX_RETRY_DOMAIN_NAME_LEN       (258 + ROUTE_HASH_PREFIX_SIZE)
#define RETRY_ENTRY_SIGNATURE_VALID		'reSV'
#define RETRY_ENTRY_SIGNATURE_FREE		'reSF'

typedef VOID (*CALLBACKFN)(PVOID pvContext);
#define INVALID_CALLBACK ((CALLBACKFN)(~0))

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_ENTRY:
//
// An entry in the retry hash table. We will also add the same entry into a queue
// ordered by retry time. A dedicated thread will walk the thread to retry domains
// if it is time.
// The hash key is the name of the domain
// Need to add CPool backed memory allocation
//
/////////////////////////////////////////////////////////////////////////////////

class CRETRY_HASH_ENTRY
{

    public:
    //One Cpool for all entries in all instances of the retry table
    static CPool       PoolForHashEntries;

    // override the mem functions to use CPool functions
    void *operator new (size_t cSize)
							    { return PoolForHashEntries.Alloc(); }
    void operator delete (void *pInstance)
							    { PoolForHashEntries.Free(pInstance); }

    protected:
        DWORD		m_Signature;
        LONG		m_RefCount;
        BOOL		m_InQ;
        BOOL		m_InTable;
        FILETIME	m_ftEntryInsertedTime;
        FILETIME	m_ftRetryTime;
        DWORD       m_cFailureCount;
        CALLBACKFN  m_pfnCallbackFn;
        PVOID       m_pvCallbackContext;
        char		m_szDomainName[MAX_RETRY_DOMAIN_NAME_LEN];

    public:
        LIST_ENTRY  m_QLEntry;  //List Entry for adding to RETRYQ
        LIST_ENTRY  m_HLEntry;  //List Entry for adding to BUCKET queue in HASH table

    CRETRY_HASH_ENTRY(char * szDomainName, DWORD cbDomainName,
                      DWORD dwScheduleID, GUID *pguidRouting,
                      FILETIME* InsertedTime)
    {
        m_Signature = RETRY_ENTRY_SIGNATURE_VALID;
        m_RefCount = 0;
        m_InQ = FALSE;
        m_InTable = FALSE;
        m_ftEntryInsertedTime = *InsertedTime;
        m_pvCallbackContext = NULL;
        m_pfnCallbackFn = NULL;

        //Our SMTP Stack will ensure that domain names that are over the RFC limit
        //are not used.
        _ASSERT(MAX_RETRY_DOMAIN_NAME_LEN >= dwGetSizeForRouteHash(cbDomainName));

        //Hash schedule ID and router guid to domain name
        CreateRouteHash(cbDomainName, szDomainName, ROUTE_HASH_SCHEDULE_ID,
                        pguidRouting, dwScheduleID, m_szDomainName);
#ifdef DEBUG
        m_hTranscriptHandle = INVALID_HANDLE_VALUE;
        m_szTranscriptFile[0] = '\0';
#endif

    }

    //Query list entries
    LIST_ENTRY & QueryHListEntry(void) {return ( m_HLEntry);}
    LIST_ENTRY & QueryQListEntry(void) {return ( m_QLEntry);}

    //Domain name used as HASH key
    void SetHashKey(char * SearchData) { lstrcpy(m_szDomainName,SearchData);}
    char * GetHashKey(void) { return m_szDomainName;}

    //Insert and RetryTimes
    void SetInsertTime(FILETIME* ftEntryInsertTime) { m_ftEntryInsertedTime = *ftEntryInsertTime;}
    void SetRetryReleaseTime(FILETIME* ftRetryTime) { m_ftRetryTime = *ftRetryTime;}
    FILETIME GetInsertTime(void){return m_ftEntryInsertedTime;}
    FILETIME GetRetryTime(void){return m_ftRetryTime;}
    DWORD GetFailureCount(void){return m_cFailureCount;}
    void  SetFailureCount(DWORD cFailureCount){m_cFailureCount = cFailureCount;}

    void SetInQ(void) { m_InQ = TRUE;}
    void ClearInQ(void) { m_InQ = FALSE;}
    BOOL GetInQ(void) { return m_InQ;}

    void SetInTable(void) { m_InTable = TRUE;}
    void ClearInTable(void) { m_InTable = FALSE;}
    BOOL GetInTable(void) { return m_InTable;}

    BOOL IsValid() { return(m_Signature == RETRY_ENTRY_SIGNATURE_VALID);}

    //Support for having non-domain based callback functions
    BOOL IsCallback() {return(NULL != m_pfnCallbackFn);};
    void ExecCallback()
    {
        _ASSERT(m_pfnCallbackFn);
        _ASSERT(INVALID_CALLBACK != m_pfnCallbackFn);
        //don't want to call twice, and don't want IsCallBack() to change
        m_pfnCallbackFn(m_pvCallbackContext);
        m_pfnCallbackFn = INVALID_CALLBACK;
    };
    void SetCallbackContext(CALLBACKFN pfnCallbackFn, PVOID pvCallbackContext)
    {
        _ASSERT(pfnCallbackFn);
        _ASSERT(INVALID_CALLBACK != pfnCallbackFn);
        m_pfnCallbackFn = pfnCallbackFn;
        m_pvCallbackContext = pvCallbackContext;
    };

    //Ref counting on the hash entry
    // Insertion into Hash table adds one and insertion into queue adds one
    LONG QueryRefCount(void){return m_RefCount;}
    LONG IncRefCount(void){return InterlockedIncrement(&m_RefCount);}
    void DecRefCount(void)
    {
        //
        if(InterlockedDecrement(&m_RefCount) == 0)
        {
            //we should not be in the retryQ if the ref
            //count is zero
            _ASSERT(m_InQ == FALSE);
            _ASSERT(m_InTable == FALSE);
            delete this;
        }
    }

    ~CRETRY_HASH_ENTRY()
    {
        m_Signature = RETRY_ENTRY_SIGNATURE_FREE;
        _ASSERT(m_InQ == FALSE);
        _ASSERT(m_InTable == FALSE);
#ifdef DEBUG
            //Close the transcript file
        if (INVALID_HANDLE_VALUE != m_hTranscriptHandle)
            _VERIFY(CloseHandle(m_hTranscriptHandle));
#endif
    }

#ifdef DEBUG
    public:
        HANDLE m_hTranscriptHandle;
        char   m_szTranscriptFile[MAX_PATH];
#endif


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\retrsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

#include "retrinc.h"
#include "hashentr.h"
#include "rhash.h"
#include "retryq.h"
#include "aqueue.h"
#include "aqintrnl.h"
#include "retrsink.h"
#include "hshroute.h"
#include "aqmem.h"

#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retrinc.h ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <rwnew.h>
#include "listmacr.h"
#include "timemath.h"

// Tracing and Cpool specific
#include <dbgtrace.h>
#include <cpool.h>

#define INOUT 
#define IN
#define OUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\main.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: main.cpp
//
//  Description: Main file for SMTP retry sink 
//
//  Author: NimishK
//
//  History:
//      7/15/99 - MikeSwa Moved to Platinum 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"

//constants
//
#define MAX_RETRY_OBJECTS 15000

#define DEFAULT_GLITCH_FAILURE_THRESHOLD 3
#define DEFAULT_FIRST_TIER_RETRY_THRESHOLD  6

#define DEFAULT_GLITCH_FAILURE_RETRY_SECONDS (1 * 60)  // retry a glitch intwo minutes
#define DEFAULT_FIRST_TIER_RETRY_SECONDS  (15 * 60)    // retry a failure in 15 minutes
#define DEFAULT_SECOND_TIER_RETRY_SECONDS  (60 * 60)   // retry a failure in 60 minutes

// provide memory for static declared in RETRYHASH_ENTRY
//
CPool CRETRY_HASH_ENTRY::PoolForHashEntries(RETRY_ENTRY_SIGNATURE_VALID);
DWORD CSMTP_RETRY_HANDLER::dwInstanceCount = 0;

//Forward declarations
//
BOOL ShouldHoldForRetry(DWORD dwConnectionStatus,
                        DWORD cFailedMsgCount,
                        DWORD cTriedMsgCount);

//Debugging related
//
#define LOGGING_DIRECTORY "c:\\temp\\"
enum DEBUGTYPE
{
    INSERT,
    UPDATE
};
#ifdef DEBUG
void WriteDebugInfo(CRETRY_HASH_ENTRY* pRHEntry,
                    DWORD DebugType,
                    DWORD dwConnectionStatus,
                    DWORD cTriedMessages,
                    DWORD cFailedMessages);
#endif

//--------------------------------------------------------------------------------
// Logic :
//      In a normal state every hashentry is added to a retry hash and
//      a retry queue strcture.
//      An entry is considered deleted when removed from both structures.
//      The deletion could happen in two ways depending on the sequence in
//      which the entry is removed from the two structres.
//      For eg : when an entry is to be released from retry, we start by
//      dequeing it from RETRYQ and then remove it from hash table.
//      On the other hand when we get successful ConnectionReleased( ) for
//      a domain that we are holding fro retry, we remove it from the hash
//      table first based on the name.
//      The following is the logic for deletion that has least contention and
//      guards against race conditions.
//      Every hash entry has normally two ref counts - one for hash table and
//      the other for the retry queue.
//      If a thread gets into ProcessEntry(), that means it dequed a
//      hash entry from RETRYQ. Obviously no other thread is going to
//      succeed in dequeing this same entry.
//      Some other thread could possibily remove it from the table, but
//      will not succeed in dequeing it from RETRYQ.
//      The deletion logic is that only the thread succeeding in dequing
//      the hash entry from RETRYQ frees it up.
//      The conflicting thread that removed the entry from hashtable via a
//      call to RemoveDomain() will fail on deque and simply carry on.
//      The thread that succeeded in dequeing may fail to remove it from hash
//      table becasue somebody has already removed it, but still goes ahead
//      and frees up the hash entry
//--------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::HrInitialize
//
//
//------------------------------------------------------------------------------
//
HRESULT CSMTP_RETRY_HANDLER::HrInitialize(IN IConnectionRetryManager *pIConnectionRetryManager)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::HrInitialize");
    //Decide if we need to copy over data from earlier sink

    _ASSERT(pIConnectionRetryManager != NULL);

    if(!pIConnectionRetryManager)
    {
        ErrorTrace((LPARAM)this, "Bad Init params");
        return E_FAIL;
    }

    m_pIRetryManager = pIConnectionRetryManager;
    m_ThreadsInRetry = 0;



    if(InterlockedIncrement((LONG*)&CSMTP_RETRY_HANDLER::dwInstanceCount) == 1)
    {
        //First instance to come in reserves the memory for the retry entries
        if (!CRETRY_HASH_ENTRY::PoolForHashEntries.ReserveMemory( MAX_RETRY_OBJECTS,
                                                            sizeof(CRETRY_HASH_ENTRY)))
        {
            DWORD err = GetLastError();
            ErrorTrace((LPARAM)NULL,
                "ReserveMemory failed for CRETRY_HASH_ENTRY. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
	            err = ERROR_NOT_ENOUGH_MEMORY;
            TraceFunctLeaveEx((LPARAM)NULL);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //Initialize Hash Table
    m_pRetryHash = new CRETRY_HASH_TABLE();

    if(!m_pRetryHash || !m_pRetryHash->IsHashTableValid())
    {
        ErrorTrace((LPARAM)this, "Failed to initialize the hash table ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return E_FAIL;
    }

    //Create the retry queue
    m_pRetryQueue = CRETRY_Q::CreateQueue();
    if(!m_pRetryQueue)
    {
        ErrorTrace((LPARAM)this, "Failed to initialize the retry queue ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return E_FAIL;
    }

    //create the Retry queue event. Others will set this event
    //when something is placed at the top of the queue or when
    //Sink needs to shutdown
    //
    m_RetryEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_RetryEvent == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //create the Shutdown event. The last of the ConnectionReleased
    //threads will set this event when the Shutting down flag is set.
    //
    m_ShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_ShutdownEvent == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //create the thread that processes things out of the
    //the queue
    DWORD ThreadId;
    m_ThreadHandle = CreateThread (NULL,
                                   0,
                                   CSMTP_RETRY_HANDLER::RetryThreadRoutine,
                                   this,
                                   0,
                                   &ThreadId);
    if (m_ThreadHandle == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //Initialize RetryQ
    return S_OK;
    TraceFunctLeaveEx((LPARAM)this);
}

//-------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::HrDeInitialize
//
//
//--------------------------------------------------------------------------------
HRESULT CSMTP_RETRY_HANDLER::HrDeInitialize(void)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::HrDeInitialize");

    //Set the flag that the Handler is shutting down
    SetShuttingDown();
    //Release the Retry thread by setting the retry event
    SetQueueEvent();
    //Wait for the thread to exit
    //NK** - right now this is infinite wait - but that needs to
    //change and we will have to comeout and keep giving hints
    WaitForQThread();

    //At this point we just need to wait for all the threads that are in there
    //to go out and we can then shutdown
    //Obviously ConnectionManager has to to stop sending threads this way
    //NK** - right now this is infinite wait - but that needs to
    //change and we will have to comeout and keep giving hints
    if(m_ThreadsInRetry)
	    WaitForShutdown();

    //Close the shutdown Event handle
    if(m_ShutdownEvent != NULL)
	    CloseHandle(m_ShutdownEvent);

    //Close the Retry Event handle
    if(m_RetryEvent != NULL)
	    CloseHandle(m_RetryEvent);

    //Close the Retry Thread handle
    if(m_ThreadHandle != NULL)
	    CloseHandle(m_ThreadHandle);

    //Once all threads are gone
    //we can deinit the hash table and the queue
    m_pRetryQueue->DeInitialize();
    m_pRetryHash->DeInitialize();

    //Release the shedule manager
    m_pIRetryManager->Release();

    if(InterlockedDecrement((LONG*)&CSMTP_RETRY_HANDLER::dwInstanceCount) == 0)
    {
        //finally, release all our memory
	    CRETRY_HASH_ENTRY::PoolForHashEntries.ReleaseMemory();
    }
	
    TraceFunctLeaveEx((LPARAM)this);
    delete this;
    return S_OK;
}


//---[ CSMTP_RETRY_HANDLER::ConnectionReleased ]-------------------------------
//
//
//  Description:
//      Default sink for ConnectionReleased event
//  Parameters:
//      - see aqintrnl.idl for a description of parameters
//  Returns:
//      S_OK on success
//  History:
//      9/24/98 - MikeSwa updated from original ConnectionReleased
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTP_RETRY_HANDLER::ConnectionReleased(
                           IN  DWORD cbDomainName,
                           IN  CHAR  szDomainName[],
                           IN  DWORD dwDomainInfoFlags,
                           IN  DWORD dwScheduleID,
                           IN  GUID  guidRouting,
                           IN  DWORD dwConnectionStatus,
                           IN  DWORD cFailedMessages,
                           IN  DWORD cTriedMessages,
                           IN  DWORD cConsecutiveConnectionFailures,
                           OUT BOOL* pfAllowImmediateRetry,
                           OUT FILETIME *pftNextRetryTime)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::ConnectionReleased");

    HRESULT hr;
    DWORD dwError;
    GUID guid = GUID_NULL;
    LPSTR szRouteHashedDomain = NULL;

    //Keep a track of threads that are inside
    //This will be needed in shutdown
    InterlockedIncrement(&m_ThreadsInRetry);

    //By default, we will allow the domain to retry
    _ASSERT(pfAllowImmediateRetry);
    *pfAllowImmediateRetry = TRUE;

    _ASSERT(pftNextRetryTime);

    if(TRUE)
    {
        // Check what we want to do
        // **If we need to disable the connection - disable it
        // **Check if there are any outstanding connections
        // If no connections, calculate the retry time and add in the queue and return
        if(ShouldHoldForRetry(dwConnectionStatus,
                              cFailedMessages,
                              cTriedMessages))
        {
            //Do not hold TURN/ETRN domains for retry (except for "glitch" retry)
            if((!(dwDomainInfoFlags & (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))) ||
               (cConsecutiveConnectionFailures < m_dwRetryThreshold))
            {
                //Insert it - we could fail to insert it if an entry already exists
                //That is OK - we will return success
                if(!InsertDomain(szDomainName,
                                 cbDomainName,
                                 dwConnectionStatus,
                                 dwScheduleID,
                                 &guidRouting,
                                 cConsecutiveConnectionFailures,
                                 cTriedMessages,
                                 cFailedMessages, pftNextRetryTime ))
                {
                    dwError = GetLastError();
                    DebugTrace((LPARAM)this,
                        "Failed to insert %s entry into retry hash table : Err : %d ",
			            szDomainName, dwError);

                    if(dwError == ERROR_FILE_EXISTS )
                    {
	                    //We did not insert because the entry was already there
                        *pfAllowImmediateRetry = FALSE;
	                    hr = S_OK;
	                    goto Exit;
                    }
                    else
                    {
                        if(dwError == ERROR_NOT_ENOUGH_MEMORY )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _ASSERT(0);
                            hr = E_FAIL;
                        }
                        goto Exit;
                    }
                }
                //Normal retry domain
                *pfAllowImmediateRetry = FALSE;
                DebugTrace((LPARAM)this,
                    "Holding domain %s for retry",szDomainName);
            }
        }
        else
        {
            // Some connection succeeded for this domain.
            //If we have it marked for retry - it needs to be freed up
            //Looks like the incident which caused retry has cleared up.
            CHAR szHashedDomain[MAX_RETRY_DOMAIN_NAME_LEN];

            //SMTP Protocol should guarantee enough space.
            _ASSERT(MAX_RETRY_DOMAIN_NAME_LEN >= dwGetSizeForRouteHash(cbDomainName));

            //Hash schedule ID and router guid to domain name
            CreateRouteHash(cbDomainName, szDomainName, ROUTE_HASH_SCHEDULE_ID,
                            &guidRouting, dwScheduleID, szHashedDomain);

            RemoveDomain(szHashedDomain);
            hr = S_OK;
            goto Exit;
        }
    }
    hr = S_OK;

Exit :

    //Keep a track of threads that are inside
    //This will be needed in shutdown
    if(InterlockedDecrement(&m_ThreadsInRetry) == 0 && IsShuttingDown())
    {
        //we signal the shutdown event to indicate that
        //no more threads are in the system
        _ASSERT(m_ShutdownEvent != NULL);
        SetEvent(m_ShutdownEvent);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
// CSMTP_RETRY_HANDLER::InsertDomain
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL CSMTP_RETRY_HANDLER::InsertDomain(char * szDomainName,
                                       IN  DWORD cbDomainName,
                                       IN  DWORD dwConnectionStatus,		//eConnectionStatus
                                       IN  DWORD dwScheduleID,
                                       IN  GUID  *pguidRouting,
                                       IN  DWORD cConnectionFailureCount,
                                       IN  DWORD cTriedMessages, 	//# of untried messages in queue
									   IN  DWORD cFailedMessages,		//# of failed message for *this* connection
									   OUT FILETIME *pftNextRetry)
{
    DWORD dwError;
    FILETIME TimeNow;
    FILETIME RetryTime;
    CRETRY_HASH_ENTRY* pRHEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::InsertDomain");

    //Get the insertion time for the entry
    GetSystemTimeAsFileTime(&TimeNow);

    //Cpool based allocations for hash entries
    pRHEntry = new CRETRY_HASH_ENTRY (szDomainName, cbDomainName,
                                dwScheduleID, pguidRouting, &TimeNow);

    if(!pRHEntry)
    {
        //_ASSERT(0);
        dwError = GetLastError();
        DebugTrace((LPARAM)this,
                    "failed to Create a new hash entry : %s err: %d",
					szDomainName,
					dwError);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //Based on the current time and the number of connections failures calculate the
    //time of release for retry
    RetryTime = CalculateRetryTime(cConnectionFailureCount, &TimeNow);
    pRHEntry->SetRetryReleaseTime(&RetryTime);
    pRHEntry->SetFailureCount(cConnectionFailureCount);

    //The hash entry has been initialized
    //Insert it - we could fail to insert it if an entry already exists
    //That is OK - we will return success
    if(!m_pRetryHash->InsertIntoTable (pRHEntry))
    {
        //Free up the entry
        _ASSERT(pRHEntry);
        delete pRHEntry;
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }
    else
    {
        //Report next retry time
        if (pftNextRetry)
            memcpy(pftNextRetry, &RetryTime, sizeof(FILETIME));

        //Insert into the retry queue.
        BOOL fTopOfQueue = FALSE;
        //Lock the queue
        m_pRetryQueue->LockQ();
        m_pRetryQueue->InsertSortedIntoQueue(pRHEntry, &fTopOfQueue);

#ifdef DEBUG
        //Add ref count for logging before releasing the lock
        //Do rtacing afterwards so as to reduce lock time
        pRHEntry->IncRefCount();
#endif
        m_pRetryQueue->UnLockQ();
        //If the insertion was at the top of the queue
        //wake up the retry thread to evaluate the new
        //sleep time
        if(fTopOfQueue)
        {
	        SetEvent(m_RetryEvent);
        }

#ifdef DEBUG
        //Write out the insert and release time to a file
        //
        WriteDebugInfo(pRHEntry,
                       INSERT,
                       dwConnectionStatus,
                       cTriedMessages,
					   cFailedMessages);
        //Decrement the ref count obtained for the tracing
        pRHEntry->DecRefCount();
#endif

    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

//---------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::RemoveDomain
//
//
//---------------------------------------------------------------------------------
//
BOOL CSMTP_RETRY_HANDLER::RemoveDomain(char * szDomainName)
{
    PRETRY_HASH_ENTRY pRHEntry;

    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::RemoveDomain");

    if(!m_pRetryHash->RemoveFromTable(szDomainName, &pRHEntry))
    {
        if(GetLastError() == ERROR_PATH_NOT_FOUND)
            return TRUE;
        else
        {
            _ASSERT(0);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }


    _ASSERT(pRHEntry != NULL);

    //Remove it from the queue
    m_pRetryQueue->LockQ();
    if(!m_pRetryQueue->RemoveFromQueue(pRHEntry))
    {
        m_pRetryQueue->UnLockQ();
        if(GetLastError() == ERROR_PATH_NOT_FOUND)
            return TRUE;
        else
        {
            _ASSERT(0);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }
    m_pRetryQueue->UnLockQ();

    //If successful in removing from the queue then we are not competing with
    //the Retry thread
    //decrement hash table ref count as well as the ref count for the queue
    pRHEntry->DecRefCount();
    pRHEntry->DecRefCount();

    //Release this entry by setting the right flags
    //This should always succeed
    DebugTrace((LPARAM)this,
            "Releasing domain %s because another connection succeeded", szDomainName);
    if(!ReleaseForRetry(szDomainName))
    {
        ErrorTrace((LPARAM)this, "Failed to release the entry");
        TraceFunctLeaveEx((LPARAM)this);
        //_ASSERT(0);
    }
    return TRUE;
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::CalculateRetryTime
//
// Logic to decide based on the number of failed connection how long to hld this
// domain for retry
//
//---------------------------------------------------------------------------------
FILETIME CSMTP_RETRY_HANDLER::CalculateRetryTime(DWORD cFailedConnections,
												 FILETIME* InsertedTime)
{
    FILETIME ftTemp;
    LONGLONG Temptime;
    DWORD dwRetryMilliSec = 0;

    //Does this look like a glitch
    //A glitch is defined as less than x consecutive failures
    if(cFailedConnections < m_dwRetryThreshold)
        dwRetryMilliSec = m_dwGlitchRetrySeconds * 1000;
    else
    {
        switch(cFailedConnections - m_dwRetryThreshold)
        {
        case 0: dwRetryMilliSec = m_dwFirstRetrySeconds  * 1000;
            break;

        case 1: dwRetryMilliSec = m_dwSecondRetrySeconds * 1000;
            break;

        case 2: dwRetryMilliSec = m_dwThirdRetrySeconds  * 1000;
            break;

        case 3: dwRetryMilliSec = m_dwFourthRetrySeconds  * 1000;
            break;

        default: dwRetryMilliSec = m_dwFourthRetrySeconds  * 1000;
            break;
        }
    }

    _ASSERT(dwRetryMilliSec);

    Temptime = INT64_FROM_FILETIME(*InsertedTime) + HnsFromMs((__int64)dwRetryMilliSec);
    // HnsFromMin(m_RetryMinutes)
    ftTemp = FILETIME_FROM_INT64(Temptime);

    return ftTemp;
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::ProcessEntry
//
// Description :
//      Process the hash entry removed from the queue because it is
//      time to release the corresponding domain.
//      We mark the domain active for retry and then take the hash
//      entry out of the hash table and delete the hash entry.
//
//---------------------------------------------------------------------------------

void CSMTP_RETRY_HANDLER::ProcessEntry(PRETRY_HASH_ENTRY pRHEntry)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::ProcessEntry");

    PRETRY_HASH_ENTRY pTempEntry;

    _ASSERT(pRHEntry != NULL);

    if (pRHEntry->IsCallback())
    {
        //call callback function
        pRHEntry->ExecCallback();
    }
    else
    {
        //Check to see if this is
        //Release this entry by setting the right flags
        //This shoudl alway suceed
        DebugTrace((LPARAM)this,
	        "Releasing domain %s for retry", pRHEntry->GetHashKey());
        if(!ReleaseForRetry(pRHEntry->GetHashKey()))
        {
            ErrorTrace((LPARAM)this,
                "Failed to release the entry %s", pRHEntry->GetHashKey());
            // _ASSERT(0);
        }

        //Remove the entry from the hash table
        if(!m_pRetryHash->RemoveFromTable(pRHEntry->GetHashKey(), &pTempEntry))
        {
		    _ASSERT(GetLastError() == ERROR_PATH_NOT_FOUND);
        }

        //Irrespective of fail or success while removing the hash entry,
        //we decrement the refcount for both the hash table
        pRHEntry->DecRefCount();
    }

    pRHEntry->DecRefCount();
    TraceFunctLeaveEx((LPARAM)this);
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::UpdateAllEntries
//
// Whenever the config data changes we update the release time for the queues
// based on it.
//
//
//---------------------------------------------------------------------------------
//
BOOL CSMTP_RETRY_HANDLER::UpdateAllEntries(void)
{
    CRETRY_HASH_ENTRY * pHashEntry = NULL;
    CRETRY_Q * pTempRetryQueue = NULL;
    FILETIME ftInsertTime, ftRetryTime;
    DWORD cConnectionFailureCount = 0;
    BOOL fTopOfQueue;
    BOOL fInserted = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::UpdateAllEntries");

    //Create the temporary retry queue
    pTempRetryQueue = CRETRY_Q::CreateQueue();
    if(!pTempRetryQueue)
    {
        ErrorTrace((LPARAM)this,
            "Failed to initialize the temp retry queue ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    m_pRetryQueue->LockQ();

    //Create a new queue and load everything into it
    while(1)
    {
        //Get the  top entry from first queue
        //Do not release the ref count on it - we need the entry to be around
        //so as to reinsert it at the right place in the updated queue
        pHashEntry = m_pRetryQueue->RemoveFromTop();

        //If we get hash entry
        if(pHashEntry)
        {
            if (!pHashEntry->IsCallback()) //don't update times of callbacks
            {
                ftInsertTime = pHashEntry->GetInsertTime();
                cConnectionFailureCount = pHashEntry->GetFailureCount();

                ftRetryTime = CalculateRetryTime(cConnectionFailureCount, &ftInsertTime);
                pHashEntry->SetRetryReleaseTime(&ftRetryTime);
#ifdef DEBUG
                WriteDebugInfo(pHashEntry,UPDATE,0,0,0);
#endif
            }

            //Insert the entry into the new queue using the new Release time
            //This will bump up the ref count.
            pTempRetryQueue->InsertSortedIntoQueue(pHashEntry, &fTopOfQueue);

            //Decrement the ref count to correspond to remove from Old queue now
            pHashEntry->DecRefCount();

            fInserted = TRUE;

        }
        else
            break;
    }

    //Update the old queue head with the Flink/Blink ptrs from the new queue
    if(fInserted)
    {
        m_pRetryQueue->StealQueueEntries(pTempRetryQueue);
    }

    pTempRetryQueue->DeInitialize();
    m_pRetryQueue->UnLockQ();
    SetEvent(m_RetryEvent);
    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

//--------------------------------------------------------------------------------------
//
//
//	Name :
//		CSMTP_RETRY_HANDLER::RetryThreadRoutine
//
//  Description:
//	   This function is the static member
//	   function that gets passed to CreateThread
//	   during the initialization. It is the main
//     thread that does the work of releasing the
//	   domain that are being held for retry.
//
//  Arguments:
//		A pointer to a RETRYQ
//
//  Returns:
//--------------------------------------------------------------------------------------
//
DWORD WINAPI CSMTP_RETRY_HANDLER::RetryThreadRoutine(void * ThisPtr)
{
    CSMTP_RETRY_HANDLER* RetryHandler =   (CSMTP_RETRY_HANDLER*)ThisPtr;
    CRETRY_Q* QueuePtr = (CRETRY_Q*) RetryHandler->GetQueuePtr();
    PRETRY_HASH_ENTRY pRHEntry;
    DWORD				dwDelay;    //Delay in seconds to sleep for
//  HANDLE WaitTable[2];
//  HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)QueuePtr, "CSMTP_RETRY_HANDLER::RetryThreadRoutine");


    //This thread will permanently loop on the retry queue.
    //If we find something at the top of the queue that can be retried, it gets
    //
    while(TRUE)
    {
        //if we are shutting down, break out of the loop
        if (RetryHandler->IsShuttingDown())
        {
            goto Out;
        }

        //if we find the top entry to be ready for a retry
        //we remove it from the queue and do the needful
        //
        if( QueuePtr->CanRETRYHeadEntry(&pRHEntry, &dwDelay))
        {
            //We got an entry to process
            //Processing should be simply enabling a link
            if(pRHEntry)
            {
                RetryHandler->ProcessEntry(pRHEntry);
            }
            else
            {
                DebugTrace((LPARAM)QueuePtr,
				            "Error getting a domain entry off the retry queue");
            }
        }
        else
        {
            DebugTrace((LPARAM)QueuePtr,"Sleeping for %d seconds", dwDelay);
            //Goto Sleep
            WaitForSingleObject(RetryHandler->m_RetryEvent,dwDelay);
        }
    } //end while

Out:

    DebugTrace((LPARAM)QueuePtr,"Queue thread exiting");
    TraceFunctLeaveEx((LPARAM)QueuePtr);
    return 1;
}

//--------------------------------------------------------------------------------------
//
// Logic to decide based on the failure condition if the connection needs to be
// disabled and added to retry queue
// If we fail we hold it for retry
// Otherwise if we tried more than one messages and every one of them failed we
// hold for retry
// In all other cases we keep the link active
//
//      2/5/99 - MikeSwa Modified to kick all non-success acks into retry
//--------------------------------------------------------------------------------------
BOOL ShouldHoldForRetry(DWORD dwConnectionStatus,
                        DWORD cFailedMsgCount,
                        DWORD cTriedMsgCount)
{

    //If connection failed or all messages on this connection failed TRUE
    if(dwConnectionStatus != CONNECTION_STATUS_OK)
    {
        return TRUE;
    }
    else if( cTriedMsgCount > 0 && !(cTriedMsgCount - cFailedMsgCount))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

//---[ CSMTP_RETRY_HANDLER::SetCallbackTime ]----------------------------------
//
//
//  Description:
//      Puts an entry in the retry queue to provide a callback at a specified
//      later time.
//  Parameters:
//      IN pCallbackFn             Pointer to retry function
//      IN pvContext            Context passed to retry function
//      IN dwCallbackMinutes    Minutes to wait before calling back
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if a hash entry cannot be allocated
//      E_INVALIDARG of pCallbackFn is NULL
//  History:
//      8/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CSMTP_RETRY_HANDLER::SetCallbackTime(
                        IN RETRFN    pCallbackFn,
                        IN PVOID     pvContext,
                        IN DWORD    dwCallbackMinutes)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTP_RETRY_HANDLER::SetCallbackTime");
    HRESULT hr = S_OK;
    CRETRY_HASH_ENTRY* pRHEntry = NULL;
    BOOL fTopOfQueue = FALSE;
    FILETIME TimeNow;
    FILETIME RetryTime;
    LONGLONG Temptime;
    GUID     guidFakeRoutingGUID = GUID_NULL;

    //$$REVIEW
    //This (and all other occurences of this in retrsink) is not really thread
    //safe... but since the code calling the retrsink *is* thread safe,
    //this is not too much of a problem. Still, this should get fixed for M3
    //though - MikeSwa 8/17/98
    InterlockedIncrement(&m_ThreadsInRetry);

    if (!pCallbackFn)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Get the insertion time for the entry
    GetSystemTimeAsFileTime(&TimeNow);

    pRHEntry = new CRETRY_HASH_ENTRY (CALLBACK_DOMAIN,
                                      sizeof(CALLBACK_DOMAIN),
                                      0,
                                      &guidFakeRoutingGUID,
                                      &TimeNow);
    if (!pRHEntry)
    {
        ErrorTrace((LPARAM) this, "ERROR: Unable to allocate retry hash entry");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //Calculate retry time
    Temptime = INT64_FROM_FILETIME(TimeNow) + HnsFromMs((__int64)dwCallbackMinutes*60*1000);
    RetryTime = FILETIME_FROM_INT64(Temptime);

    //set callback time
    pRHEntry->SetRetryReleaseTime(&RetryTime);
    pRHEntry->SetCallbackContext(pCallbackFn, pvContext);

    //Lock the queue
    m_pRetryQueue->LockQ();
    m_pRetryQueue->InsertSortedIntoQueue(pRHEntry, &fTopOfQueue);

#ifdef DEBUG

    //Add ref count for logging before releasing the lock
    //Do rtacing afterwards so as to reduce lock time
    pRHEntry->IncRefCount();

#endif //DEBUG

    m_pRetryQueue->UnLockQ();
    //If the insertion was at the top of the queue
    //wake up the retry thread to evaluate the new
    //sleep time
    if(fTopOfQueue)
    {
        SetEvent(m_RetryEvent);
    }

#ifdef DEBUG
    //Write out the insert and release time to a file
    WriteDebugInfo(pRHEntry, INSERT, 0xFFFFFFFF, 0,0);

    //Decrement the ref count obtained for the tracing
    pRHEntry->DecRefCount();

#endif //DEBUG

  Exit:
    InterlockedDecrement(&m_ThreadsInRetry);
    TraceFunctLeave();
    return hr;
}

//---[ ReleaseForRetry ]-------------------------------------------------------
//
//
//  Description:
//      Releases given domain for retry by setting link state flags
//  Parameters:
//      IN  szHashedDomainName      Route-hashed domain name to release
//  Returns:
//      TRUE on success
//      FALSE on failure
//  History:
//      9/25/98 - MikeSwa Created (adapted from inline function)
//
//-----------------------------------------------------------------------------
BOOL CSMTP_RETRY_HANDLER::ReleaseForRetry(IN char * szHashedDomainName)
{
    _ASSERT(szHashedDomainName);
    HRESULT hr = S_OK;
    DWORD dwScheduleID = dwGetIDFromRouteHash(szHashedDomainName);
    GUID  guidRouting = GUID_NULL;
    LPSTR szUnHashedDomain = szGetDomainFromRouteHash(szHashedDomainName);

    GetGUIDFromRouteHash(szHashedDomainName, &guidRouting);

    hr = m_pIRetryManager->RetryLink(lstrlen(szUnHashedDomain),
                szUnHashedDomain, dwScheduleID, guidRouting);

    return (SUCCEEDED(hr));
}


//--------------------------------------------------------------------------------------
//
// Debugging functions
//
//
//--------------------------------------------------------------------------------------
#ifdef DEBUG

void CSMTP_RETRY_HANDLER::DumpAll(void)
{
	m_pRetryQueue->PrintAllEntries();
}

void WriteDebugInfo(CRETRY_HASH_ENTRY* pRHEntry,
                    DWORD DebugType,
                    DWORD dwConnectionStatus,
                    DWORD cTriedMessages,
                    DWORD cFailedMessages)
{
    //open a transcript file and put the insert and release times in it
    //
    SYSTEMTIME stRetryTime, stInsertTime, stLocalInsertTime, stLocalRetryTime;
    char szScratch[MAX_PATH];
    char sztmp[20];
    DWORD cbWritten;
    TIME_ZONE_INFORMATION tz;

    FileTimeToSystemTime(&pRHEntry->GetRetryTime(), &stRetryTime);
    FileTimeToSystemTime(&pRHEntry->GetInsertTime(), &stInsertTime);

    GetTimeZoneInformation(&tz);
    SystemTimeToTzSpecificLocalTime(&tz, &stInsertTime, &stLocalInsertTime);
    SystemTimeToTzSpecificLocalTime(&tz, &stRetryTime, &stLocalRetryTime);

    if(DebugType == INSERT)
    {
        lstrcpy(pRHEntry->m_szTranscriptFile, LOGGING_DIRECTORY);

        //Get rid of annoying routing information
        if (lstrcmp(pRHEntry->GetHashKey(), CALLBACK_DOMAIN))
        {
            lstrcat(pRHEntry->m_szTranscriptFile,
                szGetDomainFromRouteHash(pRHEntry->GetHashKey()));

            //Add some unique information
            sprintf(sztmp, ".%p", pRHEntry);
            lstrcat(pRHEntry->m_szTranscriptFile, sztmp);
        }
        else
        {
            //callback function
            lstrcat(pRHEntry->m_szTranscriptFile, pRHEntry->GetHashKey());
        }

        lstrcat(pRHEntry->m_szTranscriptFile, ".rtr");

        pRHEntry->m_hTranscriptHandle = INVALID_HANDLE_VALUE;
        pRHEntry->m_hTranscriptHandle = CreateFile(pRHEntry->m_szTranscriptFile,
                                                   GENERIC_READ | GENERIC_WRITE,
                                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                   NULL,
                                                   OPEN_ALWAYS,
                                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                   NULL);

        switch(dwConnectionStatus)
        {
        case 0: lstrcpy( sztmp, "OK");
            break;
        case 1: lstrcpy( sztmp, "FAILED");
            break;
        case 2: lstrcpy( sztmp, "DROPPED");
            break;
        default:lstrcpy( sztmp, "UNKNOWN");
            break;
        }

        sprintf(szScratch,"InsertTime:%d:%d:%d Retrytime:%d:%d:%d\nConnection status:%s Consecutive failures:%d\nMessages Tried:%d Failed:%d\n\n",
                                        stLocalInsertTime.wHour, stLocalInsertTime.
                                        wMinute,stLocalInsertTime.wSecond,
                                        stLocalRetryTime.wHour, stLocalRetryTime.wMinute,
                                        stLocalRetryTime.wSecond,
                                        sztmp,
                                        pRHEntry->GetFailureCount(),
                                        cTriedMessages,
                                        cFailedMessages);

        if( pRHEntry->m_hTranscriptHandle != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(pRHEntry->m_hTranscriptHandle,
                           0,
                           NULL,
                           FILE_END);
            ::WriteFile(pRHEntry->m_hTranscriptHandle,
                        szScratch,
                        strlen(szScratch),
                        &cbWritten,
                        NULL);
        }
    }
    else if (DebugType == UPDATE)
    {
        sprintf(szScratch,"Updated : InsertedTime:%d:%d:%d Retrytime:%d:%d:%d\n\n",
                            stLocalInsertTime.wHour, stLocalInsertTime.wMinute,
                            stLocalInsertTime.wSecond,
                            stLocalRetryTime.wHour, stLocalRetryTime.wMinute,
                            stLocalRetryTime.wSecond);

        if( pRHEntry->m_hTranscriptHandle != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(pRHEntry->m_hTranscriptHandle,
                           0,
                           NULL,
                           FILE_END);
            ::WriteFile(pRHEntry->m_hTranscriptHandle,
                        szScratch,
                        strlen(szScratch),
                        &cbWritten,
                        NULL);
        }
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retryq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        retrq.cxx

   Abstract:
		Implements the Retry queue

   Author:

           Nimish Khanolkar    ( NimishK )    11-Dec-1995

   Project:

          CRETRY_Q sink

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "precomp.h"

//////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::InitializeQueue
//
//  Description:
//	   This function initializes the class
//
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CRETRY_Q::Initialize(void)
{

	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::InitializeQueue");

	//Init the heaad of the queue
	InitializeListHead(&m_QHead);

	//Init or critical section.  This protects the queue and the hash table
	InitializeCriticalSection(&m_CritSec);
	m_fCritSecInit = TRUE;
  
	TraceFunctLeaveEx((LPARAM)this);
	return S_OK;
}
 
//////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::CreateQueue
//
//  Description:
//	   This is the static member function that creates the Queue
//
//
////////////////////////////////////////////////////////////////////////////////

CRETRY_Q * CRETRY_Q::CreateQueue()
{
	HRESULT hr;

    CRETRY_Q * pRQueue = NULL;
	
	pRQueue = new CRETRY_Q();

    if(!pRQueue)
    {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
    }

	//initialize the queue
	hr = pRQueue->Initialize();
	if(FAILED(hr))
	{
		delete pRQueue;
		pRQueue = NULL;
	}
	return pRQueue;
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::DeInitialize
//
// Very Basic.
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT CRETRY_Q::DeInitialize(void)
{
    PLIST_ENTRY  plEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    //Release all the objects in the queue
    //      10/1/98 - MikeSwa
    while(!IsListEmpty(&m_QHead))
    {
        plEntry = RemoveHeadList (&m_QHead);
        pHashEntry = CONTAINING_RECORD(plEntry, CRETRY_HASH_ENTRY, m_QLEntry);
        pHashEntry->ClearInQ();

        //Execute callback on shutdown, so caller can free memory
        if (pHashEntry->IsCallback())
            pHashEntry->ExecCallback();

        pHashEntry->DecRefCount();
    }

    if (m_fCritSecInit)
        DeleteCriticalSection(&m_CritSec);

	delete this;
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::InsertSortedIntoQueue
//
//  Description:
//	   It takes the list entry for the new RETRY_HASH_ENTRY 
//	   and adds it in the right order based on the Retry time 
//	   for that entry.
//     UnLocked operation. The caller has to have the lock
//
//  Arguments:
//
//   Returns:
//
///////////////////////////////////////////////////////////////////////

void CRETRY_Q::InsertSortedIntoQueue(PRETRY_HASH_ENTRY pHashEntry, 
									 BOOL *fTopOfQueue )
{
	PLIST_ENTRY  pCurrentListEntry;
	FILETIME	 CurrentRetryTime;
	FILETIME	 NewRetryTime;
	PRETRY_HASH_ENTRY pCurrentHashEntry;
	
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::InsertSortedEntry");

	*fTopOfQueue = FALSE;
	
	//Initialize
	pCurrentListEntry = &m_QHead;

	//Look at the next entry to see if we are not at the end of the queue
	while(pCurrentListEntry->Flink != &m_QHead)
	{
		//Get the object pointed by the next entry
		pCurrentHashEntry = CONTAINING_RECORD( pCurrentListEntry->Flink, 
											CRETRY_HASH_ENTRY, m_QLEntry);
		CurrentRetryTime = pCurrentHashEntry->GetRetryTime();
		NewRetryTime = pHashEntry->GetRetryTime();

		//If the new entry has more delay we continue finding a place for it
		if(CompareFileTime (&CurrentRetryTime, &NewRetryTime) == -1) 
		{
			pCurrentListEntry = pCurrentListEntry->Flink;
			continue;
		}
		else 
		{	//We found the place
			break;
		}
	}

	//insert before the next entry
	InsertHeadList(pCurrentListEntry, &pHashEntry->QueryQListEntry());
	//set inQ flag
	pHashEntry->SetInQ();
	pHashEntry->IncRefCount();
	if(m_QHead.Flink == &pHashEntry->QueryQListEntry())
		*fTopOfQueue = TRUE;

	TraceFunctLeaveEx((LPARAM)this);
	return;
}

/////////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::CanRETRYHeadEntry
//
//		We look at the entry at the top of the queue
//		If it is something that we can retry right now, we remove it from the 
//		queue and return it to the caller
//
///////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_Q::CanRETRYHeadEntry(PRETRY_HASH_ENTRY* ppRHEntry, 
													DWORD* pdwDelay)
{
	FILETIME        TimeNow;        //the time now
	FILETIME		RetryTime;      //time connection should be retried
		
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::CanPopHead");

	//get the current time
	GetSystemTimeAsFileTime(&TimeNow);

	//Lock the queue
	LockQ();

	_ASSERT(m_QHead.Flink);

	//Look at the next entry to see if we are not at the end of the queue
	if(m_QHead.Flink != &m_QHead)
	{
		//Get the object pointed by the next entry
		*ppRHEntry = CONTAINING_RECORD( m_QHead.Flink, CRETRY_HASH_ENTRY, m_QLEntry);
		RetryTime = (*ppRHEntry)->GetRetryTime();

		//If the Current time is less than the retry time
		// and the time difference is greater than 1 sec then go back to waiting
		//else remove the entry
		if( (CompareFileTime (&TimeNow, &RetryTime) == -1) && 
					(*pdwDelay = ((DWORD)SecFromFtSpan(TimeNow, RetryTime) * 1000)))
		{
			//We cannnot POP this entry as it is not yet release
			_ASSERT(*pdwDelay > 0);

			*ppRHEntry = NULL;
			//Unlock the queue
			UnLockQ();
			TraceFunctLeaveEx((LPARAM)this);
			return FALSE;
		} //end of while
		else
		{
			//We can pop this entry from our retry queue
			RemoveEntryList(m_QHead.Flink);
			(*ppRHEntry)->ClearInQ();
			*pdwDelay = 0;
			//Unlock the queue
			UnLockQ();
			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}
	else
	{
		//Unlock the queue
		UnLockQ();
		//There is no entry in the queue so go to sleep indefintely.
		*ppRHEntry = NULL;
		//get the delay to sleep
		*pdwDelay = INFINITE;
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
//    CRETRY_Q::RemoveFromQueue(PLISTENTRY	pEntry)
//
//		This function removes an entry into the queue
//    
//	Arguments:
//
//			none
//
/////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_Q::RemoveFromQueue(PRETRY_HASH_ENTRY pRHEntry)
{
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::RemoveFromQueue");

    _ASSERT( pRHEntry != NULL);

	if(pRHEntry == NULL || &pRHEntry->QueryQListEntry() == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

    // Remove 
	if(pRHEntry->GetInQ())
	{
	    RemoveEntryList( &pRHEntry->QueryQListEntry());
		pRHEntry->ClearInQ();
		TraceFunctLeaveEx((LPARAM)this);
		return TRUE;
	}
	else
	{
		SetLastError(ERROR_PATH_NOT_FOUND);
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
//    CRETRY_Q::RemoveFromTop()
//
//		This function removes an entry into the queue
//    
//	Arguments:
//
//			none
//
/////////////////////////////////////////////////////////////////////////////////
//
PRETRY_HASH_ENTRY CRETRY_Q::RemoveFromTop(void)
{

    PLIST_ENTRY  plEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

     //get the first item off the queue
    if(!IsListEmpty(&m_QHead))
    {
        plEntry = RemoveHeadList (&m_QHead);
        pHashEntry = CONTAINING_RECORD(plEntry, CRETRY_HASH_ENTRY, m_QLEntry);
    }

    return pHashEntry;

}



/////////////////////////////////////////////////////////////////////////////////
// CRETRY_Q::PrintAllEntries
//
//		Walks the retry queue and Prints all the domains and the times
//
/////////////////////////////////////////////////////////////////////////////////
//
void CRETRY_Q::PrintAllEntries(void)
{
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	PLIST_ENTRY  pentryNext = NULL;
	CRETRY_HASH_ENTRY * pHashEntry = NULL;
	FILETIME ftTime;
	SYSTEMTIME stTime;
	char szRetryTime[20];
	char szInsertedTime[20];

	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::PrintAllEntries");

	LockQ();
	HeadOfList = &m_QHead;
	pEntry = m_QHead.Flink;
	for(; pEntry != HeadOfList; pEntry = pentryNext)
	{
		pentryNext = pEntry->Flink;
		pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_QLEntry);
		
		ftTime = pHashEntry->GetRetryTime();
		FileTimeToSystemTime(&ftTime, &stTime);
		sprintf(szRetryTime, "%d:%d:%d",stTime.wHour,stTime.wMinute, stTime.wSecond); 
		ftTime = pHashEntry->GetInsertTime();
		FileTimeToSystemTime(&ftTime, &stTime);
		sprintf(szInsertedTime, "%d:%d:%d",stTime.wHour,stTime.wMinute, stTime.wSecond); 

		DebugTrace((LPARAM)this,"Domain: %s RTime: %s, ITime: %s", 
					pHashEntry->GetHashKey(),szRetryTime, szInsertedTime);
	}
	UnLockQ();
	TraceFunctLeaveEx((LPARAM)this);
}

//---[ CRETRY_Q::StealQueueEntries ]-------------------------------------------
//
//
//  Description: 
//      Used to swap entries with tmp queue during config update.
//  Parameters:
//      pRetryQueue     Queue to swap entries with.
//  Returns:
//      -
//  History:
//      10/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CRETRY_Q::StealQueueEntries(CRETRY_Q *pRetryQueue)
{
    _ASSERT(IsListEmpty(&m_QHead));

    //Update our head
    if (!IsListEmpty(&(pRetryQueue->m_QHead)))
    {
        m_QHead.Flink = pRetryQueue->m_QHead.Flink;
        m_QHead.Flink->Blink = &m_QHead;
        m_QHead.Blink = pRetryQueue->m_QHead.Blink;
        m_QHead.Blink->Flink = &m_QHead;
    }

    //Now mark other queue as empty
    InitializeListHead(&(pRetryQueue->m_QHead));
}

/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retryq.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       queue.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    01-05-96   NimishK   Created
//
//----------------------------------------------------------------------------

#ifndef __QUEUE_H__
#define __QUEUE_H__

//
// A SORTED_QUEUE is a 

#define PRETRY_HASH_ENTRY CRETRY_HASH_ENTRY*

class CRETRY_HASH_ENTRY;

class CRETRY_Q 
{
	 private :

		LIST_ENTRY           		m_QHead;          	// List pointers
		CRITICAL_SECTION			m_CritSec;   		// Guard
		BOOL						m_fCritSecInit;     // Has init been called

	 public:

		CRETRY_Q () //initialize stuff that can't fail
		{
			TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::CRETRY_Q");
			m_fCritSecInit = FALSE;
			TraceFunctLeaveEx((LPARAM)this);
		}

		~CRETRY_Q ()
		{
			TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::~CRETRY_Q");
			TraceFunctLeaveEx((LPARAM)this);
		}

		HRESULT Initialize(void);
		HRESULT DeInitialize(void);
 		static CRETRY_Q * CreateQueue(void);

	public :
		//for controlling the retry queue
		void LockQ () {EnterCriticalSection (&m_CritSec);}
		void UnLockQ() {LeaveCriticalSection (&m_CritSec);}
        LIST_ENTRY* GetQHead(){return &m_QHead;}


		void PrintAllEntries(void);

		void InsertSortedIntoQueue(PRETRY_HASH_ENTRY pHashEntry, BOOL *fTopOfQueue);
		BOOL RemoveFromQueue(PRETRY_HASH_ENTRY pRHEntry);
        PRETRY_HASH_ENTRY RemoveFromTop(void);

		BOOL CanRETRYHeadEntry(PRETRY_HASH_ENTRY *ppRHEntry, DWORD* dwDelay);

		BOOL IsQueueEmpty(void) const {return IsListEmpty(&m_QHead);}

        //Used to steal entries with tmp queue
        void StealQueueEntries(CRETRY_Q *pRetryQueue);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\rhash.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       rhash.cxx

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

  		Nimish Khanolkar     (NimishK)		

--*/
#include "precomp.h"

CRETRY_HASH_TABLE::CRETRY_HASH_TABLE()
{
    TraceFunctEnterEx((LPARAM)this, 
			    "CRETRY_HASH_TABLE::CRETRY_HASH_TABLE");
    m_TotalEntries = 0;
    m_Signature = RETRY_TABLE_SIGNATURE_VALID;
	    
    TraceFunctLeaveEx((LPARAM)this);
}

CRETRY_HASH_TABLE::~CRETRY_HASH_TABLE()
{
    TraceFunctEnterEx((LPARAM)this, 
			    "CRETRY_HASH_TABLE::~CRETRY_HASH_TABLE");

    m_Signature = RETRY_TABLE_SIGNATURE_FREE;

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::DeInitialize
//
// Very Basic.
// By this time there should be no threads adding anything to the hash table
// Frees up all the entries in the hash table
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT CRETRY_HASH_TABLE::DeInitialize(void)
{
    //Remove all the entries from the HashTable
    RemoveAllEntries();
    delete this;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveThisEntry
//
// Need to add code to remove entry from retry q as well
//
/////////////////////////////////////////////////////////////////////////////////
void CRETRY_HASH_TABLE::RemoveThisEntry(CRETRY_HASH_ENTRY * pHashEntry, 
                                        DWORD BucketNum)
{
    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveThisEntry");
    DebugTrace((LPARAM)this, "removing %s from hash table", 
                                                pHashEntry->GetHashKey());

    m_HashTable[BucketNum].m_Lock.ExclusiveLock();
    RemoveEntryList(&pHashEntry->QueryHListEntry());
    m_HashTable[BucketNum].m_Lock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveAllEntries
//
// To be clean : Need to add code to remove each entry from retry q as well
// But not really needed as I will not be leaking anything if I simply destroy the
// queue
//
/////////////////////////////////////////////////////////////////////////////////

void CRETRY_HASH_TABLE::RemoveAllEntries(void)
{
    DWORD LoopVar = 0;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY pEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveAllEntries");

    for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
    {
        m_HashTable[LoopVar].m_Lock.ExclusiveLock();
        HeadOfList = &m_HashTable[LoopVar].m_ListHead;
        while (!IsListEmpty(HeadOfList))
        {
            //remove the entries from the list
            pEntry = RemoveHeadList (HeadOfList);
            pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_HLEntry);

            _ASSERT(pHashEntry->IsValid());

            DebugTrace((LPARAM)this, "removing %s from hash table. RefCnt = %d", 
			            pHashEntry->GetHashKey(),  pHashEntry->QueryRefCount());

            pHashEntry->ClearInTable();

            pHashEntry->DecRefCount();

            //decrement entry counts
            m_HashTable[LoopVar].m_NumEntries--;
            InterlockedIncrement(&(m_HashTable[LoopVar].m_RefNum));
            InterlockedDecrement(&m_TotalEntries);
        }
        m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
    }

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::PrintAllEntries
//
// Should not use this one - not really useful.
// Instead Use RETRYQ::PrintAllQEntries()
//
/////////////////////////////////////////////////////////////////////////////////
//
void CRETRY_HASH_TABLE::PrintAllEntries(void)
{

    DWORD LoopVar = 0;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY  pEntry = NULL;
    PLIST_ENTRY  pentryNext = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
    {
        m_HashTable[LoopVar].m_Lock.ExclusiveLock();
        HeadOfList = &m_HashTable[LoopVar].m_ListHead;
        pEntry = m_HashTable[LoopVar].m_ListHead.Flink;
        for(; pEntry != HeadOfList; pEntry = pentryNext)
        {
            pentryNext = pEntry->Flink;
            pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_HLEntry);
            printf("%s i n bucket %d\n", pHashEntry->GetHashKey(), LoopVar);
        }
        m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
    }

}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::InsertIntoTable
//
// We insert a new entry into the table 
// If we find an existing one for the same domain we remove it and add this new 
// one
// Adding an entry to the Hash Table also results in adding the entry to the retry 
// queue ordered on the RetryTime
//
/////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_HASH_TABLE::InsertIntoTable(CRETRY_HASH_ENTRY * pHashEntry)
{
    unsigned int HashValue = 0;
    char * NewData = NULL;
    char * ExistingData = NULL;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY ListEntry =NULL;
    CRETRY_HASH_ENTRY * pExistingEntry = NULL;
    int Result = 0;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::InsertIntoTable");

    _ASSERT(pHashEntry != NULL);

    if(pHashEntry == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //get the new key
    NewData = pHashEntry->GetHashKey();

    _ASSERT(NewData != NULL);

    if(NewData == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    CharLowerBuff((char *)NewData, lstrlen(NewData));

    //get the hash value for it
    HashValue = HashFunction (NewData);

    //lock the list exclusively
    m_HashTable[HashValue].m_Lock.ExclusiveLock();

    //insert the head of the list for this bucket
    //duplicates are dealt by removing the dup entry and
    //adding the new one
    HeadOfList = &m_HashTable[HashValue].m_ListHead;

    for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
	    ListEntry = ListEntry->Flink)
    {
        _ASSERT(ListEntry != NULL);
        pExistingEntry = CONTAINING_RECORD(ListEntry, CRETRY_HASH_ENTRY, m_HLEntry);
        
        if(pExistingEntry && pExistingEntry->IsValid())
        {
            //So we got a valid entry
            ExistingData = pExistingEntry->GetHashKey();
        }
        else
        {
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_INVALID_DATA);
            //We have a corrupt entry in the hash table
            DebugTrace((LPARAM)this, "hash table bucket %d has a currupt entry listEntry ", 
									            HashValue);
            _ASSERT(pExistingEntry->IsValid());
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        _ASSERT(ExistingData != NULL);

        Result = lstrcmpi(NewData, ExistingData);
        if(Result < 0)
        {
            break;
        }
        else if(Result == 0)
        {

            //So there is already a Hash Entry
            DebugTrace((LPARAM)this, "%s is already in hash table ", 
									            pHashEntry->GetHashKey());

            //If we already have an entry in there - we will live with it 
            //For the time being, we will taking the approach that if something 
            //makes us establish a new connection before the retry interval and
            //we fail the connection, then we simply ignore the failure and stick
            //with the original retry interval
            //eg at 2:00pm we inserted something for retry at 2:30pm
            //	 at 2:20pm something triggers this domain, but the connection fails
            //   Instead of updating the retry queue to now retry at 2:50 pm, 
            //	 we will instead retry at 2:30pm as orginally planned.

            //unlock this bucket
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_FILE_EXISTS);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }

    // Ok, insert the entry here here.

    //inc the ref count on the hash entry
    pHashEntry->IncRefCount();

    //We just added the entry the ref count cannot be anything but 1
    _ASSERT(pHashEntry->QueryRefCount() == 1);
    _ASSERT(ListEntry != NULL);

    //Insert into the hash bucket list before the exisitng entry
    InsertTailList(ListEntry, &pHashEntry->QueryHListEntry());
    pHashEntry->SetInTable();

    //update total entries in this bucket
    m_HashTable[HashValue].m_NumEntries++;

    DebugTrace((LPARAM)this, "inserted %s into hash table. RefCnt = %d", 
					    pHashEntry->GetHashKey(), pHashEntry->QueryRefCount());

    //update numentries in this bucket
    InterlockedIncrement(&m_TotalEntries);

    //unlock this bucket
    m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveFromTable
//
// We insert a new entry into the table 
// If we find an existing one for the same domain we remove it and add this new 
// one
// Adding an entry to the Hash Table also results in adding the entry to the retry 
// queue ordered on the RetryTime
//
/////////////////////////////////////////////////////////////////////////////////

BOOL CRETRY_HASH_TABLE::RemoveFromTable(const char * SearchData, 
										PRETRY_HASH_ENTRY *ppExistingEntry)
{
    unsigned int HashValue;
    char * ExistingData = NULL;
    PLIST_ENTRY	HeadOfList;
    PLIST_ENTRY ListEntry;
    int Result = 0;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveFromTable");

    _ASSERT(SearchData != NULL);

    if(SearchData == NULL)
    {
        return FALSE;
    }

    CharLowerBuff((char *)SearchData, lstrlen(SearchData));

    //get the hash value
    HashValue = HashFunction (SearchData);

    m_HashTable[HashValue].m_Lock.ExclusiveLock();

    HeadOfList = &m_HashTable[HashValue].m_ListHead;

    for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
                                        ListEntry = ListEntry->Flink)
    {
        _ASSERT(ListEntry != NULL);
        *ppExistingEntry = CONTAINING_RECORD(ListEntry, CRETRY_HASH_ENTRY, m_HLEntry);
        //ExistingData = (*ppExistingEntry)->GetHashKey();

        if((*ppExistingEntry) && (*ppExistingEntry)->IsValid())
        {
            //So we got a valid entry
            ExistingData = (*ppExistingEntry)->GetHashKey();
        }
        else
        {
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_INVALID_DATA);
            //We have a corrupt entry in the hash table
            DebugTrace((LPARAM)this, 
                "hash table bucket %d has a currupt entry listEntry ", 
	            HashValue);
            _ASSERT((*ppExistingEntry)->IsValid());
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        _ASSERT(ExistingData != NULL);

        Result = lstrcmpi(SearchData,ExistingData);
        if(Result == 0)
        {
            DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

            //found it
            //Remove it from this bucket list
            RemoveEntryList(ListEntry);
            (*ppExistingEntry)->ClearInTable();

            m_HashTable[HashValue].m_NumEntries--;

            InterlockedDecrement(&m_TotalEntries);

            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
        else if ( Result < 0 )
            break;
    }

    //duplicates are not allowed
    SetLastError(ERROR_PATH_NOT_FOUND);
    *ppExistingEntry = NULL;
    m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\timemath.h ===
// timemath.h---written by Bill Griffin (Billgr)

#if !defined(_TIMEMATH_H_)
#define _TIMEMATH_H_

const __int64 hnsPerMillisecond  = 10000i64;
const __int64 hnsPerSecond       = 10000000i64;
const __int64 hnsPerMinute       = 600000000i64;
const __int64 hnsPerHour         = 36000000000i64;
const __int64 hnsPerDay          = 864000000000i64;

inline __int64 MsFromHns(__int64 hns)
    { return hns / hnsPerMillisecond; }
inline __int64 SecFromHns(__int64 hns)
    { return hns / hnsPerSecond; }
inline __int64 MinFromHns(__int64 hns)
    { return hns / hnsPerMinute; }
inline __int64 HrFromHns(__int64 hns)
    { return hns / hnsPerHour; }
inline __int64 DayFromHns(__int64 hns)
    { return hns / hnsPerDay; }

inline  __int64 HnsFromMs(__int64 ms)
    { return ms * hnsPerMillisecond; }
inline  __int64 HnsFromSec(__int64 sec)
    { return  sec * hnsPerSecond; }
inline  __int64 HnsFromMin(__int64 min)
    { return  min * hnsPerMinute; }
inline  __int64 HnsFromHr(__int64 hr)
    { return  hr * hnsPerHour; }
inline  __int64 HnsFromDay(__int64 day)
    { return day * hnsPerDay; }

inline __int64 HnsFromFt(FILETIME ft)
    { return *((__int64*)&ft); }
inline __int64 HnsFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HnsFromFt(ftEnd) - HnsFromFt(ftStart); }
inline __int64 SecFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return SecFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 MinFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return MinFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 HrFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HrFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 DayFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return DayFromHns(HnsFromFtSpan(ftStart, ftEnd)); }

//NimishK - some more good stuff related to the time math issues
#define I64_LI(cli) (*((__int64*)&cli))
#define LI_I64(i) (*((LARGE_INTEGER*)&i))
#define INT64_FROM_LARGE_INTEGER(cli) I64_LI(cli)
#define LARGE_INTEGER_FROM_INT64(i) LI_I64(i)

#define I64_FT(ft) (*((__int64*)&ft))
#define FT_I64(i) (*((FILETIME*)&i))
#define INT64_FROM_FILETIME(ft) I64_FT(ft)
#define FILETIME_FROM_INT64(i) FT_I64(i)

#endif // !defined(_TIMEMATH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\envdef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       envdef.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    01-05-96   Rohanp   Created
//
//----------------------------------------------------------------------------

#ifndef __ENVDEF_H__
#define __ENVDEF_H__

#define MSG_TYPE_NDR				0x00000001	//Msg is an NDR
#define MSG_TYPE_DSL				0x00000002	//Msg has a DL
#define MSG_TYPE_NDE				0x00000004	//Msg is to be NDRed immediately
#define MSG_TYPE_NDP				0x00000008	//NDR sent to POSTMASTER
#define MSG_TYPE_RES				0x00000010	//Msg was already resolved through abook
#define MSG_TYPE_EMIME				0x00000020	//Msg is 8bit mime
#define MSG_TYPE_RQL				0x00000040	//Requeue this message to the sharing queue
#define MSG_TYPE_LRE				0x00000080	//Local recipients were in the retry queue
#define MSG_TYPE_RRE				0x00000100	//Remote recipients were in the retry queue
#define MSG_TYPE_NEW				0x00000200	//Brand new message
#define MSG_TYPE_SQL				0x00000400	//Reading from SQL
#define MSG_TYPE_PKUP				0x00000800	//Reading from Pickup directory
#define MSG_TYPE_ASYNC_RES_STARTED	0x00001000	//Async resolution started
#define MSG_TYPE_ASYNC_RES_STOPPED	0x00002000	//Async resolution stopped
#define MSG_TYPE_LTR_PRESENT		0x00004000	//An LTR is present before addr resolution

//current version of this header
#define CURRENT_HEADER_HIGH_VERSION 1
#define CURRENT_HEADER_LOW_VERSION 0
#define MAKESMTPVERSION(HighVersion, LowVersion) (((HighVersion) << 16) | (LowVersion))
#define ENV_SIGNATURE		((DWORD)'SENV')

#define IsPropertySet(Flags, Option) ((Flags & Option) == Option)
enum HEADER_OFFSET {HDR_VERSION, HDR_TYPE, HDR_LOFFSET, HDR_LSIZE,
				    HDR_ROFFSET, HDR_RSIZE, HDR_LEXP_TIME, 
					HDR_RETRY_OFFSET, HDR_RETRY_ELEMENTS, 
					HDR_ROUTE_SIZE, HDR_REXP_TIME};

/*	   
	   The envelope for each message resides in an NTFS
	   stream in that message file.  The envelope has
	   a header that looks like the following :

	struct ENVELOPE_HEADER
	{
	DWORD						Version;			// The current version of this structure
	DWORD						Signature;			// Signature (should be 'SENV'
	DWORD						HdrSize;			// Current size of this structure
	DWORD						BodyOffset;			// Offset of the body of the message from beginning
	DWORD						MsgFlags;			// 0 if normal message, 1 if NDR message
	DWORD                       LocalOffset;		// Local rcpt. list offset
    DWORD                       RemoteOffset;   	// Remote rcpt. list offset
    DWORD                       LocalSize;			// Size of local rcpt list in bytes
	DWORD						RemoteSize;			// Size of remote rcpt list in bytes
	DWORD						RouteStructSize;	// Size of AB structure, if present
	LONGLONG                    LocalExpireTime;	// Time to delete local portion of mail
    LONGLONG                    RemoteExpireTime;	// To delete remote portion of mail
	};

		Right after the envelope header is the address 
		that was in the "Mail From" line. This address 
		is stored like "Srohanp@microsoft.com\n".  The "S"
		stands for SENDER. In the code below, the first
		byte is always removed when reading the address.
		The '\n' is also replaced with a '\0';

		In this version the Remote recipient list, if any,
		comes right after the senders' address.  You can
		also find it by seeking RemoteOffset bytes from the
		beginning of the file.  Once RemoteOffset is reached,
		the code reads RemoteSize bytes of data.  This is the
		total size in bytes of the remote recipient list.
		Each recipient address is stored on a line by itself,
		with the first letter "R" as in the example below:

		Rrohanp@microsoft.com\n
		Rtoddch@microsoft.com\n
		etc.

		The local addresses have the same format. The first byte,
		'R' stands for recipient and is always removed when building
		the address.  The '\n' is also removed.
*/


typedef struct _ENVELOPE_HEADER_
{
	DWORD						Version;			// The current version of this structure
	DWORD						Signature;			// Signature (should be 'SENV'
	DWORD						HdrSize;			// Size of this header
	DWORD						BodyOffset;			// Offset of body into file
	DWORD						MsgFlags;			// Has flags noted above
	DWORD                       LocalOffset;		// Local rcpt. list offset
    DWORD                       RemoteOffset;   	// Remote rcpt. list offset
    DWORD                       LocalSize;			// Size of local rcpt list in bytes
	DWORD						RemoteSize;			// Size of remote rcpt list in bytes
	DWORD						RouteStructSize;	// Size of AB structure, if present
	DWORD						RetryOffset;		// offset of local recipients to retry
	DWORD						RetryElements;			// Size of retry list
    LONGLONG                    LocalExpireTime;	// Time to delete local portion of mail
    LONGLONG                    RemoteExpireTime;	// To delete remote portion of mail
} ENVELOPE_HEADER, *PENV_HEADER;

typedef struct _ENVELOPE_HEADER_EX_
{
	DWORD						ErrorCode;
	ABROUTING					AbInfo;			// Last address in DL we processed
}ENVELOPE_HEADER_EX, *PENV_HEADER_EX;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\isrpcexp.h ===
//
//  Dll initialization and termination
//

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

dllexp
BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

dllexp
CleanupServiceRpc(
               VOID
               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\rhash.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       rhash.h

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

        Nimish Khanolkar   (NimishK)       May-98 

--*/

#ifndef _RHASH_H_
#define _RHASH_H_

#include <windows.h>
#include <limits.h>


#define RETRY_TABLE_SIGNATURE_VALID		'RtsV'
#define RETRY_TABLE_SIGNATURE_FREE		'RtsF'

class RETRYQ;


typedef struct HASH_BUCKET_ENTRY
{
    DWORD       m_NumEntries;
    LONG        m_RefNum;
    LIST_ENTRY  m_ListHead;
    CShareLockNH  m_Lock;

    HASH_BUCKET_ENTRY (void)
    {
        InitializeListHead(&m_ListHead);
        m_NumEntries = 0;
        m_RefNum = 0;
    }

}BUCKET_ENTRY, *PBUCKET_ENTRY;

#define BITS_IN_int     (sizeof(int) * CHAR_BIT)
#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))
#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))
#define HIGH_BITS       (~((unsigned int)(~0) >> ONE_EIGHTH))
#define TABLE_SIZE      241

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE:
//
// A hash table to store all the domains that are in the Retry queue.
// The hash key is the name of the domain
//
/////////////////////////////////////////////////////////////////////////////////

class CRETRY_HASH_TABLE
{
    protected:
        DWORD   m_Signature;
        LONG    m_TotalEntries;
        HASH_BUCKET_ENTRY m_HashTable[TABLE_SIZE];
		RETRYQ*	m_pRetryQueue;

    public:

		CRETRY_HASH_TABLE();
        ~CRETRY_HASH_TABLE();
		HRESULT DeInitialize(void);
		void RemoveAllEntries(void);
		void RemoveThisEntry(CRETRY_HASH_ENTRY * pHashEntry, DWORD BucketNum);

        BOOL RemoveFromTable(const char * SearchData, CRETRY_HASH_ENTRY* *ppExistingEntry);
        BOOL InsertIntoTable (CRETRY_HASH_ENTRY * pHashEntry);
 
        BOOL IsTableEmpty(void) const {return (m_TotalEntries == 0);}
		BOOL IsHashTableValid(void){ return (m_Signature == RETRY_TABLE_SIGNATURE_VALID);} 

		RETRYQ*	GetQueuePtr(){return m_pRetryQueue;}

        //An adaptation of Peter Weinberger's (PJW) generic
        //hashing algorithm based on Allen Holub's version.
        //Code from Practical Algorithms for Programmers
        //by Andrew Binstock
        unsigned int HashFunction (const char * String)
        {
            unsigned int HashValue = 0;
            unsigned int i = 0;

            _ASSERT(String != NULL);

            for (HashValue = 0; String && *String; ++String)
            {
                HashValue = (HashValue << ONE_EIGHTH) + * String;
                if((i = HashValue & HIGH_BITS) != 0)
                {
                    HashValue = (HashValue ^ (i >> THREE_QUARTERS)) & ~ HIGH_BITS;
                }
            }

            HashValue %= TABLE_SIZE;
            return HashValue;
        }

	private:
		//Unused functions
#if 0		
		DWORD PrimaryCompareFunction(const char * SearchData, CRETRY_HASH_ENTRY * pExistingEntry)
		{
			DWORD Result = 0;
			Result = lstrcmpi(SearchData, pExistingEntry->GetHashKey());
			return Result;
		}
				
		CRETRY_HASH_ENTRY * FindHashData(const char * SearchData);

        LIST_ENTRY & GetBucketHead(DWORD BucketNum)
        {
            return m_HashTable[BucketNum].m_ListHead;
        }
#endif

	public:
		//debug function
		void PrintAllEntries(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\msg.h ===
// Msg.h : Declaration of the CMsg

#ifndef __MSG_H_
#define __MSG_H_

#include "imsg.h"
#include "props.h"


// This template is used for declaring objects on the stack.  It is just like
// CComObjectStack<>, except that it does not assert on Addref(), Release(), or
// QueryInterface().
template <class Base>
class CComObjectStackLoose : public Base
{
public:
	CComObjectStackLoose() { m_dwRef=1; };
	~CComObjectStackLoose() { FinalRelease(); };
	STDMETHOD_(ULONG, AddRef)() { return (InternalAddRef()); };
	STDMETHOD_(ULONG, Release)() {return (InternalRelease()); };
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{ return _InternalQueryInterface(iid,ppvObject); }
};


/////////////////////////////////////////////////////////////////////////////
// CMsg
class ATL_NO_VTABLE __declspec(uuid("2DF59670-3D15-11d1-AA51-00AA006BC80B")) CMsg : 
	public CComObjectRoot,
//	public CComCoClass<CMsg, &CLSID_Msg>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMsg, &IID_IMsg, &LIBID_IMSGLib>,
	public IMsgLog
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Init(CGenericPTable *pPTable, LPVOID pDefaultContext=NULL);
		static HRESULT CreateInstance(CGenericPTable *pPTable, LPVOID pDefaultContext, CMsg **ppCMsg);
		void SetLogging(LPVOID pvLogHandle, DWORD (*pLogInformation)(LPVOID,const INETLOG_INFORMATION *));

	DECLARE_NOT_AGGREGATABLE(CMsg);
	DECLARE_PROTECT_FINAL_CONSTRUCT();

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SMTP CMsg Class",
//								   L"SMTP.CMsg.1",
//								   L"SMTP.CMsg");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CMsg)
		COM_INTERFACE_ENTRY(IMsg)
		COM_INTERFACE_ENTRY(IMsgLog)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_IID(__uuidof(CMsg),CMsg)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISupportsErrorInfo
	public:
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	// IMsg
	public:
		STDMETHOD(SetInterfaceW)(LPCWSTR pszName, IUnknown *punkValue);
		STDMETHOD(SetInterfaceA)(LPCSTR pszName, IUnknown *punkValue);
//		STDMETHOD(GetInterfaceW)(LPCWSTR pszName, IUnknown **ppunkResult);
//		STDMETHOD(GetInterfaceA)(LPCSTR pszName, IUnknown **ppunkResult);
		STDMETHOD(GetInterfaceW)(LPCWSTR pszName, const GUID &guid, IUnknown **ppunkResult);
		STDMETHOD(GetInterfaceA)(LPCSTR pszName, const GUID &guid, IUnknown **ppunkResult);
		STDMETHOD(SetDwordW)(LPCWSTR pszName, DWORD dwValue);
		STDMETHOD(SetDwordA)(LPCSTR pszName, DWORD dwValue);
		STDMETHOD(GetDwordW)(LPCWSTR pszName, DWORD *pdwResult);
		STDMETHOD(GetDwordA)(LPCSTR pszName, DWORD *pdwResult);
		STDMETHOD(SetStringW)(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue);
		STDMETHOD(SetStringA)(LPCSTR pszName, DWORD chCount, LPCSTR pszValue);
		STDMETHOD(GetStringW)(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult);
		STDMETHOD(GetStringA)(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult);
		STDMETHOD(SetVariantW)(LPCWSTR pszName, VARIANT *pvarValue);
		STDMETHOD(SetVariantA)(LPCSTR pszName, VARIANT *pvarValue);
		STDMETHOD(GetVariantW)(LPCWSTR pszName, VARIANT *pvarResult);
		STDMETHOD(GetVariantA)(LPCSTR pszName, VARIANT *pvarResult);
		STDMETHOD(get_Value)(BSTR bstrValue, /*[out, retval]*/ VARIANT *pVal);
		STDMETHOD(put_Value)(BSTR bstrValue, /*[in]*/ VARIANT newVal);

		// This method is called by the source after all sink processing 
		// to commit all changes to the media. Only changed properties
		// are updated.
		BOOL CommitChanges() { return(m_PTable.CommitChanges() == S_OK?TRUE:FALSE); }

		// This method is called by the source to rollback
		BOOL Rollback() { return(m_PTable.Invalidate() == S_OK?TRUE:FALSE); }

	// IMsgLog
	public:
		STDMETHOD(WriteToLog)(LPCSTR pszClientHostName,
							  LPCSTR pszClientUserName,
							  LPCSTR pszServerAddress,
							  LPCSTR pszOperation,
							  LPCSTR pszTarget,
							  LPCSTR pszParameters,
							  LPCSTR pszVersion,
							  DWORD dwBytesSent,
							  DWORD dwBytesReceived,
							  DWORD dwProcessingTimeMS,
							  DWORD dwWin32Status,
							  DWORD dwProtocolStatus,
							  DWORD dwPort,
							  LPCSTR pszHTTPHeader);

	private:
		// We have an instance of CPropertyTable
		CPropertyTable m_PTable;			// Property table
		LPVOID m_pContext;			// Context pointer
		CComPtr<IUnknown> m_pUnkMarshaler;
		DWORD (*m_pLogInformation)(LPVOID,const INETLOG_INFORMATION *);
		LPVOID m_pvLogHandle;
};


class CMsgStack : public CComObjectStackLoose<CMsg> {
	public:
		CMsgStack(CGenericPTable *pPTable, LPVOID pDefaultContext=NULL) {
			Init(pPTable,pDefaultContext);
		};
};


#endif //__MSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\ims.h ===
/*++

    Copyright    (c)    1994    Microsoft Corporation

    Module  Name :

        ims.h

    Abstract:

        Common header for Internet Mail System components.

    Author:

        Richard Kamicar    (rkamicar)    31-Dec-1995

    Project:

        IMS

    Revision History:

--*/

#ifndef _IMS_H_
#define _IMS_H_

#define I64_LI(cli) (*((__int64*)&cli))
#define LI_I64(i) (*((LARGE_INTEGER*)&i))
#define INT64_FROM_LARGE_INTEGER(cli) I64_LI(cli)
#define LARGE_INTEGER_FROM_INT64(i) LI_I64(i)

#define I64_FT(ft) (*((__int64*)&ft))
#define FT_I64(i) (*((FILETIME*)&i))
#define INT64_FROM_FILETIME(ft) I64_FT(ft)
#define FILETIME_FROM_INT64(i) FT_I64(i)

//
// These can be overridden by registry values.
//
#define IMS_MAX_ERRORS          10
#define IMS_MAX_USER_NAME_LEN   64
#define IMS_MAX_DOMAIN_NAME_LEN 256
#define IMS_MAX_PATH_LEN        64
#define IMS_MAX_MSG_SIZE        42 * 1024
#define IMS_MAX_FILE_NAME_LEN   40

#define IMS_ACCESS_LOCKFILE         TEXT("pop3lock.lck")
#define IMS_ACCESS_LOCKFILE_NAME    IMS_ACCESS_LOCKFILE

#define IMS_DOMAIN_KEY              TEXT("DomainName")
#define IMS_EXTENSION               TEXT("eml")
#define ENV_EXTENSION               TEXT("env")
static const int TABLE_SIZE = 241;

/*++
    This function canonicalizes the path, taking into account the current
    user's current directory value.

    Arguments:
        pszDest   string that will on return contain the complete
                    canonicalized path. This buffer will be of size
                    specified in *lpdwSize.

        lpdwSize  Contains the size of the buffer pszDest on entry.
                On return contains the number of bytes written
                into the buffer or number of bytes required.

        pszSearchPath  pointer to string containing the path to be converted.
                    IF NULL, use the current directory only

    Returns:

        Win32 Error Code - NO_ERROR on success

    MuraliK   24-Apr-1995   Created.

--*/
BOOL
ResolveVirtualRoot(
        OUT CHAR *      pszDest,
    IN  OUT LPDWORD     lpdwSize,
    IN  OUT CHAR *      pszSearchPath,
        OUT HANDLE *    phToken = NULL
    );

//Published hash algorithm used in the UNIX ELF
//format for object files
inline unsigned long ElfHash (const unsigned char * UserName)
{
    unsigned long HashValue = 0, g;

    while (*UserName)
    {
        HashValue = (HashValue << 4) + *UserName++;
        if( g = HashValue & 0xF0000000)
            HashValue ^= g >> 24;

        HashValue &= ~g;
    }

    return HashValue;

}

inline DWORD HashUser (const unsigned char * UserName)
{
    DWORD HashValue = ElfHash (UserName);
    HashValue %= TABLE_SIZE;

    return HashValue;
}

inline VOID
MakeInboxPath(
    LPTSTR  pszInboxPath,           // UNICODE | ASCII
    LPCTSTR pszMailRoot,            // UNICODE | ASCII
    LPCSTR  paszUserName            // ASCII
    )
{

    wsprintf(pszInboxPath, "%s\\%u\\%hs",
                            pszMailRoot,
                            HashUser((const unsigned char *)paszUserName),
                            paszUserName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\regsink.h ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module name :

        regsink.h

   Abstract:

        Libaray to support registration processes for SEO sinks.

   Author:

           Keith Lau    (KeithLau)    7/04/98

   Project:

           SMTP Server DLL

   Revision History:

--*/

#ifndef __REGSINK_H__
#define __REGSINK_H__

HRESULT RegisterSinkAndAllDependencies(
			DWORD				dwInstanceID,
			REFGUID				rguidSourceType,
			LPSTR				pszSourceTypeDisplayName,
			REFGUID				rguidEventType,
			LPSTR				pszEventTypeDisplayName,
			REFGUID				rguidSourceBaseGuid,
			LPSTR				pszBaseDisplayName,
			LPSTR				pszMetabaseRootPath,
			REFGUID				rguidBinding,
			LPSTR				pszSinkDisplayName,
			LPSTR				pszSinkProgID,
			LPSTR				pszRule,
			DWORD				dwPriority
			);

HRESULT UnregisterSinkGivenDependencies(
			DWORD				dwInstanceID,
			REFGUID				rguidSourceType,
			REFGUID				rguidEventType,
			REFGUID				rguidSourceBaseGuid,
			LPSTR				pszMetabaseRootPath,
			REFGUID				rguidBinding
			);

HRESULT FindEventSourceType(
			REFGUID				rguidSourceType,
			IEventSourceType	**ppSourceType
			);

HRESULT RegisterEventSourceType(
			REFGUID				rguidSourceType,
			LPSTR				pszDisplayName,
			IEventSourceType	**ppSourceType
			);

HRESULT RegisterEventType(
			IEventSourceType	*pSourceType,
			REFGUID				rguidEventType,
			LPSTR				pszDisplayName
			);

HRESULT FindEventSource(
			IEventSourceType		*pSourceType,
			REFGUID					rguidSourceBaseGuid,
			DWORD					dwInstanceID,
			IEventSource			**ppEventSource
			);

HRESULT RegisterEventSource(
			IEventSourceType		*pSourceType,
			REFGUID					rguidSourceBaseGuid,
			LPSTR					pszMetabaseRootPath,
			LPSTR					pszBaseDisplayName,
			DWORD					dwInstanceID,
			IEventSource			**ppEventSource
			);

HRESULT RegisterEventSink(
			IEventSource			*pEventSource,
			REFGUID					rguidBinding,
			REFGUID					rguidEventType,
			LPSTR					pszSinkProgID,
			LPSTR					pszDisplayName,
			LPSTR					pszRule,
			DWORD					dwPriority
			);

HRESULT UnregisterEventSink(
			IEventSource			*pEventSource,
			REFGUID					rguidBinding,
			REFGUID					rguidEventType
			);

HRESULT UnregisterEventSource(
			IEventSourceType	*pSourceType,
			REFGUID				rguidSourceBaseGuid,
			DWORD				dwInstanceID
			);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\ptable.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	ptable.h

Abstract:

	This module contains the export of the property table

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PTABLE_H_
#define _PTABLE_H_

#include "props.h"

// Enumerated type for HP access of individual properties
typedef enum _MSG_PTABLE_ITEMS
{
	_PI_MSG_CLIENT_DOMAIN = 0,
	_PI_MSG_CLIENT_IP,
	_PI_MSG_MAIL_FROM,
	_PI_MSG_MSG_STATUS,
	_PI_MSG_MSG_STREAM,
	_PI_MSG_RCPT_TO,
	_PI_MSG_SERVER_IP,
	_PI_MSG_MAX_PI

} MSG_PTABLE_ITEMS;

typedef enum _DEL_PTABLE_ITEMS
{
	_PI_DEL_CLIENT_DOMAIN = 0,
	_PI_DEL_CLIENT_IP,
	_PI_DEL_CURRENT_RCPT,
	_PI_DEL_MAIL_FROM,
	_PI_DEL_MAILBOX_PATH,
	_PI_DEL_MSG_STATUS,
	_PI_DEL_MSG_STREAM,
	_PI_DEL_RCPT_TO,
	_PI_DEL_SECURITY_TOKEN,
	_PI_DEL_SERVER_IP,
	_PI_DEL_MAX_PI

} DEL_PTABLE_ITEMS;

extern char		*rgszMessagePropertyNames[_PI_MSG_MAX_PI];
extern char		*rgszDeliveryPropertyNames[_PI_DEL_MAX_PI];

//
// CGenericPTable and CGenericCache are all defined in props.h
//
class CPerMessageCache : public CGenericCache
{
  public:
	CPerMessageCache(LPVOID pvDefaultContext) : CGenericCache(pvDefaultContext)
	{
		m_rgpdMessagePropertyData[0].pContext = NULL;
		m_rgpdMessagePropertyData[0].pCacheData = (LPVOID)&m_psClientDomain;
		m_rgpdMessagePropertyData[1].pContext = NULL;
		m_rgpdMessagePropertyData[1].pCacheData = (LPVOID)&m_psClientIP;
		m_rgpdMessagePropertyData[2].pContext = NULL;
		m_rgpdMessagePropertyData[2].pCacheData = (LPVOID)&m_psMailFrom;
		m_rgpdMessagePropertyData[3].pContext = NULL;
		m_rgpdMessagePropertyData[3].pCacheData = (LPVOID)&m_pdMsgStatus;
		m_rgpdMessagePropertyData[4].pContext = NULL;
		m_rgpdMessagePropertyData[4].pCacheData = (LPVOID)&m_pdStream;
		m_rgpdMessagePropertyData[5].pContext = NULL;
		m_rgpdMessagePropertyData[5].pCacheData = (LPVOID)&m_psRcptTo;
		m_rgpdMessagePropertyData[6].pContext = NULL;
		m_rgpdMessagePropertyData[6].pCacheData = (LPVOID)&m_psServerIP;

		// Default context
		m_rgpdMessagePropertyData[7].pContext = pvDefaultContext;
		m_rgpdMessagePropertyData[7].pCacheData = pvDefaultContext;
	}
	~CPerMessageCache() {}

	LPPROPERTY_DATA GetCacheBlock() { return(m_rgpdMessagePropertyData); }

  private:
	CPropertyValueDWORD		m_pdStream;			// IStream to message file
	CPropertyValueDWORD		m_pdMsgStatus;		// Message status
	CPropertyValueString	m_psMailFrom;		// Mail from string
	CPropertyValueString	m_psRcptTo;			// Rcpt to (MULTISZ)
	CPropertyValueString	m_psClientDomain;	// Client domain per EHLO
	CPropertyValueString	m_psClientIP;		// Client IP address
	CPropertyValueString	m_psServerIP;		// Server IP address

	// The extra slot is for the default accessor
	PROPERTY_DATA	m_rgpdMessagePropertyData[_PI_MSG_MAX_PI + 1];
};

class CPerRecipientCache : public CGenericCache
{
  public:
	CPerRecipientCache(LPVOID pvDefaultContext) : CGenericCache(pvDefaultContext)
	{
		m_rgpdRecipientPropertyData[0].pContext = NULL;
		m_rgpdRecipientPropertyData[0].pCacheData = (LPVOID)&m_psClientDomain;
		m_rgpdRecipientPropertyData[1].pContext = NULL;
		m_rgpdRecipientPropertyData[1].pCacheData = (LPVOID)&m_psClientIP;
		m_rgpdRecipientPropertyData[2].pContext = NULL;
		m_rgpdRecipientPropertyData[2].pCacheData = (LPVOID)&m_psCurrentRcpt;
		m_rgpdRecipientPropertyData[3].pContext = NULL;
		m_rgpdRecipientPropertyData[3].pCacheData = (LPVOID)&m_psMailFrom;
		m_rgpdRecipientPropertyData[4].pContext = NULL;
		m_rgpdRecipientPropertyData[4].pCacheData = (LPVOID)&m_psMailboxPath;
		m_rgpdRecipientPropertyData[5].pContext = NULL;
		m_rgpdRecipientPropertyData[5].pCacheData = (LPVOID)&m_pdMsgStatus;
		m_rgpdRecipientPropertyData[6].pContext = NULL;
		m_rgpdRecipientPropertyData[6].pCacheData = (LPVOID)&m_pdStream;
		m_rgpdRecipientPropertyData[7].pContext = NULL;
		m_rgpdRecipientPropertyData[7].pCacheData = (LPVOID)&m_psRcptTo;
		m_rgpdRecipientPropertyData[8].pContext = NULL;
		m_rgpdRecipientPropertyData[8].pCacheData = (LPVOID)&m_pdSecurityToken;
		m_rgpdRecipientPropertyData[9].pContext = NULL;
		m_rgpdRecipientPropertyData[9].pCacheData = (LPVOID)&m_psServerIP;

		// Default context
		m_rgpdRecipientPropertyData[10].pContext = pvDefaultContext;
		m_rgpdRecipientPropertyData[10].pCacheData = pvDefaultContext;
	}
	~CPerRecipientCache() {}

	LPPROPERTY_DATA GetCacheBlock() { return(m_rgpdRecipientPropertyData); }

  private:
	CPropertyValueDWORD		m_pdStream;			// IStream to message file
	CPropertyValueDWORD		m_pdMsgStatus;		// Message status
	CPropertyValueDWORD		m_pdSecurityToken;	// hImpersonation
	CPropertyValueString	m_psMailFrom;		// Mail from string
	CPropertyValueString	m_psMailboxPath;	// Mailbox path
	CPropertyValueString	m_psRcptTo;			// Rcpt to (MULTISZ)
	CPropertyValueString	m_psClientDomain;	// Client domain per EHLO
	CPropertyValueString	m_psClientIP;		// Client IP address
	CPropertyValueString	m_psCurrentRcpt;	// Current recipient
	CPropertyValueString	m_psServerIP;		// Server IP address

	// The extra slot is for the default accessor
	PROPERTY_DATA	m_rgpdRecipientPropertyData[_PI_DEL_MAX_PI + 1];
};

class CMessagePTable : public CGenericPTable
{
  public:
	CMessagePTable(CGenericCache	*pCache);
	~CMessagePTable() {}

	LPPTABLE GetPTable() { return(&m_PTable); }

  private:
	PTABLE		m_PTable;
};

class CDeliveryPTable : public CGenericPTable
{
  public:
	CDeliveryPTable(CGenericCache	*pCache);
	~CDeliveryPTable() {}

	LPPTABLE GetPTable() { return(&m_PTable); }

  private:
	PTABLE		m_PTable;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\props.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	props.h

Abstract:

	This module contains the definition of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PROPS_H_
#define _PROPS_H_

// Define a generic accessor function to access properties
typedef HRESULT (*GET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData,
											LPVOID	pvBuffer, 
											LPDWORD	pdwBufferLen);

typedef HRESULT (*SET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pCacheData, 
											LPVOID	pvBuffer, 
											DWORD	dwBufferLen,
											DWORD	ptPropertyType);

typedef HRESULT (*COMMIT_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData);

typedef HRESULT (*INVALIDATE_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pCacheData,
											DWORD	ptPropertyType);

// Define the property item structure. We can hash this if
// we want in the future
typedef struct _PROPERTY_ITEM
{
	LPSTR							pszName;
	DWORD							ptBaseType;
	DWORD							fAccess;
	DWORD							dwIndex;
	GET_ACCESSOR_FUNCTION			pfnGetAccessor;
	SET_ACCESSOR_FUNCTION			pfnSetAccessor;
	COMMIT_ACCESSOR_FUNCTION		pfnCommitAccessor;
	INVALIDATE_ACCESSOR_FUNCTION	pfnInvalidateAccessor;

} PROPERTY_ITEM, *LPPROPERTY_ITEM;

typedef struct _PROPERTY_DATA
{
	LPVOID							pContext;
	LPVOID							pCacheData;

} PROPERTY_DATA, *LPPROPERTY_DATA;

// Define a property context
typedef struct _PROP_CTXT
{
	LPPROPERTY_ITEM	pItem;
	BOOL			fIsWideStr;
	LPSTR			pszDefaultPropertyName;

} PROP_CTXT, *LPPROP_CTXT;

// Define a generic structure to define a set of properties
typedef struct _PTABLE
{
	LPPROPERTY_ITEM		pProperties;	// Actual property table
	LPPROPERTY_DATA		pPropertyData;	// Prop data
	DWORD				dwProperties;	// Count
	BOOL				fIsSorted;		// Sorted prop table?

} PTABLE, *LPPTABLE;

// =================================================================
// Generic cache class
//
class CGenericCache
{
  public:
	CGenericCache(LPVOID pvDefaultContext) {}
	~CGenericCache() {}
	virtual LPPROPERTY_DATA GetCacheBlock() = 0;
};

// =================================================================
// Generic property table
//
class CGenericPTable
{
  public:
	CGenericPTable(CGenericCache	*pCache) {}
	~CGenericPTable() {}
	virtual LPPTABLE GetPTable() = 0;
};

// =================================================================
// Definition of an in-house string structure
//
typedef struct _STRING_ATTR
{
	LPSTR	pszValue;
	DWORD	dwMaxLen;

} STRING_ATTR, *LPSTRING_ATTR;

// Enumerated types representing type of access on property
typedef enum _PROPERTY_ACCESS
{
	PA_READ = 1,
	PA_WRITE = 2,
	PA_READ_WRITE = 3

} _PROPERTY_ACCESS;

// Enumerated types representing property types
typedef enum _PROPERTY_TYPES
{
	PT_NONE = 0,
	PT_STRING,
	PT_DWORD,
	PT_INTERFACE,
	PT_DEFAULT,
	PT_MAXPT

} PROPERTY_TYPES;


// =================================================================
// Definition of an in-house string class, this is used for caching
//
class CPropertyValueString
{
  public:
	CPropertyValueString()
	{ 
		m_pszValue = NULL; 
		m_dwLength = 0;
		m_dwMaxLen = 0; 
		m_fChanged = FALSE;
	}
	~CPropertyValueString()	
	{ 
		if (m_pszValue) 
			LocalFree(m_pszValue); 
		m_pszValue = NULL; 
	}

	// Overload the assignment to abstract the implementation
	const CPropertyValueString& operator=(LPSTR szValue);

	// Users can call copy if they desire to
	BOOL Copy(LPSTR pszSrc, DWORD dwLength /* Optional */);

	void Invalidate()
	{
		if (m_pszValue) 
			LocalFree(m_pszValue); 
		m_pszValue = NULL; 
		m_fChanged = FALSE;
	}

	// We make these directly accessible
	LPSTR	m_pszValue;
	DWORD	m_dwLength;
	DWORD	m_dwMaxLen;
	BOOL	m_fChanged;
};

// =================================================================
// Definition of an in-house DWORD class, this is used for caching
//
class CPropertyValueDWORD
{
  public:
	CPropertyValueDWORD()
	{ 
		m_dwValue = 0; 
		m_fInit = FALSE;
		m_fChanged = TRUE;
		m_punkScratch = NULL;
	}

	~CPropertyValueDWORD()
	{ 
		if (m_fInit && m_punkScratch)
			m_punkScratch->Release();
		m_punkScratch = NULL;
	}

	// Overload the assignment to abstract the implementation
	const CPropertyValueDWORD& operator=(DWORD dwValue)
	{
		m_dwValue = dwValue;
		m_fInit = TRUE;
		m_fChanged = TRUE;
		return(*this);
	}

	void Invalidate()
	{
		if (m_fInit && m_punkScratch)
			m_punkScratch->Release();
		m_punkScratch = NULL;
		m_fInit = FALSE;
		m_fChanged = FALSE;
	}

	// We make these directly accessible
	DWORD	m_dwValue;
	BOOL	m_fInit;
	BOOL	m_fChanged;
	IUnknown *m_punkScratch;	// HACK: for interfaces only
};

// Size of default scratch buffer
#define DEFAULT_SCRATCH_BUFFER_SIZE		1024

// =================================================================
// class for searching properties
//
class CPropertyTable
{
  public:

	CPropertyTable()	
	{
		// Set up the default scratch pad
		m_szBuffer = m_rgcBuffer;
		m_cBuffer = DEFAULT_SCRATCH_BUFFER_SIZE;
	}

	BOOL Init(LPPROPERTY_ITEM	pProperties,
					LPPROPERTY_DATA	pData,
					DWORD			dwcProperties,
					LPVOID			pvDefaultContext,
					BOOL			fIsSorted = FALSE)
	{
		m_pProperties = pProperties;
		m_pData = pData;
		m_dwProperties = dwcProperties;
		m_fIsSorted = fIsSorted;

		// Set up default context for properties
		for (DWORD i = 0; i < dwcProperties; i++)
			m_pData[i].pContext = pvDefaultContext;

		return(TRUE);
	}

	~CPropertyTable()
	{
		// Wipe out members
		m_pProperties = NULL;
		m_dwProperties = 0;

		// Free the scratch buffer, if not equal to default
		if (m_szBuffer != m_rgcBuffer)
		{
			LocalFree((HLOCAL)m_szBuffer);
		}
	}

	// Method to get the property type given the property name
	HRESULT GetPropertyType(LPCSTR	szPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);

	HRESULT GetPropertyType(LPCWSTR	wszPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);

	// Method to retrieve the associated property item
	HRESULT GetProperty(LPPROP_CTXT	pPropertyContext,
						LPVOID		pvBuffer,
						LPDWORD		pdwBufferLen);

	// Method to set the associated property item
	HRESULT SetProperty(LPCSTR	szPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);

	HRESULT SetProperty(LPCWSTR	wszPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);

	// Method to commit all changes. This must be called or
	// all the changes will be lost
	HRESULT CommitChanges();

	// Method to rollback changes to the initial state or the
	// state after the last commit, whichever is more recent
	HRESULT Invalidate();

  private:
  
	// Method to obtain a scratch buffer of the desired size,
	// will allocate new one if insufficient. Size in bytes.
	LPVOID GetScratchBuffer(DWORD dwSizeDesired);

	// Method to search the property table and return the associated
	// property item, if found
	LPPROPERTY_ITEM SearchForProperty(LPCSTR szPropertyName);

	// Pointer to property table and count of items
	LPPROPERTY_ITEM		m_pProperties;
	LPPROPERTY_DATA		m_pData;
	DWORD				m_dwProperties;

	// TRUE if the table of properties is sorted, will use
	// binary search if so. Otherwise, a linear scan is performed
	BOOL				m_fIsSorted;

	// Default scratch buffer, used for wide string to LPSTR
	// conversion
	CHAR				m_rgcBuffer[DEFAULT_SCRATCH_BUFFER_SIZE];

	// Pointer to current scratch buffer, will be freed by 
	// destructor if not equal to m_rgcBuffer
	LPSTR				m_szBuffer;
	DWORD				m_cBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\seoext.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    seoext.h

Abstract:

    SMTP server extension header file. These definitions are available
    to SEO server extension writers.

Author:

    Microsoft Corporation	July, 1997

Revision History:

--*/

#ifndef _SEOEXT_H_
#define _SEOEXT_H_

// ====================================================================
// Return codes
//

#define SSE_STATUS_SUCCESS                  0
#define SSE_STATUS_RETRY                    1
#define SSE_STATUS_ABORT_DELIVERY           2
#define SSE_STATUS_BAD_MAIL					3

#define SSE_STATUS_INTERNAL_ERROR			0x1000
#define SSE_STATUS_EXCEPTION				0x1001

// The SMTP server fills in one of these before it calls 
// CallDeliveryExtension()
typedef struct _DELIVERY_EXTENSION_BLOCK
{
	HANDLE	hImpersonation;			// Token for user impersonation
	LPSTR	lpszMailboxPath;		// Recipient's mailbox path

} DELIVERY_EXTENSION_BLOCK, *LPDELIVERY_EXTENSION_BLOCK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\pbagstm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	pbagstm.h

Abstract:

	This module contains the definition of the property bag stream

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/09/97	created

--*/

#ifndef _PBAGSTM_H_
#define _PBAGSTM_H_

#include "cpool.h"

#define MAX_PROPERTY_NAME_LENGTH		256

typedef struct _TABLE_ENTRY
{
	DWORD		dwOffset;
	DWORD		dwSize;
	DWORD		dwNameSize;
	DWORD		dwMaxSize;
	DWORD		dwKey;	
	WORD		fFlags;
	WORD		wIndex;

} TABLE_ENTRY, *LPTABLE_ENTRY;

typedef struct _STREAM_HEADER
{
	DWORD				dwSignature;
	WORD				wVersionHigh;
	WORD				wVersionLow;
	DWORD				dwHeaderSize;
	DWORD				dwProperties;
	DWORD				dwDirectorySize;
	DWORD				dwEndOfData;

} STREAM_HEADER, *LPSTREAM_HEADER;

#define _CACHE_SIZE				64

typedef enum _PROPERTY_BAG_CREATORS
{
	PBC_NONE = 0,
	PBC_BUILDQ,
	PBC_DIRNOT,
	PBC_ENV,
	PBC_LOCALQ,
	PBC_MAILQ,
	PBC_REMOTEQ,
	PBC_RRETRYQ,
	PBC_SMTPCLI

} PROPERTY_BAG_CREATORS;

typedef enum _PROPERTY_FLAG_OPERATIONS
{
	PFO_NONE = 0,
	PFO_OR,
	PFO_ANDNOT

} PROPERTY_FLAG_OPERATIONS;

/////////////////////////////////////////////////////////////////////////////
// CPropertyBagStream
//

class CPropertyBagStream
{
  public:
	CPropertyBagStream(DWORD dwContext = 0);
	~CPropertyBagStream();

	static CPool		Pool;

	// override the mem functions to use CPool functions
	void *operator new (size_t cSize)
					   { return Pool.Alloc(); }
	void operator delete (void *pInstance)
					   { Pool.Free(pInstance); }

	// Reference count methods ...
	ULONG AddRef();
	ULONG Release(BOOL fDeleteIfZeroRef = FALSE);

	HRESULT SetStreamFileName(LPSTR	szStreamFileName);
	LPSTR GetStreamFileName() { return(m_szStreamName); }

	// Mechanisms for locking and unlocking the property bag
	HRESULT Lock();
	HRESULT Unlock();

	// Force opens the stream file if it is not already opened.
	// This is useful in checking if a stream file exists.
	HRESULT OpenStreamFile();

	// Access to properties as a whole
	HRESULT GetProperty(LPSTR	pszName, 
						LPVOID	pvBuffer,
						LPDWORD	pdwBufferLen);

	HRESULT SetProperty(LPSTR	pszName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen);

	// Access to properties, providing specific access to 
	// portions of the property data relative to the start
	// of the property data
	HRESULT GetPropertyAt(LPSTR	pszName, 
						DWORD	dwOffsetFromStart,
						LPVOID	pvBuffer,
						LPDWORD	pdwBufferLen);

	HRESULT SetPropertyAt(LPSTR	pszName,
						DWORD	dwOffsetFromStart,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen);

	// Ad-hoc function to allow access to a specific DWORD of
	// a property, treating the DWORD as a set of flags. The 
	// dwOperation argument specifies what kind of binary operation
	// we would like to have performed on the original value.
	// If the property does not originally exist, this function
	// will fail.
	HRESULT UpdatePropertyFlagsAt(LPSTR	pszName, 
						DWORD	dwOffsetFromStart,
						DWORD	dwFlags,
						DWORD	dwOperation);

#ifdef USE_PROPERTY_ITEM_ISTREAM
	// Returns an IStream interface to the desired property
	// for random access
	HRESULT GetIStreamToProperty(LPSTR		pszName,
								 IStream	**ppIStream);
#endif

	BOOL DeleteStream();

  private:

	BOOL ReleaseStream();

	HRESULT Seek(DWORD	dwOffset, DWORD	dwMethod);

	HRESULT LoadIntoCache(DWORD	dwStartIndex);

	LPTABLE_ENTRY FindFromCache(DWORD	dwKey,
								LPDWORD	pdwStartIndex);	

	HRESULT FindFrom(LPSTR	pszName,
							DWORD	dwKey,
							DWORD	dwStartIndex,
							BOOL	fForward,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry);

	HRESULT FindFromEx(LPSTR	pszName,
							DWORD	dwKey,
							DWORD	dwStartIndex,
							BOOL	fForward,
							DWORD	dwOffsetFromStart,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry);

	HRESULT GetRecordData(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordName(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordValue(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordValueAt(LPTABLE_ENTRY	pEntry, 
							DWORD		dwOffsetFromStart,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen);

	HRESULT UpdateEntry(LPTABLE_ENTRY	pEntry);

	HRESULT UpdateHeader();
	HRESULT UpdateHeaderUsingHandle(HANDLE hStream);

	HRESULT FindProperty(LPSTR	pszName,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry = NULL);

	HRESULT FindPropertyEx(LPSTR	pszName,
							DWORD	dwOffsetFromStart,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry = NULL);

	HRESULT SetRecordData(LPTABLE_ENTRY	pEntry,
							LPSTR		pszName,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen);

	HRESULT SetRecordDataAt(LPTABLE_ENTRY	pEntry,
							LPSTR		pszName,
							DWORD		dwOffsetFromStart,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen,
							BOOL		fNewRecord = FALSE);

	HRESULT RelocateRecordData(LPTABLE_ENTRY	pEntry);

	HRESULT DetermineIfCacheValid(BOOL *pfCacheInvalid);

	DWORD CreateKey(LPSTR	pszName)
	{
		CHAR cKey[9];
		DWORD dwLen = 0;

		// Convert to lower case ...
		while (*pszName && (dwLen < 8))
			if ((*pszName >= 'A') && (*pszName <= 'Z'))
				cKey[dwLen++] = *pszName++ - 'A' + 'a';
			else
				cKey[dwLen++] = *pszName++;
		cKey[dwLen] = '\0';
		dwLen = lstrlen(cKey);

		// Create the key
		if (dwLen < 4)
			return((DWORD)cKey[dwLen - 1]);
		else if (dwLen < 8)
			return(*(DWORD *)cKey);
		else
			return(~*(DWORD *)cKey ^ *(DWORD *)(cKey + 4));
	}

	DWORD GetTotalHeaderSize()
	{	
		return(sizeof(STREAM_HEADER) + 
				(m_Header.dwDirectorySize * sizeof(TABLE_ENTRY)));
	}

	// Current context
	DWORD				m_dwContext;

	// Base file name
	CHAR				m_szStreamName[MAX_PATH + 1];

	// Handle to stream
	HANDLE				m_hStream;

	// Stream header
	STREAM_HEADER		m_Header;

	// Directory caching
	TABLE_ENTRY			m_Cache[_CACHE_SIZE];
	DWORD				m_dwCacheStart;	
	DWORD				m_dwCachedItems;

	// Reference counting
	LONG				m_lRef;

	// This is a signature placed at the end to catch memory overwrite
	DWORD				m_dwSignature;

};


/////////////////////////////////////////////////////////////////////////////
// CPropertyItemStream
//

//
// Not everyone wants to use the property IStream, so we don't expose
// it if it's not wanted
//
#ifdef USE_PROPERTY_ITEM_ISTREAM

class CPropertyItemStream : public IStream
{
	public:

		CPropertyItemStream(LPSTR				pszName, 
							CPropertyBagStream	*pBag)
		{
			m_cRef = 0;

			m_pParentBag = pBeg;
			m_szName = pszName;
			m_libOffset.QuadPart = (DWORDLONG)0;
		}

		~CPropertyItemStream()
		{
			Cleanup();
		}

		// IUnknown 
		STDMETHODIMP QueryInterface(REFIID, void**);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);

		void Cleanup() {}
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		CPropertyBagStream	*m_pParentBag;

		LPSTR				m_szName;
		ULARGE_INTEGER		m_libOffset;

		long				m_cRef;
};

#endif // USE_PROPERTY_ISTREAM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\route.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

       route.h

   Abstract:

       This file defines functions and types required for
       routing interface library.


   Revision History:

   --*/

#ifndef _ROUTE_H_
#define _ROUTE_H_

#define ROUTING_DLL_NAME                        "abookdb.dll"
#define ROUTING_FUN_INIT                        "AbInitialize"
#define ROUTING_FUN_TERM                        "AbTerminate"
#define ROUTING_FUN_GETMAILROOT                 "AbGetUserMailRoot"
#define ROUTING_FUN_RESOLVEADDRESS              "AbResolveAddress"
#define ROUTING_FUN_GET_RESOLVE_ADDRESS         "AbGetResolveAddress"
#define ROUTING_FUN_END_RESOLVE_ADDRESS         "AbEndResolveAddress"
#define ROUTING_FUN_GETNEXTENUM                 "AbGetNextEnumResult"
#define ROUTING_FUN_ENDENUMRESULT               "AbEndEnumResult"
#define ROUTING_FUN_SETDOMAIN_MAPPING           "AbSetDomainMapping"
#define ROUTING_FUN_GET_ROUTING_DIRECTORY       "AbGetRoutingDirectory"
#define ROUTING_FUN_SET_SOURCES                 "AbSetSources"
#define ROUTING_FUN_VALIDATE_SOURCE             "AbValidateSource"
#define ROUTING_FUN_VALIDATE_NUM_SOURCES        "AbValidateNumSources"

#define ROUTING_FUN_SET_LOCAL_DOMAINS           "AbSetLocalDomains"

#define ROUTING_FUN_CREATE_USER                 "AbCreateUser"
#define ROUTING_FUN_DELETE_USER                 "AbDeleteUser"
#define ROUTING_FUN_SET_FORWARD                 "AbSetForward"
#define ROUTING_FUN_SET_MAILROOT                "AbSetMailRoot"
#define ROUTING_FUN_SET_MAILBOX_SIZE            "AbSetMailboxSize"
#define ROUTING_FUN_SET_MAILBOX_MESSAGE_SIZE    "AbSetMailboxMessageSize"
#define ROUTING_FUN_GET_USER_PROPS              "AbGetUserProps"

#define ROUTING_FUN_CREATE_DL                   "AbCreateDL"
#define ROUTING_FUN_DELETE_DL                   "AbDeleteDL"
#define ROUTING_FUN_CREATE_DL_MEMBER            "AbCreateDLMember"
#define ROUTING_FUN_DELETE_DL_MEMBER            "AbDeleteDLMember"

#define ROUTING_FUN_ENUM_NAME_LIST              "AbEnumNameList"
#define ROUTING_FUN_ENUM_NAME_LIST_FROM_DL      "AbEnumNameListFromDL"
#define ROUTING_FUN_GET_NEXT_EMAIL              "AbGetNextEmail"
#define ROUTING_FUN_END_ENUM_RESULT             "AbEndEnumResult"

#define ROUTING_FUN_GETERRORSTRING              "AbGetErrorString"
#define ROUTING_FUN_ADD_LOCAL_DOMAIN            "AbAddLocalDomain"
#define ROUTING_FUN_ADD_ALIAS_DOMAIN            "AbAddAliasDomain"
#define ROUTING_FUN_DELETE_LOCAL_DOMAIN         "AbDeleteLocalDomain"
#define ROUTING_FUN_DELETE_ALL_LOCAL_DOMAINS    "AbDeleteAllLocalDomains"
#define ROUTING_FUN_ABCANCEL                    "AbCancel"

#define ROUTING_FUN_MAKE_BACKUP                 "AbMakeBackup"
#define ROUTING_FUN_GET_TYPE                    "AbGetType"


#if defined(TDC)
#define ROUTING_FUN_FREE_MEMORY                 "AbFreeMemory"
#define ROUTING_FUN_GET_DL_PROPS                "AbGetDLProps"
#define ROUTING_FUN_GET_NEXT_ENUM_RESULT        "AbGetNextEnumResult"
#endif

#define RtxFlag(i)                      ((0x1) << (i))
#define IsRtxFlagSet(rtxflag, rtxmask)  (((rtxflag) & (rtxmask)) != 0)

#define cbEmailNameMax                  (316)
#define cbVRootMax                      (250)
#define cbDomainMax                     (250)
#define cbSourceMax                     (512)

#define rtxnameUser                     RtxFlag(0)
#define rtxnameDistListNormal           RtxFlag(1)
#define rtxnameDistListExtended         RtxFlag(2)
#define rtxnameDistListSite             RtxFlag(3)
#define rtxnameDistListDomain           RtxFlag(4)
#define rtxnameDistListAll              ( \
                                        rtxnameDistListNormal | \
                                        rtxnameDistListExtended | \
                                        rtxnameDistListSite | \
                                        rtxnameDistListDomain \
                                        )

#define rtxnameAll                      ( \
                                        rtxnameUser | \
                                        rtxnameDistListAll \
                                        )

#define ROUTING_INIT_MAIL_ROOT                  (RtxFlag(1))
#define ROUTING_INIT_USER_CONFIG                (RtxFlag(2))
#define ROUTING_INIT_DL_CONFIG                  (RtxFlag(3))
#define ROUTING_INIT_RESOLVE                    (RtxFlag(4))
#define ROUTING_INIT_SOURCES                    (RtxFlag(5))
#define ROUTING_INIT_DOMAIN                     (RtxFlag(6))
#define ROUTING_INIT_PERF                       (RtxFlag(7))
#define ROUTING_INIT_ENUM                       (RtxFlag(8))
#define ROUTING_INIT_LIST                       (RtxFlag(9))
#define ROUTING_INIT_UTIL                       (RtxFlag(10))
#define ROUTING_INIT_BACKUP                     (RtxFlag(11))


#define ROUTING_INIT_ALL                        ( \
                                                ROUTING_INIT_MAIL_ROOT | \
                                                ROUTING_INIT_USER_CONFIG | \
                                                ROUTING_INIT_DL_CONFIG | \
                                                ROUTING_INIT_RESOLVE | \
                                                ROUTING_INIT_SOURCES | \
                                                ROUTING_INIT_DOMAIN | \
                                                ROUTING_INIT_PERF | \
                                                ROUTING_INIT_ENUM | \
                                                ROUTING_INIT_LIST | \
                                                ROUTING_INIT_UTIL  \
                                                )

enum RTTYPE {rttypeNone, rttypeSQL, rttypeFF, rttypeLDAP};

typedef HANDLE HRTXENUM, *PHRTXENUM;

typedef struct _RTX_DOMAIN_ENTRY
{
    LIST_ENTRY  m_list;
    char        m_szDomain[cbDomainMax];
} RTX_DOMAIN_ENTRY, *PRTX_DOMAIN_ENTRY;

typedef struct _RTX_USER_PROPS
{
    CHAR    szEmail[cbEmailNameMax];
    CHAR    szForward[cbEmailNameMax];
    BOOL    fLocal;
    DWORD   cbMailBoxSize;
    DWORD   cbMailboxMessageSize;
    CHAR    szVRoot[cbVRootMax];
} RTX_USER_PROPS, *LPRTX_USER_PROPS;

/*
typedef struct _RTX_DIST_LIST_PROPS
{
    CHAR    szEmail[cbEmailNameMax];
    DWORD   dwToken;
} RTX_DIST_LIST_PROPS, *LPRTX_DIST_LIST_PROPS;
*/

class CRtx
{
private:
    HINSTANCE                       m_hDll;
    HANDLE                          m_hContext;
    RTTYPE                          m_rttype;

    struct __ROUTINGVTBL__ {
        LPFNAB_INIT                     pfnInit;
        LPFNAB_TERM                     pfnTerm;
        LPFNAB_GET_MAILROOT             pfnGetMailRoot;
        LPFNAB_CREATE_USER              pfnCreateUser;
        LPFNAB_DELETE_USER              pfnDeleteUser;
        LPFNAB_SET_FORWARD              pfnSetForward;
        LPFNAB_SET_MAILROOT             pfnSetVRoot;
        LPFNAB_SET_MAILBOX_SIZE         pfnSetMailboxSize;
        LPFNAB_SET_MAILBOX_MESSAGE_SIZE pfnSetMailboxMessageSize;
        LPFNAB_CREATE_DL                pfnCreateDL;
        LPFNAB_DELETE_DL                pfnDeleteDL;
        LPFNAB_CREATE_DL_MEMBER         pfnCreateDLMember;
        LPFNAB_DELETE_DL_MEMBER         pfnDeleteDLMember;
        LPFNAB_GET_ROUTING_DIRECTORY    pfnGetRoutingDirectory;
        LPFNAB_SET_SOURCES              pfnSetSources;
        LPFNAB_GET_USER_PROPS           pfnGetUserProps;
#if defined(TDC)
        LPFNAB_GET_DL_PROPS             pfnGetDLProps;
#endif
        LPFNAB_ADD_LOCAL_DOMAIN         pfnAddLocalDomain;
        LPFNAB_ADD_ALIAS_DOMAIN         pfnAddAliasDomain;
        LPFNAB_DELETE_LOCAL_DOMAIN      pfnDeleteLocalDomain;
        LPFNAB_DELETE_ALL_LOCAL_DOMAINS pfnDeleteAllLocalDomains;
#if defined(TDC)
        LPFNAB_GET_NEXT_ENUM_RESULT     pfnGetNextEnumResult;
#endif
        LPFNAB_END_ENUM_RESULT          pfnEndEnumResult;
        LPFNAB_ENUM_NAME_LIST           pfnEnumNameList;
        LPFNAB_ENUM_NAME_LIST_FROM_DL   pfnEnumNameListFromDL;
        LPFNAB_GET_NEXT_EMAIL           pfnGetNextEmail;
        LPFNAB_RES_ADDR                 pfnResolveAddress;
        LPFNAB_GET_RES_ADDR             pfnGetResolveAddress;
        LPFNAB_END_RES_ADDR             pfnEndResolveAddress;
#if defined(TDC)
        LPFNAB_FREE_MEMORY              pfnFreeMemory;
#endif
        LPFNAB_GET_ERROR_STRING         pfnGetErrorString;
        LPFNAB_CANCEL                   pfnCancel;
        LPFNAB_MAKE_BACKUP              pfnMakeBackup;
        LPFNAB_GET_TYPE                 pfnGetType;
        LPFNAB_VALIDATE_SOURCE          pfnValidateSource;
        LPFNAB_VALIDATE_NUM_SOURCES     pfnValidateNumSources;
    } m_routingvtbl;


public:
    CRtx() : m_hDll(NULL), m_hContext(NULL), m_rttype(rttypeNone)
    {
        FillMemory(&m_routingvtbl, sizeof(m_routingvtbl), 0xFF);
    }

    ~CRtx() {};

    BOOL            Initialize(LPSTR szDll, LPSTR szDisplayName, LPFNLOGTRANX pfnlogtranx, DWORD dwFlags, PLIST_ENTRY pleDbConfig);
    void            Terminate();
    RTTYPE          GetRtType() { return m_rttype; }
    BOOL            AddOptionalEntryPoints(DWORD dwFlags);

    BOOL            GetMailRoot(LPSTR szUser, LPSTR szMoniker, DWORD *pcbMoniker);

    BOOL            CreateUser(LPSTR szEmail, LPSTR szForward, BOOL fLocalUser, LPSTR szVRoot, DWORD cbMailboxMax, DWORD cbMailboxMessageMax);
    BOOL            DeleteUser(LPSTR szEmail);
    BOOL            GetUserProps(LPSTR szEmail, RTX_USER_PROPS *pUserProps);
    BOOL            SetForward(LPSTR szEmail, LPSTR szForward);
    BOOL            SetMailboxSize(LPSTR szEmail, DWORD cbMailboxMax);
    BOOL            SetMailboxMessageSize(LPSTR szEmail, DWORD cbMailboxMessageMax);
    BOOL            SetVRoot(LPSTR szEmail, LPSTR szVRoot);

    BOOL            CreateDistList(LPSTR szEmail, DWORD dwType);
    BOOL            DeleteDistList(LPSTR szEmail);
    BOOL            CreateDistListMember(LPSTR szEmail, LPSTR szMember);
    BOOL            DeleteDistListMember(LPSTR szEmail, LPSTR szMember);

    BOOL            GetRoutingDirectory(LPSTR szDll, PLIST_ENTRY pleSources, LPSTR szDirectory);
    BOOL            SetSources(PLIST_ENTRY pHead);
    BOOL            ValidateSource(LPSTR szSource);
    BOOL            ValidateNumSources(DWORD dwNumSources);

    BOOL            AddLocalDomain(LPSTR szName);
    BOOL            AddAliasDomain(LPSTR szName, LPSTR szAlias);
    BOOL            DeleteLocalDomain(LPSTR szName);
    BOOL            DeleteAllLocalDomains();

    BOOL            EnumNameList(LPSTR szEmail, BOOL fForward, DWORD crowsReq, DWORD dwFlags, PHRTXENUM phrtxenum);
    BOOL            EnumNameListFromDL(LPSTR szEmailDL, LPSTR szEmail, BOOL fForward, DWORD crowsReq, DWORD dwFlags, PHRTXENUM phrtxenum);
    BOOL            GetNextEmail(HRTXENUM hrtxenum, DWORD *pdwType, LPSTR szEmail);
#if defined(TDC)
    BOOL            GetNextEnumResult(HRTXENUM hrtxenum, LPVOID pvBuf, LPDWORD pcbBuf);
#endif
    BOOL            EndEnumResult(HRTXENUM hrtxenum);

    DWORD           EnumRowsReturned(HRTXENUM hrtxenum);

    BOOL            FreeHrtxenum(HRTXENUM hrtxtenum);

#if defined(TDC)
    BOOL            FreeMemory(PABROUTING pabrouting);
#endif
    BOOL            GetErrorString(DWORD dwErr, LPSTR lpBuf, DWORD cbBufSize);

    BOOL            ResolveAddress(PLIST_ENTRY HeadOfList, PABADDRSTAT pabAddrStat, PABROUTING pabrouting, PABRESOLVE pabresolve);
    BOOL            GetResolveAddress(PABRESOLVE pabresolve, PABROUTING pabrouting);
    BOOL            EndResolveAddress(PABRESOLVE pabresolve);
    BOOL            Cancel(void);

    BOOL            MakeBackup(LPSTR szDirectory);

#if defined(TDC)
    LPFNAB_FREE_MEMORY PfnFreeMemory() { return m_routingvtbl.pfnFreeMemory; }
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\smtpdata.h ===
//#---------------------------------------------------------------
//  File:       smtpdata.h
//
//  Synopsis:   Extensible object definitions for the SMTP
//              Server's counter objects & counters.
//
//  Copyright (C) 1995 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on msn sources by rkamicar, keithmo
//              dhowell - added Instance Support for K2
//----------------------------------------------------------------

#ifndef _SMTPDATA_H_
#define _SMTPDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any unsigned __int64s that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _SMTP_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    unsigned __int64    DummyEntryForAlignmentPurposesOnly;

} SMTP_COUNTER_BLOCK;


#define         INSTANCE_NAME_SIZE      20

typedef WCHAR   SMTP_INSTANCE_NAME[INSTANCE_NAME_SIZE];

typedef struct _SMTP_INSTANCE_DEFINITION
{   
    PERF_INSTANCE_DEFINITION    PerfInstanceDef;
    SMTP_INSTANCE_NAME          InstanceName;
} SMTP_INSTANCE_DEFINITION;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define SMTP_BYTES_SENT_TTL_OFFSET                  sizeof(SMTP_COUNTER_BLOCK)
#define SMTP_BYTES_SENT_PER_SEC_OFFSET              (SMTP_BYTES_SENT_TTL_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_TTL_OFFSET                  (SMTP_BYTES_SENT_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_PER_SEC_OFFSET              (SMTP_BYTES_RCVD_TTL_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_TTL_OFFSET                       (SMTP_BYTES_RCVD_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_TTL_PER_SEC_OFFSET               (SMTP_BYTES_TTL_OFFSET + sizeof(unsigned __int64))

#define SMTP_BYTES_SENT_MSG_OFFSET                  (SMTP_BYTES_TTL_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET          (SMTP_BYTES_SENT_MSG_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_MSG_OFFSET                  (SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET          (SMTP_BYTES_RCVD_MSG_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_MSG_OFFSET                       (SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_MSG_PER_SEC_OFFSET               (SMTP_BYTES_MSG_OFFSET + sizeof(unsigned __int64))

#define SMTP_MSG_RCVD_TTL_OFFSET                    (SMTP_BYTES_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_MSG_RCVD_PER_SEC_OFFSET                (SMTP_MSG_RCVD_TTL_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET          (SMTP_MSG_RCVD_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET     (SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET      (SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET (SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET      (SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET (SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET           (SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET          (SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET           (SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET + sizeof(DWORD))


#define SMTP_MSG_DLVR_TTL_OFFSET                    (SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_DLVR_PER_SEC_OFFSET                (SMTP_MSG_DLVR_TTL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_DLVR_RETRIES_TTL_OFFSET            (SMTP_MSG_DLVR_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET        (SMTP_MSG_DLVR_RETRIES_TTL_OFFSET + sizeof(DWORD))      
#define SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET   (SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET + sizeof(DWORD))
#define SMTP_MSG_FWD_TTL_OFFSET                     (SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET + sizeof(DWORD))
#define SMTP_MSG_FWD_PER_SEC_OFFSET                 (SMTP_MSG_FWD_TTL_OFFSET + sizeof(DWORD))
#define SMTP_NDR_GENERATED_OFFSET                   (SMTP_MSG_FWD_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_LOCALQ_LENGTH_OFFSET                   (SMTP_NDR_GENERATED_OFFSET + sizeof(DWORD))
#define SMTP_RETRYQ_LENGTH_OFFSET                   (SMTP_LOCALQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_NUM_MAILFILE_HANDLES_OFFSET            (SMTP_RETRYQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_NUM_QUEUEFILE_HANDLES_OFFSET           (SMTP_NUM_MAILFILE_HANDLES_OFFSET + sizeof(DWORD))              
#define SMTP_CATQ_LENGTH_OFFSET                     (SMTP_NUM_QUEUEFILE_HANDLES_OFFSET + sizeof(DWORD))

#define SMTP_MSG_SENT_TTL_OFFSET                    (SMTP_CATQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_MSG_SENT_PER_SEC_OFFSET                (SMTP_MSG_SENT_TTL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_SEND_RETRIES_TTL_OFFSET            (SMTP_MSG_SENT_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET        (SMTP_MSG_SEND_RETRIES_TTL_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET   (SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET          (SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET     (SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET + sizeof(DWORD))
#define SMTP_REMOTEQ_LENGTH_OFFSET                  (SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET + sizeof(DWORD))

#define SMTP_DNS_QUERIES_TTL_OFFSET                 (SMTP_REMOTEQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_DNS_QUERIES_PER_SEC_OFFSET             (SMTP_DNS_QUERIES_TTL_OFFSET + sizeof(DWORD))
#define SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET       (SMTP_DNS_QUERIES_PER_SEC_OFFSET + sizeof(DWORD))

#define SMTP_CONN_IN_TTL_OFFSET                     (SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_CONN_IN_CURR_OFFSET                    (SMTP_CONN_IN_TTL_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_TTL_OFFSET                    (SMTP_CONN_IN_CURR_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_CURR_OFFSET                   (SMTP_CONN_OUT_TTL_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_REFUSED_OFFSET                (SMTP_CONN_OUT_CURR_OFFSET + sizeof(DWORD))

#define SMTP_ERR_TTL_OFFSET                         (SMTP_CONN_OUT_REFUSED_OFFSET + sizeof(DWORD))
#define SMTP_ERR_PER_SEC_OFFSET                     (SMTP_ERR_TTL_OFFSET + sizeof(DWORD))

/*** HIT A COMPILER LIMIT ON OPEN BRACKETS, HAD TO REMOVE SOME BRAKETS ***/

#define SMTP_DIR_DROPS_OFFSET                       SMTP_ERR_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_DIR_DROPS_PER_SEC_OFFSET               SMTP_DIR_DROPS_OFFSET + sizeof(DWORD)
#define SMTP_RT_LOOKUPS_OFFSET                      SMTP_DIR_DROPS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_RT_LOOKUPS_PER_SEC_OFFSET              SMTP_RT_LOOKUPS_OFFSET + sizeof(DWORD)
#define SMTP_ETRN_MSGS_OFFSET                       SMTP_RT_LOOKUPS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_ETRN_MSGS_PER_SEC_OFFSET               SMTP_ETRN_MSGS_OFFSET + sizeof(DWORD)

#define SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET       SMTP_ETRN_MSGS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET  SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET     SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET + sizeof(DWORD)             
#define SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET     SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_EVENT_OFFSET               SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET          SMTP_MSG_BADMAIL_EVENT_OFFSET + sizeof(DWORD)
#define SMTP_MSG_PENDING_ROUTING_OFFSET             SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET + sizeof(DWORD)
#define SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET    SMTP_MSG_PENDING_ROUTING_OFFSET + sizeof(DWORD)
#define SMTP_SUBMITTED_MESSAGES_OFFSET              SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET + sizeof(DWORD)
#define SMTP_DSN_FAILURES_OFFSET                    SMTP_SUBMITTED_MESSAGES_OFFSET + sizeof(DWORD)
#define SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET           SMTP_DSN_FAILURES_OFFSET + sizeof(DWORD)

#define SMTP_CATSUBMISSIONS_OFFSET                  SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET + sizeof(DWORD)
#define SMTP_CATCOMPLETIONS_OFFSET                  SMTP_CATSUBMISSIONS_OFFSET + sizeof(DWORD)
#define SMTP_CURRENTCATEGORIZATIONS_OFFSET          SMTP_CATCOMPLETIONS_OFFSET + sizeof(DWORD)
#define SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET        SMTP_CURRENTCATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_HARDFAILURECATEGORIZATIONS_OFFSET      SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET     SMTP_HARDFAILURECATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYOUTOFMEMORY_OFFSET                SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYDSLOGON_OFFSET                    SMTP_RETRYOUTOFMEMORY_OFFSET + sizeof(DWORD)
#define SMTP_RETRYDSCONNECTION_OFFSET               SMTP_RETRYDSLOGON_OFFSET + sizeof(DWORD)
#define SMTP_RETRYGENERIC_OFFSET                    SMTP_RETRYDSCONNECTION_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET     SMTP_RETRYGENERIC_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESCREATED_OFFSET                 SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESABORTED_OFFSET                 SMTP_MESSAGESCREATED_OFFSET + sizeof(DWORD)
#define SMTP_PRECATRECIPIENTS_OFFSET                SMTP_MESSAGESABORTED_OFFSET + sizeof(DWORD)
#define SMTP_POSTCATRECIPIENTS_OFFSET               SMTP_PRECATRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_NDRDRECIPIENTS_OFFSET                  SMTP_POSTCATRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_UNRESOLVEDRECIPIENTS_OFFSET            SMTP_NDRDRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_AMBIGUOUSRECIPIENTS_OFFSET             SMTP_UNRESOLVEDRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_ILLEGALRECIPIENTS_OFFSET               SMTP_AMBIGUOUSRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_LOOPRECIPIENTS_OFFSET                  SMTP_ILLEGALRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_GENERICFAILURERECIPIENTS_OFFSET        SMTP_LOOPRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_RECIPSINMEMORY_OFFSET                  SMTP_GENERICFAILURERECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_UNRESOLVEDSENDERS_OFFSET               SMTP_RECIPSINMEMORY_OFFSET + sizeof(DWORD)
#define SMTP_AMBIGUOUSSENDERS_OFFSET                SMTP_UNRESOLVEDSENDERS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPS_OFFSET                  SMTP_AMBIGUOUSSENDERS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET        SMTP_ADDRESSLOOKUPS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET          SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET + sizeof(DWORD)
#define SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET      SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET + sizeof(DWORD)
#define SMTP_CONNECTIONS_OFFSET                     SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET + sizeof(DWORD)
#define SMTP_CONNECTFAILURES_OFFSET                 SMTP_CONNECTIONS_OFFSET + sizeof(DWORD)
#define SMTP_OPENCONNECTIONS_OFFSET                 SMTP_CONNECTFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_BINDS_OFFSET                           SMTP_OPENCONNECTIONS_OFFSET + sizeof(DWORD)
#define SMTP_BINDFAILURES_OFFSET                    SMTP_BINDS_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHES_OFFSET                        SMTP_BINDFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHES_OFFSET                   SMTP_SEARCHES_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHFAILURES_OFFSET                  SMTP_PAGEDSEARCHES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHFAILURES_OFFSET             SMTP_SEARCHFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHESCOMPLETED_OFFSET               SMTP_PAGEDSEARCHFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHESCOMPLETED_OFFSET          SMTP_SEARCHESCOMPLETED_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHCOMPLETIONFAILURES_OFFSET        SMTP_PAGEDSEARCHESCOMPLETED_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET   SMTP_SEARCHCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_GENERALCOMPLETIONFAILURES_OFFSET       SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_ABANDONEDSEARCHES_OFFSET               SMTP_GENERALCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PENDINGSEARCHES_OFFSET                 SMTP_ABANDONEDSEARCHES_OFFSET + sizeof(DWORD)
// This needs to be here to pad out the number of bytes returned to 
// be divisible by 8.  If you add new counters please check eventvwr to 
// make sure that you don't have warnings from Perflib saying that your
// counters aren't properly padded.  If you do get these warnings then
// comment out this item
#define SMTP_PADDING_OFFSET                         SMTP_PENDINGSEARCHES_OFFSET + sizeof(DWORD)

#define SIZE_OF_SMTP_PERFORMANCE_DATA               SMTP_PADDING_OFFSET + sizeof(DWORD)


//
//  The counter structure returned.
//

typedef struct _SMTP_DATA_DEFINITION
{
    PERF_OBJECT_TYPE        SmtpObjectType;
    PERF_COUNTER_DEFINITION SmtpBytesSentTtl;
    PERF_COUNTER_DEFINITION SmtpBytesSentPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdTtl;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesTtl;
    PERF_COUNTER_DEFINITION SmtpBytesTtlPerSec;

    PERF_COUNTER_DEFINITION SmtpBytesSentMsg;
    PERF_COUNTER_DEFINITION SmtpBytesSentMsgPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdMsg;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdMsgPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesMsg;
    PERF_COUNTER_DEFINITION SmtpBytesMsgPerSec;

    PERF_COUNTER_DEFINITION SmtpMsgRcvdTtl;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdPerSec;
    PERF_COUNTER_DEFINITION SmtpAvgRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpPctLclRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBasePctLclRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpPctRmtRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBasePctRmtRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedSize;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedCAddr;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedMail;

    PERF_COUNTER_DEFINITION SmtpMsgDlvrTtl;
    PERF_COUNTER_DEFINITION SmtpMsgDlvrPerSec;
    PERF_COUNTER_DEFINITION SmtpMsgDlvrRetriesTtl;
    PERF_COUNTER_DEFINITION SmtpAvgRetriesPerMsgDlvr;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRetriesPerMsgDlvr;
    PERF_COUNTER_DEFINITION SmtpMsgFwdTtl;
    PERF_COUNTER_DEFINITION SmtpMsgFwdPerSec;
    PERF_COUNTER_DEFINITION SmtpNdrGenerated;
    PERF_COUNTER_DEFINITION SmtpLocalQLength;
    PERF_COUNTER_DEFINITION SmtpRetryQLength;
    PERF_COUNTER_DEFINITION SmtpNumMailFileHandles;
    PERF_COUNTER_DEFINITION SmtpNumQueueFileHandles;
    PERF_COUNTER_DEFINITION SmtpCatQLength;

    PERF_COUNTER_DEFINITION SmtpMsgSentTtl;
    PERF_COUNTER_DEFINITION SmtpMsgSentPerSec;
    PERF_COUNTER_DEFINITION SmtpMsgSendRetriesTtl;
    PERF_COUNTER_DEFINITION SmtpAvgRetriesPerMsgSend;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRetriesPerMsgSend;
    PERF_COUNTER_DEFINITION SmtpAvgRcptsPerMsgSent;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRcptsPerMsgSent;
    PERF_COUNTER_DEFINITION SmtpRemoteQLength;

    PERF_COUNTER_DEFINITION SmtpDnsQueriesTtl;
    PERF_COUNTER_DEFINITION SmtpDnsQueriesPerSec;
    PERF_COUNTER_DEFINITION SmtpRemoteRetryQueueLength;

    PERF_COUNTER_DEFINITION SmtpConnInTtl;
    PERF_COUNTER_DEFINITION SmtpConnInCurr;
    PERF_COUNTER_DEFINITION SmtpConnOutTtl;
    PERF_COUNTER_DEFINITION SmtpConnOutCurr;
    PERF_COUNTER_DEFINITION SmtpConnOutRefused;

    PERF_COUNTER_DEFINITION SmtpErrTtl;
    PERF_COUNTER_DEFINITION SmtpErrPerSec;
        
    PERF_COUNTER_DEFINITION SmtpDirectoryDropsTtl;
    PERF_COUNTER_DEFINITION SmtpDirectoryDropsPerSec;
    PERF_COUNTER_DEFINITION SmtpRoutingTblLookupsTtl;
    PERF_COUNTER_DEFINITION SmtpRoutingTblLookupsPerSec;
    PERF_COUNTER_DEFINITION SmtpETRNMsgsTtl;
    PERF_COUNTER_DEFINITION SmtpETRNMsgsPerSec;

    PERF_COUNTER_DEFINITION MsgsBadmailNoRecipients;
    PERF_COUNTER_DEFINITION MsgsBadmailHopCountExceeded;
    PERF_COUNTER_DEFINITION MsgsBadmailFailureGeneral;
    PERF_COUNTER_DEFINITION MsgsBadmailBadPickupFile;
    PERF_COUNTER_DEFINITION MsgsBadmailEvent;
    PERF_COUNTER_DEFINITION MsgsBadmailNdrOfDsn;
    PERF_COUNTER_DEFINITION MsgsPendingRouting;
    PERF_COUNTER_DEFINITION MsgsPendingUnreachableLink;
    PERF_COUNTER_DEFINITION SubmittedMessages;
    PERF_COUNTER_DEFINITION DSNFailures;
    PERF_COUNTER_DEFINITION MsgsInLocalDelivery;

    PERF_COUNTER_DEFINITION CatSubmissions;
    PERF_COUNTER_DEFINITION CatSubmissionsPerSec;
    PERF_COUNTER_DEFINITION CatCompletions;
    PERF_COUNTER_DEFINITION CatCompletionsPerSec;
    PERF_COUNTER_DEFINITION CatCurrentCategorizations;
    PERF_COUNTER_DEFINITION CatSucceededCategorizations;
    PERF_COUNTER_DEFINITION CatHardFailures;
    PERF_COUNTER_DEFINITION CatRetryFailures;
    PERF_COUNTER_DEFINITION CatOutOfMemoryFailures;
    PERF_COUNTER_DEFINITION CatDsLogonFailures;
    PERF_COUNTER_DEFINITION CatDsConnectionFailures;
    PERF_COUNTER_DEFINITION CatGenericRetryFailures;
    PERF_COUNTER_DEFINITION CatMsgsOut;
    PERF_COUNTER_DEFINITION CatMsgsCreated;
    PERF_COUNTER_DEFINITION CatMsgsAborted;
    PERF_COUNTER_DEFINITION CatRecipsPreCat;
    PERF_COUNTER_DEFINITION CatRecipsPostCat;
    PERF_COUNTER_DEFINITION CatRecipsNDRd;
    PERF_COUNTER_DEFINITION CatRecipsUnresolved;
    PERF_COUNTER_DEFINITION CatRecipsAmbiguous;
    PERF_COUNTER_DEFINITION CatRecipsIllegal;
    PERF_COUNTER_DEFINITION CatRecipsLoop;
    PERF_COUNTER_DEFINITION CatRecipsGenericFailure;
    PERF_COUNTER_DEFINITION CatRecipsInMemory;
    PERF_COUNTER_DEFINITION CatSendersUnresolved;
    PERF_COUNTER_DEFINITION CatSendersAmbiguous;
    PERF_COUNTER_DEFINITION CatAddressLookups;
    PERF_COUNTER_DEFINITION CatAddressLookupsPerSec;
    PERF_COUNTER_DEFINITION CatAddressCompletions;
    PERF_COUNTER_DEFINITION CatAddressCompletionsPerSec;
    PERF_COUNTER_DEFINITION CatAddressLookupsNotFound;
    PERF_COUNTER_DEFINITION CatMailMsgDuplicateCollisions;
    PERF_COUNTER_DEFINITION CatLDAPConnections;
    PERF_COUNTER_DEFINITION CatLDAPConnectionFailures;
    PERF_COUNTER_DEFINITION CatLDAPOpenConnections;
    PERF_COUNTER_DEFINITION CatLDAPBinds;
    PERF_COUNTER_DEFINITION CatLDAPBindFailures;
    PERF_COUNTER_DEFINITION CatLDAPSearches;
    PERF_COUNTER_DEFINITION CatLDAPSearchesPerSec;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearches;
    PERF_COUNTER_DEFINITION CatLDAPSearchFailures;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchFailures;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompleted;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompletedPerSec;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchesCompleted;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompeltedFailure;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchesCompletedFailure;
    PERF_COUNTER_DEFINITION CatLDAPGeneralCompletionFailure;
    PERF_COUNTER_DEFINITION CatLDAPAbandonedSearches;
    PERF_COUNTER_DEFINITION CatLDAPPendingSearches;

} SMTP_DATA_DEFINITION;


extern  SMTP_DATA_DEFINITION        SmtpDataDefinition;
extern  SMTP_INSTANCE_DEFINITION    SmtpInstanceDefinition;

#define NUMBER_OF_SMTP_COUNTERS ((sizeof(SMTP_DATA_DEFINITION) -        \
                                sizeof(PERF_OBJECT_TYPE)) /     \
                                sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _SMTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\smtpapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpapi.h

Abstract:

    This file contains information about the MSN SMTP server counters

Author:

    Johnson Apacible (johnsona)         10-Sept-1995
    Rohan Phillips (Rohanp)             11-Dec-1995

--*/


#ifndef _SMTPAPI_
#define _SMTPAPI_

#ifdef __cplusplus
extern "C" {
#endif

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

#include "smtpext.h"
#include "perfcat.h"

//
// Config Structures and API's

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

#define NAME_TYPE_USER                  (BitFlag(0))
#define NAME_TYPE_LIST_NORMAL           (BitFlag(1))
#define NAME_TYPE_LIST_DOMAIN           (BitFlag(2))
#define NAME_TYPE_LIST_SITE             (BitFlag(3))

#define NAME_TYPE_ALL                   ( \
                                        NAME_TYPE_USER | \
                                        NAME_TYPE_LIST_NORMAL | \
                                        NAME_TYPE_LIST_DOMAIN | \
                                        NAME_TYPE_LIST_SITE \
                                        )

typedef struct _SMTP_NAME_ENTRY
{
    DWORD       dwType;
    LPWSTR      lpszName;
} SMTP_NAME_ENTRY, *LPSMTP_NAME_ENTRY;


typedef struct _SMTP_NAME_LIST
{
    DWORD       cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_NAME_ENTRY aNameEntry[];
} SMTP_NAME_LIST, *LPSMTP_NAME_LIST;


typedef struct _SMTP_CONN_USER_ENTRY
{
    DWORD       dwUserId;
    LPWSTR      lpszName;
    LPWSTR      lpszHost;
    DWORD       dwConnectTime;
} SMTP_CONN_USER_ENTRY, *LPSMTP_CONN_USER_ENTRY;

typedef struct _SMTP_CONN_USER_LIST
{
    DWORD           cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONN_USER_ENTRY    aConnUserEntry[];
} SMTP_CONN_USER_LIST, *LPSMTP_CONN_USER_LIST;

typedef struct _SMTP_CONFIG_DOMAIN_ENTRY
{
    LPWSTR          lpszDomain;
} SMTP_CONFIG_DOMAIN_ENTRY, *LPSMTP_CONFIG_DOMAIN_ENTRY;

typedef struct _SMTP_CONFIG_DOMAIN_LIST
{
    DWORD           cEntries;                   // Count of supported domains
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONFIG_DOMAIN_ENTRY    aDomainEntry[]; // Supported domains
} SMTP_CONFIG_DOMAIN_LIST, *LPSMTP_CONFIG_DOMAIN_LIST;


typedef struct _SMTP_CONFIG_ROUTING_ENTRY
{
    LPWSTR          lpszSource;
} SMTP_CONFIG_ROUTING_ENTRY, *LPSMTP_CONFIG_ROUTING_ENTRY;


typedef struct _SMTP_CONFIG_ROUTING_LIST
{
    DWORD           cEntries;               // Count of supported data sources
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONFIG_ROUTING_ENTRY   aRoutingEntry[];
} SMTP_CONFIG_ROUTING_LIST, *LPSMTP_CONFIG_ROUTING_LIST;


// 0 - Perfmon stats

typedef struct _SMTP_STATISTICS_0
{

    // total bytes sent/received, including protocol msgs

    unsigned __int64    BytesSentTotal;
    unsigned __int64    BytesRcvdTotal;
    unsigned __int64    BytesSentMsg;
    unsigned __int64    BytesRcvdMsg;

    //incoming counters
    DWORD               NumMsgRecvd;
    DWORD               NumRcptsRecvd;
    DWORD               NumRcptsRecvdLocal;
    DWORD               NumRcptsRecvdRemote;
    DWORD               MsgsRefusedDueToSize;
    DWORD               MsgsRefusedDueToNoCAddrObjects;
    DWORD               MsgsRefusedDueToNoMailObjects;

    //MTA counters
    DWORD               NumMsgsDelivered;
    DWORD               NumDeliveryRetries;
    DWORD               NumMsgsForwarded;
    DWORD               NumNDRGenerated;
    DWORD               LocalQueueLength;
    DWORD               RetryQueueLength;
    DWORD               NumMailFileHandles;
    DWORD               NumQueueFileHandles;
    DWORD               CatQueueLength;

    //outgoing counters
    DWORD               NumMsgsSent;
    DWORD               NumRcptsSent;
    DWORD               NumSendRetries;
    DWORD               RemoteQueueLength;

    //DNS query counters
    DWORD               NumDnsQueries;
    DWORD               RemoteRetryQueueLength;

    //connection counters
    DWORD               NumConnInOpen;
    DWORD               NumConnInClose;
    DWORD               NumConnOutOpen;
    DWORD               NumConnOutClose;
    DWORD               NumConnOutRefused;

    // other counters
    DWORD               NumProtocolErrs;
    DWORD               DirectoryDrops;
    DWORD               RoutingTableLookups;
    DWORD               ETRNMessages;

    DWORD               MsgsBadmailNoRecipients;
    DWORD               MsgsBadmailHopCountExceeded;
    DWORD               MsgsBadmailFailureGeneral;
    DWORD               MsgsBadmailBadPickupFile;
    DWORD               MsgsBadmailEvent;
    DWORD               MsgsBadmailNdrOfDsn;
    DWORD               MsgsPendingRouting;
    DWORD               MsgsPendingUnreachableLink;
    DWORD               SubmittedMessages;
    DWORD               DSNFailures;
    DWORD               MsgsInLocalDelivery;

    CATPERFBLOCK        CatPerfBlock;

    DWORD               TimeOfLastClear;        // statistics last cleared

} SMTP_STATISTICS_0, *LPSMTP_STATISTICS_0;



typedef struct _SMTP_STATISTICS_BLOCK
{
    DWORD               dwInstance;
    SMTP_STATISTICS_0   Stats_0;
} SMTP_STATISTICS_BLOCK, *PSMTP_STATISTICS_BLOCK;


typedef struct _SMTP_STATISTICS_BLOCK_ARRAY
{
    DWORD           cEntries;                   // Count of instances of statistics
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_STATISTICS_BLOCK       aStatsBlock[];
} SMTP_STATISTICS_BLOCK_ARRAY, *PSMTP_STATISTICS_BLOCK_ARRAY;



#pragma warning(default:4200)

//
// Cut by keithlau on 7/8/96
//
// #define FC_SMTP_INFO_LOOP_BACK               ((FIELD_CONTROL)BitFlag(0))
// #define FC_SMTP_INFO_BACK_LOG                ((FIELD_CONTROL)BitFlag(1))
// #define FC_SMTP_INFO_MAX_OBJECTS             ((FIELD_CONTROL)BitFlag(6))
// #define FC_SMTP_INFO_DOMAIN                  ((FIELD_CONTROL)BitFlag(12))
// #define FC_SMTP_INFO_DELIVERY                ((FIELD_CONTROL)BitFlag(17))
// #define FC_SMTP_INFO_BAD_MAIL                ((FIELD_CONTROL)BitFlag(19))
// #define FC_SMTP_INFO_MAIL_QUEUE_DIR          ((FIELD_CONTROL)BitFlag(20))
// #define FC_SMTP_INFO_FILELINKS               ((FIELD_CONTROL)BitFlag(21))
// #define FC_SMTP_INFO_BATCHMSGS               ((FIELD_CONTROL)BitFlag(22))
// #define FC_SMTP_INFO_ROUTING_DLL             ((FIELD_CONTROL)BitFlag(23))
// #define FC_SMTP_INFO_MAIL_PICKUP_DIR         ((FIELD_CONTROL)BitFlag(25))

#define FC_SMTP_INFO_REVERSE_LOOKUP         ((FIELD_CONTROL)BitFlag(0))
#define FC_SMTP_INFO_MAX_HOP_COUNT          ((FIELD_CONTROL)BitFlag(1))
#define FC_SMTP_INFO_MAX_ERRORS             ((FIELD_CONTROL)BitFlag(2))
#define FC_SMTP_INFO_MAX_SIZE               ((FIELD_CONTROL)BitFlag(3))
#define FC_SMTP_INFO_REMOTE_TIMEOUT         ((FIELD_CONTROL)BitFlag(4))
#define FC_SMTP_INFO_MAX_OUTBOUND_CONN      ((FIELD_CONTROL)BitFlag(5))
#define FC_SMTP_INFO_MAX_RECIPS             ((FIELD_CONTROL)BitFlag(6))
#define FC_SMTP_INFO_RETRY                  ((FIELD_CONTROL)BitFlag(7))
#define FC_SMTP_INFO_PIPELINE               ((FIELD_CONTROL)BitFlag(8))
#define FC_SMTP_INFO_OBSOLETE_ROUTING       ((FIELD_CONTROL)BitFlag(9))
#define FC_SMTP_INFO_SEND_TO_ADMIN          ((FIELD_CONTROL)BitFlag(10))
#define FC_SMTP_INFO_SMART_HOST             ((FIELD_CONTROL)BitFlag(11))
#define FC_SMTP_INFO_AUTHORIZATION          ((FIELD_CONTROL)BitFlag(12))
#define FC_SMTP_INFO_COMMON_PARAMS          ((FIELD_CONTROL)BitFlag(13))
#define FC_SMTP_INFO_DEFAULT_DOMAIN         ((FIELD_CONTROL)BitFlag(14))
#define FC_SMTP_INFO_ROUTING                ((FIELD_CONTROL)BitFlag(15))

//
// Added by keithlau on 7/8/96
//
#define FC_SMTP_INFO_BAD_MAIL_DIR           ((FIELD_CONTROL)BitFlag(15))
#define FC_SMTP_INFO_MASQUERADE             ((FIELD_CONTROL)BitFlag(16))
#define FC_SMTP_INFO_REMOTE_PORT            ((FIELD_CONTROL)BitFlag(17))
#define FC_SMTP_INFO_LOCAL_DOMAINS          ((FIELD_CONTROL)BitFlag(18))
#define FC_SMTP_INFO_DOMAIN_ROUTING         ((FIELD_CONTROL)BitFlag(19))
#define FC_SMTP_INFO_ADMIN_EMAIL_NAME       ((FIELD_CONTROL)BitFlag(20))
#define FC_SMTP_INFO_ALWAYS_USE_SSL         ((FIELD_CONTROL)BitFlag(21))
#define FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN ((FIELD_CONTROL)BitFlag(22))
#define FC_SMTP_INFO_SASL_LOGON_DOMAIN      ((FIELD_CONTROL)BitFlag(23))
#define FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS ((FIELD_CONTROL)BitFlag(24))
#define FC_SMTP_INFO_DEFAULT_DROP_DIR       ((FIELD_CONTROL)BitFlag(25))
#define FC_SMTP_INFO_FQDN                   ((FIELD_CONTROL)BitFlag(26))
#define FC_SMTP_INFO_ETRN_SUBDOMAINS        ((FIELD_CONTROL)BitFlag(27))
#define FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS ((FIELD_CONTROL)BitFlag(29))
#define FC_SMTP_CLEARTEXT_AUTH_PROVIDER     ((FIELD_CONTROL)BitFlag(30))

//
// Added by mlans on 7/24/96
//
#define FC_SMTP_INFO_SSL_PERM               ((FIELD_CONTROL)BitFlag(28))

#define FC_SMTP_ROUTING_TYPE_FILTER         ((FIELD_CONTROL)(BitFlag(30) | BitFlag(31)))
#define FC_SMTP_ROUTING_TYPE_SQL            ((FIELD_CONTROL)(0)))
#define FC_SMTP_ROUTING_TYPE_FF             ((FIELD_CONTROL)BitFlag(30))
#define FC_SMTP_ROUTING_TYPE_LDAP           ((FIELD_CONTROL)BitFlag(31))


#define FC_SMTP_INFO_ALL                    ( \
                                            FC_SMTP_INFO_REVERSE_LOOKUP | \
                                            FC_SMTP_INFO_MAX_HOP_COUNT | \
                                            FC_SMTP_INFO_MAX_ERRORS | \
                                            FC_SMTP_INFO_MAX_SIZE | \
                                            FC_SMTP_INFO_REMOTE_TIMEOUT | \
                                            FC_SMTP_INFO_MAX_OUTBOUND_CONN | \
                                            FC_SMTP_INFO_MAX_RECIPS | \
                                            FC_SMTP_INFO_RETRY | \
                                            FC_SMTP_INFO_PIPELINE | \
                                            FC_SMTP_INFO_ROUTING | \
                                            FC_SMTP_INFO_OBSOLETE_ROUTING | \
                                            FC_SMTP_INFO_SEND_TO_ADMIN | \
                                            FC_SMTP_INFO_SMART_HOST | \
                                            FC_SMTP_INFO_COMMON_PARAMS | \
                                            FC_SMTP_INFO_DEFAULT_DOMAIN | \
                                            FC_SMTP_INFO_BAD_MAIL_DIR  | \
                                            FC_SMTP_INFO_MASQUERADE | \
                                            FC_SMTP_INFO_LOCAL_DOMAINS | \
                                            FC_SMTP_INFO_REMOTE_PORT | \
                                            FC_SMTP_INFO_DOMAIN_ROUTING |\
                                            FC_SMTP_INFO_ADMIN_EMAIL_NAME |\
                                            FC_SMTP_INFO_ALWAYS_USE_SSL |\
                                            FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN |\
                                            FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS |\
                                            FC_SMTP_INFO_DEFAULT_DROP_DIR |\
                                            FC_SMTP_INFO_FQDN |\
                                            FC_SMTP_INFO_ETRN_SUBDOMAINS |\
                                            FC_SMTP_INFO_SSL_PERM |\
                                            FC_SMTP_INFO_AUTHORIZATION |\
                                            FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS |\
                                            FC_SMTP_INFO_SASL_LOGON_DOMAIN |\
                                            FC_SMTP_CLEARTEXT_AUTH_PROVIDER \
                                            )

//
// Cut out from FC_SMTP_INFO_ALL by keithlau on 7/8/96
//
/*
 *
                                            FC_SMTP_INFO_LOOP_BACK | \
                                            FC_SMTP_INFO_BACK_LOG | \
                                            FC_SMTP_INFO_MAX_OBJECTS | \
                                            FC_SMTP_INFO_DELIVERY | \
                                            FC_SMTP_INFO_BAD_MAIL | \
                                            FC_SMTP_INFO_DOMAIN | \
                                            FC_SMTP_INFO_MAIL_QUEUE_DIR | \
                                            FC_SMTP_INFO_FILELINKS | \
                                            FC_SMTP_INFO_BATCHMSGS | \
                                            FC_SMTP_INFO_ROUTING_DLL | \
                                            FC_SMTP_INFO_MAIL_PICKUP_DIR \
 *
 */

typedef struct _SMTP_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    //
    // Removed by keithlau on 7/8/96
    //
    // DWORD            dwCheckLoopBack;            // Make sure we're not sending to ourself
    // DWORD            dwLocalBackLog;             //
    // DWORD            dwRemoteBackLog;            //
    // DWORD            dwMaxAddressObjects;        // Max CPool Addresses
    // DWORD            dwMaxMailObjects;           // Max CPool Msgs
    // DWORD            dwShouldDelete;             // Should delete messages when delivered
    // DWORD            dwShouldDeliver;            // Should deliver messages when accepted
    // DWORD            dwUseFileLinks;             // 0 = use NTFS file links, 1 = use CopyFile
    // DWORD            dwBatchMsgs;                // 0 = Don't batch msgs, 1 = batch msgs
    // DWORD            dwMaxBatchLimit;            // if dwBatchMsgs == 1, batch this many in a row
    // DWORD            dwSaveBadMail;              // Save bad mail locally - independent of sending to admin
    // DWORD            dwEnableMailPickUp;         // 1 = Pickup from a Dir, 0 = No pickup from a Dir
    // LPWSTR           lpszDeleteDir;              // Dir to move delivered msg to if dwShouldDelete == FALSE
    // LPWSTR           lpszRoutingDll;             // Mail routing DLL
    // LPWSTR           lpszMailQueueDir;           // Local directory to use for the mail queue
    // LPWSTR           lpszMailPickupDir;          // Local Directory for mail pickup
    // LPSMTP_CONFIG_DOMAIN_LIST    DomainList;     // Domain config info - default domain and supported domains

    DWORD           dwReverseLookup;            // Do DNS Reverse lookup?
    DWORD           dwMaxHopCount;              // Max msg hops before NDR
    DWORD           dwMaxRemoteTimeOut;         // Outbound inactivity timeout
    DWORD           dwMaxErrors;                // Max protocol errors before drop conn
    DWORD           dwMaxMsgSizeAccepted;       // Largest msg we'll accept
    DWORD           dwMaxMsgSizeBeforeClose;    // Largest msg we'll wait for before abrupt close
    DWORD           dwMaxRcpts;                 // Max recips per message
    DWORD           dwShouldRetry;              // Should retry delivery
    DWORD           dwMaxRetryAttempts;         // Max # of retry attempts
    DWORD           dwMaxRetryMinutes;          // Minutes between retries
    DWORD           dwNameResolution;           // 0 = DNS, 1 = GetHostByName
    DWORD           dwShouldPipelineOut;        // Pipeline outbound mail?
    DWORD           dwShouldPipelineIn;         // Advertise inbound pipeline support?
    DWORD           dwSmartHostType;            // 0 = Never, 1 = On failed connection, 1 = Always
    DWORD           dwSendNDRCopyToAdmin;       // Send copy of all NDR's to AdminEmail?
    DWORD           dwSendBadMailToAdmin;       // Send bad msgs to AdminEmail?
    DWORD           dwMaxOutboundConnections;   // Maximum outbound connections allowed

    LPWSTR          lpszSmartHostName;          // Smart host server
    LPWSTR          lpszConnectResp;            // Connection response
    LPWSTR          lpszBadMailDir;             // Dir to save bad mail
    LPWSTR          lpszDefaultDomain;          // Default domain

    LPSMTP_CONFIG_ROUTING_LIST  RoutingList;    // Mail routing source information

} SMTP_CONFIG_INFO, *LPSMTP_CONFIG_INFO;

NET_API_STATUS
NET_API_FUNCTION
SmtpGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    DWORD           dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  LPSMTP_CONFIG_INFO      pConfig,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetConnectedUserList(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONN_USER_LIST   *ppConnUserList,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDisconnectUser(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  DWORD                   dwUserId,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpRenameDomain(
    IN  LPWSTR                  wszServerName,
    IN  LPWSTR                  wszOldDomainName,
    IN  LPWSTR                  wszNewDomainName,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetLocalDomains(
    IN  LPWSTR                      wszServerName,
    OUT LPSMTP_CONFIG_DOMAIN_LIST   *ppDomainList,
    IN DWORD                        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpAddLocalDomain(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszLocalDomain,
    IN DWORD        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDelLocalDomain(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszLocalDomain,
    IN DWORD        dwInstance

    );


//
// User config
//

#define FC_SMTP_USER_PROPS_FORWARD          ((FIELD_CONTROL)BitFlag(0))
#define FC_SMTP_USER_PROPS_MAILBOX_SIZE     ((FIELD_CONTROL)BitFlag(1))
#define FC_SMTP_USER_PROPS_VROOT            ((FIELD_CONTROL)BitFlag(2))
#define FC_SMTP_USER_PROPS_LOCAL            ((FIELD_CONTROL)BitFlag(3))
#define FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE ((FIELD_CONTROL)BitFlag(4))

#define FC_SMTP_USER_PROPS_ALL              ( \
                                            FC_SMTP_USER_PROPS_FORWARD | \
                                            FC_SMTP_USER_PROPS_MAILBOX_SIZE | \
                                            FC_SMTP_USER_PROPS_VROOT | \
                                            FC_SMTP_USER_PROPS_LOCAL |\
                                            FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE \
                                            )
#if defined(MIDL_PASS)
#define MIDL(x) x
#else
#define MIDL(x)
#endif

typedef struct _SMTP_USER_PROPS
{
    FIELD_CONTROL   fc;

    LPWSTR          wszForward;
    DWORD           dwMailboxMax;
    LPWSTR          wszVRoot;
    DWORD           dwLocal;
    DWORD           dwMailboxMessageMax;
} SMTP_USER_PROPS, *LPSMTP_USER_PROPS;


NET_API_STATUS
NET_API_FUNCTION
SmtpCreateUser(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszForwardEmail,
    IN DWORD    dwLocal,
    IN DWORD    dwMailboxSize,
    IN DWORD    dwMailboxMessageSize,
    IN LPWSTR   wszVRoot,
    IN DWORD    dwInstance

    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteUser(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    OUT LPSMTP_USER_PROPS *ppUserProps,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN LPSMTP_USER_PROPS pUserProps,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance

    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwRowsReq,
    IN  BOOL                    fForward,
    OUT LPSMTP_NAME_LIST        *ppNameList,
    IN DWORD                    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameListFromList(
    IN  LPWSTR              wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN DWORD            dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetVRootSize(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszVRoot,
    IN  LPDWORD     pdwBytes,
    IN DWORD        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpBackupRoutingTable(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszPath,
    IN DWORD        dwInstance
    );

// ===================================================
// SMTP SDK RPCs
//

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProfileInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPWSTR                  wszEmail,
    IN OUT  LPSSE_USER_PROFILE_INFO lpProfileInfo,
    IN      DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProfileInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPWSTR                  wszEmail,
    IN      LPSSE_USER_PROFILE_INFO lpProfileInfo,
    IN      DWORD                   dwInstance
    );



//
// Get Server Statistics
//

NET_API_STATUS
NET_API_FUNCTION
SmtpQueryStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

//
// Clear server statistics
//

NET_API_STATUS
NET_API_FUNCTION
SmtpClearStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD            dwInstance
    );

//
// Used to free buffers returned by APIs
//

VOID
SmtpFreeBuffer(
    LPVOID Buffer
    );

//
// AQ Admin APIs
//
#include <aqadmtyp.h>

NET_API_STATUS
NET_API_FUNCTION
SmtpAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs);

#ifdef __cplusplus
}
#endif

#endif _SMTPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\smtpext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpext.h

Abstract:

    SMTP server extension header file. These definitions are available
    to server extension writers.

Author:

    Microsoft Corporation	June, 1996

Revision History:

--*/

#ifndef _SMTPEXT_H_
#define _SMTPEXT_H_


// ====================================================================
// Include files
// 


// ====================================================================
// Version Information
// 

#define SSE_VERSION_MAJOR	1 // Major version
#define SSE_VERSION_MINOR	0 // Minor version
#define SSE_VERSION			MAKELONG( SSE_VERSION_MINOR, SSE_VERSION_MAJOR )


// ====================================================================
// Generic defines
// 

#define SSE_MAX_EXT_DLL_NAME_LEN			256 // Max length of Ext. DLL name
#define SSE_MAX_STRING_LEN_ANY				512 // Max length of any string


// ====================================================================
// Return codes
//

#define SSE_STATUS_SUCCESS                  0
#define SSE_STATUS_RETRY                    1
#define SSE_STATUS_ABORT_DELIVERY           2
#define SSE_STATUS_BAD_MAIL					3


// ====================================================================
// Server support fucntions request codes
//

#define SSE_REQ_GET_USER_PROFILE_INFO			1
#define SSE_REQ_SET_USER_PROFILE_INFO			2


// ====================================================================
// Server extension version data structure
//

typedef struct _SSE_VERSION_INFO
{
    DWORD       dwServerVersion;                // Server version
    DWORD       dwExtensionVersion;             // Extension version
    CHAR        lpszExtensionDesc[SSE_MAX_EXT_DLL_NAME_LEN];    // Description

} SSE_VERSION_INFO;


// ====================================================================
// SMTP Extension Control Block data structure
//

typedef LPVOID	LPSSECTXT;

typedef struct _SSE_EXTENSION_CONTROL_BLOCK
{
	DWORD		cbSize;					// Size of this struct
	DWORD		dwVersion;				// Version of this spec
    LPSSECTXT	lpContext;				// Server context (DO NOT MODIFY)

	LPSTR		lpszSender;				// Name of sender of message
	LPSTR		lpszCurrentRecipient;	// Current recipient being processed

	DWORD		cbTotalBytes;			// Total size of message in bytes
	DWORD		cbAvailable;			// Available number of bytes
	LPBYTE		lpbData;				// Pointer to message data

	LPVOID		lpvReserved;			// Reserved, must be NULL

	// Server callbacks

	BOOL (WINAPI * GetServerVariable)	( LPSSECTXT	lpContext,
										  LPSTR		lpszVeriableName,
										  LPVOID	lpvBuffer,
										  LPDWORD	lpdwSize );

	BOOL (WINAPI * ServerSupportFunction)	( LPSSECTXT	lpContext,
											  DWORD		dwSSERequest,
											  LPVOID	lpvBuffer,
											  LPDWORD	lpdwSize,
											  LPDWORD	lpdwDataType );

} SSE_EXTENSION_CONTROL_BLOCK, *LPSSE_EXTENSION_CONTROL_BLOCK;


// ====================================================================
// Data structures for server support functions
//

typedef struct _SSE_USER_PROFILE_INFO
{
	LPTSTR		lpszExtensionDllName;	// Name of calling DLL
	LPTSTR		lpszKey;				// Key to look for
	LPTSTR		lpszValue;				// Value to set/get
	DWORD		dwSize;					// Buffer size on a get

} SSE_USER_PROFILE_INFO, *LPSSE_USER_PROFILE_INFO;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\smtptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _SMTPTYPE_
#define _SMTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Common Gibraltar Service types.
//
#include <gibtype.h>

//
//  Simple types.
//

#ifdef __cplusplus
}
#endif

#endif _SMTPTYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\stream.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.h

Abstract:

	This module contains the definition for the Server
	Extension Object Stream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29/97	created

--*/


// stream.h : Declaration of the CSEOStream

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE __declspec(uuid("2DF59671-3D15-11d1-AA51-00AA006BC80B")) CSEOStream : 
	public CComObjectRoot,
	public IStream
//	, public CComCoClass<CSEOStream, &CLSID_CSEOStream>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Cleanup();
		HRESULT Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Open();
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);
		static HRESULT CreateInstance(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream, IStream **ppStream);
		static HRESULT CreateInstance(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream, IStream **ppStream);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CSEOStream);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SMTP IStream Class",
//								   L"SMTP.IStream.1",
//								   L"SMTP.IStream");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOStream)
		COM_INTERFACE_ENTRY(IStream)
		COM_INTERFACE_ENTRY_IID(__uuidof(CSEOStream),CSEOStream)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		HANDLE m_hFile;
		LPSTR m_pszFile;
		ULARGE_INTEGER m_libOffset;
		HANDLE m_hEvent;
		CSEOStream *m_pSubStream;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\timemath.h ===
// timemath.h---written by Bill Griffin (Billgr)

#if !defined(_TIMEMATH_H_)
#define _TIMEMATH_H_

const __int64 hnsPerMillisecond  = 10000i64;
const __int64 hnsPerSecond       = 10000000i64;
const __int64 hnsPerMinute       = 600000000i64;
const __int64 hnsPerHour         = 36000000000i64;
const __int64 hnsPerDay          = 864000000000i64;

inline __int64 MsFromHns(__int64 hns)
    { return hns / hnsPerMillisecond; }
inline __int64 SecFromHns(__int64 hns)
    { return hns / hnsPerSecond; }
inline __int64 MinFromHns(__int64 hns)
    { return hns / hnsPerMinute; }
inline __int64 HrFromHns(__int64 hns)
    { return hns / hnsPerHour; }
inline __int64 DayFromHns(__int64 hns)
    { return hns / hnsPerDay; }

inline  __int64 HnsFromMs(__int64 ms)
    { return ms * hnsPerMillisecond; }
inline  __int64 HnsFromSec(__int64 sec)
    { return  sec * hnsPerSecond; }
inline  __int64 HnsFromMin(__int64 min)
    { return  min * hnsPerMinute; }
inline  __int64 HnsFromHr(__int64 hr)
    { return  hr * hnsPerHour; }
inline  __int64 HnsFromDay(__int64 day)
    { return day * hnsPerDay; }

inline __int64 HnsFromFt(FILETIME ft)
    { return *((__int64*)&ft); }
inline __int64 HnsFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HnsFromFt(ftEnd) - HnsFromFt(ftStart); }
inline __int64 SecFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return SecFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 MinFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return MinFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 HrFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HrFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 DayFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return DayFromHns(HnsFromFtSpan(ftStart, ftEnd)); }

#endif // !defined(_TIMEMATH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\inc\smtps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    smtps.h

    This file contains constants & type definitions shared between the
    SMTP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _SMTPS_H_
#define _SMTPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif

//
//  Service name.
//

#define SMTP_SERVICE_NAME               TEXT("SMTPSVC")
#define SMTP_SERVICE_NAME_A             "SMTPSVC"
#define SMTP_SERVICE_NAME_W             L"SMTPSVC"

#define IPPORT_SMTP                     25
#define IPPORT_SMTP_SECURE              465

//
//  Name of the log file, used for logging file accesses.
//

#define SMTP_LOG_FILE                  TEXT("SMTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define SMTP_PARAMETERS_KEY_A   "System\\CurrentControlSet\\Services\\SMTPSvc\\Parameters"
#define SMTP_PARAMETERS_KEY_W   L"System\\CurrentControlSet\\Services\\SMTPSvc\\Parameters"
#define SMTP_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters")


//
//  Performance key.
//

#define SMTP_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Performance")

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//
#define SMTP_ANONYMOUS_SECRET         TEXT("SMTP_ANONYMOUS_DATA")
#define SMTP_ANONYMOUS_SECRET_A       "SMTP_ANONYMOUS_DATA"
#define SMTP_ANONYMOUS_SECRET_W       L"SMTP_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//
#define SMTP_ROOT_SECRET_W            L"SMTP_ROOT_DATA"

#define DEFAULT_AUTHENTICATION	MD_AUTH_BASIC|MD_AUTH_NT
#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _SMTPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\catparams.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catparams.cpp
//
// Contents: Categorizer server event parameter classes
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/06/23 13:13:58: Created.
//
//-------------------------------------------------------------
#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>
#include "dbgtrace.h"

#include "imd.h"
#include "mb.hxx"

#include <smtpevents.h>

#include <stdio.h>

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL


#include "seo.h"
#include "seolib.h"
#include "smtpdisp.h"
#include "seodisp.h"
#include "seodisp.h"
#include <smtpevent.h>

//
// CMailTransportCatRegisterParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->Register(
        m_pContext->pICatParams);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    if(FAILED(hrRes) && (hrRes != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hrRes;
    }

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    if(FAILED(hr) && (hr != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hr;
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBeginParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BeginMessageCategorization(
        m_pContext->pICatMailMsgs);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatEndParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->EndMessageCategorization(
        m_pContext->pICatMailMsgs,
        m_pContext->hrStatus);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatBuildQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQuery(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault");
    HRESULT hr;

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hr = (m_pContext->pfnDefault)(S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBuildQueriesParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQueries(
        m_pContext->pICatParams,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->pICatQueries);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatSendQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SendQuery(
        m_Context.pICatParams,
        m_Context.pICatQueries,
        m_Context.pICatAsyncContext,
        (LPVOID)&m_Context);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    pSink->Release();

    //
    // SendQuery return values:
    //   MAILTRANSPORT_S_PEDING: Will call (or already called)
    //   ICategorizerAsyncContext.CompleteQuery with the result of
    //   this lookup
    //   S_OK: Will not call CompleteQuery, please continue
    //   S_FALSE: Will not call CompleteQuery, please stop calling sinks
    //   Everything else: Will not call CompleteQuery.
    //

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);


    hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
//
// CMailTransportCatSortQueryResultParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SortQueryResult(
        m_pContext->pICatParams,
        m_pContext->hrResolutionStatus,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->dwcResults,
        m_pContext->rgpICatItemAttributes);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatProcessItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->ProcessItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatExpandItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;
    BOOL fAlreadyAsync;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    DebugTrace((LPARAM)this, "Calling expanditem event on this sink");

    hrRes = pSink->ExpandItem(
        m_Context.pICatParams,
        m_Context.pICatItem,
        m_pINotify,
        (PVOID)this);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hrRes != MAILTRANSPORT_S_PENDING) {

        m_fAsyncCompletion = fAlreadyAsync;
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }
    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault()
{
    HRESULT hr;
    BOOL fAlreadyAsync;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);
    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hr != MAILTRANSPORT_S_PENDING)
        m_fAsyncCompletion = fAlreadyAsync;

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//   Or return value from supplied completion routine
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // The way ExpandItem works is the following:
    //  If any sinks return MAILTRANSPORT_S_PENDING (including the default), 
    //  then TriggerServerEvent returns MAILTRANSPORT_S_PENDING, and
    //  the supplied completion routine will be called. 
    //  Otherwise, TriggerServerEvent returns S_OK and no completion
    //  routine is called
    //
    if(m_fAsyncCompletion)

        hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);
        
    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//
// CMailTransportCatCompleteItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->CompleteItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\wstgado.h $(O)\wstgado_i.c : $(STAXINC)\export\wstgado.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\wstgado_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\wstgado_i.c \
    -header $@ \
    -tlb $(O)\wstagado.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpsvc.h $(O)\smtpsvc_s.c : ..\..\smtpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\smtpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: smtpmsg.mc 
    copy /a smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seomgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: seomgr.h
//
// Contents: A class to manage the SEO dispatcher for a particular
//           SMTP virtual server 
//
// Classes:
//  CSMTPSeoMgr
//
// Functions:
//
// History:
// jstamerj 1999/06/25 19:11:03: Created.
//
//-------------------------------------------------------------
#include <windows.h>

interface IEventRouter;
interface IServerDispatcher;

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(*rg))

//
// Class to manage the SEO configuration of one SMTP virtual server
//
class CSMTPSeoMgr
{
  public:
    CSMTPSeoMgr();
    ~CSMTPSeoMgr();

    HRESULT HrInit(
        DWORD dwVSID);
    VOID Deinit();

    HRESULT HrTriggerServerEvent(
        DWORD dwEventType,
        PVOID pvContext);

    IEventRouter *GetRouter()
    {
        return m_pIEventRouter;
    }

  private:
    #define SIGNATURE_CSMTPSEOMGR           (DWORD)'MSSC'
    #define SIGNATURE_CSMTPSEOMGR_INVALID   (DWORD)'MSSX'

    DWORD m_dwSignature;
    IEventRouter *m_pIEventRouter;
    IServerDispatcher *m_pICatDispatcher;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\wildmat.cpp ===
//---[ wildmat.cpp ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

//
// This stuff is isolated out to simplify unit-testing ...
//

#include "windows.h"
#include "abtype.h"
#include "dbgtrace.h"

static void pStringLower(LPSTR szString, LPSTR szLowerString)
{
	while (*szString)
		*szLowerString++ = (CHAR)tolower(*szString++);
	*szLowerString = '\0';
}

// This stuff is from address.hxx
#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2) // 2 for @ and \0

//
// This is a quick and dirty function to do wildcard matching for email
// names. The match is case-insensitive, and the pattern can be expressed as:
//
// <email pattern>[@<domain pattern>]
//
// The email pattern is expressed as follows:
//
// <email pattern> := { * | [*]<email name>[*] }
//
// Which becomes one of the below:
// *		- Any email name
// foo		- Exact match for "foo"
// *foo		- Any email name ending with "foo", including "foo"
// foo*		- Any email name beginning with "foo", including "foo"
// *foo*	- Any email name that contains the string "foo", including "foo"
//
// If a domain is not specified, the pattern matches against any domain. Both the
// email pattern and the domain pattern (if specified) must be matched for the
// rule to fire. Domain patterns are expressed as:
//
// <domain pattern> := [*][<domain name>]
//
// Which are:
// *		- Any domain
// bar.com	- Exact match for "bar.com"
// *bar.com	- Any domain ending with "bar.com", including "bar.com"
//
// szEmail must be a string to the email alias (clean without comments, etc.)
// szEmailDomain must be a string to the email domain. NULL means no domain
// is specified. The domain must be clean without comments, etc.
//
//
typedef enum _WILDMAT_MODES
{
	WMOD_INVALID = 0,
	WMOD_WILDCARD_LEFT,		// Wildcard on the left
	WMOD_WILDCARD_RIGHT,	// Wildcard on the right
	WMOD_WILDCARD_BOTH,		// Wildcard on both sides
	WMOD_WILDCARD_MAX

} WILDMAT_MODES;

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail)
{
	LPSTR		pszPatternDomain;
	BOOL		fEmailWildMat = FALSE;
	BOOL		fDomainWildMat = FALSE;
	DWORD		wmEmailWildMatMode = WMOD_INVALID;
	DWORD		dwEmailLen = 0, dwDomainLen = 0;
	DWORD		dwEmailStemLen = 0, dwDomainStemLen = 0;
	DWORD		i;
	HRESULT		hrRes = S_OK;
	CHAR		szDomainMat[MAX_INTERNET_NAME + 1];

	TraceFunctEnterEx((LPARAM)NULL, "MatchEmailOrDomainName");

	// This validates that it is a good email name
	lstrcpyn(szDomainMat, szPattern, MAX_INTERNET_NAME + 1);
	szPattern = szDomainMat;
	pszPatternDomain = strchr(szDomainMat, '@');

	// See if we have an email wildcard at the left
	if (*szPattern == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a left wildcard");
		fEmailWildMat = TRUE;
		szPattern++;
		wmEmailWildMatMode = WMOD_WILDCARD_LEFT;
	}

	// Get the domain pointer
	if (szEmailDomain)
	{
		dwEmailLen = (DWORD)(szEmailDomain - szEmail);
		*szEmailDomain++ = '\0';
		dwDomainLen = lstrlen(szEmailDomain);
	}
	else
		dwEmailLen = lstrlen(szEmail);

	if (pszPatternDomain)
	{
		dwEmailStemLen = (DWORD)(pszPatternDomain - szPattern);
		*pszPatternDomain++ = '\0';
		dwDomainStemLen = lstrlen(pszPatternDomain);
		if (*pszPatternDomain == '*')
		{
			fDomainWildMat = TRUE;
			dwDomainStemLen--;
			pszPatternDomain++;
		}
	}
	else
		dwEmailStemLen = lstrlen(szPattern);

	// See if we have an email wildcard at the right
	if (dwEmailStemLen &&
		*(szPattern + dwEmailStemLen - 1) == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a right wildcard");

		szPattern[--dwEmailStemLen] = '\0';
		if (!fEmailWildMat)
		{
			// It has no left wildcard, so it is a right-only wildcard
			fEmailWildMat = TRUE;
			wmEmailWildMatMode = WMOD_WILDCARD_RIGHT;
		}
		else
			wmEmailWildMatMode = WMOD_WILDCARD_BOTH;
	}

	// Make sure there are no more wildcards embedded
	for (i = 0; i < dwEmailStemLen; i++)
		if (szPattern[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}
	for (i = 0; i < dwDomainStemLen; i++)
		if (pszPatternDomain[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}

	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szEmail, szEmailDomain?szEmailDomain:"none");
	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szPattern, pszPatternDomain?pszPatternDomain:"none");

	// OK, now eliminate by length
	if (dwEmailLen < dwEmailStemLen)
	{
		DebugTrace((LPARAM)NULL, "Email too short to match");
		hrRes = S_FALSE;
		goto Cleanup;
	}
	else
	{
		if (fEmailWildMat)
		{
			CHAR	szPatternLower[MAX_INTERNET_NAME + 1];
			CHAR	szEmailLower[MAX_INTERNET_NAME + 1];

			_ASSERT(wmEmailWildMatMode != WMOD_INVALID);
			_ASSERT(wmEmailWildMatMode < WMOD_WILDCARD_MAX);

			// Do the right thing based on the wildcard mode
			switch (wmEmailWildMatMode)
			{
			case WMOD_WILDCARD_LEFT:
				if (lstrcmpi(szPattern, szEmail + (dwEmailLen - dwEmailStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_RIGHT:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) != szEmail)
				{
					DebugTrace((LPARAM)NULL, "Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_BOTH:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) == NULL)
				{
					DebugTrace((LPARAM)NULL, "Left and Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;
			}
		}
		else
		{
			if ((dwEmailLen != dwEmailStemLen) ||
				(lstrcmpi(szPattern, szEmail)))
			{
				DebugTrace((LPARAM)NULL, "Exact email match failed");
				hrRes = S_FALSE;
				goto Cleanup;
			}
		}
	}

	// We are matching the domain pattern
	if (pszPatternDomain)
	{
		if (!szEmailDomain)
		{
			DebugTrace((LPARAM)NULL, "No email domain");
			hrRes = S_FALSE;
			goto Cleanup;
		}

		if (dwDomainLen < dwDomainStemLen)
		{
			DebugTrace((LPARAM)NULL, "Domain too short to match");
			hrRes = S_FALSE;
			goto Cleanup;
		}
		else
		{
			if (fDomainWildMat)
			{
				if (lstrcmpi(pszPatternDomain,
							szEmailDomain + (dwDomainLen - dwDomainStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left domain wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
			else
			{
				if ((dwDomainLen != dwDomainStemLen) ||
					(lstrcmpi(pszPatternDomain, szEmailDomain)))
				{
					DebugTrace((LPARAM)NULL, "Exact domain match failed");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
		}
	}
	else
		hrRes = S_OK;

Cleanup:

	TraceFunctLeaveEx((LPARAM)NULL);
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seodisp.h ===
#ifndef __SEODISP_H__
#define __SEODISP_H__

#include <smtpevents.h>
#include "smtpseo.h"
#include <smtpevent.h>
#include "smtpguid.h"
#include <comcat.h>
#include "seolib2.h"
#include "cdo.h"
#include <baseobj.h>

class __declspec(uuid("B226CEB5-0BBF-11d2-A011-00C04FA37348")) CStoreDispatcherData : public IUnknown {
	public:
		CStoreDispatcherData() {
			m_pvServer = NULL;
			m_dwServerInstance = 0;
		};
		HRESULT STDMETHODCALLTYPE GetData(LPVOID *ppvServer, DWORD *pdwServerInstance) {
			if (ppvServer) {
				*ppvServer = NULL;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = 0;
			}
			if (!m_pvServer) {
				return (E_FAIL);
			}
			if (ppvServer) {
				*ppvServer = m_pvServer;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = m_dwServerInstance;
			}
			return (S_OK);
		};
		HRESULT STDMETHODCALLTYPE SetData(LPVOID pvServer, DWORD dwServerInstance) {
			m_pvServer = pvServer;
			m_dwServerInstance = dwServerInstance;
			return (S_OK);
		};
	private:
		LPVOID m_pvServer;
		DWORD m_dwServerInstance;
};


class CStoreDispatcher :
        public CEventBaseDispatcher,
        public CComObjectRootEx<CComMultiThreadModelNoCS>,
        public IServerDispatcher,
        public IMailTransportNotify,
        public IClassFactory,
		public IEventDispatcherChain,
		public CStoreDispatcherData
{
    public:
        DECLARE_PROTECT_FINAL_CONSTRUCT();

        DECLARE_GET_CONTROLLING_UNKNOWN();

        DECLARE_NOT_AGGREGATABLE(CStoreDispatcher);

        BEGIN_COM_MAP(CStoreDispatcher)
            COM_INTERFACE_ENTRY(IEventDispatcher)
            COM_INTERFACE_ENTRY(IServerDispatcher)
            COM_INTERFACE_ENTRY(IMailTransportNotify)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
			COM_INTERFACE_ENTRY(IClassFactory)
			COM_INTERFACE_ENTRY(IEventDispatcherChain)
			COM_INTERFACE_ENTRY_IID(__uuidof(CStoreDispatcherData),CStoreDispatcherData)
        END_COM_MAP()

        // this code gets called during initialization
        HRESULT FinalConstruct()
        {
            // we need to do this to signal that we are free threaded
            return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p));
        }

        // this has the global destructor code in it
        void FinalRelease() {}

        virtual HRESULT AllocBinding(REFGUID rguidEventType,
                                     IEventBinding *piBinding,
                                     CBinding **ppNewBinding)
        {
            if (ppNewBinding)
                *ppNewBinding = NULL;

            if (!piBinding || !ppNewBinding)
                return E_POINTER;

            *ppNewBinding = new CStoreBinding;
            if (*ppNewBinding == NULL)
                return E_OUTOFMEMORY;

            return S_OK;
        }

    //
    // Local binding class
    //
    class CStoreBinding : public CEventBaseDispatcher::CBinding
    {
      public:
        CStoreBinding();
        ~CStoreBinding();
        virtual HRESULT Init(IEventBinding *piBinding);

        LPSTR   GetRuleString() { return(m_szRule); }

      private:
        HRESULT GetAnsiStringFromVariant(CComVariant &vString, LPSTR *ppszString);

      public:
        LPSTR       m_szRule;
    };
    //
    // Parameter abstract base class
    //
#define SIGNATURE_VALID_CSTOREPARAMS (DWORD)'CSPa'
#define SIGNATURE_INVALID_CSTOREPARAMS (DWORD)'aPSC'
    class CStoreBaseParams :
        public CEventBaseDispatcher::CParams,
        public CBaseObject
    {
      public:
        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject) = 0;
        virtual HRESULT CallDefault() = 0;
        virtual HRESULT CallCompletion(HRESULT hrStatus)
        {
            //
            // Free this Params object (Referenced in CStoreDispatcher::OnEvent)
            //
            CBaseObject::Release();
            return S_OK;
        }

        virtual HRESULT Init(PVOID pContext) = 0;

        HRESULT CheckMailMsgRule(
            CBinding *pBinding,
            IMailMsgProperties *pIMsgProps);

        HRESULT CheckMailMsgRecipientsRule(
            IUnknown *pIMsg,
            LPSTR pszPatterns);

        HRESULT CheckSignature()
        {
            return (m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS) ? S_OK : E_FAIL;
        }

        HRESULT MatchEmailOrDomainName(
            LPSTR szEmail,
            LPSTR szPattern,
            BOOL  fIsEmail);

      public:
        CStoreBaseParams();
        ~CStoreBaseParams();
        HRESULT InitParamData(
            LPVOID pContext,
            DWORD  dwEventType,
            IMailTransportNotify *pINotify,
            CStoreDispatcher *pDispatcher,
            REFIID rguidEventType);


      public:
        DWORD m_dwSignature;

        // This indicates which event type we are raising so that
        // the proper sink can be QI'd
        DWORD m_dwEventType;

      public:
        // Data needed for async sink operation:

        // How many sinks to skip on the next async sink completion
        DWORD m_dwIdx_SinkSkip;

        // Indicates wether or not default processing has been called
        BOOL  m_fDefaultProcessingCalled;

        // The IMailTransportNotify interface to pass to async capable sinks
        IMailTransportNotify *m_pINotify;

        // Our event type guid -- pass to dispatcher function
        GUID m_rguidEventType;

        // A pointer to the sink currently in asynchronous operation.
        // Must be NULL when no sinks are in async operation.
        IUnknown *m_pIUnknownSink;

        // store dispatcher that owns us
        CStoreDispatcher *m_pDispatcher;

    };

    //
    // Parameter class
    //
    class CStoreParams : 
        public CStoreBaseParams,
        public IMailMsgNotify
    {
        public:

        CStoreParams()
        {
            m_pContext = NULL;
            m_fCopiedContext = FALSE;
        }

        ~CStoreParams() {
            // clean up from CopyContext
            if (m_fCopiedContext) {
                _ASSERT(m_pContext == &m_context);
                if (m_context.m_RecipientCount) {
                    delete[] m_context.pdwRecipIndexes;
                }
                if (m_context.IMsgPtr) {
                    ((IMailMsgProperties *) m_context.IMsgPtr)->Release();
                }
                if (m_context.m_EventSmtpServer) {
                    ((ISMTPServer *) m_context.m_EventSmtpServer)->Release();
                }
            }
        }

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        virtual HRESULT CallCompletion(HRESULT hrStatus);

        // this needs to be done when we expect to use m_pContext in async
        // operations (such as local delivery)
        HRESULT CopyContext() {
            TraceFunctEnter("CStoreParams::CopyContext");

            // copying twice will screw things up
            if (m_fCopiedContext) {
                    TraceFunctLeave();
                        return S_OK;
            }

            _ASSERT(&m_context != m_pContext);

            memcpy(&m_context, m_pContext, sizeof(SMTP_ALLOC_PARAMS));

            if (m_context.m_RecipientCount) {
                // this is the only operation that can fail, so we do
                // it first.
                m_context.pdwRecipIndexes = 
                    new DWORD[m_context.m_RecipientCount];
                if (m_context.pdwRecipIndexes == NULL) {
                    ErrorTrace((LPARAM) this, "out of mem copying context");
                    TraceFunctLeave();
                    return E_OUTOFMEMORY;
                }
                memcpy(m_context.pdwRecipIndexes, 
                       m_pContext->pdwRecipIndexes, 
                       sizeof(DWORD) * m_context.m_RecipientCount);
            }

            // we need to hold onto these pointers
            if (m_context.IMsgPtr) {
                ((IMailMsgProperties *) m_context.IMsgPtr)->AddRef();
            }

            if (m_context.m_EventSmtpServer) {
                ((ISMTPServer *) m_context.m_EventSmtpServer)->AddRef();
            }

            m_fCopiedContext = TRUE;
            m_pContext = &m_context;

            TraceFunctLeave();
            return S_OK;
        }

        HRESULT Init(PVOID pContext)
        {
            m_pContext = (SMTP_ALLOC_PARAMS* )pContext;
            // AddRef our notification interface.  This is released in
            // CallCompletion.
            IMailMsgNotify *pNotify = (IMailMsgNotify *) m_pContext->m_pNotify;
            if (pNotify) {
                pNotify->AddRef();
            }
            return S_OK;
        }

        // IUnknown
        HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
        {
            if ( iid == IID_IUnknown ) {
                *ppv = static_cast<IMailMsgNotify*>(this);
            } else if ( iid == IID_IMailMsgNotify ) {
                *ppv = static_cast<IMailMsgNotify*>(this);
            } else {
                *ppv = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppv)->AddRef();
            return S_OK;
        }
        STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
        STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

        // IMailMsgNotify
        HRESULT STDMETHODCALLTYPE Notify(HRESULT hrStatus);

      public:
        SMTP_ALLOC_PARAMS * m_pContext;
        SMTP_ALLOC_PARAMS m_context;
        BOOL m_fCopiedContext;
    };

    //
    // Parameter class - OnPreCategorize
    //
    class CMailTransportPreCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_PRECATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_PRECATEGORIZE m_Context;
    };

    //
    // Parameter class - OnPostCategorize
    //
    class CMailTransportPostCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_POSTCATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_POSTCATEGORIZE m_Context;
    };

    // ------------------------------------------------------------
    // Categorizer Parameter classes
    // ------------------------------------------------------------
    class CMailTransportCatRegisterParams : public CStoreBaseParams
    {
      public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATREGISTER) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATREGISTER m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBeginParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBEGIN) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBEGIN m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatEndParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATEND) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATEND m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERY) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERY m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueriesParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERIES) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERIES m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSendQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATSENDQUERY));
            //
            // Setup async params (so ICatAsyncContext can call back into dispatcher)
            //
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        EVENTPARAMS_CATSENDQUERY m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSortQueryResultParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATSORTQUERYRESULT) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATSORTQUERYRESULT m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatProcessItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATPROCESSITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATPROCESSITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatExpandItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            m_fAsyncCompletion = FALSE;
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATEXPANDITEM));
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        BOOL m_fAsyncCompletion;
        EVENTPARAMS_CATEXPANDITEM m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatCompleteItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATCOMPLETEITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATCOMPLETEITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportSubmissionParams : public CStoreBaseParams
    {
        public:
        CMailTransportSubmissionParams()
        {
            m_pCDOMessage = NULL;
        }
        ~CMailTransportSubmissionParams()
        {
            if(m_pCDOMessage)
                m_pCDOMessage->Release();
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_SUBMISSION));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        HRESULT CallCDOSink(IUnknown *pSink);

        EVENTPARAMS_SUBMISSION m_Context;
        IMessage *m_pCDOMessage;
    };

    //
    // Create options class - Routing
    //

    class CRouterCreateOptions : public CEventCreateOptionsBase
    {
      public:

        CRouterCreateOptions(PEVENTPARAMS_ROUTER pContext)
        {
            _ASSERT (pContext != NULL);

            m_pContext = pContext;
        }

      private:
        HRESULT STDMETHODCALLTYPE Init(
            REFIID iidDesired,
            IUnknown **ppUnkObject,
            IEventBinding *,
            IUnknown *);

        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class - Routing
    //
    class CMailTransportRouterParams : public CStoreBaseParams
    {
      public:

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_ROUTER) pContext;
            //
            // Make sure caller initialized pIMessageRouter to NULL
            //
            _ASSERT(m_pContext->pIMessageRouter == NULL);

            return S_OK;
        }

      private:
        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class
    //
    class CStoreAllocParams : public CEventBaseDispatcher::CParams
    {
    public:

        CStoreAllocParams();
        ~CStoreAllocParams();

        virtual HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);

    public:

        PFIO_CONTEXT  m_hContent;

    };

    //
    // Parameter class for msgTrackLog
    //
    class CMsgTrackLogParams : public CStoreBaseParams
    {
      public:
        CMsgTrackLogParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MSGTRACKLOG) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MSGTRACKLOG m_pContext;
    };

    //
    // Parameter class for mx records
    //
    class CDnsResolverRecordParams : public CStoreBaseParams
    {
      public:
        CDnsResolverRecordParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_DNSRESOLVERRECORD) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_DNSRESOLVERRECORD m_pContext;
    };

    //
    // Parameter class for max msg size exceeded event
    //
    class CSmtpMaxMsgSizeParams : public CStoreBaseParams
    {
      public:
        CSmtpMaxMsgSizeParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MAXMSGSIZE) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MAXMSGSIZE m_pContext;
    };

    //
    // Parameter class for log event
    //
    class CSmtpLogParams : public CStoreBaseParams
    {
      public:
        CSmtpLogParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_LOG) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_LOG m_pContext;
    };

    //
    // Parameter class for Get Aux Domain Info Flags event
    //
    class CSmtpGetAuxDomainInfoFlagsParams : public CStoreBaseParams
    {
      public:
        CSmtpGetAuxDomainInfoFlagsParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS m_pContext;
    };

    HRESULT CreateCParams(
            DWORD               dwEventType,
            LPVOID              pContext,
            IMailTransportNotify *pINotify,
            REFIID              rGuidEventType,
            CStoreBaseParams    **ppCParams);

    HRESULT STDMETHODCALLTYPE OnEvent(
        REFIID  iidEvent,
        DWORD   dwEventType,
        LPVOID  pvContext);

    HRESULT STDMETHODCALLTYPE Dispatcher(
        REFIID rguidEventType,
        CStoreBaseParams *pParams);

    HRESULT STDMETHODCALLTYPE Notify(
        HRESULT hrStatus,
        PVOID pvContext);

    // IClassFactory methods
    public:
	    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
	    {
	        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	    }
	    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
	    {
	        _ASSERT(FALSE);
	        return E_NOTIMPL;
	    }

	// IEventDispatcherChain methods
	public:
		HRESULT STDMETHODCALLTYPE SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload);

	// IEventDispatcher methods
	public:
		HRESULT STDMETHODCALLTYPE SetContext(REFGUID guidEventType,
											 IEventRouter *piRouter,
											 IEventBindings *pBindings);

    private:
        CComPtr<IUnknown> m_pUnkMarshaler;
};

class CStoreDispatcherClassFactory : public IClassFactory
{
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void * * ppvObj)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
    unsigned long  STDMETHODCALLTYPE AddRef () { _ASSERT(FALSE); return 0; }
    unsigned long  STDMETHODCALLTYPE Release () { _ASSERT(FALSE); return 0; }

    // *** IClassFactory methods ***
    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
    {
        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
    }
    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
};


// helper functions
//
// jstamerj 980603 10:45:21: TriggerServerEvent with async callback
// support for completion
//

HRESULT TriggerServerEvent(IEventRouter             *pRouter,
                            DWORD                   dwEventType,
                            PVOID                   pvContext);


//
// register a new SEO instance.  if the instance is already registered
// this function will detect it and won't register it again.  it should
// be called for each instance at service startup and when each instance
// is created.
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID);
//
// unregister an SEO instance.  this should be called when an SEO
// instance is being deleted.
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for 
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail);

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seodisp.cpp ===
//#define INCL_INETSRV_INCS
//#include "smtpinc.h"

#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>
#include <cpool.h>
#include <address.hxx>
#include <mailmsgprops.h>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>
#include "dbgtrace.h"

#include "imd.h"
#include "mb.hxx"

#include <stdio.h>

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#include "filehc.h"
#include "seo.h"
#include "seolib.h"

#include "smtpdisp_i.c"
#include "mailmsgi.h"
#include <smtpevent.h>
#include "cdo.h"
#include "cdo_i.c"
#include "cdoconstimsg.h"
#include "seomgr.h"

#define MAX_RULE_LENGTH 4096
//
// Message object
//
#define MAILMSG_PROGID          L"Exchange.MailMsg"

#define INITGUID
#include "initguid.h"
#include "smtpguid.h"
#include "wildmat.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "evntwrap.h"

// {0xCD000080,0x8B95,0x11D1,{0x82,0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D}}
DEFINE_GUID(IID_IConstructIMessageFromIMailMsg, 0xCD000080,0x8B95,0x11D1,0x82,
0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D);

extern VOID
ServerEventCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
);

class CStoreCreateOptions : public CEventCreateOptionsBase
{
  public:

    CStoreCreateOptions(    SMTP_ALLOC_PARAMS * pContext)
    {
        _ASSERT (pContext != NULL);

        m_Context = pContext;
    }

  private:

    HRESULT STDMETHODCALLTYPE Init(REFIID iidDesired, IUnknown **ppUnkObject, IEventBinding *, IUnknown *)
    {
        ISMTPStoreDriver *pSink = NULL;
        IUnknown * ThisUnknown = NULL;
        IUnknown * NewUnknown = NULL;
        HRESULT hrRes = S_OK;

        TraceFunctEnterEx((LPARAM)this, "Calling create options");

        ThisUnknown = *ppUnkObject;

        hrRes = ThisUnknown->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
        if (hrRes == E_NOINTERFACE) {
            return (E_NOTIMPL);
        }
        if (FAILED(hrRes))
            return(hrRes);

        DebugTrace((LPARAM)this, "Calling startup events on sinks ...");
        hrRes = pSink->Init(m_Context->m_InstanceId,
                            NULL,
                            (IUnknown *) m_Context->m_EventSmtpServer,
                            m_Context->m_dwStartupType,
                            &NewUnknown);
        pSink->Release();
        if (FAILED(hrRes) && (hrRes != E_NOTIMPL)) {
            return (hrRes);
        }
        if(NewUnknown)
            {
                hrRes = NewUnknown->QueryInterface(iidDesired, (void **)ppUnkObject);
                NewUnknown->Release();
                if (!SUCCEEDED(hrRes)) {
                    return (hrRes);
                }
                ThisUnknown->Release();
            }


        return (E_NOTIMPL);
    };

  public:
    SMTP_ALLOC_PARAMS *     m_Context;

};


CStoreDispatcher::CStoreAllocParams::CStoreAllocParams()
{
    m_hContent = NULL;
}

CStoreDispatcher::CStoreAllocParams::~CStoreAllocParams()
{
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CreateCParams
//
// Synopsis: Based on dwEventType, create the appropriate Params object
//
// Arguments:
//   dwEventType - specifies SMTP event
//   pContext - context to pass into Init function
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  or error from InitParamData
//
// History:
// jstamerj 980610 18:30:20: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CreateCParams(
    DWORD               dwEventType,
    LPVOID              pContext,
    IMailTransportNotify *pINotify,
    REFIID              rGuidEventType,
    CStoreBaseParams    **ppCParams)
{
    _ASSERT(ppCParams);
    HRESULT hr;

    switch(dwEventType) {
     case SMTP_STOREDRV_STARTUP_EVENT:
        if (!SUCCEEDED(GetData(NULL,NULL))) {
            hr = SetData(((SMTP_ALLOC_PARAMS *) pContext)->m_EventSmtpServer,
                         ((SMTP_ALLOC_PARAMS *) pContext)->m_InstanceId);
            _ASSERT(SUCCEEDED(hr));
        }
        // fall through
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
         *ppCParams = new CStoreParams();
         break;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         *ppCParams = new CMailTransportSubmissionParams();
         break;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPreCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
         *ppCParams = new CMailTransportCatRegisterParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
         *ppCParams = new CMailTransportCatBeginParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
         *ppCParams = new CMailTransportCatEndParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
         *ppCParams = new CMailTransportCatBuildQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
         *ppCParams = new CMailTransportCatBuildQueriesParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
         *ppCParams = new CMailTransportCatSendQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
         *ppCParams = new CMailTransportCatSortQueryResultParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
         *ppCParams = new CMailTransportCatProcessItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
         *ppCParams = new CMailTransportCatExpandItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         *ppCParams = new CMailTransportCatCompleteItemParams();
         break;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPostCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         *ppCParams = new CMailTransportRouterParams();
         break;

     case SMTP_MSGTRACKLOG_EVENT:
         *ppCParams = new CMsgTrackLogParams();
         break;

     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         *ppCParams = new CDnsResolverRecordParams();
         break;

     case SMTP_MAXMSGSIZE_EVENT:
         *ppCParams = new CSmtpMaxMsgSizeParams();
         break;

     case SMTP_LOG_EVENT:
     	 *ppCParams = new CSmtpLogParams();
     	 break;

     case SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT:
         *ppCParams = new CSmtpGetAuxDomainInfoFlagsParams();
         break;

     default:
         _ASSERT(0 && "Unknown server event");
         *ppCParams = NULL;
         break;
    }

    if(*ppCParams == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = (*ppCParams)->InitParamData(
        pContext,
        dwEventType,
        pINotify,
        this,
        rGuidEventType);

    if(FAILED(hr)) {
        (*ppCParams)->Release();
        *ppCParams = NULL;
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CStoreBaseParams
//
// Synopsis: Sets member data to pre-initialized values
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:01: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::CStoreBaseParams() :
    m_rguidEventType(CATID_SMTP_STORE_DRIVER)
{
    m_dwSignature = SIGNATURE_VALID_CSTOREPARAMS;

    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;

    m_pINotify = NULL;
    m_pIUnknownSink = NULL;
    m_pDispatcher = NULL;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams
//
// Synopsis: Release the IMailTransportNotify reference if held
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:51: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams()
{
    if(m_pINotify)
        m_pINotify->Release();

    _ASSERT(m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS);
    m_dwSignature = SIGNATURE_INVALID_CSTOREPARAMS;
}


//+------------------------------------------------------------
//
// Function: InitParamData
//
// Synopsis: Initializes object.  This includes calling Init() which
//           is implemented in dervied objects.
//
// Arguments:
//  pContext: Context passed in - specific for server event
//  dwEventType: Specifies which server event we are for
//  pINotify: IMailTransportNotify interface for async completion
//  rguidEventType: guid for event type binding
//
// Returns:
//  S_OK: Success
//  Error from Init()
//
// History:
// jstamerj 980615 19:16:55: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::InitParamData(
    PVOID pContext,
    DWORD dwEventType,
    IMailTransportNotify *pINotify,
    CStoreDispatcher *pDispatcher,
    REFIID rguidEventType)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreBaseParams::InitParamData");
    HRESULT hr;

    m_dwEventType = dwEventType;
    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;
    m_pINotify = pINotify;
    m_pINotify->AddRef();
    m_rguidEventType = rguidEventType;
    m_pDispatcher = pDispatcher;

    hr = Init(pContext);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Init() failed, hr = %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CallObject
//
// Synopsis: Called by the dispatcher when time to call a sink.  This
// implements some default functionality -- create the sink with a
// null CCreateOptions
//
// Arguments:
//   IEventManager
//   CBinding
//
// Returns:
//  S_OK: Success
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/06/23 13:53:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule
//
// Synopsis: Determines if a mailmsg string rule passes or fails given
//           the mailmsg and the CBinding object
//
// Arguments:
//  pBinding: CBinding object for this sink
//  pMsgProps: IMailMsgProperteries of the message to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//
// History:
// jstamerj 1999/01/11 17:04:01: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule(
    CBinding *pBinding,
    IMailMsgProperties *pIMsgProps)
{
    HRESULT hr;
    BOOL    fDomainLoaded = FALSE;
    BOOL    fSenderLoaded = FALSE;
    CHAR    szDomain[MAX_INTERNET_NAME + 2];
    CHAR    szSender[MAX_INTERNET_NAME + 2];
    LPSTR   szRule;
    CStoreBinding *pStoreBinding = (CStoreBinding *)pBinding;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule");

    _ASSERT(pStoreBinding);
    _ASSERT(pIMsgProps);

    // Get the cached rule from the binding
    szRule = pStoreBinding->GetRuleString();
    DebugTrace((LPARAM)this, "Rule string: %s", (szRule)?szRule:"NULL (No rule)");

    // If the rule is NULL, we will don't have a rule
    // string and we will return a match
    if (!szRule)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return(S_OK);
    }

    // try each comma delimited rule in the header patterns list
    char *pszHeader = (char *) _alloca(lstrlen(szRule)+1);
    if (!pszHeader) {
        return (E_OUTOFMEMORY);
    }
    lstrcpy(pszHeader,szRule);
    while (pszHeader != NULL && *pszHeader != 0)
    {
        // find the next semicolon in the string and turn it into a 0
        // if it exists
        char *pszSemiColon = strchr(pszHeader, ';');
        if (pszSemiColon != NULL)
            *pszSemiColon = 0;

        // set pszContents to point to the text which must be matched
        // in the header.  if pszContents == NULL then just having
        // the header exist is good enough.
        char *pszPatterns = strchr(pszHeader, '=');
        if (pszPatterns != NULL)
        {
            *pszPatterns = 0;
            (pszPatterns++);
        }

        // we now have the header that we are looking for in
        // pszHeader and the list of patterns that we are interested
        // in pszPatterns.  Make the lookup into the header
        // data structure
        hr = S_FALSE;

        DebugTrace((LPARAM)this, "Processing Header <%s> with pattern <%s>",
                        pszHeader, pszPatterns);
        if (!lstrcmpi(pszHeader, "EHLO")) {

            // Process a client domain rule ...
            if (!fDomainLoaded) {
                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_HELO_DOMAIN,
                    sizeof(szDomain),
                    szDomain);

                if (hr == S_OK) {

                    fDomainLoaded = TRUE;
                }
            }
            if (fDomainLoaded) {
                hr = MatchEmailOrDomainName(szDomain, pszPatterns, FALSE);
            }
        } else if (!lstrcmpi(pszHeader, "MAIL FROM")) {

            // Process a sender name rule ...
            if (!fSenderLoaded) {

                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_SENDER_ADDRESS_SMTP,
                    sizeof(szSender),
                    szSender);

                if (hr == S_OK)
                {
                    fSenderLoaded = TRUE;
                }
            }
            if (fSenderLoaded) {
                hr = MatchEmailOrDomainName(szSender, pszPatterns, TRUE);
            }
        }
        else if (!lstrcmpi(pszHeader, "RCPT TO"))
        {
            hr = CheckMailMsgRecipientsRule(
                pIMsgProps,
                pszPatterns);
        }

        // We don't want to destroy the rule string so we restore all the
        // semicolons and equal signs
        if (pszSemiColon)
            *pszSemiColon = ';';
        if (pszPatterns)
            *(pszPatterns - 1) = '=';

        // Exit immediately if we found a match!
        if (hr == S_OK)
            goto Cleanup;

        // the next pattern is the one past the end of the semicolon
        pszHeader = (pszSemiColon == NULL) ? NULL : pszSemiColon + 1;
    }

Cleanup:
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule
//
// Synopsis: Determines if a mailmsg pattern string matches mailmsg
//           recipients or not
//
// Arguments:
//  pIMsg: An interface to a mailmsg object
//  pszPatterns: The sink rule to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//  error from mailmsg
//
// History:
// jstamerj 1999/01/12 15:25:55: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule(
    IUnknown *pIMsg,
    LPSTR pszPattern)
{
    HRESULT hr;
    DWORD dwNumRecips;
    IMailMsgRecipients *pIRecips = NULL;
    BOOL fMatch = FALSE;
    DWORD dwCount;
    CHAR szRecip [MAX_INTERNET_NAME + 2];

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule");

    hr = pIMsg->QueryInterface(
        IID_IMailMsgRecipients,
        (LPVOID *)&pIRecips);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRecips->Count(&dwNumRecips);
    if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Checking rule \"%s\" for %d recipients",
               pszPattern, pIMsg);

    for(dwCount = 0;
        (fMatch == FALSE) && (dwCount < dwNumRecips);
        dwCount++) {

        hr = pIRecips->GetStringA(
            dwCount,
            IMMPID_RP_ADDRESS_SMTP,
            sizeof(szRecip),
            szRecip);

        if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
            goto CLEANUP;

        if(hr != MAILMSG_E_PROPNOTFOUND) {
            hr = MatchEmailOrDomainName(szRecip,pszPattern,TRUE);
            if(hr == S_OK)
                fMatch = TRUE;
            else if(FAILED(hr))
                goto CLEANUP;
        }
    }
    hr = (fMatch) ? S_OK : S_FALSE;

 CLEANUP:
    if(pIRecips)
        pIRecips->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseparams::MatchEmailOrDomainName
//
// Synopsis: Given an email/domain name and a pattern, determine if
// the pattern matches or not
//
// Arguments:
//  szEmail: The email address or domain name
//  szPattern: The pattern to check
//  fIsEmail: TRUE if szEmail is an email address, FALSE if szEmail is
//  a domain
//
// Returns:
//  S_OK: Success, match
//  S_FALSE: Success, no match
//  E_INVALIDARG
//
// History:
// jstamerj 1999/01/12 15:25:36: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName(
    LPSTR szEmail,
    LPSTR szPattern,
    BOOL fIsEmail)
{
    CAddr       *pEmailAddress = NULL;
    LPSTR       szEmailDomain = NULL;
    HRESULT     hrRes;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName");

    DebugTrace((LPARAM)NULL, "Matching <%s> against <%s>", szEmail, szPattern);

    if (!szEmail || !szPattern)
        return(E_INVALIDARG);

    // This validates that it is a good email name
    pEmailAddress = CAddr::CreateAddress(szEmail, fIsEmail?FROMADDR:CLEANDOMAIN);
    if (!pEmailAddress)
        return(E_INVALIDARG);

    szEmail = pEmailAddress->GetAddress();
    szEmailDomain = pEmailAddress->GetDomainOffset();

    hrRes = ::MatchEmailOrDomainName(szEmail, szEmailDomain, szPattern, fIsEmail);

    // Free the CAddr objects ...
    if (pEmailAddress)
        delete pEmailAddress;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}



CStoreDispatcher::CStoreBinding::CStoreBinding()
{
    m_szRule = NULL;
}

CStoreDispatcher::CStoreBinding::~CStoreBinding()
{
    if(m_szRule)
        delete [] m_szRule;
}

//
// initialize a new binding.  we cache information from the binding database
// here
// jstamerj 1999/01/12 16:25:59: Copied MCIS2 code to get the rule string
//
HRESULT CStoreDispatcher::CStoreBinding::Init(IEventBinding *piBinding)
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr))
        return hr;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr))
        return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr))
        return hr;

    // Process the rule string, the result code is not important
    // since it will NULL our the string
    if (hr == S_OK)
        hr = GetAnsiStringFromVariant(vRule, &m_szRule);

    return hr;
}

HRESULT CStoreDispatcher::CStoreBinding::GetAnsiStringFromVariant(
    CComVariant &vString, LPSTR *ppszString)
{
    HRESULT hr = S_OK;

    _ASSERT(ppszString);

    if (!ppszString)
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));

    // Default to NULL
    *ppszString = NULL;

    if (vString.vt == VT_BSTR)
        {
            DWORD dwLength = lstrlenW(vString.bstrVal) + 1;

            // Convert to an ANSI string and store it as a member
            *ppszString = new char[dwLength];
            if (!*ppszString)
                return HRESULT_FROM_WIN32(GetLastError());

            // copy the rule into an ascii string
            if (WideCharToMultiByte(CP_ACP, 0, vString.bstrVal,
                                    -1, (*ppszString), dwLength, NULL, NULL) <= 0)
                {
                    delete [] (*ppszString);
                    *ppszString = NULL;
                    return HRESULT_FROM_WIN32(GetLastError());
                }
        }
    else
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return(hr);
}

#if 1
//
// create and call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(IEventManager *pManager, CBinding& bBinding)
{
    CStoreCreateOptions opt (m_pContext);
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}
#endif

//
// call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    HRESULT hrTmp = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CServerParams::CallObject");

    // We do this for different types of SMTP events
    switch (m_dwEventType)
        {
         case SMTP_STOREDRV_STARTUP_EVENT:
             break;
         case SMTP_STOREDRV_ALLOC_EVENT:
         {
             IMailMsgStoreDriver *pSink = NULL;
             IMailMsgProperties *   pMsg = (IMailMsgProperties *)m_pContext->IMsgPtr;
             IMailMsgBind         *pBindInterface = NULL;
             IMailMsgPropertyStream  *pStream = NULL;
             PATQ_CONTEXT           pAtqFileContext = NULL;

             DebugTrace((LPARAM)this, "Calling bind on sinks ...");

             /*IID_ISMTPStoreDriver*/
             hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             // Allocate a new message
             hrRes = pSink->AllocMessage(pMsg, NULL, &pStream, &m_pContext->hContent, NULL);
             if(!FAILED(hrRes))
             {
                     pBindInterface = (IMailMsgBind *)m_pContext->BindInterfacePtr;

#if 0
                     hrRes = pBindInterface->BindToStore(pStream, pSink, m_pContext->hContent,
                                                         m_pContext->pAtqClientContext, ServerEventCompletion,
                                                         INFINITE,
                                                         &m_pContext->pAtqContext,
                                                         AtqAddAsyncHandle,
                                                         AtqFreeContext);
#endif
                     hrRes = pBindInterface->BindToStore(pStream,
                                                         pSink,
                                                         m_pContext->hContent);
                     if (pStream)
                     {
                         pStream->Release();
                         pStream = NULL;
                     }

                     if(FAILED(hrRes))
                     {
                            ErrorTrace((LPARAM)this, "pBindAtqInterface->BindToStore failed with %x", hrRes);

                            // Close the content handle
                            HRESULT myRes = pSink->CloseContentFile(
                                        pMsg,
                                        m_pContext->hContent);
                            if (FAILED(myRes))
                            {
                                FatalTrace((LPARAM)this, "Unable to close content file (%08x)", myRes);
                                _ASSERT(FALSE);
                            }

                            m_pContext->hContent = NULL;

                            hrTmp = pSink->Delete(pMsg, NULL);
                            _ASSERT(SUCCEEDED(hrTmp));

                     }
                     else
                     {
                            //Skip all sinks - temporary
                            hrRes = S_FALSE;
                     }

             }
             else
             {
                DebugTrace((LPARAM)this, "pSink->AllocMessage failed with %x", hrRes);
             }

             pSink->Release();
         }
         break;
         case SMTP_STOREDRV_DELIVERY_EVENT:
         {
             ISMTPStoreDriver *pSink;
             IMailMsgNotify *pNotify;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             // if the caller has async notify support then pass in our
             // notification class.  
             if (m_pContext->m_pNotify) {
                // the sink might return async, so we need to keep local
                // copies of our context data
                hrRes = this->CopyContext();
                if (FAILED(hrRes))
                    return hrRes;

                hrRes = this->QueryInterface(IID_IMailMsgNotify, 
                                             (LPVOID *) &pNotify);
                if (FAILED(hrRes))
                    return hrRes;
             } else {
                pNotify = NULL;
             }

             //
             // Remember the sink so we can release this sink later if it
             // returns pending
             //
             _ASSERT(m_pIUnknownSink == NULL);
             m_pIUnknownSink = (IUnknown*)pSink;
             m_pIUnknownSink->AddRef();

             DebugTrace((LPARAM)this, "Calling local delivery sink sink ...");
             hrRes = pSink->LocalDelivery(
                (IMailMsgProperties *) m_pContext->IMsgPtr, 
                m_pContext->m_RecipientCount, 
                m_pContext->pdwRecipIndexes, 
                (IMailMsgNotify *) pNotify);
             pSink->Release();
             if(hrRes != MAILTRANSPORT_S_PENDING) {
                 //
                 // We completed synchronously, so release the sink
                 //
                 m_pIUnknownSink->Release();
                 m_pIUnknownSink = NULL;
             }
             // if LocalDelivery was going to do an async return then it
             // should have AddRef'd pNotify
             if (pNotify) pNotify->Release();

             //
             // jstamerj 1998/08/04 17:31:07:
             //   If the store driver sink returns this specific error
             //   code, we want to stop calling sinks and return from
             //   TriggerLocalDelivery
             //
             if(hrRes == STOREDRV_E_RETRY) {

                 DebugTrace((LPARAM)this, "Sink returned STOREDRV_E_RETRY on LocalDelivery");
                 m_pContext->hr = hrRes;
                 hrRes = S_FALSE;
             }

         }
         break;
         case SMTP_MAIL_DROP_EVENT:
             // ISMTPStoreDriver *pSink;

             // hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             // if (FAILED(hrRes))
             // return(hrRes);

             // DebugTrace((LPARAM)this, "Calling mail drop sink ...");
             // hrRes = pSink->DirectoryDrop((IMailMsgProperties *) m_pContext->IMsgPtr, m_pContext->m_RecipientCount, m_pContext->pdwRecipIndexes, m_pContext->m_DropDirectory, NULL);
             // pSink->Release();
             //}
             break;
         case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling prepare to shutdown on sinks ...");
             hrRes = pSink->PrepareForShutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;
         case SMTP_STOREDRV_SHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling shutdown on sinks ...");
             hrRes = pSink->Shutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         case SMTP_STOREDRV_ENUMMESS_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling Enumerate on sinks ...");
             hrRes = pSink->EnumerateAndSubmitMessages(NULL);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         default:
             DebugTrace((LPARAM)this, "Invalid sink interface");
             hrRes = E_NOINTERFACE;
        }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreParams::CallDefault
//
// Synopsis: CStoreDispatcher::Dispatcher will call this routine when
//           the default sink priority has been reached.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980611 14:19:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreParams::CallDefault()
{
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CStoreDriver::CStoreParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreParams::CallCompletion(HRESULT hrStatus) {
    // call the caller's completion method if there is one
    IMailMsgNotify *pNotify = (IMailMsgNotify *) (m_pContext->m_pNotify);
    if (pNotify) {
        pNotify->Notify(hrStatus);
        pNotify->Release();
    }

    // do the normal call completion work
    CStoreBaseParams::CallCompletion(hrStatus);

    return S_OK;
}


//
// call the child object
//
HRESULT CStoreDispatcher::CStoreAllocParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

#if 0
    IMailMsgStoreDriver   *pStoreDriver = NULL;
    IMailMsgProperties    *pMsg         = NULL;
    IMailMsgPropertyStream  *pStream    = NULL;
    IMailMsgBindATQ       *pBindInterface = NULL;
    CLSID                 clsidMailMsg;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreAllocParams::CallObject");

    hrRes = CLSIDFromProgID(MAILMSG_PROGID, &clsidMailMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    // Create a new MailMsg
    hrRes = CoCreateInstance(
        clsidMailMsg,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMailMsgProperties,
        (LPVOID *)&pMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pStoreDriver);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    // Allocate a new message
    hrRes = pStoreDriver->AllocMessage(
        pMsg,
        NULL,
        &pStream,
        &m_hContent,
        NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "pDriver->AllocMessage failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pMsg->QueryInterface(IID_IMailMsgBindATQ, (void **)&pBindInterface);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pBindInterface->SetATQInfo (NULL, NULL, NULL, INFINITE, NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
goto Exit;
    }


Exit:

    if(pStoreDriver)
    {
        pStoreDriver->Release();
    }

    if(pMsg)
    {
        pMsg->Release();
    }

    if(pBindInterface)
    {
        pBindInterface->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
#endif

    return(hrRes);
}

#if 0
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(REFIID  iidEvent,
                                                    DWORD   dwEventType,
                                                    LPVOID  pvContext)
{
    HRESULT hr = S_OK;

    // create the params object, and pass it into the dispatcher
    CStoreParams ServerParams;
    ServerParams.Init(dwEventType, pvContext);
    hr = Dispatcher(iidEvent, &ServerParams);

    return hr;
}
#endif


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::OnEvent
//
// Synopsis: Prepares for server event
//
// Arguments:
//   iidEvent: guid for event
//   dwEventType: specifies the event
//   pvContext: context for the params object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 13:27:55: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(
    REFIID  iidEvent,
    DWORD   dwEventType,
    LPVOID  pvContext)
{
    HRESULT hr;

    IMailTransportNotify *pINotify = NULL;
    //
    // Call into ATL internals to get the interface we need to pass out
    //
    hr = _InternalQueryInterface(
        IID_IMailTransportNotify,
        (LPVOID *)&pINotify);

    if(FAILED(hr))
        return hr;

    //
    // create the CParams object on the heap -- the object will be
    // needed after this call may be out of here (when a sink returns
    // MAILTRANSPORT_S_PENDING and there are more sinks to call)
    //
    CStoreBaseParams *pCParams;

    hr = CreateCParams(
        dwEventType,
        pvContext,
        pINotify,
        iidEvent,
        &pCParams);

    //
    // The params object should addref pINotify
    //
    pINotify->Release();

    if(FAILED(hr))
        return hr;

    //
    // Start calling sinks
    //
    hr = Dispatcher(iidEvent, pCParams);
    return hr;
}


//+------------------------------------------------------------
//
// Function: GuidForEvent
//
// Synopsis: Given dwEventType, return the appropriate GUID for the
//           event binding
//
// Arguments:
//   dwEventType: type of SMTP event
//
// Returns:
//   REFIID of GUID for the event
//
// History:
// jstamerj 980610 18:24:24: Created.
//
//-------------------------------------------------------------
REFIID GuidForEvent(DWORD dwEventType)
{
    switch(dwEventType) {
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_STARTUP_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
     default:
         return CATID_SMTP_STORE_DRIVER;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         return CATID_SMTP_TRANSPORT_SUBMISSION;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_PRECATEGORIZE;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         return CATID_SMTP_TRANSPORT_CATEGORIZE;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_POSTCATEGORIZE;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         return CATID_SMTP_TRANSPORT_ROUTER;
     case SMTP_MSGTRACKLOG_EVENT:
         return CATID_SMTP_MSGTRACKLOG;
     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         return CATID_SMTP_DNSRESOLVERRECORDSINK;
     case SMTP_MAXMSGSIZE_EVENT:
         return CATID_SMTP_MAXMSGSIZE;
     case SMTP_LOG_EVENT:
         return CATID_SMTP_LOG;
     case SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT:
        return CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS;
    }
}

//
// this function performs instance level server events registration
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // see if this source is registered with the list of sources for the
    // SMTP source type
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
    if (FAILED(hr))
        return hr;
    //
    // if the source guid doesn't exist then we need to register a new
    // source for the SMTP source type and add directory drop as a binding
    //
    if (hr == S_FALSE)
    {
        // register the SMTPSvc source
        hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
        if (FAILED(hr))
            return hr;

        char szSourceDisplayName[50];
        _snprintf(szSourceDisplayName, 50, "smtpsvc %lu", dwInstanceID);
        CComBSTR bstrSourceDisplayName = szSourceDisplayName;
        hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
        if (FAILED(hr))
            return hr;

        // create the event database for this source
        CComPtr<IEventDatabaseManager> pDatabaseManager;
        hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL,
                              IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
        if (hr != S_OK)
            return hr;

        CComBSTR bstrEventPath;
        CComBSTR bstrService = "smtpsvc";
        hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
        if (FAILED(hr))
            return hr;

        CComPtr<IUnknown> pDatabaseMoniker;
        hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        // save everything we've done so far
        hr = pEventSource->Save();
        if (FAILED(hr))
            return hr;

        hr = pSourceType->Save();
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr = S_OK;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // remove this source from the list of registered sources
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
    if (FAILED(hr))
        return hr;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Dispatcher
//
// Synopsis: Override the default functionality in seolib.cpp to
//           provide some extra features (default functionality
//
// Arguments:
//   rguidEventType: Guid specifying a server event
//   pParams: CStoreBaseParams -- contains async info
//
// Returns:
//  S_OK: Success, at least one sink called
//  S_FALSE: No sinks were called
//  otherwise error from CallObject
//
// History:
// jstamerj 980603 19:23:06: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Dispatcher(
    REFIID rguidEventType,
    CStoreBaseParams *pParams)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Dispatcher");
    _ASSERT(pParams);

    //
    // This code based on %STAXPT%\src\core\seo\lib\seolib.cpp
    //
    HRESULT hrRes = S_OK;
    CETData *petdData;
    BOOL bObjectCalled = (pParams->m_dwIdx_SinkSkip > 0);

    //
    // AddRef pParams here, release at the end of the function
    // This way, if a sink returns MAILTRANSPORT_S_PENDING and does
    // async completion before this function exits, we wont AV
    // accessing pParams
    //
    pParams->AddRef();

    petdData = m_Data.Find(rguidEventType);
    if(petdData) {
        for(DWORD dwIdx = pParams->m_dwIdx_SinkSkip;
            dwIdx < petdData->Count();
            dwIdx++) {
            if(!petdData->Index(dwIdx)->m_bIsValid) {
                continue;
            }
            if(bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
                continue;
            }
            if(pParams->Abort() == S_OK) {
                break;
            }
            //
            // Call default processing method if the priority of the sink
            // we're looking at is less than default priority
            //
            if((pParams->m_fDefaultProcessingCalled == FALSE) &&
               (petdData->Index(dwIdx)->m_dwPriority >
                SMTP_TRANSPORT_DEFAULT_PRIORITY)) {

                // This is needed so we don't call the default
                // processing again if the default processing returns
                // MAILTRANSPORT_S_PENDING (and we reenter Dispatcher)
                pParams->m_fDefaultProcessingCalled = TRUE;

                //
                // Set the correct index in our async structure -- our
                // current index.
                //
                pParams->m_dwIdx_SinkSkip = dwIdx;
                hrRes = pParams->CallDefault();

                if((hrRes == MAILTRANSPORT_S_PENDING) ||
                   (hrRes == S_FALSE)) {
                    break;
                }
            }

            //
            // Now proceed with calling a real sink
            //
            hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
            if(hrRes == S_OK) {
                if(pParams->Abort() == S_OK) {
                    break;
                }
                //
                // jstamerj 980603 19:37:17: Set the correct index in our
                // async structure -- this index plus one to skip the
                // sink we are about to call
                //
                pParams->m_dwIdx_SinkSkip = dwIdx+1;
                hrRes = pParams->CallObject(
                    m_piEventManager,
                    *petdData->Index(dwIdx));

                if(!SUCCEEDED(hrRes)) {
                    continue;
                }
                bObjectCalled = TRUE;
                if((hrRes == MAILTRANSPORT_S_PENDING) ||
                   (hrRes == S_FALSE) ||
                   (petdData->Index(dwIdx)->m_bExclusive)) {
                    break;
                }
            }
        }
    }

    //
    // It is possible we haven't called our default processing sink
    // yet.  Check for this case here.  Make sure that a sink above in
    // the loop isn't indicating async completion or skip (PENDING or
    // S_FALSE)
    //
    if((pParams->m_fDefaultProcessingCalled == FALSE) &&
       (hrRes != MAILTRANSPORT_S_PENDING) &&
       (hrRes != S_FALSE)) {

        // Make sure we don't call default again on async completion...
        pParams->m_fDefaultProcessingCalled = TRUE;

        //
        // Set the index in our async structure so we don't reenter
        // the above loop on async completion
        //
        pParams->m_dwIdx_SinkSkip = (petdData ? petdData->Count() : 0);

        hrRes = pParams->CallDefault();
    }

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // It is time to call the completion processing
        //
        hrRes = pParams->CallCompletion(bObjectCalled ? S_OK : S_FALSE);
        if(FAILED(hrRes)) {
            goto CLEANUP;
        }
        hrRes = (bObjectCalled) ? S_OK : S_FALSE;
    }
 CLEANUP:
    pParams->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Notify
//
// Synopsis: Handles async completions of sinks
//
// Arguments: pvContext - context passed into sink
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG:
//
// History:
// jstamerj 980608 15:50:57: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Notify(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Notify");

    _ASSERT(pvContext);
    if((pvContext == NULL) ||
       IsBadReadPtr(
           pvContext,
           sizeof(CStoreBaseParams))) {
        ErrorTrace((LPARAM)this, "Sink called Notify with bogus pvContext");
        return E_INVALIDARG;
    }

    CStoreBaseParams *pParams = (CStoreBaseParams *)pvContext;

    if(FAILED(pParams->CheckSignature())) {
        ErrorTrace((LPARAM)this, "Sink called Notify with invalid pvContext");
        return E_INVALIDARG;
    }
    //
    // Release the sink that called us
    // m_pIUnknownSink could be NULL if default processing returned pending
    //
    if(pParams->m_pIUnknownSink) {
        pParams->m_pIUnknownSink->Release();
        pParams->m_pIUnknownSink = NULL;
    }

    Dispatcher(pParams->m_rguidEventType, pParams);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::Notify
//
// Synopsis: Handles async completions of sinks using mailmsg notify
//
// Arguments: hrStatus - hresult from async operation
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG:
//
// History:
// jstamerj 980608 15:50:57: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::CStoreParams::Notify(
    HRESULT hrStatus)
{
    TraceFunctEnter("CStoreDispatcher::CStoreBaseParams::Notify");

    //
    // Release the sink that called us
    // m_pIUnknownSink could be NULL if default processing returned pending
    //
    if(m_pIUnknownSink) {
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    m_pDispatcher->Dispatcher(m_rguidEventType, this);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//
// CMailTransportSubmissionParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    IMailTransportSubmission *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportSubmission,
                                       (PVOID *)&pSink);

    if(hrRes == E_NOINTERFACE) {
        //
        // See if we can get the interfaces we need for a CDO sink
        //
        hrRes = CallCDOSink(punkObject);
        //
        // Success or failure, return here
        //
        TraceFunctLeaveEx((LPARAM)this);
        return hrRes;
    } else if(FAILED(hrRes)) {
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessageSubmission(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink
//
// Synopsis: Call the CDO Sink
//
// Arguments:
//  pSink: IUnknown of the sink
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 10:31:47: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink(
    IUnknown *pSink)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink");
    _ASSERT(pSink);

    HRESULT hr;
    ISMTPOnArrival *pCDOSink = NULL;
    IConstructIMessageFromIMailMsg *pIConstruct = NULL;
    CdoEventStatus eStatus = cdoRunNextSink;

    hr = pSink->QueryInterface(IID_ISMTPOnArrival,
                               (PVOID *)&pCDOSink);
    if(FAILED(hr))
        goto CLEANUP;

    if(m_pCDOMessage == NULL) {
        //
        // Yay.  Create a CDO message
        //
        hr = CoCreateInstance(
            CLSID_Message,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMessage,
            (LPVOID *)&m_pCDOMessage);
        if(FAILED(hr))
            goto CLEANUP;

        //
        // Fill in properties based on MailMsg
        //
        hr = m_pCDOMessage->QueryInterface(
            IID_IConstructIMessageFromIMailMsg,
            (LPVOID *)&pIConstruct);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }

        hr = pIConstruct->Construct(
            cdoSMTPOnArrival,
            m_Context.pIMailMsgProperties);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }
    }

    //
    // Call the sink
    //
    hr = pCDOSink->OnArrival(
        m_pCDOMessage,
        &eStatus);

 CLEANUP:
    //
    // Release interfaces
    //
    if(pIConstruct)
        pIConstruct->Release();
    if(pCDOSink)
        pCDOSink->Release();

    DebugTrace((LPARAM)this, "CallCDOSink returning hr %08lx eStatus %d", hr, eStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return FAILED(hr) ? hr :
        ((eStatus == cdoSkipRemainingSinks) ? S_FALSE : S_OK);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportSubmissionParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:55:29: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportSubmissionParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPreCategorizeParams:
//


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);

    IMailTransportOnPreCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPreCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling precategorize event on this sink");

    hrRes = pSink->OnSyncMessagePreCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPreCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:59:59: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPostCategorizeParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);

    IMailTransportOnPostCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPostCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessagePostCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPostCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 17:01:40: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CRouterCreateOptions::Init
//
// Synopsis: This is called right after we CoCreate any routing sink
// -- so call routing's initialize function (RegisterRouterReset)
//
// Arguments:
//  iidDesired: not used
//  ppUnkObject: IUnknown of newly created sink object
//  IEventBinding: not used
//  IUnknown: not used
//
// Returns:
//  E_NOTIMPL: Success, please do the regular Init thing
//  otherwise error from QI or sink function
//
// History:
// jstamerj 1998/07/10 18:09:04: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::CRouterCreateOptions::Init(
    REFIID iidDesired,
    IUnknown **ppUnkObject,
    IEventBinding *,
    IUnknown *)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CRouterCreateOptions::Init");

    IMailTransportSetRouterReset *pSink = NULL;
    HRESULT hr;

    hr = (*ppUnkObject)->QueryInterface(
        IID_IMailTransportSetRouterReset,
        (PVOID *)&pSink);
    if(hr == E_NOINTERFACE) {
        //
        // It's okay; this sink just doesn't care about hooking
        // the router reset interface
        //
        DebugTrace((LPARAM)this, "Router sink doesn't support IMailTransportSetRouterReset");
        TraceFunctLeaveEx((LPARAM)this);
        return E_NOTIMPL;

    } else if(FAILED(hr)) {
        ErrorTrace((LPARAM)this,
                   "QI for IMailTransportSetRouterReset failed with hr %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    DebugTrace((LPARAM)this, "Calling RegisterRouterReset event onSink");
    hr = pSink->RegisterResetInterface(
        m_pContext->dwVirtualServerID,
        m_pContext->pIRouterReset);

    pSink->Release();

    if(FAILED(hr) && (hr != E_NOTIMPL)) {
        //
        // A real failure occured
        //
        ErrorTrace((LPARAM)this, "RegisterResetInterface failed with hr %08lx", hr);
        return hr;
    }
    //
    // Return E_NOTIMPL so the real work of Init will be done
    //
    return E_NOTIMPL;
}

//
// CMailTransportRoutingParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams::CallObject
//
// Synopsis: Creates (if necessary) and calls the sink object
//
// Arguments:
//  pManager: IEventManager passed in from dispatcher
//  bBinding: CBinding for this event
//
// Returns:
//  S_OK: Success
//  E_POINTER: bad pManager
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/07/10 18:15:09: Created.
//
//-------------------------------------------------------------
//
// create and call the child object
//
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    CRouterCreateOptions opt (m_pContext);
    CComPtr<IUnknown> pUnkSink;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRotuerParams::CallObject");

    if (pManager == NULL) {
        ErrorTrace((LPARAM)this, "Invalid (NULL) pManager");
        TraceFunctLeaveEx((LPARAM)this);
        return (E_POINTER);
    }

    hr = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (FAILED(hr)) {
        ErrorTrace((LPARAM)this, "CreateSink returned error hr %08lx",
                   hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }
    hr = CallObject(bBinding,pUnkSink);
    DebugTrace((LPARAM)this, "CallObject child returned error %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRoutingParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  Error from QI or return code from sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportRoutingEngine *pSink;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    //
    // If they pass in a pIMailMsgProperties of NULL it means that they
    // just want to create a router object, but not actually do the
    // get message router call.
    //
    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    hrRes = punkObject->QueryInterface(IID_IMailTransportRoutingEngine,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on this sink");

    hrRes = pSink->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &(pIMessageRouterNew));

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // We are done with pSink so release it
    //
    pSink->Release();

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one and save the new one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    DebugTrace((LPARAM)this, "Sink GetMessageRouter returned hr %08lx", hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallDefault()
{
    HRESULT hrRes;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallDefault");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    //
    // Call the default IMailTransportRoutingEngine (CatMsgQueue)
    // just like any other sink except SEO didn't CoCreate it for us
    //

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on default sink");

    hrRes = m_pContext->pIRoutingEngineDefault->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &pIMessageRouterNew);

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    TraceFunctLeaveEx((LPARAM)this);

    DebugTrace((LPARAM)this, "Default processing returned hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    IMsgTrackLog *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_IMsgTrackLog, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncLogMsgTrackInfo(
                    m_pContext->pIServer,
                    m_pContext->pIMailMsgProperties,
                    m_pContext->pMsgTrackInfo );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    IDnsResolverRecordSink *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_IDnsResolverRecordSink, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncGetResolverRecord( m_pContext->pszHostName,
                                         m_pContext->pszFQDN,
                                         m_pContext->dwVirtualServerId,
                                         m_pContext->ppIDnsResolverRecord );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpMaxMsgSize *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpMaxMsgSize, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncMaxMsgSize( m_pContext->pIUnknown, m_pContext->pIMailMsg, m_pContext->pfShouldImposeLimit );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpLogParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpLog *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpLog, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncLog(m_pContext->pSmtpEventLogInfo );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpLogParams::CallDefault()
{
    HRESULT hrRes = S_OK;
    SMTP_LOG_EVENT_INFO     *pLogEventInfo;
    CEventLogWrapper        *pEventLog;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CSmtpLogParams::CallDefault");

    _ASSERT(m_dwEventType == SMTP_LOG_EVENT);

    if ((m_pContext->pSmtpEventLogInfo == NULL) ||
        (m_pContext->pDefaultEventLogHandler == NULL))
    {
        DebugTrace((LPARAM) this, "Skipping LogEvent call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    // Params are m_pContext->pSmtpEventLogInfo
    pLogEventInfo = m_pContext->pSmtpEventLogInfo;

    // filter out events that the user isn't interested in
    if (m_pContext->iSelectedDebugLevel < pLogEventInfo->iDebugLevel) {
        return S_OK;
    }

    // Handler is m_pContext->pDefaultEventLogHandler
    pEventLog = (CEventLogWrapper*)m_pContext->pDefaultEventLogHandler;

    // Call into default logging handler
    pEventLog->LogEvent(
                    pLogEventInfo->idMessage,
//                    pLogEventInfo->idCategory,	// Not used by default handler
                    pLogEventInfo->cSubstrings,
                    pLogEventInfo->rgszSubstrings,
                    pLogEventInfo->wType,
                    pLogEventInfo->errCode,
                    pLogEventInfo->iDebugLevel,
                    pLogEventInfo->szKey,
                    pLogEventInfo->dwOptions,
                    pLogEventInfo->iMessageString,
                    pLogEventInfo->hModule);

    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpGetAuxDomainInfoFlagsParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpGetAuxDomainInfoFlags *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpGetAuxDomainInfoFlags, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnGetAuxDomainInfoFlags(m_pContext->pIServer,
                                        m_pContext->pszDomainName,
                                        m_pContext->pdwDomainInfoFlags );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpGetAuxDomainInfoFlagsParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------
//
// Function: CStoreDriver::Setprevious
//
// Synopsis: Method of IEventDispatcherChain - gets calle dy the
//           dispatcher, when binding changes happen.
//
// Arguments:
//   pUnkPrevious: [in] Pointer to the previous dispatcher
//   ppUnkPreload: [out] Receives an object which implements
//                 IEnumGUID, in order to tell the router
//                 which event types to pre-load.
//
// Returns:
//   S_OK: Success
//
// History:
//      dondu   06/22/98    Created
//
//-------------------------------------------------------------

const GUID* g_apStoreDispEventTypes[] = {&CATID_SMTP_STORE_DRIVER,&GUID_NULL};

HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload) {
    HRESULT hrRes;

    if (ppUnkPreload) {
        *ppUnkPreload = NULL;
    }
    if (!ppUnkPreload) {
        return (E_POINTER);
    }
    _ASSERT(pUnkPrevious);
    if (pUnkPrevious) {
        CComQIPtr<CStoreDispatcherData,&__uuidof(CStoreDispatcherData)> pData;
        LPVOID pvServer;
        DWORD dwServerInstance;

        pData = pUnkPrevious;
        _ASSERT(pData);
        if (pData) {
            hrRes = pData->GetData(&pvServer,&dwServerInstance);

            if (SUCCEEDED(hrRes)) {
                hrRes = SetData(pvServer,dwServerInstance);
                _ASSERT(SUCCEEDED(hrRes));
            }
        }
    }
    hrRes = CEDEnumGUID::CreateNew(ppUnkPreload,g_apStoreDispEventTypes);
    return (hrRes);
};


HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetContext(REFGUID guidEventType,
                                                       IEventRouter *piRouter,
                                                       IEventBindings *pBindings) {
    HRESULT hrRes;

    hrRes = CEventBaseDispatcher::SetContext(guidEventType,piRouter,pBindings);
    if (SUCCEEDED(hrRes) && (guidEventType == CATID_SMTP_STORE_DRIVER)) {
        HRESULT hrResTmp;
        LPVOID pvServer;
        DWORD dwServerInstance;
        SMTP_ALLOC_PARAMS AllocParams;

        hrResTmp = GetData(&pvServer,&dwServerInstance);
        if (SUCCEEDED(hrResTmp)) {
            ZeroMemory(&AllocParams, sizeof(AllocParams));
            AllocParams.m_EventSmtpServer = (LPVOID *) pvServer;
            AllocParams.m_InstanceId = dwServerInstance;
            AllocParams.m_dwStartupType = SMTP_INIT_BINDING_CHANGE;

            hrResTmp = OnEvent(CATID_SMTP_STORE_DRIVER,SMTP_STOREDRV_STARTUP_EVENT,&AllocParams);
            _ASSERT(SUCCEEDED(hrResTmp));
        }
    }
    return (hrRes);
}


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::CSMTPSeoMgr
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:24:18: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::CSMTPSeoMgr");

    m_dwSignature = SIGNATURE_CSMTPSEOMGR;
    m_pIEventRouter = NULL;
    m_pICatDispatcher = NULL;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::~CSMTPSeoMgr
//
// Synopsis: Deinitialize if necessary
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:26:09: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::~CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::~CSMTPSeoMgr");

    Deinit();

    _ASSERT(m_dwSignature == SIGNATURE_CSMTPSEOMGR);
    m_dwSignature = SIGNATURE_CSMTPSEOMGR_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::~CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrInit
//
// Synopsis: Initialize
//
// Arguments:
//  dwVSID: The virtual server ID
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:27:30: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrInit(
    DWORD dwVSID)
{
    HRESULT hr = S_OK;
    CStoreDispatcherClassFactory cf;
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrInit");

    _ASSERT(m_pIEventRouter == NULL);

    hr = SEOGetRouter(
        GUID_SMTP_SOURCE_TYPE,
        (REFGUID) CStringGUID(GUID_SMTPSVC_SOURCE, dwVSID),
        &m_pIEventRouter);

    if(FAILED(hr) || (hr == S_FALSE)) {
        //
        // Map S_FALSE to file not found -- this happens when the
        // source type is not registered
        //
        if(hr == S_FALSE)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        ErrorTrace((LPARAM)this, "SEOGetRouter failed hr %08lx", hr);
        m_pIEventRouter = NULL;
        goto CLEANUP;
    }
    //
    // Grab the dispatcher for the categorizer
    //
    _ASSERT(m_pICatDispatcher == NULL);

    hr = m_pIEventRouter->GetDispatcherByClassFactory(
        CLSID_CStoreDispatcher,
        &cf,
        CATID_SMTP_TRANSPORT_CATEGORIZE,
        IID_IServerDispatcher,
        (IUnknown **) &m_pICatDispatcher);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
        m_pICatDispatcher = NULL;
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr))
        Deinit();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrInit



//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::Deinit
//
// Synopsis: Deinitialize member variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:41:20: Created.
//
//-------------------------------------------------------------
VOID CSMTPSeoMgr::Deinit()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::Deinit");

    if(m_pICatDispatcher) {
        m_pICatDispatcher->Release();
        m_pICatDispatcher = NULL;
    }

    if(m_pIEventRouter) {
        m_pIEventRouter->Release();
        m_pIEventRouter = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::Deinit


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrTriggerServerEvent
//
// Synopsis: Trigger a server event
//
// Arguments:
//  dwEventType: event type to trigger
//  pvContext: structure specific to event type (see smtpseo.h)
//
// Returns:
//  S_OK: Success, called one or more sinks
//  S_FALSE: Success, no sinks called
//  MAILTRANSPORT_S_PENDING: Proccessing events async
//  E_OUTOFMEMORY
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:43:00: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrTriggerServerEvent(
    DWORD dwEventType,
    PVOID pvContext)
{
    HRESULT hr = S_OK;
    CComPtr<IServerDispatcher> pEventDispatcher;
    CStoreDispatcherClassFactory cf;
    REFIID iidBindingPoint = GuidForEvent(dwEventType);
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrTriggerServerEvent");

    if(m_pIEventRouter == NULL)
        return E_POINTER;

    if(iidBindingPoint == CATID_SMTP_TRANSPORT_CATEGORIZE) {
        //
        // Use the cached Categorizer dispatcher
        //
        pEventDispatcher = m_pICatDispatcher;

    } else {
        //
        // Get the latest dispatcher with all changes
        //
        hr = m_pIEventRouter->GetDispatcherByClassFactory(
            CLSID_CStoreDispatcher,
            &cf,
            iidBindingPoint,
            IID_IServerDispatcher,
            (IUnknown **) &pEventDispatcher);

        if (FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
            goto CLEANUP;
        }
    }

    hr = pEventDispatcher->OnEvent(
        iidBindingPoint,
        dwEventType,
        pvContext);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrTriggerServerEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\newwild.cpp ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\account.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       account.cxx
//
//  Contents:   Code to read and set the passwords for services. Adopted from
//              the code used by the service control manager to do the same.
//
//  Classes:
//
//  Functions:  SCMgrGetPassword
//              ScGetPassword
//              ScOpenPolicy
//              ScFormSecretName
//              MapNTStatus
//
//  History:    January 16, 1998    Milans Created
//
//-----------------------------------------------------------------------------

#include "smtpinc.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"
#include "account.h"

DWORD ScGetPassword(
    LPSTR szServiceName,
    LPSTR *pszPassword);

DWORD ScOpenPolicy(
    ACCESS_MASK DesiredAccess,
    LSA_HANDLE *PolicyHandle);

DWORD
ScFormSecretName(
    LPSTR szServiceName,
    LPWSTR *pwszSecretName);

DWORD
MapNTStatus(
    NTSTATUS ntstatus);

//+----------------------------------------------------------------------------
//
//  Function:   SCMgrGetPassword
//
//  Synopsis:   Reads the password configured for a given service.
//
//  Arguments:  [szServiceName] -- Name of service.
//              [cbPassword] -- Size in bytes of pszPassword buffer.
//              [pszPassword] -- The buffer in which to return the password.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning password.
//              [ERROR_MORE_DATA] -- Password too big for passed in buffer.
//              [ERROR_INVALID_SREVICE_ACCOUNT] -- Unable to find password for
//                  specified service.
//              [ERROR_ACCESS_DENIED] -- Priviledge violation reading password
//
//-----------------------------------------------------------------------------

DWORD SCMgrGetPassword(
    LPSTR szServiceName,
    DWORD cbPassword,
    LPSTR pszPassword)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPSTR pszAllocatedPassword;

    pszAllocatedPassword = NULL;

    dwErr = ScGetPassword(szServiceName, &pszAllocatedPassword);

    if (dwErr == ERROR_SUCCESS) {

        if (strlen(pszAllocatedPassword) < cbPassword)
            strcpy(pszPassword, pszAllocatedPassword);
        else
            dwErr = ERROR_MORE_DATA;

        delete [] pszAllocatedPassword;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ScGetPassword
//
//  Synopsis:   Retrieves the configured password for a given service
//
//  Arguments:  [szServiceName] -- Name of service for which the configured
//                  password is to be retrieved.
//              [pszPassword] -- On successful return, a string is allocated
//                  using new and the password returned in it. Caller should
//                  free using delete.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning password.
//              [ERROR_INVALID_SERVICE_ACCOUNT] -- Service name not found.
//              [ERROR_ACCESS_DENIED] -- No access to password registry
//
//-----------------------------------------------------------------------------

DWORD ScGetPassword(
    LPSTR szServiceName,
    LPSTR *pszPassword)
{
    DWORD dwErr;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    LPWSTR LsaSecretName;
    UNICODE_STRING SecretNameString;
    PUNICODE_STRING NewPasswordString;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_CREATE_SECRET,
            &PolicyHandle
            ) != NO_ERROR) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Form the secret name under which the service password is stored
    //
    if ((dwErr = ScFormSecretName(
                      szServiceName,
                      &LsaSecretName
                      )) != ERROR_SUCCESS) {
        (void) LsaClose(PolicyHandle);
        return dwErr;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaRetrievePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   &NewPasswordString
                   );

    if (NT_SUCCESS(ntstatus)) {

        *pszPassword = new CHAR[ NewPasswordString->Length + 1 ];

        if (*pszPassword != NULL) {

            wcstombs(
                *pszPassword,
                NewPasswordString->Buffer,
                NewPasswordString->Length/sizeof(WCHAR));

            (*pszPassword)[NewPasswordString->Length/sizeof(WCHAR)] = 0;

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = E_OUTOFMEMORY;

        }

    } else {

        dwErr = MapNTStatus( ntstatus );
    }

    delete [] LsaSecretName;

    (void) LsaClose(PolicyHandle);

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   ScOpenPolicy
//
//  Synopsis:   Opens the local security policy by calling LsaOpenPolicy.
//
//  Arguments:  [DesiredAccess] -- Desired access to Policy.
//              [PolicyHandle] -- The policy handle is returned here.
//
//  Returns:    [ERROR_SUCCESS] -- Successful return.
//              [ERROR_ACCESS_DENIED] -- No access to lsa policy.
//
//-----------------------------------------------------------------------------

DWORD ScOpenPolicy(
    ACCESS_MASK DesiredAccess,
    LSA_HANDLE *PolicyHandle)
{
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   DesiredAccess,
                   PolicyHandle
                   );

    return( MapNTStatus( ntstatus ) );

}

//+----------------------------------------------------------------------------
//
//  Function:   ScFormSecretName
//
//  Synopsis:   Forms the secret name used to store the password for the
//              service.
//
//  Arguments:  [szServiceName] -- The service name for which the
//                  corresponding secret name is required.
//              [pwszSecretName] -- On successful return, a newly allocated
//                  buffer, containing the UNICODE secret name, is returned
//                  here. Caller should free using delete.
//
//  Returns:    [ERROR_SUCCESS] -- If successful
//              [E_OUTOFMEMORY] -- If unable to allocate space for
//                  pwszSecretName.
//
//-----------------------------------------------------------------------------

#define SC_SECRET_PREFIX "_SC_"
#define SC_SECRET_PREFIX_W L"_SC_"

DWORD
ScFormSecretName(
    LPSTR szServiceName,
    LPWSTR *pwszSecretName)
{
    DWORD cLen, cServiceNameLen;

    cServiceNameLen = strlen(szServiceName);

    cLen = sizeof( SC_SECRET_PREFIX ) + cServiceNameLen + 1;

    *pwszSecretName = new WCHAR[ cLen ];

    if (*pwszSecretName != NULL) {

        wcscpy( *pwszSecretName, SC_SECRET_PREFIX_W );

        mbstowcs(
            &(*pwszSecretName)[sizeof(SC_SECRET_PREFIX) - 1],
            szServiceName,
            cServiceNameLen + 1);

        return( ERROR_SUCCESS );

    } else {

        return( E_OUTOFMEMORY );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   MapNTStatus
//
//  Synopsis:   Simple function to map some registry related NT statuses to
//              Win32 errors.
//
//  Arguments:  [ntstatus] -- The NT Status to map
//
//  Returns:    Win32 error corresponding to ntstatus
//
//-----------------------------------------------------------------------------

DWORD
MapNTStatus(
    NTSTATUS ntstatus)
{
    DWORD dwErr;

    switch (ntstatus) {
    case STATUS_SUCCESS:
        dwErr = ERROR_SUCCESS;
        break;

    case STATUS_ACCESS_DENIED:
        dwErr = ERROR_ACCESS_DENIED;
        break;

    default:
        dwErr = ERROR_INVALID_SERVICE_ACCOUNT;
        break;

    }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\admin.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    This module contains code for doing admin rpcs

Author:

    Todd Christensen (ToddCh)     28-Apr-1996

Revision History:

    Rohan Phillips (Rohanp) - enabled virtual server support 4-Feb-1997

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpsvc.h"
#include "smtpcli.hxx"
#include "admin.hxx"

// Address validation lib (KeithLau 7/28/96)
#include "address.hxx"
#include "findiis.hxx"
#include <stdio.h>
#include <malloc.h>

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return(TRUE);
    return(FALSE);
}

//
// Quick and dirty range check using inlines
//
static inline BOOL pValidateRange(DWORD dwValue, DWORD dwLower, DWORD dwUpper)
{
    // Inclusive
    if ((dwValue >= dwLower) && (dwValue <= dwUpper))
        return(TRUE);

    SetLastError(ERROR_INVALID_PARAMETER);
    return(FALSE);
}

NET_API_STATUS
NET_API_FUNCTION
SmtprGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pszServer - unused
       ppConfig - Receives pointer to admin information

   Note:

--*/
{
    SMTP_CONFIG_INFO * pConfig;
    PSMTP_SERVER_INSTANCE pInstance;
    DWORD            err = NO_ERROR;

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (IsBadWritePtr((LPVOID)ppConfig, sizeof(LPSMTP_CONFIG_INFO)))
        return(ERROR_INVALID_PARAMETER);

    // In case we exit on an error...
    *ppConfig = NULL;

    if ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION ))
        return err;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (!ConvertSmtpConfigToRpc(&pConfig, pInstance))
    {
        err = GetLastError();
        goto exit;
    }

    if (!ConvertSmtpRoutingListToRpc(&(pConfig->RoutingList), pInstance))
    {
        FreeRpcSmtpConfig(pConfig);
        err = GetLastError();
        goto exit;
    }

    *ppConfig = pConfig;

exit:

    pInstance->Dereference();
    return err;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  SMTP_CONFIG_INFO *      pConfig,
    IN  DWORD                   dwInstance
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pszServer - unused
       pConfig - Admin information to set

   Note:

--*/
{
    PSMTP_SERVER_INSTANCE pInstance;

    if (IsBadReadPtr((LPVOID)pConfig, sizeof(SMTP_CONFIG_INFO)))
        return(ERROR_INVALID_PARAMETER);

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    DWORD err;

    if ( err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION ))
        return err;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance != NULL)
    {
        // raid 129712 - we treat this case the same as before.
        if ( !(pInstance->WriteRegParams(pConfig)) ||
         !(pInstance->ReadRegParams(pConfig->FieldControl, TRUE)))
        {
            pInstance->Dereference();
            return GetLastError();
        }

        pInstance->Dereference();
        return NO_ERROR;
    }

    return ERROR_INVALID_DATA;
}



//+---------------------------------------------------------------
//
//  Function:   ConvertSmtpConfigToRpc
//
//  Synopsis:   Moves config values into the RPC structure
//
//  Arguments:  LPSMTP_CONFIG_INFO *: structure to be filled with
//                  configuration data.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL ConvertSmtpConfigToRpc(LPSMTP_CONFIG_INFO *ppConfig, PSMTP_SERVER_INSTANCE pInstance)
{
    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}


void FreeRpcSmtpConfig(LPSMTP_CONFIG_INFO pConfig)
{
    if (pConfig)
    {
        if (pConfig->lpszSmartHostName)
            FreeRpcString(pConfig->lpszSmartHostName);
        if (pConfig->lpszConnectResp)
            FreeRpcString(pConfig->lpszConnectResp);
        if (pConfig->lpszBadMailDir)
            FreeRpcString(pConfig->lpszBadMailDir);

        if (pConfig->RoutingList)
            FreeRpcSmtpRoutingList(pConfig->RoutingList);

        MIDL_user_free(pConfig);
    }
}


BOOL ConvertSmtpRoutingListToRpc(LPSMTP_CONFIG_ROUTING_LIST *ppRoutingList, PSMTP_SERVER_INSTANCE pInstance)
{
#if 0
    LPSMTP_CONFIG_ROUTING_LIST  pRoutingList;
    DWORD                       dwErr;
    DWORD                       iSource;
    DWORD                       cSources = 0;
    DWORD                       cbAlloc;
    PLIST_ENTRY                 pEntry;
    PLIST_ENTRY                 pHead;

    cSources = pInstance->GetRoutingSourceCount();

    cbAlloc = sizeof(SMTP_CONFIG_ROUTING_LIST) + cSources * sizeof(SMTP_CONFIG_ROUTING_ENTRY);
    pRoutingList = (LPSMTP_CONFIG_ROUTING_LIST) MIDL_user_allocate(cbAlloc);
    if (!pRoutingList)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    ZeroMemory(pRoutingList, cbAlloc);

    pRoutingList->cEntries = cSources;
    pHead = pInstance->GetRoutingSourceList();

    for (pEntry = pHead->Flink, iSource = 0 ; pEntry != pHead ; pEntry = pEntry->Flink, iSource++)
    {
        if (!ConvertStringToRpc(&(pRoutingList->aRoutingEntry[iSource].lpszSource),
                CONTAINING_RECORD(pEntry, ABSOURCE, list)->szConfig))
        {
            dwErr = GetLastError();
            for (iSource = 0 ; iSource < cSources ; iSource++)
            {
                if (pRoutingList->aRoutingEntry[iSource].lpszSource)
                    FreeRpcString(pRoutingList->aRoutingEntry[iSource].lpszSource);
            }

            MIDL_user_free(pRoutingList);
            SetLastError(dwErr);
            return FALSE;
        }
    }

    *ppRoutingList = pRoutingList;
#endif

    return FALSE;
}



void FreeRpcSmtpRoutingList(LPSMTP_CONFIG_ROUTING_LIST pRoutingList)
{
    DWORD       iSource;

    if (pRoutingList)
    {
        for (iSource = 0 ; iSource < pRoutingList->cEntries ; iSource++)
        {
            if (pRoutingList->aRoutingEntry[iSource].lpszSource)
                FreeRpcString(pRoutingList->aRoutingEntry[iSource].lpszSource);
        }

        MIDL_user_free(pRoutingList);
    }
}



NET_API_STATUS
NET_API_FUNCTION
SmtprGetConnectedUserList(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONN_USER_LIST   *ppConnUserList,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Retrieves the connected user list

   Arguments:

       pszServer - unused
       ppConnUserList - Receives pointer to admin information

   Note:

--*/
{
    SMTP_CONN_USER_LIST     *pConnUserList;
    SMTP_CONN_USER_ENTRY    *pConnEntry;
    DWORD                   dwErr;
    PLIST_ENTRY             pleHead;
    PLIST_ENTRY             pleT;
    SMTP_CONNECTION         *pConn;
    DWORD                   iEntry;
    DWORD                   NumUsers = 0;
    PSMTP_SERVER_INSTANCE pInstance;

    // In case we exit on an error...
    *ppConnUserList = NULL;

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (IsBadWritePtr((LPVOID)ppConnUserList, sizeof(LPSMTP_CONN_USER_LIST)))
        return(ERROR_INVALID_PARAMETER);

    if (dwErr = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION))
        return dwErr;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance->LockConfig();

    //loop through the list to get the count of all connected users.
    //These are users whose sockets are not equal to INVALID_SOCKET
    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);
        if(pConn->QueryClientSocket() != INVALID_SOCKET)
        {
            NumUsers++;
        }
    }

    pConnUserList = (SMTP_CONN_USER_LIST *)MIDL_user_allocate(sizeof(SMTP_CONN_USER_LIST) +
        sizeof(SMTP_CONN_USER_ENTRY) * NumUsers);
    if (!pConnUserList)
    {
        pInstance->UnLockConfig();
        pInstance->Dereference();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pConnUserList->cEntries = NumUsers;
    pConnEntry = pConnUserList->aConnUserEntry;
    ZeroMemory(pConnEntry, sizeof(SMTP_CONN_USER_ENTRY) * pConnUserList->cEntries);

    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);

        //disregard anyone whose socket is invalid
        if(pConn->QueryClientSocket() == INVALID_SOCKET)
            continue;

        pConnEntry->dwUserId = pConn->QueryClientId();
        pConnEntry->dwConnectTime = pConn->QuerySessionTime();
        if (pConn->QueryClientUserName())
        {
            if (!ConvertStringToRpc(&(pConnEntry->lpszName), pConn->QueryClientUserName()))
            {
                pInstance->UnLockConfig();

                pConnEntry = pConnUserList->aConnUserEntry;
                for (iEntry = 0 ; iEntry < pConnUserList->cEntries ; iEntry++, pConnEntry++)
                {
                    if (pConnEntry->lpszName)
                        FreeRpcString(pConnEntry->lpszName);
                    if (pConnEntry->lpszHost)
                        FreeRpcString(pConnEntry->lpszHost);
                }
                MIDL_user_free(pConnUserList);

                pInstance->Dereference();
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if (pConn->QueryClientHostName())
        {
            if (!ConvertStringToRpc(&(pConnEntry->lpszHost), pConn->QueryClientHostName()))
            {
                pInstance->UnLockConfig();

                pConnEntry = pConnUserList->aConnUserEntry;
                for (iEntry = 0 ; iEntry < pConnUserList->cEntries ; iEntry++, pConnEntry++)
                {
                    if (pConnEntry->lpszName)
                        FreeRpcString(pConnEntry->lpszName);
                    if (pConnEntry->lpszHost)
                        FreeRpcString(pConnEntry->lpszHost);
                }
                MIDL_user_free(pConnUserList);
                pInstance->Dereference();
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        pConnEntry++;
    }

    pInstance->UnLockConfig();
    *ppConnUserList = pConnUserList;

    pInstance->Dereference();
    return NO_ERROR;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprDisconnectUser(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  DWORD                   dwUserId,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Disconnects the specified user

   Arguments:

       pszServer - unused
       dwUserId - user to disconnect

   Note:

--*/
{
    DWORD                   dwErr;
    PLIST_ENTRY             pleHead;
    PLIST_ENTRY             pleT;
    SMTP_CONNECTION         *pConn;
    PSMTP_SERVER_INSTANCE pInstance;


    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (dwErr = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION))
        return dwErr;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance->LockConfig();

    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);
        if (pConn->QueryClientId() == dwUserId)
        {
            pConn->DisconnectClient();
            pInstance->UnLockConfig();
            pInstance->Dereference();

            return NO_ERROR;
        }
    }

    pInstance->UnLockConfig();
    pInstance->Dereference();
    return ERROR_NO_SUCH_USER;
}



/*++

    Description:
        Adds a user

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateUser(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszForwardEmail,
    IN  DWORD                   dwLocal,
    IN  DWORD                   dwMailboxSize,
    IN  DWORD                   dwMailboxMessageSize,
    IN  LPWSTR                  wszVRoot,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szForward = NULL;
    LPSTR   szVRoot = NULL;
    HANDLE  hToken;
    DWORD   cbRoot;
    char    szRoot[MAX_PATH + 1];
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateUser");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (wszForwardEmail &&
        !pValidateStringPtr(wszForwardEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (wszVRoot &&
        !pValidateStringPtr(wszVRoot, AB_MAX_VROOT))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Forward: %ls", wszForwardEmail ? wszForwardEmail : L"<NULL>");
    if (wszForwardEmail)
    {
        szForward = ConvertUnicodeToAnsi(wszForwardEmail, NULL, 0);
        if (!szForward)
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszForwardEmail, dwErr);
            TCP_FREE(szEmail);
            pInstance->Dereference();
            TraceFunctLeave();
            return dwErr;
        }
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail)) // Note: ANSI version
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (wszForwardEmail)
        if (!CAddr::ValidateEmailName(szForward)) // Note: ANSI version
        {
            ErrorTrace(NULL, "Invalid parameter: wszForwardEmail (%ls)\n",
                       (wszForwardEmail)?wszForwardEmail:L"NULL");
            if (szForward)
                TCP_FREE(szForward);
            TCP_FREE(szEmail);
            pInstance->Dereference();
            TraceFunctLeave();
            return(ERROR_INVALID_PARAMETER);
        }
    if (!pValidateRange(dwLocal, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: dwLocal (%u)\n",
                   dwLocal);
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    // VRoot is checked downstream

    DebugTrace(NULL, "Create mailbox: %s", dwLocal ? "TRUE" : "FALSE");
    if (dwLocal)
    {
        DebugTrace(NULL, "VRoot: %ls", wszVRoot ? wszVRoot : L"<NULL>");
        if (wszVRoot)
        {
            szVRoot = ConvertUnicodeToAnsi(wszVRoot, NULL, 0);
            if (!szVRoot)
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszVRoot, dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }

            DWORD dwAccessMask = 0;

            // Parameter checking for valid vroot
            cbRoot = sizeof(szRoot);
            if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
                szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                &hToken, NULL))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to resolve virtual root(%ls): %u", wszVRoot, dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                TCP_FREE(szVRoot);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }
        }
        else
        {
            szVRoot = (LPSTR)TCP_ALLOC(MAX_PATH);
            if (!szVRoot)
            {
                ErrorTrace(NULL, "Allocation failed");
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if (!pInstance->FindBestVRoot(szVRoot))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to FindBestVRoot: %u", dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }

        }
    }

/*
    if (!pInstance->PRtx()->CreateUser(szEmail, szForward, dwLocal, szVRoot, dwMailboxSize, dwMailboxMessageSize))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to create user %s: %u", szEmail, dwErr);
        if (szVRoot)
            TCP_FREE(szVRoot);
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }
*/
    if (szVRoot)
        TCP_FREE(szVRoot);
    if (szForward)
        TCP_FREE(szForward);
    TCP_FREE(szEmail);

    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Deletes a user

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteUser(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwInstance
    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprDeleteUser");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

/*
    if (!pInstance->PRtx()->DeleteUser(szEmail))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete user %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }
*/

    TCP_FREE(szEmail);
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Gets user properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprGetUserProps(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    OUT LPSMTP_USER_PROPS       *ppUserProps,
    IN  DWORD                   dwInstance

    )
{
#if 0
    LPSTR               szEmail;
    DWORD               dwErr;
    LPSMTP_USER_PROPS   pUserProps;
    RTX_USER_PROPS      rtxuserprops;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetUserProps");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppUserProps, sizeof(LPSMTP_USER_PROPS)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    if (!pInstance->PRtx()->GetUserProps(szEmail, &rtxuserprops))
    {
        ErrorTrace(NULL, "GetUserProps call failed: %u", GetLastError());
        TCP_FREE(szEmail);
        pInstance->Dereference();
        return GetLastError();
    }
    TCP_FREE(szEmail);

    pUserProps = (LPSMTP_USER_PROPS) MIDL_user_allocate(sizeof(SMTP_USER_PROPS));

    if (!ConvertStringToRpc(&(pUserProps->wszForward), rtxuserprops.szForward))
    {
        ErrorTrace(NULL, "Unable to convert forward to rpc string: %u", GetLastError());
        MIDL_user_free(pUserProps);
        pInstance->Dereference();

        return GetLastError();
    }

    if (!ConvertStringToRpc(&(pUserProps->wszVRoot), rtxuserprops.szVRoot))
    {
        ErrorTrace(NULL, "Unable to convert vroot to rpc string: %u", GetLastError());
        FreeRpcString(pUserProps->wszForward);
        MIDL_user_free(pUserProps);
        pInstance->Dereference();

        return GetLastError();
    }

    pUserProps->dwMailboxMax = rtxuserprops.cbMailBoxSize;
    pUserProps->dwMailboxMessageMax = rtxuserprops.cbMailboxMessageSize;
    pUserProps->dwLocal = rtxuserprops.fLocal;
    pUserProps->fc = FC_SMTP_USER_PROPS_ALL;

    *ppUserProps = pUserProps;

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
#endif 

	return ERROR_INVALID_PARAMETER;
}



/*++

    Description:
        Sets a users properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprSetUserProps(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPSMTP_USER_PROPS       pUserProps,
    IN  DWORD                   dwInstance

    )
{
#if 0

    DWORD   dwErr;
    DWORD   dwErrKeep = NO_ERROR;
    LPSTR   szEmail = NULL;
    LPSTR   szForward = NULL;
    LPSTR   szVRoot = NULL;
    HANDLE  hToken;
    DWORD   cbRoot;
    char    szRoot[MAX_PATH + 1];
    BOOL    fSet;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprSetUserProps");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadReadPtr((LPVOID)pUserProps, sizeof(SMTP_USER_PROPS)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    if (!pUserProps->fc)
    {
        // Nothing to do...
        pInstance->Dereference();
        return NO_ERROR;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pUserProps)
    {
        ErrorTrace(NULL, "Invalid parameter: pUserProps (NULL)\n");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    // More checking downstream ...

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_FORWARD))
    {
        fSet = TRUE;

        if (pUserProps->wszForward)
        {
            szForward = ConvertUnicodeToAnsi(pUserProps->wszForward, NULL, 0);
            if (!szForward)
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", pUserProps->wszForward, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
                fSet = FALSE;
            }
        }
        else
        {
            szForward = NULL;
        }

        // Parameter check for forward
        if (szForward &&
            !CAddr::ValidateEmailName(szForward))
        {
            ErrorTrace(NULL, "Invalid parameter: pconfig->pUserProps->wszForward (%s)\n",
                       (pUserProps->wszForward)?pUserProps->wszForward:L"NULL");
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = ERROR_INVALID_PARAMETER;
            fSet = FALSE;
        }

        if (fSet)
        {
            if (!pInstance->PRtx()->SetForward(szEmail, szForward))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to set forward for %s: %d", szEmail, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
            }
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_MAILBOX_SIZE))
    {
        if (!pInstance->PRtx()->SetMailboxSize(szEmail, pUserProps->dwMailboxMax))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to set mailbox size for %s: %d", szEmail, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE))
    {
        if (!pInstance->PRtx()->SetMailboxMessageSize(szEmail, pUserProps->dwMailboxMessageMax))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to set mailbox size for %s: %d", szEmail, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_VROOT))
    {
        fSet = TRUE;
        szVRoot = ConvertUnicodeToAnsi(pUserProps->wszVRoot, NULL, 0);
        if (!szVRoot)
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", pUserProps->wszVRoot, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
            fSet = FALSE;
        }

        DWORD dwAccessMask = 0;

        // Parameter checking for VRoot
        cbRoot = sizeof(szRoot);
        if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
                szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                &hToken, NULL))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to resolve virtual root(%ls): %u", pUserProps->wszVRoot, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
            fSet = FALSE;
        }

        if (fSet)
        {
            if (!pInstance->PRtx()->SetVRoot(szEmail, szVRoot))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to set vroot for %s: %d", szEmail, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
            }
        }
    }

    if (szVRoot)
        TCP_FREE(szVRoot);
    if (szForward)
        TCP_FREE(szForward);
    TCP_FREE(szEmail);

    pInstance->Dereference();

    TraceFunctLeave();
    return dwErrKeep;

#endif
	return ERROR_INVALID_PARAMETER;
}



/*++

    Description:
        Creates a DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateDistList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwInstance

    )
{
#if 0
    DWORD   dwErr;
    LPSTR   szEmail;
    DWORD   dwRtxType;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateDistList");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (dwType == NAME_TYPE_LIST_NORMAL)
        dwRtxType = rtxnameDistListNormal;
    else if (dwType == NAME_TYPE_LIST_SITE)
        dwRtxType = rtxnameDistListSite;
    else if (dwType == NAME_TYPE_LIST_DOMAIN)
        dwRtxType = rtxnameDistListDomain;
    else
    {
        ErrorTrace(NULL, "TYPE is not NAME_TYPE_LIST_NORMAL or NAME_TYPE_LIST_SITE");
        pInstance->Dereference();
        TraceFunctLeave();
        return ERROR_INVALID_PARAMETER;
    }


    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    if (!pInstance->PRtx()->CreateDistList(szEmail, dwRtxType))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to create list %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmail);
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
#endif

	return ERROR_INVALID_PARAMETER;
}


/*++

    Description:
        Deletes a DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteDistList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    PSMTP_SERVER_INSTANCE pInstance;

    TraceFunctEnter("SmtprDeleteDistList");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->DeleteDistList(szEmail))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete list %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Adds a member to the DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateDistListMember(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszEmailMember,
    IN  DWORD                   dwInstance
    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szMember;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateDistListMember");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmailMember, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }

    szMember = ConvertUnicodeToAnsi(wszEmailMember, NULL, 0);
    if (!szMember)
    {
        dwErr = GetLastError();
	TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmailMember, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!CAddr::ValidateEmailName(szMember))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailMember (%ls)\n",
                   (wszEmailMember)?wszEmailMember:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->CreateDistListMember(szEmail, szMember))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to add member %s to %s: %d", szMember, szEmail, dwErr);
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szMember);
    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Deletes a member from the DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteDistListMember(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszEmailMember,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szMember;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprDeleteDistListMember");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmailMember, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    szMember = ConvertUnicodeToAnsi(wszEmailMember, NULL, 0);
    if (!szMember)
    {
        dwErr = GetLastError();
	TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmailMember, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!CAddr::ValidateEmailName(szMember))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailMember (%ls)\n",
                   (wszEmailMember)?wszEmailMember:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->DeleteDistListMember(szEmail, szMember))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete member %s from %s: %d", szMember, szEmail, dwErr);
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szMember);
    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}



/*++

    Description:
        Sets DL properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprGetNameList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwRowsReq,
    IN  BOOL                    fForward,
    OUT LPSMTP_NAME_LIST        *ppNameList,
    IN  DWORD                   dwInstance

    )
{
#if 0

    DWORD               dwErr;
    HRTXENUM            hrtxenum;
    LPSTR               szEmail;
    DWORD               crowsReturned;
    DWORD               cbAlloc;
    DWORD               irows;
    LPSMTP_NAME_LIST    pNameList;
    DWORD               dwFlags;
    DWORD               cbNameEntry;
    char                szName[cbEmailNameMax];
    PSMTP_SERVER_INSTANCE pInstance;

    TraceFunctEnter("SmtprGetNameList");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppNameList, sizeof(LPSMTP_NAME_LIST)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    // Up front parameter check
    if (!pValidateRange(dwType, 1,15))
    {
        ErrorTrace(NULL, "Invalid parameter: dwType (%u)\n",
                   dwType);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(dwRowsReq, 1, 100))
    {
        ErrorTrace(NULL, "Invalid parameter: dwRowsReq (%u)\n",
                   dwRowsReq);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(fForward, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: fForward (%u)\n",
                   fForward);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!ppNameList)
    {
        ErrorTrace(NULL, "Invalid parameter: ppNameList (NULL)\n");
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }


    // More checks downstream

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter change
    if (szEmail[0] != 0 &&
            szEmail[0] != '@' &&
                !CAddr::ValidateEmailName(szEmail, TRUE))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwFlags = 0;
    if (dwType & NAME_TYPE_USER)
        dwFlags |= rtxnameUser;
    if (dwType & NAME_TYPE_LIST_NORMAL)
        dwFlags |= rtxnameDistListNormal;
    if (dwType & NAME_TYPE_LIST_SITE)
        dwFlags |= rtxnameDistListSite;
    if (dwType & NAME_TYPE_LIST_DOMAIN)
        dwFlags |= rtxnameDistListDomain;

    if (!pInstance->PRtx()->EnumNameList(szEmail, fForward, dwRowsReq, dwFlags, &hrtxenum))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to enum name list: %d", dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmail);

    crowsReturned = pInstance->PRtx()->EnumRowsReturned(hrtxenum);
    cbAlloc = sizeof(SMTP_NAME_LIST) + crowsReturned * sizeof(SMTP_NAME_ENTRY);

    pNameList = (LPSMTP_NAME_LIST)MIDL_user_allocate(cbAlloc);
    ZeroMemory(pNameList, cbAlloc);
    pNameList->cEntries = crowsReturned;

    for (irows = 0 ; irows < crowsReturned ; irows++)
    {
        cbNameEntry = cbEmailNameMax;
        if (!pInstance->PRtx()->GetNextEmail(hrtxenum, &(dwFlags),
                szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "GetNext failed on row %u: %u", irows, dwErr);
            pInstance->Dereference();
            return dwErr;
        }

        if (dwFlags & rtxnameUser)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_USER;
        if (dwFlags & rtxnameDistListNormal)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_NORMAL;
        if (dwFlags & rtxnameDistListSite)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_SITE;
        if (dwFlags & rtxnameDistListDomain)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_DOMAIN;

        if (!ConvertStringToRpc(&(pNameList->aNameEntry[irows].lpszName), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", szName, dwErr);
            pInstance->Dereference();
            return dwErr;
        }
    }

    _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
    _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));

    *ppNameList = pNameList;
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;

#endif

	return ERROR_INVALID_PARAMETER;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprGetNameListFromList(
    IN  SMTP_HANDLE         wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Performs a search within a list

   Arguments:

       wszServer - unused
       wszEmailList - Email list to search from
       wszEmail - Email name to search for
       dwType - Type of the Email name supplied
       dwRowsRequested - Number of rows requested
       fForward -
       ppNameList - pointer to pointer to name list to return

   Note:

       This RPC is added by Keith Lau (keithlau) on 7/5/96

--*/
{

#if 0
    DWORD               dwErr;
    HRTXENUM            hrtxenum;
    LPSTR               szEmail;
    LPSTR               szEmailList;
    DWORD               crowsReturned;
    DWORD               cbAlloc;
    DWORD               irows;
    LPSMTP_NAME_LIST    pNameList;
    DWORD               dwFlags;
    DWORD               cbNameEntry;
    char                szName[cbEmailNameMax];
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetNameListFromList");


    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmailList, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppNameList, sizeof(LPSMTP_NAME_LIST)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    if (!pValidateRange(dwType, 1, 15))
    {
        ErrorTrace(NULL, "Invalid parameter: dwType (%u)\n",
                   dwType);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(dwRowsRequested, 1, 100))
    {
        ErrorTrace(NULL, "Invalid parameter: dwRowsRequested (%u)\n",
                   dwRowsRequested);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(fForward, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: fForward (%u)\n",
                   fForward);
        pInstance->Dereference();

        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!ppNameList)
    {
        ErrorTrace(NULL, "Invalid parameter: ppNameList (NULL)\n");
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email list name: %ls", wszEmailList);
    szEmailList = ConvertUnicodeToAnsi(wszEmailList, NULL, 0);
    if (!szEmailList)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszEmailList, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (!CAddr::ValidateEmailName(szEmailList))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailList (%ls)\n",
                   (wszEmailList)?wszEmailList:L"NULL");
        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszEmail, dwErr);

        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (szEmail[0] != 0 &&
            szEmail[0] != '@' &&
                !CAddr::ValidateEmailName(szEmail, TRUE))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwFlags = 0;
    if (dwType & NAME_TYPE_USER)
        dwFlags |= rtxnameUser;
    if (dwType & NAME_TYPE_LIST_NORMAL)
        dwFlags |= rtxnameDistListNormal;
    if (dwType & NAME_TYPE_LIST_SITE)
        dwFlags |= rtxnameDistListSite;
    if (dwType & NAME_TYPE_LIST_DOMAIN)
        dwFlags |= rtxnameDistListDomain;

    if (!pInstance->PRtx()->EnumNameListFromDL(szEmailList,
                                    szEmail,
                                    fForward,
                                    dwRowsRequested,
                                    dwFlags,
                                    &hrtxenum))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to enum name list: %d", dwErr);
        TCP_FREE(szEmailList);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmailList);
    TCP_FREE(szEmail);

    crowsReturned = pInstance->PRtx()->EnumRowsReturned(hrtxenum);
    cbAlloc = sizeof(SMTP_NAME_LIST) + crowsReturned * sizeof(SMTP_NAME_ENTRY);

    pNameList = (LPSMTP_NAME_LIST)MIDL_user_allocate(cbAlloc);
    ZeroMemory(pNameList, cbAlloc);
    pNameList->cEntries = crowsReturned;

    for (irows = 0 ; irows < crowsReturned ; irows++)
    {
        cbNameEntry = cbEmailNameMax;
        if (!pInstance->PRtx()->GetNextEmail(hrtxenum, &(dwFlags), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "GetNext failed on row %u: %u", irows, dwErr);
            pInstance->Dereference();
            return dwErr;
        }

        if (dwFlags & rtxnameUser)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_USER;
        if (dwFlags & rtxnameDistListNormal)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_NORMAL;
        if (dwFlags & rtxnameDistListSite)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_SITE;
        if (dwFlags & rtxnameDistListDomain)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_DOMAIN;

        if (!ConvertStringToRpc(&(pNameList->aNameEntry[irows].lpszName), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", szName, dwErr);
            pInstance->Dereference();
            return dwErr;
        }
    }

    _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
    _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));

    *ppNameList = pNameList;

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;

#endif

	return ERROR_INVALID_PARAMETER;
}

NET_API_STATUS
NET_API_FUNCTION
SmtprGetVRootSize(
    IN  SMTP_HANDLE     wszServerName,
    IN  LPWSTR          wszVRoot,
    OUT LPDWORD         pdwBytes,
    IN  DWORD           dwInstance

    )
/*++

   Description

       Obtains the size of the specified VRoot

   Arguments:

       wszServer - unused
       wszVRoot - VRoot whose size to return
       pdwBytes - Pointer to a DWORD to contain the VRoot size on return

   Return Value:

       This call returns NO_ERROR on success. ERROR_INVALID_NAME is returned
       if ResolveVirtualRoot returns an invalid directory name. A Win32
       error code is returned for other error conditions.

   Note:

       This RPC is added by Keith Lau (keithlau) on 7/5/96

--*/
{
    HANDLE          hToken;
    DWORD           cbRoot;
    LPSTR           szVRoot;
    char            szRoot[MAX_PATH + 1];
    DWORD           dwErr;
    ULARGE_INTEGER  uliBytesAvail;
    ULARGE_INTEGER  uliBytesTotal;
    ULARGE_INTEGER  uliBytesFree;
    DWORD dwAccessMask = 0;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetVRootSize");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszVRoot, AB_MAX_VROOT))
    {
        ErrorTrace(NULL, "Invalid parameter: wszVRoot\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (IsBadWritePtr((LPVOID)pdwBytes, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pdwBytes\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    // Default the size to 0 bytes free
    *pdwBytes = 0;
    dwErr = NO_ERROR;

    // Access check
    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    // Resolve the Virtual Root, need Unicode - ANSI conversion
    cbRoot = sizeof(szRoot);
    DebugTrace(NULL, "VRoot name: %ls", wszVRoot);
    if (!(szVRoot = ConvertUnicodeToAnsi(wszVRoot, NULL, 0)))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszVRoot, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
        szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
        &hToken, NULL))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "ResolveVirtualRoot failed for %s, %u", wszVRoot, dwErr);
        TCP_FREE(szVRoot);
    }
    else
    {
        // Free it right away lest we forget
        TCP_FREE(szVRoot);

        DebugTrace(NULL, "Getting free disk ratio on %s", szRoot);
        if (hToken == 0 || ImpersonateLoggedOnUser(hToken))
        {
            if (GetDiskFreeSpaceEx(szRoot,
                                   &uliBytesAvail,
                                   &uliBytesTotal,
                                   &uliBytesFree))
            {
                // Make sure we are not overflowing 4Gig, which is easy
                _ASSERT(uliBytesAvail.HighPart == 0);
                *pdwBytes = uliBytesAvail.LowPart;
            }
            else
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "GetDiskFreeSpaceEx failed on %s: %u", szRoot, dwErr);
            }

            if (hToken != 0)
                _VERIFY(RevertToSelf());
        }
        else
        {
            ErrorTrace(NULL, "Impersonation failed");
            dwErr = GetLastError();
        }
    }

    pInstance->Dereference();
    TraceFunctLeave();
    return dwErr;
}




NET_API_STATUS
NET_API_FUNCTION
SmtprBackupRoutingTable(
    IN  SMTP_HANDLE     wszServerName,
    IN  LPWSTR          wszPath,
    IN  DWORD           dwInstance

    )
/*++

   Description

       Tells routing table to backup itself to the given path

   Arguments:

       wszServer - unused
       wszVRoot - Path to put backup file

   Return Value:

       This call returns NO_ERROR on success. Routing table error
       if routing table cannot create the backup

--*/
{

#if 0
    DWORD           dwErr;
    LPSTR           szBackupDir = NULL;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprBackupRoutingTable");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszPath, MAX_PATH))
    {
        ErrorTrace(NULL, "Invalid parameter: wszPath\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = NO_ERROR;

    // Access check
    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    if (pInstance->PRtx()->GetRtType() != rttypeFF)
    {
        ErrorTrace(NULL, "Backup for non-FF routing table isn't allowed!");
        pInstance->Dereference();
        return ERROR_NOT_SUPPORTED;
    }

    if (!(szBackupDir = ConvertUnicodeToAnsi(wszPath, NULL, 0)))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszPath, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (!pInstance->PRtx()->MakeBackup(szBackupDir))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to complete backup to %s: %d", szBackupDir, dwErr);
        TCP_FREE(szBackupDir);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szBackupDir);

    pInstance->Dereference();
    TraceFunctLeave();
    return dwErr;
#endif

	return ERROR_INVALID_PARAMETER;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\adns.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) Library

    Send response routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "dnsreci.h"
#include <dnsapi.h>
#include "cdns.h"
#include <time.h>

extern CTcpRegIpList g_TcpRegIpList;
WORD    gwTransactionId = 1;


VOID
DnsCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    )
{
    BOOL WasProcessed = TRUE;
    CAsyncDns *pCC = (CAsyncDns *) pvContext;

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());

    //
    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    //
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
}

void DeleteDnsRec(PSMTPDNS_RECS pDnsRec)
{
    DWORD Loop = 0;
    PLIST_ENTRY  pEntry = NULL;
    PMXIPLIST_ENTRY pQEntry = NULL;

    if(pDnsRec == NULL)
    {
        return;
    }

    while (pDnsRec->DnsArray[Loop] != NULL)
    {
        if(pDnsRec->DnsArray[Loop]->DnsName[0])
        {
            while(!IsListEmpty(&pDnsRec->DnsArray[Loop]->IpListHead))
            {
                pEntry = RemoveHeadList (&pDnsRec->DnsArray[Loop]->IpListHead);
                pQEntry = CONTAINING_RECORD( pEntry, MXIPLIST_ENTRY, ListEntry);
                delete pQEntry;
            }

            delete pDnsRec->DnsArray[Loop];
        }
        Loop++;
    }

    if(pDnsRec)
    {
        delete pDnsRec;
        pDnsRec = NULL;
    }
}

CAsyncDns::CAsyncDns(void)
{
    m_signature = DNS_CONNECTION_SIGNATURE_VALID;            // signature on object for sanity check

    m_cPendingIoCount = 0;

    m_cThreadCount = 0;

    m_cbReceived = 0;
    
    m_BytesToRead = 0;

    m_dwIpServer = 0;

    m_dwFlags = 0;

    m_Index = 0;

    m_LocalPref = 256;

    m_fUdp = TRUE;

    m_fUsingMx = TRUE;

    m_FirstRead = TRUE;

    //
    // By default we fail (AQUEUE_E_DNS_FAILURE) is the generic failure code. On success
    // this is set to ERROR_SUCCESS. We may also set this to a more specific error code
    // at the point of failure.
    //
    m_dwDiagnostic = AQUEUE_E_DNS_FAILURE;

    m_pMsgRecv = NULL;
    m_pMsgRecvBuf = NULL;

    m_pMsgSend = NULL;
    m_pMsgSendBuf = NULL;
    m_cbSendBufSize = 0;
    m_ppRecord = NULL;

    m_ppResponseRecords = NULL;
    
    m_pAtqContext = NULL;

    m_FQDNToDrop[0] = '\0';

    m_HostName [0] = '\0';

    m_SeenLocal = FALSE;

    ZeroMemory (m_Weight, sizeof(m_Weight));
    ZeroMemory (m_Prefer, sizeof(m_Prefer));
}

CAsyncDns::~CAsyncDns(void)
{
    PATQ_CONTEXT pAtqContext = NULL;

    //_ASSERT(m_cThreadCount == 0);

    if(m_pMsgSend)
    {
        delete [] m_pMsgSendBuf;
        m_pMsgSend = NULL;
        m_pMsgSendBuf = NULL;
    }

    if(m_pMsgRecv)
    {
        delete [] m_pMsgRecvBuf;
        m_pMsgRecv = NULL;
        m_pMsgRecvBuf = NULL;
    }

    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       AtqFreeContext( pAtqContext, TRUE );
    }

    DeleteDnsRec(m_AuxList);
    m_signature = DNS_CONNECTION_SIGNATURE_FREE;            // signature on object for sanity check
}

BOOL CAsyncDns::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    BOOL fRet = TRUE;

    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));

    m_ReadOverlapped.LastIoState = DNS_READIO;

    IncPendingIoCount();

    fRet = AtqReadFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        (OVERLAPPED *)&m_ReadOverlapped) ;

    if(!fRet)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    return fRet;
}

BOOL CAsyncDns::WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    BOOL fRet = TRUE;

    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.LastIoState = DNS_WRITEIO;

    IncPendingIoCount();

    fRet = AtqWriteFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        (OVERLAPPED *) &m_WriteOverlapped) ;

    if(!fRet)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    return fRet;
}

DNS_STATUS
CAsyncDns::SendPacket(void)
{

    return 0;
}


//
//  Public send routines
//

DNS_STATUS
CAsyncDns::Dns_Send(
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

Arguments:

    pMsg - message info for message to send

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    INT         err = 0;
    BOOL        fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_Send");


    DebugTrace((LPARAM) this, "Sending DNS request for %s", m_HostName);

    fRet = WriteFile(m_pMsgSendBuf, (DWORD) m_cbSendBufSize);
    
    if(!fRet)
    {
        err = GetLastError();
    }

    return( (DNS_STATUS)err );

} // Dns_Send


//-----------------------------------------------------------------------------------
// Description:
//      Kicks off an async query to DNS.
//
// Arguments:
//      IN pszQuestionName - Name to query for.
//
//      IN wQuestionType - Record type to query for.
//
//      IN dwFlags - DNS configuration flags for SMTP. Currently these dictate
//          what transport is used to talk to DNS (TCP/UDP). They are:
//
//              DNS_FLAGS_NONE - Use UDP initially. If that fails, or if the
//                  reply is truncated requery using TCP.
//
//              DNS_FLAGS_TCP_ONLY - Use TCP only.
//
//              DNS_FLAGS_UDP_ONLY - Use UDP only.
//
//      IN MyFQDN - FQDN of this machine (for MX record sorting)
//
//      IN fUdp - Should UDP or TCP be used for this query? When dwFlags is
//          DNS_FLAGS_NONE the initial query is UDP, and the retry query, if the
//          response was truncated, is TCP. Depending on whether we're retrying
//          this flag should be set appropriately by the caller.
//
// Returns:
//      ERROR_SUCCESS if an async query was pended
//      Win32 error if an error occurred and an async query was not pended. All
//          errors from this function are retryable (as opposed NDR'ing the message)
//          so the message is re-queued if an error occurred.
//-----------------------------------------------------------------------------------
DNS_STATUS
CAsyncDns::Dns_QueryLib(
        IN      DNS_NAME            pszQuestionName,
        IN      WORD                wQuestionType,
        IN      DWORD               dwFlags,
        IN      char               *MyFQDN,
        IN      BOOL                fUdp)
{
    DNS_STATUS      status = ERROR_NOT_ENOUGH_MEMORY;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_QueryLib");

    m_dwFlags = dwFlags;

    m_fUdp = fUdp;

    m_AuxList = new SMTPDNS_RECS;
    
    if(m_AuxList == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return (DNS_STATUS) ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(m_AuxList, sizeof(SMTPDNS_RECS));

    lstrcpyn(m_FQDNToDrop, MyFQDN, sizeof(m_FQDNToDrop));
    lstrcpyn(m_HostName, pszQuestionName, sizeof(m_HostName));

    MultiByteToWideChar( CP_ACP, 0, pszQuestionName, -1, m_wszHostName, MAX_PATH );

    //
    //  build send packet
    //

    m_pMsgSendBuf = new BYTE[DNS_TCP_DEFAULT_PACKET_LENGTH ];

    if( NULL == m_pMsgSendBuf )
    {
        TraceFunctLeaveEx((LPARAM) this);
        return (DNS_STATUS) ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwBufSize = DNS_TCP_DEFAULT_PACKET_LENGTH ;
    
    
    if( !m_fUdp )
    {
        m_pMsgSend = (PDNS_MESSAGE_BUFFER)(m_pMsgSendBuf+2);
        dwBufSize -= 2;
    }
    else
    {
        m_pMsgSend = (PDNS_MESSAGE_BUFFER)(m_pMsgSendBuf);
    }

    if( !DnsWriteQuestionToBuffer_UTF8 ( m_pMsgSend,
                                      &dwBufSize,
                                         pszQuestionName,
                                      wQuestionType,
                                      gwTransactionId++,
                                      !( dwFlags & DNS_QUERY_NO_RECURSION ) ) )
    {
        ErrorTrace((LPARAM) this, "Unable to create DNS query for %s", pszQuestionName);
        TraceFunctLeaveEx((LPARAM) this);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    m_cbSendBufSize = (WORD) dwBufSize;

    if( !m_fUdp )
    {
        *((u_short*)m_pMsgSendBuf) = htons((WORD)dwBufSize );
        m_cbSendBufSize += 2;
    }
    
    if (m_pMsgSend)
    {
        status = DnsSendRecord();
    }
    else
    {
        status = ERROR_INVALID_NAME;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return status;
}

void CAsyncDns::DisconnectClient(void)
{
    SOCKET  hSocket;

    hSocket = (SOCKET)InterlockedExchangePointer( (PVOID *)&m_DnsSocket, (PVOID) INVALID_SOCKET );
    if ( hSocket != INVALID_SOCKET )
    {
       if ( QueryAtqContext() != NULL )
       {
            AtqCloseSocket(QueryAtqContext() , TRUE);
       }
    }
}

//
//  TCP routines
//

DNS_STATUS
CAsyncDns::Dns_OpenTcpConnectionAndSend()
/*++

Routine Description:

    Connect via TCP or UDP to a DNS server. The server list is held
    in a global variable read from the registry.

Arguments:

    None

Return Value:

    ERROR_SUCCESS on success
    Win32 error on failure

--*/
{
    INT     err = 0;
    DWORD   dwErrServList = ERROR_SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_OpenTcpConnectionAndSend");

    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //
    if(!m_fUdp)
    {
        m_DnsSocket = Dns_CreateSocket(SOCK_STREAM);

        BOOL fRet = FALSE;
        int err;

        //Alway enable linger so sockets that connect to the server.
        //This will send a hard close to the server which will cause
        //the servers TCP/IP socket table to be flushed very early.
        //We should see very few, if any, sockets in the TIME_WAIT
        //state
        struct linger Linger;

        Linger.l_onoff = 1;
        Linger.l_linger = 0;
        err = setsockopt(m_DnsSocket, SOL_SOCKET, SO_LINGER, (const char FAR *)&Linger, sizeof(Linger));

    }
    else
    {
        m_DnsSocket = Dns_CreateSocket(SOCK_DGRAM);    
    }

    if ( m_DnsSocket == INVALID_SOCKET )
    {
        err = WSAGetLastError();

        if ( !err )
        {
            err = WSAENOTSOCK;
        }

        ErrorTrace((LPARAM) this, "Received error %d opening a socket to DNS server", err);

        return( err );
    }


    m_RemoteAddress.sin_family = AF_INET;
    m_RemoteAddress.sin_port = DNS_PORT_NET_ORDER;

    //
    // Get a DNS server from the set of servers for this machine and connect
    // to it. The g_TcpRegIpList has logic to keep track of the state of DNS
    // servers (UP or DOWN) and logic to retry DOWN DNS servers.
    //

    dwErrServList = g_TcpRegIpList.GetIp(&m_dwIpServer);
    while(ERROR_SUCCESS == dwErrServList)
    {
        m_RemoteAddress.sin_addr.s_addr = m_dwIpServer;
        err = connect(m_DnsSocket, (struct sockaddr *) &m_RemoteAddress, sizeof(SOCKADDR_IN));
        if ( !err )
        {
            break;
        }
        else
        {
            MarkDown(m_dwIpServer, err, m_fUdp);
            dwErrServList = g_TcpRegIpList.GetIp(&m_dwIpServer);
            continue;
        }
    }

    if(DNS_ERROR_NO_DNS_SERVERS == dwErrServList || ERROR_RETRY == dwErrServList)
    {
        //
        //  Log Event and set diagnostic: No DNS servers available.
        //
        err = DNS_ERROR_NO_DNS_SERVERS;
        m_dwDiagnostic = AQUEUE_E_NO_DNS_SERVERS;
        SmtpLogEventSimple(SMTP_NO_DNS_SERVERS, DNS_ERROR_NO_DNS_SERVERS);
        ErrorTrace((LPARAM) this, "No DNS servers. Error - %d", dwErrServList);
        return err;
    }

    _ASSERT(ERROR_SUCCESS == dwErrServList);

    //
    //  We have a connection to DNS
    //
    if(ERROR_SUCCESS == err)
    {
        //
        // NOTE: We've set the timeout to a hardcoded value of 1 minute. This might
        // seem excessively large for DNS, however, since the resolution of the ATQ
        // timer is 1 minute that's the minimum anyway. Might as well make it apparent.
        //


        // Re-associate the handle to the ATQ
        // Call ATQ to associate the handle
        if (!AtqAddAsyncHandle(
                        &m_pAtqContext,
                        NULL,
                        (LPVOID) this,
                        DnsCompletion,
                        60, // Timeout == 60 seconds
                        (HANDLE) m_DnsSocket))
        {
            return GetLastError();
        }

        //
        //  send desired packet
        //

        err = Dns_Send();
   }
   else
   {
       if(m_DnsSocket != INVALID_SOCKET)
       {
           closesocket(m_DnsSocket);
           m_DnsSocket = INVALID_SOCKET;
       }
   }

   return( (DNS_STATUS)err );

}   // Dns_OpenTcpConnectionAndSend

//------------------------------------------------------------------------------
//  Description:
//      Failed to connect to dwIpServer. Mark the server as DOWN, log
//      an event and write traces. This is a simple wrapper for
//      CTcpRegIpList::MarkDown.
//  Arguments:
//      DWORD dwIpServer - IP of server to which we failed to connect
//      DWORD dwErr - Win32 error if any
//      BOOL fUdp - Which transport was being used when the failure occurred.
//------------------------------------------------------------------------------
void CAsyncDns::MarkDown(DWORD dwIpServer, DWORD dwErr, BOOL fUdp)
{
    const CHAR *pszServerIp = NULL;
    const CHAR *pszProtocol = NULL;
    const CHAR *apszSubStrings[2];
    in_addr inAddrIpServer;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::MarkDown");

    CopyMemory(&inAddrIpServer, &dwIpServer, sizeof(DWORD));
    pszServerIp = inet_ntoa(inAddrIpServer);
    if(NULL != pszServerIp)
    {
        pszProtocol = fUdp ? "UDP" : "TCP";
        apszSubStrings[0] = pszServerIp;
        apszSubStrings[1] = pszProtocol;
        SmtpLogEvent(SMTP_DNS_SERVER_DOWN, 2, apszSubStrings, dwErr);
    }

    ErrorTrace((LPARAM) this, "Received error %d connecting to DNS server %d.%d.%d.%d over %s",
            dwErr, ((PBYTE)&dwIpServer)[0], ((PBYTE)&dwIpServer)[1],
                 ((PBYTE)&dwIpServer)[2], ((PBYTE)&dwIpServer)[3],
                 fUdp ? "UDP" : "TCP");

    g_TcpRegIpList.MarkDown(dwIpServer);
    TraceFunctLeaveEx((LPARAM)this);
}

BOOL CAsyncDns::ProcessReadIO(IN      DWORD InputBufferLen,
                              IN      DWORD dwCompletionStatus,
                              IN      OUT  OVERLAPPED * lpo)
{
    BOOL fRet = TRUE;
    DWORD    DataSize = 0;
    DNS_STATUS DnsStatus = 0;

    TraceFunctEnterEx((LPARAM) this, "BOOL CAsyncDns::ProcessReadIO");

    //add up the number of bytes we received thus far
    m_cbReceived += InputBufferLen;

    //
    // read atleast 2 bytes
    //
    
    if(!m_fUdp && m_FirstRead && ( m_cbReceived < 2 ) )
    {
        fRet = ReadFile(&m_pMsgRecvBuf[m_cbReceived],DNS_TCP_DEFAULT_PACKET_LENGTH-1 );
        return fRet;
    }

    //
    // get the size of the message
    //
    
    if(!m_fUdp && m_FirstRead && (m_cbReceived >= 2))
    {
        DataSize = ntohs(*(u_short *)m_pMsgRecvBuf);

        //
        // add 2 bytes for the field which specifies the length of data
        //
        
        m_BytesToRead = DataSize + 2; 
        m_FirstRead = FALSE;
    }

    //
    // pend another read if we have n't read enough
    //
    
    if(!m_fUdp && (m_cbReceived < m_BytesToRead))
    {
        DWORD cbMoreToRead = m_BytesToRead - m_cbReceived;
        fRet = ReadFile(&m_pMsgRecvBuf[m_cbReceived], cbMoreToRead);
    }
    else
    {

        if( !m_fUdp )
        {
            //
            // message length is 2 bytes less to take care of the msg length
            // field.
            //
            //m_pMsgRecv->MessageLength = (WORD) m_cbReceived - 2;
            m_pMsgRecv = (PDNS_MESSAGE_BUFFER)(m_pMsgRecvBuf+2);
            
        }
        else
        {
            //m_pMsgRecv->MessageLength = (WORD) m_cbReceived;
            m_pMsgRecv = (PDNS_MESSAGE_BUFFER)m_pMsgRecvBuf;
        }
            

        SWAP_COUNT_BYTES(&m_pMsgRecv->MessageHead);

        //
        // We queried over UDP and the reply from DNS was truncated because the response
        // was longer than the UDP packet size. We requery DNS using TCP unless SMTP is
        // configured to use UDP only. RetryAsyncDnsQuery sets the members of this CAsyncDns
        // object appropriately depending on whether if fails or succeeds. After calling
        // RetryAsyncDnsQuery, this object must be deleted.
        //

        if(m_fUdp && !(m_dwFlags & DNS_FLAGS_UDP_ONLY) && m_pMsgRecv->MessageHead.Truncation)
        {
            _ASSERT(!(m_dwFlags & DNS_FLAGS_TCP_ONLY) && "Shouldn't have truncated reply over TCP");
            DebugTrace((LPARAM) this, "Truncated reply - reissuing query using TCP");
            RetryAsyncDnsQuery(FALSE); // FALSE == Do not use UDP
            goto Exit;
        }

        DnsStatus = DnsParseMessage( m_pMsgRecv,
                                     (WORD)( m_fUdp ? ( m_cbReceived ) : ( m_cbReceived - 2 )),
                                     &m_ppRecord);

        //
        // End of resolve: HandleCompleted data examines the DnsStatus and results, and sets up
        // member variables of CAsyncSmtpDns to either NDR messages, connect to the remote host
        // or ack this queue for retry when the object is deleted.
        //

        HandleCompletedData(DnsStatus);
    }

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

BOOL CAsyncDns::ProcessClient (IN DWORD InputBufferLen,
                               IN DWORD            dwCompletionStatus,
                               IN OUT  OVERLAPPED * lpo)
{
    BOOL    RetStatus = FALSE;
    DWORD   dwIp = 0;
    BOOL    fRetryQuery = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::ProcessClient()");

    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if( (lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT))
    {
        fRetryQuery = TRUE;

        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //
        IncPendingIoCount();
        DebugTrace( (LPARAM)this, "Async DNS client timed out");
        DisconnectClient();
    }
    else if((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR))
    {
        fRetryQuery = TRUE;
        DebugTrace((LPARAM) this, "CAsyncDns::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d  - Closing connection", InputBufferLen, dwCompletionStatus);
        DisconnectClient();
    }
    else if (lpo == (OVERLAPPED *) &m_ReadOverlapped)
    {
        //A client based async IO completed
        RetStatus = ProcessReadIO(InputBufferLen, dwCompletionStatus, lpo);
    }
    else if(lpo == (OVERLAPPED *) &m_WriteOverlapped)
    {
        RetStatus = ReadFile(m_pMsgRecvBuf, DNS_TCP_DEFAULT_PACKET_LENGTH);
        if(!RetStatus)
        {
            ErrorTrace((LPARAM) this, "ReadFile failed");
            fRetryQuery = TRUE;
        }
    }


    if(fRetryQuery)
    {
        MarkDown(m_dwIpServer, dwCompletionStatus, m_fUdp);

        if(g_TcpRegIpList.GetIp(&dwIp) != ERROR_SUCCESS)
        {
            m_dwDiagnostic = AQUEUE_E_NO_DNS_SERVERS;
            SmtpLogEventSimple(SMTP_NO_DNS_SERVERS, DNS_ERROR_NO_DNS_SERVERS);
            ErrorTrace((LPARAM) this, "No DNS servers");

        } else {

            RetryAsyncDnsQuery(m_fUdp); // This sets m_dwDiagnostic
        }
    }

    DebugTrace((LPARAM)this,"ASYNC DNS - Pending IOs: %d", m_cPendingIoCount);

    // Do NOT Touch the member variables past this POINT!
    // This object may be deleted!

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //

    DecThreadCount();

    if (DecPendingIoCount() == 0)
    {
        DisconnectClient();

        DebugTrace((LPARAM)this,"ASYNC DNS - Pending IOs: %d", m_cPendingIoCount);
        DebugTrace((LPARAM)this,"ASYNC DNS - Thread count: %d", m_cThreadCount);
        delete this;
    }

    return TRUE;
}

int MxRand(char * host)
{
   int hfunc = 0;
   unsigned int seed = 0;;

   seed = rand() & 0xffff;

   hfunc = seed;
   while (*host != '\0')
    {
       int c = *host++;

       if (isascii((UCHAR)c) && isupper((UCHAR)c))
             c = tolower(c);

       hfunc = ((hfunc << 1) ^ c) % 2003;
    }

    hfunc &= 0xff;

    return hfunc;
}


BOOL CAsyncDns::CheckList(void)
{
    MXIPLIST_ENTRY * pEntry = NULL;
    struct hostent *hp = NULL;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::CheckList");
    
    if(m_Index == 0)
    {
        DebugTrace((LPARAM) this, "m_Index == 0 in CheckList");

        m_fUsingMx = FALSE;
        m_cbReceived = 0;
        m_BytesToRead = 0;

        m_FirstRead = TRUE;

        DeleteDnsRec(m_AuxList);

        m_AuxList = new SMTPDNS_RECS;
        if(m_AuxList == NULL)
        {
            ErrorTrace((LPARAM) this, "m_AuxList = new SMTPDNS_RECS failed");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        ZeroMemory(m_AuxList, sizeof(SMTPDNS_RECS));

        m_AuxList->NumRecords = 1;

        m_AuxList->DnsArray[0] = new MX_NAMES;
        if(m_AuxList->DnsArray[0] == NULL)
        {
            ErrorTrace((LPARAM) this, "m_AuxList->DnsArray[0] = new MX_NAMES failed");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        
        m_AuxList->DnsArray[0]->NumEntries = 0;
        InitializeListHead(&m_AuxList->DnsArray[0]->IpListHead);
        lstrcpyn(m_AuxList->DnsArray[0]->DnsName, m_HostName, sizeof(m_AuxList->DnsArray[m_Index]->DnsName));

        hp = gethostbyname (m_HostName);
        if(hp != NULL)
        {
            for (DWORD Loop = 0; (hp->h_addr_list[Loop] != NULL); Loop++)
            {
                pEntry = new MXIPLIST_ENTRY;
                if(pEntry != NULL)
                {
                    m_AuxList->DnsArray[0]->NumEntries++;
                    CopyMemory(&pEntry->IpAddress, hp->h_addr_list[Loop], 4);
                    InsertTailList(&m_AuxList->DnsArray[0]->IpListHead, &pEntry->ListEntry);
                }
                else
                {
                    fRet = FALSE;
                    ErrorTrace((LPARAM) this, "pEntry = new MXIPLIST_ENTRY failed in CheckList");
                    break;
                }
            }
        }
        else
        {
            fRet = FALSE;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL CAsyncDns::SortMxList(void)
{
    BOOL fRet = TRUE;

   /* sort the records */
   for (DWORD i = 0; i < m_Index; i++)
    {
        for (DWORD j = i + 1; j < m_Index; j++)
          {
              if (m_Prefer[i] > m_Prefer[j] ||
                            (m_Prefer[i] == m_Prefer[j] && m_Weight[i] > m_Weight[j]))
              {
                       DWORD temp;
                       MX_NAMES  *temp1;

                        temp = m_Prefer[i];
                        m_Prefer[i] = m_Prefer[j];
                        m_Prefer[j] = temp;
                        temp1 = m_AuxList->DnsArray[i];
                        m_AuxList->DnsArray[i] = m_AuxList->DnsArray[j];
                        m_AuxList->DnsArray[j] = temp1;
                        temp = m_Weight[i];
                        m_Weight[i] = m_Weight[j];
                        m_Weight[j] = temp;
                }
          }

        if (m_SeenLocal && m_Prefer[i] >= m_LocalPref)
        {
            /* truncate higher preference part of list */
            m_Index = i;
        }
   }

    m_AuxList->NumRecords = m_Index;

    if(!CheckList())
    {
        DeleteDnsRec(m_AuxList);
        m_AuxList = NULL;
        fRet = FALSE;
    }

    return fRet;
}

void CAsyncDns::ProcessMxRecord(PDNS_RECORD pnewRR)
{
    DWORD Len = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::ProcessMxRecord");

    if(m_Index >= SMTP_MAX_DNS_ENTRIES)
    {
        DebugTrace((LPARAM) this, "SMTP_MAX_DNS_ENTRIES reached for %s", m_HostName);    
        TraceFunctLeaveEx((LPARAM)this);
        return;
    }

    if((pnewRR->wType == DNS_TYPE_MX) && pnewRR->Data.MX.nameExchange)
    {
        Len = lstrlen(pnewRR->Data.MX.nameExchange);
        if(pnewRR->Data.MX.nameExchange[Len - 1] == '.')
        {
            pnewRR->Data.MX.nameExchange[Len - 1] = '\0';
        }

        DebugTrace((LPARAM) this, "Received MX rec %s with priority %d for %s", pnewRR->Data.MX.nameExchange, pnewRR->Data.MX.wPreference, m_HostName);

        if(lstrcmpi(pnewRR->Data.MX.nameExchange, m_FQDNToDrop))
        {
            m_AuxList->DnsArray[m_Index] = new MX_NAMES;

            if(m_AuxList->DnsArray[m_Index])
            {
                m_AuxList->DnsArray[m_Index]->NumEntries = 0;;
                InitializeListHead(&m_AuxList->DnsArray[m_Index]->IpListHead);
                lstrcpyn(m_AuxList->DnsArray[m_Index]->DnsName,pnewRR->Data.MX.nameExchange, sizeof(m_AuxList->DnsArray[m_Index]->DnsName));
                m_Weight[m_Index] = MxRand (m_AuxList->DnsArray[m_Index]->DnsName);
                m_Prefer[m_Index] = pnewRR->Data.MX.wPreference;
                m_Index++;
            }
            else
            {
                DebugTrace((LPARAM) this, "Out of memory allocating MX_NAMES for %s", m_HostName);
            }
        }
        else
        {
            if (!m_SeenLocal || pnewRR->Data.MX.wPreference < m_LocalPref)
                    m_LocalPref = pnewRR->Data.MX.wPreference;

                m_SeenLocal = TRUE;
        }
    }
    else if(pnewRR->wType == DNS_TYPE_A)
    {
        MXIPLIST_ENTRY * pEntry = NULL;

        for(DWORD i = 0; i < m_Index; i++)
        {
            if(lstrcmpi(pnewRR->nameOwner, m_AuxList->DnsArray[i]->DnsName) == 0)
            {
                pEntry = new MXIPLIST_ENTRY;

                if(pEntry != NULL)
                {
                    m_AuxList->DnsArray[i]->NumEntries++;;
                    pEntry->IpAddress = pnewRR->Data.A.ipAddress;
                    InsertTailList(&m_AuxList->DnsArray[i]->IpListHead, &pEntry->ListEntry);
                }

                break;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
}

void CAsyncDns::ProcessARecord(PDNS_RECORD pnewRR)
{
    MXIPLIST_ENTRY * pEntry = NULL;

    if(pnewRR->wType == DNS_TYPE_A)
    {
        pEntry = new MXIPLIST_ENTRY;

        if(pEntry != NULL)
        {
            pEntry->IpAddress = pnewRR->Data.A.ipAddress;
            InsertTailList(&m_AuxList->DnsArray[0]->IpListHead, &pEntry->ListEntry);
        }
    }
}

DNS_STATUS CAsyncDns::DnsParseMessage(
                                IN      PDNS_MESSAGE_BUFFER    pMsg,
                                IN      WORD            wMessageLength, 
                                OUT     PDNS_RECORD *   ppRecord)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::DnsParseMessage");
    PDNS_RECORD pTmp = NULL;

    m_SeenLocal = FALSE;
    m_LocalPref = 256;

    DNS_STATUS status = DnsExtractRecordsFromMessage_UTF8( pMsg, wMessageLength, ppRecord );
    
    //
    //  Due to Raid #122555 m_fUsingMx is always TRUE in this function
    //    - hence we will always go a GetHostByName() if there is no MX
    //      record.  It would be better Perf if we did a A record lookup.
    //
    DebugTrace((LPARAM) this, "Parsed DNS record for %s. status = 0x%08x", m_HostName, status);

    switch(status)
    {
    case ERROR_SUCCESS:
        //
        //  Got the DNS record we want.
        //
        DebugTrace((LPARAM) this, "Success: DNS record parsed");
        pTmp = *ppRecord;
        while( pTmp )
        {
            if( m_fUsingMx )
            {
                ProcessMxRecord( pTmp );
            }
            else
            {
                ProcessARecord( pTmp );
            }
            pTmp = pTmp->pNext;
        }

        if(m_fUsingMx)
        {
            //
            //  SortMxList sorts the MX records by preference and calls
            //  gethostbyname() to resolve A records for Mail Exchangers
            //  if needed (when the A records are not returned in the
            //  supplementary info).
            //

            if(SortMxList())
            {
                status = ERROR_SUCCESS;
                DebugTrace((LPARAM) this, "SortMxList() succeeded.");
            }
            else
            {
                status = ERROR_RETRY; 
                ErrorTrace((LPARAM) this, "SortMxList() failed. Message will stay queued.");
            }
        }
        break;
 
    case DNS_ERROR_RCODE_NAME_ERROR:
        //  Fall through to using gethostbyname()

    case DNS_INFO_NO_RECORDS:
        //  Non authoritative host not found.
        //  Fall through to using gethostbyname()

    default:
        DebugTrace((LPARAM) this, "Error in query: status = 0x%08x.", status);

        //
        //  Use gethostbyname to resolve the hostname:
        //  One issue with our approach is that sometimes we will NDR the message
        //  on non-permanent errors, "like WINS server down", when gethostbyname
        //  fails. However, there's no way around it --- gethostbyname doesn't
        //  report errors in a reliable manner, so it's not possible to distinguish
        //  between permanent and temporary errors.
        //

        if (!CheckList ()) {

            if(status == DNS_ERROR_RCODE_NAME_ERROR) {
                ErrorTrace((LPARAM) this, "Authoritative error");
                status = ERROR_NOT_FOUND;
            } else {
                ErrorTrace((LPARAM) this, "Retryable error");
                status = ERROR_RETRY;
            }

        } else {
            DebugTrace ((LPARAM) this, "Successfully resolved using gethostbyname");
            status = ERROR_SUCCESS;
        }
        
        break;
    }

    DnsRecordListFree( *ppRecord, TRUE );
    return( status );
    
}



DNS_STATUS
CAsyncDns::DnsSendRecord()
/*++

Routine Description:

    Send message, receive response.

Arguments:

    aipDnsServers -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = 0;

    m_pMsgRecvBuf = (BYTE*) new BYTE[DNS_TCP_DEFAULT_PACKET_LENGTH];

    if(m_pMsgRecvBuf == NULL)
    {
        return( DNS_ERROR_NO_MEMORY );        
    }


    status = Dns_OpenTcpConnectionAndSend();
    return( status );
}

SOCKET
CAsyncDns::Dns_CreateSocket(
    IN  INT         SockType
    )
/*++

Routine Description:

    Create socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    SOCKET      s;

    //
    //  create socket
    //

    s = socket( AF_INET, SockType, 0 );
    if ( s == INVALID_SOCKET )
    {
        return INVALID_SOCKET;
    }

    return s;
}

//-----------------------------------------------------------------------------
//  Description:
//      Constructor and Destructor for class to maintain a list of IP addresses
//      (for DNS servers) and their state (UP or DOWN). The IP addresses are
//      held in an IP_ARRAY, and the user must set m_DeleteFunc to deallocate
//      the memory.
//-----------------------------------------------------------------------------
CTcpRegIpList::CTcpRegIpList()
{
    m_IpListPtr = NULL;

    //
    // Shortcut to quickly figure out how many servers are down. This keeps track
    // of how many servers are marked up currently. Used in ResetServersIfNeeded
    // primarily to avoid checking the state of all servers in the usual case when
    // all servers are up.
    //

    m_cUpServers = 0;
    m_prgdwFailureTick = NULL;
    m_prgfServerUp = NULL;
    m_dwSig = TCP_REG_LIST_SIGNATURE;
}

CTcpRegIpList::~CTcpRegIpList()
{
    _ASSERT(m_DeleteFunc);

    if(m_DeleteFunc && m_IpListPtr)
        m_DeleteFunc(m_IpListPtr);

    if(m_prgdwFailureTick)
        delete [] m_prgdwFailureTick;

    if(m_prgfServerUp)
        delete [] m_prgfServerUp;

    m_IpListPtr = NULL;
    m_prgdwFailureTick = NULL;
    m_prgfServerUp = NULL;
}

//-----------------------------------------------------------------------------
//  Description:
//      Initializes or updates the IP address list. If this fails due to out
//      of memory, there's precious little we can do. So we don't return anything
//      and just delete the server IP list.
//  Arguments:
//      IpPtr - Ptr to IP_ARRAY of servers, this can be NULL in which case
//          we assume that there are no servers. On shutdown, the SMTP code
//          calls this with NULL.
//-----------------------------------------------------------------------------
void CTcpRegIpList::Update(PIP_ARRAY IpPtr)
{
    BOOL fFatalError = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CTcpRegIpList::Update");

    m_sl.ExclusiveLock();
    
    _ASSERT(m_DeleteFunc);

    if(m_IpListPtr && m_DeleteFunc)
        m_DeleteFunc(m_IpListPtr);

    if(m_prgdwFailureTick) {
        delete [] m_prgdwFailureTick;
        m_prgdwFailureTick = NULL;
    }

    if(m_prgfServerUp) {
        delete [] m_prgfServerUp;
        m_prgfServerUp = NULL;
    }

    // Note: this can be NULL
    m_IpListPtr = IpPtr;
    
    if(IpPtr == NULL) {
        m_cUpServers = 0;
        goto Exit;
    }

    m_cUpServers = IpPtr->cAddrCount;
    m_prgdwFailureTick = new DWORD[m_cUpServers];
    m_prgfServerUp = new BOOL[m_cUpServers];

    if(!m_prgdwFailureTick || !m_prgfServerUp) {
        ErrorTrace((LPARAM) this, "Failed to read DNS server list - out of memory");
        fFatalError = TRUE;
        goto Exit;
    }

    for(int i = 0; i < m_cUpServers; i++) {
        m_prgdwFailureTick[i] = 0;
        m_prgfServerUp[i] = TRUE;
    }

Exit:
    if(fFatalError) {
        if(m_prgfServerUp) {
            delete [] m_prgfServerUp;
            m_prgfServerUp = NULL;
        }

        if(m_prgdwFailureTick) {
            delete [] m_prgdwFailureTick;
            m_prgdwFailureTick = NULL;
        }

        if(m_IpListPtr && m_DeleteFunc) {
            m_DeleteFunc(m_IpListPtr);
            m_IpListPtr = NULL;
        }

        m_cUpServers = 0;
    }

    m_sl.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      Return the IP address of a server known to be UP. This function also
//      checks to see if any servers currently marked DOWN should be reset to
//      the UP state again (based on a retry interval).
//  Arguments:
//      DWORD *pdwIpServer - Sets the DWORD pointed to, to the IP address of
//          a server in the UP state.
//  Returns:
//      ERROR_SUCCESS - If a DNS server in the UP state was found
//      ERROR_RETRY - If all DNS servers are currently down
//      DNS_ERROR_NO_DNS_SERVERS - If no DNS servers are configured
//-----------------------------------------------------------------------------
DWORD CTcpRegIpList::GetIp(DWORD *pdwIpServer)
{
    DWORD dwErr = ERROR_SUCCESS;
    int iServer = 0;

    _ASSERT(pdwIpServer != NULL);

    *pdwIpServer = INADDR_NONE;

    // Check if any servers were down and bring them up if needed
    ResetServersIfNeeded();

    m_sl.ShareLock();
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0) {
        dwErr = DNS_ERROR_NO_DNS_SERVERS;
        goto Exit;
    }

    if(m_cUpServers == 0) {
        dwErr = ERROR_RETRY;
        goto Exit;
    }

    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {
        if(m_prgfServerUp[iServer])
            break;
    }

    if(m_prgfServerUp[iServer])
        *pdwIpServer = m_IpListPtr->aipAddrs[iServer];
    else
        dwErr = ERROR_RETRY;

Exit:
    m_sl.ShareUnlock();
    return dwErr;
}

//-----------------------------------------------------------------------------
//  Description:
//      Marks a server in the list as down and sets the next retry time for
//      that server. The next retry time is calculated modulo MAX_TICK_COUNT.
//  Arguments:
//      dwIp -- IP address of server to mark as DOWN
//-----------------------------------------------------------------------------
void CTcpRegIpList::MarkDown(DWORD dwIp)
{
    int iServer = 0;

    m_sl.ExclusiveLock();

    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == 0)
        goto Exit;

    // Find the server to mark as down among all the UP servers
    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {
        if(m_IpListPtr->aipAddrs[iServer] == dwIp)
            break;
    }

    if(iServer < (int)m_IpListPtr->cAddrCount && m_prgfServerUp[iServer]) {

        m_prgfServerUp[iServer] = FALSE;
        _ASSERT(m_cUpServers > 0);
        m_cUpServers--;
        m_prgdwFailureTick[iServer] = GetTickCount();
    }
Exit:
    m_sl.ExclusiveUnlock();
    return;
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks if any servers are DOWN, and if the retry time has expired for
//      those servers. If so those servers will be brought up.
//-----------------------------------------------------------------------------
void CTcpRegIpList::ResetServersIfNeeded()
{
    int iServer = 0;
    DWORD dwElapsedTicks = 0;
    DWORD dwCurrentTick = 0;

    //
    // Quick check - if all servers are up (usual case) or there are no configured
    // servers, there's nothing for us to do.
    //

    m_sl.ShareLock();
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == m_IpListPtr->cAddrCount) {

        m_sl.ShareUnlock();
        return;
    }

    m_sl.ShareUnlock();

    // Some servers are down... figure out which need to be brought up
    m_sl.ExclusiveLock();

    // Re-check that no one modified the list while we didn't have the sharelock
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == m_IpListPtr->cAddrCount) {
        m_sl.ExclusiveUnlock();
        return;
    }

    dwCurrentTick = GetTickCount();

    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {

        if(m_prgfServerUp[iServer])
            continue;

        //
        // Note: This also takes care of the special case where dwCurrentTick occurs
        // after the wraparound and m_prgdwFailureTick occurs before the wraparound.
        // This is because, in that case, the elapsed time is:
        //
        //   time since wraparound + time before wraparound that failure occurred - 1
        //   (-1 is because it's 0 time to transition from MAX_TICK_VALUE to 0)
        //
        //      = dwCurrentTick + (MAX_TICK_VALUE - m_prgdwFailureTick[iServer]) - 1
        //
        //   Since MAX_TICK_VALUE == -1
        //
        //      = dwCurrentTick + (-1 - m_prgdwFailureTick[iServer]) - 1
        //      = dwCurrentTick - m_prgdwFailureTick[iServer]
        //

        dwElapsedTicks = dwCurrentTick - m_prgdwFailureTick[iServer];

#define TICKS_TILL_RETRY        10 * 60 * 1000 // 10 minutes

        if(dwElapsedTicks > TICKS_TILL_RETRY) {
            m_prgfServerUp[iServer] = TRUE;
            m_prgdwFailureTick[iServer] = 0;
            m_cUpServers++;
            _ASSERT(m_cUpServers <= (int)m_IpListPtr->cAddrCount);
        }
    }

    m_sl.ExclusiveUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\aqstore.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>

#include <nsepname.hxx>

extern DWORD g_UseMapiDriver ;

HINSTANCE g_hStoredll = NULL;
HINSTANCE g_hAqdll = NULL;
BOOL StoreDriverInitialized = FALSE;

AQ_INITIALIZE_EX_FUNCTION g_pfnInitializeAQ = NULL;
AQ_DEINITIALIZE_EX_FUNCTION g_pfnDeinitializeAQ = NULL;


static void STDAPICALLTYPE DeInitialize(DWORD InstanceId)
{
	return;
}


void UnLoadQueueDriver(void)
{
        if(g_hAqdll != NULL)
        {
                FreeLibrary(g_hAqdll);
                g_hAqdll = NULL;
        }
}


BOOL LoadAdvancedQueueing(char *szAQDll)
{
    TraceFunctEnterEx((LPARAM) NULL, "LoadAdvancedQueueing");

    DWORD dwErr = ERROR_SUCCESS;

    g_hAqdll = LoadLibraryEx(szAQDll, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (g_hAqdll != NULL) {

        g_pfnInitializeAQ =
            (AQ_INITIALIZE_EX_FUNCTION)
                GetProcAddress(g_hAqdll, AQ_INITIALIZE_FUNCTION_NAME_EX);

        if (g_pfnInitializeAQ != NULL) {

            g_pfnDeinitializeAQ =
                (AQ_DEINITIALIZE_EX_FUNCTION)
                    GetProcAddress(g_hAqdll, AQ_DEINITIALIZE_FUNCTION_NAME_EX);

        }

        if (g_pfnInitializeAQ == NULL || g_pfnDeinitializeAQ == NULL) {
            dwErr = GetLastError();

            DebugTrace((LPARAM) NULL, "Error getting address of %s - %d",
                g_pfnInitializeAQ ? AQ_DEINITIALIZE_FUNCTION_NAME_EX :
                    AQ_INITIALIZE_FUNCTION_NAME_EX, dwErr);
        }

    } else {

        dwErr = GetLastError();

        DebugTrace((LPARAM) NULL, "Error loading %s - %d", szAQDll, dwErr);

    }


    TraceFunctLeaveEx((LPARAM) NULL);
	return (dwErr == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\asyncmx.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include <asynccon.hxx>
#include <dnsreci.h>
#include "asyncmx.hxx"

#include "smtpout.hxx"

extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);

CPool  CAsyncMx::Pool(ASYNCMX_SIGNATURE);

CAsyncMx::CAsyncMx(PMXPARAMS Parameters)
:CAsyncConnection(Parameters->PortNum, Parameters->TimeOut, Parameters->HostName, Parameters->CallBack)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::CAsyncMx");

    m_Signature = ASYNCMX_SIGNATURE;
    NumMxRecords = Parameters->pDnsRec->NumRecords;
    m_DomainOptions = 0;
    m_NextMxRecord = Parameters->pDnsRec->StartRecord;
    m_CurrentMxRec = 0;
    m_fTriedOnFailHost = FALSE;
    m_fLoopback = FALSE;
    pSmtpConnection = Parameters->pISMTPConnection;
    pServiceInstance = Parameters->pInstance;
    m_pDnsRec = Parameters->pDnsRec;
    m_pNextIpAddress = NULL;
    m_pDNS_RESOLVER_RECORD = Parameters->pDNS_RESOLVER_RECORD;
    m_fInitCalled = FALSE;
    m_pszSSLVerificationName = NULL;

    pServiceInstance->InsertAsyncObject(this);

    DebugTrace((LPARAM) this, "Constructing MX object with %d records", NumMxRecords);
    DebugTrace((LPARAM) this, "Got DNS_RESOLVER_RECORD = 0x%08x", m_pDNS_RESOLVER_RECORD);

    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      Initializes heap allocated members of CAsyncMx, ~CAsyncMx cleans up.
//  Arguments:
//      pszSSLVerificationName - For outbound session, name against which
//          server SSL certificate is matched (if config option to match the
//          name is set in SMTP).
//  Returns:
//      FALSE on failure (caller should then delete CAsyncMx), else TRUE
//-----------------------------------------------------------------------------
BOOL CAsyncMx::Init (LPSTR pszSSLVerificationName)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CAsyncMx::Init");

    m_fInitCalled = TRUE;
    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen (pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName)
            goto Exit;

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }

    fRet = TRUE;
Exit:
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

CAsyncMx::~CAsyncMx()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::~CAsyncMx");
    
    _ASSERT (m_fInitCalled && "Init not called for CAsyncMx object");

    if(m_pDNS_RESOLVER_RECORD != NULL)
    {
        DebugTrace((LPARAM) this, "Deleting embedded DNS_RESOLVER_RECORD in async MX obj");
        delete m_pDNS_RESOLVER_RECORD;
        m_pDNS_RESOLVER_RECORD = NULL;
    }
    DBG_CODE(else DebugTrace((LPARAM)this, "No DNS_RESOLVER_RECORD object in async MX obj"));

    if(m_pDnsRec != NULL)
    {
        DeleteDnsRec (m_pDnsRec);
        m_pDnsRec = NULL;
    }

    if(m_pszSSLVerificationName != NULL)
    {
        delete [] m_pszSSLVerificationName;
        m_pszSSLVerificationName = NULL;
    }

    pServiceInstance->RemoveAsyncObject(this);

    m_Signature = ASYNCMX_SIGNATURE_FREE;
    TraceFunctLeaveEx((LPARAM) this);
}


BOOL CAsyncMx::CheckIpAddress(DWORD IpAddress, DWORD PortNum)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::CheckIpAddress");

    fRet = pServiceInstance->IsAddressMine (IpAddress, PortNum);

    m_fLoopback = fRet;

    return !fRet;
    TraceFunctLeaveEx((LPARAM) this);
}

BOOL CAsyncMx::IsMoreIpAddresses(void)
{
    BOOL fMore = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::IsMoreIpAddresses");

    if(m_pDnsRec && m_pNextIpAddress && m_pDnsRec->DnsArray[m_CurrentMxRec])
    {
        if(m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead)
        {
            fMore = TRUE;
        }
        else
        {
            m_pNextIpAddress = NULL;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fMore;
}

void CAsyncMx::IncNextIpToTry (void) 
{
    if(m_pNextIpAddress)
    {
        m_pNextIpAddress = m_pNextIpAddress->Flink;
    }
}

DWORD CAsyncMx::GetNextIpAddress(void)
{
    PMXIPLIST_ENTRY pContext = NULL;
    DWORD IpAddress = INADDR_NONE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::GetNextIpAddress");

	if(m_pDnsRec && m_pNextIpAddress && m_pDnsRec->DnsArray[m_CurrentMxRec])
	{
		//m_pNextIpAddress = m_pNextIpAddress->Flink;

        //if m_pNextIpAddress == &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead
        //this means we have tried every IP address in the list, and there is no more.
        //else we get the next IP address and try to connect to it.
        if(m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead)
        {
            pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );
            IpAddress = pContext->IpAddress;
        }
        else
        {
            m_pNextIpAddress = NULL;
        }
    }
    else
    {
            m_pNextIpAddress = NULL;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return IpAddress;
}

BOOL CAsyncMx::ConnectToNextMxHost(void)
{
    BOOL fReturn = FALSE;
    LIST_ENTRY * pEntry = NULL;
    PMXIPLIST_ENTRY pContext = NULL;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::ConnectToNextMxHost");

    SetLastError(NO_ERROR);

    DebugTrace((LPARAM)this, "m_NextMxRecord is %d", m_NextMxRecord);
    DebugTrace((LPARAM)this, "NumMxRecords is %d", NumMxRecords);

    //If there are more MX records to connect to, then try and connect
    //to the next one.
    
    if((m_NextMxRecord < NumMxRecords) &&  (m_pDnsRec->DnsArray[m_NextMxRecord] != NULL))
    {
        m_CurrentMxRec = m_NextMxRecord;

        SetNewHost(m_pDnsRec->DnsArray[m_NextMxRecord]->DnsName);

        DebugTrace((LPARAM)this, "m_NextMxRecord for %s is %d", GetHostName(), m_NextMxRecord);

        //if the first entry is non NULL, then see if this
        //entry has an Ip Address. If it has an ip address,
        //save the link to the next ip address incase this
        //one fails to connect. Also, bump the next MX record
        //to try counter.
        if(!IsListEmpty(&m_pDnsRec->DnsArray[m_NextMxRecord]->IpListHead))
        {
            m_pNextIpAddress = m_pDnsRec->DnsArray[m_NextMxRecord]->IpListHead.Flink;
            pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );

            m_NextMxRecord++;
            SetErrorCode(NO_ERROR);

#define BYTE_VAL(dw, ByteNo) ( ((dw) >> (8 * (ByteNo))) & 0xFF)

            DebugTrace((LPARAM) this, "ConnectToNextMxHost trying IP address %d.%d.%d.%d", 
                BYTE_VAL(pContext->IpAddress, 0),
                BYTE_VAL(pContext->IpAddress, 1),
                BYTE_VAL(pContext->IpAddress, 2),
                BYTE_VAL(pContext->IpAddress, 3));

            fReturn = ConnectToHost(pContext->IpAddress);
        }
        else
        {
            //the list is empty.
            DebugTrace((LPARAM) this, "No more MX hosts in ConnectToNextMxHost");

            m_NextMxRecord++;
            m_pDnsRec->StartRecord++;   
            SetErrorCode(WSAHOST_NOT_FOUND);
        }
    }
    else
    {
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

BOOL CAsyncMx::MakeFirstAsyncConnect(void)
{
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::MakeFirstAsyncConnect");

    fReturn = ConnectToNextMxHost();

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}


BOOL CAsyncMx::OnConnect(BOOL fConnected)
{
    LIST_ENTRY  * pEntryNext = NULL;
    PMXIPLIST_ENTRY pContext = NULL;
    BOOL fReturn = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::OnConnect");

    //remove this IP address from the list, so we do not connect
    //to it again if the connection drops when we perform all our
    //outbound processing
    if(m_pNextIpAddress &&
        (m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead))
    {
        //save the next entry in the list
        pEntryNext = m_pNextIpAddress->Flink;   

        //get the current entry, remove it, then delete it
        pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );
        RemoveEntryList( &(pContext->ListEntry));
        delete pContext;

        //set the current entry equal to the saved entry
        m_pNextIpAddress = pEntryNext;
    }
    else
    {
        fReturn = FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

void CAsyncMx::AckMessage(void)
{
    MessageAck MsgAck;

    if(m_pDnsRec != NULL)
    {
        if(m_pDnsRec->pMailMsgObj)
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;
            MsgAck.pvMsgContext = (DWORD *) m_pDnsRec->pAdvQContext;
            MsgAck.pIMailMsgProperties = (IMailMsgProperties *) m_pDnsRec->pMailMsgObj;
            pSmtpConnection->AckMessage(&MsgAck);
            MsgAck.pIMailMsgProperties->Release();
            m_pDnsRec->pMailMsgObj = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\base64.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name:
      base64.cxx

   Abstract:
      This module supports functions for file caching for servers

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Oct-1995

   Environment:

       Win32 Apps

   Project:

       Internet Services Common  DLL

   Functions Exported:



   Revision History:
     Obtained from old inetsvcs.dll

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <iis64.h>

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
	int nbytesin = 0;
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

	/*NimishK ** : If it aint divisible by 4 it aint base 64 */
	if(!fBase64)
	{
		nbytesin = lstrlen(bufcoded);
		if(nbytesin % 4)
			return FALSE;
	}

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}
/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\buildq.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        buildq.cxx

   Abstract:
        Builds the initial queue during service startup

   Author:

           KeithLau     10/9/96

   Project:

          SMTP Server DLL

   Functions Exported:

   Revision History:

            dhowell     26/5/97  Added MCIS to K2 upgrade... rewrite envelope if required logic.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "buildq.hxx"
#include "headers.hxx"
//#include "pkuprtyq.hxx"
#include "timeconv.h"

#define MAX_INITIAL_THREADS         8


/************************************************************
 *    Threadprocs
 ************************************************************/

//
// Threadproc which builds up the initial queue of messages
//
DWORD BuildInitialQueueProc(void *lpThis);

//
// Threadproc which delivers the queued messages
// 
VOID ProcessInitialQueueObjects(PVOID       pvContext, 
                                DWORD       cbWritten, 
                                DWORD       dwCompletionStatus, 
                                OVERLAPPED  *lpo);

/************************************************************
 *    Globals
 ************************************************************/

/************************************************************
 *    Implementation of SMTP_BUILDQ class
 ************************************************************/

/*++

    Name:

    SMTP_BUILDQ::SMTP_BUILDQ

    Constructs a new SMTP_BUILDQ object

--*/
SMTP_BUILDQ::SMTP_BUILDQ(SMTP_SERVER_INSTANCE * pInst)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::SMTP_BUILDQ");

    m_hAtq = INVALID_HANDLE_VALUE;
    m_pAtqContext = NULL;
    m_cPendingIoCount = 0;
    m_cActiveThreads = 0;
    m_Entries = 0;
    m_Signature = SMTP_BUILDQ_SIGNATURE_VALID;
    m_pInstance = pInst;

    InitializeListHead(&m_InitalQListHead);
    InitializeCriticalSection (&m_CritSec);

    TraceFunctLeaveEx((LPARAM)this);
}

SMTP_BUILDQ::~SMTP_BUILDQ(void)
{
    PATQ_CONTEXT pAtqContext = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::~SMTP_BUILDQ");

    _ASSERT(GetThreadCount() == 0);

    // Release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer((PVOID *)&m_pAtqContext, (PVOID)NULL);
    if (pAtqContext != NULL) 
    {
        pAtqContext->hAsyncIO = NULL;
        AtqFreeContext( pAtqContext, TRUE );
    }

    // Close the directory handle if for some reason it is
    // not already closed
    if (m_hAtq != INVALID_HANDLE_VALUE)
    {
        _VERIFY(CloseHandle(m_hAtq));
        m_hAtq = INVALID_HANDLE_VALUE;
    }

    // Invalidate the signature. since this connection is trashed.
    m_Signature = SMTP_BUILDQ_SIGNATURE_FREE;

    DeleteCriticalSection (&m_CritSec);

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_BUILDQ::InitializeObject(ATQ_COMPLETION pfnCompletion)
{
    //PATQ_CONT pContext;
    BOOL        fReturn = FALSE;
    HANDLE      hStop;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::InitializeObject");

    // Open the queue directory, this is just to keep AtqAddAsyncHandle happy
    m_hAtq = CreateFile(QuerySmtpInstance()->GetMailQueueDir(), 
                        FILE_LIST_DIRECTORY,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
                        NULL);
    if(m_hAtq == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM)this, 
                    "CreateFile on %s failed with error %d ",
                    QuerySmtpInstance()->GetMailQueueDir(), 
                    GetLastError());
        goto ExitFunc;
    }

    // Create an event to fire when we stop
    hStop = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(hStop == NULL)
    {
        ErrorTrace((LPARAM)this, 
                    "CreateEvent() for hStop failed with error %d ", 
                    GetLastError());
        goto ExitFunc;
    }

    QuerySmtpInstance()->SetBuildQStopHandle(hStop);

    // Add it to our Gibraltar interface
    if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this, pfnCompletion,
                            INFINITE, m_hAtq))
     {
        ErrorTrace((LPARAM)this, 
                    "AtqAddAsyncHandle failed with error %d ", 
                    GetLastError());
        goto ExitFunc;
     }

    // Hack to get around ATQ assert
    //pContext = (PATQ_CONT)m_pAtqContext;
    //pContext->lSyncTimeout = AtqProcessingIo;

    // Indicate success
    fReturn = TRUE;

ExitFunc:
    if (!fReturn)
    {
        if (m_hAtq != INVALID_HANDLE_VALUE)
        {
            _VERIFY(CloseHandle(m_hAtq));
            m_hAtq = INVALID_HANDLE_VALUE;
        }

        QuerySmtpInstance()->CloseBuildQStopHandle();
    }
    TraceFunctLeaveEx((LPARAM)this);
    return(fReturn);
}

void SMTP_BUILDQ::CloseAtqHandleAndFlushQueue (void)
{
    HANDLE          hAtq = INVALID_HANDLE_VALUE;
    PQUEUE_ENTRY    pQEntry;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::CloseAtqHandle");

    // We close the Atq (directory) handle.
    hAtq = (HANDLE)InterlockedExchangePointer((PVOID *)&m_hAtq, 
                                        (PVOID)INVALID_HANDLE_VALUE);
    if (hAtq != INVALID_HANDLE_VALUE)
        _VERIFY(CloseHandle(hAtq));

    QuerySmtpInstance()->SetStopHint(2);
    WaitForSingleObject(QuerySmtpInstance()->QueryBuildQStopHandle(), INFINITE);
    QuerySmtpInstance()->CloseBuildQStopHandle();
        
    // Flush the queue, since we are all shuttin gdown
    LockQ();
    while(!IsListEmpty(&m_InitalQListHead))
    {
        QuerySmtpInstance()->StopHint();
        pQEntry = PopQEntry();
        delete pQEntry;
    }
    UnLockQ();

    QuerySmtpInstance()->SetStopHint(2);

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_BUILDQ::InsertIntoInitialQueue(IN OUT PERSIST_QUEUE_ENTRY * pEntry)
{
    return(TRUE);
}

PQUEUE_ENTRY SMTP_BUILDQ::PopQEntry(void)
{
    return NULL;
}


BOOL SMTP_BUILDQ::PostCompletionStatus(DWORD BytesTransferred)
{
    BOOL fRet;

    TraceFunctEnterEx((LPARAM)this, "PostCompletionStatus");

    _ASSERT(QueryAtqContext() != NULL);

    // Ask for more threads only if we are less than the preset
    // maximum number of threads
    IncPendingIoCount();

    if(!(fRet = AtqPostCompletionStatus(QueryAtqContext(), 
                                        BytesTransferred)))
    {
        DecPendingIoCount();
        ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
    }

    TraceFunctLeaveEx((LPARAM) this);
    return(fRet);
}

/*++

    Name :
        DWORD BuildInitialQueueProc

    Description:
        Wrapper for the SMTP_BUILDQ::BuildInitialQueue workhorse
        funciton.

    Arguments:
        lpThis - points to the SMTP_BUILDQ object

    Returns:
        NO_ERROR

--*/
DWORD BuildInitialQueueProc(void *lpThis)
{
    SMTP_BUILDQ *pBuildQ = (SMTP_BUILDQ *)lpThis;

    _ASSERT(pBuildQ);
    _ASSERT(pBuildQ->IsValid());

    // Call the main workhorse function
    pBuildQ->BuildInitialQueue();

    return(NO_ERROR);
}

/*++

    Name :
        SMTP_BUILDQ::BuildInitialQueue

    Description:
       This function reads all the mail files
       that were not sent, for what ever reason,
       opens the NTFS stream that holds the envelope,
       and builds up the internal send queue. The
       envelope for each message resides in an NTFS
       stream in that message file.  The envelope has
       a header that looks like the following :

        struct ENVELOPE_HEADER
        {
            DWORD                       Version;
            DWORD                       Dummy1;         // To be used later
            DWORD                       Dummy2;         // To be used later
            DWORD                       LocalOffset;    // Local rcpt. list offset
            DWORD                       RemoteOffset;   // Remote rcpt. list offset
            DWORD                       LocalSize;      // Size of local rcpt list
            DWORD                       RemoteSize;     // Size of remote rcpt list 
        };

        Right after the envelope header is the address 
        that was in the "Mail From" line. This address 
        is stored like "Srohanp@microsoft.com\n".  The "S"
        stands for SENDER. In the code below, the first
        byte is always removed when reading the address.
        The '\n' is also replaced with a '\0';

        In this version the Local recipient list, if any,
        comes right after the senders' address.  You can
        also find it by seeking LocalOffset bytes from the
        beginning of the file.  Once LocalOffset is reached,
        the code reads LocalSize bytes of data.  This is the
        total size in bytes of the local recipient list.
        Each recipient address is stored on a line by itself,
        with the first letter "R" as in the example below:

        Rrohanp@microsoft.com\n
        Rtoddch@microsoft.com\n
        etc.

        The remote addresses have the same format. The first byte,
        'R' stands for recipient and is always removed when building
        the address.  The '\n' is also removed.

    Arguments:
        A pointer to a PERSIST_QUEUE

    Returns:

--*/

DWORD SMTP_BUILDQ::BuildInitialQueue(void)
{

    SMTP_SERVER_INSTANCE * pInst;

    pInst = QuerySmtpInstance();

    SetEvent(QuerySmtpInstance()->GetBuildQStopHandle());

    // Log an event saying that the server is ready to accept connections,
    // only if we are not shutting down.
    if (!pInst->IsShuttingDown())
    {
        char IntBuffer [20];

        pInst->SetAcceptConnBool();

        _itoa(pInst->QueryInstanceId(), IntBuffer, 10);
        SmtpLogEventEx(SMTP_EVENT_ACCEPTING_CONNECTIONS, IntBuffer, 0);
    }

    return(NO_ERROR);
}


BOOL SMTP_BUILDQ::ProcessMailQIO(DWORD InputBufferLen,
                                    DWORD dwCompletionStatus,
                                    OVERLAPPED * lpo)
{
    return(TRUE);
}


/*++

    Name :
        SMTP_BUILDQ::ProcessQueueObject

    Description:

       Main function for this class. Processes the objects in the
       initial queue

    Arguments:

       cbWritten          count of bytes written
       dwCompletionStatus Error Code for last IO operation
       lpo                Overlapped stucture

    Returns:

       FALSE when processing is incomplete.
       TRUE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_BUILDQ::ProcessQueueObject(IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fRet;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::ProcessQueueObject" );

    //
    // Increment the number of threads processing this client
    //
    IncThreadCount();

    if(!QuerySmtpInstance()->IsShuttingDown())
    {
        // We want to make sure we are called from the Gibraltar
        // context since that should be the only case ...
        if (lpo == &(QueryAtqContext()->Overlapped))
        {
            DebugTrace((LPARAM)this,"About to process queue object");
            fRet = ProcessMailQIO (InputBufferLen, dwCompletionStatus, lpo);
        }
        else
        {
            // We are not called with the correct context, we can't
            // do much about it; so we skip in in retail and break
            // in debug.
            FatalTrace((LPARAM)this,"Bad overlapped context");
            _ASSERT(0);
        }
    }

    //
    // Decrement the number of threads processing this client
    //
    DecThreadCount();

    // If our pending IO count ever hits zero, we know we have handled 
    // all initial mail messages. If this is the case, we will return 
    // FALSE, and the calling function will then fire the Stop event.
    if (DecPendingIoCount() == 0)
    {
        DebugTrace((LPARAM)this, 
                    "SMTP_BUILDQ::ProcessQueueObject() shutting down - Pending IOs: %d", 
                    m_cPendingIoCount);
        DebugTrace((LPARAM)this, 
                    "SMTP_BUILDQ::ProcessQueueObject() shutting down - ActiveThreads: %d", 
                    m_cActiveThreads);
        _ASSERT(m_cActiveThreads == 0);
        fRet = TRUE;
    }
    else
    {
        DebugTrace((LPARAM)this,
                    "SMTP_BUILDQ::ProcessClient() - Pending IOs: %d",
                    m_cPendingIoCount);
        DebugTrace((LPARAM)this,
                    "SMTP_BUILDQ::ProcessClient() - ActiveThreads: %d",
                    m_cActiveThreads);
        fRet = FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fRet);
}

/*++
    Name :
        ProcessInitialQueueObjects

    Description:

        Handles a completed I/O for delivering queued mail objects

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID ProcessInitialQueueObjects(PVOID       pvContext, 
                                DWORD       cbWritten, 
                                DWORD       dwCompletionStatus, 
                                OVERLAPPED  *lpo)
{
    BOOL        fCompleted;
    SMTP_BUILDQ *pBuildQ = (SMTP_BUILDQ *)pvContext;

    TraceFunctEnterEx((LPARAM)pBuildQ, "ProcessInitialQueueObjects");

    _ASSERT(pBuildQ);
    _ASSERT(pBuildQ->IsValid());

    // Call the in-context function to process the object
    fCompleted = 
        pBuildQ->ProcessQueueObject(cbWritten, dwCompletionStatus, lpo);
    if (fCompleted)
    {
        // If fCompleted is TRUE, we know that we either finished
        // delivering the entire initial queue, or that we are already
        // signalled to shut down, and the last pending IO has just
        // been serviced. We fire the Stop event to allow CloseAtqHandle 
        // to proceed through the wait.
        _VERIFY(SetEvent(pBuildQ->QuerySmtpInstance()->GetBuildQStopHandle()));
    }

    TraceFunctLeaveEx((LPARAM)pBuildQ);
}

BOOL     SMTP_BUILDQ::MakeAllAddrsLocal (HANDLE hFile,  char * szBuffer, ENVELOPE_HEADER * pMyHeader)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\cbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cbuffer.h
//
//  Contents:   CHAR buffer definitions
//
//  History:    02-16-93    SethuR -- Implemented
//              07-28-94    AlokS  -- Added more methods
//              12-09-97    MilanS -- Ported to Exchange
//              01-18-99    MikeSwa -- Fixed Cat()
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __CBUFFER_H__
#define __CBUFFER_H__

//+---------------------------------------------------------------------
//
// Class:   CCHARBuffer
//
// Purpose: A CHAR buffer
//
// History:
//
// Notes:   Very often we encounter the case in string manipulation wherein
//          the length of the string is less than some value most of the time
//          (99%). However, in order to reliably with the very rare case we
//          are forced to either allocate the string on the heap or alternatively
//          go through some bizarre code that avoids the heap allocation in the
//          common case. This class is an abstraction of a WCHAR buffer and its
//          implementation is an attempt at hiding the detail from all clients.
//
//          As it is designed it is an ideal candidate for a temporary buffer
//          for string manipulation.
//
//----------------------------------------------------------------------

#define MAX_CHAR_BUFFER_SIZE 260 // long enough to cover all path names

class CCHARBuffer
{
public:

    inline CCHARBuffer(ULONG cwBuffer = 0);
    inline ~CCHARBuffer();

    inline DWORD    Size();
    inline PCHAR   ReAlloc(DWORD cwBuffer = MAX_CHAR_BUFFER_SIZE);
    inline void     Set(PWCHAR pwszFrom);
    inline void     Set(PCHAR  pszFrom);
    inline BOOL     Cat(PCHAR pszPlus);

    inline      operator PCHAR ();
    inline      operator PCHAR () const;

    inline void operator  =(PWCHAR pwszFrom)
    {
        Set(pwszFrom);
    };

    inline void operator  =(PCHAR  pszFrom)
    {
        Set(pszFrom);
    };

private:

    DWORD   _cBuffer;
    PCHAR   pchBuffer;    // buffer ptr;
    CHAR   _achBuffer[MAX_CHAR_BUFFER_SIZE];
};

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::CCHARBuffer, inline public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cBuffer]   -- desired buffer length.
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::CCHARBuffer(ULONG cBuffer) :
                     pchBuffer(NULL),
                     _cBuffer(cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::~CCHARBuffer, inline public
//
//  Synopsis:   Destructor
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::~CCHARBuffer()
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Size, inline public
//
//  Synopsis:   Retrieve the size of the buffer
//
//  Returns:    the size of the buffer as a DWORD
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline DWORD CCHARBuffer::Size()
{
    return _cBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::ReAlloc, inline public
//
//  Synopsis:   Reallocates the buffer to accomdate the newly specified size
//
//  Arguments:  [cBuffer] -- the desired buffer size
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline PCHAR CCHARBuffer::ReAlloc(DWORD cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }

    if ((_cBuffer = cBuffer) > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
    else if (_cBuffer == 0)
    {
        pchBuffer = NULL;
    }

    return pchBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::operator PCHAR (), inline public
//
//  Synopsis:   casting operator to accomdate syntactic sugaring
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::operator PCHAR ()
{
    return (PCHAR)pchBuffer;
}

inline CCHARBuffer::operator PCHAR () const
{
    return (PCHAR)pchBuffer;
}
//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pwszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PWCHAR pwszFrom)
{
    if (pwszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pwszFrom)
    {
        DWORD len = wcslen(pwszFrom)+1;
        if (len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        wcstombs(pchBuffer, pwszFrom, len);
    }
    else
    {
        *pchBuffer='\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PCHAR pszFrom)
{
    if (pszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pszFrom)
    {
        DWORD len = strlen(pszFrom)+1;
        if ( len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        memcpy(pchBuffer, pszFrom, len);
    }
    else
    {
        *pchBuffer=L'\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Cat, inline public
//
//  Synopsis:   Concatnates the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszPlus] -- Pointer to the string
//
//  Returns:    TRUE on success
//              FALSE if memory allocation failed
//
//  History:    07-28-94  AlokS Created
//              01-18-99  Mikeswa Fixed AV in checkin allocated ptr
//
//  Notes:
//
//----------------------------------------------------------------------------

inline BOOL CCHARBuffer::Cat(PCHAR pszFrom)
{
    DWORD  len1 = strlen(pchBuffer),
           len2 = strlen(pszFrom),
           len3 = len1+len2 + 1;

    if ( len3 > MAX_CHAR_BUFFER_SIZE)
    {
        PCHAR ptr = new CHAR [len3];

        //Avoid AV'ing
        if (!ptr)
            return FALSE;

        memcpy(ptr, pchBuffer, len1);

        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        pchBuffer = ptr;
    }
    memcpy( ((LPWSTR)(pchBuffer)+len1), pszFrom, (len2+1) * sizeof(CHAR));
    _cBuffer = len3;
    return TRUE;
}
#endif // __CBUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\cpropbag.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cpropbag.cpp

Abstract:

	This module contains the definition of the 
	generic property bag class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	06/30/98	created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "cpropbag.h"

// =================================================================
// Default instance info
//

PROPERTY_TABLE_INSTANCE	CMailMsgPropertyBag::s_DefaultInstanceInfo =
{
	GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE,
	GLOBAL_PROPERTY_ITEM_BITS,
	GLOBAL_PROPERTY_ITEM_SIZE,
	0,
	INVALID_FLAT_ADDRESS
};

DWORD CMailMsgLoggingPropertyBag::LoggingHelper(
			LPVOID pvLogHandle, 
			const INETLOG_INFORMATION *pLogInformation
			)
{
	if (!pvLogHandle) {
		_ASSERT(pvLogHandle);
		return (ERROR_INVALID_PARAMETER);
	}
	return (((LOGGING *) pvLogHandle)->LogInformation(pLogInformation));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\cleanback.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cleanback.h
//
// Contents: Implements Cleanup callback interface
//
// Classes: CCleanBack
//
// Description: The intention is this object will be used as a part of
//              other objects (member variable or inheritence).
//              Therefore, the IUnknown passed in is NOT referenced.
//
// History:
// jstamerj 1999/09/27 17:58:50: Created.
//
//-------------------------------------------------------------
#include "mailmsg.h"
#include "spinlock.h"

class CCleanBack :
    public IMailMsgRegisterCleanupCallback
{
  public:
    CCleanBack(IUnknown *pUnknown)
    {
        m_pListHead = NULL;
        m_pIUnknown = pUnknown;
        InitializeSpinLock(&m_spinlock);
    }
    ~CCleanBack()
    {
        CallCallBacks();
    }
    VOID CallCallBacks()
    {
        //
        // Call all registered callbacks while destroying the list
        //
        CCallBack *pCallback;

        while(m_pListHead) {
            //
            // Dequeue from head of list
            //
            AcquireSpinLock(&m_spinlock);

            pCallback = m_pListHead;
            if(pCallback)
                m_pListHead = pCallback->GetNext();

            ReleaseSpinLock(&m_spinlock);
            //
            // Make the call
            //
            if(pCallback) {
                pCallback->Call(m_pIUnknown);
                delete pCallback;
            }
        }
    }        

    STDMETHOD (RegisterCleanupCallback) (
        IMailMsgCleanupCallback *pICallBack,
        PVOID                    pvContext)
    {
        CCallBack *pCCallBack;

        if(pICallBack == NULL)
            return E_POINTER;

        pCCallBack = new CCallBack(
            pICallBack,
            pvContext);

        if(pCCallBack == NULL)
            return E_OUTOFMEMORY;

        //
        // Insert object into list
        //
        AcquireSpinLock(&m_spinlock);
        pCCallBack->SetNext(m_pListHead);
        m_pListHead = pCCallBack;
        ReleaseSpinLock(&m_spinlock);

        return S_OK;
    }

    
    class CCallBack {

      public:
        CCallBack(IMailMsgCleanupCallback *pICallBack, PVOID pvContext)
        {
            m_pICallBack = pICallBack;
            m_pICallBack->AddRef();
            m_pvContext = pvContext;
            m_pNext = NULL;
        }
        ~CCallBack()
        {
            m_pICallBack->Release();
        }
        VOID Call(IUnknown *pIUnknown)
        {
            m_pICallBack->CleanupCallback(
                pIUnknown,
                m_pvContext);
        }
        VOID SetNext(CCallBack *pCCallBack)
        {
            m_pNext = pCCallBack;
        }
        CCallBack * GetNext()
        {
            return m_pNext;
        }

      private:
        IMailMsgCleanupCallback *m_pICallBack;
        PVOID m_pvContext;
        CCallBack *m_pNext;
    };
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        PVOID *ppv)
    {
        return m_pIUnknown->QueryInterface(
            iid,
            ppv);
    }
    STDMETHOD_ (ULONG, AddRef) ()
    {
        return m_pIUnknown->AddRef();
    }
    STDMETHOD_ (ULONG, Release) ()
    {
        return m_pIUnknown->Release();
    }

  private:
    SPIN_LOCK m_spinlock;
    CCallBack *m_pListHead;
    IUnknown *m_pIUnknown;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\cpropbag.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpropbag.h

Abstract:

    This module contains the definition of the 
    generic property bag class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    06/30/98    created

--*/

#ifndef _CPROPBAG_H_
#define _CPROPBAG_H_


#include "filehc.h"
#include "mailmsg.h"
#include "cmmtypes.h"
#include "cleanback.h"

//
//Logging facilities
//
#include "inetcom.h"
#include "logtype.h"


/***************************************************************************/
// Definitions
//

#define GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID     ((DWORD)'PTGv')


/***************************************************************************/
// CMailMsgPropertyBag
//

//
// Disable warning about using the this pointer in the constructor
// (CCleanBack only saves the pointer, so this is safe)
//
#pragma warning( disable: 4355 )

class CMailMsgPropertyBag : 
    public IMailMsgPropertyBag,
    public CCleanBack
{
  public:

    CMailMsgPropertyBag() :
        CCleanBack((IUnknown *)(IMailMsgPropertyBag *)this),
        m_bmBlockManager(NULL),
        m_ptProperties(
            PTT_PROPERTY_TABLE,
            GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
            &m_bmBlockManager,
            &m_InstanceInfo,
            CompareProperty,
            NULL,
            NULL
        )
    {
        m_lRefCount = 1;

        // Copy the default instance into our instance
        MoveMemory(
                &m_InstanceInfo, 
                &s_DefaultInstanceInfo, 
                sizeof(PROPERTY_TABLE_INSTANCE));
    }

    ~CMailMsgPropertyBag()
    {
        //
        // Call all registered callbacks BEFORE destroying member
        // variables (so that properties will still be accessible) 
        //
        CallCallBacks();
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
            if (riid == IID_IUnknown)
                *ppvObj = (IUnknown *)(IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgPropertyBag)
                *ppvObj = (IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgRegisterCleanupCallback)
                *ppvObj = (IMailMsgRegisterCleanupCallback *)this;
            else
                return(E_NOINTERFACE);
            AddRef();
            return(S_OK);
    }

    unsigned long STDMETHODCALLTYPE AddRef() 
    {
        return(InterlockedIncrement(&m_lRefCount));
    }

    unsigned long STDMETHODCALLTYPE Release() 
    {
        LONG    lTemp = InterlockedDecrement(&m_lRefCount);
        if (!lTemp)
        {
            // Extra releases are bad!
            _ASSERT(lTemp);
        }
        return(lTemp);
    }

    HRESULT STDMETHODCALLTYPE PutProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        piItem.idProp = dwPropID;
        return(m_ptProperties.PutProperty(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pbValue));
    }

    HRESULT STDMETHODCALLTYPE GetProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                DWORD   *pcbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        return(m_ptProperties.GetPropertyItemAndValue(
                                (LPVOID)&dwPropID,
                                (LPPROPERTY_ITEM)&piItem,
                                cbLength,
                                pcbLength,
                                pbValue));
    }

    HRESULT STDMETHODCALLTYPE PutStringA(
                DWORD   dwPropID,
                LPCSTR  pszValue
                ) 
    {
        return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringA(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPSTR   pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutStringW(
                DWORD   dwPropID,
                LPCWSTR pszValue
                )
    {
        return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringW(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPWSTR  pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutDWORD(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetDWORD(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutBool(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        dwValue = dwValue ? 1 : 0;
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetBool(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        HRESULT hrRes;
        DWORD dwLength;

        hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
        if (pdwValue)
            *pdwValue = *pdwValue ? 1 : 0;
        return (hrRes);
    }

  private:

    // The specific compare function for this type of property table
    static HRESULT CompareProperty(
                LPVOID          pvPropKey,
                LPPROPERTY_ITEM pItem
                );

  private:

    // Usage count
    LONG                            m_lRefCount;

    // Property table instance
    PROPERTY_TABLE_INSTANCE         m_InstanceInfo;
    static PROPERTY_TABLE_INSTANCE  s_DefaultInstanceInfo;

    // IMailMsgProperties is an instance of CPropertyTable
    CPropertyTable                  m_ptProperties;

    // An instance of the block memory manager 
    CBlockManager                   m_bmBlockManager;

};

//
// Restore original warning settings
//
#pragma warning ( default: 4355 )

/***************************************************************************/
// CMailMsgLoggingPropertyBag
//

class __declspec(uuid("58f9a2d2-21ca-11d2-aa6b-00c04fa35b82")) CMailMsgLoggingPropertyBag : 
    public CMailMsgPropertyBag,
    public IMailMsgLoggingPropertyBag
{
  public:

    CMailMsgLoggingPropertyBag()
    {
        m_lRefCount = 1;
        m_pvLogHandle       = NULL;
    }

    HRESULT STDMETHODCALLTYPE PutProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                LPBYTE  pbValue
                )
    {
        HRESULT                 hrRes = S_OK;

        m_rwLock.ExclusiveLock();
        hrRes = CMailMsgPropertyBag::PutProperty(
                        dwPropID,
                        cbLength,
                        pbValue);
        m_rwLock.ExclusiveUnlock();
        return(hrRes);
    }

    HRESULT STDMETHODCALLTYPE GetProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                DWORD   *pcbLength,
                LPBYTE  pbValue
                )
    {
        HRESULT                 hrRes = S_OK;

        m_rwLock.ExclusiveLock();
        hrRes = CMailMsgPropertyBag::GetProperty(
                                dwPropID,
                                cbLength,
                                pcbLength,
                                pbValue);
        m_rwLock.ExclusiveUnlock();
        return(hrRes);
    }

    HRESULT STDMETHODCALLTYPE PutStringA(
                DWORD   dwPropID,
                LPCSTR  pszValue
                ) 
    {
        return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringA(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPSTR   pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutStringW(
                DWORD   dwPropID,
                LPCWSTR pszValue
                )
    {
        return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringW(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPWSTR  pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutDWORD(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetDWORD(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutBool(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        dwValue = dwValue ? 1 : 0;
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetBool(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        HRESULT hrRes;
        DWORD dwLength;

        hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
        if (pdwValue)
            *pdwValue = *pdwValue ? 1 : 0;
        return (hrRes);
    }

    HRESULT SetLogging(
                LPVOID  pvLogHandle
                )
    {
        if (!pvLogHandle)
            return(E_POINTER);
        m_pvLogHandle = pvLogHandle;
        return(S_OK);
    }

    static void SetInetLogInfoField(
                LPCSTR  pszInput, 
                LPSTR   *ppszOutput, 
                DWORD   *pdwOutput
                )
    {
        if (pszInput) 
        {
            *ppszOutput = (LPSTR) pszInput;
            if (pdwOutput) 
                *pdwOutput = lstrlen(pszInput);
        }
    }

    unsigned long STDMETHODCALLTYPE AddRef() 
    {
        return(InterlockedIncrement(&m_lRefCount));
    }

    unsigned long STDMETHODCALLTYPE Release() 
    {
        LONG    lTemp = InterlockedDecrement(&m_lRefCount);
        if (!lTemp)
        {
            // Extra releases are bad!
            _ASSERT(lTemp);
        }
        return(lTemp);
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
            if (riid == IID_IUnknown)
                *ppvObj = (IUnknown *)(IMailMsgLoggingPropertyBag *)this;
            else if (riid == IID_IMailMsgLoggingPropertyBag)
                *ppvObj = (IMailMsgLoggingPropertyBag *)this;
            else if (riid == __uuidof(CMailMsgLoggingPropertyBag))
                *ppvObj = (CMailMsgLoggingPropertyBag *)this;
            else if (riid == IID_IMailMsgPropertyBag)
                *ppvObj = (IMailMsgPropertyBag *)
                          ((IMailMsgLoggingPropertyBag *)this);
            else if (riid == IID_IMailMsgRegisterCleanupCallback)
                *ppvObj = (IMailMsgRegisterCleanupCallback *)this;
            else
                return(E_NOINTERFACE);
            AddRef();
            return(S_OK);
    }

    static DWORD LoggingHelper(
                LPVOID pvLogHandle, 
                const INETLOG_INFORMATION *pLogInformation
                );

    HRESULT STDMETHODCALLTYPE WriteToLog(
                LPCSTR pszClientHostName,
                LPCSTR pszClientUserName,
                LPCSTR pszServerAddress,
                LPCSTR pszOperation,
                LPCSTR pszTarget,
                LPCSTR pszParameters,
                LPCSTR pszVersion,
                DWORD dwBytesSent,
                DWORD dwBytesReceived,
                DWORD dwProcessingTimeMS,
                DWORD dwWin32Status,
                DWORD dwProtocolStatus,
                DWORD dwPort,
                LPCSTR pszHTTPHeader
                ) 
    {
        INETLOG_INFORMATION info;
        DWORD dwRes;

        memset(&info,0,sizeof(info));
        SetInetLogInfoField(pszClientHostName,&info.pszClientHostName,&info.cbClientHostName);
        SetInetLogInfoField(pszClientUserName,&info.pszClientUserName,NULL);
        SetInetLogInfoField(pszServerAddress,&info.pszServerAddress,NULL);
        SetInetLogInfoField(pszOperation,&info.pszOperation,&info.cbOperation);
        SetInetLogInfoField(pszTarget,&info.pszTarget,&info.cbTarget);
        SetInetLogInfoField(pszParameters,&info.pszParameters,NULL);
        SetInetLogInfoField(pszVersion,&info.pszVersion,NULL);
        info.dwBytesSent = dwBytesSent;
        info.dwBytesRecvd = dwBytesReceived;
        info.msTimeForProcessing = dwProcessingTimeMS;
        info.dwWin32Status = dwWin32Status;
        info.dwProtocolStatus = dwProtocolStatus;
        info.dwPort = dwPort;
        SetInetLogInfoField(pszHTTPHeader,&info.pszHTTPHeader,&info.cbHTTPHeaderSize);
        dwRes = LoggingHelper(m_pvLogHandle,&info);
        return(S_OK);
    }


  private:

    // Usage count
    LONG                m_lRefCount;
    LPVOID              m_pvLogHandle;
    CShareLockNH        m_rwLock;

};



// =================================================================
// Compare function
//

inline HRESULT CMailMsgPropertyBag::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}                       



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\dirnot.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "dirnot.hxx"
#include "headers.hxx"
#include "timeconv.h"
#include "smtpcli.hxx"

//
// ProgID for IMsg - this needs to be published in an SDK
//

#define TIMEOUT_INTERVAL 30
#define DIRNOT_IP_ADDRESS "127.0.0.1"

#define IMSG_PROGID L"Exchange.IMsg"
#define MAILMSG_PROGID   L"Exchange.MailMsg"


extern void GenerateMessageId (char * Buffer, DWORD BuffLen);
extern DWORD GetIncreasingMsgId();
extern BOOL FindNextUnquotedOccurrence(char *lpszString,DWORD dwStringLength, char cSearch,char **ppszLocation);

static char * Daynames[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

//Event used make write files blocking
HANDLE              g_hFileWriteEvent;

//
// provide memory for static declared in SMTP_DIRNOT
//
CPool   CIoBuffer::Pool( DIRNOT_BUFFER_SIGNATURE );
CPool   CBuffer::Pool( DIRNOT_IO_BUFFER_SIGNATURE );

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

//+---------------------------------------------------------------
//
//  Function:   CBuffer
//
//  Synopsis:   constructor
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CBuffer::CBuffer( BOOL bEncrypted ) :
    m_dwSignature( DIRNOT_BUFFER_SIGNATURE ),
    m_bEncrypted( bEncrypted )
{
    TraceFunctEnterEx( (LPARAM)this, "CBuffer::CBuffer" );

    //
    // allocate the IO Buffer for this CBuffer
    // allocator needs to call GetData to ensure m_pIoBuffer is not NULL
    //

    ZeroMemory (&m_Overlapped, sizeof(m_Overlapped));
    m_pIoBuffer = new CIoBuffer;

    m_Overlapped.pBuffer = this;
    m_cCount = 0;  
}

//+---------------------------------------------------------------
//
//  Function:   CBuffer::~CBuffer
//
//  Synopsis:   frees associated IO buffer
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CBuffer::~CBuffer( void )
{
    TraceFunctEnterEx( (LPARAM)this, "CBuffer::~CBuffer" );

    //
    // delete the IO Buffer for this CBuffer
    //
    if ( m_pIoBuffer != NULL )
    {
        delete    m_pIoBuffer;
        m_pIoBuffer = NULL;
    }
    
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name:

    SMTP_DIRNOT::SMTP_DIRNOT

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

--*/
SMTP_DIRNOT::SMTP_DIRNOT(SMTP_SERVER_INSTANCE * pInstance)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::SMTP_DIRNOT" );

    _ASSERT(pInstance != NULL);

    m_hDir = INVALID_HANDLE_VALUE;
    m_pAtqContext = NULL;
    m_cPendingIoCount = 0;
    m_cDirChangeIoCount = 0;
    m_cActiveThreads = 0;
    m_pInstance = pInstance;
    //m_pRetryQ = NULL;
    m_Signature = SMTP_DIRNOT_SIGNATURE_VALID;
    InitializeCriticalSection (&m_CritFindLock);

    g_hFileWriteEvent = INVALID_HANDLE_VALUE;

    m_FindThreads = 0;
    m_FindFirstHandle = INVALID_HANDLE_VALUE;
    m_bDelayedFind = FALSE;

    TraceFunctLeaveEx((LPARAM)this);

}

SMTP_DIRNOT::~SMTP_DIRNOT (void)
{
    PATQ_CONTEXT pAtqContext = NULL;
    HANDLE  hTemp = INVALID_HANDLE_VALUE;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::~SMTP_DIRNOT" );

    _ASSERT(GetThreadCount() == 0);

    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, (PVOID) NULL);
    if ( pAtqContext != NULL ) 
    {
       pAtqContext->hAsyncIO = NULL;
       AtqFreeContext( pAtqContext, TRUE );
    } 

    // Invalidate the signature. since this connection is trashed.
    m_Signature = SMTP_DIRNOT_SIGNATURE_FREE;

    hTemp = (HANDLE)InterlockedExchangePointer( (PVOID *)&g_hFileWriteEvent, (PVOID) INVALID_HANDLE_VALUE);
    if ( hTemp != INVALID_HANDLE_VALUE ) 
    {
       CloseHandle(hTemp);
    } 

    DeleteCriticalSection (&m_CritFindLock);

    TraceFunctLeaveEx((LPARAM)this);
}

void SMTP_DIRNOT::SetPickupRetryQueueEvent(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::SetPickupRetryQueueEvent");

    //if(m_pRetryQ)
    //{
    //    m_pRetryQ->SetQueueEvent();
    //}
    
    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_DIRNOT::InitializeObject (char *DirPickupName,  ATQ_COMPLETION  pfnCompletion)
{
    DWORD    error = 0;
    //PATQ_CONT pContext;
    HANDLE    StopHandle;
    DWORD    i;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::InitializeObject" );

    _ASSERT(m_pInstance != NULL);

    //open the directory
    m_hDir = CreateFile (DirPickupName, FILE_LIST_DIRECTORY,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
                        NULL);
    if(m_hDir == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateFile on %s failed with error %d ", DirPickupName, GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    g_hFileWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(g_hFileWriteEvent == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed for FileWriteEvent with error %d ", GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    StopHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(StopHandle == NULL)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed with error %d ", GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;        
    }

    //add it to our Gibraltar interface
    if(!AtqAddAsyncHandle( &m_pAtqContext, NULL, this, pfnCompletion,
                            INFINITE, m_hDir))
     {
        error = GetLastError();
        ErrorTrace((LPARAM) this, "AtqAddAsyncHandle on %s failed with error %d ", DirPickupName, GetLastError());
        CloseHandle (m_hDir);
        CloseHandle (StopHandle);
        m_hDir = INVALID_HANDLE_VALUE;
        StopHandle = NULL;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
     }

    QuerySmtpInstance()->SetDirnotStopHandle(StopHandle);

    //
    // pend a set of outstanding directory change notifications, at all times, we want
    // at least one notification outstanding, so pend 3 or 4
    //

    for (i = 0; i < OUTSTANDING_NOTIFICATIONS; i++)
    {
        if(!PendDirChangeNotification ())
        {
            ErrorTrace((LPARAM) this, "PendDirChangeNotification on failed with error %d ", GetLastError());
            ErrorTrace((LPARAM) this, "Setting stop handle because PendDirChangeNotification () failed");
            SetEvent(StopHandle);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

void SMTP_DIRNOT::CloseDirHandle (void)
{
    HANDLE        hDir = NULL;
    int i = 0;
    int Count = 0;
    int AfterSleepCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount = 0;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::CloseDirHandle" );

    _ASSERT(m_pInstance != NULL);

	hDir = (HANDLE) InterlockedExchangePointer((PVOID *) &m_hDir, NULL);
    if(hDir != NULL)
    {
        CloseHandle (hDir);
    }

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //

    dwTickCount = GetTickCount();
    for( i = 0; i < 240;  i++ ) 
    {
        dwAllocCount = (DWORD) QuerySmtpInstance()->GetCBufferAllocCount ();

        if ( dwAllocCount == 0) 
        {
            DebugTrace((LPARAM)this, "All pickup CBuffers are gone!");
            break;
        }

        Sleep( 1000 );

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc && 
                (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING))
        {
            DebugTrace((LPARAM)this, "Updating stop hint in pickup, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                             SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u;", 
                dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount)
        {
            DebugTrace((LPARAM)this, "Pickup CBuffers are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }


    DebugTrace((LPARAM)this, "Waiting for QuerySmtpInstance()->GetDirnotStopHandle()!");

    WaitForSingleObject(QuerySmtpInstance()->GetDirnotStopHandle(), INFINITE);

    DebugTrace((LPARAM)this, "End waiting for QuerySmtpInstance()->GetDirnotStopHandle()!");

    QuerySmtpInstance()->SetStopHint(2);

    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_DIRNOT::CreateSmtpDirNotification

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNOUT
       class.  This class cannot be allocated on the stack.

    Arguments:


    Returns:

       A pointer to an SMTP_DIRNOT class or NULL
--*/
SMTP_DIRNOT * SMTP_DIRNOT::CreateSmtpDirNotification (char * DirPickupName, 
                                                      ATQ_COMPLETION  pfnCompletion,
                                                      SMTP_SERVER_INSTANCE * pInstance)
{
    SMTP_DIRNOT * pSmtpDirNotObj;

    TraceFunctEnterEx((LPARAM) 0, "SMTP_CONNOUT::CreateSmtpConnection");

    pSmtpDirNotObj = new SMTP_DIRNOT (pInstance);
    if(pSmtpDirNotObj == NULL)
    {
        ErrorTrace(0, "new SMTP_DIRNOT () failed");
        TraceFunctLeaveEx((LPARAM)NULL);
        return NULL;
    }

    if(!pSmtpDirNotObj->InitializeObject(pSmtpDirNotObj->QuerySmtpInstance()->GetMailPickupDir(), SMTP_DIRNOT::ReadDirectoryCompletion))
    {
        TraceFunctLeaveEx((LPARAM)NULL);
        return NULL;
    }

    TraceFunctLeaveEx((LPARAM)NULL);
    return pSmtpDirNotObj;
}


BOOL SMTP_DIRNOT::DoFindFirstFile(BOOL    bIISThread)
{
    //
    // re-entrent FindFirst... the first thread does the FindFirst, all other threads up to
    // MAXFIND_THREADS do the FindNext.
    //

    char                    Buffer [MAX_PATH + 1];
    HANDLE                    hFindFile = INVALID_HANDLE_VALUE;
    DWORD                    BytesRead  = 0;
    DWORD                    NumFiles = 0;
    WIN32_FIND_DATA            find;
    BOOL                    bClosed;
    PSMTP_IIS_SERVICE        pService;

    TraceFunctEnterEx((LPARAM)this, "DoFindFirstFile");

    _ASSERT(m_pInstance != NULL);

    if (!QuerySmtpInstance()->GetAcceptConnBool())
    {
        return TRUE;
    }


    pService = (PSMTP_IIS_SERVICE) g_pInetSvc;
    //
    // ensure only one thread gets in here at a time.  we can only have one thread either setting
    // the find first at a time.
    //

    LockFind();

    hFindFile = GetFindFirstHandle();
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //make up the file spec we want to find
        lstrcpy(Buffer, QuerySmtpInstance()->GetMailPickupDir());
        lstrcat(Buffer, "*.*");

        hFindFile = FindFirstFile(Buffer, &find);
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // should not fail as we look for *.* and the directory root should be there.
            // setting the flag will make sure that next drop posts a findfirst.
            SetDelayedFindNotification(TRUE);

            ErrorTrace((LPARAM) this, "FindFirst failed for %s. Error %d", Buffer, GetLastError());

            UnLockFind();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
        else
        {

            IncFindThreads();    // there should be not find threads running at this point.
            //
            // We have no IIS threads available for the single findfirst... we must create a thread.
            // hopefull this will happen seldom.

            SetFindFirstHandle(hFindFile);
            
            SetDelayedFindNotification(FALSE);
        }
    }
    else
    {
        SetDelayedFindNotification(TRUE);
        
        if (!IncFindThreads())
        {
            UnLockFind();
        
            DebugTrace((LPARAM)this, "Have hit the max num Find Threads.");
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }

        if (!FindNextFile(hFindFile, &find))
        {
            if (GetLastError() != ERROR_NO_MORE_FILES)
            {
                SetDelayedFindNotification(TRUE);
                ErrorTrace((LPARAM) this,"FindNextFile() failed with error %d", GetLastError());
            }
        
            CloseFindHandle();  // will DecFindThreads.

            //
            // In the case below, it is possible that some files were missed by FindFirst.  
            // Create an ATQ thread for a final findfirst iteration to make sure.
            //
            if ((GetNumFindThreads() == 0) && GetDelayedFindNotification())
            {
                IncPendingIoCount();
                // AtqContext with buffer size of zero to get a FindFirst Going.
                if(!AtqPostCompletionStatus(QueryAtqContext(), 0))
                {
                    DecPendingIoCount();
                    ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
                }
            }

            UnLockFind();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
    }

    UnLockFind();


    bClosed = FALSE;
    do
    {
        //format the name of the stream and then open the file.
        BytesRead = wsprintf(Buffer, "%s%s",QuerySmtpInstance()->GetMailPickupDir(), find.cFileName);
        if (!(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            HRESULT hr = S_OK;
            IMailMsgProperties *pIMsg = NULL;

            hr = CoCreateInstance(CLSID_MsgImp, NULL, CLSCTX_INPROC_SERVER,
                                            IID_IMailMsgProperties, (LPVOID *)&pIMsg);

            // Next, check if we are over the inbound cutoff limit. If so, we will release the message
            // and not proceed.
            if (SUCCEEDED(hr))
            {
                DWORD    dwCreationFlags;
                hr = pIMsg->GetDWORD(
                            IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                            &dwCreationFlags);
                if (FAILED(hr) || 
                    (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                {
                    // If we fail to get this property of if the inbound cutoff
                    // exceeded flag is set, discard the message and return failure
                    if (SUCCEEDED(hr))
                    {
                        DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                        hr = E_OUTOFMEMORY;
                    }
                    pIMsg->Release();
                    pIMsg = NULL;
                }
            }

            DebugTrace((LPARAM)this,"Found file %s", find.cFileName);

            if ((pIMsg == NULL) || FAILED(hr))
            {
                // We are out of resources, there is absolutely nothing
                // we can do: can't NDR, can't retry ...
                ErrorTrace((LPARAM) this, "new  MAILQ_ENTRY failed for file: %s",
                            find.cFileName);

                // 
                // Will want to run a findfirst when things free up a little.  Flag the post-processing findfirst.
                //
                SetDelayedFindNotification(TRUE);
                IncPendingIoCount ();
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, TIMEOUT_INTERVAL);    //retry after a while
                ErrorTrace((LPARAM)this, "Failed to create message will retry later.");
                break;
            }
            else
            {
                // We are in faith that upon delivery, the allocated
                // MailQEntry structure will be freed
                NumFiles++;
                pIMsg->PutStringA(IMMPID_MP_PICKUP_FILE_NAME, find.cFileName);

                if(!ProcessFile(pIMsg))
                {
                    // will be mail left in pickup.  queue a findfirst to take care of it.
                    SetDelayedFindNotification(TRUE);
                }
            }
        }

    
        LockFind();
        if (!FindNextFile(hFindFile, &find))
        {
            if (GetLastError() != ERROR_NO_MORE_FILES)
            {
                SetDelayedFindNotification(TRUE);
                ErrorTrace((LPARAM) this,"FindNextFile() failed with error %d", GetLastError());
            }

            CloseFindHandle();

            //
            // In the case below, it is possible that some files were missed by FindFirst.  
            // Create an ATQ thread for a final findfirst iteration to make sure.
            //
            if ((GetNumFindThreads() == 0) && GetDelayedFindNotification())
            {
                IncPendingIoCount();
                // AtqContext with buffer size of zero to get a FindFirst Going.
                if(!AtqPostCompletionStatus(QueryAtqContext(), 0))
                {
                    DecPendingIoCount();
                    ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
                }
            }

            UnLockFind();
            bClosed = TRUE;
            break;
        }
        UnLockFind();

    } 
    while ((!QuerySmtpInstance()->IsShuttingDown())
            && (QuerySmtpInstance()->QueryServerState( ) != MD_SERVER_STATE_STOPPED)
            && (QuerySmtpInstance()->QueryServerState( ) != MD_SERVER_STATE_INVALID)); 

        
    if (!bClosed)    // termination by the while condition above.
    {
        LockFind();
        CloseFindHandle();    
                
        UnLockFind();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}



DWORD WINAPI SMTP_DIRNOT::CreateNonIISFindThread(void * ClassPtr)
{
    //
    // Called by a CreateThread when we have run out of IIS threads.
    //

    SMTP_DIRNOT * ThisPtr = (SMTP_DIRNOT *) ClassPtr;

    TraceFunctEnterEx((LPARAM) ThisPtr,"CreateNonIISFindThread");

    _ASSERT(ThisPtr != NULL);

    _ASSERT(ThisPtr->QuerySmtpInstance() != NULL);


    //
    // Build the initial list - THE FLAG bIISThread IS SET TO FALSE.  
    // We IncCBufferAllocCount and DecCBufferAllocCount to make sure that we clean up properly in CloseDirHandle.
    // We don't want to destroy the Dirnot Object before this thread finishes.
    //

    ThisPtr->QuerySmtpInstance()->IncCBufferObjs();

    ThisPtr->DoFindFirstFile(FALSE);

    ThisPtr->QuerySmtpInstance()->DecCBufferObjs();

    TraceFunctLeaveEx((LPARAM)ThisPtr);
    return TRUE;
}



DWORD WINAPI SMTP_DIRNOT::PickupInitialFiles(void * ClassPtr)
{
    SMTP_DIRNOT * ThisPtr = (SMTP_DIRNOT *) ClassPtr;

    TraceFunctEnterEx((LPARAM) ThisPtr,"PickupInitialFiles");

    _ASSERT(ThisPtr != NULL);

    _ASSERT(ThisPtr->QuerySmtpInstance() != NULL);

    // Just quit if we are suhtting down already
    if (ThisPtr->QuerySmtpInstance()->IsShuttingDown())
        return TRUE;

    // Build the initial list
    ThisPtr->DoFindFirstFile();

    TraceFunctLeaveEx((LPARAM)ThisPtr);
    return TRUE;
}



#define PRIVATE_OPTIMAL_BUFFER_SIZE        4096
#define PRIVATE_LINE_BUFFER_SIZE        1024

#define IS_SPACE_OR_TAB(ch)                (((ch) == ' ') || ((ch) == '\t'))
#define IS_WHITESPACE_OR_CRLF(ch)        (((ch) == ' ') || ((ch) == '\t') || ((ch) == '\n') || ((ch) == '\r'))

static void pReplaceCrLfWithSpaces(CHAR *szIn, CHAR *szOut)
{
    while (*szIn)
    {
        if ((*szIn == '\r') || (*szIn == '\n'))
            *szOut++ = ' ';
        else
            *szOut++ = *szIn;
        szIn++;
    }
    *szOut = '\0';
}

BOOL SMTP_DIRNOT::CreateToList (char *AddrsList, IMailMsgRecipientsAdd *pIMsgRecips, IMailMsgProperties *pIMsgProps)
{
    char *p = NULL;                    //points to the ',' or '\0'
    char * StartOfAddress = NULL;    //start of recipient address
    char * EndOfAddress = NULL;        // end of recipient address
    char * ThisAddress = NULL;
    CAddr * NewAddress = NULL;        //new CAddr to add to our list
    char szAddress[MAX_INTERNET_NAME + 1], *pszAddress = szAddress;
    DWORD    dwPropId = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwNewRecipIndex = 0;
    HRESULT hr = S_OK;
    BOOL fNotFound = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::CreateToList");

    _ASSERT(m_pInstance != NULL);

    //start at the top of the list
    p = AddrsList;

    //get rid of leading white space, newlines, and commas
    while ((*p == ',') || IS_WHITESPACE_OR_CRLF(*p))
        p++;

    while((p != NULL) && (*p != '\0'))
    {
        char LastChar;

        StartOfAddress = p;

        // Find the ending delimiter of the address
        //while((*p != '\0') && (*p != ','))
        //    p++;

        // The first unquoted comma indicates the end of the address
        if(!FindNextUnquotedOccurrence(p,strlen(p),',',&EndOfAddress))
        {
                SetLastError(ERROR_INVALID_DATA);
                NewAddress = NULL;
                ErrorTrace((LPARAM) this, "Failed to parse out the address");
                return FALSE;
        }
        else if(!EndOfAddress)
            EndOfAddress = p + strlen(p);

        p = EndOfAddress;

        _ASSERT(EndOfAddress != NULL);
        
        // We don't like trailing spaces either, so walk backwards
        // to get rid of them
        //EndOfAddress = p;
        while (EndOfAddress > StartOfAddress)
        {
            EndOfAddress--;
            if (!IS_WHITESPACE_OR_CRLF(*EndOfAddress))
            {
                EndOfAddress++;
                break;
            }
        }

        // Save the character we are about to overrite
        LastChar = *EndOfAddress;

        // NULL terminate the address
        *EndOfAddress = '\0';

        if(lstrlen(StartOfAddress) > (MAX_INTERNET_NAME + 1))
        {
                SetLastError(ERROR_INVALID_DATA);
                NewAddress = NULL;
                ErrorTrace((LPARAM) this, "Address too long : %d bytes",lstrlen(StartOfAddress));
                return FALSE;
        }

        pReplaceCrLfWithSpaces(StartOfAddress, szAddress);

        DebugTrace((LPARAM) this, "found address [%s]", szAddress);

        //
        // Run it through the addr821 library
        //
        NewAddress = CAddr::CreateAddress(szAddress);
        BOOL fValidAddress = FALSE;
        if(NewAddress)
        {
            if(!NewAddress->IsDomainOffset())
            {
                CAddr * TempAddress = NULL;
                TempAddress = QuerySmtpInstance()->AppendLocalDomain (NewAddress);
                if (TempAddress)
                {
                    delete NewAddress;
                    NewAddress = TempAddress;
                    TempAddress = NULL;
                } else if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                    ErrorTrace((LPARAM) this, "CAddr::CreateAddress (StartOfAddress) failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

            }

            DebugTrace((LPARAM) this, "CreateAddress returned %s", NewAddress->GetAddress());

            ThisAddress = NewAddress->GetAddress();
            DWORD dwLen = strlen(ThisAddress);
            if(Validate821Address(
                ThisAddress,
                dwLen)) {
                
                LPSTR pszDomain;
                if(Get821AddressDomain(
                    ThisAddress,
                    dwLen,
                    &pszDomain) && pszDomain) 
                {
                    DWORD dwDomain = strlen(pszDomain);
                    if (Validate821Domain(pszDomain, dwDomain)) {
                        // everything is valid
                        fValidAddress = TRUE;
                    }
                } else {
                    ErrorTrace((LPARAM)0, "Detected legal address without a domain: %s", 
                               ThisAddress);
                }
            } else {
                ErrorTrace((LPARAM)0, "Detected ILLEGAL address: %s",
                           ThisAddress);
            }
        } else {
            if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                ErrorTrace((LPARAM) this, "CAddr::CreateAddress (StartOfAddress) failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            ThisAddress = szAddress;
            fValidAddress = FALSE;
        }


        hr = pIMsgRecips->AddPrimary(1, (LPCTSTR *) &ThisAddress, &dwPropId, &dwNewRecipIndex, NULL, 0);
        if (FAILED(hr)) {
            SetLastError(hr);
            return FALSE;
        }

        if (NewAddress) delete NewAddress;

        if (!fValidAddress) {
            // AQ will look for this special domain and won't add it to the
            // DMT.  This stops us from putting corrupted domains into the
            // DMT
            hr = pIMsgRecips->PutStringA(dwNewRecipIndex, 
                                         IMMPID_RP_DOMAIN, 
                                         "==NDR==");
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutString(RP_DOMAIN) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // set the recipient to NDR
            hr = pIMsgRecips->PutDWORD(dwNewRecipIndex,
                                       IMMPID_RP_RECIPIENT_FLAGS,
                                       (RP_ERROR_CONTEXT_CAT | RP_UNRESOLVED));
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutDWORD(RP_FLAGS) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // tell AQ why it is NDRing
            hr = pIMsgRecips->PutDWORD(dwNewRecipIndex,
                                       IMMPID_RP_ERROR_CODE,
                                       CAT_E_ILLEGAL_ADDRESS);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutDWORD(RP_ERROR) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // tell AQ that some recips are NDRing
            hr = pIMsgProps->PutDWORD(IMMPID_MP_HR_CAT_STATUS,
                                      CAT_W_SOME_UNDELIVERABLE_MSGS);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "SetMailMsgCatStatus failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }
        }

        // Go find the start of the next address
        *EndOfAddress = LastChar;
        if(*p == ',')
        {
            p++;
            while(IS_WHITESPACE_OR_CRLF(*p))
                p++;
        }
    }

    TraceFunctLeave();
    return (TRUE);
}

static HANDLE pOpenPickupFile(LPSTR    szFileName)
{
    DWORD    dwError;
    HANDLE    hFile;

    TraceFunctEnterEx((LPARAM)NULL, "pOpenPickupFile");

    // Open the file
    hFile = CreateFile(szFileName, 
                        GENERIC_READ,   
                        FILE_SHARE_DELETE,
                        NULL,                              
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
                        NULL );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        ErrorTrace((LPARAM)NULL, 
                    "Error: Can't open source file %s (err=%d)...skipping it",
                    szFileName, dwError);
    }
    TraceFunctLeaveEx((LPARAM)NULL);
    return(hFile);
}

static inline BOOL pFetchFileBuffer(    HANDLE    hFile,
                                        CHAR    *lpBuffer,
                                        LPDWORD    lpdwSize)
{
    BOOL fRet = TRUE;
    DWORD Error = 0;

    fRet = ReadFile(hFile, lpBuffer, *lpdwSize, lpdwSize, NULL);

    if(!fRet)
    {
        Error = GetLastError();
        if(Error == 998)
        {
            _ASSERT(FALSE);
        }
    }

    return fRet;
}

static CHAR *pGetLineBuffer(CHAR    *lpOldBuffer,
                            DWORD    *lpdwLength)
{
    DWORD dwLength = *lpdwLength;
    CHAR  *lpBuffer;

    if (lpOldBuffer)
    {
        // We have an old buffer, we double the size of the old buffer
        _ASSERT(lpdwLength);
        dwLength <<= 1;
    }
    else
        dwLength = PRIVATE_LINE_BUFFER_SIZE;

    // Allocate the new buffer
    lpBuffer = (CHAR *)HeapAlloc(GetProcessHeap(), 0, dwLength);
    if (!lpBuffer)
        return(NULL);

    if (lpOldBuffer)
    {
        // Copy the info over and free the old buffer
        CopyMemory((LPVOID)lpBuffer, (LPVOID)lpOldBuffer, *lpdwLength);
        _VERIFY( HeapFree(GetProcessHeap(), 0, lpOldBuffer) );
    }

    *lpdwLength = dwLength;
    return(lpBuffer);
}

static BOOL pFreeLineBuffer(CHAR    *lpBuffer)
{
    return( HeapFree(GetProcessHeap(), 0, lpBuffer) );
}

static CHAR *pGetValueFromHeader(CHAR *szHeader)
{
    while (*szHeader && (*szHeader++ != ':'))
        ;
    while (*szHeader)
    {
        if (!IS_SPACE_OR_TAB(*szHeader))
            return(szHeader);
        else
            szHeader++;
    }
    return(NULL);
}

static CHAR *pReadNextLineFromBuffer(   HANDLE   hFile,
                                        CHAR    *lpBuffer,
                                        LPDWORD  lpdwSize,
                                        CHAR    *lpStart,
                                        LPSTR   *ppszLine,
                                        DWORD   *lpdwMaxLineLen,
                                        LPSTR   *ppOriginalBuffer,
                                        DWORD   *lpdwOriginalBufferLen)
{
	DWORD	dwLineLen = 0;
	DWORD	dwMaxLineLen = *lpdwMaxLineLen;
	BOOL	fThisIsCR = FALSE;
	BOOL	fLastIsCR = FALSE;
	BOOL	fThisIsLF = FALSE;
	BOOL	fLastIsLF = FALSE;
	CHAR	*lpEnd;
	CHAR	*lpszLine = *ppszLine;
	CHAR	ch;
	BOOL	bEndOfFile;

	TraceFunctEnter("pReadNextLineFromBuffer");

	_ASSERT(hFile != INVALID_HANDLE_VALUE);
	_ASSERT(!IsBadWritePtr(lpdwSize, sizeof(DWORD)));
	_ASSERT(!IsBadWritePtr(lpBuffer, *lpdwSize));
	_ASSERT(!IsBadWritePtr(*ppszLine, *lpdwMaxLineLen));

	// raid 181922/88855 - replace recusive loop with while loop.
	do {
		dwLineLen = 0;
		dwMaxLineLen = *lpdwMaxLineLen;
		fThisIsCR = FALSE;
		fLastIsCR = FALSE;
		fThisIsLF = FALSE;
		fLastIsLF = FALSE;
	
		bEndOfFile = FALSE;

		// Now, make sure the supplied start pointer is within 
		// buffer supplied (We allow it to be one byte past the
		// end of the buffer, but we will never dereference it).
		if ((lpStart < lpBuffer) || (lpStart > (lpBuffer + *lpdwSize)))
		{
			_ASSERT(0);
			return(NULL);
		}

		// Now, keep copying until we hit one of the following scenarios:
		// i)  We hit CRLF
		// ii) We hit the end of the buffer, which we reload more data
		//     or if it is the end of the mail, we postpend a CRLF.
		lpEnd = lpBuffer + *lpdwSize;
		do
		{
			// See if this is past the buffer
			if (lpStart == lpEnd)
			{
				DWORD	dwNewLength;

				dwNewLength = *lpdwSize;
				if (!pFetchFileBuffer(hFile, lpBuffer, &dwNewLength))
				{
					return(NULL);
				}

				// Done!
				if (!dwNewLength)
				{
					bEndOfFile = TRUE;
					break;
				}

				// Get the new buffer length
				*lpdwSize = dwNewLength;

				// Reset the start and end pointers
				lpStart = lpBuffer;
				lpEnd = lpBuffer + *lpdwSize;
			}

			ch = *lpszLine++ = *lpStart++;

			// Too long?
			if (++dwLineLen >= dwMaxLineLen)
			{
				CHAR *lpTemp;
				DWORD dwUsedPortion = (DWORD)(lpszLine - *ppOriginalBuffer);

				// Yep, get a bigger buffer, all the existing stuff is copied over
				DebugTrace((LPARAM)*ppOriginalBuffer, "Growing buffer at %u bytes", *lpdwOriginalBufferLen);
				lpTemp = pGetLineBuffer(*ppOriginalBuffer, lpdwOriginalBufferLen);
				if (!lpTemp)
				{
					DebugTrace((LPARAM)NULL, "Failed to obtain buffer (%u)", GetLastError());
					TraceFunctLeave();
					return(NULL);
				}

				// Got it, adjust all associated pointers and lengths
				DebugTrace((LPARAM)lpTemp, "Obtained buffer at %u bytes", *lpdwOriginalBufferLen);

				// New beginning of line buffer
				*ppOriginalBuffer = lpTemp;

				// New beginning of line
				*ppszLine = lpTemp;

				// New pointer to next character
				lpszLine = lpTemp + dwUsedPortion;

				// New maximum length for current string before re-growing
				dwMaxLineLen = *lpdwOriginalBufferLen - dwUsedPortion;

			}

			fLastIsCR = fThisIsCR;
			if (ch == '\r')
				fThisIsCR = TRUE;
			else
				fThisIsCR = FALSE;

			fLastIsLF = fThisIsLF;
			if (ch == '\n')
				fThisIsLF = TRUE;
			else
				fThisIsLF = FALSE;

			// If we have CRLF or LFCR we leave
			if ((fLastIsCR && fThisIsLF) || (fLastIsLF && fThisIsCR))
				break;

		} while (1);

		*lpszLine = '\0';

		// Calculate remaining buffer size
		*lpdwMaxLineLen = dwMaxLineLen - dwLineLen;

		// raid 178234 - If we have CRLF or LFCR and no more continue line we leave 
		if (((fLastIsCR && fThisIsLF) || (fLastIsLF && fThisIsCR)) && !IS_SPACE_OR_TAB(*lpStart))
		{
		    // raid 166777 - Make sure we do leave if we find a line.
			break;
		}


	} while (!bEndOfFile && (IS_SPACE_OR_TAB(*lpStart) || (lpStart == lpEnd)));
	
	// We always return the start of line to be the start of our buffer
	// Note that the buffer could have changed during recursion due to growth
	*ppszLine = *ppOriginalBuffer;

	TraceFunctLeave();
	return(lpStart);  
}



BOOL inline WriteToSpooledFile(PFIO_CONTEXT hDstFile, CHAR *lpszLine, DWORD &DestOffset)
{
    DWORD dwBytesToWrite;
    DWORD  dwBytesWritten;
    BOOL fResult = FALSE;
    FH_OVERLAPPED ov;
    DWORD err = NO_ERROR;
    HANDLE HackedHandle = NULL;
    BOOL fRet = FALSE;

    ZeroMemory(&ov, sizeof(ov));

    ov.Offset = DestOffset;

    dwBytesToWrite = lstrlen(lpszLine);
    if (!dwBytesToWrite)
    {
        fRet = TRUE; //This is not really a failure
        goto Exit;
    }

    //HackedHandle = ((DWORD)g_hFileWriteEvent | 1);
    HackedHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(HackedHandle == NULL)
    {
        return FALSE;
    }
    
    ov.hEvent = (HANDLE) ((ULONG_PTR) HackedHandle | 1);

    //ov.hEvent = (HANDLE)HackedHandle;

    fResult = FIOWriteFile(hDstFile, lpszLine, dwBytesToWrite, &ov);

    if (!fResult) err = GetLastError();
    
    if((err == ERROR_IO_PENDING) || (((DWORD)STATUS_PENDING == ov.Internal) && ( err == NO_ERROR )))
    {

        //      12/16/98 - MikeSwa Modified 
        // OK... this is the theory... we are getting random AV, from what
        // looks like async completion to I/O.  It looks like
        // GetOverlappedResult cannot be called to wait for a hacked handle,
        // and it will not use the first argument unless the event in the
        // overlapped structure is NULL.  The solution is to call WaitForSingleObject
        // if we detect that the IO is still pending
        WaitForSingleObject(HackedHandle, INFINITE);
        _ASSERT((DWORD)STATUS_PENDING != ov.Internal);
    }
    else if (NO_ERROR != err)
    {
        SetLastError (err); //preserve the last error
        if(err == 998)
        {
            _ASSERT(FALSE);
        }

        goto Exit;
    }


    DestOffset += dwBytesToWrite;

    fRet = TRUE;

Exit:

    if(HackedHandle)
    {
        CloseHandle(HackedHandle);
    }

    //TraceFunctLeaveEx((LPARAM)NULL);
    return fRet;
}

BOOL CopyRestOfMessage(HANDLE hSrcFile, PFIO_CONTEXT hDstFile, DWORD &DestOffset)
{
    CHAR    acBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    DWORD    dwBytesRead;
    DWORD    dwBytesWritten;
    DWORD    dwTotalBytes = 0;
    DWORD    err = NO_ERROR;
    BOOL    fResult = FALSE;
    BOOL    fRet = FALSE;
    HANDLE  HackedHandle;
    FH_OVERLAPPED ov;

    CHAR    acCrLfDotCrLf[5] = { '\r', '\n', '.', '\r', '\n' };
    CHAR    acLastBytes[5] = { '\0', '\0', '\0', '\0', '\0' };

    // Copies from the current file pointer to the end of hSrcFile 
    // and appends to the current file pointer of hDstFile.
    _ASSERT(hSrcFile != INVALID_HANDLE_VALUE);
    _ASSERT(hDstFile != NULL);

    ZeroMemory(&ov, sizeof(ov));
    
    HackedHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(HackedHandle == NULL)
    {
        return FALSE;
    }
    
    ov.hEvent = (HANDLE) ((ULONG_PTR) HackedHandle | 1);

    do 
    {
        if (!ReadFile(hSrcFile, acBuffer, 
                        PRIVATE_OPTIMAL_BUFFER_SIZE,
                        &dwBytesRead,
                        NULL))
        {
            err = GetLastError();
            if(err == 998)
            {
                _ASSERT(FALSE);
            }

            goto Exit;
        }

        if (dwBytesRead)
        {
            ov.Offset = DestOffset;

            //
            // Save the last two bytes ever read/written. the buffer after
            // writing could be modified due to dot-stripping.
            //
            
            if (dwBytesRead > 4)
            {
                CopyMemory(acLastBytes, &acBuffer[dwBytesRead-5], 5);
            }
            else
            {
                MoveMemory(acLastBytes, &acLastBytes[dwBytesRead], 5-dwBytesRead);
                CopyMemory(&acLastBytes[5-dwBytesRead], acBuffer, dwBytesRead);
            }


            fResult = FIOWriteFile(hDstFile, acBuffer, dwBytesRead, &ov);

            if (!fResult) err = GetLastError();

            if((err == ERROR_IO_PENDING) || (((DWORD)STATUS_PENDING == ov.Internal) && ( err == NO_ERROR )))
            {

                //      12/16/98 - MikeSwa Modified 
                // OK... this is the theory... we are getting random AV, from what
                // looks like async completion to I/O.  It looks like
                // GetOverlappedResult cannot be called to wait for a hacked handle,
                // and it will not use the first argument unless the event in the
                // overlapped structure is NULL.  The solution is to call 
                // WaitForSingleObject and pass in the un-munged handle (only if 
                // we know that IO is still pending).
                WaitForSingleObject(HackedHandle, INFINITE);
                _ASSERT((DWORD)STATUS_PENDING != ov.Internal);
            }
            else if (NO_ERROR != err)
            {
                SetLastError (err); //preserve the last error
                if(err == 998)
                {
                    _ASSERT(FALSE);
                }

                goto Exit;
            }

            //
            // this is because Fcache keeps track of the offset were we need
            // to write. So we update dwBytesWritten to what we actually read.
            //
            dwBytesWritten = dwBytesRead;
        }
        else
        {
            dwBytesWritten = 0;
        }

        if (dwBytesWritten)
        {
            dwTotalBytes += dwBytesWritten;
            DestOffset += dwBytesWritten;
        }

    } while (dwBytesRead);

    // Now, see if the file ends with a CRLF, if not, add it
    if ((dwTotalBytes > 1) && memcmp(&acLastBytes[3], &acCrLfDotCrLf[3], 2))
    {
        // Add the trailing CRLF        
        if (!WriteToSpooledFile(hDstFile, "\r\n", DestOffset)) 
        {
            goto Exit;
        }

        dwTotalBytes+=2;

    }

    //If file ends with CRLF.CRLF, remove the trailing .CRLF
    //NimishK ** : this was decided per the bug 63394
    if ((dwTotalBytes > 4) && !memcmp(acLastBytes, acCrLfDotCrLf, 5))
    {
        DWORD dwFileSizeHigh = 0;
        DWORD dwFileSizeLow = GetFileSizeFromContext( hDstFile, &dwFileSizeHigh );

        DWORD Offset = SetFilePointer(hDstFile->m_hFile, dwFileSizeLow, NULL, FILE_BEGIN);

        // Remove the trailing CRLF only as the <DOT> would have been removed by
        // dot-stripping by file handle cache.
        if ((SetFilePointer(hDstFile->m_hFile, -2, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile->m_hFile))
        {
            _ASSERT(0 && "SetFilePointerFailed");
            goto Exit;
        }
    }

    fRet = TRUE;


Exit:

    if(HackedHandle)
    {
        CloseHandle(HackedHandle);
    }

    return fRet;
}



BOOL SMTP_DIRNOT::ProcessFile(IMailMsgProperties *pIMsg)
{
    LONGLONG                 LastAccessTime = (LONGLONG) 0;
    CHAR*                    acCrLf = "\r\n";
    DWORD                    AbOffset = 0;
    DWORD                    DestWriteOffset = 0;
    DWORD                    HeaderFlags = 0;
    DWORD                    dwPickupFileSize = 0;
    BOOL                     fIsStartOfFile = TRUE;
    BOOL                     fIsXSenderRead = FALSE;
    BOOL                     fAreXRcptsRead = FALSE;
    BOOL                     fIsSenderSeen = FALSE;
    BOOL                     fInvalidAddresses = FALSE;
    BOOL                     fDateExists = FALSE;
    BOOL                     fMessageIdExists = FALSE;
    BOOL                     fXOriginalArrivalTime = FALSE;
    BOOL                     fFromSeen = FALSE;
    BOOL                     fRcptSeen = FALSE;
    BOOL                     fSeenRFC822FromAddress = FALSE;
    BOOL                     fSeenRFC822ToAddress = FALSE;
    BOOL                     fSeenRFC822CcAddress = FALSE;
    BOOL                     fSeenRFC822BccAddress = FALSE;
    BOOL                     fSeenRFC822Subject = FALSE;
    BOOL                     fSeenRFC822SenderAddress = FALSE;
    BOOL                     fSeenXPriority = FALSE;
    BOOL                     fSeenContentType = FALSE;
    BOOL                     fSetContentType = FALSE;
    HANDLE                   hSource = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT             hDest = NULL;
    SYSTEMTIME               SysTime;
    DWORD                    dwLineBufferSize = 0;
    DWORD                    dwMaxLineSize = 0;
    CHAR*                    szLineBuffer = NULL;
    CHAR*                    szLine = NULL;
    CHAR*                    szValue = NULL;
    CHAR                     szScratch[512];
    CHAR                     szMsgId[512];
    CHAR                     acReadBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    CHAR                     szPickupFilePath[MAX_PATH + 1];
    CHAR                     szDateBuf [cMaxArpaDate];
    DWORD                    dwBufferSize = 0;
    CHAR                     FileName[MAX_PATH + 1];
    CHAR*                    lpStart = NULL;
    CHAR*                    lpXMarker = NULL;
    DWORD                    dwBytesToRewind = 0;
    LONG                     lOffset = 0;
    CAddr*                   Sender = NULL;
    PSMTP_IIS_SERVICE        pService = NULL;
    IMailMsgRecipientsAdd*   pIMsgRecips = NULL;
    IMailMsgRecipients*      pIMsgOrigRecips = NULL;
    IMailMsgBind*            pBindInterface = NULL;
    HRESULT                  hr = S_OK;
    DWORD                    dwTotalRecips = 0;
    SMTP_ALLOC_PARAMS        AllocParams;
    BOOL                     fResult = FALSE;
    BOOL                     DeleteIMsg = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::ProcessFile" );

    _ASSERT(m_pInstance != NULL);
    _ASSERT(pIMsg);
    if (!pIMsg)
    {
        ErrorTrace((LPARAM)this, "Internal error: pIMsg is NULL.");
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    // Compose the pickup path
    hr = pIMsg->GetStringA(IMMPID_MP_PICKUP_FILE_NAME, sizeof(FileName), FileName);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "MailQEntry->GetFileName() is NULL.");
        goto RetryPickup;
    }

    hr = pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&pBindInterface);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "IMsg->QueryInterface(IID_IMailMsgBindATQ) failed.");
        goto RetryPickup;
    }

    //Get recipient list
    hr = pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &pIMsgOrigRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "IMsg->QueryInterface(IID_IMailMsgRecipients) failed.");
        goto RetryPickup;
    }

    hr = pIMsgOrigRecips->AllocNewList(&pIMsgRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "pIMsgOrigRecips->AllocNewList");
        goto RetryPickup;
    }

    lstrcpy(szPickupFilePath, QuerySmtpInstance()->GetMailPickupDir());
    lstrcat(szPickupFilePath, FileName);

    // Open the pickup file, if this failsas a sharing violation,
    // we would like to retry it ...
    hSource = pOpenPickupFile(szPickupFilePath);
    if (hSource == INVALID_HANDLE_VALUE)
    {    //
        // this is probably caused by the file still being written, wait a small amount of time
        // we manage our IO compl. threads to ensure that there are enough, so this shouldn't be
        // a big problem.  It avoids the retry queue.
        //

        WaitForSingleObject(QuerySmtpInstance()->GetQStopEvent(), g_PickupWait);
        
        hSource = pOpenPickupFile(szPickupFilePath);
        if (hSource == INVALID_HANDLE_VALUE)
        {
        
            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                //delete MailQEntry;
                ErrorTrace((LPARAM)this, "File %s is deleted from pickup dir", szPickupFilePath);
                goto RetryPickup;
            }

        // Schedule pickup mail for retry ...
        goto RetryPickup;
        }
    }

    AllocParams.BindInterfacePtr = (PVOID) pBindInterface;
    AllocParams.IMsgPtr = (PVOID)pIMsg;
    AllocParams.hContent = NULL;
    AllocParams.pAtqClientContext = QuerySmtpInstance();
    AllocParams.m_pNotify = NULL;
    fResult = QuerySmtpInstance()->AllocNewMessage (&AllocParams);

    //Get the context and the atq context
    hDest = AllocParams.hContent;

    if((!fResult) || (hDest == NULL))
    {
        goto RetryPickup;
    }

    // Get the handle of the spooled file
    _ASSERT(hDest != NULL);

    //
    // Winse:13699 and X5:174038
    // Remove Dot stuffing based on the metabase key.
    // Default behavior is that pickup directory messages are dot stuffed.
    // If the metabase key DisablePickupDotStuff is set then the pickup directory
    // messages should not be dot stuffed.
    //
    
    if( !SetDotStuffingOnWrites( hDest, !m_pInstance->DisablePickupDotStuff(), TRUE ) )
    {
        ErrorTrace((LPARAM)this, "SetDotStuffingonWrites failed" );
        goto RetryPickup;
    }
    
    // Spit a Received: line to the spooled file
    GetArpaDate(szDateBuf);
    GetLocalTime(&SysTime);

    // Allocate the needed line buffer
    szLineBuffer = pGetLineBuffer(NULL, &dwLineBufferSize);
    if (!szLineBuffer)
    {
        // Schedule pickup mail for retry ...
        ErrorTrace((LPARAM)this, "Unable to allocate line buffer (%u)", GetLastError());
        goto RetryPickup;
    }

    DebugTrace((LPARAM)this, "Allocated line buffer at %p, %u bytes", szLineBuffer, dwLineBufferSize);

    // Set up the line pointers
    szLine = szLineBuffer;
    dwMaxLineSize = dwLineBufferSize;

    // Prefetch a buffer-full of text
    dwBufferSize = PRIVATE_OPTIMAL_BUFFER_SIZE;
    if (!pFetchFileBuffer(hSource, acReadBuffer, &dwBufferSize))
    {
        // Schedule pickup mail for retry ...
        ErrorTrace((LPARAM)this, "Retrying because cannot fetch file buffer (%u)",GetLastError());
        goto RetryPickup;
    }

    m_pInstance->LockGenCrit();
    wsprintf( szScratch,
              "Received: from mail pickup service by %s with Microsoft SMTPSVC;\r\n\t %s, %s\r\n",
              QuerySmtpInstance()->GetFQDomainName(),
              Daynames[SysTime.wDayOfWeek],
              szDateBuf);
    m_pInstance->UnLockGenCrit();    

    //We will copy out to the temp out buffer
    //NK** : This is a safe assumption that this will not result in IO
#if 0
    if ((SetFilePointer(hDest, 0, NULL, FILE_BEGIN) == 0xffffffff) ||
        !WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
#else
    if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
#endif
        goto RetryPickup;

    lpStart = acReadBuffer;
    while (1)
    {
        HeaderFlags = 0;

        // The X marker is used to mark the start of the 
        // non-X-headers if X-headers are used
        if (fIsStartOfFile)
            lpXMarker = lpStart;

        // This function will read a complete header line,
        // into a single NULL-terminated string.
        // Raid 181922 - The function no longer unfolds the line.
        if (!(lpStart = pReadNextLineFromBuffer( hSource, 
                                                 acReadBuffer, 
                                                 &dwBufferSize, 
                                                 lpStart, 
                                                 &szLine,
                                                 &dwMaxLineSize,
                                                 &szLineBuffer,
                                                 &dwLineBufferSize)))
        {
            // We failed a file operation, we will retry later
            goto RetryPickup;
        }

        // See if we are still in the header portion of the body
        if (!IsHeader(szLine))
            break;

        // Get the set of headers that we know about.
        ChompHeader(szLine, HeaderFlags);
        szValue = pGetValueFromHeader(szLine);
        if(!szValue)
        {
            continue;
        }


        // Strip away the CRLF at the end of the value string
        lOffset = lstrlen(szValue);
        if (lOffset >= 2)
        {
            if (((szValue[lOffset-2] == '\r') && (szValue[lOffset-1] == '\n')) ||
                ((szValue[lOffset-2] == '\n') && (szValue[lOffset-1] == '\r')))

                
                szValue[lOffset-2] = '\0';
        }

        hr = GetAndPersistRFC822Headers( szLine,
                                         szValue,
                                         pIMsg,
                                         fSeenRFC822FromAddress,
                                         fSeenRFC822ToAddress,
                                         fSeenRFC822BccAddress,
                                         fSeenRFC822CcAddress,
                                         fSeenRFC822Subject,
                                         fSeenRFC822SenderAddress,
                                         fSeenXPriority,
                                         fSeenContentType,
                                         fSetContentType );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot getAndPersistRFC822 headers(%x)", hr);
            goto RetryPickup;
        }
            

        // Check for leading X-Sender and X-Receiver header lines ...
        if (fIsStartOfFile)
        {
            if (HeaderFlags & H_X_SENDER)
            {
                // NOTE: if we have more than one sender, 
                // we always use the first one encountered

                // Yes, we found an X-header
                fIsXSenderRead = TRUE;
            }
            else if (HeaderFlags & H_X_RECEIVER)
            {
                // We don't check for sender here, since if we don't
                // have one, we will barf downstream

                // Yes, we found an X-header
                fAreXRcptsRead = TRUE;
            }
            else
            {
                // We are done with our X-headers, now we have
                // normal headers!
                fIsStartOfFile = FALSE;
            }
        }

        if (HeaderFlags & H_FROM)
        {
            fFromSeen = TRUE;
        }

        if (HeaderFlags & H_RCPT)
        {
            fRcptSeen = TRUE;
        }


        // Handle senders and recipients
        if (!fIsSenderSeen && ((HeaderFlags & H_X_SENDER) || (HeaderFlags & H_FROM)))
        {
            // Selectively do so
            if (fIsStartOfFile || !fIsXSenderRead)
            {
                char    *Address = NULL;
                DWORD    cbText = 0;
                DWORD   dwlen = strlen(szValue);
                _ASSERT(dwlen < 512 );

                Sender = CAddr::CreateAddress (szValue, FROMADDR);
                if (Sender)
                {
                    Address = Sender->GetAddress();
                    if(!Sender->IsDomainOffset() && !ISNULLADDRESS(Address))
                    {
                        CAddr * TempAddress = NULL;
                        TempAddress = QuerySmtpInstance()->AppendLocalDomain (Sender);
                        delete Sender;
                        if (TempAddress)
                        {
                            Sender = TempAddress;
                            Address = Sender->GetAddress();
                            TempAddress = NULL;
                        }
                        else
                        {
                            ErrorTrace((LPARAM) this,"Retrying because cannot to append local domain (%u)",GetLastError());
                            goto RetryPickup;
                        }
                    }

                    // Set the size of the FromName so that we can
                    // read it out of the queue file if we need it.
                    //cbText = lstrlen(Address) + 1;
                    //MailQEntry->SetFromNameSize (cbText);
                    //MailQEntry->SetSenderToStream(Address);
                    hr = pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, Address);
                    fIsSenderSeen = TRUE;
                }
                else
                {
                    // Undo the flag
                    if (fIsXSenderRead)
                        fIsXSenderRead = FALSE;

                    // If the sender is not invalid, it is likely to be a
                    // resource constraint, so we go and retry it
                    if (GetLastError() != ERROR_INVALID_DATA)
                    {
                        ErrorTrace((LPARAM)this, "Retrying because cannot allocate sender (%u)", GetLastError());
                        goto RetryPickup;
                    }
                }
            }
        }
        else if ((HeaderFlags & H_X_RECEIVER) || (HeaderFlags & H_RCPT))
        {
            // Selectively do so
            if (fIsStartOfFile || !fAreXRcptsRead)
            {
                DebugTrace((LPARAM)szLine, "To: line read <%s>", szValue);

                if (!CreateToList(szValue, pIMsgRecips, pIMsg))
                {
                    // If we're out of memory, we retry.
                    // If it is an invalid address, we remember the fact and
                    // remember to throw a copy into badmail
                    if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
                    {
                        ErrorTrace((LPARAM)this, "Retrying because cannot allocate recipient (%u)", GetLastError());
                        goto RetryPickup;
                    }
                    else
                        fInvalidAddresses = TRUE;
                }

                if (fIsStartOfFile)
                {
                    // X-headers!
                    lpXMarker = lpStart;
                }
            }
        }
        else if (HeaderFlags & H_MID)
        {
            // Message-ID already exists
            fMessageIdExists = TRUE;
            hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID , szValue );
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of IMMPID_MP_RFC822_MSG_ID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
            
        }
        else if (HeaderFlags & H_DATE)
        {
            // Date line already exists
            fDateExists = TRUE;
        }
        //      10/15/98 - MikeSwa Added supersedes functionality
        else if (HeaderFlags & H_X_MSGGUID)
        {
            hr = pIMsg->PutStringA(IMMPID_MP_MSG_GUID, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of MSG_GUID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
        else if (HeaderFlags & H_X_SUPERSEDES_MSGGUID)
        {
            hr = pIMsg->PutStringA(IMMPID_MP_SUPERSEDES_MSG_GUID, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of SUPERSEDES_MSG_GUID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
        else if( HeaderFlags & H_X_ORIGINAL_ARRIVAL_TIME )
        {
            fXOriginalArrivalTime = TRUE;
            hr = pIMsg->PutStringA(IMMPID_MP_ORIGINAL_ARRIVAL_TIME, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of ORIGINAL_ARRIVAL_TIME failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
            

        // If this is an ordinary header, we will dump this to 
        // the spooled file
        if (!fIsStartOfFile)
        {
            // Non-x-header; dump the line!
            lstrcat(szLine, acCrLf);
            if (!WriteToSpooledFile(hDest, szLine, DestWriteOffset))
            {
                ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
                goto RetryPickup;
            }
        }
    }

    hr = pIMsg->PutStringA(IMMPID_MP_HELO_DOMAIN, m_pInstance->GetDefaultDomain());
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString(helo domain) failed (%x)", hr);
        goto RetryPickup;

    }

    hr = pIMsg->PutStringA(IMMPID_MP_CONNECTION_IP_ADDRESS, DIRNOT_IP_ADDRESS);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString(IP address) failed (%x)", hr);
        goto RetryPickup;

    }

    hr = SetAvailableMailMsgProperties( pIMsg );
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString( for all available props) failed (%x)", hr);
        goto RetryPickup;

    }
    
    wsprintf( szScratch,
              "%s, %s",
              Daynames[SysTime.wDayOfWeek],
              szDateBuf);

    

    hr = pIMsg->PutStringA(IMMPID_MP_ARRIVAL_TIME, szScratch);
    if( FAILED( hr ) )
    {
        ErrorTrace((LPARAM)this,"Retrying because cannot putString IMPPID_MP_ARRIVAL_TIME (%x)", hr);
        goto RetryPickup;
    }


    // Now, before we go on and waste time on copying the rest of the message, etc.
    // we want to make sure we saw the sender and at least one valid recipient.
    // If not, we will just move the message to bad mail and be done with it.

    hr = pIMsgRecips->Count(&dwTotalRecips);
    if (!fIsSenderSeen || FAILED(hr) || (dwTotalRecips == 0))
    {
        // If no recipients but sender is seen, we must not leak the sender
        // object
        if (fIsSenderSeen)
        {
            delete Sender;
            Sender = NULL;
        }

        _VERIFY( pFreeLineBuffer(szLineBuffer) );
        szLineBuffer = NULL;
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }

        if(FAILED(hr))
        {
            goto RetryPickup;
        }
        else
        {
            // No choice but move to bad mail directory
            if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir()) )
            {
                if (!DeleteFile(szPickupFilePath))
                {
                    DWORD dwError = GetLastError();
                    ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
                }
            }
            goto RetryPickup;
        }
    }

    hr = pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, dwTotalRecips );
    if( FAILED( hr ) )
    {
        ErrorTrace((LPARAM)this,"Retrying because cannot putDWORD IMPPID_MP_NUM_RECIPIENTS (%x)", hr);
        goto RetryPickup;
    }
        



    // if we did not read a From Line, create a From: line from the xSender.
    // if we did not read a To, CC, BCC line, create a To: line from the xReceiver.
    if (!fFromSeen)
    {
        char    *Address = NULL;
        char    szUserName[MAX_INTERNET_NAME + 5];

        Address = Sender->GetAddress();
        
        if (!Address)
        {
            _VERIFY( pFreeLineBuffer(szLineBuffer) );
            szLineBuffer = NULL;
            if (hSource != INVALID_HANDLE_VALUE)
            {
                _VERIFY( CloseHandle(hSource) );
                hSource = INVALID_HANDLE_VALUE;
            }

            // No choice but move to bad mail directory
            if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir()) )
            {
                if (!DeleteFile(szPickupFilePath))
                {
                    DWORD dwError = GetLastError();
                    ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
                }
            }
            goto RetryPickup;
        }

        wsprintf(szUserName, "From: %s\r\n", Address);
        
        if (!WriteToSpooledFile(hDest, szUserName, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this,"Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }


    if (!fRcptSeen)
    {
        //
        // fix for bug: 78275
        // add an emty Bcc line:
        //
        static char *    endRcpt = "Bcc:\r\n";

        if (!WriteToSpooledFile(hDest, endRcpt, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }    
    }


    if (fIsSenderSeen)
    {                    
        delete Sender;
    }




    // We still have to dump the current line to the spool
    // file, then we copy the rest over.
    // Since we use buffered read, the current file position
    // really doesn't mean much. So we calculate how many bytes
    // we have to rewind
    dwBytesToRewind = dwBufferSize - (DWORD)(lpStart - acReadBuffer);

    // Negative, since we are going backwards
    _ASSERT(dwBytesToRewind <= PRIVATE_OPTIMAL_BUFFER_SIZE);
    lOffset = -(long)dwBytesToRewind;
    if (SetFilePointer(hSource, lOffset, NULL, FILE_CURRENT) 
            == 0xffffffff) 
    {
        ErrorTrace((LPARAM)this, 
                        "Retrying because cannot move file pointer (%u)", 
                        GetLastError());
        goto RetryPickup;
    }

    // See if we have to add a Date: or Message-ID: line
    if (!fMessageIdExists)
    {
        char    MessageId[MAX_PATH];

        MessageId[0] = '\0';

        GenerateMessageId (MessageId, sizeof(MessageId));
        
        m_pInstance->LockGenCrit();
        wsprintf( szMsgId, "<%s%8.8x@%s>", MessageId, GetIncreasingMsgId(),QuerySmtpInstance()->GetFQDomainName());
        m_pInstance->UnLockGenCrit();
        
        wsprintf(szScratch, "Message-ID: %s\r\n",szMsgId );
                

        hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, szMsgId );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because Put string of IMMPID_MP_RFC822 failed (%x)", hr );
            goto RetryPickup;
        }
            

        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    //
    // see if we have to add Original Arrival time
    //
    
    if (!fXOriginalArrivalTime )
    {
        char    szOriginalArrivalTime[64];

        szOriginalArrivalTime[0] = '\0';

        GetSysAndFileTimeAsString( szOriginalArrivalTime );
        
        wsprintf(szScratch, "X-OriginalArrivalTime: %s\r\n",szOriginalArrivalTime );
                

        hr = pIMsg->PutStringA( IMMPID_MP_ORIGINAL_ARRIVAL_TIME, szOriginalArrivalTime );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because Put string of IMMPID_MP_ORIGINAL_ARRIVAL_TIME failed (%x)", hr );
            goto RetryPickup;
        }
            

        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    //
    // see if we have to add the date
    //
    
    if (!fDateExists)
    {
        lstrcpy(szScratch, "Date: ");
        lstrcat(szScratch, szDateBuf);
        lstrcat(szScratch, acCrLf);
        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    // Write out the currently buffered line, then copy the 
    // pickup file to the spooler
    if (!WriteToSpooledFile(hDest, szLine, DestWriteOffset) ||
        !CopyRestOfMessage(hSource, hDest, DestWriteOffset))
    {
        ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
        goto RetryPickup;
    }

    // We will no longer read headers at this point, so we free our
    // line buffer here ...
    DebugTrace((LPARAM)this, "Freeing line buffer at %p, %u bytes", szLineBuffer, dwLineBufferSize);
    _VERIFY( pFreeLineBuffer(szLineBuffer) );
    szLineBuffer = NULL;

    // Get the size of the spooled file before we close it
    DWORD dwFileSizeHigh;
    dwPickupFileSize = GetFileSizeFromContext(hDest, &dwFileSizeHigh);
    _ASSERT(dwFileSizeHigh == 0); // why??
    
    if (dwPickupFileSize == 0xffffffff)
    {
        dwPickupFileSize = 0;
    }

    pIMsg->PutDWORD( IMMPID_MP_MSG_SIZE_HINT, dwPickupFileSize );
    

    // Now, we see if there are any invalid addresses; if so, we will 
    // throw a copy og the original message into the badmail directory
    if (fInvalidAddresses)
    {
        // Close the pickup file
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }

        // Move it to badmail instead of deleting it
        DebugTrace((LPARAM)this, "Saving a copy in badmail due to bad recipients");
    
        // No choice but move to bad mail directory
        if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir() ) )
        {
            if (!DeleteFile(szPickupFilePath))
            {
                DWORD dwError = GetLastError();
                ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
            }
        }
            
    }
    else
    {
        // Delete the file
        if (!DeleteFile(szPickupFilePath))
        {
            DWORD dwError = GetLastError();
            ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
        }
        // Close the pickup file
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }
    }

    //
    // put the file into the local queue. 
    //

    pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

    hr = pIMsgOrigRecips->WriteList(pIMsgRecips);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsgOrigRecips->WriteList failed (%x)", hr);
        goto RetryPickup;
    }

    
    //
    // we scan for dots & strip them away while storing, so set these two properties
    // so we can get the dot stuffed context while sending it out.
    //
    
    pIMsg->PutDWORD( IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF, TRUE );
    pIMsg->PutDWORD( IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, TRUE );

    CompleteDotStuffingOnWrites( hDest, TRUE );

    hr = pIMsg->Commit(NULL);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->Commit(NULL) failed (%u)", 
                        hr);
        goto RetryPickup;
    } 

    pIMsgRecips->Release();
    pIMsgOrigRecips->Release();
    pIMsgRecips = NULL;
    pIMsgOrigRecips = NULL;

    if(m_pInstance->InsertIntoQueue(pIMsg))
    {
        DeleteIMsg = FALSE;
        
        // Up the msgs received and avg bytes per message counters
        ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (dwPickupFileSize));
        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsForwarded);
    }

RetryPickup:

    IMailMsgQueueMgmt * pMgmt = NULL;

    if(pBindInterface)
    {
        pBindInterface->Release();
    }

    if(pIMsgRecips)
    {
        pIMsgRecips->Release();
        pIMsgRecips = NULL;
    }

    if(pIMsgOrigRecips)
    {
        pIMsgOrigRecips->Release();
        pIMsgOrigRecips = NULL;
    }

    if(DeleteIMsg)
    {
        hr = pIMsg->QueryInterface(IID_IMailMsgQueueMgmt, (void **)&pMgmt);
        if(!FAILED(hr))
        {
            pMgmt->Delete(NULL);
            pMgmt->Release();
        }
    }

    if(pIMsg)
    {
        pIMsg->Release();
        pIMsg = NULL;
    }

    // Retry message
    if (szLineBuffer)
    {
        _VERIFY( pFreeLineBuffer(szLineBuffer) );
        szLineBuffer = NULL;
    }

    if (hSource != INVALID_HANDLE_VALUE)
    {
        _VERIFY( CloseHandle( hSource ) );
        hSource = INVALID_HANDLE_VALUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_DIRNOT::GetAndPersistRFC822Headers(
    char* InputLine,
    char* pszValueBuf,
    IMailMsgProperties* pIMsg,
    BOOL & fSeenRFC822FromAddress,
    BOOL & fSeenRFC822ToAddress,
    BOOL & fSeenRFC822BccAddress,
    BOOL & fSeenRFC822CcAddress,
    BOOL & fSeenRFC822Subject,
    BOOL & fSeenRFC822SenderAddress,
    BOOL & fSeenXPriority,
    BOOL & fSeenContentType,
    BOOL & fSetContentType
    )
{
    HRESULT hr = S_OK;
    
    //
    // get the Subject:  & persist it
    //
    
    if( !fSeenRFC822Subject &&
        ( !strncasecmp( InputLine, "Subject:", strlen("Subject:") ) ||
          !strncasecmp( InputLine, "Subject :", strlen("Subject :") ) ) )
    {
        fSeenRFC822Subject = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_SUBJECT, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the To: address & persist it
    //
    
    if( !fSeenRFC822ToAddress &&
        ( !strncasecmp( InputLine, "To:", strlen("To:") ) ||
          !strncasecmp( InputLine, "To :", strlen("To :") ) ) )
    {
        fSeenRFC822ToAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_TO_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the Cc: address & persist it
    //
    
    if( !fSeenRFC822CcAddress &&
        ( !strncasecmp( InputLine, "Cc:", strlen("Cc:") ) ||
          !strncasecmp( InputLine, "Cc :", strlen("Cc :") ) ) )
    {
        fSeenRFC822CcAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_CC_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the Bcc: address & persist it
    //
    
    if( !fSeenRFC822BccAddress &&
        ( !strncasecmp( InputLine, "Bcc:", strlen("Bcc:") ) ||
          !strncasecmp( InputLine, "Bcc :", strlen("Bcc :") ) ) )
    {
        fSeenRFC822BccAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_BCC_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the From: address & persist it
    //
    
    if( !fSeenRFC822FromAddress &&
        ( !strncasecmp( InputLine, "From:", strlen("From:") ) ||
          !strncasecmp( InputLine, "From :", strlen("From :") ) ) )
    {
        fSeenRFC822FromAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }

        }

        char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
        char *pszDomainOffset;
        DWORD cAddr;
        if (CAddr::ExtractCleanEmailName(szSmtpFromAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
            if (FAILED(hr = pIMsg->PutStringA(IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress))) {
                return hr;
            }
        }
    }

    if( !fSeenRFC822SenderAddress &&
        ( !strncasecmp( InputLine, "Sender:", strlen("Sender:") ) ||
          !strncasecmp( InputLine, "Sender :", strlen("Sender :") ) ) )
    {
        fSeenRFC822SenderAddress = TRUE;
        
        if( pszValueBuf )
        {
            char szSmtpSenderAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpSenderAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS, szSmtpSenderAddress))) {
                    return hr;
                }
            }            
        }
    
    }

    //
    // get the X-Priority & persist it
    //
    
    if( !fSeenXPriority &&
        ( !strncasecmp( InputLine, "X-Priority:", strlen("X-Priority:") ) ||
          !strncasecmp( InputLine, "X-Priority :", strlen("X-Priority :") ) ) )
    {
        fSeenXPriority = TRUE;
        
        if( pszValueBuf )
        {
            DWORD dwPri = (DWORD)atoi( pszValueBuf );
            if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_X_PRIORITY, dwPri ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the content type & persist it
    //
    
    if( !fSeenContentType &&
        ( !strncasecmp( InputLine, "Content-Type:", strlen("Content-Type:") ) ||
          !strncasecmp( InputLine, "Content-Type :", strlen("Content-Type :") ) ) )
    {
        fSeenContentType = TRUE;
        fSetContentType = TRUE;
        DWORD dwContentType = 0;

        if( pszValueBuf )
        {
            if( !strncasecmp( pszValueBuf, "multipart/signed", strlen("multipart/signed") ) )
            {
                dwContentType = 1;
            }
            else if( !strncasecmp( pszValueBuf, "application/x-pkcs7-mime", strlen("application/x-pkcs7-mime") ) ||
                     !strncasecmp( pszValueBuf, "application/pkcs7-mime", strlen("application/pkcs7-mime") ) )
            {
                dwContentType = 2;
            }

            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_CONTENT_TYPE, pszValueBuf ) ) )
            {
                return( hr );
            }
        }

        if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, dwContentType ) ) )
        {
            return( hr );
        }
    }

    if( !fSetContentType )
    {
        fSetContentType =   TRUE;
        
        if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, 0 ) ) )
        {
            return( hr );
        }
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_DIRNOT::SetAvailableMailMsgProperties( IMailMsgProperties *pIMsg )
{
    
    //set IPaddress that is already available
    HRESULT hr = S_OK;
    
    hr = pIMsg->PutStringA(IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS, DIRNOT_IP_ADDRESS);
    if(FAILED(hr))
    {
        return( hr );
    }
    
    hr = pIMsg->PutStringA(IMMPID_MP_SERVER_NAME, g_ComputerName);
    if(FAILED(hr))
    {
        return( hr );
    }
    
    hr = pIMsg->PutStringA(IMMPID_MP_SERVER_VERSION, g_VersionString);
    if(FAILED(hr))
    {
        return( hr );
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
void SMTP_DIRNOT::CreateLocalDeliveryThread (void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_DIRNOT::CreateLocalDeliveryThread");
    //
    // Add a delivery thread with the ATQPorts Overlapped structure. For the dir notifications, 
    // our overlapped structure is used... this is how we tell the difference in Process Client.
    //
    IncPendingIoCount();
    if(!AtqPostCompletionStatus(QueryAtqContext(), 50))
    {
        DecPendingIoCount();
        ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
    }
    
    TraceFunctLeaveEx((LPARAM)this);
}



//////////////////////////////////////////////////////////////////////////////
BOOL SMTP_DIRNOT::PendDirChangeNotification (void)
{
    CBuffer * pBuffer = NULL;
    DWORD nBytes = 0;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::PendDirChangeNotification" );

    _ASSERT(m_pInstance != NULL);
    _ASSERT(m_hDir != INVALID_HANDLE_VALUE);

    //get a new buffer
    pBuffer = new CBuffer();
    if(pBuffer == NULL)
    {
        ErrorTrace((LPARAM) this, "pBuffer = new CBuffer()failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if(pBuffer->GetData() == NULL)
    {
        ErrorTrace((LPARAM) this, "pBuffer = new CBuffer()->GetData failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
        delete pBuffer;
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    QuerySmtpInstance()->IncCBufferObjs ();

    IncPendingIoCount();
    IncDirChangeIoCount();

    if(!AtqReadDirChanges(QueryAtqContext(),pBuffer->GetData(),QuerySmtpInstance()->GetDirBufferSize(),
                            FALSE,FILE_NOTIFY_CHANGE_FILE_NAME,
                            (OVERLAPPED *) &pBuffer->m_Overlapped.SeoOverlapped.Overlapped))
    {
        Error = GetLastError();
        ErrorTrace((LPARAM) this, "ReadDirectoryChangesW failed . err: %u", Error);
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
    
        //decrement over all I/O count
        DecPendingIoCount();
        DecDirChangeIoCount();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;

    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_DIRNOT::ProcessDirNotification( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    CHAR FileName[MAX_PATH + 1];
    PFILE_NOTIFY_INFORMATION Info = NULL;
    DWORD FileNameLength = 0;
    DWORD ServerState;
    CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "SMTP_DIRNOT::ProcessDirNotification" );

    _ASSERT(m_pInstance != NULL);

    //
    // pend a new notification to replace the one we are currently using... there will still be
    // a couple outstanding unless we are shutting down.
    //

    if (!PendDirChangeNotification())
        ErrorTrace((LPARAM)this, "PendDirChangeNotification() failed");

    if (!QuerySmtpInstance()->GetAcceptConnBool())
    {
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }


    if(dwCompletionStatus != NO_ERROR)
    {
        ErrorTrace((LPARAM) this, "SMTP_DIRNOT::ProcessDirNotification received error %d", dwCompletionStatus);
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    ServerState = QuerySmtpInstance()->QueryServerState( );

    //if we are not running, just delete
    if( (ServerState == MD_SERVER_STATE_STOPPED ) || (ServerState == MD_SERVER_STATE_INVALID))
    {
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }


    if(InputBufferLen)
    {
        Info = (PFILE_NOTIFY_INFORMATION) pBuffer->GetData();
        while (1)
        {
            //we only care about files added to this
            //directory
            //if(Info->Action == FILE_ACTION_MODIFIED)
            if(Info->Action == FILE_ACTION_ADDED)
            {
                IMailMsgProperties *pIMsg = NULL;

                //convert the name to ascii
                FileNameLength = WideCharToMultiByte(CP_ACP, 0, &Info->FileName[0], Info->FileNameLength,
                                                    FileName, sizeof(FileName), NULL, NULL);
                FileName[FileNameLength/2] = '\0';
                DebugTrace((LPARAM) this, "File %s was detected", FileName);

                hr = CoCreateInstance(CLSID_MsgImp, NULL, CLSCTX_INPROC_SERVER,
                                                IID_IMailMsgProperties, (LPVOID *)&pIMsg);

                // Next, check if we are over the inbound cutoff limit. If so, we will release the message
                // and not proceed.
                if (SUCCEEDED(hr))
                {
                    DWORD    dwCreationFlags;
                    hr = pIMsg->GetDWORD(
                                IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                                &dwCreationFlags);
                    if (FAILED(hr) || 
                        (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                    {
                        // If we fail to get this property of if the inbound cutoff
                        // exceeded flag is set, discard the message and return failure
                        if (SUCCEEDED(hr))
                        {
                            DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                            hr = E_OUTOFMEMORY;
                        }
                        pIMsg->Release();
                        pIMsg = NULL;
                    }
                }

                if( (pIMsg == NULL) || FAILED(hr))
                {
                    // We are out of resources, there is absolutely nothing
                    // we can do: can't NDR, can't retry ...
                    // Just go on with the next mail ...
                    ErrorTrace((LPARAM) this, "new  MAILQ_ENTRY failed for file: %s",
                                FileName);

                    // will be mail left in pickup.  queue a findfirst to take care of it.
                    SetDelayedFindNotification(TRUE);
                    IncPendingIoCount ();
                    AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, TIMEOUT_INTERVAL);    //retry after a while
                    ErrorTrace((LPARAM)this, "Failed to create message will retry later.");
                    goto Exit;
                }
                else
                {
                    pIMsg->PutStringA(IMMPID_MP_PICKUP_FILE_NAME, FileName);
                    if(!ProcessFile(pIMsg))
                    {
                        // will be mail left in pickup.  queue a findfirst to take care of it.
                        SetDelayedFindNotification(TRUE);
                    }
                }
            }

            if(Info->NextEntryOffset == 0)
            {
                DebugTrace((LPARAM) this, "No more entries in this notification");
                break;
            }

            //get the next entry in the list to process
            Info = (PFILE_NOTIFY_INFORMATION)( (PCHAR)Info + Info->NextEntryOffset);
        }

        if (GetDelayedFindNotification())
        {
            DebugTrace((LPARAM) this, "Doing FindFirstFile because max mail objects was hit in notification");
            DoFindFirstFile();
        }

    }
    else
    {
        DebugTrace((LPARAM) this, "Doing FindFirstFile because InputBufferLen == 0");
        DoFindFirstFile();
    }

Exit:
    if(pBuffer)
    {
        delete pBuffer;
        pBuffer = NULL;
        QuerySmtpInstance()->DecCBufferObjs ();
    }


    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}


/*++

    Name :
        SMTP_DIRNOT::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                  Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_DIRNOT::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    PFILE_NOTIFY_INFORMATION Info = NULL;
    DWORD FileNameLength = 0;
    BOOL fRet;
    PSMTP_IIS_SERVICE        pService;


    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::ProcessClient" );

    _ASSERT(m_pInstance != NULL);

    //
    // increment the number of threads processing this client
    //
    IncThreadCount();

    if(!QuerySmtpInstance()->IsShuttingDown())
    {

        //
        //    dhowell - if a gilbraltar thread, and size > 0 then it is a delivery thread we have created
        // the SMTP_CONNECTION code will ensure that only the correct number run.
        //

        if (lpo == &(QueryAtqContext()->Overlapped) || dwCompletionStatus == ERROR_SEM_TIMEOUT)
        {
            if(InputBufferLen == 0) 
            {
                DebugTrace( (LPARAM)this,"FindFirst called internally.");

                //reset timeout to infinity in anticipation of having memory; DoFindFirstFile
                //will set it to TIMEOUT_INTERVAL if it runs out of memory
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, INFINITE);

                DoFindFirstFile();

                //since this was a timeout completion, the atq context has been "disabled" from
                //further IO processing. Restart the timeout processing.
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_RESUME_IO, 1);
            }
        }
        //
        // A legit notification . 
        //
        else
        {
            DecDirChangeIoCount();
            DebugTrace( (LPARAM)this,"ReadDirectoryChange Notification");
            fRet = ProcessDirNotification(InputBufferLen, dwCompletionStatus, lpo);
        }
    }
    else
    {
        if (lpo != &(QueryAtqContext()->Overlapped))
        {
            //just cleanup up shop if we are shutting down.
            CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;
            delete pBuffer;
            pBuffer = NULL;
            QuerySmtpInstance()->DecCBufferObjs ();
            DecDirChangeIoCount();
        }

        //
        // only applies to shutdown case
        // these will not be decremented via SMTP_CONNECTION::ProcessMailQIO so we have to do it here.
        //
        if ((lpo == &(QueryAtqContext()->Overlapped)) && InputBufferLen)
        {
            pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

            QuerySmtpInstance()->DecRoutingThreads();
            pService->DecSystemRoutingThreads();
        }
    }

    //
    // decrement the number of threads processing this client
    //
    DecThreadCount();

    if ( DecPendingIoCount() == 0 )
    {
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() shutting down - Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() shutting down - ActiveThreads: %d",m_cActiveThreads);
        _ASSERT( m_cActiveThreads == 0 );
        fRet = FALSE;
    }
    else
    {
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() - Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() - ActiveThreads: %d",m_cActiveThreads);
        fRet = TRUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++
    Name :
        ReadDirectoryCompletion

    Description:

        Handles a completed I/O for ReadDirectoryChanges

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID SMTP_DIRNOT::ReadDirectoryCompletion(PVOID pvContext, DWORD cbWritten, 
                        DWORD dwCompletionStatus, OVERLAPPED * lpo)
{
    BOOL WasProcessed;
    SMTP_DIRNOT *pCC = (SMTP_DIRNOT *) pvContext;

    TraceFunctEnterEx((LPARAM) pCC, "SMTP_DIRNOT::ReadDirectoryCompletion");

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    if (dwCompletionStatus != NO_ERROR && dwCompletionStatus != ERROR_SEM_TIMEOUT)
        ErrorTrace((LPARAM)pCC, "Error in Atq operation: %d\r\n", dwCompletionStatus);

    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
    if(!WasProcessed)
    {
        SetEvent(pCC->QuerySmtpInstance()->GetDirnotStopHandle());
    }

    TraceFunctLeaveEx((LPARAM) pCC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\dropdir.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "dropdir.hxx"

DWORD   g_dwDropFileCounter = 0;
CPool  CDropDir::m_Pool(DROPDIR_SIG);

//////////////////////////////////////////////////////////////////////////////
VOID
DropDirWriteCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    )
{
    DECL_TRACE((LPARAM) 0xC0DEC0DE, "DropDirWriteCompletion");
    BOOL WasProcessed = TRUE;
    CDropDir *pCC = (CDropDir *) pvContext;

    _ASSERT(pCC);

    pCC->SetHr( pCC->OnIoWriteCompletion(cbWritten, dwCompletionStatus, lpo) );

    SAFE_RELEASE( pCC );    
}

//////////////////////////////////////////////////////////////////////////////
VOID
DropDirReadCompletion(
    PFIO_CONTEXT   pContext,
    PFH_OVERLAPPED lpo,
    DWORD          cbRead,
    DWORD          dwCompletionStatus
    )
{
    DECL_TRACE((LPARAM) 0xC0DEC0DE, "DropDirReadCompletion");
    BOOL WasProcessed = TRUE;
    DROPDIR_READ_OVERLAPPED *p = (DROPDIR_READ_OVERLAPPED *) lpo;
    CDropDir *pCC = (CDropDir*) p->ThisPtr;

    _ASSERT(pCC);

    pCC->SetHr( pCC->OnIoReadCompletion(cbRead, dwCompletionStatus, (LPOVERLAPPED)lpo) );

    SAFE_RELEASE( pCC );    
}

//////////////////////////////////////////////////////////////////////////////
CDropDir::CDropDir()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CDropDir");

    m_dwSig = DROPDIR_SIG;
    m_cRef = 1;
    m_NumRcpts = 0;
    m_hDrop   = INVALID_HANDLE_VALUE;
    m_hMail   = NULL;
    m_AdvContext = NULL;
    m_rgRcptIndexList = NULL;
    m_pIMsg = NULL;
    m_pBindInterface = NULL;
    m_pAtqContext = NULL;
    CopyMemory( m_acCrLfDotCrLf, "\r\n.\r\n", 5 );
    ZeroMemory( m_acLastBytes, 5 );
    m_pIMsgRecips = NULL;
    m_hr = S_OK;
    m_cbWriteOffset = 0;
    m_cbReadOffset = 0;
    m_cbMsgWritten = 0;
    m_idxRecips = 0;
    ZeroMemory( &m_WriteOverlapped, sizeof( m_WriteOverlapped ) );
    ZeroMemory( &m_ReadOverlapped, sizeof( m_ReadOverlapped ) );
    m_szDropDir[0] = '\0';
    m_pISMTPConnection = NULL;
    m_ReadState = DROPDIR_READ_NULL;
    m_WriteState = DROPDIR_WRITE_NULL;
    m_pParentInst = NULL;
}

//////////////////////////////////////////////////////////////////////////////

CDropDir::~CDropDir()
{
    DECL_TRACE((LPARAM) this, "CDropDir::~CDropDir");
    
    SAFE_RELEASE( m_pIMsgRecips );
    
    if(m_pBindInterface)
    {
        m_pBindInterface->ReleaseContext();
        SAFE_RELEASE(m_pBindInterface);
    }
    
    m_MsgAck.pIMailMsgProperties = m_pIMsg;
    m_MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
    
    if(SUCCEEDED(m_hr))
    {
        m_MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
    }
    else
    {
        m_MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;      
    }
    
    m_MsgAck.dwStatusCode = 0;
    m_pISMTPConnection->AckMessage(&m_MsgAck);
    SAFE_RELEASE(m_pIMsg);

    if(SUCCEEDED(m_hr))
    {
        BUMP_COUNTER( m_pParentInst, DirectoryDrops);
    }

    if(SUCCEEDED(m_hr))
    {
        m_pISMTPConnection->AckConnection(CONNECTION_STATUS_OK);
    }
    else
    {
        DeleteFile(m_szDropFile);
        SetLastError( 0x0000FFFF & m_hr );
        m_pISMTPConnection->AckConnection(CONNECTION_STATUS_FAILED);
    }

    PATQ_CONTEXT pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       if(m_hDrop != INVALID_HANDLE_VALUE)
           AtqCloseFileHandle( pAtqContext );
       AtqFreeContext( pAtqContext, TRUE );
    }
    
    //
    // Now get the next message on this connection and
    // copy it to drop directory.
    //

    if (m_szDropDir[0])
        AsyncCopyMailToDropDir( m_pISMTPConnection, m_szDropDir, m_pParentInst );

    SAFE_RELEASE( m_pISMTPConnection );
    
    m_dwSig = DROPDIR_SIG_FREE;
}


//---[ CDropDir::CopyMailToDropDir ]-------------------------------------------
//
//
//  Description: 
//
//      Entry point to the Async writing to the mail file. When this is called
//      it sets up a series of alternating reads and writes (read from the queue
//      and write to the mail file). The (rough description of the) algorithm is 
//      as follows:
//  
//          WriteHeaders()
//          Post Async Read from MailFile
//          return
//
//          Read Completion function()
//          Post Async Write of Data to DropDir
//          return
//
//          Write Completion function()
//          Post Async Read from MailFile
//          return
//
//      Called by
//          AsyncCopyMailToDropDir()
//
//  Parameters:
//
//  Returns:
//
//  History:
//      Created by PGOPI
//      3/25/99 - MikeSwa modified for checkin
//
//-----------------------------------------------------------------------------
HRESULT CDropDir::CopyMailToDropDir(
    ISMTPConnection      *pISMTPConnection,
    const char           *DropDirectory,
    IMailMsgProperties   *pIMsg,
    PVOID                 AdvContext,
    DWORD                 NumRcpts,
    DWORD                *rgRcptIndexList,
    SMTP_SERVER_INSTANCE *pParentInst)
{
    DECL_TRACE((LPARAM) this, "CDropDir::CopyMailToDropDir");
    HRESULT hr = S_OK;
    
    m_pISMTPConnection = pISMTPConnection;
    SAFE_ADDREF( m_pISMTPConnection );
    m_pIMsg = pIMsg;
    SAFE_ADDREF( m_pIMsg );
    m_pParentInst = pParentInst;
    m_AdvContext = AdvContext;
    m_NumRcpts = NumRcpts;
    m_rgRcptIndexList = rgRcptIndexList;

    if (!DropDirectory)
    {
        hr = E_INVALIDARG;
        return ( hr );
    }

    //Copy drop directory now... so we have a copy in the destructor
    //even if this message cannot be dropped
    lstrcpy(m_szDropDir, DropDirectory);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);

    if(FAILED(hr))
    {
        ErrorTrace( (LPARAM)this, "m_pIMsg->QueryInterface for IID_IMailMsgBind return hr = 0x%x", hr );
        return( hr );
    }
    
    hr = m_pBindInterface->GetBinding(&m_hMail, NULL);
    
    if(FAILED(hr))
    {
        ErrorTrace( (LPARAM)this, "GetBinding return hr = 0x%x", hr );
        return( hr );
    }

    hr = m_pIMsg->QueryInterface( IID_IMailMsgRecipients, (PVOID *) &m_pIMsgRecips);

    if( FAILED( hr ) )
    {
        ErrorTrace( (LPARAM)this, "QueryInterface for IID_IMailMsgRecipients failed hr = 0x%x", hr );
        return( hr );
    }

    if( CheckIfAllRcptsHandled() )
    {
        return( S_OK );
    }

    
    DebugTrace((LPARAM)this, "Dropping file to: %s", DropDirectory);
    
    m_hDrop = CreateDropFile(DropDirectory);
    
    if (m_hDrop == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        ErrorTrace( (LPARAM)this, "Unable to create drop directory (%s) : 0x%x", DropDirectory, hr);
        return( hr );
    }

    if (!AtqAddAsyncHandle( &m_pAtqContext,
                            NULL,
                            (LPVOID) this,
                            DropDirWriteCompletion,
                            INFINITE,
                            m_hDrop))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        ErrorTrace((LPARAM)this, "Error 0x%x while adding async handle to ATQ", hr);
        return( hr );
    }

    // Output the x-headers

    if (FAILED( hr = CreateXHeaders() ) )
    {
        ErrorTrace( (LPARAM)this, " Error while creating x-headers hr = 0x%x", hr);
        return( hr );
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HANDLE CDropDir::CreateDropFile(const char * DropDir)
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    DWORD           dwStrLen;
    FILETIME        ftTime;
    DWORD           Error = 0;

    DECL_TRACE((LPARAM)this, "CDropDir::CreateDropFile");

    dwStrLen = lstrlen(DropDir);
    lstrcpy(m_szDropFile, DropDir); 

    do
    {
        GetSystemTimeAsFileTime(&ftTime);
        wsprintf(&m_szDropFile[dwStrLen],
                "%08x%08x%08x%s",
                ftTime.dwLowDateTime,
                ftTime.dwHighDateTime,
                InterlockedIncrement((PLONG)&g_dwDropFileCounter),
                ".eml");

        FileHandle = CreateFile(m_szDropFile,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
                                NULL);
        if (FileHandle != INVALID_HANDLE_VALUE)
                break;

        if((Error = GetLastError()) !=  ERROR_FILE_EXISTS)
        {
                FileHandle = INVALID_HANDLE_VALUE;
                ErrorTrace( (LPARAM)this, "CreateFile returns err = %u", Error );
                break;
        }

    } while( (FileHandle == INVALID_HANDLE_VALUE) && !m_pParentInst->IsShuttingDown());

    return (FileHandle);
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize
            )
{
    DECL_TRACE((LPARAM) this, "CDropDir::ReadFile");
    HRESULT hr = S_OK;

    _ASSERT(pBuffer != NULL);
    
    m_ReadOverlapped.Overlapped.Offset = LODWORD( m_cbReadOffset );
    m_ReadOverlapped.Overlapped.OffsetHigh = HIDWORD( m_cbReadOffset );
    m_ReadOverlapped.Overlapped.pfnCompletion = DropDirReadCompletion;
    m_ReadOverlapped.ThisPtr = (PVOID)this;

    AddRef();
    
    BOOL fRet = FIOReadFile( m_hMail,
                             pBuffer,            // Buffer
                             cbSize,             // BytesToRead
                             (PFH_OVERLAPPED)&m_ReadOverlapped) ;

    if(!fRet)
    {
        DWORD err = GetLastError();
        if( err != ERROR_IO_PENDING )
        {
            hr = HRESULT_FROM_WIN32( err );
            
            ErrorTrace( (LPARAM)this, "FIOReadFile return hr = 0x%x", hr );
        }
        
    }

    if( FAILED( hr ) )
    {
        Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize 
            )
{
    DECL_TRACE((LPARAM) this, "CDropDir::WriteFile");
    CDropDir *p = this;
    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);
    HRESULT hr = S_OK;

    m_WriteOverlapped.Offset = LODWORD( m_cbWriteOffset );
    m_WriteOverlapped.OffsetHigh = HIDWORD( m_cbWriteOffset );

    AddRef();

    BOOL fRet = AtqWriteFile( m_pAtqContext,      // Atq context
                              pBuffer,            // Buffer
                              cbSize,             // BytesToRead
                              (OVERLAPPED *) &m_WriteOverlapped) ;

    if(!fRet)
    {
        DWORD err = GetLastError();
        if( err != ERROR_IO_PENDING )
        {
            hr = HRESULT_FROM_WIN32( err );
            
            ErrorTrace( (LPARAM)this, "AtqWriteFile return hr = 0x%x", hr );
        }
        
    }

    if( FAILED( hr ) )
    {
        Release();
    }
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnIoWriteCompletion( DWORD cbSize, DWORD dwErr, OVERLAPPED *lpo )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnIoWriteCompletion");
    
    HRESULT hr = S_OK;

    if( dwErr != NO_ERROR )
    {
        ErrorTrace( (LPARAM)this, "OnIoWriteCompletion got err = %u", dwErr );
        return( HRESULT_FROM_WIN32( dwErr ) );
    }

    m_cbWriteOffset += cbSize;

    switch( m_ReadState )
    {
        case DROPDIR_READ_X_SENDER:
            _ASSERT(!"Invalid State READ_X_SENDER");
            hr = E_INVALIDARG;
            break;
        case DROPDIR_READ_X_RECEIVER:
            hr = CreateXRecvHeaders();
            break;
        case DROPDIR_READ_DATA:
            hr = OnCopyMessageWrite( cbSize);
            break;
        default:
            _ASSERT(!"INVALID read STATE");
            hr = E_INVALIDARG;
            ErrorTrace( (LPARAM)this, "Invalid ReadState" );
            break;
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnIoReadCompletion( DWORD cbSize, DWORD dwErr, OVERLAPPED *lpo )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnIoReadCompletion");
    HRESULT hr = S_OK;

    if( ( dwErr != NO_ERROR ) && ( dwErr != ERROR_HANDLE_EOF ) )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        ErrorTrace( (LPARAM)this, "OnIOReadCompletion got hr = 0x%x", hr );
    }
    else
    {
        m_cbReadOffset += cbSize;
        hr = OnCopyMessageRead( cbSize, dwErr );
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CreateXHeaders()
{

    DECL_TRACE(((LPARAM) this), "CDropDir::CreateXHeaders");
    HRESULT hr = S_OK;

    DebugTrace( (LPARAM)this, "Setting m_ReadState = DROPDIR_READ_X_SENDER" );

    m_ReadState = DROPDIR_READ_X_SENDER;

    strcpy( m_szBuffer, X_SENDER_HEADER );

    hr = m_pIMsg->GetStringA( IMMPID_MP_SENDER_ADDRESS_SMTP, MAX_INTERNET_NAME, &m_szBuffer[ sizeof(X_SENDER_HEADER) - 1] );

    if(SUCCEEDED(hr))
    {
        strcat( m_szBuffer, X_HEADER_EOLN);

        //
        // this WriteFile will complete async, so set the next read state.
        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.

        m_ReadState = DROPDIR_READ_X_RECEIVER;

        DebugTrace( (LPARAM)this, "Setting m_ReadState = DROPDIR_READ_X_RECEIVER" );
        //

        if( FAILED( hr = WriteFile( m_szBuffer, strlen( m_szBuffer ) ) ) )
        {
            ErrorTrace((LPARAM)this, "Error %d writing x-sender line %s", hr, m_szBuffer);
            
            return( hr );
        }
    }
    else
    {

        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        
        ErrorTrace((LPARAM)this, "Could not get Sender Address returning hr = 0x%x", hr);
        
        return( hr );
    }

    return( hr );


}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CreateXRecvHeaders()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CreateXRecvHeaders");
    HRESULT hr = S_OK;
    DWORD dwRecipientFlags = 0;
    BOOL fPendingWrite = FALSE;
    
    strcpy( m_szBuffer, X_RECEIVER_HEADER );

    while( m_idxRecips < m_NumRcpts )
    {    
        hr = m_pIMsgRecips->GetDWORD( m_rgRcptIndexList[m_idxRecips], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
        
        if( SUCCEEDED( hr ) )
        {
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                hr = m_pIMsgRecips->GetStringA( m_rgRcptIndexList[m_idxRecips],
                                                IMMPID_RP_ADDRESS_SMTP,
                                                MAX_INTERNET_NAME,
                                                &m_szBuffer[ sizeof(X_RECEIVER_HEADER) - 1 ]);
                if (SUCCEEDED(hr))
                {
                    strcat(m_szBuffer, X_HEADER_EOLN);
                
                    
                
                    // Make Sure that no class member variables are acessed after calling
                    // WriteFile or ReadFile as they complete async & there is no critical
                    // section protecting access.To do this trace through all paths
                    // thru which ReadFile and WriteFile are called and make sure no member
                    // variables are accessed.

                    m_idxRecips++;
                    
                    if(FAILED( hr = WriteFile(m_szBuffer, strlen(m_szBuffer) ) ) )
                                               
                    {
                        ErrorTrace( (LPARAM)this, "WriteFile return hr = 0x%x", hr );
                        return( hr );
                    }
                    fPendingWrite = TRUE;
                    break;
                }
                else
                {
                    ErrorTrace( (LPARAM)this, "GetStringA for IMMPID_RP_ADDRESS_SMTP returns hr = 0x%x", hr );
                    return( hr );
                }       
            }
            else
            {
                m_idxRecips++;
            }       
        }
        else
        {
            ErrorTrace( (LPARAM)this, "GetDWORD for IMMPID_RP_RECIPIENT_FLAGS returns hr = 0x%x", hr );
            return( hr );
        }
    }
    
    if( !fPendingWrite )
    {
        m_ReadState = DROPDIR_READ_DATA;
        m_WriteState = DROPDIR_WRITE_DATA;
        DebugTrace( (LPARAM)this, "Setting m_WriteState & m_ReadState to WRITE_DATA & READ_DATA respectively" );
        return( CopyMessage() );
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CopyMessage()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CopyMessage");

    // Make Sure that no class member variables are acessed after calling
    // WriteFile or ReadFile as they complete async & there is no critical
    // section protecting access.To do this trace through all paths
    // thru which ReadFile and WriteFile are called and make sure no member
    // variables are accessed.
    
    HRESULT hr = ReadFile( m_szBuffer, sizeof( m_szBuffer ) );

    if( hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ) )
    {
        m_WriteState = DROPDIR_WRITE_CRLF;
        
        DebugTrace( (LPARAM)this, "ReadFile returns err = ERROR_HANDLE_EOF, Setting m_WriteState = DROPDIR_WRITE_CRLF" );
        
        return( DoLastFileOp() );
    }

    return( hr );
    
    
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnCopyMessageRead( DWORD dwBytesRead, DWORD dwErr )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnCopyMessageRead");
    HRESULT hr = S_OK;
    
    if (dwBytesRead )
    {
        if (dwBytesRead > 4)
        {
            CopyMemory(m_acLastBytes, &m_szBuffer[dwBytesRead-5], 5);
        }
        else
        {
            MoveMemory(m_acLastBytes, &m_acLastBytes[dwBytesRead], 5-dwBytesRead);
            CopyMemory(&m_acLastBytes[5-dwBytesRead], m_szBuffer, dwBytesRead);
        }

        //
        // the write file will complete async & then we'll do the
        // last fileop.
        //
        
        if( dwErr == ERROR_HANDLE_EOF )
        {
            DebugTrace( (LPARAM)this, " Interesting case err = ERROR_HANDLE_EOF, Setting m_WriteState = DROPDIR_WRITE_CRLF" );
            
            m_WriteState = DROPDIR_WRITE_CRLF;
        }

        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.
        
        if ( FAILED( hr = WriteFile(m_szBuffer, dwBytesRead ) ) )
        {
            ErrorTrace( (LPARAM)this, "WriteFile return hr = 0x%x", hr );
            return( hr );
        }

    }
    else
    {
        m_WriteState = DROPDIR_WRITE_CRLF;
        
        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_CRLF" );
        
        return( DoLastFileOp() );
        
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnCopyMessageWrite( DWORD cbWritten )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnCopyMessageWrite");
    HRESULT hr = S_OK;
    
    m_cbMsgWritten += cbWritten;

    switch( m_WriteState )
    {
        case DROPDIR_WRITE_DATA:
            return( CopyMessage() );
            break;
        case DROPDIR_WRITE_CRLF:
            return( DoLastFileOp() );
            break;
        case DROPDIR_WRITE_SETPOS:
            return( AdjustFilePos() );
            break;
        default:
            _ASSERT(!"Invalid WriteState");
            ErrorTrace( (LPARAM)this, "Invalid WriteState" );
            hr = E_INVALIDARG;
            break;
    }

    return( hr );

}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::DoLastFileOp()
{
    DECL_TRACE((LPARAM) this, "CDropDir::DoLastFileOp");
    HRESULT hr = S_OK;
    DebugTrace( (LPARAM)this, "DoLastFileOp called" );
    
    // Now, see if the file ends with a CRLF, if not, add it
    if ((m_cbMsgWritten > 1) && memcmp(&m_acLastBytes[3], &m_acCrLfDotCrLf[3], 2))
    {
        //
        // the write will complete async. set next write state
        //
        
        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_SETPOS" );
        
        m_WriteState = DROPDIR_WRITE_SETPOS;

        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.
        
        // Add the trailing CRLF        
        if(FAILED( hr = WriteFile(m_acCrLfDotCrLf, 2 ) ) )
        {
            ErrorTrace( (LPARAM)this, "WriteFile returns hr = 0x%x", hr );
            return(hr);
        }
        
    }
    else
    {
        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_SETPOS" );
        
        m_WriteState = DROPDIR_WRITE_SETPOS;
        
        return( AdjustFilePos() );
    }

    
    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::AdjustFilePos()
{
    DECL_TRACE((LPARAM) this, "CDropDir::AdjustFilePos");
    HRESULT hr = S_OK;

    DebugTrace( (LPARAM)this, "AdjustFilePos called" );

    //If file ends with CRLF.CRLF, remove the trailing .CRLF
    //Do not modify the file otherwise

    DWORD dwLo = LODWORD( m_cbWriteOffset );
    DWORD dwHi = HIDWORD( m_cbWriteOffset );
    
    if ((m_cbMsgWritten > 4) && !memcmp(m_acLastBytes, m_acCrLfDotCrLf, 5))
    {
        DebugTrace( (LPARAM)this, "Removing the trailing CRLF-DOT-CRLF" );
        
        // Remove the trailing .CRLF
        if ((SetFilePointer(m_hDrop, dwLo-3, (LONG*)&dwHi, FILE_BEGIN) == 0xffffffff) ||
            !SetEndOfFile(m_hDrop))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            ErrorTrace( (LPARAM)this, "SetFilePointer or SetEndofFile return hr = 0x%x", hr );
            return( hr );
        }
    }

    //We need to flush the context before ACK'ing the message
    if (!FlushFileBuffers(m_hDrop))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        ErrorTrace( (LPARAM)this, "FlushFileBuffers failed with hr = 0x%x", hr );
        return( hr );
    }

    hr = SetAllRcptsHandled();
    if( FAILED( hr ) )
    {
        ErrorTrace( (LPARAM)this, "SetAllRcptsHandledreturn hr = 0x%x", hr );
        return( hr );
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CDropDir::CheckIfAllRcptsHandled()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CheckIfAllRcptsHandled");
    BOOL fRet = TRUE;
    
    for( DWORD i = 0; i < m_NumRcpts; i++ )
    {
        if ( m_rgRcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            HRESULT hr = m_pIMsgRecips->GetDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                fRet = FALSE;
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                fRet = FALSE;
                break;
            }
                
        }
    }

    return( fRet );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::SetAllRcptsHandled()
{
    DECL_TRACE((LPARAM) this, "CDropDir::SetAllRcptsHandled");
    HRESULT hr = S_OK;
    
    for( DWORD i = 0; i < m_NumRcpts; i++ )
    {
        if (m_rgRcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            hr = m_pIMsgRecips->GetDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                dwRecipientFlags |= RP_DELIVERED;
            
    
                hr = m_pIMsgRecips->PutDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr))
                {
                    break;
                }
            }
                
        }
    }
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\findiis.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceId
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceId(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	PSMTP_SERVER_INSTANCE pSmtpInstance = (PSMTP_SERVER_INSTANCE)pInstance ;
	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext) ;
	PSMTP_SERVER_INSTANCE* ppSmtpInstance = (PSMTP_SERVER_INSTANCE*)pvContext1 ;

	//
	//	Check this instance for its id - if it matches the id we are looking for
	//	return FALSE to discontinue the iteration.
	//
	if( dwInstanceId == pSmtpInstance->QueryInstanceId() )
	{
		// found it
		if(!pSmtpInstance->IsShuttingDown())
		{
			//reference it first
			pSmtpInstance->Reference();

			*ppSmtpInstance = pSmtpInstance ;
			return FALSE ;
		}
		else
		{
			//lie and say we did not find the instance
			//if we are shutting down
			*ppSmtpInstance = NULL;
			return FALSE;
		}
	}

	// did not find it - continue iteration
	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   FindIISInstance
//
//  Synopsis:  Returns an instance pointer for the given ID
//
//  Arguments:  pointer to an SMTP server calss and instance ID
//
//  Returns: pointer to an SMTP instance class
//
//  History:
//
//----------------------------------------------------------------
PSMTP_SERVER_INSTANCE
FindIISInstance(
    PSMTP_IIS_SERVICE pService,
	DWORD	dwInstanceId
    )

{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	PSMTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter("FindIISInstance");

	pService->AcquireServiceShareLock();
	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceId;
	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)dwInstanceId,
									(PVOID)&pInstance,
									pfnInstanceEnum
									) ) {

		ErrorTrace(0,"Error enumerating instances");
	}

	//if we found an instance, but it's not running, or the service is
	//not running, then dereference the instance and leave
	if(pInstance && ( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)
		|| (pService->QueryCurrentServiceState() != SERVICE_RUNNING)))


	{
			pInstance->Dereference();
			pInstance = NULL;
	}

	pService->ReleaseServiceShareLock();

	TraceFunctLeave();

	return pInstance ;
}


BOOL CountInstances(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{

	if(pInstance)
	{
		(*(DWORD*)pvContext)++;
	}

	return TRUE;
}

BOOL GetInstancePerfData(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{

	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext) ;
	PSMTP_STATISTICS_BLOCK			pStatsBlock;
	PSMTP_INSTANCE_LIST_ENTRY	pInstanceInfo = NULL;

	pStatsBlock =  *(PSMTP_STATISTICS_BLOCK *) pvContext1;

	if(pInstance->QueryInstanceId() <= (DWORD)((DWORD_PTR)pvContext))
	{
		pStatsBlock->dwInstance = pInstance->QueryInstanceId();

		pInstanceInfo = ((SMTP_SERVER_INSTANCE *)pInstance)->GetSmtpInstanceInfo();

		if(pInstanceInfo)
		{
			pInstanceInfo->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		}
		//((SMTP_SERVER_INSTANCE *)pInstance)->GetSmtpInstanceInfo()->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		(*(PSMTP_STATISTICS_BLOCK *) pvContext1)++;
		return TRUE;
	}

	return FALSE;

}

PSMTP_STATISTICS_BLOCK_ARRAY GetServerPerfCounters(PSMTP_IIS_SERVICE pService)
{
	DWORD							NumInstances = 0;
	DWORD							dwAlloc = 0;
	PSMTP_INSTANCE_LIST_ENTRY		pSmtpInfo = NULL;
	PSMTP_STATISTICS_BLOCK_ARRAY	pSmtpStatsBlockArray = NULL;
	PSMTP_STATISTICS_BLOCK			pStatsBlock = NULL;

	TraceFunctEnter("GetServerPerfCounters");

	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;

	//Get the count of the number of instances first
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CountInstances;

	if( !pService->EnumServiceInstances(
									(PVOID)&NumInstances,
									(PVOID)NULL,
									pfnInstanceEnum
									) )
	{

		ErrorTrace(0,"Error counting instances");
	}

	if (NumInstances == 0)
	{
		TraceFunctLeave();
		return NULL;
	}

	//allocate memory to return to caller
	dwAlloc = sizeof(SMTP_STATISTICS_BLOCK_ARRAY) + NumInstances * sizeof(SMTP_STATISTICS_BLOCK);
	pSmtpStatsBlockArray = (PSMTP_STATISTICS_BLOCK_ARRAY)MIDL_user_allocate(dwAlloc);
	if (!pSmtpStatsBlockArray)
	{
		TraceFunctLeave();
		return NULL;
	}

	ZeroMemory(pSmtpStatsBlockArray, dwAlloc);

	//fill in memory structure
	pSmtpStatsBlockArray->cEntries = NumInstances;
	pStatsBlock = pSmtpStatsBlockArray->aStatsBlock;
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&GetInstancePerfData;

	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)NumInstances,
									(PVOID)&pStatsBlock,
									pfnInstanceEnum
									) )
	{

		ErrorTrace(0,"Error counting instances");
	}


	TraceFunctLeave();
	return pSmtpStatsBlockArray;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the connection accept routine called by the connection
    thread.


    FILE HISTORY:
        Johnl       08-Aug-1994 Lifted from FTP server

*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <rdns.hxx>
#include "smtpcli.hxx"



//
//  Private prototypes.
//

VOID
SmtpCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	);

SOCKERR CloseSocket( SOCKET sock );

BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    );

//
//  Private functions.
//

/*++
  This function dereferences User data and kills the UserData object if the
    reference count hits 0. Before killing the user data, it also removes
    the connection from the list of active connections.

--*/
VOID DereferenceUserDataAndKill(IN OUT CLIENT_CONNECTION * pUserData)
{
        pUserData->DisconnectClient();
		((SMTP_CONNECTION*)pUserData)->QuerySmtpInstance()->RemoveConnection(pUserData);
		delete pUserData;
    
} // DereferenceUserDataAndKill()

void HandleErrorCondition(SOCKET sock, SMTP_SERVER_INSTANCE *pInstance, DWORD dwError, PSOCKADDR_IN pSockAddr)
{
	char ErrorBuf[4 *MAX_PATH];
	const CHAR * apszSubStrings[2];
	CHAR pchAddr1[50] = "";
	CHAR pchAddr2[50] = "";
	DWORD SendSize;

	_ASSERT(pSockAddr != NULL);
	_ASSERT(pInstance != NULL);
	_ASSERT(sock != INVALID_SOCKET);

	SendSize = wsprintf (ErrorBuf, "%d-%s %s\r\n", 
							SMTP_RESP_SRV_UNAVAIL, 
							pInstance->GetConnectResponse(),							
							SMTP_SRV_UNAVAIL_MSG);
		
	CLIENT_CONNECTION::WriteSocket(sock, ErrorBuf, SendSize );

	if(dwError == ERROR_REMOTE_SESSION_LIMIT_EXCEEDED)
	{
		_itoa(pInstance->QueryInstanceId(), pchAddr1, 10);
		InetNtoa(pSockAddr->sin_addr, pchAddr2 );

		apszSubStrings[0] = pchAddr1;
		apszSubStrings[1] = pchAddr2;

		SmtpLogEvent(SMTP_MAX_CONNECTION_REACHED,
                     2,
                     apszSubStrings,
                     NO_ERROR );
	}
}

BOOL VerifyClient(SMTP_CONNECTION * pNewClient, PSOCKADDR_IN psockAddrRemote)
{
	AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
	BOOL			fRet = TRUE;
	struct hostent* pH = NULL;

	pNewClient->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockAddrRemote );
	if ( pNewClient->BindInstanceAccessCheck() ) 
	{
		acIpAccess = pNewClient->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck);
		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) 
		{
			fRet = FALSE;
		}
		else if (fNeedDnsCheck) 
		{
			pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)psockAddrRemote)->sin_addr),
                          4, PF_INET );
			if(pH != NULL)
			{
				acIpAccess = pNewClient->QueryAccessCheck()->CheckName(pH->h_name);
			}
			else
			{
				acIpAccess = AC_IN_DENY_LIST;
			}
		}

		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				(acIpAccess == AC_NOT_IN_GRANT_LIST)) 
		{
			fRet = FALSE;
		}

		pNewClient->UnbindInstanceAccessCheck();
	}


	if(!fRet)
	{
		SetLastError(ERROR_ACCESS_DENIED);
	}

	return fRet;
}

BOOL
ProcessNewClient(
    IN SOCKET       sNew,
    IN PVOID        EndpointObject,
    IN SMTP_SERVER_INSTANCE *pInstance,
	IN BOOL         fMaxConnExceeded,
    IN PSOCKADDR_IN psockAddrRemote,
    IN PSOCKADDR_IN psockAddrLocal = NULL,
    IN PATQ_CONTEXT patqContext    = NULL,
    IN PVOID        pvBuff         = NULL,
    IN DWORD        cbWritten      = 0,
    OUT LPBOOL      pfAtqToBeFreed = NULL
    )
{
	SMTP_CONNECTION * pNewClient = NULL;
    DWORD           err     = NO_ERROR;
    BOOL            fReturn  = FALSE;
    BOOL            fMaxExceeded = FALSE;
    DBG_CODE( CHAR  pchAddr[32];);
    BOOL            fSockToBeFreed = TRUE;
    BOOL            fDereferenceInstance = FALSE;
    CLIENT_CONN_PARAMS clientParams;

	TraceFunctEnterEx((LPARAM) NULL, "ProcessNewClient");

    DBG_CODE( InetNtoa( psockAddrRemote->sin_addr, pchAddr));

    if ( pfAtqToBeFreed != NULL) 
	{
        *pfAtqToBeFreed = TRUE;
    }

	clientParams.sClient = sNew;
    clientParams.pAtqContext = patqContext;
    clientParams.pAddrLocal = (PSOCKADDR) psockAddrLocal;
    clientParams.pAddrRemote = (PSOCKADDR)psockAddrRemote;
    clientParams.pvInitialBuff = pvBuff;
    clientParams.cbInitialBuff = cbWritten ;
    clientParams.pEndpoint = (PIIS_ENDPOINT)EndpointObject;

	if( pInstance && (pInstance->IsShuttingDown() || (pInstance->QueryServerState( ) != MD_SERVER_STATE_STARTED)))
	{
		DBGPRINTF((DBG_CONTEXT," Service instance is shutting down\n"));
	}
	else if ( !fMaxConnExceeded)
	{

	//	DBGPRINTF((DBG_CONTEXT,"Getting a connection object\n"));

        pNewClient = (SMTP_CONNECTION *) pInstance->CreateNewConnection( &clientParams);

		if(pNewClient)
		{
			if(!VerifyClient(pNewClient, psockAddrRemote))
			{
				DereferenceUserDataAndKill(pNewClient);
				pNewClient = NULL;
				fSockToBeFreed = FALSE;
				fDereferenceInstance = FALSE;
				SetLastError(ERROR_ACCESS_DENIED);
			}
		}
    }
	else
	{
		err = ERROR_REMOTE_SESSION_LIMIT_EXCEEDED;
		SetLastError(err);
	}

    if( pNewClient != NULL)
	{

		//DBGPRINTF((DBG_CONTEXT,"New connection object is non-null\n"));

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the USER_DATA object is created
        //    with the socket and atq context.
        //  From now on USER_DATA will take care of freeing
        // ATQ context & socket
        //

        fSockToBeFreed = FALSE;

         //
         // At this point we have the context for the AcceptExed socket.
         //  Set the context in the AtqContext if need be.
          //

         if ( patqContext != NULL) 
		 {
			 	//DBGPRINTF((DBG_CONTEXT,"AtqContext is not NULL\n"));


                //
                // Associate client connection object with this control socket
                //  handle for future completions.
                //

                AtqContextSetInfo(patqContext,
                                  ATQ_INFO_COMPLETION_CONTEXT,
                                  (UINT_PTR) pNewClient);
          }
		 else 
		 {
			 //DBGPRINTF((DBG_CONTEXT,"AtqContext is  NULL\n"));

			 if(!pNewClient->AddToAtqHandles((HANDLE) sNew,EndpointObject, pInstance->QueryConnectionTimeout(),
				SmtpCompletion))
			{
				err = GetLastError();
				DBGPRINTF((DBG_CONTEXT,"AddToAtqHandles() failed- err= %d\n", err));
				DebugTrace((LPARAM) NULL, "pNewClient->AddToAtqHandles failed- err = %d", err);

				DereferenceUserDataAndKill(pNewClient);
				fDereferenceInstance = FALSE;
				fSockToBeFreed = FALSE;
				pNewClient = NULL;
			}
		 }
    }
	else
	{
		err = GetLastError();

		if(err != ERROR_ACCESS_DENIED)
			fDereferenceInstance = TRUE;
	}

	if ( (pNewClient == NULL) || (err != NO_ERROR) ) 
	{

	//	DBGPRINTF((DBG_CONTEXT,"New connection object is NULL\n"));

        //
        // Failed to allocate new connection
        // Reasons:
        //   1) Max connections might have been exceeded.
        //   2) Not enough memory is available.
        //
        //  handle the failures and notify client.
        //

		HandleErrorCondition(sNew, pInstance, err, psockAddrRemote);

	}
	else
	{

		//DBGPRINTF((DBG_CONTEXT,"Calling StartSession()\n"));

		if(!pNewClient->StartSession())
		{
			err = GetLastError();
			DBGPRINTF((DBG_CONTEXT,"StartSession() failed - err= %d\n", err));
            DebugTrace((LPARAM) NULL, "pNewClient->StartSession() failed- err = %d", err);

			DereferenceUserDataAndKill(pNewClient);
			pNewClient = NULL;
			fSockToBeFreed = FALSE;
			fDereferenceInstance = FALSE;
		}
		else
		{
			fReturn = TRUE;
		}
	}


    if ( fSockToBeFreed ) 
	{
        if ( patqContext != NULL) 
		{
			// ensure that socket is shut down.
             DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE));
         } 
		else 
		{

            CloseSocket( sNew);
         }
    }


    if ( pfAtqToBeFreed != NULL) 
	{

        *pfAtqToBeFreed = fSockToBeFreed;
    }

	if (pInstance && fDereferenceInstance ) 
	{
		pInstance->DecrementCurrentConnections();
		pInstance->Dereference();
	}

	TraceFunctLeaveEx((LPARAM) NULL);
    return (fReturn);

} // ProcessNewClient()

/*******************************************************************

    NAME:       SmtpOnConnect

    SYNOPSIS:   Handles the incoming connection indication from the
                connection thread


    ENTRY:      sNew - New client socket

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        Johnl       02-Aug-1994 Reworked from FTP server

********************************************************************/

VOID SmtpOnConnect( IN SOCKET        sNew,
                  IN SOCKADDR_IN * psockaddr,       //Should be SOCKADDR *
                  IN PVOID         pEndpointContext,
                  IN PVOID         pEndpointObject )
{

    PIIS_ENDPOINT      pEndpoint    = (PIIS_ENDPOINT)pEndpointContext;
    INT                cbAddr       = sizeof( sockaddr );
    SOCKADDR_IN           sockaddr;
	SMTP_SERVER_INSTANCE *pInstance;
	BOOL fProcessed;
	BOOL fMaxConnExceeded;

    DBG_ASSERT( sNew != INVALID_SOCKET );
	DBG_ASSERT( psockaddr != NULL );

	if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) 
	{

		DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

		goto error_exit;

	}

	if ( getsockname( sNew, (PSOCKADDR) &sockaddr, &cbAddr ) != 0 )
    {
        goto error_exit;
    }

	//
	// Find Instance
	//
	pInstance = (SMTP_SERVER_INSTANCE *)
     ((PIIS_ENDPOINT)pEndpointContext)->FindAndReferenceInstance(
                             (LPCSTR)NULL,
                             sockaddr.sin_addr.s_addr,
							 &fMaxConnExceeded);

	if ( pInstance == NULL ) 
	{

		//
		//  Site is not permitted to access this server.
		//  Dont establish this connection. We should send a message.
		//

		goto error_exit;
	}

	fProcessed = ProcessNewClient( sNew,
                               pEndpointObject,
                               pInstance,
							   fMaxConnExceeded,
                               psockaddr);

	if ( fProcessed) 
	{
		//StatCheckAndSetMaxConnections();
	}

	return;

error_exit:

    CloseSocket( sNew );

	return;

} // SmtpOnConnect



VOID
SmtpOnConnectEx(
    VOID *        patqContext,
    DWORD         cbWritten,
    DWORD         err,
    OVERLAPPED *  lpo
    )
{
    BOOL       fAllowConnection    = FALSE;
    PVOID      pvBuff = NULL;
    PSOCKADDR_IN psockAddrLocal = NULL;
    PSOCKADDR_IN psockAddrRemote = NULL;
    SOCKET     sNew;
    PIIS_ENDPOINT pEndpoint;
    PSMTP_SERVER_INSTANCE pInstance;
	BOOL fProcessed = FALSE;
	BOOL  fAtqContextToBeFreed = TRUE;
	BOOL fMaxConnExceeded;

    if ( err || !lpo || g_IsShuttingDown)
    {
		if(g_IsShuttingDown)
		{
			DBGPRINTF(( DBG_CONTEXT,
                   "[SmtpOnConnectEx] Completion failed because of shutdown %d, Atq context %lx\n",
                    err,
                    patqContext ));

		}
		else
		{
			DBGPRINTF(( DBG_CONTEXT,
                   "[SmtpOnConnectEx] Completion failed with error %d, Atq context %lx\n",
                    err,
                    patqContext ));
		}

		goto exit;
    }


    //
    // Get AcceptEx parameters
    //

    AtqGetAcceptExAddrs( (PATQ_CONTEXT) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         (PSOCKADDR *) &psockAddrLocal,
                         (PSOCKADDR *) &psockAddrRemote );


	if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) 
	{

		DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

		goto exit ;
	}

	//
	// Find Instance
	//

	pInstance = (SMTP_SERVER_INSTANCE *)
     ((PIIS_ENDPOINT)pEndpoint)->FindAndReferenceInstance(
                             (LPCSTR)NULL,
                             psockAddrLocal->sin_addr.s_addr,
							 &fMaxConnExceeded
                             );

	if(pInstance == NULL)
	{
		//
		//  Site is not permitted to access this server.
		//  Dont establish this connection. We should send a message.
		//

	//	DBGPRINTF((DBG_CONTEXT,
		//	"Unable to find instance [err %d]\n",GetLastError()));
		goto exit;
	}


    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       (UINT_PTR) pInstance->QueryConnectionTimeout());


	fProcessed = ProcessNewClient( sNew,
                               pEndpoint,
                               pInstance,
							   fMaxConnExceeded,
                               psockAddrRemote,
                               psockAddrLocal,
                               (PATQ_CONTEXT ) patqContext,
                               pvBuff,
                               cbWritten,
                               &fAtqContextToBeFreed);


exit:

    if ( !fProcessed && fAtqContextToBeFreed ) 
	{

	//	DBGPRINTF((DBG_CONTEXT,
		//	"ProcessNewClient returned false\n"));

        //
        // We failed to process this connection. Free up resources properly
        //

        DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT )patqContext, FALSE));
        AtqFreeContext( (PATQ_CONTEXT ) patqContext, TRUE );
    }

    return;

} // SmtpOnConnectEx



#if 0
BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    )
{
    STR strResponse;

    if ( !strResponse.Resize( 512 ) ||
         !HTTP_REQ_BASE::BuildExtendedStatus( &strResponse,
                                              HT_FORBIDDEN,
                                              NO_ERROR,
                                              ids ))
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SendError] Failed to build status (error %d)\n",
                   GetLastError()));

        return FALSE;
    }

    //
    //  Do a synchronous send
    //

    send( socket,
          strResponse.QueryStr(),
          strResponse.QueryCB(),
          0 );

    return TRUE ;
} // SendError
#endif

/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR CloseSocket( SOCKET sock )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

#if 0
    shutdown( sock, 1 );    // Davidtr sez not needed
#endif

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    if( serr == 0 )
     {
         // DBGPRINTF(( DBG_CONTEXT,
                      // "closed socket %d\n",
                      //  sock ));
      }
     else
      {
          DBGPRINTF(( DBG_CONTEXT,
                       "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
      }

    return serr;

}   // CloseSocket

/*++

	Description:

		Handles a completed IO.

	Arguments:

		pvContext:			the context pointer specified in the initial IO
		cbWritten:			the number of bytes sent
		dwCompletionStatus:	the status of the completion (usually NO_ERROR)
		lpo:				the overlapped structure associated with the IO

	Returns:

		nothing.

--*/
VOID
SmtpCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	)
{
	BOOL WasProcessed;
	SMTP_CONNECTION *pCC = (SMTP_CONNECTION *) pvContext;

	_ASSERT(pCC);
	_ASSERT(pCC->IsValid());
	_ASSERT(pCC->QuerySmtpInstance() != NULL);

	//
	// if we could not process a command, or we were
	// told to destroy this object, close the connection.
	//
	WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
}

/*++

	Description:

		Handles a completed IO.

	Arguments:

		pvContext:			the context pointer specified in the initial IO
		cbWritten:			the number of bytes sent
		dwCompletionStatus:	the status of the completion (usually NO_ERROR)
		lpo:				the overlapped structure associated with the IO

	Returns:

		nothing.

--*/
VOID
SmtpCompletionFIO(
	PFIO_CONTEXT		pFIOContext,
	FH_OVERLAPPED		*pOverlapped,
	DWORD				cbWritten,
	DWORD				dwCompletionStatus)
{
	BOOL WasProcessed;
	SMTP_CONNECTION *pCC = (SMTP_CONNECTION *) (((SERVEREVENT_OVERLAPPED *) pOverlapped)->ThisPtr);

	_ASSERT(pCC);
	_ASSERT(pCC->IsValid());
	_ASSERT(pCC->QuerySmtpInstance() != NULL);

	//
	// if we could not process a command, or we were
	// told to destroy this object, close the connection.
	//
	WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, (OVERLAPPED *) pOverlapped);
}

#if 0
VOID
ServerEventCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	)
{
	SERVEREVENT_OVERLAPPED * Ov = (SERVEREVENT_OVERLAPPED *) lpo;

	_ASSERT(pvContext);

	Ov->Overlapped.pfnCompletion(Ov->ThisPtr, cbWritten, dwCompletionStatus, lpo);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\conn.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        conn.cxx

   Abstract:

        This module defines the functions for base class of connections
        for Internet Services  ( class CLIENT_CONNECTION)

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

           Gibraltar Services Common Code

   Functions Exported:

          CLIENT_CONNECTION::Initialize()
          CLIENT_CONNECTION::Cleanup()
          CLIENT_CONNECTION::~CLIENT_CONNECTION()
          BOOL CLIENT_CONNECTION::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)
          VOID CLIENT_CONNECTION::DisconnectClient( IN DWORD ErrorReponse)

          BOOL CLIENT_CONNECTION::StartupSession( VOID)
          BOOL CLIENT_CONNECTION::ReceiveRequest(
                                               OUT LPBOOL pfFullRequestRecd)

          BOOL CLIENT_CONNECTION::ReadFile( OUT LPVOID pvBuffer,
                                            IN  DWORD  dwSize)
          BOOL CLIENT_CONNECTION::WriteFile( IN LPVOID pvBuffer,
                                             IN DWORD  dwSize)
          BOOL CLIENT_CONNECTION::TransmitFile( IN HANDLE hFile,
                                                IN DWORD cbToSend)
          BOOL CLIENT_CONNECTION::PostCompletionStatus( IN DWORD dwBytes )

   Revision History:
   Revision History:
           Richard Kamicar   ( rkamicar )  31-Dec-1995
                Moved to common directory, filled in more

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "conn.hxx"



/************************************************************
 *    Functions
 ************************************************************/



/*++

   ICLIENT_CONNECTION::Initialize()

      Constructor for ICLIENT_CONNECTION object.
      Initializes the fields of the client connection.

   Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

   Note:
      TO keep the number of connected users <= Max connections specified.
      Make sure to add this object to global list of connections,
       after creating it.
      If there is a failure to add to global list, delete this object.

--*/

CLIENT_CONNECTION::Initialize(
    IN SOCKET              sClient,
    IN const SOCKADDR_IN * psockAddrRemote,
    IN const SOCKADDR_IN * psockAddrLocal  /* Default  = NULL */,
    IN PATQ_CONTEXT        pAtqContext     /* Default  = NULL */,
    IN PVOID               pvInitialRequest/* Default  = NULL */,
    IN DWORD               cbInitialData   /* Default  = 0    */
    )
{
    DWORD dwError = NO_ERROR;


    m_sClient        = ( sClient);
    m_pAtqContext    = pAtqContext;
    m_cbReceived = 0;
    m_pvInitial    = pvInitialRequest;
    m_cbInitial    = cbInitialData;
    m_Destroy = FALSE;

    _ASSERT( psockAddrRemote != NULL);

    m_saClient = *psockAddrRemote;

    //  Obtain the socket addresses for the socket
    m_pchRemoteHostName[0] =
    m_pchLocalHostName[0] =
    m_pchLocalPortName[0] = '\0';

    // InetNtoa() wants just 16 byte buffer.
    _ASSERT( 16 <= MAX_HOST_NAME_LEN);
    dwError = InetNtoa( psockAddrRemote->sin_addr, m_pchRemoteHostName);

    _ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer

    if ( psockAddrLocal != NULL)
    {
      dwError = InetNtoa( psockAddrLocal->sin_addr, m_pchLocalHostName);
      _itoa( ntohs(psockAddrLocal->sin_port), m_pchLocalPortName, 10);
    } else
    {
        SOCKADDR_IN  sockAddr;
        int cbAddr = sizeof( sockAddr);

        if ( getsockname( sClient,
                         (struct sockaddr *) &sockAddr,
                         &cbAddr ))
        {

            dwError = InetNtoa( sockAddr.sin_addr, m_pchLocalHostName );
            _itoa( ntohs(sockAddr.sin_port), m_pchLocalPortName, 10);

        }
    }

   // DBG_ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer

#if 0
    DBG_CODE(
             if ( dwError != NO_ERROR) {

                 DBGPRINTF( ( DBG_CONTEXT,
                             "Obtaining Local Host Name Failed. Error = %u\n",
                             dwError)
                           );
                 SetLastError( dwError);
             }
             );

    DEBUG_IF( CLIENT, {

     DBGPRINTF( ( DBG_CONTEXT,
                    " Constructed ICLIENT_CONNECTION object ( %08x)."
                    " Socket (%d), Host (%s).\n",
                    this,
                    sClient,
                    QueryClientHostName()
                    ));
    });

#endif

    return ( TRUE);

}


/*++
     ICLIENT_CONNECTION::Cleanup()

       Destructor function for client connection object.
       Checks and frees the AtqContext.

    Note:
       If enlisted in the global list of connections,
        ensure that this object is freed from that list before deletion.

--*/
VOID CLIENT_CONNECTION::Cleanup( VOID)
{
  PATQ_CONTEXT pAtqContext;

  if(m_DoCleanup)
  {
    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       AtqFreeContext( pAtqContext, TRUE );
    }
  }

} // ICLIENT_CONNECTION::Cleanup()


/*++

    Description:

        Checks to see if we have received the complete request from the client.
        ( A complete request is a line of text terminated by <cr><lf> )
        if a CRLF is found, it returns a pointer into the buffer were the CR
        starts, else it returns NULL.  If this routine finds a CR without a
        LF it will return NULL

    Arguments:

        InputBuffer       pointer to character buffer containing received data.

        cbRecvd         count of bytes of data received

    Returns:

       a pointer to the CR if CRLF is found
       NULL if CRLF is not found.

--*/
//  VIRTUAL
char * CLIENT_CONNECTION::IsLineComplete(IN OUT const char * InputBuffer, IN  DWORD cbRecvd)
{
    register DWORD Loop = 0;

    _ASSERT(InputBuffer != NULL);

    //we need at least 2 bytes to find a
    //CRLF pair
    if( cbRecvd < 2)
     return NULL;

    //we are going to start at the 2nd byte
    //looking for the LF, then look backwards
    //for the CR
    Loop = 1;

    while (Loop < cbRecvd)
    {
        if(InputBuffer[Loop] == LF)
        {
            if(InputBuffer[Loop - 1] == CR)
                return (char *) &InputBuffer[Loop - 1];
            else
            {
                //skip 2 bytes since we saw a LF
                //without a CR.
                Loop += 2;
            }
        }
        else if(InputBuffer[Loop] == CR)
        {
            //we saw a CR, so increment out
            //loop variable by one so that
            //we can catch the LF on the next
            //go around
            Loop += 1;
        }
        else
        {
            //This character is neither a CR
            //or a LF, so we can increment by
            //2
            Loop += 2;
        }
    }

    //didn't find a CRLF pair
    return NULL;
}

/*++

    Description:

        VIRTUAL Method that MUST be defined by the derived class

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       fIOCompletion      TRUE if this was an IO completion


    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::ProcessClient( IN DWORD cbWritten, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    return ( TRUE);
} // CLIENT_CONNECTION::ProcessClient()


/*++

    Reads contents using ATQ into the given buffer.
    