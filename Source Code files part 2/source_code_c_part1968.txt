etails -> Found = Found;
			Details -> Page = this;

			Details -> AllocationMask = AllocationMask;
			Details -> SubDivisionMask = SubDivisionMask;
			Details -> VectorWord = VectorWord;

			Details -> ArrayOffset = ArrayOffset;
			Details -> VectorOffset = VectorOffset;
			Details -> WordShift = WordShift;
			}
		}

	return this;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate available memeory elements from a page.  This is      */
    /*   done by scanning the bit vector looking for unallocated        */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate and that we need to
	//   allocated at least one element.
	//
	if ( (! Full()) && ((*Actual) < Requested) )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slots.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER SBIT32 ArrayOffset = (FirstFree * OverheadBitsPerWord);
			REGISTER BIT32 AvailableMask = WordSearchMask;
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];
			REGISTER SBIT32 WordOffset = 0;

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			while ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 Value = (*VectorWord);

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = (ArrayOffset + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bits indicating that this
						//   element is in use.
						//
						(*VectorWord) |= AvailableMask;

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Add the element to the allocation array
						//   so it can be returned to the caller.
						//
						Array[ (Requested - ((*Actual) ++) - 1) ] =
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);

						//
						//   When we have got what we need we exit.
						//
						if ( ((*Actual) >= Requested) )
							{ return True; }
						}
					else
						{ break; }
					}
				else
					{ Failure( "Bit vector is corrupt in MultipleNew" ); }
				}
			}
		}

	return ((*Actual) >= Requested);
    }

    /********************************************************************/
    /*                                                                  */
    /*   A single memory allocation.                                    */
    /*                                                                  */
    /*   Allocate an available memeory element from the page.  This     */
    /*   is done by scanning the bit vector looking for unallocated     */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

VOID *PAGE::New( BOOLEAN SubDivided )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate.
	//
	if ( ! Full() )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slot.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			if ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 AvailableMask = WordSearchMask;
				REGISTER BIT32 Value = (*VectorWord);
				REGISTER SBIT32 WordOffset = 0;

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = 
						((FirstFree * OverheadBitsPerWord) + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bit indicating that this
						//   element is in use.  If the allocation 
						//   is to be sub-divided then trun on this
						//   bit as well.
						//
						(*VectorWord) |=
							(
							AvailableMask
								|
							(SubDivided ? (AvailableMask >> 1) : 0)
							);

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Return the address of the allocated 
						//   memory to the caller.
						//
						return
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);
						}
					}
				else
					{ Failure( "Bit vector is corrupt in New" ); }
				}
			}
#ifdef DEBUGGING

		if ( ! Full() )
			{ Failure( "Available count corrupt in New" ); }
#endif
		}

	return ((VOID*) AllocationFailure);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Walk( SEARCH_PAGE *Details,FIND *Find )
    {
	REGISTER BOOLEAN FreshPage = False;

	//
	//   We have been handed the details of an allocation.
	//   We need to walk along this allocation and find
	//   the next non-subdivided allocation.
	do
		{
		//
		//   We need to setup the heap walk if the address
		//   is null so we skip the heap walk code.
		//
		if ( Details -> Address != NULL )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 End = Details -> Cache -> GetNumberOfElements();
			REGISTER SBIT32 Start = Details -> ArrayOffset;
			REGISTER PAGE *Page = Details -> Page;

			//
			//   Walk the current page looking for a suitable
			//   memory allocation to report to the user.  When
			//   we reach the end of the page we need to get
			//   another page to walk.
			//
			for 
					(
					Count = ((FreshPage) ? 0 : 1);
					(Start + Count) < End;
					Count ++
					)
				{
				//
				//   Compute the new address.
				//
				Details -> Address = 
					(
					Page -> Cache -> ComputeAddress
						( 
						Page -> Address,
						(Start + Count)
						)
					);

				//
				//   Compute the new allocation details.
				//
				Page -> FindPage
					( 
					Details -> Address,
					Details,
					Find,
					False 
					);

				//
				//   We skip all sub-divided allocations as they 
				//   will get reported elsewhere.
				//
				if (! ((*Details -> VectorWord) & Details -> SubDivisionMask) )
					{ return True; }
				}
			}

		//
		//   Update the flag to show that we have
		//   had to go and get a new page.
		//
		FreshPage = True;
		}
	while ( Details -> Cache -> Walk( Details,Find ) );

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current page structure.                            */
    /*                                                                  */
    /********************************************************************/

PAGE::~PAGE( VOID )
	{
#ifdef DEBUGGING
	//
	//   Destroy the page structure.
	//
	Address = NULL;
	PageSize = 0;
	ParentPage = NULL;

	Allocated = 0;
	Available = 0;
	FirstFree = 0;

#endif
	//
	//   We update the version number whenever a page is created
	//   or destroyed.  We use the version number to ensure that
	//   a page has not been deleteed and/or recreated between
	//   releasing one lock and claiming a another other lock.
	//
	Version ++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\CallStack.hpp ===
#ifndef _CALL_STACK_HPP_
#define _CALL_STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A call stack trace.                                            */
    /*                                                                  */
    /*   The call stack trace class supports the extraction, storage    */
    /*   and formatting of call stack function traces.                  */
    /*                                                                  */
    /********************************************************************/

class CALL_STACK
    {
        //
        //   Static private data.
        //
 		STATIC BOOLEAN				  Active;
 		STATIC SBIT32				  Activations;
	    STATIC HANDLE			      Process;
        STATIC SPINLOCK               Spinlock;

    public:
        //
        //   Public functions.
        //
        CALL_STACK( VOID );

		SBIT32 GetCallStack
			( 
			VOID					  *Frames[], 
			SBIT32					  MaxFrames, 
			SBIT32					  SkipFrames = 1
			);

		VOID FormatCallStack
			(
			CHAR					  *Buffer, 
			VOID					  *Frames[], 
			SBIT32					  MaxBuffer, 
			SBIT32					  MaxFrames 
			);

		BOOLEAN UpdateSymbols( VOID );

        ~CALL_STACK( VOID );

	private:
#ifndef DISABLE_DEBUG_HELP
		//
		//   Private functions.
		//
		BOOLEAN FormatSymbol
			(
			VOID					  *Address,
			CHAR					  *Buffer,
			SBIT32					  MaxBuffer
			);

		//
		//   Static provate functions.
		//
		STATIC BOOL STDCALL UpdateSymbolCallback
			(
			PSTR					  Module,
			ULONG_PTR				  BaseOfDLL,
			ULONG					  SizeOfDLL,
			VOID					  *Context
			);

#endif
        //
        //   Disabled operations.
        //
        CALL_STACK( CONST CALL_STACK & Copy );

        VOID operator=( CONST CALL_STACK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\common.hpp ===
#ifndef _COMMON_HPP_
#define _COMMON_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A collection of common functions.                              */
    /*                                                                  */
    /*   This class contains common functions that are needed           */
    /*   throughout the application.                                    */
    /*                                                                  */
    /********************************************************************/

class COMMON : public ASSEMBLY
    {
    public:
        //
        //   Public functions.
        //
		COMMON( VOID )
			{ /* void */ }

		STATIC BOOLEAN ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift );

		STATIC SBIT32 ForceToPowerOfTwo( SBIT32 Value );

		STATIC CHAR *LowerCase( CHAR *Text );

		STATIC CHAR *LowerCase( CHAR *Text,SBIT32 Size );

		STATIC BOOLEAN PowerOfTwo( SBIT32 Value );
#ifndef DISABLE_ATOMIC_FLAGS

		STATIC VOID SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC VOID UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC CHAR *UpperCase( CHAR *Text );

		STATIC CHAR *UpperCase( CHAR *Text,SBIT32 Size );
#endif

		~COMMON( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        COMMON( CONST COMMON & Copy );

        VOID operator=( CONST COMMON & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\delay.hpp ===
#ifndef _DELAY_HPP_
#define _DELAY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The delay constants specify the initial size of the array      */
    /*   containing the list of allocations to be deleted.              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 BlockSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Delayed memory deletion.                                       */
    /*                                                                  */
    /*   This class provides general purpose memory delayed memory      */
    /*   deletion mechanism.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class DELAY : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Used;

        TYPE                          **Block;

    public:
        //
        //   Public functions.
        //
        DELAY( SBIT32 NewMaxSize = BlockSize );

        VOID DeferedDelete( TYPE *Memory );

        ~DELAY( VOID );

		//
		//   Public inline functions.
		//
        INLINE CONST TYPE **AllocationList( VOID )
			{ return ((CONST TYPE**) Block); };

        INLINE SBIT32 SizeOfBlock( VOID ) 
			{ return Used; }

    private:
        //
        //   Disabled operations.
        //
        DELAY( CONST DELAY & Copy );

        VOID operator=( CONST DELAY & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new block and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::DELAY( SBIT32 NewMaxSize ) 
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Used = 0;

        Block = new TYPE* [ NewMaxSize ];
#ifdef DEBUGGING
        }
    else
        { Failure( "Max size in constructor for DELAY" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Defered delete for an allocated memory block.                  */
    /*                                                                  */
    /*   An allocated memory block is registered for deletion by        */
    /*   the class destructor.                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID DELAY<TYPE,LOCK>::DeferedDelete
		( 
		TYPE						  *Memory 
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Make sure we have enough space to register this memory 
	//   block for later deletion.  If not allocate more space 
	//   and copy the existing data into the enlarged space.
	//
    if ( Used >= MaxSize )
        {
        REGISTER SBIT32 Count;
        REGISTER TYPE **NewBlock = new TYPE* [ (MaxSize *= ExpandStore) ];

        for ( Count=0;Count < Used;Count ++ )
            { NewBlock[ Count ] = Block[ Count ]; }

        delete [] Block;

        Block = NewBlock;
        }

	//
	//   Register the allocated memory block.
	//
    Block[ Used ++ ] = Memory;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an allocation.  This call is not thread safe and       */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::~DELAY( VOID )
    {
    REGISTER SBIT32 Count;

	//
	//   Delete the allocated memory blocks.
	//
    for ( Count = (Used - 1);Count >= 0;Count -- )
        { delete Block[ Count ]; }

    delete [] Block;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Dll.hpp ===
#ifndef _DLL_HPP_
#define _DLL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A monitor class for DLLs.                                      */
    /*                                                                  */
    /*   When a process or thread attaches or dettaches from a DLL      */
    /*   the notification is passed along to all interested parties.    */
    /*                                                                  */
    /********************************************************************/

class DLL : public LIST
    {
		//
		//   Private type definitions.
		//
		typedef VOID (*FUNCTION)( void *Parameter, int Reason );

        //
        //   Private data.
        //
		FUNCTION					  Function;
		VOID						  *Parameter;

        //
        //   Static private data.
        //
        STATIC LIST					  ActiveClasses;
        STATIC SPINLOCK				  Spinlock;

    public:
        //
        //   Public functions.
        //
        DLL( FUNCTION NewFunction = NULL,VOID *NewParameter = NULL );

		VIRTUAL VOID ProcessAttach( VOID );

		VIRTUAL VOID ProcessDetach( VOID );

		VIRTUAL VOID ThreadAttach( VOID );

		VIRTUAL VOID ThreadDetach( VOID );

        ~DLL( VOID );

		//
		//   Static public functions.
		//
		STATIC VOID ClaimLock( VOID )
			{ Spinlock.ClaimLock(); }

		STATIC DLL *GetActiveClasses( VOID )
			{ return ((DLL*) ActiveClasses.First()); }

		STATIC VOID ReleaseLock( VOID )
			{ Spinlock.ReleaseLock(); }

	private:
        //
        //   Disabled operations.
        //
        DLL( CONST DLL & Copy );

        VOID operator=( CONST DLL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\align.hpp ===
#ifndef _ALIGN_HPP_
#define _ALIGN_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Alignment of structures to cache line boundaries.              */
    /*                                                                  */
    /*   This class aligns data structures to cache line boundaries.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class ALIGN
    {
        //
        //   Private data.
        //
        TYPE                          *Adress;

    public:
        //
        //   Public functions.
        //
        ALIGN( VOID );

        ~ALIGN( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE *operator&( VOID )
			{ return Address; }

	private:
        //
        //   Disabled operations.
        //
        ALIGN( CONST ALIGN & Copy );

        VOID operator=( CONST ALIGN & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate an aligned memory allocation and initialize it.          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::ALIGN( VOID )
    {
    REGISTER CHAR *Address;

	//
	//   Allocate an aligned memory allocation.
	//
	Address = _aligned_malloc( sizeof(TYPE),CacheLineSize );

	//
	//   Call the constructor to initialize the type.
	//
    PLACEMENT_NEW( Address,TYPE );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the memory allocation.                                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::~ALIGN( VOID )
    { 
	//
	//   Call the destructor for the aligned type.
	//
    PLACEMENT_DELETE( Address,TYPE );

	//
	//   Delete the aligned memory allocation.
	//
	_aligned_free( Address ); 
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\common.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Common.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Convert a divisor to a shift.                                  */
    /*                                                                  */
    /*   We know that we can convert any divide operation into a        */
    /*   shift when the divisor is a power of two.  This function       */
    /*   figures out whether we can do this and what the how far        */
    /*   we would need to shift.                               .        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift )
	{
	if ( Divisor > 0 )
		{
		REGISTER SBIT32 Count;

		for ( Count=0;(Divisor & 1) == 0;Count ++ )
			{ Divisor >>= 1; }

		if (Divisor == 1)
			{
			(*Shift) = Count;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Force to the next power of two.                                */
    /*                                                                  */
    /*   We know that we can do certain optimizations if certain        */
    /*   values are a power of two.  Here we force the issue by         */
    /*   rounding up the value to the next power of two.                */
    /*                                                                  */
    /********************************************************************/

SBIT32 COMMON::ForceToPowerOfTwo( SBIT32 Value )
	{
	//
	//   We ensure the value is positive if not we 
	//   simply return the identity value.
	//
	if ( Value > 1 )
		{
		//
		//   We only have to compute the next power of
		//   two if the value is not already a power
		//   of two.
		//
		if ( ! PowerOfTwo( Value ) )
			{
			REGISTER SBIT32 Count;

			for ( Count=0;Value > 0;Count ++ )
				{ Value >>= 1; }

			return (1 << Count);
			}
		else
			{ return Value; }
		}
	else
		{ return 1; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert all characters to lower case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to lower case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Ensure value is a power of two.                                */
    /*                                                                  */
    /*   We need to ensure that certain values are an exact power       */
    /*   of two.  If this is true then the value will be positive       */
    /*   and only 1 bit will be set.  So we shift right until we        */
    /*   find the first bit on and then the value should be one.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::PowerOfTwo( SBIT32 Value )
	{ return ((Value & (Value-1)) == 0); }
#ifndef DISABLE_ATOMIC_FLAGS

    /********************************************************************/
    /*                                                                  */
    /*   Atomically set flags.                                          */
    /*                                                                  */
    /*   We need to atomically set some flags to prevent them being     */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags |= NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Atomically unset flags.                                        */
    /*                                                                  */
    /*   We need to atomically unset some flags to prevent them being   */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags &= ~NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert all characters to upper case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to upper case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\assembly.hpp ===
#ifndef _ASSEMBLY_HPP_
#define _ASSEMBLY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The assembly constants indicate the location of the thread     */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

#define PcTeb                         0x18
#define IDTeb                         0x24

#ifdef WINDOWS_95
CONST SBIT32 TebSlot				  = 0x88;
#else
CONST SBIT32 TebSlot				  = 0xE10;
#endif

#pragma warning( disable : 4035 )

    /********************************************************************/
    /*                                                                  */
    /*   Assembly language for ultra high performance.                  */
    /*                                                                  */
    /*   We have coded a few functions in assembly language for         */
    /*   ultra high performance.                                        */
    /*                                                                  */
    /********************************************************************/

class ASSEMBLY
    {
	protected:
		//
		//   Protected type definitions.
		//
		typedef struct
			{
	        SBIT32                    First;
	        SBIT32                    Second;
			}
		DOUBLE_SBIT32;

    public:
        //
        //   Public inline functions.
        //
		ASSEMBLY( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 AtomicAdd
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  Value 
				)
			{
			return 
				(
				(SBIT32) InterlockedExchangeAdd
					( 
					((LPLONG) Address),
					((LONG) Value) 
					)
				);
			}

		STATIC INLINE SBIT32 AtomicCompareExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue,
				SBIT32				  Value 
				)
			{
			return 
				(
				(SBIT32) InterlockedCompareExchange
					( 
					((LONG*) Address),
					((LONG) NewValue),
					((LONG) Value)
					)
				);
			}

		STATIC INLINE VOID *AtomicCompareExchangePointer
				( 
				VOLATILE VOID		  **Address,
				VOID				  *NewPointer,
				VOID				  *OldPointer 
				)
			{ 
			return 
				(
				InterlockedCompareExchangePointer
					( 
					((VOLATILE PVOID*) Address),
					NewPointer,
					OldPointer
					)
				); 
			}


		STATIC INLINE SBIT64 AtomicCompareExchange64
				( 
				VOLATILE SBIT64		  *Address,
				SBIT64				  NewValue,
				SBIT64				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		esi, Address				// Load the address.
				mov		ebx, dword ptr NewValue[0]	// Load the new value.
				mov		ecx, dword ptr NewValue[4]	// Load the new value.
				mov		eax, dword ptr Value[0]		// Load the value.
				mov		edx, dword ptr Value[4]		// Load the value.
				lock	cmpxchg8b [esi]				// Update the value.
				}
#else
#ifdef WINDOWS64
			return 
				(
				InterlockedCompareExchange64
					( 
					((VOLATILE SBIT64*) Address),
					NewValue,
					Value
					)
				);
#else
#error No Interlocked 64 bit exchange.
#endif
#endif
			}

		STATIC INLINE SBIT32 AtomicDecrement( VOLATILE SBIT32 *Address )
			{ return ((SBIT32) InterlockedDecrement( ((LONG*) Address) )); }

		STATIC INLINE VOID AtomicDoubleDecrement( VOLATILE SBIT32 *Address )
			{
			AUTO DOUBLE_SBIT32 Original;
			AUTO DOUBLE_SBIT32 Update;

			do
				{
				//
				//   Clone the current values.
				//
				(*((SBIT64*) & Original)) = (*((SBIT64*) Address));
				(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

				//
				//   Update the current values.
				//
				Update.First --;
				Update.Second --;
				}
			while
				( 
				AtomicCompareExchange64
					( 
					((SBIT64*) Address),
					(*((SBIT64*) & Update)),
					(*((SBIT64*) & Original))
					) 
						!= 
				(*((SBIT64*) & Original))
				);
			}

		STATIC INLINE VOID AtomicDoubleIncrement( VOLATILE SBIT32 *Address )
			{
			AUTO DOUBLE_SBIT32 Original;
			AUTO DOUBLE_SBIT32 Update;

			do
				{
				//
				//   Clone the current values.
				//
				(*((SBIT64*) & Original)) = (*((SBIT64*) Address));
				(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

				//
				//   Update the current values.
				//
				Update.First ++;
				Update.Second ++;
				}
			while
				( 
				AtomicCompareExchange64
					( 
					((SBIT64*) Address),
					(*((SBIT64*) & Update)),
					(*((SBIT64*) & Original))
					) 
						!= 
				(*((SBIT64*) & Original))
				);
			}

		STATIC INLINE SBIT32 AtomicExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue 
				)
			{
			return 
				(
				(SBIT32) InterlockedExchange
					( 
					((LONG*) Address),
					((LONG) NewValue) 
					)
				);
			}

		STATIC INLINE VOID *AtomicExchangePointer
				( 
				VOLATILE VOID		  **Address,
				VOID				  *NewPointer 
				)
			{ 
			return 
				(
				InterlockedCompareExchangePointer
					( 
					((VOLATILE PVOID*) Address),
					NewPointer,
					((PVOID) (*Address))
					)
				); 
			}

		STATIC INLINE SBIT32 AtomicIncrement( VOLATILE SBIT32 *Address )
			{ return ((SBIT32) InterlockedIncrement( ((LONG*) Address) )); }

		STATIC INLINE SBIT32 GetThreadId( VOID )
			{ return ((SBIT32) GetCurrentThreadId()); }

		STATIC INLINE VOID Pause( VOID )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				pause								// Pause for Jackson MP.
				}
#endif
#ifdef WINDOWS64
			_mm_pause();
#endif
			}

		STATIC INLINE VOID PrefetchL1( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load the address.
				prefetcht0	[eax]					// Prefetch into the L1.
				}
#endif
#ifdef WINDOWS64
			_mm_prefetch( ((CHAR*) Address),_MM_HINT_T0 );
#endif
			}

		STATIC INLINE VOID PrefetchL2( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load the address.
				prefetcht1	[eax]					// Prefetch into the L2.
				}
#endif
#ifdef WINDOWS64
			_mm_prefetch( ((CHAR*) Address),_MM_HINT_T1 );
#endif
			}

		STATIC INLINE VOID PrefetchL3( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load the address.
				prefetcht2	[eax]					// Prefetch into the L3.
				}
#endif
#ifdef WINDOWS64
			_mm_prefetch( ((CHAR*) Address),_MM_HINT_T2 );
#endif
			}

		STATIC INLINE VOID PrefetchNta( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load the address.
				prefetchnta	[eax]					// Prefetch into the L1.
				}
#endif
#ifdef WINDOWS64
			_mm_prefetch( ((CHAR*) Address),_MM_HINT_NTA );
#endif
			}

#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
		STATIC INLINE VOID *GetTlsAddress( SBIT32 TlsOffset )
			{
			__asm
				{
				mov		eax,TlsOffset				// Load the TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				}
			}
#endif
#endif

		STATIC INLINE VOID *GetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		edx,TlsOffset				// Load the TLS offset.
				add		edx,fs:[PcTeb]				// Add TEB base address.
				mov		eax,[edx]					// Load TLS value.
				}
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
			}

		STATIC INLINE VOID SetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset,
				VOID				  *NewPointer 
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		edx,TlsOffset				// Load the TLS offset.
				add		edx,fs:[PcTeb]				// Add TEB base address.
				mov		ecx,NewPointer				// Load new TLS value.
				mov		[edx],ecx					// Store new TLS value.
				}
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
			}

		~ASSEMBLY( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        ASSEMBLY( CONST ASSEMBLY & Copy );

        VOID operator=( CONST ASSEMBLY & Copy );
    };

#pragma warning( default : 4035 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\environment.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The enviroment class slaves various information to speed       */
    /*   up access to it.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 EnvironmentCacheSize	  = 16;
CONST SBIT32 SizeOfName				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
SBIT32 ENVIRONMENT::Activations = 0;
SBIT32 ENVIRONMENT::AllocationGranularity = 0;
#ifndef DISABLE_HEAP_USE
CHAR *ENVIRONMENT::FullDnsName = NULL;
CHAR *ENVIRONMENT::FullHostName = NULL;
#endif
SBIT16 ENVIRONMENT::NumberOfProcessors = 0;
SBIT32 ENVIRONMENT::SizeOfMemory = 0;
SBIT32 ENVIRONMENT::SizeOfPage = 0;
#ifndef DISABLE_HEAP_USE
CHAR *ENVIRONMENT::ProgramName = NULL;
CHAR *ENVIRONMENT::ProgramPath = NULL;
SBIT32 ENVIRONMENT::MaxVariables = 0;
SBIT32 ENVIRONMENT::VariablesUsed = 0;
ENVIRONMENT::VARIABLE *ENVIRONMENT::Variables = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new environment and initialize it if needed.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::ENVIRONMENT( VOID )
    {
	//
	//   We only actvate the environment once regardless 
	//   of the number of instances as it is a static class.
	//
    if ( AtomicIncrement( & Activations ) == 1 )
        {
#ifndef DISABLE_HEAP_USE
#ifndef COMPILING_ROCKALL_DLL
#ifndef COMPILING_ROCKALL_LIBRARY
		AUTO CHAR ProgramFullName[ SizeOfName ];
		AUTO ULONG FullSize;
#endif
#endif
#endif
		AUTO MEMORYSTATUS MemoryStatus;
		AUTO SYSTEM_INFO SystemInformation;

		//
		//   Initialize the class members to reasonable 
		//   default values.
		//
		GetSystemInfo( & SystemInformation );

		GlobalMemoryStatus( & MemoryStatus );

		AllocationGranularity = 
			((SBIT32) SystemInformation.dwAllocationGranularity);
		NumberOfProcessors = 
			((SBIT16) SystemInformation.dwNumberOfProcessors);
		SizeOfMemory = 
			((SBIT32) MemoryStatus.dwTotalPhys);
		SizeOfPage = 
			((SBIT32) SystemInformation.dwPageSize);
#ifndef DISABLE_HEAP_USE

		//
		//   Slave interesting values like the host 
		//   name and the DNS name.
		//
		FullDnsName = NULL;
		FullSize = SizeOfName;

		//
		//   Extract the full DNS name from the OS.
		//
		if 
				( 
				GetComputerNameEx
					(
					ComputerNameDnsFullyQualified,
					ProgramFullName,
					& FullSize
					)
				)
			{
			REGISTER SBIT16 Count = 
				((SBIT16) (strlen( (char*) ProgramFullName ) + 1));

			//
			//   We allocate some space for the DNS name
			//   and copy the name into the newly allocated
			//   space.
			//
			if ( (FullDnsName = new CHAR[ Count ]) != NULL )
				{
				//
				//   Copy in the new DNS name.
				//
				(VOID) strcpy
					(
					FullDnsName,
					ProgramFullName
					);
				}
			}

		//
		//   Slave interesting values like the host 
		//   name and the DNS name.
		//
		FullHostName = NULL;
		FullSize = SizeOfName;

		//
		//   Extract the full host name from the OS.
		//
		if 
				( 
				GetComputerNameEx
					(
					ComputerNameDnsHostname,
					ProgramFullName,
					& FullSize
					)
				)
			{
			REGISTER SBIT16 Count = 
				((SBIT16) (strlen( (char*) ProgramFullName ) + 1));

			//
			//   We allocate some space for the host name
			//   and copy the name into the newly allocated
			//   space.
			//
			if ( (FullHostName = new CHAR[ Count ]) != NULL )
				{
				//
				//   Copy in the new host name.
				//
				(VOID) strcpy
					(
					FullHostName,
					ProgramFullName
					);
				}
			}

		//
		//   Slave interesting values like the program name 
		//   and path variable.
		//
		ProgramName = NULL;
		ProgramPath = NULL;

		MaxVariables = 0;
		VariablesUsed = 0;
		Variables = NULL;

		//
		//   Get the complete file name for the current program.
		//
		if ( GetModuleFileName( NULL,ProgramFullName,SizeOfName ) > 0 )
			{
			REGISTER SBIT16 Count = (SBIT16) strlen( (char*) ProgramFullName );
			REGISTER CHAR *Characters = & ProgramFullName[ Count ];

			//
			//   Scan backwards looking for the first directory   
			//   seperator.  There is guaranteed to be at least 
			//   one.
			//
			for 
				( 
				/* void */;
				((Count > 0) && ((*Characters) != (*DirectorySeperator())));
				Count --, Characters -- 
				);

			(*(Characters ++)) = '\0';

			//
			//   Allocate space for the directory path and copy   
			//   the path into the newly allocated area.
			//
			ProgramPath = new CHAR [ (strlen( ((char*) ProgramFullName) )+1) ];

			if ( ProgramPath != NULL )
				{
				(VOID) strcpy
					( 
					((char*) ProgramPath),
					((char*) ProgramFullName)
					); 
				}

			//
			//   Scan the program name backwards looking for a '.'.
			//
			for 
				( 
				Count = (SBIT16) strlen( (char*) Characters );
				((Count > 0) && (Characters[ Count ] != '.'));
				Count -- 
				);

			//
			//   Remove any trailing suffix from the program name 
			//   (i.e. '*.EXE').
			//
			if ( Count > 0 )
				{ Characters[ Count ] = '\0'; }

			//
			//   Allocate space for the program name and copy  
			//   the name into the newly allocated area.
			//
			ProgramName = new CHAR [ (strlen( ((char*) Characters) )+1) ];

			if ( ProgramName != NULL )
				{
				(void) strcpy
					( 
					((char*) ProgramName),
					((char*) Characters) 
					);
				}
			}
#endif
		}
	}
#ifndef DISABLE_HEAP_USE

    /********************************************************************/
    /*                                                                  */
    /*   Read an environment variable.                                  */
    /*                                                                  */
    /*   When we read an environment value we want to make sure that    */
    /*   it never changes and gets slaved in memory.  This routine      */
    /*   implements this functionality.                                 */
    /*                                                                  */
    /********************************************************************/

CONST CHAR *ENVIRONMENT::ReadEnvironmentVariable( CONST CHAR *Name )
	{
	if ( Activations > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 SizeOfName = (SBIT32) strlen( (char*) Name );
		REGISTER VARIABLE *Variable;
		STATIC SPINLOCK Spinlock;

		//
		//   The environment variables can only be scanned by  
		//   one CPU at a time because a second CPU might reallocate  
		//   the storage and cause the first CPU to fail.
		//
		Spinlock.ClaimLock();

		//
		//   Examine all existing environment variables looking for a 
		//   match. If a match is found return it to the caller.
		//
		for 
				( 
				Count = VariablesUsed, Variable = Variables;
				Count > 0; 
				Count --, Variable ++ 
				)
			{
			if 
					( 
					(SizeOfName == Variable -> SizeOfName) 
						&& 
					(strcmp( (char*) Name,(char*) Variable -> Name ) == 0) 
					)
				{
				Spinlock.ReleaseLock();

				return (Variable -> Value);
				}
			}

		//
		//  If we have filled up our array so we need to make it bigger.
		//  So lets check for this now.
		//
		if ( VariablesUsed >= MaxVariables )
			{
			REGISTER VARIABLE *PreviousAllocation = Variables;

			if ( MaxVariables > 0 )
				{
				Variables = 
					(
					(VARIABLE*) realloc
						( 
						(VOID*) Variables,
						((MaxVariables *= ExpandStore) * sizeof(VARIABLE)) 
						)
					);
				}
			else
				{ Variables = new VARIABLE [ EnvironmentCacheSize ]; }

			//
			//   Lets make sure we were successful.  If not we restore 
			//   the previous pointer as it is still valid.
			//
			if ( Variables == NULL )
				{
				Variables = PreviousAllocation;

				Failure( "Expand memory in ReadEnvironmentVariable" );
				}
			}

		//
		//  We know that we have enough memory to allocate another element and 
		//  that we are the only CPU in this section of code so just add the 
		//  new variable.
		//
		Variable = & Variables[ VariablesUsed ++ ];

		Variable -> SizeOfName = 
			(SBIT32) strlen( (char*) Name );
		Variable -> SizeOfValue = 
			(SBIT32) GetEnvironmentVariable( (char*) Name,"",0 );

		Variable -> Name = new CHAR [ (Variable -> SizeOfName + 1) ];
		(VOID) strcpy( (char*) Variable -> Name,(char*) Name );

		if ( Variable -> SizeOfValue > 0 )
			{
			Variable -> Value = new CHAR [ (Variable -> SizeOfValue + 1) ];

			(VOID) GetEnvironmentVariable
				( 
				(char*) Name,
				(char*) Variable -> Value,
				(int) (Variable -> SizeOfValue + 1)
				);
			}
		else
			{ Variable -> Value = NULL; }

		Spinlock.ReleaseLock();

		return (Variable -> Value);
		}
	else
		{ return NULL; }
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an environment.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::~ENVIRONMENT( VOID )
	{
	//
	//   We only destroy the environment once regardless 
	//   of the number of instances as it is a static class.
	//
    if ( AtomicDecrement( & Activations ) == 0 )
		{
#ifndef DISABLE_HEAP_USE
		REGISTER SBIT32 Count;

		//
		//  Delete any existing DNS name.
		//
		if ( FullDnsName != NULL )
			{
			delete [] FullDnsName;
			FullDnsName = NULL;
			}

		//
		//  Delete any existing host name.
		//
		if ( FullHostName != NULL )
			{
			delete [] FullHostName;
			FullHostName = NULL;
			}

		//
		//   Delete all of the environment variable names
		//   and values.
		//
		for ( Count = 0;Count < VariablesUsed;Count ++ )
			{
			REGISTER VARIABLE *Variable = & Variables[ Count ];

			delete [] Variable -> Name;

			if ( Variable -> Value != NULL )
				{ delete [] Variable -> Value; }
			}


		//
		//   Delete the environment array.
		//
		delete [] Variables;
		Variables = NULL;

		//
		//   Delete the program name and path.
		//
		if ( ProgramPath != NULL )
			{
			delete [] ProgramPath;
			ProgramPath = NULL;
			}

		if ( ProgramName != NULL )
			{
			delete [] ProgramName;
			ProgramName = NULL;
			}
#endif
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\CallStack.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#ifndef DISABLE_DEBUG_HELP
#include <dbghelp.h>
#endif
#include "CallStack.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Compiler options.                                              */
    /*                                                                  */
    /*   Ensure that the last function call(s) before 'StackWalk'       */
    /*   are not FPO-optimized.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef DISABLE_DEBUG_HELP
#pragma optimize("y", off)
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the debug buffer size.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxBufferSize			  = 512;
CONST SBIT32 SymbolNameLength		  = 512;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CALL_STACK::Active = False;
SBIT32 CALL_STACK::Activations = 0;
HANDLE CALL_STACK::Process = NULL;
SPINLOCK CALL_STACK::Spinlock = NULL;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a call stack class and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

CALL_STACK::CALL_STACK( VOID )
    {
	//
	//   Claim a lock to prevent multiple threads
	//   from using the symbol lookup mechanism.
	//
	Spinlock.ClaimLock();

#ifndef DISABLE_DEBUG_HELP
	//
	//   We will activate the symbols if they are
	//   not already available.
	//
	if ( ! Active )
		{
		//
		//   Setup the process handle, load image help  
		//   and then load any available symbols.
		//
		Process = GetCurrentProcess();

		//
		//   Setup the image help library.
		//
		if ( ! (Active = ((BOOLEAN) SymInitialize( Process,NULL,TRUE ))) )
			{
			//
			//   We only issue the warning message once
			//   when we fail to load the symbols.
			//
			if ( Activations == 0 )
				{
				//
				//   Format the error message and output it
				//   to the debug stream.
				//
				DebugPrint
					(
					"Missing or mismatched symbols files: %x\n",
					HRESULT_FROM_WIN32( GetLastError() )
					);
				}
			}
		}

	//
	//   We keep track of the number of activations
	//   so we can delete the symbols at the
	//   required point.
	//
	Activations ++;

#endif
	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();

	//
	//   Update the available symbols.
	//
	UpdateSymbols();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Extract the current call stack.                                */
    /*                                                                  */
    /*   Extract the current call stack and return it to the caller     */
    /*   so it can be used later.                                       */
    /*                                                                  */
    /********************************************************************/

SBIT32 CALL_STACK::GetCallStack
		(
		VOID						  *Frames[],
        SBIT32						  MaxFrames,
        SBIT32						  SkipFrames
		)
    {
	REGISTER SBIT32 Count = 0;

#ifndef DISABLE_DEBUG_HELP
	//
	//   We can only examine the symbol information if
	//   we were able to load image help.
	//
	if ( Active )
		{
		REGISTER CONTEXT Context;
		REGISTER HANDLE Thread;
		REGISTER SBIT32 MachineType;
		REGISTER STACKFRAME StackFrame;

		//
		//   Zero all the data structures to make
		//   sure they are clean.
		//
		ZeroMemory( & Context,sizeof(CONTEXT) );
		ZeroMemory( & StackFrame,sizeof(STACKFRAME) );

		//
		//   Setup the necessary flags and extract
		//   the thread context.
		//
		Context.ContextFlags = CONTEXT_FULL;
		MachineType = IMAGE_FILE_MACHINE_I386;
		Thread = GetCurrentThread();

		GetThreadContext( Thread,& Context );

		//
		//   Extract the details of the current
		//   stack frame.
		//
		_asm
			{
				mov StackFrame.AddrStack.Offset, esp
				mov StackFrame.AddrFrame.Offset, ebp
				mov StackFrame.AddrPC.Offset, offset DummyLabel
			DummyLabel:
			}

		StackFrame.AddrPC.Mode = AddrModeFlat;
		StackFrame.AddrStack.Mode = AddrModeFlat;
		StackFrame.AddrFrame.Mode = AddrModeFlat;

		//
		//   Claim a lock to prevent multiple threads
		//   from using the symbol lookup mechanism.
		//
		Spinlock.ClaimLock();

		//
		//   Walk the stack frames extracting the
		//   details from each frame examined.
		//
		while ( Count < MaxFrames )
			{
			//
			//   Walk the each stack frame.
			//
			if 
					(
					StackWalk
						(
						MachineType,		   
						Process,		   
						Thread,		   
						& StackFrame,
						& Context,
						NULL,
						SymFunctionTableAccess,
						SymGetModuleBase,
						NULL
						)
					)
				{
				//
				//   Examine and process the current 
				//   stack frame.
				//
				if ( SkipFrames <= 0 )
					{ 
					//
					//   Collect the current function
					//   address and store it.
					//
					Frames[ (Count ++) ] = 
						((VOID*) StackFrame.AddrPC.Offset); 
					}
				else
					{ SkipFrames --; }
				}
			else
				{ break; }
			}

		//
		//   Release the lock.
		//
		Spinlock.ReleaseLock();
		}

#endif
	return Count;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Format a call stack.                                           */
    /*                                                                  */
    /*   We format an entire call stack into a single string ready      */
    /*   for output.                                                    */
    /*                                                                  */
    /********************************************************************/

VOID CALL_STACK::FormatCallStack
		(
		CHAR						  *Buffer, 
		VOID						  *Frames[], 
		SBIT32						  MaxBuffer, 
		SBIT32						  MaxFrames 
		)
    {
#ifndef DISABLE_DEBUG_HELP
	//
	//   We can only examine the symbol information if
	//   we were able to load image help.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Delete any existing string.
		//
		strcpy( Buffer,"" );

		//
		//   Format each frame and then update the
		//   main buffer.
		//
		for ( Count=0;Count < MaxFrames;Count ++ )
			{
			AUTO CHAR NewSymbol[ MaxBufferSize ];
			REGISTER SBIT32 Size;

			//
			//   Format the symbol.
			//
			FormatSymbol( Frames[ Count ],NewSymbol,MaxBufferSize );

			//
			//   Make sure there is enough space in the
			//   output buffer.
			//
			if ( ((Size = strlen( NewSymbol )) + 1) < MaxBuffer)
				{
				//
				//   Copy the symbol into the buffer.
				//
				strcpy( Buffer,NewSymbol );
				Buffer += Size;

				strcpy( Buffer ++,"\n" );

				MaxBuffer -= (Size + 1);
				}
			else
				{ break; }
			}
		}
	else
		{ strcpy( Buffer,"" ); }
#else
	strcpy( Buffer,"" );
#endif
    }
#ifndef DISABLE_DEBUG_HELP

    /********************************************************************/
    /*                                                                  */
    /*   Format a single symbol.                                        */
    /*                                                                  */
    /*   We format a single simple converting it from an address to     */
    /*   a text string.                                                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CALL_STACK::FormatSymbol
		(
		VOID						  *Address,
        CHAR						  *Buffer,
        SBIT32						  MaxBuffer
		)
    {
    AUTO CHAR SymbolBuffer[ (sizeof(IMAGEHLP_SYMBOL) + SymbolNameLength) ];
    AUTO IMAGEHLP_MODULE Module = { 0 };
    REGISTER BOOLEAN Result = True;
    REGISTER PIMAGEHLP_SYMBOL Symbol = ((PIMAGEHLP_SYMBOL) SymbolBuffer);   

	//
	//   Setup values ready for main symbol
	//   extraction function body.
	//
    Module.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    ZeroMemory( Symbol,(sizeof(IMAGEHLP_SYMBOL) + SymbolNameLength) );

    Symbol -> SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    Symbol -> MaxNameLength = SymbolNameLength;

	//
	//   Claim a lock to prevent multiple threads
	//   from using the symbol lookup mechanism.
	//
	Spinlock.ClaimLock();

	//
	//   Extract the module information for the
	//   symbol and format it.
	//
    if ( SymGetModuleInfo( Process,((DWORD) Address),& Module ) )
		{
		REGISTER SBIT32 Size;

		//
		//   Make sure there is enough space in the
		//   output buffer.
		//
        if ( ((Size = strlen( Module.ModuleName )) + 1) < MaxBuffer)
			{
			//
			//   Copy the module name into the buffer.
			//
            strcpy( Buffer,Module.ModuleName );
			Buffer += Size;

            strcpy( Buffer ++,"!" );

			MaxBuffer -= (Size + 1);
			}
		}
    else
		{
		REGISTER SBIT32 Size;

		//
		//   Make sure there is enough space in the
		//   output buffer.
		//
        if ( (Size = strlen( "None!" )) < MaxBuffer)
			{
			//
			//   Copy the module name into the buffer.
			//
            strcpy( Buffer,"None!" );
			Buffer += Size;
			MaxBuffer -= Size;
			}

		//
		//  We failed to extract the module name.
		//
		Result = False;
		}

	//
	//   We will not even bother to try to decode
	//   the symbol if we can't decode the module.
	//
    if ( Result )
		{
		AUTO CHAR SymbolName[ SymbolNameLength ];
		AUTO DWORD Offset = 0;

		//
		//   Try to convert the symbol from an
		//   address to a name.
		//
        if
				(
				SymGetSymFromAddr
					(
					Process,
					((DWORD) Address),
					& Offset,
					Symbol
					)
				)
	        {
			REGISTER SBIT32 Size;

			//
			//   Try to undecorate the name.  If
			//   this fails just use the decorated
			//   name is it is better than nothing.
			//
            if ( ! SymUnDName( Symbol,SymbolName,sizeof(SymbolName) ) )
				{ lstrcpynA( SymbolName,& Symbol->Name[1],sizeof(SymbolName) ); }

			//
			//   Make sure there is enough space in the
			//   output buffer.
			//
			if ( (Size = strlen( SymbolName )) < MaxBuffer)
				{
				//
				//   Copy the symbol name into the buffer.
				//
				strcpy( Buffer,SymbolName );
				Buffer += Size;
				MaxBuffer -= Size;
	            }
			
			//
			//   Format the offset if is is non-zero.
			//
			if ( Offset != 0 )
				{
				//
				//   Format the symbol offset.
				//
				sprintf( SymbolName,"+0x%x",Offset );

				//
				//   Make sure there is enough space in the
				//   output buffer.
				//
				if ( (Size = strlen( SymbolName )) < MaxBuffer)
					{
					//
					//   Copy the symbol name into the buffer.
					//
					strcpy( Buffer,SymbolName );
					Buffer += Size;
					MaxBuffer -= Size;
					}
				}
	        }
        else
	        {
			REGISTER SBIT32 Size;

			//
			//   Format the symbol address.
			//
            sprintf( SymbolName,"0x%p",Address );

			//
			//   Make sure there is enough space in the
			//   output buffer.
			//
			if ( (Size = strlen( SymbolName )) < MaxBuffer)
				{
				//
				//   Copy the symbol name into the buffer.
				//
				strcpy( Buffer,SymbolName );
				Buffer += Size;
				MaxBuffer -= Size;
	            }

 			//
			//  We failed to extract the symbol name.
			//
           Result = False;
	       }
		}
    else
		{
		AUTO CHAR SymbolName[ SymbolNameLength ];
		REGISTER SBIT32 Size;

		//
		//   Format the symbol address.
		//
        sprintf( SymbolName,"0x%p",Address );

		//
		//   Make sure there is enough space in the
		//   output buffer.
		//
		if ( (Size = strlen( SymbolName )) < MaxBuffer)
			{
			//
			//   Copy the symbol name into the buffer.
			//
			strcpy( Buffer,SymbolName );
			Buffer += Size;
			MaxBuffer -= Size;
	        }
		}

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();

    return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Load symbols callback.                                         */
    /*                                                                  */
    /*   When we load the symbols we get a callback for every module    */
    /*   that is currently loaded into the application.                 */
    /*                                                                  */
    /********************************************************************/

BOOL STDCALL CALL_STACK::UpdateSymbolCallback
		(
		PSTR						  Module,
        ULONG_PTR					  BaseOfDLL,
        ULONG						  SizeOfDLL,
        VOID						  *Context
		)
    {
	if ( SymGetModuleBase( Process,BaseOfDLL ) == 0 )
		{ SymLoadModule( Process,NULL,Module,NULL,BaseOfDLL,SizeOfDLL ); }

	return TRUE;
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Load the symbols.                                              */
    /*                                                                  */
    /*   Load the symbols for the current process so we can translate   */
    /*   code addresses into names.                                     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CALL_STACK::UpdateSymbols( VOID )
    {
	REGISTER BOOLEAN Result = True;
#ifndef DISABLE_DEBUG_HELP
	//
	//   We can only examine the symbol information if
	//   we were able to load image help.
	//
	if ( Active )
		{
		//
		//   Claim a lock to prevent multiple threads
		//   from using the symbol lookup mechanism.
		//
		Spinlock.ClaimLock();

		//
		//   Enumaerate all of the loaded modules and
		//   cascade load all of the symbols.
		//
		if ( ! EnumerateLoadedModules( Process,UpdateSymbolCallback,NULL ) )
			{
			//
			//   Format the error message and output it
			//   to the debug window.
			//
			DebugPrint
				(
				"EnumerateLoadedModules returned: %x\n",
				HRESULT_FROM_WIN32( GetLastError() )
				);

			Result = False;
			}

		//
		//   Release the lock.
		//
		Spinlock.ReleaseLock();
		}
#endif

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the call stack.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

CALL_STACK::~CALL_STACK( VOID )
	{ 
	//
	//   Claim a lock to prevent multiple threads
	//   from using the symbol lookup mechanism.
	//
	Spinlock.ClaimLock();

#ifndef DISABLE_DEBUG_HELP
	//
	//   Cleanup the symbol library.
	//
	if ( ((-- Activations) == 0) && (Active) )
		{
		Active = False;

		//
		//   I don't understand why this does not work at
		//   the moment so I will fix it later.
		//
		// SymCleanup( Process ); 

		//
		//   Just to be neat lets zero everything.
		//
		Process = NULL;
		}

#endif
	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\features.hpp ===
#ifndef _FEATURES_HPP_
#define _FEATURES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Active project list.	 							            */
    /*                                                                  */
    /*   The active project list contains all of the projects that      */
    /*   are currently selected.                                        */
    /*                                                                  */
    /********************************************************************/

//#define COMPILING_PIPELINE_SERVER	  1
#define COMPILING_ROCKALL_IV		  1
//#define COMPILING_TRIGGERS		  1
//#define COMPILING_WEB_SERVER		  1

    /********************************************************************/
    /*                                                                  */
    /*   Active fetaure lists.	 							            */
    /*                                                                  */
    /*   The active features list contain all of the features that      */
    /*   are currently selected for each project.                       */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_PIPELINE_SERVER
#ifdef DEBUGGING
#define COMPILING_ROCKALL_LIBRARY	  1			// Enable for testing.
//#define DISABLE_MULTIPLE_PROCESSORS	  1		// Disable for testing.
#define ENABLE_LOCK_STATISTICS		  1			// Enable for testing.
#endif
#define DISABLE_PRECOMPILED_HEADERS	  1		// Disable for testing.
#define DISABLE_STRUCTURED_EXCEPTIONS 1			// Disable for product groups.
#define ENABLE_DEBUG_FILE             1			// Enable for testing.
#define ENABLE_GLOBAL_ROCKALL		  1			// Enable for pure speed.
#define ENABLE_NON_STANDARD_ASSEMBLY  1			// Enable for pure speed.
//#define PRINT_ACTIVE_PACKETS		  1			// Enable for testing.
#define SELECT_CACHE_LINE_SIZE		  32		// Set for Pentium III
#endif

#ifdef COMPILING_ROCKALL_IV
#ifdef DEBUGGING
#define ENABLE_HEAP_STATISTICS        1			// Enable stats in debug build.
#endif
#define COMPILING_ROCKALL_LIBRARY	  1			// Enable for testing.
#define DISABLE_ATOMIC_FLAGS		  1			// Disable for product groups.
#define DISABLE_DEBUG_HELP			  1
#define DISABLE_GLOBAL_NEW			  1			// Disable for product groups.
#define DISABLE_HEAP_USE			  1			// Disable for product groups.
//#define DISABLE_MULTIPLE_PROCESSORS	  1		// Disable for testing.
//#define DISABLE_PRECOMPILED_HEADERS	  1			// Disable for testing.
#define DISABLE_STRUCTURED_EXCEPTIONS 1			// Disable for product groups.
#define ENABLE_DEBUG_FILE             1			// Create a debug file.
//#define ENABLE_NON_STANDARD_ASSEMBLY  1			// Enable for pure speed.
//#define ENABLE_RECURSIVE_LOCKS		  1		// Enable to save lost of TLS.
#define SELECT_CACHE_LINE_SIZE		  128		// Set for Pentium IV
#endif

#ifdef COMPILING_TRIGGERS
#define DISABLE_DEBUG_HELP			  1
//#define DISABLE_MULTIPLE_PROCESSORS	  1		// Disable for testing.
#define DISABLE_PRECOMPILED_HEADERS	  1			// Disable for testing.
//#define DISABLE_STRUCTURED_EXCEPTIONS 1			// Disable for product groups.
#define ENABLE_DEBUG_FILE             1			// Create a debug file.
#define ENABLE_GLOBAL_ROCKALL		  1			// Enable for pure speed.
//#define ENABLE_NON_STANDARD_ASSEMBLY  1			// Enable for pure speed.
//#define ENABLE_RECURSIVE_LOCKS		  1		// Enable to save lost of TLS.
#define SELECT_CACHE_LINE_SIZE		  32		// Set for Pentium III
#endif

#ifdef COMPILING_WEB_SERVER
#ifdef DEBUGGING
#define ENABLE_LOCK_STATISTICS		  1			// Enable for testing.
#define PRINT_ACTIVE_PACKETS		  1			// Enable for testing.
#endif
#define ENABLE_DEBUG_FILE             1			// Create a debug file.
#define ENABLE_NON_STANDARD_ASSEMBLY  1			// Enable for pure speed.
#define SELECT_CACHE_LINE_SIZE		  32		// Set for Pentium III
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The complete feature list.							            */
    /*                                                                  */
    /*   The code supports a significant number of optional features    */
    /*   which are listed in this file.  Any feature can be activated   */
    /*   by copying the approriate setting.  Please be sure to keep     */
    /*   all the flags up to date and leave at list one copy of each    */
    /*   flag below.                                                    */
    /*                                                                  */
    /********************************************************************/

#ifdef ACTIVATE_ALL_OPTIONS
	//
	//   Standard options for all code.
	//
#define ASSEMBLY_X86				  1
#define DEBUGGING                     1

#define DISABLE_GLOBAL_NEW			  1
#define DISABLE_PRECOMPILED_HEADERS	  1
#define DISABLE_STRUCTURED_EXCEPTIONS 1

	//
	//   Standard options for the library code.
	//
#define ENABLE_DEBUG_FILE             1
#define ENABLE_GLOBAL_ROCKALL		  1
#define ENABLE_LOCK_STATISTICS		  1
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#define ENABLE_RECURSIVE_LOCKS		  1

#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_DEBUG_HELP			  1
#define DISABLE_HEAP_USE			  1
#define DISABLE_MULTIPLE_PROCESSORS	  1
#define DISABLE_STRING_LOCKS		  1

#define SELECT_CACHE_LINE_SIZE		  32

	//
	//   Rockall specific options.
	//
#define COMPILING_ROCKALL_DLL		  1
#define COMPILING_ROCKALL_LIBRARY	  1
#define ENABLE_ALLOCATION_STATISTICS  1
#define ENABLE_HEAP_STATISTICS        1
#define NO_DEFAULT_HEAP				  1

	//
	//   Pipeline Server specific options.
	//
#define ENABLE_BUFFER_LOCK			  1
#define ENABLE_ZERO_WRITE_BUFFER	  1

#define PRINT_ACTIVE_PACKETS		  1

	//
	//   Pipeline Server demo specific options.
	//
#define ENABLE_DATABASE				  1
#define ENABLE_READING				  1
#define ENABLE_TRANSACTIONS			  1
#define ENABLE_WRITING				  1

	//
	//   Web Server specific options.
	//
#define DISABLE_ASYNC_IO			  1
#define DISABLE_BUFFER_COPY			  1
#define DISABLE_WEB_LOCKS			  1
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\environment.hpp ===
#ifndef _ENVIRONMENT_HPP_
#define _ENVIRONMENT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Environment configuration values.                              */
    /*                                                                  */
    /*   This class provides a information about the environment.       */
    /*   The information can be accessed repeatedly with very little    */
    /*   cost as the data is slaved in static memory.                   */
    /*                                                                  */
    /********************************************************************/

class ENVIRONMENT : public ASSEMBLY
    {
#ifndef DISABLE_HEAP_USE
		//
		//   Private structures.
		//
		typedef struct
			{
			CHAR					  *Name;
			SBIT32                    SizeOfName;
			CHAR                      *Value;
			SBIT32                    SizeOfValue;
			} 
		VARIABLE;

#endif
        //
        //   Private data.
        //
        STATIC SBIT32		          Activations;

		STATIC SBIT32                 AllocationGranularity;
        STATIC SBIT16                 NumberOfProcessors;
#ifndef DISABLE_HEAP_USE
		STATIC CHAR                   *FullDnsName;
		STATIC CHAR                   *FullHostName;
		STATIC CHAR                   *ProgramName;
		STATIC CHAR                   *ProgramPath;
#endif
		STATIC SBIT32                 SizeOfMemory;
		STATIC SBIT32                 SizeOfPage;
#ifndef DISABLE_HEAP_USE

		STATIC SBIT32                 MaxVariables;
		STATIC SBIT32                 VariablesUsed;
		STATIC VARIABLE               *Variables;
#endif

    public:
        //
        //   Public functions.
        //
        ENVIRONMENT( VOID );
#ifndef DISABLE_HEAP_USE

		STATIC CONST CHAR *ReadEnvironmentVariable( CONST CHAR *Name );
#endif

        ~ENVIRONMENT( VOID );

		//
		//   Public inline functions.
		//
		STATIC INLINE  SBIT32 AllocationSize(VOID ) 
			{ return AllocationGranularity; };
	
		STATIC INLINE SBIT32 CacheAlignSize( SBIT32 Size )
			{ return ((Size + CacheLineMask) & ~CacheLineMask); }

		STATIC INLINE CONST CHAR *DirectorySeperator( VOID ) 
			{ return "\\"; };
#ifndef DISABLE_HEAP_USE

		STATIC INLINE CONST CHAR *DnsName( VOID )
			{ return ((CONST CHAR*) FullDnsName); }

		STATIC INLINE CONST CHAR *HostName( VOID )
			{ return ((CONST CHAR*) FullHostName); }
#endif

#ifndef DISABLE_MULTIPLE_PROCESSORS
        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return NumberOfProcessors; }
#else
        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return 1; }
#endif

		STATIC INLINE SBIT32 MemorySize( VOID ) 
			{ return SizeOfMemory; };

		STATIC INLINE SBIT32 PageSize( VOID ) 
			{ return SizeOfPage; };
#ifndef DISABLE_HEAP_USE

		STATIC INLINE CONST CHAR *ProgramFileName( VOID ) 
			{ return ((CONST CHAR*) ProgramName); };

		STATIC INLINE CONST CHAR *ProgramFilePath( VOID ) 
			{ return ((CONST CHAR*) ProgramPath); };
#endif

	private:
        //
        //   Disabled operations.
        //
        ENVIRONMENT( CONST ENVIRONMENT & Copy );

        VOID operator=( CONST ENVIRONMENT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Globallock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Globallock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

GLOBALLOCK::GLOBALLOCK( CHAR *Name,SBIT32 NewMaxUsers )
    {
	//
	//   Set the initial state.
	//
	if ( (Semaphore = CreateSemaphore( NULL,1,NewMaxUsers,Name )) == NULL )
		{ Failure( "Global semaphore rejected by OS" ); } 
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalTimeouts = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the Globallock.                                          */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN GLOBALLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Wait for the global lock.
		//
		if 
				( 
				WaitForSingleObject( Semaphore,Sleep ) 
					!= 
				WAIT_OBJECT_0 
				)
			{
			//
			//   We failed to claim the lock due to
			//   a timeout.
			//
#ifdef ENABLE_LOCK_STATISTICS
			(VOID) AtomicIncrement( & TotalTimeouts );

#endif
			return False;
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

VOID GLOBALLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Globallock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

VOID GLOBALLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

VOID GLOBALLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
		//
		//   Release the global lock.
		//
		ReleaseSemaphore( Semaphore,1,NULL );
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

GLOBALLOCK::~GLOBALLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Globallock : %d locks, %d timeouts.\n"
		TotalLocks,
		TotalTimeouts
		);

#endif
	//
	//   Close the semaphore handle.
	//
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for GLOBALLOCK" ); }

	//
	//   Just to be tidy.
	//
	Semaphore = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Globallock.hpp ===
#ifndef _GLOBALLOCK_HPP_
#define _GLOBALLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Global locking.                                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The lock claimed is a system-wide global lock shared           */
    /*   between all classes, DLLs and proceses.                        */
    /*                                                                  */
    /********************************************************************/

class GLOBALLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalTimeouts;
#endif

    public:
        //
        //   Public functions.
        //
        GLOBALLOCK( CHAR *Name = "GlobalLock", SBIT32 NewMaxUsers = 256 );

        BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        VOID ReleaseLock( VOID );

        ~GLOBALLOCK( VOID );

    private:
        //
        //   Private functions.
        //
		VOID DeleteExclusiveOwner( VOID );

		VOID NewExclusiveOwner( SBIT32 NewOwner );
        //
        //   Disabled operations.
        //
        GLOBALLOCK( CONST GLOBALLOCK & Copy );

        VOID operator=( CONST GLOBALLOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\librarypch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\global.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Global.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control various debug settings.    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxDebugFileName		  = 128;
CONST SBIT32 DebugBufferSize		  = 512;
#ifdef ENABLE_DEBUG_FILE

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC CHAR DebugModuleName[ MaxDebugFileName ] = "";
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Debug file name.                                               */
    /*                                                                  */
    /*   We sometimes want to change the debug file name to prevent     */
    /*   the debug file being overwritten by a DLLs output or a later   */
    /*   run of the same application.                                   */
    /*                                                                  */
    /********************************************************************/

HANDLE DebugFileHandle( VOID )
	{
	AUTO CHAR FileName[ MaxDebugFileName ];
	STATIC HANDLE DebugFile = INVALID_HANDLE_VALUE;

	//
	//   We will open the debug file if it is not 
	//   already open.
	//
	if ( DebugFile == INVALID_HANDLE_VALUE )
		{
		//
		//   Construct the full file name.
		//
		sprintf
			( 
			FileName,
			"C:\\Temp\\DebugTrace%s.log",
			DebugModuleName 
			);

		//
		//   Now lets try to open the file.
		//
		DebugFile =
			(
			CreateFile
				(
				((LPCTSTR) FileName),
				(GENERIC_READ | GENERIC_WRITE),
				FILE_SHARE_READ, 
				NULL,
				CREATE_ALWAYS,
				NULL,
				NULL
				)
			);

		//
		//   When the file will not open for some reason
		//   we try an alternative path.
		//
		if ( DebugFile == INVALID_HANDLE_VALUE )
			{ 
			//
			//   Construct the alternate file name.
			//
			sprintf
				( 
				FileName,
				"C:\\DebugTrace%s.log",
				DebugModuleName 
				);

			//
			//   Try again using an alternative name.
			//
			DebugFile =
				(
				CreateFile
					(
					((LPCTSTR) FileName),
					(GENERIC_READ | GENERIC_WRITE),
					FILE_SHARE_READ, 
					NULL,
					CREATE_ALWAYS,
					NULL,
					NULL
					)
				);
			}
		}

	return DebugFile;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Debug file name.                                               */
    /*                                                                  */
    /*   We sometimes want to change the debug file name to prevent     */
    /*   the debug file being overwritten by a DLLs output or a later   */
    /*   run of the same application.                                   */
    /*                                                                  */
    /********************************************************************/

VOID DebugFileName( CONST CHAR *FileName )
	{
	AUTO CHAR EditBuffer[ MaxDebugFileName ];
	REGISTER CHAR *Current;

	//
	//   Copy the file name into an edit buffer
	//   so we can remove any directories or
	//   trailing names.
	//
	strncpy( EditBuffer,FileName,MaxDebugFileName );

	EditBuffer[ (MaxDebugFileName-1) ] = '\0';

	//
	//   Scan backwards to remove any suffix.
	//
	for
		(
		Current = & EditBuffer[ (strlen( EditBuffer )-1) ];
		(Current > EditBuffer) && ((*Current) != '.') && ((*Current) != '\\');
		Current --
		);

	if ( (Current > EditBuffer) && (*Current) == '.' )
		{ (*Current) = '\0'; }

	//
	//   Scan backwards to the first directory name.
	//
	for
		(
		Current = & EditBuffer[ (strlen( EditBuffer )-1) ];
		(Current > EditBuffer) && ((*Current) != '\\');
		Current --
		);

	if ( (*Current) == '\\' )
		{ Current ++; }

	//
	//   Copy the edited file name.
	//
	DebugModuleName[0] = '-';

	strncpy( & DebugModuleName[1],Current,(MaxDebugFileName-1) );
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Debug printing.                                                */
    /*                                                                  */
    /*   We sometimes need to print message during debugging. We        */
    /*   do this using the following 'printf' like function.            */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... )
	{
	AUTO CHAR Buffer[ DebugBufferSize ];

	//
	//   Start of variable arguments.
	//
	va_list Arguments;

	va_start(Arguments, Format);

	//
	//   Format the string to be printed.
	//
	_vsnprintf
		( 
		Buffer,
		(DebugBufferSize-1),
		Format,
		Arguments 
		);

	//
	//   Force null termination.
	//
	Buffer[ (DebugBufferSize-1) ] = '\0';

#ifdef ENABLE_DEBUG_FILE
	//
	//   Claim a spinlock to prevent multiple
	//   threads executing overlapping writes.
	//
	Spinlock.ClaimLock();

	//
	//   We will write to the debug file if there
	//   is a valid handle.
	//
	if ( DebugFileHandle() != INVALID_HANDLE_VALUE )
		{
		REGISTER CHAR *Current = Buffer;
		REGISTER SBIT32 Length;

		//
		//   A number of windows applications are too
		//   stupid to understand a simple '\n'.  So
		//   here we convert all "\n" to "\r\n".
		//
		for ( /* void */;(*Current) != '\0';Current += Length )
			{
			STATIC DWORD Written;

			//
			//   Count the characters until the next
			//   newline or end of string.
			//
			for
				(
				Length=0;
				((Current[ Length ] != '\n') && (Current[ Length ] != '\0'));
				Length ++
				);

			//
			//   Write the string and then add a return
			//   newline sequence.
			//
			WriteFile
				(
				DebugFileHandle(),
				((LPCVOID) Current),
				((DWORD) Length),
				& Written,
				NULL
				);

			//
			//   Generate a newline (if needed).
			//
			if ( Current[ Length ] == '\n' )
				{ 
				WriteFile
					(
					DebugFileHandle(),
					((LPCVOID) "\r\n"),
					((DWORD) (sizeof("\r\n") - 1)),
					& Written,
					NULL
					);

				Length ++; 
				}
			}

		//
		//   Flush the file buffers.
		//
		FlushFileBuffers( DebugFileHandle() );
		}

	//
	//   Release any lock claimed earlier.
	//
	Spinlock.ReleaseLock();
#else
	//
	//   Write to the debug window.
	//
	OutputDebugString( Buffer );
#endif

	//
	//   End of variable arguments.
	//
	va_end( Arguments );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Software failure.                                              */
    /*                                                                  */
    /*   We know that when this function is called the application      */
    /*   has failed so we simply try to cleanly exit in the vain        */
    /*   hope that the failure can be caught and corrected.             */
    /*                                                                  */
    /********************************************************************/

VOID Failure( char *Message,BOOLEAN Report )
	{
	//
	//   Report the fault to the debug stream
	//   (if required).
	//
	if ( Report )
		{ DebugPrint( "*** Software Failure: %s ***\n",Message ); }

	//
	//   Raise an exception.
	//
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	throw ((FAULT) Message);
#else
	RaiseException( 1,0,1,((CONST ULONG_PTR*) Message) );
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\lock.hpp ===
#ifndef _LOCKS_HPP_
#define _LOCKS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Full lock structure.                                           */
    /*                                                                  */
    /*   This class provides an full locking mechanism for a            */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class FULL_LOCK
    {
        //
        //   Private data.
        //
		SHARELOCK                     ShareLock;

    public:
        //
        //   Public inline functions.
        //
        FULL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) ShareLock.ClaimExclusiveLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) ShareLock.ClaimShareLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) ShareLock.ReleaseExclusiveLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) ShareLock.ReleaseShareLock(); }

        ~FULL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        FULL_LOCK( CONST FULL_LOCK & Copy );

        VOID operator=( CONST FULL_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   No lock structure.                                             */
    /*                                                                  */
    /*   This class provides a default locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class NO_LOCK
    {
    public:
        //
        //   Public inline functions.
        //
        NO_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ /* void */ }

        INLINE VOID ClaimSharedLock( VOID )
			{ /* void */ }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ /* void */ }

		INLINE VOID ReleaseSharedLock( VOID )
 			{ /* void */ }

        ~NO_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        NO_LOCK( CONST NO_LOCK & Copy );

        VOID operator=( CONST NO_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Partial lock structure.                                        */
    /*                                                                  */
    /*   This class provides a partial locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class PARTIAL_LOCK
    {
        //
        // Private structures.
        //
		SPINLOCK                      Spinlock;

    public:
        //
        //   Public inline functions.
        //
        PARTIAL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

        ~PARTIAL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PARTIAL_LOCK( CONST PARTIAL_LOCK & Copy );

        VOID operator=( CONST PARTIAL_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Dll.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Dll.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control various debug settings.    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxDebugFileName		  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
LIST DLL::ActiveClasses;
SPINLOCK DLL::Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new entry so we can notify the class when a DLL       */
    /*   event occurs.                                                  */
    /*                                                                  */
    /********************************************************************/

DLL::DLL( FUNCTION NewFunction,VOID *NewParameter )
    {
	//
	//  Setup class values.
	//
	Function = NewFunction;
	Parameter = NewParameter;

	//
	//   Claim a lock to ensure the list does
	//   not become corrupt.
	//
	Spinlock.ClaimLock();

	//
	//   Add the current instance into the active 
	//   list so it will be notified of all future
	//   events.
	//
	Insert( & ActiveClasses );

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Standard DLL processing.                                       */
    /*                                                                  */
    /*   Automatically delete the private per thread heap on thread     */
    /*   exit when Rockall is compiled as a DLL.                        */
    /*                                                                  */
    /********************************************************************/

BOOL WINAPI DllMain
		(
		HINSTANCE					  Module,
		DWORD						  Reason,
		LPVOID						  Reserved 
		)
	{
	REGISTER DLL *Current;

	//
	//   Claim a lock to ensure the list does
	//   not become corrupt.
	//
	DLL::ClaimLock();

	//
	//   When Rockall is built for a DLL we use the 
	//   detach notification to delete the private
	//   per thread heap.
	//
	switch( Reason ) 
		{ 
		case DLL_PROCESS_ATTACH:
			{
#ifdef ENABLE_DEBUG_FILE
			AUTO CHAR FileName[ MaxDebugFileName ];

			//
			//   We will register the DLL name with the 
			//   debug trace code just in case any messages
			//   are generated.
			//
			if ( GetModuleFileName( Module,FileName,MaxDebugFileName ) != 0 )
				{ DebugFileName( FileName ); }

#endif
			//
			//   Notify all interested parties that
			//   a process has attached.
			//
			for 
					( 
					Current = ((DLL*) DLL::GetActiveClasses());
					Current != NULL;
					Current = ((DLL*) Current -> Next())
					)
				{ Current -> ProcessAttach(); }

			break;
			}

		case DLL_THREAD_ATTACH:
			{
			//
			//   Notify all interested parties that
			//   a thread has attached.
			//
			for 
					( 
					Current = ((DLL*) DLL::GetActiveClasses());
					Current != NULL;
					Current = ((DLL*) Current -> Next())
					)
				{ Current -> ThreadAttach(); }

			break;
			}

		case DLL_THREAD_DETACH:
			{
			//
			//   Notify all interested parties that
			//   a thread has dettached.
			//
			for 
					( 
					Current = ((DLL*) DLL::GetActiveClasses());
					Current != NULL;
					Current = ((DLL*) Current -> Next())
					)
				{ Current -> ThreadDetach(); }

			break;
			}

		case DLL_PROCESS_DETACH:
			{
			//
			//   Notify all interested parties that
			//   a process has dettached.
			//
			for 
					( 
					Current = ((DLL*) DLL::GetActiveClasses());
					Current != NULL;
					Current = ((DLL*) Current -> Next())
					)
				{ Current -> ProcessDetach(); }

			break;
			}
		}

	//
	//   Release the lock.
	//
	DLL::ReleaseLock();

	return TRUE;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Process attach callback.                                       */
    /*                                                                  */
    /*   When a process attach occurs the following callback is         */
    /*   executed.                                                      */
    /*                                                                  */
    /********************************************************************/

VOID DLL::ProcessAttach( VOID )
	{
	if ( Function != NULL )
		{ Function( Parameter,DLL_PROCESS_ATTACH ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Thread attach callback.                                        */
    /*                                                                  */
    /*   When a thread attach occurs the following callback is          */
    /*   executed.                                                      */
    /*                                                                  */
    /********************************************************************/

VOID DLL::ThreadAttach( VOID )
	{
	if ( Function != NULL )
		{ Function( Parameter,DLL_THREAD_ATTACH ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Thread dettach callback.                                       */
    /*                                                                  */
    /*   When a thread dettach occurs the following callback is         */
    /*   executed.                                                      */
    /*                                                                  */
    /********************************************************************/

VOID DLL::ThreadDetach( VOID )
	{
	if ( Function != NULL )
		{ Function( Parameter,DLL_THREAD_DETACH ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Process dettach callback.                                      */
    /*                                                                  */
    /*   When a process dettach occurs the following callback is        */
    /*   executed.                                                      */
    /*                                                                  */
    /********************************************************************/

VOID DLL::ProcessDetach( VOID )
	{
	if ( Function != NULL )
		{ Function( Parameter,DLL_PROCESS_DETACH ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a DLL.  This call is not thread safe and should        */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

DLL::~DLL( VOID )
    {
	//
	//   Claim a lock to ensure the list does
	//   not become corrupt.
	//
	Spinlock.ClaimLock();

	//
	//   Delete the current instance from the active 
	//   list so it will not be notified of future
	//   events.
	//
	Delete( & ActiveClasses );

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();

	//
	//   Delete class values.
	//
	Parameter = NULL;
	Function = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\hash.hpp ===
#ifndef _HASH_HPP_
#define _HASH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Include files for inherited classes.                           */
    /*                                                                  */
    /*   The include files for inherited classes are required in the    */
    /*   specification of this class.                                   */
    /*                                                                  */
    /********************************************************************/

#include "Common.hpp"
#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Macros exported from this class.                               */
    /*                                                                  */
    /*   This class has three template parameters so to make it more    */
    /*   readable a macro is specified here to simplify the code.       */
    /*                                                                  */
    /********************************************************************/

#define HASH_TEMPLATE				  class KEY,class TYPE,class LOCK 

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the map.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HashSize				  = 1024;
CONST SBIT32 MinHashFree			  = (100/25);
CONST SBIT32 ValueSize				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Hash table.                                                    */
    /*                                                                  */
    /*   This class provides general purpose hash table functions to    */
    /*   safely map sparse integer keys into some pointer or value.     */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE=NO_LOCK> class HASH : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            KEY                       Key;
            SBIT32                    Next;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxHash;
        SBIT32                        MaxValues;
        SBIT32                        ValuesUsed;

		SBIT32						  Active;
        VECTOR<SBIT32>                Hash;
		SBIT32						  HashMask;
		SBIT32						  HashShift;
        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Values;

    public:
        //
        //   Public functions.
        //
        HASH
			( 
			SBIT32                    NewMaxHash = HashSize, 
			SBIT32                    NewMaxValues = ValueSize, 
			SBIT32                    Alignment = 1 
			);

        VOID AddToHash( CONST KEY & Key, CONST TYPE & Value );

        VIRTUAL SBIT32 ComputeHashKey( CONST KEY & Key );

		BOOLEAN FindInHash( CONST KEY & Key, TYPE *Value );

		VIRTUAL BOOLEAN MatchingKeys( CONST KEY & Key1, CONST KEY & Key2 );

        VOID RemoveFromHash( CONST KEY & Key );

        ~HASH( VOID );

	private:
        //
        //   Private functions.
        //
		BOOLEAN FindHashKeyValue( CONST KEY & Key, SBIT32 **HashIndex );

		VOID Resize( VOID );

        //
        //   Disabled operations.
        //
        HASH( CONST HASH & Copy );

        VOID operator=( CONST HASH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new hash and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::HASH
		( 
		SBIT32						  NewMaxHash,
		SBIT32                        NewMaxValues,
		SBIT32                        Alignment
		) :
		//
		//   Call the constructors for the contained classes.
		//
		Hash( (COMMON::ForceToPowerOfTwo( NewMaxHash )),NoAlignment ),
		FreeStack( (NewMaxValues / 2) ),
		Values( NewMaxValues,Alignment )
    {
    if 
			( 
			(NewMaxHash > 0) 
				&& 
			(
			COMMON::ConvertDivideToShift
				( 
				(COMMON::ForceToPowerOfTwo( NewMaxHash )),
				& HashMask 
				)
			)
				&&
			(NewMaxValues > 0) 
			)
        {
		REGISTER SBIT32 Count;

		//
		//   Setup the hash table size information.
		//
        MaxHash = (COMMON::ForceToPowerOfTwo( NewMaxHash ));
        MaxValues = NewMaxValues;
        ValuesUsed = 0;

		//
		//   Zero the control values compute the
		//   hash table shift values.
		//
		Active = 0;
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		for( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
        }
    else
        { Failure( "Max sizes in constructor for HASH" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add to the hash table.                                         */
    /*                                                                  */
    /*   We add an key to the hash table if it does not already exist.  */
    /*   Then we add (or update) the current value.  If the is not      */
    /*   space we expand the size of the 'Values' table.                */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::AddToHash
        (
		CONST KEY					  & Key,
        CONST TYPE					  & Value 
        )
    {
	AUTO SBIT32 *HashIndex;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	if ( ! FindHashKeyValue( Key, & HashIndex ) )
		{
		AUTO SBIT32 NewIndex;
		REGISTER VALUE *NewValue;

		//
		//   Extract a free element from the stack.
		//   If the stack is empty then allocated one
		//   from the array.
		//
		if ( ! FreeStack.PopStack( & NewIndex ) )
			{
			//
			//   If the array is full then resize it.
			//   We need to be careful here as a resize
			//   can change the address of the 'Values'
			//   array.
			//
			if ( (NewIndex = ValuesUsed ++) >= MaxValues  )
				{ Values.Resize( (MaxValues *= ExpandStore) ); }
			}

		//
		//   Add the new element into the hash table
		//   and link it into any overflow chains.
		//
		NewValue = & Values[ NewIndex ];

		Active ++;

		//
		//   Link in the new element.
		//
		NewValue -> Key = Key;
		NewValue -> Next = (*HashIndex);
		(*HashIndex) = NewIndex;
		NewValue -> Value = Value;
		}
	else
		{ Values[ (*HashIndex) ].Value = Value; }

	//
	//   If the hash table has grown too big we
	//   resize it.
	//
	if ( (Active + (MaxHash / MinHashFree)) > MaxHash )
		{ Resize(); }

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the hash key.                                          */
    /*                                                                  */
    /*   Compute a hash value from the supplied key.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> SBIT32 HASH<KEY,TYPE,LOCK>::ComputeHashKey
        (
		CONST KEY					  & Key
        )
	{
	//
	//   When the key is larger than an integer the we need 
	//   to do a bit more work.
	//
	if ( sizeof(KEY) > sizeof(SBIT32) )
		{
		REGISTER SBIT64 FullValue = ((SBIT64) (*((KEY*) & Key)));
		REGISTER SBIT32 HighWord = ((SBIT32) (FullValue >> 32));
		REGISTER SBIT32 LowWord = ((SBIT32) FullValue);

		//
		//   We compute the hash key using both the high
		//   and low order words.
		//
		return ((HighWord * 2964557531) + (LowWord * 2964557531) + 1);
		}
	else
		{ return ((((SBIT32) (*((KEY*) & Key))) * 2964557531) + 1); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a key in the hash table.                                  */
    /*                                                                  */
    /*   Find a key in the hash table and return the associated value.  */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindInHash
        (
		CONST KEY					  & Key,
        TYPE						  *Value 
        )
    {
	AUTO SBIT32 *Index;
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the key in the hash table.
	//
	if ( (Result = FindHashKeyValue( Key,& Index )) )
		{ (*Value) = Values[ (*Index) ].Value; }

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the hash key value.                                       */
    /*                                                                  */
    /*   Find the value associated with the supplied hash key.          */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindHashKeyValue
        (
		CONST KEY					  & Key,
		SBIT32                        **Index
        )
	{
	REGISTER SBIT32 *Current;
	REGISTER VALUE *List;

	//
	//   Find the bucket in the hash table that should
	//   contain this key.
	//
	(*Index) = & Hash[ ((ComputeHashKey( Key ) >> HashShift) & HashMask) ];

	//
	//   Walk the overflow chain and look for the key.
	//
	for ( Current = (*Index);(*Current) != EndOfList;Current = & List -> Next )
		{
		List = & Values[ (*Current) ];

		//
		//   If the keys match we are out of here.
		//
		if ( MatchingKeys( Key,List -> Key ) )
			{
			(*Index) = Current;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hask keys.       .                                 */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::MatchingKeys
        (
		CONST KEY					  & Key1,
		CONST KEY					  & Key2
        )
	{ return ((*((KEY*) & Key1)) == (*((KEY*) & Key2))); }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a key from the hash table.                              */
    /*                                                                  */
    /*   The supplied key is removed from the hash table (if it exists) */
    /*   and the associated value is deleted.                           */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::RemoveFromHash
        (
		CONST KEY					  & Key
        )
    {
	AUTO SBIT32 *Index;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Find the key in the hash table..  If it 
	//   exists then delete it.
	//
	if ( FindHashKeyValue( Key,& Index ) )
		{
		Active --;

		FreeStack.PushStack( (*Index) );

		(*Index) = Values[ (*Index) ].Next;
		}

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the hash table.                                         */
    /*                                                                  */
    /*   The hash table is resized if it becomes more than 75% full     */
    /*   and all the keys are rehashed.                                 */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::Resize( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 List = EndOfList;

	//
	//   Walk the hash table and link all the active
	//   values into a single linked list.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{
		REGISTER SBIT32 Start = Hash[ Count ];

		//
		//   We know that some of the hash buckets may
		//   be empty so we skip these.
		//
		if ( Start != EndOfList )
			{
			REGISTER SBIT32 Last = Start;

			//
			//   Walk along the overflow chain until
			//   we find the end.
			//
			while ( Values[ Last ].Next != EndOfList )
				{ Last = Values[ Last ].Next; }
			
			//
			//   Add the list on the front of the new
			//   global list.
			//   
			Values[ Last ].Next = List;
			List = Start;
			}
		}

	//
	//   Resize the hash table.
	//
	Hash.Resize( (MaxHash *= ExpandStore) );

    if ( COMMON::ConvertDivideToShift( MaxHash,& HashMask ) )
        {
		REGISTER SBIT32 Count;

		//
		//   Update the shift values.
		//
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		//
		//   Zero the resized table.
		//  
		for ( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
		}
	else
		{ Failure( "Hash size in Resize" ); }

	//
	//   Rehash all the existing values.
	//
	while ( List != EndOfList )
		{
		AUTO SBIT32 *Index;
		REGISTER VALUE *Current = & Values[ List ];
		REGISTER SBIT32 Next = Current -> Next;

		if ( ! FindHashKeyValue( Current -> Key,& Index ) )
			{
			Current -> Next = (*Index);
			(*Index) = List;
			List = Next;
			}
		else
			{ Failure( "Duplicate hash key in Risize" ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the hash.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::~HASH( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\librarypch.hpp ===
#ifndef _LIBRARY_PCH_HPP_
#define _LIBRARY_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Align.hpp"
#include "Assembly.hpp"
#include "Autolock.hpp"
#include "Barrier.hpp"
#include "CallStack.hpp"
#include "Common.hpp"
#include "Delay.hpp"
#include "Dll.hpp"
#include "Environment.hpp"
#include "Global.hpp"
#include "Globallock.hpp"
#include "Hash.hpp"
#include "List.hpp"
#include "Lock.hpp"
#include "Map.hpp"
#include "New.hpp"
#include "Pool.hpp"
#include "Prefetch.hpp"
#include "Queue.hpp"
#include "References.hpp"
#include "Semaphore.hpp"
#include "Sharelock.hpp"
#include "SList.hpp"
#include "SortedFind.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Standard.hpp"
#include "String.hpp"
#include "System.hpp"
#include "Thread.hpp"
#include "Tlc.hpp"
#include "Tls.hpp"
#include "Unique.hpp"
#include "Vector.hpp"
#include "Wait.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\prefetch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Prefetch.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
BOOLEAN PREFETCH::Active =
	(
	(BOOLEAN) IsProcessorFeaturePresent
		( 
		PF_XMMI_INSTRUCTIONS_AVAILABLE
		)
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\prefetch.hpp ===
#ifndef _PREFETCH_HPP_
#define _PREFETCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch a cache line.				                            */
    /*                                                                  */
    /*   Support of data prefetch on the Pentium III or better.         */
    /*                                                                  */
    /********************************************************************/

class PREFETCH : public ASSEMBLY
    {
#ifdef ASSEMBLY_X86
        //
        //   Static private data.
        //
        STATIC BOOLEAN		          Active;

#endif
    public:
        //
        //   Public inline functions.
        //
        PREFETCH( VOID )
			{ /* void */ }

		STATIC INLINE VOID L1( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L2( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L3( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID Nta( CHAR *Address,SBIT32 Size );

        ~PREFETCH( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PREFETCH( CONST PREFETCH & Copy );

        VOID operator=( CONST PREFETCH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L1( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL1( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L2.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L2 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L2( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL2( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L3.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L3 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L3( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL3( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::Nta( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchNta( Address ); }
		}
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\global.hpp ===
#ifndef _GLOBAL_HPP_
#define _GLOBAL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Features.hpp"
#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The standard macros.                                           */
    /*                                                                  */
    /*   The following are standard macros used by various              */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

#define FIELDOFFSET( Type,Field )	  ((SBIT16) & (((Type *)0) -> Field))
#define TO_DO( Message ) message ( "---- To do ---->>>> " Message )

#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#define TRY							  try
#else
#define TRY							  __try
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The standard constants.                                        */
    /*                                                                  */
    /*   The following are standard constants used by various           */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

	//
	//   The hardware cache line size.
	//
CONST SBIT32 CacheLineSize			  = SELECT_CACHE_LINE_SIZE;
CONST SBIT32 CacheLineMask			  = (CacheLineSize - 1);
CONST SBIT32 NoAlignment			  = 1;

	//
	//   The end of a linked list.
	//
CONST INT EndOfList					  = -1;

	//
	//   The boolean constants.
	//
CONST BOOLEAN False					  = 0;
CONST BOOLEAN True					  = 1;

	//
	//   Various misc constants.
	//
CONST INT ExpandStore				  = 2;
CONST INT MaxCpus					  = 32;
CONST INT NoFlags					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/
#ifdef ENABLE_DEBUG_FILE

HANDLE DebugFileHandle( VOID );

VOID DebugFileName( CONST CHAR *FileName );
#endif

VOID DebugPrint( CONST CHAR *Format,... );

VOID Failure( char *Message,BOOLEAN Report = True );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\list.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new linked list element.                              */
    /*                                                                  */
    /********************************************************************/

LIST::LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an element.                                             */
    /*                                                                  */
    /*   Delete the current element.                                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Delete( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == HeadOfList )
		{
#endif
		//
		//   Relink the forward chain.
		//
		if ( Forward != NULL )
			{ Forward -> Backward = Backward; }
		else
			{ HeadOfList -> Backward = Backward; }

		//
		//   Relink the backward chain.
		//
		if ( Backward != NULL )
			{ Backward -> Forward = Forward; }
		else
			{ HeadOfList -> Forward = Forward; }

		//
		//   Reset the list elements.
		//
		Forward = NULL;
		Backward = NULL;
#ifdef DEBUGGING
		Head = NULL;
		}
	else
		{ Failure( "No active linked list element in Delete" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a list element at the head of the list.                 */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Insert( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == NULL )
		{
#endif
		//
		//   Insert the new element at the front of the list.
		//
		if ( (Forward = HeadOfList -> Forward) == NULL )
			{ 
			HeadOfList -> Forward = this;
			HeadOfList -> Backward = this; 
			}
		else
			{ 
			HeadOfList -> Forward -> Backward = this; 
			HeadOfList -> Forward = this;
			}

		//
		//   Set the other pointers as needed.
		//
		Backward = NULL;
#ifdef DEBUGGING
		Head = HeadOfList;
		}
	else
		{ Failure( "List element already in use in Insert" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a new list element before the current element.          */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertBefore( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a previous element we must
				//   make it point at the new element.  If
				//   not we are the first element in the 
				//   list so update the head.
				//
				if ( Backward != NULL )
					{ Backward -> Forward = NewList; }
				else
					{ HeadOfList -> Forward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Backward = Backward;
				NewList -> Forward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Backward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertBefore" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertBefore" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert an element.                                             */
    /*                                                                  */
    /*   Insert a new list element after the current element.           */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertAfter( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a next element we must
				//   make it point at the new element.  If
				//   not we are the last element in the 
				//   list so update the head.
				//
				if ( Forward != NULL )
					{ Forward -> Backward = NewList; }
				else
					{ HeadOfList -> Backward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Forward = Forward;
				NewList -> Backward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Forward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertAfter" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertAfter" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset a list element.                                          */
    /*                                                                  */
    /*   Reset a list element without any questions.                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Reset( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a linked list element.                                 */
    /*                                                                  */
    /********************************************************************/

LIST::~LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\list.hpp ===
#ifndef _LIST_HPP_
#define _LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A generic linked list.                                         */
    /*                                                                  */
    /*   There are a significant number of situations where objects     */
    /*   need to be linked together.  The objects may be of the same    */
    /*   or diffrent types so the class specified here is intended      */
    /*   to be used as base class so as to make supporting this easy.   */
    /*                                                                  */
    /********************************************************************/

	//
	//   Template this like SList to allow multiple
	//   linked lists in a single structure.  Then
	//   remove the linked list hackj from Rockall.
	//
class LIST
    {
		//
		//   Private data.
		//
 		LIST						  *Backward;
 		LIST						  *Forward;
#ifdef DEBUGGING
		LIST						  *Head;
#endif

   public:
        //
        //   Public functions.
        //
        LIST( VOID );

		VOID Delete( LIST *HeadOfList );

		VOID Insert( LIST *HeadOfList );

		VOID InsertBefore( LIST *HeadOfList,LIST *NewList );

		VOID InsertAfter( LIST *HeadOfList,LIST *NewList );

		VOID Reset( VOID );

        ~LIST( VOID );

		//
		//   Public line functions.
		//
		INLINE BOOLEAN StartOfList( VOID )
			{ return (Backward == NULL); }

		INLINE LIST *First( VOID )
			{ return Forward; }

		INLINE LIST *Last( VOID )
			{ return Backward; }

		INLINE LIST *Next( VOID )
			{ return Forward; }

		INLINE LIST *Previous( VOID )
			{ return Backward; }

		INLINE BOOLEAN EndOfList( VOID )
			{ return (Forward == NULL); }

	private:
        //
        //   Disabled operations.
        //
        LIST( CONST LIST & Copy );

        VOID operator=( CONST LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\map.hpp ===
#ifndef _MAP_HPP_
#define _MAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The map constants specify the initial size of the map.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MapSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Maps and map management.                                       */
    /*                                                                  */
    /*   This class provides general purpose mapping functions to       */
    /*   safely convert handles into some pointer or value.             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class MAP : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            BOOLEAN                   Available;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxMap;
        SBIT32                        MapUsed;

        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Map;

    public:
        //
        //   Public functions.
        //
        MAP( SBIT32 NewMaxMap = MapSize, SBIT32 Alignment = 1 );

        SBIT32 NewHandle( CONST TYPE & Value );

		BOOLEAN FindHandle
			( 
			SBIT32                        Handle, 
			TYPE                          *Value 
			);

		VOID DeleteHandle( SBIT32 Handle );

        ~MAP( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 MaxHandles( VOID )
			{ return MapUsed; }

	private:
        //
        //   Disabled operations.
        //
        MAP( CONST MAP & Copy );

        VOID operator=( CONST MAP & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new map and prepare it for use.  This call is         */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::MAP
		( 
		SBIT32						  NewMaxMap,
		SBIT32						  Alignment 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		FreeStack( NewMaxMap ), 
		Map( NewMaxMap,Alignment,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxMap > 0 )
        {
#endif
        MaxMap = NewMaxMap;
        MapUsed = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Max map size in constructor for MAP" ); }
#endif
    }

	/********************************************************************/
    /*                                                                  */
    /*   Create a new handle.                                           */
    /*                                                                  */
    /*   We create a new handle for the supplied value.                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 MAP<TYPE,LOCK>::NewHandle
		( 
		CONST TYPE					  & Value 
		)
    {
	AUTO SBIT32 Handle;
	REGISTER VALUE *NewValue;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Expand the mapping table if it is too
	//   small be resizing it.
	//
	if ( ! FreeStack.PopStack( & Handle ) )
		{
		if ( (Handle = MapUsed ++) >= MaxMap )
			{ Map.Resize( (MaxMap *= ExpandStore) ); }
		}

	//
	//   Link in the new mapping.
	//
	NewValue = & Map[ Handle ];

	NewValue -> Available = True;
	NewValue -> Value = Value;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();

	return Handle;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the value associated with a handle.                       */
    /*                                                                  */
    /*   We find the value associated with the supplied handle.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN MAP<TYPE,LOCK>::FindHandle
        ( 
        SBIT32                        Handle, 
        TYPE                          *Value 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the handle and return the associated value.
	//
	Result = 
		( 
		((Handle >= 0) && (Handle < MaxMap))
			&& 
		(Map[ Handle ].Available) 
		);

	if ( Result )
		{ (*Value) = Map[ Handle ].Value; }

	//
	//   Release any lock claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a handle.                                               */
    /*                                                                  */
    /*   We delete the supplied handle and the associated value.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID MAP<TYPE,LOCK>::DeleteHandle
		( 
        SBIT32                        Handle
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the handle is valid then delete any
	//   associated value.
	//
	if ( (Handle >= 0) && (Handle < MaxMap) && (Map[ Handle ].Available) )
		{
		Map[ Handle ].Available = False;
		FreeStack.PushStack( Handle );
		}
	else
		{ Failure( "No mapping in DeleteMapHandle()" ); } 

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the map.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::~MAP( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\new.hpp ===
#ifndef _NEW_HPP_
#define _NEW_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())
#ifndef DISABLE_GLOBAL_NEW

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/

VOID *operator new( size_t Size );
VOID *operator new[]( size_t Size );
VOID operator delete( VOID *Store );
VOID operator delete[]( VOID *Store );
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\queue.hpp ===
#ifndef _QUEUE_HPP_
#define _QUEUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Common.hpp"
#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The queue constants specify the initial size of the queue.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 QueueSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Queues and queue management.                                   */
    /*                                                                  */
    /*   This class provides general purpose queues along with some     */
    /*   basic management.  The queues are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a queue at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class QUEUE : public COMMON, public LOCK
    {
        //
        //   Private data.
        //
        SBIT32						  MaxSize;

		BOOLEAN						  Align;
        SBIT32						  Mask;

        SBIT32						  Back;
        SBIT32						  Front;

        VECTOR<TYPE>                  Queue;

    public:
        //
        //   Public functions.
        //
        QUEUE( SBIT32 NewMaxSize = QueueSize,BOOLEAN NewAlign = True );

        BOOLEAN MultiplePopBackOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        BOOLEAN MultiplePopFrontOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        VOID MultiplePushBackOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        VOID MultiplePushFrontOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        BOOLEAN PeekBackOfQueue( TYPE *Data );

        BOOLEAN PeekFrontOfQueue( TYPE *Data );

        BOOLEAN PopBackOfQueue( TYPE *Data );

        BOOLEAN PopFrontOfQueue( TYPE *Data );

        VOID PushBackOfQueue( CONST TYPE & Data );

        VOID PushFrontOfQueue( CONST TYPE & Data );

		SBIT32 SizeOfQueue( VOID );

        ~QUEUE( VOID );

		//
		//   Public inline functions.
		//
        INLINE BOOLEAN MultiplePopQueue
				( 
				SBIT32				  Requested, 
				TYPE				  Data[], 
				SBIT32				  *Size 
				)
			{ return MultiplePopFrontOfQueue( Requested,Data,Size ); }

        INLINE VOID MultiplePushQueue
				( 
				CONST TYPE			  Data[], 
				CONST SBIT32		  Size 
				)
			{ MultiplePushBackOfQueue( Data,Size ); }

        INLINE BOOLEAN PeekQueue( TYPE *Data )
			{ return PeekFrontOfQueue( Data ); }

        INLINE BOOLEAN PopQueue( TYPE *Data )
			{ return PopFrontOfQueue( Data ); }

        INLINE VOID PushQueue( CONST TYPE & Data )
			{ PushBackOfQueue( Data ); }

	private:
		//
		//   Private functions.
		//
		VOID ExpandQueue( VOID );

        //
        //   Disabled operations.
        //
        QUEUE( CONST QUEUE & Copy );

        VOID operator=( CONST QUEUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new queue and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::QUEUE
		( 
		SBIT32						  NewMaxSize,
		BOOLEAN						  NewAlign 
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		Align = NewAlign;
        Mask = 0x7fffffff;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Compute the alignment mask.
		//
		if 
				(
				((sizeof(TYPE) > 0) && (sizeof(TYPE) <= CacheLineSize))
					&&
				(PowerOfTwo( sizeof(TYPE) ))
				)
			{ Mask = ((CacheLineSize / sizeof(TYPE))-1); }
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for QUEUE" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand a queue.                                                */
    /*                                                                  */
    /*   When a queue becomes full we need to expand it and to copy     */
    /*   the tail end of the queue into the correct place.              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::ExpandQueue( VOID )
    {
    REGISTER SBIT32 Count;
    REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

	//
	//   Expand the queue (it will be at least doubled).
	//
    Queue.Resize( NewSize );

	//
	//   Copy the tail end of the queue to the correct
	//   place in the expanded queue.
	//
    for ( Count = 0;Count < Back;Count ++ )
        { Queue[ (MaxSize + Count) ] = Queue[ Count ]; }

	//
	//   Update the control information.
	//
    Back += MaxSize;
    MaxSize = NewSize;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the back of the queue.                 */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopBackOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing a cache  
	//   line at the same time.  Here we modify the request  
	//   to pop exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = (Back & Mask);

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && (Front <= (Back - Requested))) 
                || 
            ((Front > Back) && ((Back - Requested) >= 0)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ -- Back ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
				 if ( Back <= 0 )
					{ Back = MaxSize; }

                Data[ Count ] = Queue[ -- Back ];
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the front of the queue.                */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopFrontOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing cache  
	//   lines at the same time.  Here we modify the request  
	//   to access exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = ((Mask + 1) - (Front & Mask));

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front + Requested) <= Back)) 
                || 
            ((Front > Back) && ((Front + Requested) < MaxSize)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ Front ++ ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;
        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
                Data[ Count ] = Queue[ Front ++ ];

                if ( Front >= MaxSize )
                    { Front = 0; }
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the back of the queue.                */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushBackOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Back + Size) < MaxSize)) 
                || 
            ((Front > Back) && (Front > (Back + Size))) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ Back ++ ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the front of the array.
            //
            Queue[ Back ++ ] = Data[ Count ];

             if ( Back >= MaxSize )
                { Back = 0; }

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the front of the queue.               */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushFrontOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front - Size) >= 0)) 
                || 
            ((Front > Back) && ((Front - Size) > Back)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ -- Front ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count = 0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the back of the array.
            //
			 if ( Front <= 0 )
				{ Front = MaxSize; }

			Queue[ -- Front ] = Data[ Count ];

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the back of the queue.                                    */
    /*                                                                  */
    /*   We return the end of the queue but check to make sure          */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the last element.
	//
    if ( Front != Back )
		{
		//
		//   The 'Back' index points at the next free cell.
		//   So the last element is 'Back - 1'.  However,
		//   when 'Back' is zero we need to wrap.
		//
		if ( Back > 0 )
			{ (*Data) = Queue[ (Back - 1) ]; }
		else
			{ (*Data) = Queue[ (MaxSize - 1) ]; }
	
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the front of the queue.                                   */
    /*                                                                  */
    /*   We return the front of the queue but check to make sure        */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the first element.
	//
    if ( Front != Back )
		{ 
		(*Data) = Queue[ Front ];
		
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the back of the queue.                        */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
         if ( Back <= 0 )
            { Back = MaxSize; }

       (*Data) = Queue[ -- Back ];

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the front of the queue.                       */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
        (*Data) = Queue[ Front ++ ];

        if ( Front >= MaxSize )
            { Front = 0; }

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the back of the queue.                       */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushBackOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Queue[ Back ++ ] = Data;

     if ( Back >= MaxSize )
        { Back = 0; }

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the front of the queue.                      */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushFrontOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the back of the array.
    //
     if ( Front <= 0 )
        { Front = MaxSize; }

    Queue[ -- Front ] = Data;

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the queue.                               */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*   This is only used when the size is needed in all other cases   */
    /*   we just try to remove the elements in the queue.               */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 QUEUE<TYPE,LOCK>::SizeOfQueue( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Compute the size of the queue.
	//
	Size = (Back - Front);

	if ( Size < 0 )
		{ Size += MaxSize; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseSharedLock();

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::~QUEUE( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\References.hpp ===
#ifndef _REFERENCES_HPP_
#define _REFERENCES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The empty class.                                               */
    /*                                                                  */
    /*   The empty class is a useful device to allow a class to         */
    /*   appear at may levels in an inheritance heirarchy.              */
    /*                                                                  */
    /********************************************************************/

class EMPTY_CLASS
    {
    public:
        //
        //   Public inline functions.
        //
        EMPTY_CLASS( VOID )
			{ /* void */ }

        VIRTUAL ~EMPTY_CLASS( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        EMPTY_CLASS( CONST EMPTY_CLASS & Copy );

        VOID operator=( CONST EMPTY_CLASS & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Automated reference counting.                                  */
    /*                                                                  */
    /*   When we need to reference count an object we can use this      */
    /*   class to keep track of the references.                         */
    /*                                                                  */
    /********************************************************************/

template <class BASE=EMPTY_CLASS> class REFERENCES : public BASE
    {
		//
		//   Private data.
		//
		SBIT32						  References;

    public:
        //
        //   Public inline functions.
        //
        REFERENCES( VOID )
			{ References = 1; }

		INLINE SBIT32 GetReferences( VOID )
			{ return References; }

		INLINE SBIT32 Increment( VOID )
			{ return AtomicIncrement( & References ); }

		INLINE SBIT32 Decrement( VOID )
			{
			REGISTER SBIT32 Result = AtomicDecrement( & References );
			//
			//   Delete the entire object after
			//   the last reference is removed.
			//
			if ( Result == 0 )
				{ delete this; }

			return Result;
			}

        VIRTUAL ~REFERENCES( VOID )
			{
			//
			//   We really should have no outstanding
			//   references at this point.
			//
			if ( References != 0 )
				{ Failure( "References in destructor for REFERENCES" ); } 
			}

	private:
        //
        //   Disabled operations.
        //
        REFERENCES( CONST REFERENCES & Copy );

        VOID operator=( CONST REFERENCES & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\pool.hpp ===
#ifndef _POOL_HPP_
#define _POOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Delay.hpp"
#include "Lock.hpp"
#include "New.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinPoolSize			  = 64;
CONST SBIT16 PoolStackSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class POOL : public LOCK
    {
		//
		//   Private type definitions.
		//
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        DELAY< VECTOR<TYPE_SIZE> >    Delay;
		STACK<POINTER>				  Stack;

    public:
        //
        //   Public functions.
        //
        POOL( SBIT32 NewMinSize = MinPoolSize );

        TYPE **MultiplePopPool
            ( 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID MultiplePushPool
            ( 
            CONST TYPE					  *Type[], 
            CONST SBIT32				  Size 
            );

        TYPE *PopPool( VOID );

        VOID PushPool( CONST TYPE *Type );

        ~POOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 MaxSize );

        //
        //   Disabled operations.
        //
        POOL( CONST POOL & Copy );

        VOID operator=( CONST POOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::POOL( SBIT32 NewMinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMinSize )
    {
#ifdef DEBUGGING
    if ( NewMinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        MaxSize = 0;
        MinSize = NewMinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "Min size in constructor for POOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID POOL<TYPE,LOCK>::ExpandSize
		( 
		SBIT32						  NewSize 
		)
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	REGISTER SBIT32 ActualSize =
		((NewSize <= MinSize) ? MinSize : NewSize);
	REGISTER VECTOR<TYPE> *NewBlock =
		(
		(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
			( 
			ActualSize, 
			CacheLineSize,
			CacheLineSize
			)
		);

	//
	//   We need to keep a note of the number of elements 
	//   we have allocated thus far.
	//
    MaxSize += ActualSize;

	//
	//   We put the address of each element we allocate on
	//   a stack to enable high speed allocation and 
	//   deallocation.
	//
    for 
			( 
			Count1 = 0;
			Count1 < ActualSize;
			Count1 += PoolStackSize 
			)
        {
		AUTO POINTER NewCalls[ PoolStackSize ];

		//
		//   We add elements to the stack in blocks
		//   to reduce the number of call to the
		//   stack code.
		//
        for 
				( 
				Count2 = 0;
				((Count1 + Count2) < ActualSize)
					&&
				(Count2 < PoolStackSize);
				Count2 ++ 
				)
            {
			REGISTER TYPE *NewCall =
				(
                & (*NewBlock)[ (Count1 + Count2) ]
				);
                 
            NewCalls[ Count2 ] = (POINTER) NewCall;
            }

		//
		//   Add the next block for free work packets to
		//   the global free stack.
		//
        Stack.MultiplePushStack
            ( 
            NewCalls,
            Count2 
            );
        }

    //
    //   Add the newly allocated block to the list of
    //   things to be deleted when this class is deleted.
    //
    Delay.DeferedDelete( ((VECTOR<TYPE_SIZE>*) NewBlock) );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We allocate a multiple elements from the allocation pool.      */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE **POOL<TYPE,LOCK>::MultiplePopPool
        ( 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	AUTO TYPE *Type[ PoolStackSize ];
	REGISTER SBIT32 Count;

	//
	//   Compute the actual request size.
	//
	Requested = ((Requested <= PoolStackSize) ? Requested : PoolStackSize);

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Extract as may elements from the stack as possible.
	//   If the stack is empty then allocate more.
	//
	while ( ! Stack.MultiplePopStack( Requested,(POINTER*) Type,Size ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructors.
	//
	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We push multiple existing elements into the pool for reuse.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::MultiplePushPool
        ( 
        CONST TYPE					  *Type[],
        CONST SBIT32				  Size 
        )
	{
	REGISTER SBIT32 Count;
	
	//
	//   Call the destructors.
	//
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Type[ Count ],TYPE ); }


	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the elements back onto the free stack.
	//
	Stack.MultiplePushStack( (POINTER*) Type,Size ); 

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We allocate a new element from the allocation pool.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE *POOL<TYPE,LOCK>::PopPool( VOID )
    {
	AUTO TYPE *Type;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   We pop an element off the stack if the
	//   stack is empty we create more elements.
	//
	while ( ! Stack.PopStack( (POINTER*) & Type ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructor.
	//
	(VOID) PLACEMENT_NEW( Type, TYPE );

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We push an existing element into the pool for reuse.           */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::PushPool
		( 
		CONST TYPE					  *Type 
		)
	{
	//
	//   Call the destructor.
	//
	PLACEMENT_DELETE( Type,TYPE );

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the element back onto the free stack.
	//
	Stack.PushStack( (POINTER) Type );

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::~POOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\sharelock.hpp ===
#ifndef _SHARELOCK_HPP_
#define _SHARELOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Sharelock and Semaphore locking.                               */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  A lock can be obtained in         */
    /*   either exclusive mode or shared mode.  If the lock is not      */
    /*   available the caller waits by spinning or if that fails        */
    /*   by sleeping.                                                   */
    /*                                                                  */
    /********************************************************************/

class SHARELOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		CACHE_ALIGNMENT SBIT32        MaxSpins;
		SBIT32                        MaxUsers;

        VOLATILE SBIT32               ExclusiveUsers;
        VOLATILE SBIT32               TotalUsers;

        SEMAPHORE                     NormalSemaphore;
        VOLATILE SBIT32               NormalWaiting;
        SEMAPHORE                     PrioritySemaphore;
        VOLATILE SBIT32               PriorityWaiting;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;

#endif
#ifdef ENABLE_LOCK_STATISTICS
        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalExclusiveLocks;
        VOLATILE SBIT32               TotalShareLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SHARELOCK
			( 
			SBIT32					  NewMaxSpins = DefaultMaxSpins, 
			SBIT32					  NewMaxThreads = DefaultMaxThreads, 
			SBIT32					  NewMaxUsers = DefaultMaxUsers 
			);

        BOOLEAN UpdateMaxSpins( SBIT32 NewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 NewMaxUsers );

        ~SHARELOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 ActiveUsers( VOID ) 
			{ return ((SBIT32) TotalUsers); }

		//
		//   Public inline functions (see below).
		//
        INLINE VOID ChangeExclusiveLockToSharedLock( VOID );

        INLINE BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimShareLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseExclusiveLock( VOID );

        INLINE VOID ReleaseShareLock( VOID );

    private:
        //
        //   Private functions.
        //
        BOOLEAN SleepWaitingForLock
			( 
			SEMAPHORE				  *Semaphore,
			SBIT32					  Sleep,
			VOLATILE SBIT32			  *Waiting 
			);

        BOOLEAN WaitForExclusiveLock( SBIT32 Sleep );

        BOOLEAN WaitForShareLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Private inline functions.
        //
		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        //
        //   Disabled operations.
        //
        SHARELOCK( CONST SHARELOCK & Copy );

        VOID operator=( CONST SHARELOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Change an exclusive lock to a shared lock.                     */
    /*                                                                  */
    /*   Downgrade the existing exclusive lock to a shared lock.        */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ChangeExclusiveLockToSharedLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Simply decrement the exclusive count.
		//   This allows the lock to be shared.
		//
		(VOID) AtomicDecrement( & ExclusiveUsers );

		//
		//   Wakeup anyone who is asleep waiting.  We
		//   need to be very careful here as in very
		//   rare situations the waiting counts can
		//   be negative for very brief periods.
		//
		if ( (PriorityWaiting > 0) || (NormalWaiting > 0) )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Change a shared lock to an exclusive lock.                     */
    /*                                                                  */
    /*   Upgrade the existing shared lock to an exclusive lock.         */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ChangeSharedLockToExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif		
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared.
		//
		(VOID) AtomicIncrement( & ExclusiveUsers );

		//
		//   If the total number of users is one then
		//   we have the lock exclusively otherwise we
		//   may need to wait.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim an exclusive lock.                                       */
    /*                                                                  */
    /*   Claim an exclusive lock if available else wait or exit.        */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.  We need
		//   update the total number of users first to
		//   avoid a deadlock when real-time priorites
		//   are being used.  If not then an interupt
		//   can occur after the update of the 
		//   'ExclusiveUsers' count but before the 
		//   'TotalUsers' count that will prevent
		//   another thread from getting the lock or
		//   sleeping (i.e. a live lock).
		//
		AtomicDoubleIncrement( & ExclusiveUsers );

		//
		//   Lets see if we have got the lock.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a shared lock.                                           */
    /*                                                                  */
    /*   Claim a shared lock if available else wait or exit.            */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimShareLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
		(VOID) AtomicIncrement( & TotalUsers );

		//
		//   Lets see if we have got the lock.
		//
		if ( (ExclusiveUsers > 0) || (TotalUsers > MaxUsers) )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif

	return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release an exclusive lock.                                     */
    /*                                                                  */
    /*   Release an exclusive lock and if needed wakeup any sleepers.   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseExclusiveLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Release an exclusive lock.
		//
		AtomicDoubleDecrement( & ExclusiveUsers );

		//
		//   Wakeup anyone who is asleep waiting.  We
		//   need to be very careful here as in very
		//   rare situations the waiting counts can
		//   be negative for very brief periods.
		//
		if ( (PriorityWaiting > 0) || (NormalWaiting > 0) )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock.                                         */
    /*                                                                  */
    /*   Release a shared lock and if needed wakeup any sleepers.       */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseShareLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
#endif
		//
		//   Release a shared lock.
		//
#ifdef DEBUGGING
		if ( AtomicDecrement( & TotalUsers ) < 0 )
			{ Failure( "Negative lock count in ReleaseShareLock" ); }
#else
		AtomicDecrement( & TotalUsers );
#endif

		//
		//   Wakeup anyone who is asleep waiting.  We
		//   need to be very careful here as in very
		//   rare situations the waiting counts can
		//   be negative for very brief periods.
		//
		if ( (PriorityWaiting > 0) || (NormalWaiting > 0) )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Semaphore.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Semaphore.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new semaphore and initialize it.  This call is not    */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SEMAPHORE::SEMAPHORE( SBIT32 NewMaxThreads )
    {
	//
	//   We need to ensure that the number of threads
	//   makes sense.
	//
	if ( NewMaxThreads > 0 )
		{
		//
		//   Setup class control information.
		//
		MaxThreads = NewMaxThreads;
		Semaphore = NULL;
		Signals = 0;
		Waiting = 0;
		}
	else
		{ Failure( "Max threads in constructor for SEMAPHORE" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Signal a semaphore.                                            */
    /*                                                                  */
    /*   Signal a semaphore to wake sleeping threads.  We go to some    */
    /*   trouble to deal with the interesting case were the OS will     */
    /*   not allow us to create an OS semaphore.                        */
    /*                                                                  */
    /********************************************************************/

VOID SEMAPHORE::Signal( SBIT32 Count )
    {
	//
	//   We need to find out whether there is an existing
	//   semaphore.  If not then things can be tricky.
	//
	if ( Semaphore == NULL )
		{
		//
		//   When we don't have a semaphore we increment
		//   a counter.
		//
		AtomicAdd( & Signals,Count );

		//
		//   We need to be sure that there is no race
		//   condition where a semaphore is created at
		//   the same time it is signaled.  If so we
		//   update the semaphore.
		//
		if ( Semaphore != NULL )
			{ UpdateSemaphore(); }
		}
	else
		{
		//
		//   When we have an existing semaphore things
		//   are easy.  We just update it.
		//
		if ( ! ReleaseSemaphore( Semaphore,Count,NULL ) )
			{ Failure( "Wakeup failed in Signal()" ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait on a semaphore.                                           */
    /*                                                                  */
    /*   We sleep on a semaphore until a signal allows us to proceed.   */
    /*   We go to some trouble to deal with the interesting case where  */
    /*   the OS will not allow us to create an OS semaphore.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SEMAPHORE::Wait( SBIT32 Timeout )
    {
	REGISTER BOOLEAN Result = False;

	//
	//   We keep a count of threads waiting on the 
	//   semaphore.
	//
	AtomicIncrement( & Waiting );

	//
	//   When there is no existing semaphore we need
	//   to create one or just sleep for a while and
	//   try again later.
	//
	while ( Semaphore == NULL )
		{
		REGISTER SBIT32 Original = Signals;

		//
		//   Great, it looks like the semaphore has
		//   already been signalled.
		//
		if ( Original > 0 )
			{
			REGISTER SBIT32 Update = (Original - 1);

			//
			//   Lets try to atomically decrement the 
			//   signal count.
			//
			if 
					( 
					AtomicCompareExchange( & Signals,Update,Original ) 
						== 
					Original 
					)
				{
				//
				//   Great, we have actually done it.  We
				//   can safely exit as we have matched a
				//   wait and a signal.
				//
				AtomicDecrement( & Waiting );

				return True; 
				}
			}

		//
		//   Lets see if we can create a semaphore so we
		//   can sleep on it.
		//
		if ( ! UpdateSemaphore() )
			{ Sleep( 1 ); }
		}

	//
	//   The threads sleep here waiting to be signalled 
	//   so they can be restarted.
	//
	if ( Semaphore != NULL )
		{
		REGISTER DWORD Status = WaitForSingleObject( Semaphore,Timeout );

		//
		//   A wait can return various status values.  We
		//   just ensure we get one we like.
		//
		switch ( Status )
			{
			case WAIT_OBJECT_0:
				{ 
				Result = True;
				break;
				}

			case WAIT_TIMEOUT:
				{ 
				Result = False;
				break;
				}

			default:
				{ Failure( "Wait status in Wait" ); }
			}
		}

	//
	//   Finally, we decrement the count of waiting threads.
	//
	AtomicDecrement( & Waiting );

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the semaphore.                                          */
    /*                                                                  */
    /*   When we sleep we may decide that we need to create a new       */
    /*   semaphore.  We try to achieve that if we can otherwise we      */
    /*   have to pospone it until later.                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SEMAPHORE::UpdateSemaphore( VOID )
    {
	//
	//   We need to verify that we don't already have a
	//   semaphore and still need to create one.
	//
	if ( Semaphore == NULL )
		{
		REGISTER HANDLE Handle = CreateSemaphore( NULL,0,MaxThreads,NULL );

		//
		//   We need to ensure that we managed to create
		//   a semaphore.  If not we just exit.
		//
		if ( Handle != NULL )
			{
			REGISTER VOLATILE VOID **Address = ((VOLATILE VOID**) & Semaphore);

			//
			//   There is a clear race condition here in
			//   that another thread may manage to create
			//   a new semaphore before we do.  If so we 
			//   delete our semaphore.
			//
			if ( AtomicCompareExchangePointer( Address,Handle,NULL ) != NULL )
				{ CloseHandle( Handle ); }
			}
		}

	//
	//   When a semaphore is created we need to update it
	//   with the outstanding signals.
	//
	if ( Semaphore != NULL )
		{
		REGISTER SBIT32 Count = AtomicExchange( & Signals,0 );

		//
		//   We only need to update the semaphore if the
		//   signal count is greater than zero.
		//
		if ( Count > 0 )
			{
			//
			//   Update the semaphore.
			//
			if ( ! ReleaseSemaphore( Semaphore,Count,NULL ) )
				{ Failure( "Wakeup failed in UpdateSemaphore()" ); }
			}

		return True; 
		}
	else
		{ return False; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a semaphore.  This call is not thread safe and should  */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SEMAPHORE::~SEMAPHORE( VOID )
    {
	//
	//   When we create a semaphore it is necessary to
	//   delete it.
	//
	if ( Semaphore != NULL )
		{
		//
		//   We just verify that we were able to delete the
		//   semaphore.
		//
		if ( ! CloseHandle( Semaphore ) )
			{ Failure( "Close semaphore in destructor for SEMAPHORE" ); }
		}
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\slist.hpp ===
#ifndef _SLIST_HPP_
#define _SLIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A lockless list.                                               */
    /*                                                                  */
    /*   An SList is a lockless list suitable for high contention       */
    /*   SMP access.                                                    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET=0> class SLIST : public ASSEMBLY
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
	        SLIST                     *Address;
	        SBIT16                    Size;
	        SBIT16                    Version;
			}
		HEADER;

        //
        //   Private data.
        //
        VOLATILE HEADER	              Header;

    public:
        //
        //   Public functions.
        //
        SLIST( VOID );

		VOID CloneList( SLIST *List );

		VOID JoinList( SLIST *List );

		VOID MoveList( SLIST *List );

		VOID ZeroList( VOID );

		BOOLEAN Pop( TYPE **Type );

		VOID Push( TYPE *Type );

        ~SLIST( VOID );

		//
		//   Public inline functions.
		//
		INLINE TYPE *Address( VOID )
			{ return ((TYPE*) (((CHAR*) Header.Address) - OFFSET)); }

		INLINE BOOLEAN Empty( VOID )
			{ return (Header.Size == 0); }

		INLINE SBIT32 Size( VOID )
			{ return Header.Size; }

	private:
        //
        //   Disabled operations.
        //
        SLIST( CONST SLIST & Copy );

        VOID operator=( CONST SLIST & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new slist and initialize it.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> SLIST<TYPE,OFFSET>::SLIST( VOID )
    {
	//
	//   Zero the list head.
	//
	Header.Address = NULL;
	Header.Size = 0;
	Header.Version = 0;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Clone all of the list.                                         */
    /*                                                                  */
    /*   Clone the head of the slist to allow it to be examined.        */
    /*   Extreme caution is required with is function as grave          */
    /*   disorder may occur if any element is removed from the          */
    /*   list after a clone have been made.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> VOID SLIST<TYPE,OFFSET>::CloneList
		( 
		SLIST						  *List 
		)
    {
	AUTO HEADER Original;

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));
		}
	while 
		( 
		AtomicCompareExchange64
			( 
			((SBIT64*) & Header),
			(*((SBIT64*) & Original)),
			(*((SBIT64*) & Original))
			) 
				!= 
		(*((SBIT64*) & Original))
		);

	//
	//   We now store the extracted list in the target
	//   to allow it to be processed.  We know the new
	//   clone is a valid snapshot because of the atomic
	//   compare and update. 
	//
	(*((SBIT64*) List)) = (*((SBIT64*) & Original));
    }

    /********************************************************************/
    /*                                                                  */
    /*   Join two lists.                                                */
    /*                                                                  */
    /*   Join two lists together and form a single larger list.         */
    /*   The head of the one list is zeroed so it may continue to       */
    /*   be used in the normal way.                                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> VOID SLIST<TYPE,OFFSET>::JoinList
		( 
		SLIST						  *List 
		)
    {
	AUTO SLIST NewList;

	//
	//   When we join two lists we must safely extract
	//   the first list so we can join it without the
	//   fear of further updates.
	//
	List.MoveList( & NewList );

	//
	//   We may find the the new list is empty in which
	//   case we don't need to do anything.
	//
	if ( NewList.Address != NULL )
		{
		AUTO HEADER Original;
		AUTO HEADER Update;
		AUTO SLIST *Current;

		//
		//   Walk along the list and find the tail so we
		//   can join it to the head of the other list.
		//
		for 
			( 
			Current = NewList.Address;
			Current -> Address != NULL;
			Current = Current -> Address 
			);

		//
		//   We repeatedly try to update the list until
		//   we are sucessful.
		//
		do 
			{
			//
			//   Clone the current head of the other list.
			//
			(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));
			(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

			//
			//   Join the tail of the new list with the 
			//   head of the other list.
			//
			Current -> Header.Address = Original.Address;

			//
			//   Update the list head.
			//
			Update.Address = NewList.Address;
			Update.Size += NewList.Size;
			Update.Version ++;
			}
		while 
			( 
			AtomicCompareExchange64
				( 
				((SBIT64*) & Header),
				(*((SBIT64*) & Update)),
				(*((SBIT64*) & Original))
				) 
					!= 
			(*((SBIT64*) & Original))
			);
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Move all of the list.                                          */
    /*                                                                  */
    /*   Move the head of the slist to allow it to be examined.         */
    /*   The head of the list is zeroed so it may continue to be        */
    /*   used in the normal way.                                        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> VOID SLIST<TYPE,OFFSET>::MoveList
		( 
		SLIST						  *List 
		)
    {
	AUTO HEADER Original;
	AUTO SBIT64 Update = 0;

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));

		//
		//   Update the version number to ensure
		//   a 'ZeroList' and 'Pop' don't race if
		//   they are repeatedly used in close 
		//   succession.
		//
		Update.Version = (Original.Version + 1);
		}
	while 
		( 
		AtomicCompareExchange64
			( 
			((SBIT64*) & Header),
			(*(SBIT64*) & Update),
			(*(SBIT64*) & Original)
			) 
				!= 
		(*((SBIT64*) & Original))
		);

	//
	//   We now store the extracted list in the target
	//   to allow it to be processed.  There is still
	//   only one copy of the head of the list so all
	//   operations are still safe.
	//
	(*((SBIT64*) List)) = (*((SBIT64*) & Original));
    }

    /********************************************************************/
    /*                                                                  */
    /*   Zero all of the list.                                          */
    /*                                                                  */
    /*   Zero the head of the so it no longer contains any elements.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> VOID SLIST<TYPE,OFFSET>::ZeroList( VOID )
    {
	AUTO HEADER Original;
	AUTO SBIT64 Update = 0;

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));

		//
		//   Update the version number to ensure
		//   a 'ZeroList' and 'Pop' don't race if
		//   they are repeatedly used in close 
		//   succession.
		//
		Update.Version = (Original.Version + 1);
		}
	while 
		( 
		AtomicCompareExchange64
			( 
			((SBIT64*) & Header),
			(*(SBIT64*) & Update),
			(*(SBIT64*) & Original)
			) 
				!= 
		(*((SBIT64*) & Original))
		);
    }
    /********************************************************************/
    /*                                                                  */
    /*   Pop an element.                                                */
    /*                                                                  */
    /*   Pop an element from the list.                                  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> BOOLEAN SLIST<TYPE,OFFSET>::Pop
		( 
		TYPE						  **Type 
		)
    {
	AUTO HEADER Original = { 0,0,0 };
	AUTO HEADER Update = { 0,0,0 };

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));
		(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

		//
		//   We need to be sure that there is an element
		//   to extract.  If not we exit.
		//
		if ( Original.Address != NULL )
			{
			//
			//   Update the list head.  We only need to update
			//   the version on either 'Pop' or 'Push' but not
			//   both so we do it on 'Push'.
			//
			Update.Address = Original.Address -> Header.Address;
			Update.Size --;
			}
		else
			{ return False; }
		}
	while 
		( 
		AtomicCompareExchange64
			( 
			((SBIT64*) & Header),
			(*((SBIT64*) & Update)),
			(*((SBIT64*) & Original))
			) 
				!= 
		(*((SBIT64*) & Original))
		);

	//
	//   The slist elements point to the next slist link
	//   instead of the start of the class or structure.
	//   The adjustment to the head of the structure is
	//   made by the following code.
	//
	(*Type) = ((TYPE*) (((CHAR*) Original.Address) - OFFSET));

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an element.                                               */
    /*                                                                  */
    /*   Push an element onto the list.                                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> VOID SLIST<TYPE,OFFSET>::Push
		( 
		TYPE						  *Type 
		)
    {
	AUTO HEADER Original = { 0,0,0 };
	AUTO HEADER Update = { 0,0,0 };
	AUTO SLIST *SList = NULL;

	//
	//   We assume we have been supplied a pointer 
	//   to the sart of the class or structure.  The  
	//   adjustment to the head of the structure is
	//   made by the following code.
	//
	SList = ((SLIST*) (((CHAR*) Type) + OFFSET));

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		(*((SBIT64*) & Original)) = (*((SBIT64*) & Header));
		(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

		//
		//   The current list head is copied to 
		//   the new element pointer.
		//
		SList -> Header.Address = Original.Address;

		//
		//   Update the list head.  We only need to update
		//   the version on either 'Pop' or 'Push' but not
		//   both so we do it on 'Push'.
		//
		Update.Address = SList;
		Update.Size ++;
		Update.Version ++;
		}
	while 
		( 
		AtomicCompareExchange64
			( 
			((SBIT64*) & Header),
			(*((SBIT64*) & Update)),
			(*((SBIT64*) & Original))
			) 
				!= 
		(*((SBIT64*) & Original))
		);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a SList.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,SBIT32 OFFSET> SLIST<TYPE,OFFSET>::~SLIST( VOID )
    {
	//
	//   The list should be empty.
	//
    if ( (Header.Address != NULL) || (Header.Size != 0) )
		{ Failure( "Non-empty list in destructor for SLIST" ); }
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\sharelock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::SHARELOCK
		( 
		SBIT32						  NewMaxSpins,
		SBIT32						  NewMaxThreads,
		SBIT32						  NewMaxUsers 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		NormalSemaphore( NewMaxThreads ),
		PrioritySemaphore( NewMaxThreads )
    {
	//
	//   Set the initial state.
	//
	ExclusiveUsers = 0;
	TotalUsers = 0;

    NormalWaiting = 0;
    PriorityWaiting = 0;

#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;

#endif
	//
	//   Check the configurable values.
	//
	if ( NewMaxSpins > 0 )
		{ MaxSpins = NewMaxSpins; }
	else
		{ Failure( "Maximum spins invalid in constructor for SHARELOCK" ); }

	if ( (NewMaxUsers > 0) && (NewMaxUsers <= NormalSemaphore.GetMaxThreads()) )
		{ MaxUsers = NewMaxUsers; }
	else
		{ Failure( "Maximum share invalid in constructor for SHARELOCK" ); }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the statistics.
	//
    TotalExclusiveLocks = 0;
    TotalShareLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Sleep waiting for the lock.                                    */
    /*                                                                  */
    /*   We have decided it is time to sleep waiting for the lock       */
    /*   to become free.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::SleepWaitingForLock
		( 
		SEMAPHORE					  *Semaphore,
		SBIT32						  Sleep,
		VOLATILE SBIT32				  *Waiting 
		)
    {
	//
	//   We have been spinning waiting for the lock but it
	//   has not become free.  Hence, it is now time to 
	//   give up and sleep for a while.
	//
	(VOID) AtomicIncrement( Waiting );

	//
	//   Just before we go to sleep we do one final check
	//   to make sure that the lock is still busy and that
	//   there is someone to wake us up when it becomes 
	//   free.
	//
	if ( TotalUsers > 0 )
		{
#ifdef ENABLE_LOCK_STATISTICS
		//
		//   Count the number of times we have slept on 
		//   this lock.
		//
		(VOID) AtomicIncrement( & TotalSleeps );

#endif
		//
		//   When we sleep we awoken when the lock  
		//   becomes free or when we timeout.  If we  
		//   timeout we simply exit after decrementing 
		//   various counters.
		//
		if ( ! Semaphore -> Wait( Sleep ) )
			{ 
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have timed  
			//   out on this lock.
			//
			(VOID) AtomicIncrement( & TotalTimeouts );

#endif
			return False; 
			}
		}
	else
		{
		//
		//   Lucky - the lock was just freed so lets
		//   decrement the sleep count and exit without
		//   sleeping.
		// 
		(VOID) AtomicDecrement( Waiting );
		}
	
	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the spin limit.                                         */
    /*                                                                  */
    /*   Update the maximum number of spins while waiting for the lock. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxSpins( SBIT32 NewMaxSpins )
    {
	if ( NewMaxSpins > 0 )
		{ 
		MaxSpins = NewMaxSpins; 

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the sharing limit.                                      */
    /*                                                                  */
    /*   Update the maximum number of users that can share the lock.    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxUsers( SBIT32 NewMaxUsers )
    {
	//
	//   We need to verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= NormalSemaphore.GetMaxThreads()) )
		{
		//
		//   We claim an exclusive lock so we know
		//   we can update the control information
		//   atomically.
		//
		ClaimExclusiveLock();

		//
		//   Update the maximum number of users.
		//
		MaxUsers = NewMaxUsers;
		
		//
		//   Release any lock we claimed earlier.
		//
		ReleaseExclusiveLock();

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for an exclusive lock.                                    */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForExclusiveLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( TotalUsers != 1 )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > PriorityWaiting) )
				{
				//
				//   Wait by spinning and repeatedly testing 
				//   the spinlock.  We exit when the lock  
				//   becomes free or the spin limit is exceeded.
				//
				for 
						( 
						Count = MaxSpins;
						(Count > 0) && (TotalUsers > 0);
						Count -- 
						)
					{
					//
					//   When we are using Jackson MP machines
					//   we need to pause to give the other
					//   virtual processors a chance.
					//
					Pause();
					}
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is 
			//   time to sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(VOID) AtomicDecrement( & ExclusiveUsers );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if 
						( 
						! SleepWaitingForLock
							( 
							& PrioritySemaphore,
							Sleep,
							& PriorityWaiting 
							) 
						)
					{ return False; }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(VOID) AtomicIncrement( & ExclusiveUsers );
				}
			}
		else
			{ 
			//
			//   We have decide that we need to exit but are 
			//   still holding an exclusive lock.  so lets drop 
			//   it and leave.
			//
			(VOID) AtomicDecrement( & ExclusiveUsers );

			return False; 
			} 
		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for a shared lock.                                        */
    /*                                                                  */
    /*   Wait for the lock to become free and then claim it.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForShareLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (ExclusiveUsers > 0) || (TotalUsers > MaxUsers) )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > (PriorityWaiting + NormalWaiting)) )
				{
				//
				//   Wait by spinning and repeatedly testing 
				//   the spinlock.  We exit when the lock  
				//   becomes free or the spin limit is exceeded.
				//
				for 
						( 
						Count = MaxSpins;
						(Count > 0) 
							&& 
						((ExclusiveUsers > 0) || (TotalUsers >= MaxUsers));
						Count -- 
						)
					{
					//
					//   When we are using Jackson MP machines
					//   we need to pause to give the other
					//   virtual processors a chance.
					//
					Pause();
					}
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is 
			//   time to sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if 
						( 
						! SleepWaitingForLock
							( 
							& NormalSemaphore,
							Sleep,
							& NormalWaiting 
							) 
						)
					{ return False; }
				}
			}
		else
			{ return False; }

		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is typically short.      */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::WakeAllSleepers( VOID )
    {
    REGISTER SBIT32 PriorityWakeup = AtomicExchange( & PriorityWaiting, 0 );

	//
	//   We try to wake any priority sleepers before
	//   waking any normal sleepers.
	//
    if ( PriorityWakeup > 0 )
        {
		REGISTER SBIT32 Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( PriorityWakeup > Cpus )
			{
			(VOID) AtomicAdd( & PriorityWaiting,(PriorityWakeup - Cpus) );
			PriorityWakeup = Cpus; 
			}

        //
        //   Wake some sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
		PrioritySemaphore.Signal( PriorityWakeup );
        }
    else
        {
		REGISTER SBIT32 NormalWakeup = AtomicExchange( & NormalWaiting, 0 );

		//
		//   Well as there are no priority sleepers lets  
		//   wake some of the normal sleepers.
		//
		if ( NormalWakeup > 0 )
			{
			REGISTER SBIT32 Cpus = ((LONG) NumberOfCpus());

			//
			//   We will only wake enough threads to ensure that 
			//   there is one active thread per CPU.  So if an 
			//   application has hundreds of threads we will try 
			//   prevent the system from becoming swampped.
			//
			if ( NormalWakeup > Cpus )
				{
				(VOID) AtomicAdd( & NormalWaiting,(NormalWakeup - Cpus) );
				NormalWakeup = Cpus; 
				}

			//
			//   Wake some sleepers as the lock has just been freed.
			//   It is a straight race to decide who gets the lock next.
			//
			NormalSemaphore.Signal( NormalWakeup );
			}
		else
			{
			//
			//   When multiple threads pass through the critical  
			//   section it is possible for the waiting count  
			//   to become negative.  This should be very rare but 
			//   such a negative value needs to be preserved. 
			//
			if ( NormalWakeup < 0 )
				{ (VOID) AtomicAdd( & NormalWaiting, NormalWakeup ); }
			}

        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the waiting count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( PriorityWakeup < 0 )
			{ (VOID) AtomicAdd( & PriorityWaiting, PriorityWakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::~SHARELOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Sharelock: %d exclusive, %d shared, %d timeouts, " 
		"%d locks per wait, %d spins per wait, %d waits per sleep.\n",
		TotalExclusiveLocks,
		TotalShareLocks,
		TotalTimeouts,
		((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Semaphore.hpp ===
#ifndef _SEMAPHORE_HPP_
#define _SEMAPHORE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The semaphore constants indicate the limits of a semaphore.    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DefaultMaxThreads		  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   A control semaphore.                                           */
    /*                                                                  */
    /*   This class implements a semaphore abstraction.                 */
    /*                                                                  */
    /********************************************************************/

class SEMAPHORE : public ASSEMBLY
    {
        //
        //   Private data.
        //
		SBIT32						  MaxThreads;
        VOLATILE HANDLE               Semaphore;
        VOLATILE SBIT32               Signals;
        VOLATILE SBIT32               Waiting;

    public:
        //
        //   Public functions.
        //
        SEMAPHORE( SBIT32 NewMaxThreads = DefaultMaxThreads );

        VOID Signal( SBIT32 Count = 1 );

        BOOLEAN Wait( SBIT32 Timeout = INFINITE );

        ~SEMAPHORE( VOID );

		//
		//   Public inline functions.
		//
		INLINE SBIT32 GetMaxThreads( VOID )
			{ return MaxThreads; }

		INLINE SBIT32 GetWaiting( VOID )
			{ return Waiting; }

	private:
		//
		//   Private functions.
		//
		BOOLEAN UpdateSemaphore( VOID );

        //
        //   Disabled operations.
        //
        SEMAPHORE( CONST SEMAPHORE & Copy );

        VOID operator=( CONST SEMAPHORE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\string.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Delay.hpp"
#include "String.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
#ifdef DISABLE_STRING_LOCKS
UNIQUE<NO_LOCK> *STRING::Unique;
#else
SPINLOCK STRING::Spinlock;
UNIQUE<FULL_LOCK> *STRING::Unique = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Create the string table.                                       */
    /*                                                                  */
    /*   We create the string table on first use.  This is tricky as    */
    /*   we may have created multiple threads so we must be careful     */
    /*   to avoid race conditions.  We also arrang for the string table */
    /*   to be deleted at the end of the run unit.                      */
    /*                                                                  */
    /********************************************************************/

VOID STRING::CreateStringTable( VOID )
	{
#ifdef DISABLE_STRING_LOCKS
	STATIC DELAY<UNIQUE<NO_LOCK>> Delay;

	//
	//   Create the new string table.
	//
	Unique = new UNIQUE<NO_LOCK>;

	//
	//   Register the string table for deletion at
	//   at the end of the run unit.
	//
	Delay.DeferedDelete( Unique );
#else
	//
	//   Claim a lock to avoid race conditions.
	//
	Spinlock.ClaimLock();

	//
	//   If the string table still does not exist
	//   then create it.
	//
	if ( Unique == NULL )
		{
		STATIC DELAY< UNIQUE<FULL_LOCK> > Delay;

		//
		//   Create the new string table.
		//
		Unique = new UNIQUE<FULL_LOCK>;

		//
		//   Register the string table for deletion at
		//   at the end of the run unit.
		//
		Delay.DeferedDelete( Unique );
		}

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\SortedFind.hpp ===
#ifndef _SORTED_FIND_HPP_
#define _SORTED_FIND_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Include files for inherited classes.                           */
    /*                                                                  */
    /*   The include files for inherited classes are required in the    */
    /*   specification of this class.                                   */
    /*                                                                  */
    /********************************************************************/

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The sorted find constants specify the initial size of          */
    /*   the list.                                                      */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DefaultAlignmentSize	  = 1;
CONST SBIT32 DefaultListSize		  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Sorted storage and lookup.                                     */
    /*                                                                  */
    /*   It is not uncommon to want to store sorted data or to try to   */
    /*   find the closest match.  We combine this functionality into    */
    /*   a single combined class.                                       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class SORTED_FIND : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxList;
        SBIT32                        ListUsed;

        VECTOR<TYPE>	              List;

    public:
        //
        //   Public functions.
        //
        SORTED_FIND
			( 
			SBIT32                    NewMaxOrdered = DefaultListSize, 
			SBIT32                    Alignment = DefaultAlignmentSize 
			);

        VOID AddToList( CONST TYPE & Value );

		VIRTUAL SBIT32 CompareValues
			( 
			CONST TYPE				  & Value1,
			CONST TYPE				  & Value2 
			);

		BOOLEAN ExtractValue( SBIT32 Offset,TYPE *Type );

		BOOLEAN FindClosest
			( 
			CONST TYPE				  & Value,
			SBIT32					  *Before,
			SBIT32					  *After
			);

        VOID RemoveFromList( SBIT32 Offset );

        VIRTUAL ~SORTED_FIND( VOID );

		//
		//   Public inline functions.
		//
		SBIT32 GetSize( VOID )
			{ return ListUsed; }

	protected:
		//
		//   Protected inline functions.
		//
		TYPE *GetList( VOID )
			{ return & List[0]; }

	private:
		//
		//   Private functions.
		//
		BOOLEAN FindClosestValues
			( 
			CONST TYPE				  & Value,
			SBIT32					  *Before,
			SBIT32					  *After
			);

        //
        //   Disabled operations.
        //
        SORTED_FIND( CONST SORTED_FIND & Copy );

        VOID operator=( CONST SORTED_FIND & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new sorted find list and prepare it for use.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SORTED_FIND<TYPE,LOCK>::SORTED_FIND
		( 
		SBIT32						  NewMaxList,
		SBIT32                        Alignment
		) :
		//
		//   Call the constructors for the contained classes.
		//
		List( NewMaxList,Alignment,CacheLineSize )
    {
	//
	//   Lets just make sure that the list size
	//   appears to be reasonable.
	//
    if ( NewMaxList > 0 ) 
        {
		//
		//   Setup the hash table size information.
		//
        MaxList = NewMaxList;
        ListUsed = 0;
        }
    else
        { Failure( "Max size in constructor for SORTED_FIND" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add to the sorted list.                                        */
    /*                                                                  */
    /*   We add an item to the sorted list if it does not already       */
    /*   exist.  If there is not enough space we expand the size        */
    /*   of the 'List'.                                                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID SORTED_FIND<TYPE,LOCK>::AddToList
        (
        CONST TYPE					  & Value 
        )
    {
	AUTO SBIT32 *After;
	AUTO SBIT32 *Before;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Find the closest match to the value.
	//
	if ( FindClosestValues( Value,& Before,& After ) )
		{
		//
		//   We insert the new value in the sorted
		//   list unless we have an exact match.
		//   If we have an exact match we overwrite
		//   the existing value.
		//
		if ( Before != After )
			{
			//
			//   If the array is full then resize it.
			//   We need to be careful here as a resize
			//   can change the address of the 'List'
			//   array.
			//
			if ( MaxList < ListUsed  )
				{ List.Resize( (MaxList *= ExpandStore) ); }

			//
			//   We have a special case when the list
			//   wraps as this means we insert at the
			//   end of the list.  If not then the normal
			//   case is to copy down the existing 
			//   values and insert the new value.
			//
			if ( Before < After )
				{
				REGISTER SBIT32 Count;

				//
				//   The existing values are copied further
				//   down the list.
				//
				for ( Count=ListUsed ++;Count > After;Count -- )
					{ List[ Count ] = List[ (Count-1) ]; }

				//
				//   Insert the new value.
				//
				List[ After ] = Value;
				}
			else
				{ List[ (ListUsed ++) ] = Value; }
			}
		else
			{ List[ After ] = Value; }
		}
	else
		{ List[ (ListUsed ++) ] = Value; }

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compare two values.          .                                 */
    /*                                                                  */
    /*   Compare two values to understand the relationship.             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 SORTED_FIND<TYPE,LOCK>::CompareValues
        (
		CONST TYPE					  & Value1,
		CONST TYPE					  & Value2
        )
	{ return ((SBIT32) (Value2 - Value1)); }

    /********************************************************************/
    /*                                                                  */
    /*   Extract a list value.        .                                 */
    /*                                                                  */
    /*   Extact a list value and return for examination.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN SORTED_FIND<TYPE,LOCK>::ExtractValue
        (
		SBIT32						  Offset,
		TYPE						  *Value
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Extract the value from the list if it
	//   exists.
	//
	if ( (Offset >= 0) && (Offset < ListUsed) )
		{
		(*Value) = List[ Offset ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the closest match.                                        */
    /*                                                                  */
    /*   Find the closest matches in the sorted list.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN SORTED_FIND<TYPE,LOCK>::FindClosest
        (
		CONST TYPE					  & Value,
        SBIT32						  *Before, 
        SBIT32						  *After 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the closest matches.
	//
	Result = FindClosestValues( Value,Before,After );

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the closest values.                                       */
    /*                                                                  */
    /*   Find the closest matching values in the sorted list.           */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN SORTED_FIND<TYPE,LOCK>::FindClosestValues
        (
		CONST TYPE					  & Value,
        SBIT32						  *Before, 
        SBIT32						  *After 
        )
	{
	REGISTER BOOLEAN Found = False;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the list is empty we claerly can't find
	//   anybody who is close so we need to check for
	//   this now.
	//
	if ( ListUsed > 0 )
		{
		REGISTER SBIT32 First = CompareValues( Value,List[ 0 ] );
		REGISTER SBIT32 Last = CompareValues( Value,List[ (ListUsed-1) ] );

		//
		//   We are about to start a classical binary
		//   search so lets set the start and end indicators
		//   at the two ends of the list.
		//
		Before = 0;
		After = (ListUsed-1);

		//
		//   We do something special in this binary search
		//   in that we always indicate the two closest
		//   matches if an exact hit is not found.  We need
		//   to consider the case where there is a wrap around
		//   (this could be very nasty).
		//
		if ( (First > 0) && (Last < 0) )
			{
			REGISTER SBIT32 Current;

			//
			//   We now know that the target value is in the
			//   list somewhere but it is not a special case
			//   of any kind.  So lets go and find it.
			//
			for 
					( 
					Current=(After / 2);
					! Found;
					Current=((Before + After) / 2)
					)
				{
				REGISTER SBIT32 Delta = ((*After) - (*Before));

				//
				//   Lets compare the target value with
				//   the current value.
				//
				switch ( CompareValues( Value,List[ Current ] ) )
					{
					case -1:
						{
						//
						//   The target value is greater
						//   than the current value.  If
						//   we are not within 1 step try
						//   again otherwise exit as we have
						//   found the closest values.
						//
						if ( Delta > 1 )
							{ (*After) = Current; }
						else
							{ Found = True; }
						break;
						}

					case 0:
						{
						//
						//   A direct hit.  We have found
						//   the target value.
						//
						(*Before) = (*After) = Current;

						Found = True;

						break;
						}

					case 1:
						{
						//
						//   The target value is smaller
						//   than the current value.  If
						//   we are not within 1 step try
						//   again otherwise exit as we have
						//   found the closest values.
						//
						if ( Delta > 1 )
							{ (*Before) = Current; }
						else
							{ Found = True; }
						break;
						}
					}
				}
			}
		else
			{
			//
			//   We know that the target value matches
			//   one of the end points or lies outside
			//   the list.  We deduce which is the case
			//   and exit.
			//   
			if ( First == 0 )
				{ (*After) = (*Before); }
			else
				{
				//
				//   It must either match the last value
				//   or be outside the range.
				//
				if ( Last == 0 )
					{ (*Before) = (*After); }
				else
					{
					Before = After;
					After = 0;
					}
				}

			//
			//   Anyway you see it we wil have found the
			//   closest values.
			//
			Found = True;
			}
		}

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Found;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Remove a key from the hash table.                              */
    /*                                                                  */
    /*   The supplied key is removed from the hash table (if it exists) */
    /*   and the associated value is deleted.                           */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID SORTED_FIND<TYPE,LOCK>::RemoveFromList
        (
		SBIT32						  Offset
        )
    {
	REGISTER SBIT32 Count;

	if ( (Offset >= 0) && (Offset < (ListUsed --)) )
		{
		//
		//   Claim an exclusive lock (if enabled).
		//
		ClaimExclusiveLock();

		//
		//   The existing values are copied further
		//   up the list.
		//
		for ( Count=Offset;Count < ListUsed;Count ++ )
			{ List[ Count ] = List[ (Count+1) ]; }

		//
		//   Release any lock we got earlier.
		//
		ReleaseExclusiveLock();
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the sorted find.  This call is not thread safe and     */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SORTED_FIND<TYPE,LOCK>::~SORTED_FIND( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\spinlock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::SPINLOCK( SBIT32 NewMaxSpins,SBIT32 NewMaxThreads ) :
 		//
		//   Call the constructors for the contained classes.
		//
		WaitSemaphore( NewMaxThreads )
   {
	//
	//   Set the initial state.
	//
	MaxSpins = NewMaxSpins;
#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;
#endif
    Spinlock = LockOpen;
    Waiting = 0;
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for the spinlock.                                         */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SPINLOCK::WaitForLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER SBIT32 Sleeps = 0;
    REGISTER SBIT32 Spins = 0;
    REGISTER SBIT32 Waits = 0;

#endif
    do
        {
        REGISTER SBIT32 Count;
        
		//
		//   If there are already more threads waiting 
		//   than the number of CPUs then the odds of 
		//   getting the lock by spinning are slim, when 
		//   there is only one CPU the chance is zero, so 
		//   just bypass this step.
		//
		if ( (Cpus > 1) && (Cpus > Waiting) )
			{
			//
			//   Wait by spinning and repeatedly testing the
			//   spinlock.  We exit when the lock becomes free 
			//   or the spin limit is exceeded.
			//
			for 
					( 
					Count = MaxSpins;
					(Count > 0) && (Spinlock != LockOpen);
					Count -- 
					)
				{
				//
				//   When we are using Jackson MP machines
				//   we need to pause to give the other
				//   virtual processors a chance.
				//
				Pause();
				}
#ifdef ENABLE_LOCK_STATISTICS

			//
			//   Update the statistics.
			//
			Spins += (MaxSpins - Count);
			Waits ++;
#endif
			}
		else
			{ Count = 0; }

		//
		//   We have exhusted our spin count so it is time to
		//   sleep waiting for the lock to clear.
		//
        if ( Count == 0 )
            {
			//
			//   The lock is still closed so lets go to sleep on 
			//   a semaphore.  However, we must first increment
			//   the waiting count and test the lock one last time
			//   to make sure it is still busy and there is someone
			//   to wake us up later.
			//
			(VOID) AtomicIncrement( & Waiting );

			if ( ! ClaimSpinlock( & Spinlock ) )
				{
				//
				//   Sleep on the semaphore until we are awoken
				//   by the lock holder.
				//
				if ( ! WaitSemaphore.Wait( Sleep ) )
					{
#ifdef ENABLE_LOCK_STATISTICS
					//
					//   Count the number of times we have  
					//   timed out on this lock.
					//
					(VOID) AtomicIncrement( & TotalTimeouts );

#endif
					return False; 
					}
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Sleeps ++;
#endif
				}
			else
				{
				//
				//   Lucky - got the lock on the last attempt.
				//   Hence, lets decrement the sleep count and
				//   exit.
				// 
				(VOID) AtomicDecrement( & Waiting );
            
				break; 
				}
            }
        }
    while ( ! ClaimSpinlock( & Spinlock ) );
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    TotalSleeps += Sleeps;
    TotalSpins += Spins;
    TotalWaits += Waits;
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::WakeAllSleepers( VOID )
    {
    REGISTER SBIT32 Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER SBIT32 Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake some sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
		WaitSemaphore.Signal( Wakeup );
#ifdef ENABLE_DYNAMIC_SEMAPHORES

		//
		//   Now for a stunning trick.  We want to reclaim the
		//   semaphore it is it not in use.  However, it could be
		//   reused at any point.  So here we do a double exchange
		//   and we reclaim the semaphore only it is it free.
		//
		if ( Waiting == 0 )
			{
			AUTO DOUBLE_SBIT32 Original;
			AUTO DOUBLE_SBIT32 Update;

			//
			//   Clone the current values of the waiting count
			//   and the semaphore handle.
			//
			(*((SBIT64*) & Original)) = (*((SBIT64*) & Waiting));
			(*((SBIT64*) & Update)) = (*((SBIT64*) & Original));

			//
			//   Update the current values.  We overwrite the 
			//   original value of the waiting count because
			//   it must be zero for this to work.  The new values
			//   will be zero as well.
			//
			Original.First = 0;

			Update.First = 0;
			Update.Second = 0;

			//
			//   So it is time to hold onto you seats.  We now
			//   atomically swap the waiting cound and the semaphore
			//   pointer only if the waiting count is zero.
			if
					( 
					AtomicCompareExchange64
						( 
						((SBIT64*) & Original),
						(*((SBIT64*) & Update)),
						(*((SBIT64*) & Original))
						) 
							!= 
					(*((SBIT64*) & Original))
					)
				{
				//
				//   It looks like it actually worked so we can
				//   release the semaphore
				//
				//   ******** Bug here ********
				//   I can't release the semaphore here because the
				//   waiting count might include a thread that has
				//   added itself to the waiting count but got the
				//   lock just before it went to sleep.  If I release
				//   the semaphore it will have 1 too many signals
				//   and later a thread on this lok will not have
				//   enough signals.
				//
				((WAIT*) Original.First) -> ReleaseSemaphore();
				}
			}
#endif
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::~SPINLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Spinlock: %d locks, %d timeouts, %d locks per wait, "
		"%d spins per wait, %d waits per sleep.\n",
		TotalLocks,
		TotalTimeouts,
		(TotalLocks / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);

#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\smpool.hpp ===
#ifndef _SMPOOL_HPP_
#define _SMPOOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Block.hpp"
#include "Exclusive.hpp"
#include "Queue.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinSMPoolSize			  = 128;
CONST SBIT16 SMPoolStackSize		  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class SMPOOL
    {
		//
		//   Private structures.
		//
		typedef EXCLUSIVE< QUEUE<POINTER> > LOCKED_QUEUE;
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        BLOCK< VECTOR<TYPE_SIZE> >    Block;
        LOCKED_QUEUE                  FreeQueue;
		VECTOR< STACK<POINTER> >      Stacks;

    public:
        //
        //   Public functions.
        //
        SMPOOL( SBIT32 MinSize = MinSMPoolSize );

        TYPE *PopPool( SBIT16 Cpu );

        TYPE **MultiplePopPool
            ( 
            SBIT16                        Cpu, 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID PushPool( SBIT16 Cpu, TYPE *Pool );

        VOID MultiplePushPool
            ( 
            SBIT16                        Cpu, 
            TYPE                          *Pool[], 
            SBIT32                        Size 
            );

        ~SMPOOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 NewSize );

        //
        //   Disabled operations.
        //
        SMPOOL( CONST SMPOOL & Copy );

        VOID operator=( CONST SMPOOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::SMPOOL( SBIT32 MinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		FreeQueue( MinSize ), 
		Stacks( NumberOfCpus(), CacheLineSize )
    {
#ifdef DEBUGGING
    if ( MinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        this -> MaxSize = 0;
        this -> MinSize = MinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "MinSize in constructor for SMPOOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation if the free queue is      */
    /*   empty.                                                         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::ExpandSize( SBIT32 NewSize )
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	STATIC SPINLOCK Spinlock;

	Spinlock.ClaimLock();

	if ( FreeQueue.SizeOfQueue() <= 0 )
		{
		REGISTER SBIT32 ActualSize =
			(NewSize <= MinSize) ? MinSize : NewSize;
		REGISTER VECTOR<TYPE> *NewBlock =
			(
			(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
				( 
				ActualSize, 
				CacheLineSize 
				)
			);

		//
		//   We need to keep a note of the number of elements 
		//   we have allocated thus far.
		//
		MaxSize += ActualSize;

		//
		//   We put the address of each element we allocate on
		//   a stack to enable high speed allocation and 
		//   deallocation.
		//
		for 
				( 
				Count1 = 0;
				Count1 < ActualSize;
				Count1 += SMPoolStackSize 
				)
			{
			AUTO POINTER NewCalls[ SMPoolStackSize ];

			//
			//   We add elements to the stack in blocks
			//   to reduce the number of call to the
			//   stack code.
			//
			for 
					( 
					Count2 = 0;
					((Count1 + Count2) < ActualSize)
						&&
					(Count2 < SMPoolStackSize);
					Count2 ++ 
					)
				{
				REGISTER TYPE *NewCall =
					(
					& (*NewBlock)[ (Count1 + Count2) ]
					);
                 
				NewCalls[ Count2 ] = (POINTER) NewCall;
				}

			//
			//   Add the next block for free work packets to
			//   the global free queue.
			//
			Stack.MultiplePushStack
				( 
				NewCalls,
				Count2 
				);
			}

		//
		//   Add the newly allocated block to the list of
		//   things to be deleted when this class is deleted.
		//
		Block.DeferedDelete( (VECTOR<TYPE_SIZE>*) NewBlock );
		}
	
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We remove a single item from the pool.  This call assumes      */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE *SMPOOL<TYPE>::PopPool( SBIT16 Cpu )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool;

	while ( ! Stack -> PopStack( (POINTER*) & NewPool ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	(VOID) PLACEMENT_NEW( NewPool, TYPE );

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We remove multiple items from the pool.  This call assumes     */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE **SMPOOL<TYPE>::MultiplePopPool
        ( 
        SBIT16                        Cpu, 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool[ SMPoolStackSize ];

	Requested = (Requested <= SMPoolStackSize) ? Requested : SMPoolStackSize;

	while ( ! Stack -> MultiplePopStack( Requested,(POINTER*) NewPool,Size ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We add a single item to the pool.  This call assumes           */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::PushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool
        )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];

	PLACEMENT_DELETE( Pool, TYPE );

	Stack -> PushStack( (POINTER) Pool );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We add a multiple items to the pool.  This call assumes        */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::MultiplePushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool[],
        SBIT32                        Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Pool[ Count ], TYPE ); }

	Stack -> MultiplePushStack( (POINTER*) Pool,Size );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::~SMPOOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\thread.hpp ===
#ifndef _THREAD_HPP_
#define _THREAD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   A thread started by this class should conform to the type      */
    /*   specification given here.                                      */
    /*                                                                  */
    /********************************************************************/

typedef VOID (*NEW_THREAD)( VOID *Parameter );

    /********************************************************************/
    /*                                                                  */
    /*   Thread synchronization.                                        */
    /*                                                                  */
    /*   This class privides a method for synchronizing a number        */
    /*   of worker threads with a master thread.  Each time the         */
    /*   master thread calls 'StartThread()' a new thread is created.   */
    /*   When a thread calls 'EndThread()' the thread is terminated.    */
    /*   At any point the master thread can enquire about the number    */
    /*   of active threads or wait for them to complete.                */
    /*                                                                  */
    /********************************************************************/

class THREAD : public ENVIRONMENT
    {
    public:
		//
		//   Public data.
		//
		BOOLEAN						  Active;

        SBIT32						  ActiveThreads;
        SBIT32						  MaxThreads;
        VECTOR<HANDLE>				  Threads;

        BOOLEAN                       Affinity;
        VOLATILE SBIT16               Cpu;
        BOOLEAN                       Priority;
        LONG                          Stack;

        HANDLE                        Completed;
        HANDLE                        Running;
        HANDLE                        Started;

		SPINLOCK					  Spinlock;

		NEW_THREAD					  ThreadFunction;
	    VOID						  *ThreadParameter;
		BOOLEAN						  ThreadWait;

        //
        //   Public functions.
        //
        THREAD( VOID );

        VOID EndThread( VOID );

		VOID RegisterThread( VOID );

        VOID SetThreadStackSize( LONG Stack = 0 );

        BOOLEAN StartThread
			( 
			NEW_THREAD                Function, 
			VOID                      *Parameter = NULL, 
			BOOLEAN                   Wait = True 
			);

        BOOLEAN WaitForThreads( LONG WaitTime = INFINITE );

        ~THREAD( VOID );

		//
		//   Public inline functions.
		//
        VOID SetThreadAffinity( BOOLEAN NewAffinity = True )
			{ Affinity = NewAffinity; }

        VOID SetThreadPriority( BOOLEAN NewPriority = True )
			{ Priority = NewPriority; }

	private:
        //
        //   Disabled operations.
        //
        THREAD( CONST THREAD & Copy );

        VOID operator=( CONST THREAD & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\stack.hpp ===
#ifndef _STACK_HPP_
#define _STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the stack.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 StackSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Stacks and stack management.                                   */
    /*                                                                  */
    /*   This class provides general purpose stacks along with some     */
    /*   basic management.  The stacks are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a stack at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class STACK : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Top;

        VECTOR<TYPE>                  Stack;

    public:
        //
        //   Public functions.
        //
        STACK( SBIT32 NewMaxSize = StackSize );

        BOOLEAN MultiplePopStack
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        BOOLEAN MultiplePopStackReversed
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        VOID MultiplePushStack
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        VOID MultiplePushStackReversed
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        BOOLEAN PeekStack( TYPE *Data );

        BOOLEAN PopStack( TYPE *Data );

        VOID PushStack( CONST TYPE & Data );

        BOOLEAN ReadStack( SBIT32 Index, TYPE *Data );

        VOID ReverseStack( VOID );

        BOOLEAN UpdateStack
            ( 
            CONST SBIT32				  Index, 
            CONST TYPE					  & Data 
            );

        ~STACK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 SizeOfStack( VOID ) 
			{ return Top; }

	private:
        //
        //   Disabled operations.
        //
        STACK( CONST STACK & Copy );

        VOID operator=( CONST STACK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new stack and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::STACK( SBIT32 NewMaxSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMaxSize,NoAlignment )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Top = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for STACK" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack.                            */
    /*                                                                  */
    /*   We remove multiple items from a stack and check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStack
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = ((*Size) - 1);Count >= 0;Count -- )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack in reverse order.           */
    /*                                                                  */
    /*   We remove multiple items from a stack in reverse order and     */
    /*   check to make sure that the stack is not empty.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStackReversed
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = 0;Count < (*Size);Count ++ )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack.                                 */
    /*                                                                  */
    /*   We add multiple items to a stack and check to make sure that   */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStack
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements.
	//
    for ( Count = 0;Count < Size;Count ++ )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack in reverse order.                */
    /*                                                                  */
    /*   We add multiple items to a stack in reverse order and check    */
    /*   to make sure that the stack has not overflowed.  If the stack  */
    /*   has overflowed we double its size.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStackReversed
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements in reverse order.
	//
    for ( Count = (Size-1);Count >= 0;Count -- )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek at the top of stack.                                      */
    /*                                                                  */
    /*   We return the top of stack with a pop but check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PeekStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the stack is not empty return a copy
	//   of the top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ (Top - 1) ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from a stack.                             */
    /*                                                                  */
    /*   We remove a single item from a stack and check to make sure    */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PopStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

    //
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the
	//   top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ -- Top ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to a stack.                                  */
    /*                                                                  */
    /*   We add a single item to a stack and check to make sure that    */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::PushStack
		( 
		CONST TYPE					  & Data
		)
    {    
	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is full then expand it.
	//
    while ( Top >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push a new element.
	//
    Stack[ Top ++ ] = Data;

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Read a stack value.                                            */
    /*                                                                  */
    /*   We return a single item from the stack but check to make       */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::ReadStack
        ( 
        SBIT32                        Index, 
        TYPE                          *Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the element exists then return a copy of
	//   it to the caller.
	//
    if ( Index < Top )
		{ 
		(*Data) = Stack[ Index ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Reverse the stack.                                             */
    /*                                                                  */
    /*   We reverse the order of the stack to make effectively          */
    /*   make it a queue.                .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::ReverseStack( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 MidPoint = (Top / 2);

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Swap all elements around the mid point.
	//
	for ( Count=0;Count < MidPoint;Count ++ )
		{
		REGISTER TYPE *Low = & Stack[ Count ];
		REGISTER TYPE *High = & Stack[ (Top - Count - 1) ];
		REGISTER TYPE Temp = (*Low);

		(*Low) = (*High);
		(*High) = Temp;
		}

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update a stack value.                                          */
    /*                                                                  */
    /*   We update a single item on the stack but check to make         */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::UpdateStack
        ( 
        CONST SBIT32				  Index, 
        CONST TYPE					  & Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the element exists then update it.
	//
    if ( Index < Top )
		{ 
		Stack[ Index ] = Data;

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::~STACK( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\system.hpp ===
#ifndef _SYSTEM_HPP_
#define _SYSTEM_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard system include files.                             */
    /*                                                                  */
    /*   The standard system include files contain various definitions  */
    /*   used throughout the system.                                    */
    /*                                                                  */
    /********************************************************************/

#include <conio.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <new.h>
#include <process.h>
#include <time.h>
#include <winsock2.h>
#include <windows.h>

    /********************************************************************/
    /*                                                                  */
    /*   Automatically set the debugging flag if needed.                */
    /*                                                                  */
    /*   There are various standards for enabling dedugging code.       */
    /*   Here we translate on to the standard used in this              */
    /*   application.                                                   */
    /*                                                                  */
    /********************************************************************/

#ifdef _M_IX86
#define ASSEMBLY_X86				  1
#endif

#ifdef _DEBUG
#define DEBUGGING                     1
#endif

#ifdef UNICODE
#undef CreateSemaphore
#undef OutputDebugString

#define CreateSemaphore				  CreateSemaphoreA
#define OutputDebugString			  OutputDebugStringA
#endif

#ifdef _WIN64
#define WINDOWS64                     1
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Automatically disable anoying warnings.                        */
    /*                                                                  */
    /*   Some of the VC compiler warning are not very helpful so        */
    /*   we disable them here.                                          */
    /*                                                                  */
    /********************************************************************/

#ifndef ALL_COMPLAINTS
#pragma warning( disable : 4073 )
#pragma warning( disable : 4074 )
#pragma warning( disable : 4097 )
#pragma warning( disable : 4100 )
#pragma warning( disable : 4121 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4291 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4509 )
#pragma warning( disable : 4511 )
#pragma warning( disable : 4512 )
#pragma warning( disable : 4514 )
#pragma warning( disable : 4701 )
#pragma warning( disable : 4702 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4710 )
#pragma warning( disable : 4711 )
#pragma warning( disable : 4800 )
#pragma warning( disable : 4996 )
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\spinlock.hpp ===
#ifndef _SPINLOCK_HPP_
#define _SPINLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Wait.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The spinlock constants indicate when the lock is open and      */
    /*   when it is closed.                                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DefaultMaxSpins		  = 4096;
CONST SBIT32 DefaultMaxUsers		  = 256;

CONST LONG LockClosed				  = 1;
CONST LONG LockOpen					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Spinlock and Semaphore locking.                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  When a lock is taken a memory     */
    /*   location is exchanged.  All other threads that want this       */
    /*   lock wait by spinning and sometimes sleeping on a semaphore    */
    /*   until it becomes free again.  The only other choice is not     */
    /*   to wait at all and move on to do something else.  This         */
    /*   module should normally be used in conjunction with cache       */
    /*   aligned memory in minimize cache line misses.                  */
    /*                                                                  */
    /********************************************************************/

class SPINLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		CACHE_ALIGNMENT SBIT32		  MaxSpins;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        VOLATILE SBIT32               Spinlock;
        VOLATILE SBIT32               Waiting;
#ifndef ENABLE_DYNAMIC_SEMAPHORES
        SEMAPHORE                     WaitSemaphore;
#else
        WAIT	                      WaitSemaphore;
#endif
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SPINLOCK
			( 
			SBIT32					  NewMaxSpins = DefaultMaxSpins, 
			SBIT32					  NewMaxThreads = DefaultMaxThreads 
			);

        ~SPINLOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseLock( VOID );

    private:
        //
        //   Private functions.
        //
        BOOLEAN WaitForLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Private inline functions.
        //
        INLINE BOOLEAN ClaimSpinlock( VOLATILE SBIT32 *Spinlock );

		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );


        //
        //   Disabled operations.
        //
        SPINLOCK( CONST SPINLOCK & Copy );

        VOID operator=( CONST SPINLOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   A guaranteed atomic exchange.                                  */
    /*                                                                  */
    /*   An attempt is made to claim the spinlock.  This action is      */
    /*   guaranteed to be atomic.                                       */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimSpinlock( VOLATILE SBIT32 *Spinlock )
    {
    return 
		(
		AtomicCompareExchange( Spinlock,LockClosed,LockOpen ) 
			== 
		LockOpen
		); 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the spinlock.                                            */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Claim the spinlock.
		//
		if ( ! ClaimSpinlock( & Spinlock ) )
			{
			//
			//   We have to wait.  If we are not 
			//   allowed to sleep or we have timed
			//   out then exit.
			//
			if ( (Sleep == 0) || (! WaitForLock( Sleep )) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
#ifdef DEBUGGING

		//
		//   Release the spinlock.
		//
		if ( AtomicExchange( & Spinlock, LockOpen ) == LockClosed )
			{
#else
			(VOID) AtomicExchange( & Spinlock, LockOpen );
#endif

			//
			//   Wakeup anyone who is asleep waiting.
			//
			if ( Waiting > 0 )
				{ WakeAllSleepers(); }
#ifdef DEBUGGING
			}
		else
			{ Failure( "Spinlock released by not held in ReleaseLock" ); } 
#endif
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\standard.hpp ===
#ifndef _STANDARD_HPP_
#define _STANDARD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard data types.                                       */
    /*                                                                  */
    /*   The standard data types should be used in preference to the    */
    /*   data types defined in the C++ language.  This is to allow      */
    /*   for easier porting.  If no suitable standard type exists       */
    /*   then one should be created and documented here.                */
    /*                                                                  */
    /********************************************************************/

#define AUTO                          auto
#define CACHE_ALIGNMENT				  __declspec(align(SELECT_CACHE_LINE_SIZE))
#define CONST						  const
#define CONSTANT                      const
#define EXTERN                        extern
#define GLOBAL                        extern
#define INLINE                        __forceinline
#define LOCAL                         auto
#define REGISTER                      register
#define STATIC                        static
#define VIRTUAL                       virtual
#define VOLATILE                      volatile

    /********************************************************************/
    /*                                                                  */
    /*   The standard C++ types.                                        */
    /*                                                                  */
    /*   The C++ standard reserves various lower case keywords.  This   */
    /*   system uses a similar standard.  All upper case words are      */
    /*   either constants or types.  All words begining with a single   */
    /*   upper case letter are variables.                               */
    /*                                                                  */
    /********************************************************************/

typedef unsigned char                 BOOLEAN;

typedef char                          CHAR;
typedef short int                     SHORT;
typedef int                           INT;
typedef long int                      LONG;

typedef signed char                   SCHAR;
typedef signed short int              SSHORT;
typedef signed int                    SINT;
typedef signed long int               SLONG;

typedef unsigned char                 UCHAR;
typedef unsigned short int            USHORT;
typedef unsigned int                  UINT;
typedef unsigned long int             ULONG;

typedef unsigned char                 *FAULT;
typedef void                          *POINTER;

    /********************************************************************/
    /*                                                                  */
    /*   The optional standard types.                                   */
    /*                                                                  */
    /*   Some of the standard types are specified in other headers.     */
    /*   We need to be careful not to redefine these specifications     */
    /*   if they already exist.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef CDECL
#define	CDECL						  _cdecl
#endif

#ifndef DLL_EXPORT
#define	DLL_EXPORT					  _declspec(dllexport)
#endif

#ifndef DLL_IMPORT
#define	DLL_IMPORT					  _declspec(dllimport)
#endif

#ifndef STDCALL
#define	STDCALL						  _stdcall
#endif

#ifndef VOID
#define	VOID						  void
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The fixed length types.                                        */
    /*                                                                  */
    /*   The above types are intended to shadow the standard C++ types  */
    /*   built into the language.  However, these types don't assure    */
    /*   any level of accuracy.  Each of following types is defined     */
    /*   to provide a minimum level of precision.                       */
    /*                                                                  */
    /********************************************************************/

typedef unsigned __int8               BIT8;
typedef unsigned __int16              BIT16;
typedef unsigned __int32              BIT32;
typedef unsigned __int64              BIT64;

typedef signed __int8                 SBIT8;
typedef signed __int16                SBIT16;
typedef signed __int32                SBIT32;
typedef signed __int64                SBIT64;

    /********************************************************************/
    /*                                                                  */
    /*   The variable length types.                                     */
    /*                                                                  */
    /*   The slow transition to 64-bit machines means it is nice to     */
    /*   have types that match the native machine register size.        */
    /*   Each of the following types matches tha native hardware        */
    /*   to enable good performance.                                    */
    /*                                                                  */
    /********************************************************************/

#ifndef _WIN64
typedef __w64 SBIT32				  SNATIVE;
typedef __w64 BIT32					  UNATIVE;
#else
typedef SBIT64						  SNATIVE;
typedef BIT64						  UNATIVE;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\tls.hpp ===
#ifndef _TLS_HPP_
#define _TLS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The environment constants indicate the state of thread         */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoTLSMemory			  = -1;
CONST SBIT32 NoTLSStructure			  = 0;

#ifdef ENABLE_NON_STANDARD_ASSEMBLY
CONST SBIT32 MaxTlsIndex			  = 64;
#else
	//   The original and correct value for 'MaxTlsIndex'
	//   is 1088 by it turns out that AppVerifier does
	//   not like this and complains so we accept a larger
	//   value just to be a team player.
CONST SBIT32 MaxTlsIndex			  = (1<<30);
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Thread local store.                                            */
    /*                                                                  */
    /*   A wide range of applications use threads.  It is often very    */
    /*   valuable to be able to have some private per thread data.      */
    /*   This functionality is supported by the following class.        */
    /*                                                                  */
    /********************************************************************/

class TLS : public ASSEMBLY
    {
        //
        //   Private data.
        //
		BOOLEAN						  Active;

		SBIT32						  TlsIndex;
		SBIT32						  TlsOffset;

    public:
        //
        //   Public functions.
        //
        TLS( VOID )
			{
			Active = ((TlsIndex = TlsAlloc()) != NoTLSMemory);

			if ( (Active) && (TlsIndex < MaxTlsIndex) )
				{ TlsOffset = ((TlsIndex * sizeof(void*)) + TebSlot); }
			else
				{ Failure( "No TLS available" ); }
			}

		INLINE BOOLEAN Available( VOID )
			{ return Active; }
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY

		INLINE VOID *GetAddress( VOID )
			{ return (GetTlsAddress( TlsOffset )); }
#endif
#endif

		INLINE VOID *GetPointer( VOID )
			{ return (GetTlsValue( TlsIndex,TlsOffset )); }

		INLINE VOID SetPointer( VOID *NewPointer )
			{ SetTlsValue( TlsIndex,TlsOffset,NewPointer ); }

        ~TLS( VOID )
			{
			Active = False;

			if ( TlsIndex != NoTLSMemory )
				{ 
				if ( ! TlsFree( TlsIndex ) )
					{ Failure( "Unable to free TLS memory" ); }
				}
			}

	private:
        //
        //   Disabled operations.
        //
        TLS( CONST TLS & Copy );

        VOID operator=( CONST TLS & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\string.hpp ===
#ifndef _STRING_HPP_
#define _STRING_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Spinlock.hpp"
#include "Unique.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A string class.                                                */
    /*                                                                  */
    /*   A typical string class manages variable length text strings.   */
    /*   Although we support the same in this class we ensure that      */
    /*   there is only one copy of every unique string.  There is a     */
    /*   cost associated with this at string creation time but a big    */
    /*   win when the strings are heavily compared, copied or           */
    /*   replicated.                                                    */
    /*                                                                  */
    /********************************************************************/

class STRING
    {
        //
        //   Private data.
        //
        DETAIL						  *Detail;

        //
        //   Static private data.
        //
#ifdef DISABLE_STRING_LOCKS
		STATIC UNIQUE<NO_LOCK>		  *Unique;
#else
		STATIC SPINLOCK				  Spinlock;
		STATIC UNIQUE<FULL_LOCK>	  *Unique;
#endif

    public:
		//
		//   Public inline functions.
		//
        STRING( VOID )
			{ DefaultString(); }

        STRING( CHAR *String )
			{ CreateString( String,((SBIT32) strlen( String )) ); }

        STRING( CHAR *String,SBIT32 Size )
			{ CreateString( String,Size ); }

        STRING( CONST STRING & Update )
			{ Detail = Unique -> CopyString( DefaultString(),Update.Detail ); }

        INLINE VOID operator=( CONST STRING & Update )
			{ Detail = Unique -> CopyString( Detail,Update.Detail ); }

        INLINE BOOLEAN operator==( CONST STRING & String )
			{ return (Detail == String.Detail); }

        INLINE BOOLEAN operator!=( CONST STRING & String )
			{ return (Detail != String.Detail); }

        INLINE BOOLEAN operator<( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) < 0); }

        INLINE BOOLEAN operator<=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) <= 0); }

        INLINE BOOLEAN operator>( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) > 0); }

        INLINE BOOLEAN operator>=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) >= 0); }

		INLINE SBIT32 Size( VOID )
			{ return Unique -> Size( Detail ); }

		INLINE CHAR *Value( VOID )
			{ return Unique -> Value( Detail ); }

		INLINE SNATIVE ValueID( VOID )
			{ return ((SNATIVE) Detail); }

        ~STRING( VOID )
			{ DeleteString(); }

	private:
		//
		//   Private functions.
		//
		VOID CreateStringTable( VOID );

		//
		//   Private inline functions.
		//
		DETAIL *CreateString( CHAR *String,SBIT32 Size )
			{
			VerifyStringTable();

			return (Detail = Unique -> CreateString( String,Size ));
			}

        DETAIL *DefaultString( VOID )
			{
			VerifyStringTable();

			return (Detail = Unique -> DefaultString()); 
			}

        VOID DeleteString( VOID )
			{
			if ( Unique != NULL )
				{ Unique -> DeleteString( Detail ); }
			}

		VOID VerifyStringTable( VOID )
			{
			if ( Unique == NULL )
				{ CreateStringTable(); }
			}
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\unique.hpp ===
#ifndef _UNIQUE_HPP_
#define _UNIQUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Hash.hpp"
#include "List.hpp"
#include "Pool.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control how unique strings         */
    /*   are constructed.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinDetails				  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> class UNIQUE;

    /********************************************************************/
    /*                                                                  */
    /*   A string description.                                          */
    /*                                                                  */
    /*   All unique strings have a string drescription which is         */
    /*   into either the active or free list.                           */
    /*                                                                  */
    /********************************************************************/

class DETAIL : public LIST
	{
	private:
		//
		//   Friend classes.
		//
		friend class				  UNIQUE<NO_LOCK>;
		friend class				  UNIQUE<PARTIAL_LOCK>;
		friend class				  UNIQUE<FULL_LOCK>;

		//
		//   Private data.
		//
		BOOLEAN						  Active;
		SBIT32						  Size;
		CHAR						  *Text;
		SBIT32						  Uses;
	};

    /********************************************************************/
    /*                                                                  */
    /*   A unique string.                                               */
    /*                                                                  */
    /*   Almost all the other classes in the library offer valuable     */
    /*   free-standing functionality.  However, this class is really    */
    /*   just a support class for the variable length string class.     */
    /*                                                                  */
    /********************************************************************/

template <class LOCK=PARTIAL_LOCK> class UNIQUE : public HASH<SNATIVE,POINTER>
    {
		//
		//   Private data.
		//
		LIST						  Active;
		LIST						  Free;

		DETAIL						  *Default;
		POOL<DETAIL>				  Details;
		LOCK						  Sharelock;

    public:
        //
        //   Public functions.
        //
        UNIQUE( VOID );

		DETAIL *CreateString( CHAR *String,SBIT32 Size );

		SBIT32 CompareStrings( DETAIL *Detail1,DETAIL *Detail2 );

		DETAIL *CopyString( DETAIL *Detail1,DETAIL *Detail2 );

		VOID DeleteString( DETAIL *Detail );

        ~UNIQUE( VOID );

		//
		//   Public inline functions.
		//
		INLINE DETAIL *DefaultString( VOID )
			{ return Default; }

		INLINE SBIT32 Size( DETAIL *Detail )
			{ return Detail -> Size; }

		INLINE CHAR *Value( DETAIL *Detail )
			{ return Detail -> Text; }

	private:
		//
		//   Private functions.
		//
		VIRTUAL SBIT32 ComputeHashKey
			( 
			CONST SNATIVE			  & Key 
			);

		VIRTUAL BOOLEAN MatchingKeys
			( 
			CONST SNATIVE			  & Key1,
			CONST SNATIVE			  & Key2 
			);

        //
        //   Disabled operations.
        //
        UNIQUE( CONST UNIQUE & Copy );

        VOID operator=( CONST UNIQUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new unique string table.  This call is not thread     */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::UNIQUE( VOID )
	{
	//
	//   Create the default string.
	//
	Default = CreateString( "",0 );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new unique string.                                    */
    /*                                                                  */
    /*   When we are handed a new string we need to find out whether    */
    /*   it is unique (and needs to be added to the table) or just a    */
    /*   duplicate of an existing string.                               */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CreateString
		( 
		CHAR						  *String,
		SBIT32						  Size 
		)
	{
	AUTO DETAIL *Detail1;
	AUTO DETAIL *Detail2;

	//
	//   Claim an exclusive lock (if enabled).
	//
    Sharelock.ClaimExclusiveLock();

	//
	//   Let us assume that the string is unique and
	//   build an entry to for it.  If we later find
	//   it is not then we just back out the changes.
	//
	if ( Free.EndOfList() )
		{
		REGISTER SBIT32 Count;

		//
		//   Create a several new string descriptions 
		//   and link them into the free list.
		//
		for ( Count=0;Count < MinDetails;Count ++ )
			{
			//
			//   Create a new description and add it 
			//   to the free list.
			//
			Detail1 = new DETAIL;

			Detail1 -> Active = False;

			Detail1 -> Insert( & Free );
			}
		}

	//
	//   We know that the free list must contain 
	//   least one element (if not we would have 
	//   just made some).  We extract the oldest
	//   here.
	//
	if ( (Detail1 = ((DETAIL*) Free.Last())) -> Active )
		{
		//
		//   Delete any existing value when we
		//   recycle an old and unused string
		//   description.  Remember to remove
		//   it from the hash before deleting
		//   the string as the hash uses the
		//   string.
		//
		RemoveFromHash( ((SNATIVE) Detail1) );

		delete [] Detail1 -> Text;

		Detail1 -> Active = False;
		}

	//
	//   We now setup the string description for the 
	//   new string.
	//
	Detail1 -> Size = Size;
	Detail1 -> Text = String;
	Detail1 -> Uses = 1;

	//
	//   We are now ready to search the hash table for
	//   a matching string.  We do this by overloading
	//   the hash table key comparision (see later).
	//
	if ( ! FindInHash( ((SNATIVE) Detail1),((POINTER*) & Detail2) ) )
		{
		//
		//   We have found a new string so we need to
		//   make the string description active and
		//   insert it in the active list.
		//
		(Detail2 = Detail1) -> Active = True;

		Detail1 -> Delete( & Free );
		Detail1 -> Insert( & Active );

		//
		//   Add the new unique string the the hash 
		//   table so we can find it later.
		//
		AddToHash( ((SNATIVE) Detail1),((POINTER) Detail1) );

		//
		//   We know the string is unique so lets
		//   allocate some space for it and copy it 
		//   into the new area.
		//
		Detail1 -> Text = 
			(
			strncpy
				( 
				new CHAR [ (Size + 1) ],
				String,
				Size 
				)
			);

		Detail1 -> Text[ Size ] = '\0';
		}
	else
		{
		//
		//   Increment the use count for an existing
		//   string.
		//
		if ( Detail2 != Default )
			{ 
			//
			//   We may be lucky and find an unused
			//   string.  If so we need to add it to
			//   the active list again.
			//
			if ( (Detail2 -> Uses ++) == 0 )
				{
				//
				//   Add an unused string back to the 
				//   active list again.
				//
				Detail2 -> Delete( & Free );
				Detail2 -> Insert( & Active );
				}
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two strings.                                           */
    /*                                                                  */
    /*   Compare two strings and find the relationship between them.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::CompareStrings
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   We know that all strings are unique so if the
	//   string pointers match then they must be the 
	//   the same string.
	//
	if ( Detail1 != Detail2 )
		{
		REGISTER SBIT32 Result =
			(
			strncmp
				( 
				Detail1 -> Text,
				Detail2 -> Text,
				(Detail1 -> Size < Detail2 -> Size)
					? Detail1 -> Size
					: Detail2 -> Size
				)
			);

		//
		//   If the strings match pick the longest.
		//
		if ( Result == 0 )
			{ Result = ((Detail1 -> Size < Detail2 -> Size) ? -1 : 1); }

		return Result;
		}
	else
		{ return 0; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute a hash key.                                            */
    /*                                                                  */
    /*   Compute a hash key for the supplied key.  This hash key        */
    /*   is used to select the hash chain to search.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::ComputeHashKey
		( 
		CONST SNATIVE				  & Key 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER DETAIL *Detail = ((DETAIL*) Key);
	REGISTER SBIT32 HashKey = 2964557531;

	for ( Count=0;Count < Detail -> Size;Count ++ )
		{
		REGISTER SBIT32 Value = ((SBIT32) Detail -> Text[ Count ]);

		HashKey = ((HashKey * Value) + Value); 
		}

	return (HashKey & 0x3fffffff);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Copy a string.                                                 */
    /*                                                                  */
    /*   All strings are unique so there is no need to copy a string.   */
    /*   Nonetheless, we still have to update the use counts.           */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CopyString
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for old string.
	//
	if ( Detail1 != Default )
		{ Detail1 -> Uses --; }

	//
	//   Increment the use count for new string.
	//
	if ( Detail2 != Default )
		{ Detail2 -> Uses ++; }

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hash keys.                                         */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> BOOLEAN UNIQUE<LOCK>::MatchingKeys
		( 
		CONST SNATIVE				  & Key1,
		CONST SNATIVE				  & Key2 
		)
	{
	REGISTER DETAIL *Detail1 = ((DETAIL*) Key1);
	REGISTER DETAIL *Detail2 = ((DETAIL*) Key2);

	return
		(
		(Detail1 -> Size == Detail2 -> Size)
			&&
		(strncmp( Detail1 -> Text,Detail2 -> Text,Detail1 -> Size ) == 0)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a string.                                               */
    /*                                                                  */
    /*   Delete a text string.                                          */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> VOID UNIQUE<LOCK>::DeleteString( DETAIL *Detail )
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for the string.
	//
	if ( Detail != Default )
		{
		//
		//   Decrement the use count and ensure that
		//   this is not the last use of the string.
		//
		if ( (-- Detail -> Uses) == 0 )
			{
			//
			//   When we delete the last use of
			//   a string we add it to the free 
			//   list.  The string can be reclaimed
			//   if it is recreated before it is
			//   deleted.
			//
			Detail -> Delete( & Active );
			Detail -> Insert( & Free );
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the unique string table.  This call is not thread      */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::~UNIQUE( VOID )
	{ 
	//
	//   Delete all active strings.
	//
	while ( ! Active.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Active.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Active );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SNATIVE) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}

	//
	//   Delete all free strings.
	//
	while ( ! Free.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Free.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Free );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SNATIVE) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\thread.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Thread.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The thread class keeps track of active threads.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 ThreadsSize			  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Static functions local to the class.                           */
    /*                                                                  */
    /*   The static functions used by this class are declared here.     */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL MonitorThread( VOID *Parameter );
STATIC VOID CDECL NewThread( VOID *Parameter );

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a thread class and initialize it.  This call is not     */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

THREAD::THREAD( VOID ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Threads( ThreadsSize,NoAlignment )
    {
	//
	//   Setup the initial flags.
	//
	Active = True;

	//
	//   The inital configuration.
	//
	ActiveThreads = 0;
	MaxThreads = ThreadsSize;

    Affinity = False;
    Cpu = 0;
    Priority = False;
    Stack = 0;

	//
	//   This event is signaled when all threads are 
	//   complete.
	//
    if ( (Completed = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }

	//
	//   This event is signaled when a thread is 
	//   running.
	//
    if ( (Running = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }

	//
	//   This event is signaled when a new thread can 
	//   be started.
	//
    if ( (Started = CreateEvent( NULL, FALSE, TRUE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }

	//
	//   A thread is started whos job in life is to monitor
	//   all the other threads.
	//
	if ( _beginthread( MonitorThread,0,((VOID*) this) ) == NULL )
        { Failure( "Monitor thread in constructor for THREAD" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   End a thread.                                                  */
    /*                                                                  */
    /*   Terminate the current thread.                                  */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::EndThread( VOID )
	{ _endthread(); }

    /********************************************************************/
    /*                                                                  */
    /*   The monitor thread.                                            */
    /*                                                                  */
    /*   The monitor thread simply watches the lifetimes of all the     */
    /*   other threads in the process.                                  */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL MonitorThread( VOID *Parameter )
    {
	AUTO SBIT32 Current = 0;
	REGISTER THREAD *Thread = ((THREAD*) Parameter);

	//
	//   The monitor thread only remains active while 
	//   the class is active.
	//
	while ( Thread -> Active )
		{
		//
		//   There is little point in trying to sleep
		//   on a thread handle if no threads are active.
		//
		if ( Thread -> ActiveThreads > 0 )
			{
			REGISTER DWORD Status = 
				(WaitForSingleObject( Thread -> Threads[ Current ],1 ));

			//
			//   Claim a spinlock so we can update the 
			//   thread table.
			//
			Thread -> Spinlock.ClaimLock();

			//
			//   A wait can terminate in various ways
			//   each of which is dealt with here.
			//
			switch ( Status )
				{
				case WAIT_OBJECT_0:
					{
					REGISTER SBIT32 *ActiveThreads = & Thread -> ActiveThreads;

					//
					//   The thread has terminated so close
					//   the thread handle.
					//
					CloseHandle( Thread -> Threads[ Current ] );

					//
					//   Delete the handle from the table
					//   if it was not the last entry.
					//
					if ( (-- (*ActiveThreads)) > 0 )
						{
						REGISTER SBIT32 Count;

						//
						//   Copy down the remaining 
						//   thread handles.
						//
						for ( Count=Current;Count < (*ActiveThreads);Count ++ )
							{						
							Thread -> Threads[ Count ] =
								Thread -> Threads[ (Count+1) ];
							}

						//
						//   We may need to wrap around to
						//   the start of the array.
						//
						Current %= (*ActiveThreads);
						}
					else
						{ SetEvent( Thread -> Completed ); }

					break;
					}

				case WAIT_TIMEOUT:
					{
					//
					//   The thread is still active so try the
					//   next thread handle.
					//
					Current = ((Current + 1) % Thread -> ActiveThreads);

					break;
					}

				case WAIT_FAILED:
					{ Failure( "Wait fails in MonitorThread" ); }

				default:
					{ Failure( "Missing case in MonitorThread" ); }
				}

			//
			//   We are finished so release the lock.
			//
			Thread -> Spinlock.ReleaseLock();
			}
		else
			{ Sleep( 1 ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   When a new thread is created it executes a special initial     */
    /*   function which configures it.  When control returns to this    */
    /*   function the thread is terminated.                             */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL NewThread( VOID *Parameter )
    {
	REGISTER THREAD *Thread = ((THREAD*) Parameter);
	REGISTER NEW_THREAD ThreadFunction = Thread -> ThreadFunction;
	REGISTER VOID *ThreadParameter = Thread -> ThreadParameter;

    //
    //   Set the affinity mask to the next processor 
	//   if requested.
    //  
    if ( (Thread -> Affinity) && (Thread -> NumberOfCpus() > 1) )
        {
        REGISTER DWORD AffinityMask;

        if ( (Thread -> Cpu) < (Thread -> NumberOfCpus()) )
            { AffinityMask = (1 << (Thread -> Cpu ++)); }
        else
            {
            AffinityMask = 1;
            Thread -> Cpu = 1;
            }

        if ( SetThreadAffinityMask( GetCurrentThread(),AffinityMask ) == 0 )
            { Failure( "Affinity mask invalid in NewThread()" ); }
        }

    //
    //   Set the priority to 'HIGH' if requested.
    //
    if ( Thread -> Priority )
        { SetThreadPriority( GetCurrentThread(),THREAD_PRIORITY_HIGHEST ); }

	//
	//   The thread is now ready so add it to the table
	//   executiong threads.
	//
	Thread -> RegisterThread();

	//
	//   Wake up anyone who is waiting.
	//
	if ( Thread -> ThreadWait )
		{ SetEvent( Thread -> Running ); }

	SetEvent( Thread -> Started );

    //
    //   Call the thread function.
    //
    ThreadFunction( ThreadParameter );

    //
    //   The thread function has returned so exit.
    //
    Thread -> EndThread();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Register the current thread.                                   */
    /*                                                                  */
    /*   When a thread has created we can add the thread info to        */
    /*   our internal table.                                            */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::RegisterThread( VOID )
    {
	AUTO HANDLE NewHandle;
	REGISTER HANDLE Process = GetCurrentProcess();
	REGISTER HANDLE Thread = GetCurrentThread();

	//
	//   Claim a spinlock so we can update the 
	//   thread table.
	//
	Spinlock.ClaimLock();

	//
	//   We need to duplicate the handle so we get
	//   a real thread handle and not the pretend
	//   ones supplied by NT.
	//
	if
			(
			DuplicateHandle
				(
				Process,
				Thread,
				Process,
				& NewHandle,
				DUPLICATE_SAME_ACCESS,
				False,
				DUPLICATE_SAME_ACCESS
				)
			)
		{
		//
		//   We may need to expand the table if there are
		//   a large number of threads.
		//
		while ( ActiveThreads >= MaxThreads )
			{ Threads.Resize( (MaxThreads *= ExpandStore) ); }

		//
		//   Add the thread handle to the table.
		//
		Threads[ ActiveThreads ++ ] = NewHandle;
		}
	else
		{ Failure( "Failed to duplicate handle in RegisterThread" ); }

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Set thread stack size.                                         */
    /*                                                                  */
    /*   Set thread stack size.  This will cause all new threads to     */
    /*   be created with the selected stack size.                       */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::SetThreadStackSize( LONG Stack ) 
    {
#ifdef DEBUGGING
    if ( Stack >= 0 )
        {
#endif
        this -> Stack = Stack;
#ifdef DEBUGGING
        }
    else
        { Failure( "Stack size in SetThreadStack()" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   Start a new thread and configure it as requested by the        */
    /*   caller.  If needed we will set the affinity and priority       */
    /*   of this thread later.                                          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::StartThread( NEW_THREAD Function,VOID *Parameter,BOOLEAN Wait )
    {
	//
	//   Wait for any pending thread creations to
	//   complete.
	//
    if ( WaitForSingleObject( Started,INFINITE ) == WAIT_OBJECT_0 )
		{
		REGISTER unsigned NewStack = ((unsigned) Stack);

		//
		//   Store the thread function and parameter
		//   so they can be extracted later.
		//
		ThreadFunction = Function;
		ThreadParameter = Parameter;
		ThreadWait = Wait;

		//
		//   Call the operating system to start the thread.
		//
		if ( _beginthread( NewThread,NewStack,((VOID*) this) ) != NULL )
			{
			//
			//   Wait for the thread to initialize if needed.
			//
			return
				(
				(! Wait)
					||
				(WaitForSingleObject( Running,INFINITE ) == WAIT_OBJECT_0)
				);
			}
		else
			{ return False; }
		}
	else
		{ return False; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for threads.                                              */
    /*                                                                  */
    /*   Wait for all threads to finish and then return.  As this may   */
    /*   take a while an optional timeout may be supplied.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::WaitForThreads( LONG WaitTime )
    {
	REGISTER DWORD Wait = ((DWORD) WaitTime);

	return ( WaitForSingleObject( Completed,Wait ) != WAIT_TIMEOUT );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the thread class.  This call is not thread safe        */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

THREAD::~THREAD( VOID )
    {
	Active = False;

	if 
			(
			! CloseHandle( Started )
				||
			! CloseHandle( Running )
				||
			! CloseHandle( Completed )
			)
		{ Failure( "Event handles in destructor for THREAD" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\ticket.hpp ===
#ifndef _TICKET_HPP_
#define _TICKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The ticket constants specify the initial size of the           */
    /*   ticket array.                                                  */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 TicketSize			  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Ticketing to maintain ordering.                                */
    /*                                                                  */
    /*   This class provides general purpose event ordering so          */
    /*   that events can arrive in any order but processed in           */
    /*   sequential order with a minimal amount of fuss.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class TICKET : public LOCK
    {
		//
		//   Private data structure.
		//
		typedef struct
			{
			BOOLEAN					  Available;
			TYPE					  Data;
			}
		STUB;

        //
        //   Private data.
        //
        SBIT32						  MaxSize;

        SBIT32						  Back;
        SBIT32						  Front;

        SBIT32						  Base;
        SBIT32						  Stride;

        VECTOR<STUB>				  Ticket;

    public:
        //
        //   Public functions.
        //
        TICKET
			( 
			SBIT32					  Start = 0,
			SBIT32					  NewMaxSize = TicketSize,
			SBIT32					  NewStride = 1  
			);

		BOOLEAN CollectTicket( TYPE *Data,SBIT32 *Ticket );

		SBIT32 NumberOfTickets( VOID );

		SBIT32 NewTicket( VOID );

		BOOLEAN PunchTicket( CONST TYPE & Data,SBIT32 Ticket );

        ~TICKET( VOID );

		//
		//   Public inline functions.
		//
		SBIT32 LowestOutstandingTicket( VOID )
			{ return Base; }

	private:

        //
        //   Disabled operations.
        //
        TICKET( CONST TICKET & Copy );

        VOID operator=( CONST TICKET & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new ticket queue and prepare it for use.  This call   */
    /*   is not thread safe and should only be made in a single thread  */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::TICKET
		( 
		SBIT32						  Start,
		SBIT32						  NewMaxSize,
		SBIT32						  NewStride
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Set the initial ticket number.
		//
		Base = Start;
		Stride = NewStride;
#ifdef DEBUGGING
        }
    else
        { Failure( "MaxSize in constructor for TICKET" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Issue a new ticket.                                            */
    /*                                                                  */
    /*   We issue a new ticket and allocate a place in the line.  We    */
    /*   also we reserve space in the ticket queue.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NewTicket( VOID )
    {
	REGISTER SBIT32 Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Ticket[ Back ++ ].Available = False;

     if ( Back >= MaxSize )
        { Back = 0; }

	//
	//   Compute the ticket number.
	//
	Result = (Base + (NumberOfTickets() * Stride));

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

		//
		//   Expand the queue (it will be at least doubled).
		//
		Ticket.Resize( NewSize );

		//
		//   Copy the tail end of the queue to the correct
		//   place in the expanded queue.
		//
		for ( Count = 0;Count < Back;Count ++ )
			{ Ticket[ (MaxSize + Count) ] = Ticket[ Count ]; }

		//
		//   Update the control information.
		//
		Back += MaxSize;
		MaxSize = NewSize;
		}

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Punch a ticket and store any associated data.                  */
    /*                                                                  */
    /*   We punch a ticket so it can be collected and store any         */
    /*   related data.                                                  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::PunchTicket
		( 
		CONST TYPE					  & Data,
		SBIT32						  Ticket
		)
    {
    REGISTER BOOLEAN Result;
	REGISTER SBIT32 TicketOffset;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Compute the offset in the ticket array.
	//
	TicketOffset = ((Ticket - Base) / Stride);

	//
	//   Ensure the ticket refers to and active ticket
	//   that has not already been recycled.
	//
	if ( (TicketOffset >= 0) && (TicketOffset < NumberOfTickets()) )
		{
		REGISTER STUB *Stub = & Ticket[ TicketOffset ];

		//
		//   Ensure the ticket has not already been
		//   punched.
		//
		if ( ! Stub -> Available )
			{
			Stub -> Available = True;
			Stub -> Data = Data;

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Collect the lowest numbered ticket.                            */
    /*                                                                  */
    /*   We try to collect the lowest numbered ticket that has been     */
    /*   issued.  If it is has been punched and is available we         */
    /*   recycle it after returning any associated data to the caller.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::CollectTicket
		( 
		TYPE						  *Data,
		SBIT32						  *Ticket
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the ticket queue is not empty.
	//
    if ( Front != Back )
        {
		REGISTER STUB *Stub = & Ticket[ Front ];

		//
		//   We can collect the first ticket in the
		//   ticket queue if it has been punched.
		//
		if ( Stub -> Available )
			{
			//
			//   We have an ticket ready so return it to 
			//   the caller.  If we walk off the end of  
			//   the ticket queue then wrap to the other
			//   end.
			//
			(*Data) = Stub -> Data;
			(*Ticket) = (Base += Stride);

			if ( (++ Front) >= MaxSize )
				{ Front = 0; }

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the reorder queue.                       */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NumberOfTickets( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Compute the size of the reorder queue.
	//
	Size = (Back - Front);

	//
	//   If the queue has wrapped then adjust as needed.
	//
	if ( Size < 0 )
		{ Size += MaxSize; }

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::~TICKET( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\tlc.hpp ===
#ifndef _TLC_HPP_
#define _TLC_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"
#include "Spinlock.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A thread local class.                                          */
    /*                                                                  */
    /*   A significant number of SMP applications need thread local     */
    /*   data structures.  Here we support the automatic creation       */
    /*   and management of such structures.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class TLC
    {
        //
        //   Private data.
        //
		LIST						  ActiveList;
		LIST						  FreeList;
	    SPINLOCK					  Spinlock;
		TLS							  Tls;

    public:
        //
        //   Public functions.
        //
        TLC( VOID );

        ~TLC( VOID );

		//
		//   Public inline functions.
		//
		INLINE TYPE *GetPointer( VOID )
			{
			REGISTER LIST *Class = ((LIST*) Tls.GetPointer());

			return ((Class != NULL) ? ((TYPE*) & Class[1]) : CreateClass());
			}

		INLINE VOID Delete( VOID )
			{
			REGISTER LIST *Class = ((LIST*) Tls.GetPointer());

			if ( Class != NULL )
				{ DeleteClass( Class ); }
			}

	private:
		//
		//   Private functions.
		//
		TYPE *CreateClass( VOID );

		VOID DeleteClass( LIST *Class );

        //
        //   Disabled operations.
        //
        TLC( CONST TLC & Copy );

        VOID operator=( CONST TLC & Copy );
    };
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a thread private management class.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TLC<TYPE>::TLC( VOID )
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Create a new class.                                            */
    /*                                                                  */
    /*   Create a new private class and store a pointer to it in        */
    /*   the thread local store.                                        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE *TLC<TYPE>::CreateClass( VOID )
	{
	REGISTER LIST *Class;

	//
	//   Claim a spinlock just in case multiple
	//   threads are active.
	//
	Spinlock.ClaimLock();

	//
	//   We are more than happy to use any existing
	//   memory allocation from the free list if
	//   one is available.
	//
	Class = FreeList.First();

	//
	//   If the free list is empty we create a new
	//   class using the memory allocator.  If it is
	//   not empty we delete the first element from
	//   the list.
	//
	if ( Class == NULL )
		{
		REGISTER SBIT32 TotalSize = (sizeof(LIST) + sizeof(TYPE));

		//
		//   Cache align the size.  This may look
		//   like a waste of time but is worth
		//   30% in some cases when we are correctly
		//   aligned.
		//
		TotalSize = ((TotalSize + CacheLineMask) & ~CacheLineMask);

		Class = ((LIST*) new CHAR [ TotalSize ]); 
		}
	else
		{ Class -> Delete( & FreeList ); }

	PLACEMENT_NEW( & Class[0],LIST );

	//
	//   We need to add the new class to the active
	//   list so we can rememebr to delete it later.
	//
	Class -> Insert( & ActiveList );

	//
	//   Relaese the lock we claimed earlier.
	//
	Spinlock.ReleaseLock();

	//
	//   Finally, update the TLS pointer and call the
	//   class constructor to get everything ready for
	//   use.
	//
	Tls.SetPointer( Class );

	PLACEMENT_NEW( & Class[1],TYPE );

	return ((TYPE*) & Class[1]);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a class.                                                */
    /*                                                                  */
    /*   We may need to delete a thread local class in some situations  */
    /*   so here we call the destructor and recycle the memory.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID TLC<TYPE>::DeleteClass( LIST *Class )
	{
	//
	//   Call the destructor for clean up.
	//
	PLACEMENT_DELETE( & Class[1],TYPE );

	//
	//   Claim a spinlock just in case multiple
	//   threads are active.
	//
	Spinlock.Claimlock();

	//
	//   Call the destructor for clean up.
	//
	PLACEMENT_DELETE( & Class[0],LIST );

	//
	//   Move the element from the active list
	//   to the free list.
	//
	Class -> Delete( & ActiveList );

	Class -> Insert( & FreeList );

	//
	//   Relaese the lock we claimed earlier.
	//
	Spinlock.ReleaseLock();

	//
	//   Finally, zero the TLS pointer.
	//
	Tls.SetPointer( NULL );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destroy a thread private management class.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TLC<TYPE>::~TLC( VOID )
	{
	REGISTER LIST *Current;

	//
	//   Walk the list of active classes and release
	//   them back to the heap.
	//
	for 
			( 
			Current = ActiveList.First();
			Current != NULL;
			Current = ActiveList.First()
			)
		{
		//
		//   Call the destructor, remove the element
		//   from the active list and free it.
		//
		PLACEMENT_DELETE( (Current + 1),TYPE );

		Current -> Delete( & ActiveList );

		delete [] ((CHAR*) Current);
		}

	//
	//   Walk the list of free classes and release
	//   them back to the heap.
	//
	for 
			( 
			Current = FreeList.First();
			Current != NULL;
			Current = FreeList.First()
			)
		{
		//
		//   Remove the element from the free list  
		//   and free it.
		//
		Current -> Delete( & FreeList );

		delete [] Current;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\vector.hpp ===
#ifndef _VECTOR_HPP_
#define _VECTOR_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"
#ifdef DEBUGGING

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here control various aspects of the    */
    /*   vector classes debugging operations.                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DebugDisplaySize		  = 8;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Vector creation, management and use.                           */
    /*                                                                  */
    /*   A vector is esentially an allocated array of data.  However,   */
    /*   vectors also have some special features.  A vector can be      */
    /*   aligned to any binary boundary and each element can also be    */
    /*   aligned to any binary boundary.  This is very helpful in       */
    /*   SMP systems as increased performance can be obtained by        */
    /*   using vectors on selected data structures.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class VECTOR
    {
        //
        //   Private data.
        //
        CHAR                          *Address;
#ifdef DEBUGGING
		TYPE                          *Display[DebugDisplaySize];
#endif

        SBIT32                        Elements;
        SBIT32                        Size;

    public:
        //
        //   Public functions.
        //
        VECTOR
            ( 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignmentSize
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignmentSize
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  Two, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignmentSize
            );

        VOID Resize( SBIT32 Reallocate );

        ~VECTOR( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE & operator[]( SBIT32 Index )
			{
#ifdef DEBUGGING
			if ( (Index < 0) || (Index >= Elements) )
				{ Failure( "Array subscript in VECTOR[]" ); }

#endif
			return (*((TYPE*) & Address[ (Index * Size) ]));
			}

        INLINE TYPE *operator&( VOID )
			{ return ((TYPE*) & Address[0]); }

		SBIT32 SizeOfVector( VOID ) 
			{ return Elements; }

	private:
		//
		//   Private functions.
		//
        VOID AllocateAndAlignVector
            ( 
            SBIT32                        NumberOfElements, 
            SBIT32                        AlignmentSize 
            );

		//
        //   Disabled operations.
        //
        VECTOR( CONST VECTOR & Copy );

        VOID operator=( CONST VECTOR & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32						  AlignmentSize
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignmentSize );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Address[ (Count * Size) ], TYPE ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32	                      One,
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignmentSize
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignmentSize );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Address[ (Count * Size) ],TYPE( One ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32	                      One, 
        SBIT32                        Two, 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignmentSize 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignmentSize );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Address[ (Count * Size) ],TYPE( One,Two ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Allocate and align a vector.                                   */
    /*                                                                  */
    /*   We need to allocate some memory and align it as requested      */
    /*   by the user.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::AllocateAndAlignVector
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignmentSize 
        )
    {
    if ( NumberOfElements > 0 )
        {
#ifdef DEBUGGING
		REGISTER SBIT32 Count;

#endif
        //
        //   We need to remember the initial alignment and count of
		//   elements for later.
        //   
        Elements = NumberOfElements;

        //
        //   Calculate the new element size using the requested alignment
		//   value.
        //
		Size = (AlignmentSize - (sizeof(TYPE) % AlignmentSize));
		Size = (Size == AlignmentSize) ? 0 : Size;
		Size += sizeof(TYPE);

        //
        //   Allocate memory and call constructor for each element.
        //   Calculate the start address for requested alignment.
        //
		Address = 
			(
			(CHAR*) _aligned_malloc
				( 
				(NumberOfElements * Size),
				CacheLineSize
				)
			);
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < NumberOfElements) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = ((TYPE*) & Address[ (Count * Size) ]); }
#endif
        }
    else
        { Failure( "Allocation size in AllocateAndAlignVector" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize a memory allocation.                                    */
    /*                                                                  */
    /*   Resize a memory allocation and initialize the resized area.    */
    /*   This call is not thread safe and should only be made in a      */
    /*   single thread environment.                                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::Resize( SBIT32 Reallocate )
    {
	REGISTER SBIT32 Count;

    if ( Reallocate > 0 )
        {
		REGISTER SBIT32 Minimum = 
			((Elements < Reallocate) ? Elements : Reallocate);

		//
		//   Call the destructor for each element that is
		//   about to be deleted.
		//
		for ( Count = (Elements - 1);Count >= Minimum;Count -- )
			{ PLACEMENT_DELETE( & Address[ (Count * Size) ],TYPE ); }

		//
		//   Just ensure that the reallocation is not the same
		//   as the existing structure.
		//
		if ( Elements != Reallocate )
			{
			REGISTER CHAR *NewAddress = 
				(
				(CHAR*) _aligned_realloc
					( 
					Address,
					(Reallocate * Size),
					CacheLineSize 
					)
				);

			//
			//   Ensure we were able to allocate some memory.
			//
			if ( NewAddress != NULL )
				{

				//
				//   Call the constructor for each new element.
				//
				for ( Count = Elements;Count < Reallocate;Count ++ )
					{ 
					(VOID) PLACEMENT_NEW
						(
						& NewAddress[ (Count * Size) ], 
						TYPE 
						); 
					}
#ifdef DEBUGGING

				//
				//   When we are in debug mode calculate the addresses
				//   of the first few elements of the vector.
				//
				for 
						( 
						Count = 0;
						(Count < Reallocate) && (Count < DebugDisplaySize);
						Count ++ 
						)
					{ 
					Display[ Count ] = 
						((TYPE*) & NewAddress[ (Count * Size) ]); 
					}
#endif
	 
				//
				//   Finally, lets update the information about the new
				//   amended allocation.
				//   
				Address = NewAddress;
				Elements = Reallocate;
				}
			else
				{ Failure( "No memory available in Resize" ); }
 			}
       }
    else
        { Failure( "Rellocation size in Resize" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a vector.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::~VECTOR( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Call the destructors.
	//
	for ( Count = (Elements - 1);Count >= 0;Count -- )
		{ PLACEMENT_DELETE( & Address[ (Count * Size) ],TYPE ); }

	//
	//   Delete the storage.
	//
    _aligned_free( Address );
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Wait.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Wait.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

SBIT32 WAIT::Activations = 0;
SBIT32 WAIT::MaxThreads = 0;
SLIST<WAIT::SEMAPHORE_LIST> WAIT::SList;

#ifdef DISABLE_HEAP_USE
WAIT::SEMAPHORE_LIST WAIT::Semaphores[ MaxSemaphores ];
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new and prepare it for use.                           */
    /*                                                                  */
    /********************************************************************/

WAIT::WAIT( SBIT32 NewMaxThreads )
    {
	//
	//   When we have the heap unavailable and we
	//   are using static semaphore we need to prime
	//   the slist when the class is activated for the
	//   first time.
	//
	if ( AtomicIncrement( & Activations ) == 1 )
		{
#ifdef DISABLE_HEAP_USE
		REGISTER SBIT32 Count;

		//
		//   We push each static semaphore on to the
		//   slist.  If we run out at any point then
		//   we will fail.
		//
		for ( Count=0;Count < MaxSemaphores;Count ++ )
			{ SList.Push( & Semaphores[ Count ] ); }
#endif

		//
		//   Setup class contraol variables.
		//
		MaxThreads = NewMaxThreads;
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a semaphore.                                             */
    /*                                                                  */
    /*   When we need a semaphore we may claim one so that we can       */
    /*   sleep on it.                                                   */
    /*                                                                  */
    /********************************************************************/

VOID WAIT::ClaimSemaphore( SEMAPHORE_LIST **Update )
    {
	//
	//   We need to ensure that we don't already have
	//   an active semaphore.  If we do we just exit.
	//
	if ( Semaphore == NULL )
		{
		//
		//   We extract a free semaphore from the slist
		//   if one is available.
		//
		if ( ! SList.Pop( Update ) )
			{
#ifndef DISABLE_HEAP_USE
			//
			//   When we do not have a semaphore on the
			//   slist we try to create a new one.
			//
			(*Update) = new SEMAPHORE_LIST;
#endif
			}

		//
		//   We ensure that we have managed to obtain 
		//   a semaphore somehow.
		//
		if ( (*Update) != NULL )
			{
			REGISTER SEMAPHORE_LIST *Current =
				(
				(SEMAPHORE_LIST*) AtomicCompareExchangePointer
					( 
					((VOLATILE VOID**) & Semaphore),
					(*Update),
					NULL 
					)
				);

			//
			//   We now try to place the semaphore in
			//   the current slot.  If we find that we
			//   already have one somehow we push it on
			//   the slist for later.
			//
			if ( Current != NULL )
				{
				//
				//   We already have a semaphore so save
				//   the new one and return the current one.
				//
				SList.Push( (*Update) );

				(*Update) = Current;
				}
			}
		else
			{ Failure( "No semaphore in Create" ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Relaese a semaphore.                                           */
    /*                                                                  */
    /*   When we have finished with a semaphore we can return it for    */
    /*   reuse.  It is the callers responsibility to ensure the         */
    /*   semaphore is free.  If not a thread could sleep forever as     */
    /*   any wakeup signal could be sent to an alternative thread.      */
    /*                                                                  */
    /********************************************************************/

VOID WAIT::ReleaseSemaphore( VOID )
    {
	REGISTER SEMAPHORE_LIST *Current = Semaphore;

	//
	//   We ensure that we have a semaphore.  If not we
	//   just quitely exit.
	//
	if ( Current != NULL )
		{
		//
		//   We try to extract the semaphore so we can
		//   push it on the slist.  If we fail we just
		//   forget it.
		//
		if
				(
				AtomicCompareExchangePointer
					( 
					((VOLATILE VOID**) & Semaphore),
					NULL,
					Current
					) != NULL
				)
			{ SList.Push( Current ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a wait and if needed clean up.                         */
    /*                                                                  */
    /********************************************************************/

WAIT::~WAIT( VOID )
    {
	//
	//   When the last activation of the class has
	//   completed we empty the slist and delete any 
	//   semaphores if needed.
	//
	if ( AtomicDecrement( & Activations ) == 0 )
		{
		REGISTER SEMAPHORE_LIST *Current;

#ifdef DISABLE_HEAP_USE
		//
		//   Walk the slist to remove any semaphores.
		//
		while ( SList.Pop( & Current ) );
#else
		//
		//   Walk the slist and delete any semaphores.
		//
		while ( SList.Pop( & Current ) )
			{ delete Current; }
#endif
		}
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_library_none_12.4.56.0_none_4e88bf41204b23e1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=library
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_library_no-public-key_12.4.56.0_x-ww_b3574531.manifest
XP_MANIFEST_PATH=manifests\x86_library_no-public-key_12.4.56.0_x-ww_b3574531.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_library_no-public-key_12.4.56.0_x-ww_b3574531.cat
XP_CATALOG_PATH=manifests\x86_library_no-public-key_12.4.56.0_x-ww_b3574531.cat
XP_PAYLOAD_PATH=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=library,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_library_none_12.4.56.0_none_4e88bf41204b23e1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=library
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_library_no-public-key_12.4.56.0_x-ww_b3574531.manifest
XP_MANIFEST_PATH=manifests\x86_library_no-public-key_12.4.56.0_x-ww_b3574531.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_library_no-public-key_12.4.56.0_x-ww_b3574531.cat
XP_CATALOG_PATH=manifests\x86_library_no-public-key_12.4.56.0_x-ww_b3574531.cat
XP_PAYLOAD_PATH=x86_library_no-public-key_12.4.56.0_x-ww_b3574531
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=library,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\library\Wait.hpp ===
#ifndef _WAIT_HPP_
#define _WAIT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"
#include "Semaphore.hpp"
#include "SList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control static semaphore list.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxSemaphores			  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   A provider of waits (not weights :-).                          */
    /*                                                                  */
    /*   When a thread needs to wait a suitable semaphore can be        */
    /*   dynamically acquired, used and later returned.  Care must      */
    /*   be taken to release the wait until the semaphore is free.      */
    /*                                                                  */
    /********************************************************************/

class WAIT : public ASSEMBLY
    {
		//
		//   Private type definitions.
		//
		typedef struct SEMAPHORE_LIST : public SLIST<SEMAPHORE_LIST>
			{
	        SEMAPHORE                 Semaphore;
			}
		SEMAPHORE_LIST;

		//
		//   Private data.
		//
		SEMAPHORE_LIST				  *Semaphore;

        //
        //   Static private data.
        //
		STATIC SBIT32				  Activations;
		STATIC SBIT32				  MaxThreads;
		STATIC SLIST<SEMAPHORE_LIST>  SList;

#ifdef DISABLE_HEAP_USE
		STATIC SEMAPHORE_LIST		  Semaphores[ MaxSemaphores ];
#endif

    public:
        //
        //   Public functions.
        //
        WAIT( SBIT32 NewMaxThreads = DefaultMaxThreads );

        VOID ClaimSemaphore( SEMAPHORE_LIST **Current = NULL );

        VOID ReleaseSemaphore( VOID );

        ~WAIT( VOID );

		//
		//   Public inline functions.
		//
		INLINE VOID Signal( SBIT32 Count = 1 )
			{
			AUTO SEMAPHORE_LIST *Current = Semaphore;

			if ( Current == NULL )
				{ ClaimSemaphore( & Current ); }

			Current -> Semaphore.Signal( Count ); 
			}

		INLINE BOOLEAN Wait( SBIT32 Timeout = INFINITE )
			{
			AUTO SEMAPHORE_LIST *Current = Semaphore;

			if ( Current == NULL )
				{ ClaimSemaphore( & Current ); }

			return Current -> Semaphore.Wait( Timeout ); 
			}

	private:
        //
        //   Disabled operations.
        //
        WAIT( CONST WAIT & Copy );

        VOID operator=( CONST WAIT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\BlendedHeap.hpp ===
#ifndef _BLENDED_HEAP_HPP_
#define _BLENDED_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A blended heap.                                                */
    /*                                                                  */
    /*   A blended heap tries to provide good performance and           */
    /*   thoughtfull memory layout for a modest cost in terms of        */
    /*   additional memory usage.                                       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE BLENDED_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        BLENDED_HEAP
			( 
			int						  MaxFreeSpace = HalfMegabyte,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~BLENDED_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BLENDED_HEAP( const BLENDED_HEAP & Copy );

        void operator=( const BLENDED_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\blendedheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "BlendedHeap.hpp"
#include "RockallBackEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 4096;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 2048;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,       64,       32,     1024 },
		{        8,       32,       32,     1024 },
		{       12,       32,       64,     1024 },
		{       16,       16,       64,     1024 },
		{       20,       16,       64,     1024 },
		{       24,       12,      128,     1024 },
		{       28,       12,      128,     1024 },

		{       32,       12,      128,     1024 },
		{       40,        8,      128,     1024 },
		{       48,        8,	  1024,     1024 },
		{       56,        8,	  1024,     1024 },

		{       64,        8,     2048,     2048 },
		{       80,        4,     2048,     2048 },
		{       96,        4,     2048,     2048 },
		{      112,        4,     2048,     2048 },

		{      128,        4,     4096,     4096 },
		{      160,        4,     4096,     4096 },
		{      192,        4,     4096,     4096 },
		{      224,        4,     4096,     4096 },

		{      256,        4,     4096,     4096 },
		{      320,        2,     4096,     4096 },
		{      384,        2,     4096,     4096 },
		{      448,        2,     4096,     4096 },
		{      576,        2,     8192,     8192 },
		{      640,        0,     4096,     4096 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        2,     8192,     8192 },
		{     2048,        2,     8192,     8192 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,    65536,    65536 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::BLENDED_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_FRONT_END
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			(ROCKALL_BACK_END::RockallBackEnd()),
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::~BLENDED_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\defaultheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   Create a single static instance of the default heap so         */
    /*   that is available as soon as the DLL has finished loading.     */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
DEFAULT_HEAP DefaultHeap;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\DynamicDebugHeap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DynamicDebugHeap.hpp"
#include "List.hpp"
#include "New.hpp"
#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Structures local to the class.                                 */
    /*                                                                  */
    /*   The structures supplied here describe the layout of the        */
    /*   private per thread heap structures.                            */
    /*                                                                  */
    /********************************************************************/

typedef struct DYNAMIC_HEAP : public LIST
	{
	ROCKALL_FRONT_END				  *Heap;
	}
DYNAMIC_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC SHARELOCK Sharelock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DYNAMIC_DEBUG_HEAP::DYNAMIC_DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe,
		//
		//   Additional debug flags.
		//
		bool						  FunctionTrace,
		int							  PercentToDebug,
		int							  PercentToPage,
		bool						  TrapOnUserError
		) :
		//
		//   Call the constructors for the contained classes.
		//
		DebugHeap( 0,false,false,ThreadSafe,FunctionTrace,TrapOnUserError ),
		FastHeap( MaxFreeSpace,Recycle,false,ThreadSafe ),
		PageHeap( 0,false,false,ThreadSafe,FunctionTrace,TrapOnUserError )
	{
	//
	//   Setup various control variables.
	//
	Active = false;

	//
	//   Create the linked list header and zero
	//   any other variables.
	//
	AllHeaps = ((LIST*) SMALL_HEAP::New( sizeof(LIST) ));
	Array = ((DYNAMIC_HEAP*) SMALL_HEAP::New( (sizeof(DYNAMIC_HEAP) * 3) ));
	HeapWalk = NULL;

	PercentDebug = PercentToDebug;
	PercentPage = PercentToPage;

	//
	//   We can only activate the the heap if we manage
	//   to allocate the space we requested.
	//
	if (  (AllHeaps != NULL) && (Array != NULL)) 
		{
		//
		//   Execute the constructors for each linked list
		//   and for the thread local store.
		//
		PLACEMENT_NEW( AllHeaps,LIST );

		//
		//   Setup each linked list element.
		//
		PLACEMENT_NEW( & Array[0],DYNAMIC_HEAP );
		PLACEMENT_NEW( & Array[1],DYNAMIC_HEAP );
		PLACEMENT_NEW( & Array[2],DYNAMIC_HEAP );

		//
		//   Setup the heap for each linked list
		//   element and store the pointer.
		//
		Array[0].Heap = & DebugHeap;
		Array[1].Heap = & FastHeap;
		Array[2].Heap = & PageHeap;

		//
		//   Insert each linked list element into
		//   the list of heaps.
		//
		Array[0].Insert( AllHeaps );
		Array[1].Insert( AllHeaps );
		Array[2].Insert( AllHeaps );

		//
		//   Activate the heap.
		//
		Active = true;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   When we delete an allocation we try to each heap in turn       */
    /*   until we find the correct one to use.                          */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::Delete( void *Address,int Size )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   We try the fastest heap as we are betting
		//   it is the most common.
		//
		if ( FastHeap.KnownArea( Address ) )
			{ return (FastHeap.Delete( Address,Size )); }
		else
			{
			//
			//   Next we try the debug heap.
			//
			if ( DebugHeap.KnownArea( Address ) )
				{ return (DebugHeap.Delete( Address,Size )); }
			else
				{
				//
				//   Finally we try the page heap.
				//
				if ( PageHeap.KnownArea( Address ) )
					{ return (PageHeap.Delete( Address,Size )); }
				}
			}
		}

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We walk the list of all the heaps and instruct each heap       */
    /*   to delete everything.                                          */
    /*                                                                  */
    /********************************************************************/

void DYNAMIC_DEBUG_HEAP::DeleteAll( bool Recycle )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER DYNAMIC_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as everything gets
		//   blown away.
		//
		for 
				( 
				Current = ((DYNAMIC_HEAP*) AllHeaps -> First());
				(Current != NULL);
				Current = ((DYNAMIC_HEAP*) Current -> Next())
				)
			{ Current -> Heap -> DeleteAll( Recycle ); }

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   When we are asked for details we try to each heap in turn      */
    /*   until we find the correct one to use.                          */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::Details( void *Address,int *Space )
	{ return Verify( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DYNAMIC_DEBUG_HEAP::HeapLeaks( void )
    {
	//
	//   We call heap leaks for each heap
	//   that supports the interface.
	//
	DebugHeap.HeapLeaks();
	PageHeap.HeapLeaks();
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   When we are asked about an address we try to each heap in      */
    /*   turn until we find the correct one to use.                     */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::KnownArea( void *Address )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   We try the fastest heap as we are betting
		//   it is the most common, followed by the
		//   degug and the page heaps.
		//
		return
			(
			FastHeap.KnownArea( Address )
				||
			DebugHeap.KnownArea( Address )
				||
			PageHeap.KnownArea( Address )
			);
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   We claim all of the heap locks so that it is safe to do        */
    /*   operations like walking all of the heaps.                      */
    /*                                                                  */
    /********************************************************************/

void DYNAMIC_DEBUG_HEAP::LockAll( VOID )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER DYNAMIC_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as we claim all
		//   of the heap locks.
		//
		for 
				( 
				Current = ((DYNAMIC_HEAP*) AllHeaps -> First());
				(Current != NULL);
				Current = ((DYNAMIC_HEAP*) Current -> Next())
				)
			{ Current -> Heap -> LockAll(); }

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When we delete multiple allocations we simply delete each      */
    /*   allocation one at a time.                                      */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER bool Result = true;
	REGISTER SBIT32 Count;

	//
	//   We would realy like to use the multiple
	//   delete functionality of Rockall here but 
	//   it is too much effort.  So we simply call
	//   the standard delete on each entry in the
	//   array.  Although this is not as fast it
	//   does give more transparent results.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		//
		//   Delete each memory allocation after
		//   carefully checking it.
		//
		if ( ! Delete( Array[ Count ],Size ) )
			{ Result = false; }
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   When we do multiple allocations we simply allocate each        */
    /*   piece of memory one at a time.                                 */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER int Random = (RandomNumber() % 100);

		//
		//   We do all the page heap allocations
		//   in accordance with the supplied ratios.
		//
		if ( Random <= PercentPage )
			{ 
			return 
				(
				PageHeap.MultipleNew
					(
					Actual,
					Array,
					Requested,
					Size,
					Space,
					Zero 
					)
				); 
			}
		else
			{
			//
			//   Next we do all the debug allocations
			//   in accordance with the supplied ratios.
			//
			if ( Random <= (PercentPage + PercentDebug) )
				{ 
				return 
					(
					DebugHeap.MultipleNew
						(
						Actual,
						Array,
						Requested,
						Size,
						Space,
						Zero 
						)
					); 
				}
			else
				{ 
				return 
					(
					FastHeap.MultipleNew
						(
						Actual,
						Array,
						Requested,
						Size,
						Space,
						Zero 
						)
					); 
				}
			}
		}
	else
		{
		(*Actual) = 0;

		return false; 
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate from each heap in proportion to the ratios         */
    /*   supplied by the user.                                          */
    /*                                                                  */
    /********************************************************************/

void *DYNAMIC_DEBUG_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER int Random = (RandomNumber() % 100);

		//
		//   We do all the page heap allocations
		//   in accordance with the supplied ratios.
		//
		if ( Random <= PercentPage )
			{ return PageHeap.New( Size,Space,Zero ); }
		else
			{
			//
			//   Next we do all the debug allocations
			//   in accordance with the supplied ratios.
			//
			if ( Random <= (PercentPage + PercentDebug) )
				{ return DebugHeap.New( Size,Space,Zero ); }
			else
				{ return FastHeap.New( Size,Space,Zero ); }
			}
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute a random number.                                       */
    /*                                                                  */
    /*   Compute a random number and return it.                         */
    /*                                                                  */
    /********************************************************************/

int DYNAMIC_DEBUG_HEAP::RandomNumber( VOID )
	{
	STATIC int RandomSeed = 1;

	//
	//   Compute a new random seed value.
	//
	RandomSeed =
		(
		((RandomSeed & 0xff00) * 2964557531)
			+
		((RandomSeed & 0xffff) * 2964557531)
			+
		1
		);

	//
	//   The new random seed is returned.
	//
	return (RandomSeed >> 1);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We reallocate space for an allocation on the original heap     */
    /*   to make sure this case is well tested.                         */
    /*                                                                  */
    /********************************************************************/

void *DYNAMIC_DEBUG_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   We try the fastest heap as we are betting
		//   it is the most common.
		//
		if ( FastHeap.KnownArea( Address ) )
			{ 
			//
			//   Reallocate the memory as requested. 
			//
			return 
				(
				FastHeap.Resize
					( 
					Address,
					NewSize,
					Move,
					Space,
					NoDelete,
					Zero
					)
				);
			}
		else
			{
			//
			//   Next we try the debug heap.
			//
			if ( DebugHeap.KnownArea( Address ) )
				{ 
				//
				//   Reallocate the memory as requested. 
				//
				return 
					(
					DebugHeap.Resize
						( 
						Address,
						NewSize,
						Move,
						Space,
						NoDelete,
						Zero
						)
					);
				}
			else
				{
				//
				//   Finally we try the page heap.
				//
				if ( PageHeap.KnownArea( Address ) )
					{ 
					//
					//   Reallocate the memory as requested. 
					//
					return 
						(
						PageHeap.Resize
							( 
							Address,
							NewSize,
							Move,
							Space,
							NoDelete,
							Zero
							)
						);
					}
				}
			}
		}

	return NULL;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *DYNAMIC_DEBUG_HEAP::SpecialNew( int Size )
	{ return FastHeap.New( Size ); }

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::Truncate( int MaxFreeSpace )
    {
	REGISTER bool Result = true;

	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER DYNAMIC_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as we are truncating
		//   all of the heaps.
		//
		for 
				( 
				Current = ((DYNAMIC_HEAP*) AllHeaps -> First());
				(Current != NULL);
				Current = ((DYNAMIC_HEAP*) Current -> Next())
				)
			{
			//
			//   If faulty delete is noted during the
			//   cache flushes then exit with the
			//   correct status.
			//
			if ( ! Current -> Heap -> Truncate( MaxFreeSpace ) )
				{ Result = false; }
			}

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We unlock all of the heap locks so normal processing can       */
    /*   continue on the heaps.                                         */
    /*                                                                  */
    /********************************************************************/

void DYNAMIC_DEBUG_HEAP::UnlockAll( VOID )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER DYNAMIC_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as we claim all
		//   of the heap locks.
		//
		for 
				( 
				Current = ((DYNAMIC_HEAP*) AllHeaps -> First());
				(Current != NULL);
				Current = ((DYNAMIC_HEAP*) Current -> Next())
				)
			{ Current -> Heap -> UnlockAll(); }

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   When we verify an allocation we try to each heap in turn       */
    /*   until we find the correct one to use.                          */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::Verify( void *Address,int *Space )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   We try the fastest heap as we are betting
		//   it is the most common.
		//
		if ( FastHeap.KnownArea( Address ) )
			{ return (FastHeap.Verify( Address,Space )); }
		else
			{
			//
			//   Next we try the debug heap.
			//
			if ( DebugHeap.KnownArea( Address ) )
				{ return (DebugHeap.Verify( Address,Space )); }
			else
				{
				//
				//   Finally we try the page heap.
				//
				if ( PageHeap.KnownArea( Address ) )
					{ return (PageHeap.Verify( Address,Space )); }
				}
			}
		}

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool DYNAMIC_DEBUG_HEAP::Walk( bool *Activity,void **Address,int *Space )
    {
	//
	//   Claim a process wide shared lock
	//   to ensure the list of heaps does
	//   not change until we have finished.
	//
	Sharelock.ClaimShareLock();

	//
	//   Nasty, in 'DYNAMIC_DEBUG_HEAP' we have multiple heaps
	//   to walk so if we don't have a current heap
	//   then just select the first available.
	//
	if ( ((*Address) == NULL) || (HeapWalk == NULL) )
		{ HeapWalk = ((DYNAMIC_HEAP*) AllHeaps -> First()); }

	//
	//   Walk the heap.  When we come to the end of
	//   the current heap then move on to the next
	//   heap.
	//
	while 
			( 
			(HeapWalk != NULL)
				&& 
			(! HeapWalk -> Heap -> Walk( Activity,Address,Space ))
			)
		{ HeapWalk = ((DYNAMIC_HEAP*) HeapWalk -> Next()); }

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();

	return (HeapWalk != NULL);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

DYNAMIC_DEBUG_HEAP::~DYNAMIC_DEBUG_HEAP( void )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Deactivate the heap.
		//
		Active = false;

		//
		//   Delete each linked list element into
		//   the list of heaps.
		//
		Array[2].Delete( AllHeaps );
		Array[1].Delete( AllHeaps );
		Array[0].Delete( AllHeaps );

		//
		//   Delete each linked list element.
		//
		PLACEMENT_DELETE( & Array[2],DYNAMIC_HEAP );
		PLACEMENT_DELETE( & Array[1],DYNAMIC_HEAP );
		PLACEMENT_DELETE( & Array[0],DYNAMIC_HEAP );

		//
		//   Call the list and TLS destructors.
		//
		PLACEMENT_DELETE( AllHeaps,LIST );

		//
		//   Delete the space.
		//
		SMALL_HEAP::Delete( Array );
		SMALL_HEAP::Delete( AllHeaps );

		//
		//   Zero the pointers just to be tidy.
		//
		HeapWalk = NULL;
		Array = NULL;
		AllHeaps = NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\DefaultHeap.hpp ===
#ifndef _DEFAULT_HEAP_HPP_
#define _DEFAULT_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef _DEBUG
#include "DebugHeap.hpp"
typedef DEBUG_HEAP DEFAULT_HEAP;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP DEFAULT_HEAP;
#endif
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   The default heap is available for everyone as soon as the      */
    /*   memory allocator DLL has loaded.                               */
    /*                                                                  */
    /********************************************************************/

extern ROCKALL_DLL_LINKAGE DEFAULT_HEAP DefaultHeap;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\DebugHeap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MaxLeadingGuardWords		  = (MaxFunctions + 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CALL_STACK;

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL_DEBUG_FRONT_END
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Count;
			int						  Size;
			void					  *Functions[ MaxLeadingGuardWords ];
			}
		HEADER;

		typedef struct
			{
			char					  GuardBytes[ GuardSize ];
			void					  *GuardWords[1];
			}
		TRAILER;

		typedef struct
			{
			HEADER					  DebugHeader;
			TRAILER					  DebugTrailer;
			}
		HEADER_AND_TRAILER;

		//
		//   Private data.
		//
		CALL_STACK					  *CallStack;
		bool						  ExitOnError;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			bool					  TrapOnUserError = true
			);

		virtual void HeapLeaks( void );

        virtual ~DEBUG_HEAP( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   debug memory allocations.
		//
		virtual void DeleteGuard( void *Address );

		virtual bool NewGuard( void **Address,int Size,int *Space );

		virtual bool VerifyGuard( void *Address,int *Size,int *Space );

		virtual bool WalkGuard( bool *Active,void **Address,int *Space );

		virtual void UserError( void *Address,void *Details,char *Message );

	private:
		//
		//   Private functions.
		//
		//   Support functions to compute various
		//   offsets and sizes within the page heap.
		//   
		void *ComputeHeapAddress( void *Address );

		void *ComputeUserAddress( void *Address );
			 
		int ComputeUserSpace( int Space );

		//
		//   Private functions.
		//
		//   Support functions to implement the guard
		//   words for the debug heap.
		//   
		bool VerifyAddress
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		bool VerifyHeader
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyHeaderAndTrailer
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			TRAILER					  **Trailer,
			bool					  Verify
			);

		bool VerifyTrailer
			( 
			HEADER					  *Header,
			int						  Space,
			TRAILER					  **Trailer
			);

		void WriteGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\debugheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "CallStack.hpp"
#include "DebugHeap.hpp"
#include "Globallock.hpp"
#include "New.hpp"
#include "RockallDebugBackEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxContents			  = 32;
CONST SBIT32 DebugBufferSize		  = 256;
CONST SBIT32 SkipFunctions			  = 2;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },
		{       28,        0,      256,      256 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },
		{       56,        0,      512,      512 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },
		{      112,        0,     1024,     1024 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     8192,     8192 },
		{      640,        0,     4096,     4096 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(compiler)
STATIC ROCKALL_DEBUG_BACK_END RockallDebugBackEnd( true,false );

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe,
		//
		//   Additional debug flags.
		//
		bool						  FunctionTrace,
		bool						  TrapOnUserError
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_DEBUG_FRONT_END
			(
			Caches1,
			Caches2,
			MaxFreeSpace,
			& RockallDebugBackEnd,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We will only enable the symbols if they are
	//   requested by the user.  If not we will zero
	//   the class pointer.
	//
	if ( FunctionTrace )
		{
		//
		//   We will try to allocate some space so we can
		//   support the annoation of memory allocations
		//   will call traces.
		//
		CallStack = ((CALL_STACK*) SpecialNew( sizeof(CALL_STACK) ));
		
		//
		//   We ensure that we were able to allocate the 
		//   required space.
		//
		if ( CallStack != NULL )
			{ PLACEMENT_NEW( CallStack,CALL_STACK ); }
		}
	else
		{ CallStack = NULL; }

	//
	//   We know that Rockall can survive a wide variety
	//   of user errors.  Nonetheless, we can optionally 
	//   raise an exception whn there is an error.
	//
	ExitOnError = TrapOnUserError;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the heap address.                                      */
    /*                                                                  */
    /*   Compute the heap address from the user address.                */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::ComputeHeapAddress( void *Address )
	{ return ((void*) (((char*) Address) - sizeof(HEADER))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the user address.                                      */
    /*                                                                  */
    /*   Compute the user address from the heap address.                */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::ComputeUserAddress( void *Address )
	{ return ((void*) (((char*) Address) + sizeof(HEADER))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the user space.                                        */
    /*                                                                  */
    /*   Compute the user space from the supplied size.                 */
    /*                                                                  */
    /********************************************************************/

int DEBUG_HEAP::ComputeUserSpace( int Space )
	{ return (Space - sizeof(HEADER_AND_TRAILER)); }

    /********************************************************************/
    /*                                                                  */
    /*   Delete the guard words.                                        */
    /*                                                                  */
    /*   When we delete a memory allocation we overwrite it with        */
    /*   guard words to make it really unpleasant for anyone who        */
    /*   reads it and easy to spot when anyone write to it.             */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::DeleteGuard( void *Address )
	{
	AUTO HEADER *Header;
	AUTO TRAILER *Trailer;
	AUTO int Space;

	//
	//   Although we are about to delete the memory
	//   allocation there is still a chance that it
	//   got corrupted.  So we need to verify that
	//   it is still undamaged.
	//
	if ( VerifyHeaderAndTrailer( Address,& Header,& Space,& Trailer,false ) )
		{
		//
		//   We need to overwrite all of the allocation
		//   to ensure that if the code tries to read 
		//   any existing data that it is overwritten.
		//
		WriteGuardWords( ((void*) Header),Space );

		//
		//   Delete the allocation.  This really ought 
		//   to work given we have already checked that 
		//   the allocation is valid unless there is a  
		//   race condition.
		//
		if ( ! ROCKALL_FRONT_END::Delete( ((void*) Header),Space ) )
			{ UserError( Address,NULL,"Delete failed due to race" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( WalkGuard( & Active,& Address,& Space ) )
		{
		AUTO CHAR Contents[ ((MaxContents + 4) * 2) ];

#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO HEADER *Header = ((HEADER*) ComputeHeapAddress( Address ) );
			AUTO SBIT32 Count;

			//
			//   Format the contents string into hexadecimal
			//   ready for output.
			//
			for 
					( 
					Count=0;
					((Count < MaxContents) && (Count < Header -> Size));
					Count += sizeof(SBIT32)
					)
				{
				REGISTER CHAR *Value =
					(((CHAR*) Header) + Count + sizeof(HEADER));

				//
				//   Format each byte into hexadecimal.
				//
				sprintf
					(
					& Contents[ (Count * 2) ],
					"%08x",
					(*((SBIT32*) Value))
					);
				}

			//
			//   Terminate the string.  If it was too long 
			//   then add the postfix "..." to the end.
			//
			if ( Count < MaxContents )
				{ Contents[ (Count * 2) ] = '\0'; }
			else
				{
				REGISTER CHAR *End = & Contents[ (Count * 2) ];

				End[0] = '.';
				End[1] = '.';
				End[2] = '.';
				End[3] = '\0';
				}

			//
			//   Format the message to be printed.
			//
			DebugPrint
				(
				"\nDetails of Memory Leak\n"
				"Active      : %d\n"
				"Address     : 0x%x\n"
				"Bytes       : %d\n"
				"Contents    : 0x%s\n",
				Active,
				((SBIT32) ((SNATIVE) Address)),
				Header -> Size,
				Contents
				);

			//
			//   We will generate a call trace if this
			//   is enabled.
			//
			if ( CallStack != NULL )
				{
				//
				//   Even when enabled there is a chance
				//   that the symbol subsystem could
				//   not walk the stack.
				//
				if ( Header -> Count > 0 )
					{
					AUTO CHAR Buffer[ DebugBufferSize ];

					//
					//   We add the call stack information
					//   if there is enough space.
					//
					CallStack -> FormatCallStack
						(
						Buffer,
						Header -> Functions,
						DebugBufferSize,
						Header -> Count
						);

					//
					//   Format the message to be printed.
					//
					DebugPrint
						(
						"Origin      : (See 'Call Stack')\n"
						"\n"
						"Call Stack at Allocation:\n"
						"%s\n",
						Buffer
						);
					}
				else
					{
					//
					//   Explain why there is no 'Call Stack'.
					//
					DebugPrint
						(
						"Origin      : Unknown ('StackWalk' in 'ImageHlp.DLL' "
						"was unable to walk the call stack)\n"
						);
					}
				}
			else
				{ 
				//
				//   Explain why there is no 'Call Stack'.
				//
				DebugPrint( "Origin      : 'Call Stack' is Disabled\n" ); 
				}
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   New guard words.                                               */
    /*                                                                  */
    /*   When we make a memory allocation we verify that the guard      */
    /*   words are still unmodified.  We then setup the debug           */
    /*   information so it describes the allocation.                    */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::NewGuard( void **Address,int Size,int *Space )
	{
	AUTO int ActualSize;
	AUTO SBIT32 MinimumSize =
		(((Size + sizeof(HEADER_AND_TRAILER)) + GuardMask) & ~GuardMask);
	AUTO HEADER *Header = 
		((HEADER*) ROCKALL_FRONT_END::New( MinimumSize,& ActualSize,false ));

	//
	//   We need to be sure that the memory allocation
	//   was sucessful.
	//
	if ( ((void*) Header) != ((void*) AllocationFailure) )
		{
		//
		//   We need to compute the address of the area 
		//   available to the caller and return the space
		//   available if requested.
		//
		(*Address) = ComputeUserAddress( ((void*) Header) );

		if ( Space != NULL )
			{ (*Space) = ComputeUserSpace( ActualSize ); }

		//
		//   We need to make sure that the memory has
		//   not been damaged in any way.
		//
		if ( ! VerifyGuardWords( ((void*) Header),ActualSize ) )
			{
			//
			//   Complain about the damaged guard words
			//   and repair it so processing can continue.
			//
			UserError( (*Address),NULL,"Area damaged since deletion" );

			WriteGuardWords( ((void*) Header),ActualSize );
			}

		//
		//   We now set up the header information that 
		//   describes the memory allocation.
		//
		Header -> Count = 0;
		Header -> Size = ((Space == NULL) ? Size : (*Space));

		//
		//   We will extract the current call stack if 
		//   needed and store it in the memory allocation.
		//
		if ( CallStack != NULL )
			{
			Header -> Count =
				(
				CallStack -> GetCallStack
					( 
					Header -> Functions,
					MaxFunctions,
					SkipFunctions
					)
				);
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the supplied address.                                   */
    /*                                                                  */
    /*   We verify that the supplied address appaers to be a valid      */
    /*   debug memory allocation.  If not we complain and exit.         */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyAddress
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		bool						  Verify
		)
	{
	//
	//   Lets be really paranoid and make sure that
	//   this heap knows about the supplied address.
	//
	if ( ROCKALL_FRONT_END::KnownArea( Address ) )
		{
		REGISTER void *NewAddress = ComputeHeapAddress( Address );

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL_FRONT_END::Verify( ((void*) NewAddress),Space ) )
			{
			//
			//   Lets be even more paranoid and make sure
			//   that the address is correctly aligned
			//   and memory allocation is large enough to
			//   contain the necessary debug information.
			//
			if
					(
					((((SNATIVE) NewAddress) & GuardMask) == 0)
						&&
					((*Space) >= sizeof(HEADER_AND_TRAILER))
						&&
					(((*Space) & GuardMask) == 0)
					)
				{
				//
				//   When we have established that the address
				//   seems to be valid we can return it to
				//   the caller.
				//
				(*Header) = ((HEADER*) NewAddress);

				return true;
				}
			else
				{
				//
				//   When the address is refers to something
				//   that does not appear to be from the debug
				//   heap we complain about it to the user.
				//
				UserError( Address,NULL,"Address unsuitable for debugging" );

				return false; 
				}
			}
		else
			{
			//
			//   When the address is refers to something
			//   that does not appear to be from Rockall
			//   heap we complain about it to the user.
			//
			if ( ! Verify )
				{ UserError( Address,NULL,"Address not allocated" ); }

			return false; 
			}
		}
	else
		{
		//
		//   When the address is clearly bogus we complain
		//   about it to the user.
		//
		if ( ! Verify )
			{ UserError( Address,NULL,"Address falls outside the heap" ); }

		return false;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the guard words.                                        */
    /*                                                                  */
    /*   When we verify a memory allocation we ensure that the          */
    /*   guard words are all undamaged.  If we find a problem we        */
    /*   complain and repair the damage.                                */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyGuard( void *Address,int *Size,int *Space )
	{
	AUTO HEADER *Header;
	AUTO TRAILER *Trailer;

	//
	//   We would like to verify that the allocated
	//   area is still undamaged and extract various
	//   information about it.
	//
	if ( VerifyHeaderAndTrailer( Address,& Header,Space,& Trailer,true ) )
		{
		//
		//   We know that Rockall typically allocates
		//   a few more bytes than requested.  However,
		//   when we are debugging we pretend that this
		//   is not the case and fill the extra space 
		//   with guard words.  However, if we are asked
		//   the actual size then the game it is up and  
		//   we update the necessary fields.
		//
		if ( Space != NULL )
			{
			//
			//   Compute the available user space and
			//   update the internal sizes.
			//
			Header -> Size = ComputeUserSpace( (*Space) );

			(*Space) = Header -> Size;
			}

		//
		//   We need to return what we believe is the the 
		//   size of the user area and the total amount of
		//   user available space.
		//   
		(*Size) = Header -> Size;

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a string of guard words.                                */
    /*                                                                  */
    /*   We need to verify the guard words a various times to ensure    */
    /*   they have not been damaged.                                    */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyGuardWords( void *Address,int Size )
	{
	REGISTER SBIT32 Size1 = ((SBIT32) (((SNATIVE) Address) & GuardMask));
	REGISTER SBIT32 Size2 = ((GuardSize - Size1) & GuardMask);
	REGISTER SBIT32 Size3 = ((Size - Size2) / GuardSize);
    REGISTER SBIT32 Size4 = (Size - Size2 - (Size3 * GuardSize));
	REGISTER SNATIVE *Word = ((SNATIVE*) (((SNATIVE) Address) & ~GuardMask));

	//
	//   Although a guard word area typically starts 
	//   on a word aligned boundary it can sometimes 
	//   start on a byte aligned boundary.
	//   
	if ( Size2 > 0 )
		{
		//hpleung fix
		REGISTER SNATIVE Mask = ~((SNATIVE)((((SNATIVE)1) << (Size1 * 8)) - 1));
        
		//
		//   Examine the partial word and make sure
		//   the guard bytes are unmodified.
		//
		if ( ((*(Word ++)) & Mask) != (GuardValue & Mask) )
			{ return false; }
		}

	//
	//   When there is a collection of aligned guard words
	//   we can quickly verify them.
	//
	if ( Size3 > 0 )
		{
		//
		//   Verify each guard word is unmodified.
		//
		for ( Size3 --;Size3 >= 0;Size3 -- )
			{ 
			if ( Word[ Size3 ] != GuardValue )
				{ return false; }
			}
		}

	//
	//   Although a guard word area typically ends 
	//   on a word aligned boundary it can sometimes 
	//   end on a byte aligned boundary.
	//   
	if ( Size4 > 0 )
		{
		//hpleung fix
		REGISTER SNATIVE Mask = ((((SNATIVE)1) << ((GuardSize - Size4) * 8)) - 1);

		//
		//   Examine the partial word and make sure
		//   the guard bytes are unmodified.
		//
		if ( ((*(Word ++)) & Mask) != (GuardValue & Mask) )
			{ return false; }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the header.                                             */
    /*                                                                  */
    /*   We verify that the suppied address appears to map to a         */
    /*   valid debug header.  If not we complain and exit.              */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyHeader
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		bool						  Verify
		)

	{
	//
	//   We check that the address supplied seems
	//   to make sense before examining the header
	//   and testing the guard words.
	//
	if ( VerifyAddress( Address,Header,Space,Verify ) )
		{
		REGISTER int MaxSpace = 
			((int) ((*Header) -> Size + sizeof(HEADER_AND_TRAILER)));

		//
		//   We are now fairly confident that the
		//   address is (or was at one time) a valid
		//   debug mory allocation.  So lets examine
		//   the header to see if it still seems valid.
		//
		if
				(
				((*Header) -> Count >= 0)
					&&
				((*Header) -> Count <= MaxFunctions)
					&&
				((*Header) -> Size >= 0)
					&&
				(MaxSpace <= (*Space))
				)
			{
			REGISTER int Count = ((*Header) -> Count);
			REGISTER void *GuardWords = & (*Header) -> Functions[ Count ];
			REGISTER int NumberOfGuardWords = (MaxLeadingGuardWords - Count);
			REGISTER int Size = (NumberOfGuardWords * sizeof(GuardWords));

			//
			//   Verify that the leading guard words
			//   just after the header have not been 
			//   damaged.
			//
			if ( ! VerifyGuardWords( GuardWords,Size ) )
				{
				//
				//   We complain about damaged guard
				//   words and then repair them to prevent
				//   further complaints.
				//
				UserError( Address,(*Header),"Leading guard words corrupt" );

				WriteGuardWords( GuardWords,Size );
				}
			}
		else
			{
			//
			//   When the header has been damaged we 
			//   complain about it to the user and then
			//   try to repair it to prevent further
			//   complaints.
			//
			UserError( Address,NULL,"Leading guard information corrupt" );

			WriteGuardWords( ((void*) (*Header)),sizeof(HEADER) );

			//
			//   We select safe default settings.
			//
			(*Header) -> Count = 0;
			(*Header) -> Size = ((*Space) - sizeof(HEADER_AND_TRAILER));
			}

		return true; 
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation.                                    */
    /*                                                                  */
    /*   We need to verify that the supplied address is an undamaged    */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyHeaderAndTrailer
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		TRAILER						  **Trailer,
		bool						  Verify
		)
	{
	//
	//   We need to know the space occupied by the
	//   allocation to compute the details of the
	//   trailer.  So if the space parameter is null 
	//   we use a local temporary value.
	//
	if ( Space != NULL )
		{
		//
		//   We need to verify the entire memory allocation
		//   and ensure it is fit for use.
		//
		return
			(
			VerifyHeader( Address,Header,Space,Verify )
				&&
			VerifyTrailer( (*Header),(*Space),Trailer )
			);
		}
	else
		{
		AUTO int Temporary;

		//
		//   We need to verify the entire memory allocation
		//   and ensure it is fit for use.
		//
		return
			(
			VerifyHeader( Address,Header,& Temporary,Verify )
				&&
			VerifyTrailer( (*Header),Temporary,Trailer )
			);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the trailer.                                            */
    /*                                                                  */
    /*   We need to verify the guard words a various times to ensure    */
    /*   they have not been damaged.                                    */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::VerifyTrailer
		( 
		HEADER						  *Header,
		int							  Space,
		TRAILER						  **Trailer
		)
	{
	REGISTER SBIT32 Size = (Space - (sizeof(HEADER) + Header -> Size ));

	//
	//   Compute the address of the user area and the
	//   the trailing guard words.
	//
	(*Trailer) = 
		((TRAILER*) (((char*) Header) + sizeof(HEADER) + Header -> Size));

	//
	//   Verify that the trailing guard words
	//   just after the user area are not damaged.
	//
	if ( ! VerifyGuardWords( ((void*) (*Trailer)),Size ) )
		{
		REGISTER void *Address = ComputeUserAddress( ((void*) Header) );

		//
		//   We complain about damaged guard words 
		//   and then repair them to prevent further
		//   complaints.
		//
		UserError( Address,Header,"Trailing guard words corrupt" );

		WriteGuardWords( ((void*) (*Trailer)),Size );
		}

	return true; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   When we verify each memory allocation as we walk the heap      */
    /*   and ensure the guard words are all undamaged.  If we find a    */
    /*   problem we complain and repair the damage.                     */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::WalkGuard( bool *Active,void **Address,int *Space )
	{
	//
	//   We may need to convert the supplied user
	//   address into a heap address so we can walk
	//   the heap.
	//
	if ( (*Address) != ((void*) AllocationFailure) )
		{ (*Address) = ComputeHeapAddress( (*Address) ); }

	//
	//   Walk the heap.
	//
	if ( ROCKALL_FRONT_END::Walk( Active,Address,Space ) )
		{
		AUTO int FullSpace = (*Space);
		REGISTER void *FullAddress = (*Address);
		REGISTER void *UserAddress = ComputeUserAddress( (*Address) );

		//
		//   Compute the new heap address and adjust
		//   the reported size.  We do that here because
		//   we might throw an exception during the 
		//   verify and some users need to the user address
		//   so they can keep on walking the heap.
		//
		(*Address) = UserAddress;
		(*Space) = ComputeUserSpace( (*Space) );

		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ 
			AUTO HEADER *Header;
			AUTO TRAILER *Trailer;

			//
			//   Although we are walking the allocations 
			//   there is a chance that it has already
			//   been corrupted.  So we need to verify 
			//   that it is still undamaged.
			//
			VerifyHeaderAndTrailer
				( 
				UserAddress,
				& Header,
				& FullSpace,
				& Trailer,
				false 
				);
			}
		else
			{
			//
			//   We need to make sure that the memory has
			//   not been damaged in any way.
			//
			if ( ! VerifyGuardWords( FullAddress,FullSpace ) )
				{
				//
				//   We need to overwrite the entire alloction
				//   as it has been damaged in some way. 
				//
				UserError( FullAddress,NULL,"Area damaged after deletion" );

				WriteGuardWords( FullAddress,FullSpace );
				}
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Write a string of guard words.                                 */
    /*                                                                  */
    /*   We need write a string of guard words whenever we allocate     */
    /*   memory or detect some corruption.                              */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::WriteGuardWords( void *Address,int Size )
	{
	REGISTER SBIT32 Size1 = ((SBIT32) (((SNATIVE) Address) & GuardMask));
	REGISTER SBIT32 Size2 = ((GuardSize - Size1) & GuardMask);
	REGISTER SBIT32 Size3 = ((Size - Size2) / GuardSize);
	REGISTER SBIT32 Size4 = (Size - Size2 - (Size3 * GuardSize));
	REGISTER SNATIVE *Word = ((SNATIVE*) (((SNATIVE) Address) & ~GuardMask));

	//
	//   Although a guard word area typically starts 
	//   on a word aligned boundary it can sometimes 
	//   start on a byte aligned boundary.
	//   
	if ( Size2 > 0 )
		{
		//hpleung fix
		//In a 64 bit world, both GuardValue and *Word are 64 bit values
		//The checking condition here is as follows
		//      (HEADER)(DATA_NOT_ENDING_IN_POINTER_ALIGNMENT)(TRAILER_NOT_STARTING_IN_POINTER_ALIGNMENT)(REMAINING_TRAILER)
		//The check here is to make sure TRAILER_NOT_STARTING_IN_POINTER_ALIGNMENT still have the guardvalue
		//The mask needs to span the size of TRAILER_NOT_STARTING_IN_POINTER_ALIGNMENT which is up to size of a pointer -1
		//REGISTER SBIT32 Mask = ~((1 << (Size1 * 8)) - 1);
        REGISTER SNATIVE Mask = ~((((SNATIVE)1) << (Size1 * 8)) - 1);

		//
		//   Write the partial guard word but keep any
		//   existing data in related bytes.
		//
		(*(Word ++)) = (((*Word) & ~Mask) | (GuardValue & Mask));
		}

	//
	//   When there is a collection of aligned guard words
	//   we can quickly write them.
	//
	if ( Size3 > 0 )
		{
		//
		//   Write each guard word.
		//
		for ( Size3 --;Size3 >= 0;Size3 -- )
			{ Word[ Size3 ] = ((SNATIVE) GuardValue); }
		}

	//
	//   Although a guard word area typically ends 
	//   on a word aligned boundary it can sometimes 
	//   end on a byte aligned boundary.
	//   
	if ( Size4 > 0 )
		{
		//hpleung fix - logic same as above
		//REGISTER SBIT32 Mask = ((1 << ((GuardSize - Size4) * 8)) - 1);
		REGISTER SNATIVE Mask = ~((((SNATIVE)1) << (Size1 * 8)) - 1);

		//
		//   Write the partial guard word but keep any
		//   existing data in related bytes.
		//
		(*(Word ++)) = (((*Word) & ~Mask) | (GuardValue & Mask));
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Abort on user error.                                           */
    /*                                                                  */
    /*   When we encounter an error we output all of the information    */
    /*   and throw an exception.                                        */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UserError( void *Address,void *Details,char *Message )
	{
	REGISTER HEADER *Header = ((HEADER*) Details);
	STATIC GLOBALLOCK Globallock;

	//
	//   Claim a lock so that multiple threads have
	//   to wait to output any heap statistics.
	//
	Globallock.ClaimLock();

	//
	//   When we have an description of the 
	//   allocation we can complain about it
	//
	if ( Header != NULL )
		{
		AUTO CHAR Contents[ ((MaxContents + 4) * 2) ];
		AUTO SBIT32 Count;

		//
		//   Format the contents string into hexadecimal
		//   ready for output.
		//
		for 
				( 
				Count=0;
				((Count < MaxContents) && (Count < Header -> Size));
				Count += sizeof(SBIT32)
				)
			{
			REGISTER CHAR *Value =
				(((CHAR*) Header) + Count + sizeof(HEADER));

			//
			//   Format each byte into hexadecimal.
			//
			sprintf
				(
				& Contents[ (Count * 2) ],
				"%08x",
				(*((SBIT32*) Value))
				);
			}

		//
		//   Terminate the string.  If it was too long 
		//   then add the postfix "..." to the end.
		//
		if ( Count < MaxContents )
			{ Contents[ (Count * 2) ] = '\0'; }
		else
			{
			REGISTER CHAR *End = & Contents[ (Count * 2) ];

			End[0] = '.';
			End[1] = '.';
			End[2] = '.';
			End[3] = '\0';
			}

		//
		//   Format the message to be printed.
		//
		DebugPrint
			(
			"\nDetails of Heap Corruption\n"
			"Address     : 0x%x\n"
			"Bytes       : %d\n"
			"Contents    : 0x%s\n"
			"Message     : %s\n",
			Address,
			Header -> Size,
			Contents,
			Message
			);

		//
		//   We will generate a call trace if this
		//   is enabled.
		//
		if ( CallStack != NULL )
			{
			//
			//   Even when enabled there is a chance
			//   that the symbol subsystem could
			//   not walk the stack.
			//
			if ( Header -> Count > 0 )
				{
				AUTO CHAR Buffer[ DebugBufferSize ];

				//
				//   We add the call stack information
				//   if there is enough space.
				//
				CallStack -> FormatCallStack
					(
					Buffer,
					Header -> Functions,
					DebugBufferSize,
					Header -> Count
					);

				//
				//   Format the message to be printed.
				//
				DebugPrint
					(
					"Origin      : (See 'Call Stack')\n\n"
					"Call Stack at Allocation:\n"
					"%s\n",
					Buffer
					);
				}
			else
				{
				//
				//   Explain why there is no 'Call Stack'.
				//
				DebugPrint
					(
					"Origin      : Unknown ('StackWalk' in 'ImageHlp.DLL' "
					"was unable to walk the call stack)\n"
					);
				}
			}
		else
			{ 
			//
			//   Explain why there is no 'Call Stack'.
			//
			DebugPrint( "Origin      : 'Call Stack' is Disabled\n" ); 
			}
		}
	else
		{
		//
		//   Format the message to be printed.
		//
		DebugPrint
			(
			"\nDetails of Heap Corruption\n"
			"Address     : 0x%x\n"
			"Bytes       : (unknown)\n"
			"Contents    : (unknown)\n"
			"Message     : %s\n\n",
			Address,
			Message
			);
		}

	//
	//   Relesae the lock.
	//
	Globallock.ReleaseLock();

	//
	//   Terminate the application (if enabled).
	//
	if ( ExitOnError )
		{ Failure( Message ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::~DEBUG_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Output a warning message related to debug heaps
	//   and the inflated size of allocations.
	//
	DebugPrint
		( 
		"\n"
		"REMINDER: The heap at 0x%x is a 'DEBUG_HEAP'.\n"
		"REMINDER: All allocations are inflated by %d bytes.\n"
		"\n", 
		this,
		sizeof(HEADER_AND_TRAILER)
		);

	//
	//   Walk the heap to verify all the allocations
	//   so that we know that the heap is undamaged.
	//
	while ( WalkGuard( & Active,& Address,& Space ) );

	//
	//   Destroy the symbols if they are active.
	//
	if ( CallStack != NULL )
		{ PLACEMENT_DELETE( CallStack,CALL_STACK ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\DynamicDebugHeap.hpp ===
#ifndef _DYNAMIC_DEBUG_HEAP_HPP_
#define _DYNAMIC_DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DebugHeap.hpp"
#include "FastHeap.hpp"
#include "PageHeap.hpp"
#include "SmallHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class LIST;

struct DYNAMIC_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A dynamic debug heap.                                          */
    /*                                                                  */
    /*   A dynamic debug heap switches all allocations between a        */
    /*   standard 'FAST_HEAP', a 'DEBUG_HEAP' and a 'PAGE_HEAP' in      */
    /*   proportion to the supplied ratios.  The dynamic spread means   */
    /*   that the heap is typically quite fast but occasional random    */
    /*   allocations are heavily checked by the debugging features.     */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DYNAMIC_DEBUG_HEAP : public SMALL_HEAP
    {
		//
		//   Private data.
		//
		bool						  Active;

		LIST						  *AllHeaps;
		DYNAMIC_HEAP				  *Array;
		DYNAMIC_HEAP				  *HeapWalk;

		DEBUG_HEAP					  DebugHeap;
		FAST_HEAP					  FastHeap;
		PAGE_HEAP					  PageHeap;

		int							  PercentDebug;
		int							  PercentPage;

   public:
        //
        //   Public functions.
        //
        DYNAMIC_DEBUG_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = false,
			bool					  SingleImage = true,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			int						  PercentToDebug = 20,
			int						  PercentToPage = 5,
			bool					  TrapOnUserError = true
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual void HeapLeaks( void );

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        ~DYNAMIC_DEBUG_HEAP( void );

	protected:
		//
		//   Protected inline functions.
		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

   private:
	    //
	    //   Private functions.
	    //
	    int RandomNumber( void );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DYNAMIC_DEBUG_HEAP( const DYNAMIC_DEBUG_HEAP & Copy );

        void operator=( const DYNAMIC_DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\FastHeap.hpp ===
#ifndef _FAST_HEAP_HPP_
#define _FAST_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A fast heap.                                                   */
    /*                                                                  */
    /*   A fast heap tries to provide very good performance even        */
    /*   if that comes at a significant cost in terms of additional     */
    /*   memory usage.                                                  */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE FAST_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        FAST_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~FAST_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FAST_HEAP( const FAST_HEAP & Copy );

        void operator=( const FAST_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\fastheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "RockallBackEnd.hpp"
#include "FastHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 8192;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,      256,       32,     4096 },
		{        8,      128,       32,     4096 },
		{       12,      128,       64,     4096 },
		{       16,      128,       64,     4096 },
		{       20,       64,       64,     4096 },
		{       24,       64,      128,     4096 },
		{       28,       64,      128,     4096 },

		{       32,       64,      128,     4096 },
		{       40,       64,      128,     4096 },
		{       48,       64,     4096,     4096 },
		{       56,       64,	  4096,     4096 },

		{       64,       64,     4096,     4096 },
		{       80,       64,     4096,     4096 },
		{       96,       64,     4096,     4096 },
		{      112,       64,     4096,     4096 },

		{      128,       32,     4096,     4096 },
		{      160,       16,     4096,     4096 },
		{      192,       16,     4096,     4096 },
		{      224,       16,     4096,     4096 },

		{      256,       16,     4096,     4096 },
		{      320,        8,     4096,     4096 },
		{      384,        8,     4096,     4096 },
		{      448,        8,     4096,     4096 },
		{      512,        4,     4096,     4096 },
		{      576,        4,     8192,     8192 },
		{      640,        4,     4096,     4096 },
		{      704,        4,     4096,     4096 },
		{      768,        4,     4096,     4096 },
		{      832,        4,     8192,     8192 },
		{      896,        4,     8192,     8192 },
		{      960,        4,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        8,     8192,     8192 },
		{     2048,        8,     8192,     8192 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::FAST_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_FRONT_END
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			(ROCKALL_BACK_END::RockallBackEnd()),
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::~FAST_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

TARGETSRCS= $(TARGETPATH)\$(TARGET_DIRECTORY)\xheap.lib \
            $(TARGETPATH)\$(TARGET_DIRECTORY)\heap.lib \
            $(TARGETPATH)\$(TARGET_DIRECTORY)\library.lib
           
TARGETDST=  $(BASEDIR)\private\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)\xheap.lib

xheaplib: $(TARGETDST)

$(TARGETDST) : $(TARGETSRCS)
    lib $(TARGETSRCS)  /out:$(TARGETDST)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\interfacepch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\interfacepch.hpp ===
#ifndef _ROCKALL_PCH_HPP_
#define _ROCKALL_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "RockallBackEnd.hpp"
#include "RockallDebugBackEnd.hpp"
#include "RockallDebugFrontEnd.hpp"
#include "RockallFrontEnd.hpp"

#include "HeapPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\PageHeap.hpp ===
#ifndef _PAGE_HEAP_HPP_
#define _PAGE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MinLeadingGuardWords		  = (MaxFunctions + 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CALL_STACK;

    /********************************************************************/
    /*                                                                  */
    /*   The page heap allocator.                                       */
    /*                                                                  */
    /*   The page heap allocator checks all the memory allocation       */
    /*   references to make sure they are reasonable.  If not then it   */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE PAGE_HEAP : public ROCKALL_DEBUG_FRONT_END
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Count;
			int						  Size;
			void					  *Functions[ MinLeadingGuardWords ];
			}
		HEADER;

		typedef struct
			{
			char					  GuardBytes[ GuardSize ];
			void					  *GuardWords[1];
			}
		TRAILER;

		typedef struct
			{
			HEADER					  DebugHeader;
			TRAILER					  DebugTrailer;
			}
		HEADER_AND_TRAILER;

		//
		//   Private data.
		//
		CALL_STACK					  *CallStack;
		bool						  ExitOnError;
		int							  PageMask;
		int							  PageSize;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        PAGE_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true,
			//
			//   Additional debug flags.
			//
			bool					  FunctionTrace = false,
			bool					  TrapOnUserError = true
			);

		virtual void HeapLeaks( void );

        virtual ~PAGE_HEAP( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   page heap memory allocations.
		//
		virtual void DeleteGuard( void *Address );

		virtual bool NewGuard( void **Address,int Size,int *Space );

		virtual bool VerifyGuard( void *Address,int *Size,int *Space );

		virtual bool WalkGuard( bool *Active,void **Address,int *Space );

		virtual void UserError( void *Address,void *Details,char *Message );

	private:
		//
		//   Private functions.
		//
		//   Support functions to compute various
		//   offsets and sizes within the page heap.
		//   
		int ComputeGuardSpace( int Space );

		void *ComputeHeapAddress( void *Address );
			 
		int ComputeHeapSpace( int Space );

		void *ComputeUserAddress( void *Address,int Size );

		//
		//   Private functions.
		//
		//   Support functions to implement the guard
		//   words for the page heap.
		//   
		bool VerifyAddress
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		bool VerifyHeader
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			bool					  Verify
			);

		bool VerifyHeaderAndTrailer
			(
			void					  *Address,
			HEADER					  **Header,
			int						  *Space,
			TRAILER					  **Trailer,
			bool					  Verify
			);

		bool VerifyTrailer
			( 
			HEADER					  *Header,
			int						  Space,
			TRAILER					  **Trailer
			);

		void WriteGuardWords
			( 
			void					  *Address,
			int						  Size 
			);

		//
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE_HEAP( const PAGE_HEAP & Copy );

        void operator=( const PAGE_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\PageHeap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "CallStack.hpp"
#include "Common.hpp"
#include "Globallock.hpp"
#include "New.hpp"
#include "PageHeap.hpp"
#include "RockallDebugBackEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxContents			  = 32;
CONST SBIT32 DebugBufferSize		  = 256;
CONST SBIT32 SkipFunctions			  = 2;
CONST SBIT32 Stride1				  = 4096;
CONST SBIT32 Stride2				  = 4096;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     4096,       16,    65536,    65536 },
		{     8192,       16,    65536,    65536 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{    12288,       16,    65536,    65536 },
		{    16384,       16,    65536,    65536 },
		{    20480,       16,    65536,    65536 },
		{    32768,       16,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(compiler)
STATIC ROCKALL_DEBUG_BACK_END RockallDebugBackEnd( true,true );

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

PAGE_HEAP::PAGE_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe,
		//
		//   Additional debug flags.
		//
		bool						  FunctionTrace,
		bool						  TrapOnUserError
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_DEBUG_FRONT_END
			(
			Caches1,
			Caches2,
			MaxFreeSpace,
			& RockallDebugBackEnd,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We will only enable the symbols if they are
	//   requested by the user.  If not we will zero
	//   the class pointer.
	//
	if ( FunctionTrace )
		{
		//
		//   We will try to allocate some space so we can
		//   support the annoation of memory allocations
		//   will call traces.
		//
		CallStack = ((CALL_STACK*) SpecialNew( sizeof(CALL_STACK) ));
		
		//
		//   We ensure that we were able to allocate the 
		//   required space.
		//
		if ( CallStack != NULL )
			{ PLACEMENT_NEW( CallStack,CALL_STACK ); }
		}
	else
		{ CallStack = NULL; }

	//
	//   We know that Rockall can survive a wide variety
	//   of user errors.  Nonetheless, we can optionally 
	//   raise an exception whn there is an error.
	//
	ExitOnError = TrapOnUserError;

	//
	//   Compute the page size and page mask for later 
	//   use.
	//
	if ( COMMON::PowerOfTwo( (PageSize = RockallDebugBackEnd.GetPageSize()) ) )
		{ PageMask = (PageSize - 1); }
	else
		{ Failure( "The OS page size is NOT a power of two !" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the guard space.                                       */
    /*                                                                  */
    /*   Compute the gurad space from the supplied size.                */
    /*                                                                  */
    /********************************************************************/

int PAGE_HEAP::ComputeGuardSpace( int Size )
	{ 
	REGISTER int Modulo = (Size % PageSize);

	if ( Modulo <= ((int) (PageSize - sizeof(HEADER))) )
		{ return (PageSize - Modulo); }
	else
		{ return (PageSize + (PageSize - Modulo)); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the heap address.                                      */
    /*                                                                  */
    /*   Compute the heap address from the user address.                */
    /*                                                                  */
    /********************************************************************/

void *PAGE_HEAP::ComputeHeapAddress( void *Address )
	{ return ((void*) ((((SNATIVE) Address) - sizeof(HEADER)) & ~PageMask)); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the heap space.                                        */
    /*                                                                  */
    /*   Compute the heap space from the supplied size.                 */
    /*                                                                  */
    /********************************************************************/

int PAGE_HEAP::ComputeHeapSpace( int Size )
	{ return ((Size + sizeof(HEADER) + (2 * PageSize) - 1) & ~PageMask); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the user address.                                      */
    /*                                                                  */
    /*   Compute the user address from the heap address.                */
    /*                                                                  */
    /********************************************************************/

void *PAGE_HEAP::ComputeUserAddress( void *Address,int Size )
	{ return ((void*) (((char*) Address) + ComputeGuardSpace( Size ))); }

    /********************************************************************/
    /*                                                                  */
    /*   Delete the guard words.                                        */
    /*                                                                  */
    /*   When we delete a memory allocation we overwrite it with        */
    /*   guard words to make it really unpleasant for anyone who        */
    /*   reads it and easy to spot when anyone write to it.             */
    /*                                                                  */
    /********************************************************************/

void PAGE_HEAP::DeleteGuard( void *Address )
	{
	AUTO HEADER *Header;
	AUTO TRAILER *Trailer;
	AUTO int Space;

	//
	//   Although we are about to delete the memory
	//   allocation there is still a chance that it
	//   got corrupted.  So we need to verify that
	//   it is still undamaged.
	//
	if ( VerifyHeaderAndTrailer( Address,& Header,& Space,& Trailer,false ) )
		{
		REGISTER int UnprotectedSize = (Space - PageSize);

		//
		//   We need to overwrite all of the allocation
		//   to ensure that if the code tries to read 
		//   any existing data that it is overwritten.
		//
		WriteGuardWords( ((void*) Header),UnprotectedSize );

		//
		//   We need to protect the deleted area to 
		//   prevent any further access.
		//
		RockallDebugBackEnd.ProtectArea( ((void*) Header),UnprotectedSize );

		//
		//   Delete the allocation.  This really ought 
		//   to work given we have already checked that 
		//   the allocation is valid unless there is a  
		//   race condition.
		//
		if ( ! ROCKALL_FRONT_END::Delete( ((void*) Header),Space ) )
			{ UserError( Address,NULL,"Delete failed due to race" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void PAGE_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( WalkGuard( & Active,& Address,& Space ) )
		{
		AUTO SBIT32 Count;
		AUTO CHAR Contents[ ((MaxContents + 4) * 2) ];

#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO HEADER *Header = ((HEADER*) ComputeHeapAddress( Address ) );
			AUTO SBIT32 HeaderSize = ComputeGuardSpace( Header -> Size );

			//
			//   Format the contents string into hexadecimal
			//   ready for output.
			//
			for 
					( 
					Count=0;
					((Count < MaxContents) && (Count < Header -> Size));
					Count += sizeof(SBIT32)
					)
				{
				REGISTER CHAR *Value =
					(((CHAR*) Header) + HeaderSize + Count);

				//
				//   Format each byte into hexadecimal.
				//
				sprintf
					(
					& Contents[ (Count * 2) ],
					"%08x",
					(*((SBIT32*) Value))
					);
				}

			//
			//   Terminate the string.  If it was too long 
			//   then add the postfix "..." to the end.
			//
			if ( Count < MaxContents )
				{ Contents[ (Count * 2) ] = '\0'; }
			else
				{
				REGISTER CHAR *End = & Contents[ (Count * 2) ];

				End[0] = '.';
				End[1] = '.';
				End[2] = '.';
				End[3] = '\0';
				}

			//
			//   Format the message to be printed.
			//
			DebugPrint
				(
				"\nDetails of Memory Leak\n"
				"Active      : %d\n"
				"Address     : 0x%x\n"
				"Bytes       : %d\n"
				"Contents    : 0x%s\n",
				Active,
				((SBIT32) ((SNATIVE) Address)),
				Header -> Size,
				Contents
				);

			//
			//   We will generate a call trace if this
			//   is enabled.
			//
			if ( CallStack != NULL )
				{
				//
				//   Even when enabled there is a chance
				//   that the symbol subsystem could
				//   not walk the stack.
				//
				if ( Header -> Count > 0 )
					{
					AUTO CHAR Buffer[ DebugBufferSize ];

					//
					//   We add the call stack information
					//   if there is enough space.
					//
					CallStack -> FormatCallStack
						(
						Buffer,
						Header -> Functions,
						DebugBufferSize,
						Header -> Count
						);

					//
					//   Format the message to be printed.
					//
					DebugPrint
						(
						"Origin      : (See 'Call Stack')\n"
						"\n"
						"Call Stack at Allocation:\n"
						"%s\n",
						Buffer
						);
					}
				else
					{
					//
					//   Explain why there is no 'Call Stack'.
					//
					DebugPrint
						(
						"Origin      : Unknown ('StackWalk' in 'ImageHlp.DLL' "
						"was unable to walk the call stack)\n"
						);
					}
				}
			else
				{ 
				//
				//   Explain why there is no 'Call Stack'.
				//
				DebugPrint( "Origin      : 'Call Stack' is Disabled\n" ); 
				}
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   New guard words.                                               */
    /*                                                                  */
    /*   When we make a memory allocation we verify that the guard      */
    /*   words are still unmodified.  We then setup the debug           */
    /*   information so it describes the allocation.                    */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::NewGuard( void **Address,int Size,int *Space )
	{
	AUTO int ActualSize;
	AUTO HEADER *Header =
		(
		(HEADER*) ROCKALL_FRONT_END::New
			( 
			ComputeHeapSpace( Size ),
			& ActualSize,
			false 
			)
		);

	//
	//   We need to be sure that the memory allocation
	//   was sucessful.
	//
	if ( ((void*) Header) != ((void*) AllocationFailure) )
		{
		REGISTER int UnprotectedSize = (ActualSize - PageSize);

		//
		//   We unlock the allocated memory to allow
		//   access to it by the application.
		//
		RockallDebugBackEnd.UnprotectArea( ((void*) Header),UnprotectedSize );

		//
		//   We need to make sure that the memory has
		//   not been damaged in any way.
		//
		if ( ! VerifyGuardWords( ((void*) Header),UnprotectedSize ) )
			{
			//
			//   Complain about the damaged guard words
			//   and repair it so processing can continue.
			//
			UserError( ((void*) Header),NULL,"Area damaged since deletion" );

			WriteGuardWords( ((void*) Header),UnprotectedSize );
			}

		//
		//   We now set up the header information that 
		//   describes the memory allocation.
		//
		Header -> Count = 0;
		Header -> Size = Size;

		//
		//   We will extract the current call stack if 
		//   needed and store it in the memory allocation.
		//
		if ( CallStack != NULL )
			{
			Header -> Count =
				(
				CallStack -> GetCallStack
					( 
					Header -> Functions,
					MaxFunctions,
					SkipFunctions
					)
				);
			}

		//
		//   We need to compute the address of the area 
		//   available to the caller and return the space
		//   available if requested.
		//
		(*Address) = ComputeUserAddress( ((void*) Header),Header -> Size );

		if ( Space != NULL )
			{ (*Space) = Header -> Size; }

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the supplied address.                                   */
    /*                                                                  */
    /*   We verify that the supplied address appaers to be a valid      */
    /*   debug memory allocation.  If not we complain and exit.         */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyAddress
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		bool						  Verify
		)
	{
	//
	//   Lets be really paranoid and make sure that
	//   this heap knows about the supplied address.
	//
	if ( ROCKALL_FRONT_END::KnownArea( Address ) )
		{
		REGISTER void *NewAddress = ComputeHeapAddress( Address );

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL_FRONT_END::Verify( ((void*) NewAddress),Space ) )
			{
			//
			//   Lets be even more paranoid and make sure
			//   that the address is correctly aligned
			//   and memory allocation is large enough to
			//   contain the necessary debug information.
			//
			if
					(
					((((SNATIVE) NewAddress) & PageMask) == 0)
						&&
					((*Space) >= sizeof(HEADER_AND_TRAILER))
						&&
					(((*Space) & PageMask) == 0)
					)
				{
				//
				//   When we have established that the address
				//   seems to be valid we can return it to
				//   the caller.
				//
				(*Header) = ((HEADER*) NewAddress);

				return true;
				}
			else
				{
				//
				//   When the address is refers to something
				//   that does not appear to be from the debug
				//   heap we complain about it to the user.
				//
				UserError( Address,NULL,"Address unsuitable for debugging" );

				return false; 
				}
			}
		else
			{
			//
			//   When the address is refers to something
			//   that does not appear to be from Rockall
			//   heap we complain about it to the user.
			//
			if ( ! Verify )
				{ UserError( Address,NULL,"Address not allocated" ); }

			return false; 
			}
		}
	else
		{
		//
		//   When the address is clearly bogus we complain
		//   about it to the user.
		//
		if ( ! Verify )
			{ UserError( Address,NULL,"Address falls outside the heap" ); }

		return false;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the guard words.                                        */
    /*                                                                  */
    /*   When we verify a memory allocation we ensure that the          */
    /*   guard words are all undamaged.  If we find a problem we        */
    /*   complain and repair the damage.                                */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyGuard( void *Address,int *Size,int *Space )
	{
	AUTO HEADER *Header;
	AUTO TRAILER *Trailer;

	//
	//   We would like to verify that the allocated
	//   area is still undamaged and extract various
	//   information about it.
	//
	if ( VerifyHeaderAndTrailer( Address,& Header,Space,& Trailer,true ) )
		{
		//
		//   We know that Rockall typically allocates
		//   a few more bytes than requested.  However,
		//   when we are debugging we pretend that this
		//   is not the case and fill the extra space 
		//   with guard words.  However, if we are asked
		//   the actual size then the game it is up and  
		//   we update the necessary fields.
		//
		if ( Space != NULL )
			{ (*Space) = Header -> Size; }

		//
		//   We need to return what we believe is the the 
		//   size of the user area and the total amount of
		//   user available space.
		//   
		(*Size) = Header -> Size;

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a string of guard words.                                */
    /*                                                                  */
    /*   We need to verify the guard words a various times to ensure    */
    /*   they have not been damaged.                                    */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyGuardWords( void *Address,int Size )
	{
	REGISTER SBIT32 Size1 = ((SBIT32) (((SNATIVE) Address) & GuardMask));
	REGISTER SBIT32 Size2 = ((GuardSize - Size1) & GuardMask);
	REGISTER SBIT32 Size3 = ((Size - Size2) / GuardSize);
	REGISTER SBIT32 Size4 = (Size - Size2 - (Size3 * GuardSize));
	REGISTER SNATIVE *Word = ((SNATIVE*) (((SNATIVE) Address) & ~GuardMask));

	//
	//   Although a guard word area typically starts 
	//   on a word aligned boundary it can sometimes 
	//   start on a byte aligned boundary.
	//   
	if ( Size2 > 0 )
		{
		REGISTER SBIT32 Mask = ~((1 << (Size1 * 8)) - 1);

		//
		//   Examine the partial word and make sure
		//   the guard bytes are unmodified.
		//
		if ( ((*(Word ++)) & Mask) != (GuardValue & Mask) )
			{ return false; }
		}

	//
	//   When there is a collection of aligned guard words
	//   we can quickly verify them.
	//
	if ( Size3 > 0 )
		{
		//
		//   Verify each guard word is unmodified.
		//
		for ( Size3 --;Size3 >= 0;Size3 -- )
			{ 
			if ( Word[ Size3 ] != GuardValue )
				{ return false; }
			}
		}

	//
	//   Although a guard word area typically ends 
	//   on a word aligned boundary it can sometimes 
	//   end on a byte aligned boundary.
	//   
	if ( Size4 > 0 )
		{
		REGISTER SBIT32 Mask = ((1 << ((GuardSize - Size4) * 8)) - 1);

		//
		//   Examine the partial word and make sure
		//   the guard bytes are unmodified.
		//
		if ( ((*(Word ++)) & Mask) != (GuardValue & Mask) )
			{ return false; }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the header.                                             */
    /*                                                                  */
    /*   We verify that the suppied address appears to map to a         */
    /*   valid debug header.  If not we complain and exit.              */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyHeader
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		bool						  Verify
		)
	{
	//
	//   We check that the address supplied seems
	//   to make sense before examining the header
	//   and testing the guard words.
	//
	if ( VerifyAddress( Address,Header,Space,Verify ) )
		{
		REGISTER int HeaderSize = 
			(ComputeGuardSpace( (*Header) -> Size ));
		REGISTER int MaxSpace = 
			(HeaderSize + (*Header) -> Size + PageSize);

		//
		//   We are now fairly confident that the
		//   address is (or was at one time) a valid
		//   debug mory allocation.  So lets examine
		//   the header to see if it still seems valid.
		//
		if
				(
				((*Header) -> Count >= 0)
					&&
				((*Header) -> Count <= MaxFunctions)
					&&
				((*Header) -> Size >= 0)
					&&
				(MaxSpace <= (*Space))
				)
			{
			REGISTER int Count = ((*Header) -> Count);
			REGISTER void *GuardWords = & (*Header) -> Functions[ Count ];
			REGISTER int NumberOfGuardWords = (MinLeadingGuardWords - Count);
			REGISTER int GuardSize = (NumberOfGuardWords * sizeof(GuardWords));
			REGISTER int Size = (HeaderSize + GuardSize - sizeof(HEADER));

			//
			//   Verify that the leading guard words
			//   just after the header have not been 
			//   damaged.
			//
			if ( ! VerifyGuardWords( GuardWords,Size ) )
				{
				//
				//   We complain about damaged guard
				//   words and then repair them to prevent
				//   further complaints.
				//
				UserError( Address,(*Header),"Leading guard words corrupt" );

				WriteGuardWords( GuardWords,Size );
				}
			}
		else
			{
			//
			//   When the header has been damaged we 
			//   complain about it to the user and then
			//   try to repair it to prevent further
			//   complaints.
			//
			UserError( Address,NULL,"Leading guard information corrupt" );

			WriteGuardWords( ((void*) Header),sizeof(HEADER) );

			//
			//   We select safe default settings.
			//
			(*Header) -> Count = 0;
			(*Header) -> Size = ((*Space) - sizeof(HEADER) - PageSize);
			}

		return true; 
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation.                                    */
    /*                                                                  */
    /*   We need to verify that the supplied address is an undamaged    */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyHeaderAndTrailer
		(
		void						  *Address,
		HEADER						  **Header,
		int							  *Space,
		TRAILER						  **Trailer,
		bool						  Verify
		)
	{
	//
	//   We need to know the space occupied by the
	//   allocation to compute the details of the
	//   trailer.  So if the space parameter is null 
	//   we use a local temporary value.
	//
	if ( Space != NULL )
		{
		//
		//   We need to verify the entire memory allocation
		//   and ensure it is fit for use.
		//
		return
			(
			VerifyHeader( Address,Header,Space,Verify )
				&&
			VerifyTrailer( (*Header),(*Space),Trailer )
			);
		}
	else
		{
		AUTO int Temporary;

		//
		//   We need to verify the entire memory allocation
		//   and ensure it is fit for use.
		//
		return
			(
			VerifyHeader( Address,Header,& Temporary,Verify )
				&&
			VerifyTrailer( (*Header),Temporary,Trailer )
			);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify the trailer.                                            */
    /*                                                                  */
    /*   We need to verify the guard words a various times to ensure    */
    /*   they have not been damaged.                                    */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::VerifyTrailer
		( 
		HEADER						  *Header,
		int							  Space,
		TRAILER						  **Trailer
		)
	{
	//
	//   Compute the address of the user area and the
	//   the trailing guard words.
	//
	(*Trailer) = 
		((TRAILER*) (((char*) Header) + Space - PageSize));

	return true; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   When we verify each memory allocation as we walk the heap      */
    /*   and ensure the guard words are all undamaged.  If we find a    */
    /*   problem we complain and repair the damage.                     */
    /*                                                                  */
    /********************************************************************/

bool PAGE_HEAP::WalkGuard( bool *Active,void **Address,int *Space )
	{
	//
	//   We may need to convert the supplied user
	//   address into a heap address so we can walk
	//   the heap.
	//
	if ( (*Address) != ((void*) AllocationFailure) )
		{ (*Address) = ComputeHeapAddress( (*Address) ); }

	//
	//   Walk the heap.
	//
	if ( ROCKALL_FRONT_END::Walk( Active,Address,Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ 
			AUTO HEADER *Header = ((HEADER*) (*Address));
			AUTO TRAILER *Trailer;

			//
			//   Compute the new heap address and adjust
			//   the reported size.
			//
			(*Address) = ComputeUserAddress( ((void*) Header),Header -> Size );
			(*Space) = Header -> Size;

			//
			//   Although we are about to delete the memory
			//   allocation there is still a chance that it
			//   got corrupted.  So we need to verify that
			//   it is still undamaged.
			//
			VerifyHeaderAndTrailer( (*Address),& Header,NULL,& Trailer,false );
			}
		else
			{
			//
			//   Compute the new heap address and adjust
			//   the reported size.
			//
			(*Address) = ((void*) (((char*) (*Address)) + sizeof(HEADER)));
			(*Space) -= sizeof(HEADER);
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Write a string of guard words.                                 */
    /*                                                                  */
    /*   We need write a string of guard words whenever we allocate     */
    /*   memory or detect some corruption.                              */
    /*                                                                  */
    /********************************************************************/

void PAGE_HEAP::WriteGuardWords( void *Address,int Size )
	{
	REGISTER SBIT32 Size1 = ((SBIT32) (((SNATIVE) Address) & GuardMask));
	REGISTER SBIT32 Size2 = ((GuardSize - Size1) & GuardMask);
	REGISTER SBIT32 Size3 = ((Size - Size2) / GuardSize);
	REGISTER SBIT32 Size4 = (Size - Size2 - (Size3 * GuardSize));
	REGISTER SNATIVE *Word = ((SNATIVE*) (((SNATIVE) Address) & ~GuardMask));

	//
	//   Although a guard word area typically starts 
	//   on a word aligned boundary it can sometimes 
	//   start on a byte aligned boundary.
	//   
	if ( Size2 > 0 )
		{
		REGISTER SBIT32 Mask = ~((1 << (Size1 * 8)) - 1);

		//
		//   Write the partial guard word but keep any
		//   existing data in related bytes.
		//
		(*(Word ++)) = (((*Word) & ~Mask) | (GuardValue & Mask));
		}

	//
	//   When there is a collection of aligned guard words
	//   we can quickly write them.
	//
	if ( Size3 > 0 )
		{
		//
		//   Write each guard word.
		//
		for ( Size3 --;Size3 >= 0;Size3 -- )
			{ Word[ Size3 ] = ((SNATIVE) GuardValue); }
		}

	//
	//   Although a guard word area typically ends 
	//   on a word aligned boundary it can sometimes 
	//   end on a byte aligned boundary.
	//   
	if ( Size4 > 0 )
		{
		REGISTER SBIT32 Mask = ((1 << ((GuardSize - Size4) * 8)) - 1);

		//
		//   Write the partial guard word but keep any
		//   existing data in related bytes.
		//
		(*(Word ++)) = (((*Word) & ~Mask) | (GuardValue & Mask));
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Abort on user error.                                           */
    /*                                                                  */
    /*   When we encounter an error we output all of the information    */
    /*   and throw an exception.                                        */
    /*                                                                  */
    /********************************************************************/

void PAGE_HEAP::UserError( void *Address,void *Details,char *Message )
	{
	REGISTER HEADER *Header = ((HEADER*) Details);
	STATIC GLOBALLOCK Globallock;

	//
	//   Claim a lock so that multiple threads have
	//   to wait to output any heap statistics.
	//
	Globallock.ClaimLock();

	//
	//   When we have an description of the 
	//   allocation we can complain about it
	//
	if ( Header != NULL )
		{
		AUTO SBIT32 Count;
		AUTO CHAR Contents[ ((MaxContents + 4) * 2) ];
		AUTO SBIT32 HeaderSize = ComputeGuardSpace( Header -> Size );

		//
		//   Format the contents string into hexadecimal
		//   ready for output.
		//
		for 
				( 
				Count=0;
				((Count < MaxContents) && (Count < Header -> Size));
				Count += sizeof(SBIT32)
				)
			{
			REGISTER CHAR *Value =
				(((CHAR*) Header) + HeaderSize + Count);

			//
			//   Format each byte into hexadecimal.
			//
			sprintf
				(
				& Contents[ (Count * 2) ],
				"%08x",
				(*((SBIT32*) Value))
				);
			}

		//
		//   Terminate the string.  If it was too long 
		//   then add the postfix "..." to the end.
		//
		if ( Count < MaxContents )
			{ Contents[ (Count * 2) ] = '\0'; }
		else
			{
			REGISTER CHAR *End = & Contents[ (Count * 2) ];

			End[0] = '.';
			End[1] = '.';
			End[2] = '.';
			End[3] = '\0';
			}

		//
		//   Format the message to be printed.
		//
		DebugPrint
			(
			"\nDetails of Heap Corruption\n"
			"Address     : 0x%x\n"
			"Bytes       : %d\n"
			"Contents    : 0x%s\n"
			"Message     : %s\n",
			Address,
			Header -> Size,
			Contents,
			Message
			);

		//
		//   We will generate a call trace if this
		//   is enabled.
		//
		if ( CallStack != NULL )
			{
			//
			//   Even when enabled there is a chance
			//   that the symbol subsystem could
			//   not walk the stack.
			//
			if ( Header -> Count > 0 )
				{
				AUTO CHAR Buffer[ DebugBufferSize ];

				//
				//   We add the call stack information
				//   if there is enough space.
				//
				CallStack -> FormatCallStack
					(
					Buffer,
					Header -> Functions,
					DebugBufferSize,
					Header -> Count
					);

				//
				//   Format the message to be printed.
				//
				DebugPrint
					(
					"Origin      : (See 'Call Stack')\n\n"
					"Call Stack at Allocation:\n"
					"%s\n",
					Buffer
					);
				}
			else
				{
				//
				//   Explain why there is no 'Call Stack'.
				//
				DebugPrint
					(
					"Origin      : Unknown ('StackWalk' in 'ImageHlp.DLL' "
					"was unable to walk the call stack)\n"
					);
				}
			}
		else
			{ 
			//
			//   Explain why there is no 'Call Stack'.
			//
			DebugPrint( "Origin      : 'Call Stack' is Disabled\n" ); 
			}
		}
	else
		{
		//
		//   Format the message to be printed.
		//
		DebugPrint
			(
			"\nDetails of Heap Corruption\n"
			"Address     : 0x%x\n"
			"Bytes       : (unknown)\n"
			"Contents    : (unknown)\n"
			"Message     : %s\n\n",
			Address,
			Message
			);
		}

	//
	//   Terminate the application (if enabled).
	//
	if ( ExitOnError )
		{ Failure( Message ); }

	//
	//   Relesae the lock.
	//
	Globallock.ReleaseLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

PAGE_HEAP::~PAGE_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Output a warning message related to debug heaps
	//   and the inflated size of allocations.
	//
	DebugPrint
		( 
		"\n"
		"REMINDER: The heap at 0x%x is a 'PAGE_HEAP'.\n"
		"REMINDER: All allocations are aligned to page boundaries.\n"
		"\n", 
		this
		);

	//
	//   Walk the heap to verify all the allocations
	//   so that we know that the heap is undamaged.
	//
	while ( WalkGuard( & Active,& Address,& Space ) );

	//
	//   Destroy the symbols if they are active.
	//
	if ( CallStack != NULL )
		{ PLACEMENT_DELETE( CallStack,CALL_STACK ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Version.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\PosixHeap.hpp ===
#ifndef _POSIX_HEAP_HPP_
#define _POSIX_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DefaultHeap.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   The standard posix interface.                                  */
    /*                                                                  */
    /*   The Posix interface allows Rockall to be linked into Unix      */
    /*   applications with a minimal amount of fuss.  Although the      */
    /*   function names are not identical to the posix names (so as     */
    /*   to avoid name clashes) functionally they are close enough      */
    /*    to be simple replacements.                                    */
    /*                                                                  */
    /********************************************************************/

inline void *Calloc( int Size )
	{ return DefaultHeap.New( Size,NULL,true ); }

inline bool Free( void *Address,int Size = NoSize )
	{ return DefaultHeap.Delete( Address,Size ); }

inline void *Malloc( int Size )
	{ return DefaultHeap.New( Size ); }

inline void *Realloc( void *Address,int NewSize )
	{ return DefaultHeap.Resize( Address,NewSize ); }
#ifdef POSIX_EXTENSIONS

    /********************************************************************/
    /*                                                                  */
    /*   Extensions to the posix interface.                             */
    /*                                                                  */
    /*   The Posix interface is fairly restricted and only gives        */
    /*   access to a small portion of Rockall.  The functions that      */
    /*   follow expose additional Rockall functionality.                */
    /*                                                                  */
    /********************************************************************/

inline void DeleteAll( bool Recycle = true )
	{ DefaultHeap.DeleteAll( Recycle ); }

inline bool MultipleFree
		( 
		int				Actual,
		void			*Array[],
		int				Size = NoSize
		)
	{ return DefaultHeap.MultipleDelete( Actual,Array,Size ); }

inline bool MultipleMalloc
		( 
		int				*Actual,
		void			*Array[],
		int				Requested,
		int				Size
		)
	{ return DefaultHeap.MultipleNew( Actual,Array,Requested,Size ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\rockall.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The interface default constructor creates a null heap for      */
    /*   internal use by selected classes.                              */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL( void )
	{
	//
	//   A heap constructed by this constructor should
	//   never be used.  Hence, we zero key pointers to
	//   ensure grave disorder will result if anyone tries.
	//
	Array = NULL;
	Caches = NULL;
	Find = NULL;
	Heap = NULL;
	NewPage = NULL;

	GlobalDelete = True;
	GuardWord = GuardValue;
	NumberOfCaches = 0;
	TotalSize = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe 
		)
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	TRY
#endif
		{
		REGISTER int AlignMask = ((int) (NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Find = NULL;
		Heap = NULL;
		NewPage = NULL;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			((GlobalDelete) ? 0 : sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) NewArea( ((SBIT32) AlignMask),TotalSize,False ));

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the caches.
				//
				//   The first step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((BOOLEAN) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the global find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC ROCKALL Rockall;

						//
						//   Select the global find table 
						//   and call the constructor.
						//
						Find = ((FIND*) GlobalFind);

						PLACEMENT_NEW( Find,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((ROCKALL*) & Rockall),
							((BOOLEAN) True),
							((BOOLEAN) (GlobalDelete || ThreadSafe))
							);
						}
					else
						{
						//
						//   A global find has table already
						//   exists so just use it.
						//
						Find = ((FIND*) GlobalFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}
				else
					{
					Find = (FIND*) NewMemory;
					NewMemory += sizeof(FIND);

					//
					//   We create a local find hash table
					//   if we are do not need to provide
					//   a single heap image.
					//
					PLACEMENT_NEW( Find,FIND ) 
						( 
						((SBIT32) FindSize),
						((SBIT32) FindCacheSize),
						((SBIT32) FindCacheThreshold),
						((ROCKALL*) this),
						((BOOLEAN) True),
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((FIND*) Find),
					((SBIT32*) NewPageSizes),
					((ROCKALL*) this),
					((SBIT32) Size3),
					((BOOLEAN) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((FIND*) Find),
					((NEW_PAGE*) NewPage),
					((ROCKALL*) this),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					ThreadSafe
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   the area back to the operating system.                         */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Details( ((VOID*) Address),((SBIT32*) Space) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   The default is to ask the operating system for the             */
    /*   allocation granularity.                                        */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER LONG Address = ((LONG) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Verify( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Verify( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::~ROCKALL( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the find hash table destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the global find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( Find,FIND ); }

				Spinlock.ReleaseLock();
				}
			else
				{ PLACEMENT_DELETE( Find,FIND ); }


			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Deallocate the heap structures.
			//
			DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			NewPage = NULL;
			Heap = NULL;
			Find = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallDebugBackEnd.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Environment.hpp"
#include "RockallDebugBackEnd.hpp"
#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The may be a situation where the Rockall Back End needs a      */
    /*   constructor but this is certainly not expected to be           */
    /*   very common.                                                   */
    /*                                                                  */
    /********************************************************************/

ROCKALL_DEBUG_BACK_END::ROCKALL_DEBUG_BACK_END
		( 
		bool						  NewFormatting,
		bool						  NewNoAccess 
		)
	{
	STATIC ENVIRONMENT Environment;

	//
	//   Store the flags.
	//
	Formatting = NewFormatting; 
	NoAccess = NewNoAccess; 

	//
	//   Extract the OS page size.
	//
	PageSize = Environment.PageSize();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_DEBUG_BACK_END::NewArea( int AlignMask,int Size,bool User )
    {
	REGISTER void *Memory = (ROCKALL_BACK_END::NewArea( AlignMask,Size,User ));

	//
	//   If we managed to get a new page then write
	//   the guard value over it to allow us to
	//   verify it has not been overwritten later.
	//
	if ( Memory != ((void*) AllocationFailure) )
		{
		//
		//   Write the guard value into all of the new
		//   heap page to allow it to be checked for
		//   corruption.
		//
		if ( Formatting )
			{
			REGISTER int Count;

			for ( Count=((Size / GuardSize) - 1);Count >= 0;Count -- )
				{ (((SNATIVE*) Memory)[ Count ]) = GuardValue; }
			}

		//
		//   When 'NoAccess' is requested we remove 
		//   all access rights to the memory area.  So
		//   we will fault if there is any attempt to
		//   read or write from this memory region.
		//
		if ( (NoAccess) && (User) )
			{ ProtectArea( Memory,Size ); }
		}
	
	return Memory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_DEBUG_BACK_END::ProtectArea( void *Address,int Size )
    {
	//
	//   Lets be sure that the area that is to be protected
	//   is page aligned.
	//
	if ( ((((SNATIVE) Address) & (PageSize-1)) == 0) && ((Size % PageSize) == 0) )
		{
		AUTO DWORD Original;

		//
		//   Nasty: We are about to tell the OS not to write
		//   the allocated page to disk if the space is needed.
		//   This saves lots of space but means the guard bytes
		//   might be lost.  We need to be careful to restore
		//   the guards bytes when we unprotect the page.
		//
		VirtualAlloc( Address,Size,MEM_RESET,PAGE_NOACCESS );

		//
		//   We need to protect the memory area to prevent
		//   any further access.
		//
		VirtualProtect( Address,Size,PAGE_NOACCESS,& Original );

		//
		//   Lets be sure the original protection mode
		//   was what we expected.
		//
		if ( Original != PAGE_READWRITE )
			{ Failure( "Area protection mode unexpected in ProtectArea" ); }
		}
	else
		{ Failure( "Protection area not page aligned in ProtectArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_DEBUG_BACK_END::UnprotectArea( void *Address,int Size )
    {
	//
	//   Lets be sure that the area that is to be
	//   un protected is page aligned.
	//
	if ( ((((SNATIVE) Address) & (PageSize-1)) == 0) && ((Size % PageSize) == 0) )
		{
		AUTO DWORD Original;

		//
		//   We need to unprotect the memory area to 
		//   enable later access.
		//
		VirtualProtect( Address,Size,PAGE_READWRITE,& Original );

		//
		//   Nasty: When we protected the page we also used 'MEM_RESET'.
		//   This is pretty nice in that the OS will not write the page
		//   to disk if the space is required.  As the page only contains
		//   guard bytes this is not a big deal.  However, when the page
		//   is unprotected we need to write the guard bytes again just
		//   in case they were destroyed.
		//
		if ( Formatting )
			{
			REGISTER int Count;

			for ( Count=((Size / GuardSize) - 1);Count >= 0;Count -- )
				{ (((SNATIVE*) Address)[ Count ]) = GuardValue; }
			}

		//
		//   Lets be sure the original protection mode
		//   was what we expected.
		//
		if ( Original != PAGE_NOACCESS )
			{ Failure( "Area protection mode unexpected in UnprotectArea" ); }
		}
	else
		{ Failure( "Protection area not page aligned in UnprotectArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   The may be a situation where the Rockall Back End needs a      */
    /*   destructor but this is certainly not expected to be            */
    /*   very common.                                                   */
    /*                                                                  */
    /********************************************************************/

ROCKALL_DEBUG_BACK_END::~ROCKALL_DEBUG_BACK_END( void )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallBackEnd.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Common.hpp"
#include "RockallBackEnd.hpp"
#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(compiler)
ROCKALL_BACK_END ROCKALL_BACK_END::DefaultBaseClass;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The may be a situation where the Rockall Back End needs a      */
    /*   constructor but this is certainly not expected to be           */
    /*   very common.                                                   */
    /*                                                                  */
    /********************************************************************/

ROCKALL_BACK_END::ROCKALL_BACK_END( void )
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   it back to the operating system.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_BACK_END::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   We really don't have a clue so we ask the operating system     */
    /*   for the size of an allocation granual.                         */
    /*                                                                  */
    /********************************************************************/

int ROCKALL_BACK_END::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_BACK_END::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER SNATIVE Address = ((SNATIVE) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   The may be a situation where the Rockall Back End needs a      */
    /*   destructor but this is certainly not expected to be            */
    /*   very common.                                                   */
    /*                                                                  */
    /********************************************************************/

ROCKALL_BACK_END::~ROCKALL_BACK_END( void )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallDebugBackEnd.hpp ===
#ifndef _ROCKALL_DEBUG_BACK_END_HPP_
#define _ROCKALL_DEBUG_BACK_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallBackEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug heap services.                                       */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DEBUG_BACK_END : public ROCKALL_BACK_END
    {
		//
		//   Private data.
		//
		bool					  Formatting;
		bool					  NoAccess;

		int						  PageSize;

    public:
		//
		//   Low level heap interface.
		//
		//   The following group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
        ROCKALL_DEBUG_BACK_END
			( 
			bool					  NewFormatting = false,
			bool					  NewNoAccess = false 
			);

		virtual void *NewArea( int AlignMask,int Size,bool User );

		void ProtectArea( void *Address,int Size );

		void UnprotectArea( void *Address,int Size );

        virtual ~ROCKALL_DEBUG_BACK_END( void );

		//
		//   Public line functions.
		//
		inline int GetPageSize( void )
			{ return PageSize; }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_DEBUG_BACK_END( const ROCKALL_DEBUG_BACK_END & Copy );

        void operator=( const ROCKALL_DEBUG_BACK_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallDebugFrontEnd.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Heap.hpp"
#include "RockallDebugBackEnd.hpp"
#include "RockallDebugFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

ROCKALL_DEBUG_FRONT_END::ROCKALL_DEBUG_FRONT_END
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  MaxFreeSpace,
		ROCKALL_BACK_END			  *RockallBackEnd,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_FRONT_END
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			((MaxFreeSpace == 0) ? MaxFreeSpace : 0),
			NewPageSizes,
			RockallBackEnd,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We make much use of the guard value in the
	//   debug heap so here we try to claim the 
	//   address but not commit it so we will ensure
	//   an access violation if the program ever
	//   tries to access it.
	//
	VirtualAlloc
		( 
		((void*) GuardValue),
		GuardSize,
		MEM_RESERVE,
		PAGE_NOACCESS 
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We make sure the memory is allocated and that the guard        */
    /*   words have not been damanged.  If so we reset the contents     */
    /*   of the allocation and delete the allocation.                   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::Delete( void *Address,int Size )
    {
	//
	//   A well known practice is to try to delete
	//   a null pointer.  This is really a very poor  
	//   style but we support it in any case.
	//   
	if ( Address != ((void*) AllocationFailure) )
		{
		//
		//   Delete the user information by writing 
		//   guard words over the allocation.  This
		//   should cause the application to crash
		//   if the area is read and also allows us 
		//   to check to see if it is written later.
		//
		DeleteGuard( Address );

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_DEBUG_FRONT_END::DeleteAll( bool Recycle )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap to verify all the allocations
	//   so that we know that the heap is undamaged.
	//
	while ( WalkGuard( & Active,& Address,& Space ) );

	//
	//   Delete the heap and force all the allocated
	//   memory to be returned to the operating system
	//   regardless of what the user requested.  Any
	//   attempt to access the deallocated memory will 
	//   be trapped by the operating system.
	//
	ROCKALL_FRONT_END::DeleteAll( (Recycle && false) );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::Details( void *Address,int *Space )
	{ return Verify( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Exception processing.                                          */
    /*                                                                  */
    /*   Although it is very hard to make Rockall crash it is           */
    /*   technically possible.  When (or should I say if) this          */
    /*   we call the following function (which may be overloadded).     */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_DEBUG_FRONT_END::Exception( char *Message )
	{ 
	DebugPrint
		( 
		"EXCEPTION CAUGHT: %s\n" 
		"ROCKALL TOTAL HEAP FAILURE: You have toasted the heap - Wow !!!!\n",
		Message
		); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   We make sure all the memory is allocated and that the guard    */
    /*   words have not been damaged.  If so we reset the contents      */
    /*   of the allocations and then delete the allocations.            */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER bool Result = true;
	REGISTER SBIT32 Count;

	//
	//   We would realy like to use the multiple
	//   delete functionality of Rockall here but 
	//   it is too much effort.  So we simply call
	//   the standard debug delete on each entry
	//   in the array.  Although this is not as
	//   fast it does give more transparent results.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		//
		//   Delete each memory allocation after
		//   carefully checking it.
		//
		if ( ! Delete( Array[ Count ],Size ) )
			{ Result = false; }
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate a collection of memory elements and setup the         */
    /*   guard information so we can check they have not been           */
    /*   damaged later.                                                 */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   We would realy like to use the multiple
	//   new functionality of Rockall here but 
	//   it is too much effort.  So we simply call
	//   the standard debug new on each entry
	//   in the array.  Although this is not as
	//   fast it does give more transparent results.
	//
	for ( (*Actual)=0;(*Actual) < Requested;(*Actual) ++ )
		{
		REGISTER void *Current = New( Size,Space,Zero );

		//
		//   We add each sucessful memory allocation to
		//   into the array.
		//
		if ( Current != ((void*) AllocationFailure) )
			{ Array[ (*Actual) ] = Current; }
		else
			{ break; }
		}

	return ((*Actual) == Requested);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We add some space on to the original allocation size for       */
    /*   various information and then call the allocator.  We then      */
    /*   set the guard words so we can check for overruns.              */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_DEBUG_FRONT_END::New( int Size,int *Space,bool Zero )
    {
	AUTO void *Address = ((void*) AllocationFailure);

	//
	//   The size must be greater than or equal to zero.  
	//   We do not know how to allocate a negative amount
	//   of memory.
	//
	if ( Size >= 0 )
		{
		//
		//   We need to allocate some space plus an extra
		//   bit for the guard words so we can detect any
		//   corruption later.
		//
		if ( NewGuard( & Address,Size,Space ) ) 
			{
			//
			//   Zero the allocation if requested.  We do
			//   this based on whether we are returning the
			//   space information.  If not we only zero 
			//   size requested.  Otherwise we have to zero 
			//   the entire area.
			//
			if ( Zero )
				{ 
				ZeroMemory
					( 
					Address,
					((Space == NULL) ? Size : (*Space)) 
					); 
				} 
			}
		}
	else
		{ UserError( Address,NULL,"Allocation size can not be negative" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We need to resize an allocation.  We ensure the original       */
    /*   allocation was undamaged and then expand it.  We also          */
    /*   update the guard words to reflect the changes.                 */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_DEBUG_FRONT_END::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	REGISTER void *NewAddress = ((void*) AllocationFailure);

	//
	//   A well known practice is to try to resize a null
	//   pointer.  This is really a very poor style but we 
	//   support it in any case.
	//   
	if ( Address != ((void*) AllocationFailure) )
		{
		//
		//   The new size must be greater than or equal to  
		//   zero.  We do not know how to allocate a negative 
		//   amount of memory.
		//
		if ( NewSize >= 0 )
			{
			AUTO int ActualSize;

			//
			//   Ask for the details of the allocation.  This 
			//   will fail if the memory is not allocated.
			//
			if ( VerifyGuard( Address,& ActualSize,Space ) )
				{
				//
				//   We always move an allocation if we are
				//   allowed to as this has the best chance
				//   of shaking out various types of bugs.
				//
				if ( Move != 0 )
					{
					//
					//   We need to make sure we were able 
					//   to allocate the new memory otherwise 
					//   the copy will fail.
					//
					if ( NewGuard( & NewAddress,NewSize,Space ) )
						{
						REGISTER SBIT32 Smallest = 
							((ActualSize < NewSize) ? ActualSize : NewSize);
						REGISTER SBIT32 Largest = 
							(((Space == NULL)) ? NewSize : (*Space));

						//
						//   Copy the contents of the old allocation 
						//   to the new allocation.
						//
						memcpy
							( 
							((void*) NewAddress),
							((void*) Address),
							((int) Smallest) 
							);

						//
						//   Zero the allocation if requested.  We do
						//   this based on whether we are returning the
						//   space information.  If not we only zero 
						//   size requested.  Otherwise we have to zero 
						//   the entire area.
						//
						if ( Zero )
							{ 
							ZeroMemory
								( 
								(((char*) NewAddress) + Smallest),
								(Largest - Smallest) 
								); 
							} 

						//
						//   Delete the existing memory allocation
						//   and clean up.
						//
						DeleteGuard( Address );
						}
					}
				}
			else
				{ UserError( Address,NULL,"Resize on unallocated address" ); }
			}
		else
			{ UserError( Address,NULL,"Allocation size must be positive" ); }
		}
	else
		{ NewAddress = New( NewSize,Space,Zero ); }

	return NewAddress;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::Verify( void *Address,int *Space )
    {
	AUTO int Size;

	//
	//   Verify that the supplied address is an area
	//   of allocated memory.  If not just exit as this
	//   is only a request for information.
	//
	return VerifyGuard( Address,& Size,Space );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_DEBUG_FRONT_END::Walk( bool *Active,void **Address,int *Space )
	{ 
	//
	//   Walk the heap. 
	//
	return WalkGuard( Active,Address,Space );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

ROCKALL_DEBUG_FRONT_END::~ROCKALL_DEBUG_FRONT_END( void )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallBackEnd.hpp ===
#ifndef _ROCKALL_BACK_END_HPP_
#define _ROCKALL_BACK_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation support services.                        */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_BACK_END
    {
		//
		//   Private static data.
		//
		static ROCKALL_BACK_END		  DefaultBaseClass;

    public:
		//
		//   Low level heap interface.
		//
		//   The following group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		ROCKALL_BACK_END( void );

		virtual void DeleteArea( void *Memory,int Size,bool User );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~ROCKALL_BACK_END( void );

		//
		//   Static public inline functions.
		//
		static ROCKALL_BACK_END *RockallBackEnd( void )
			{ return & DefaultBaseClass; }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_BACK_END( const ROCKALL_BACK_END & Copy );

        void operator=( const ROCKALL_BACK_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallFrontEnd.hpp ===
#ifndef _ROCKALL_FRONT_END_HPP_
#define _ROCKALL_FRONT_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   The hardware word size.                                        */
    /*                                                                  */
    /*   We need to deduce the word size for the current hardware so    */
    /*   we can create suitable constants and interfaces.               */
    /*                                                                  */
    /********************************************************************/

#ifndef _WIN64
typedef __w64 __int32				  SNATIVE;
typedef __w64 unsigned __int32		  UNATIVE;
#else
typedef __int64						  SNATIVE;
typedef unsigned __int64			  UNATIVE;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const SNATIVE AllocationFailure		  = 0;
const SNATIVE GuardMask				  = (sizeof(void*)-1);
const SNATIVE GuardSize				  = sizeof(void*);
const SNATIVE HalfMegabyte			  = (512 * 1024);
const SNATIVE NoSize				  = -1;

#ifndef _WIN64
const SNATIVE GuardValue			  = 0xDeadBeef;
#else
const SNATIVE GuardValue			  = 0xDeadBeefDeadBeef;
#endif


    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;
class ROCKALL_BACK_END;
class THREAD_SAFE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_FRONT_END
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;
		FIND						  *PrivateFind;
		FIND						  *PublicFind;
		ROCKALL_BACK_END			  *RockallBackEnd;
		THREAD_SAFE					  *ThreadSafe;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		SNATIVE						  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        ROCKALL_FRONT_END
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			ROCKALL_BACK_END		  *NewRockallBackEnd,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafeFlag
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space = NULL
			);

        virtual ~ROCKALL_FRONT_END( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   Execptional situations.
		//
		//   The third group of functions are called in
		//   exceptional situations.
		//
		virtual void Exception( char *Message );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as part of heap deletion.
		//
		virtual void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_FRONT_END( const ROCKALL_FRONT_END & Copy );

        void operator=( const ROCKALL_FRONT_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallFrontEnd.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "RockallFrontEnd.hpp"
#include "Spinlock.hpp"
#include "ThreadSafe.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalPublicFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL_FRONT_END::ROCKALL_FRONT_END
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		ROCKALL_BACK_END			  *NewRockallBackEnd,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafeFlag
		)
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	TRY
#endif
		{
		REGISTER int AlignMask = ((int) (NewRockallBackEnd -> NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Heap = NULL;
		NewPage = NULL;
		PrivateFind = NULL;
		PublicFind = NULL;
		RockallBackEnd = NewRockallBackEnd;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(sizeof(THREAD_SAFE))
				+ 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			(sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) RockallBackEnd -> NewArea
					( 
					((SBIT32) AlignMask),
					TotalSize,
					False 
					)
				);

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the thread lock.
				//
				//   The first step in creating a heap is to
				//   create a thread locking class to control 
				//   access to the shared data structures.  
				//
				ThreadSafe = ((THREAD_SAFE*) NewMemory);
				NewMemory += sizeof(THREAD_SAFE);

				//
				//   We create a local find hash table
				//   if we are do not need to provide
				//   a single heap image.
				//
				PLACEMENT_NEW( ThreadSafe,THREAD_SAFE ) 
					( 
					((BOOLEAN) ThreadSafeFlag)
					);

				//
				//   Build the caches.
				//
				//   The next step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((THREAD_SAFE*) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((THREAD_SAFE*) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				PrivateFind = ((FIND*) NewMemory);
				NewMemory += sizeof(FIND);

				//
				//   We create a local find hash table
				//   if we are do not need to provide
				//   a single heap image.
				//
				PLACEMENT_NEW( PrivateFind,FIND ) 
					( 
					((SBIT32) FindSize),
					((SBIT32) FindCacheSize),
					((SBIT32) FindCacheThreshold),
					((BOOLEAN) False),
					((BOOLEAN) True),
					((ROCKALL_BACK_END*) RockallBackEnd),
					((THREAD_SAFE*) ThreadSafe)
					);

				//
				//   When a request is made to have a single heap
				//   image we create a public find table (in
				//   addition to the private one above).  We always 
				//   use the private find table first (to minimize 
				//   sharing and lock contention) but if this fails
				//   to work we try the shared public find table 
				//   that has everything in it.
				//   
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the public find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC THREAD_SAFE StaticThreadSafe = True;

						//
						//   Select the public find table 
						//   and call the constructor.
						//
						PublicFind = ((FIND*) GlobalPublicFind);

						PLACEMENT_NEW( PublicFind,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((BOOLEAN) True),
							((BOOLEAN) True),
							((ROCKALL_BACK_END*) RockallBackEnd),
							((THREAD_SAFE*) & StaticThreadSafe)
							);
						}
					else
						{
						//
						//   A public find table already
						//   exists so just use it.
						//
						PublicFind = ((FIND*) GlobalPublicFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((SBIT32*) NewPageSizes),
					((ROCKALL_BACK_END*) RockallBackEnd),
					((SBIT32) Size3),
					((THREAD_SAFE*) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((NEW_PAGE*) NewPage),
					((FIND*) PrivateFind),
					((FIND*) PublicFind),
					((ROCKALL_BACK_END*) RockallBackEnd),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					((THREAD_SAFE*) ThreadSafe)
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL_FRONT_END" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL_FRONT_END" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
#ifdef FIX_LATER
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL_FRONT_END::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_FRONT_END::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ 
			return 
				(
				Heap -> Details
					( 
					((VOID*) Address),
					((SEARCH_PAGE*) NULL),
					((SBIT32*) Space) 
					)
				); 
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Exception processing.                                          */
    /*                                                                  */
    /*   Although it is very hard to make Rockall crash it is           */
    /*   technically possible.  When (or should I say if) this          */
    /*   we call the following function (which may be overloadded).     */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_FRONT_END::Exception( char *Message )
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_FRONT_END::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_FRONT_END::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_FRONT_END::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL_FRONT_END::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL_FRONT_END::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::Verify( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Verify( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL_FRONT_END::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL_FRONT_END::~ROCKALL_FRONT_END( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the public find hash table 
			//   destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the public find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( PublicFind,FIND ); }

				Spinlock.ReleaseLock();
				}

			//
			//   Execute the private find hash table 
			//   destructor.
			//
			PLACEMENT_DELETE( PrivateFind,FIND );

			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Execute the thread locking class 
			//   destructor.
			//
			PLACEMENT_DELETE( ThreadSafe,THREAD_SAFE );

			//
			//   Deallocate the heap structures.
			//
			RockallBackEnd -> DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			ThreadSafe = NULL;
			RockallBackEnd = NULL;
			PublicFind = NULL;
			PrivateFind = NULL;
			NewPage = NULL;
			Heap = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, report 
		//   the fault and exit.
		//
		GuardWord = AllocationFailure;

		Exception( ((char*) Message) );
		}
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;

		Exception( "(unknown exception type)" );
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\smallheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "RockallBackEnd.hpp"
#include "SmallHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,      512 },
		{        8,        0,       32,      512 },
		{       12,        0,       64,      512 },
		{       16,        0,       64,      512 },
		{       20,        0,       64,      512 },
		{       24,        0,      128,      512 },
		{       28,        0,      128,      512 },

		{       32,        0,      128,      512 },
		{       40,        0,      128,      512 },
		{       48,        0,	   512,      512 },
		{       56,        0,	   512,      512 },

		{       64,        0,     1024,     1024 },
		{       80,        0,     1024,     1024 },
		{       96,        0,     1024,     1024 },
		{      112,        0,     1024,     1024 },

		{      128,        0,     2048,     2048 },
		{      160,        0,     2048,     2048 },
		{      192,        0,     2048,     2048 },
		{      224,        0,     2048,     2048 },

		{      256,        0,     4096,     4096 },
		{      320,        0,     4096,     4096 },
		{      384,        0,     4096,     4096 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     4096,     4096 },
		{      576,        0,     8192,     8192 },
		{      640,        0,     4096,     4096 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     8192,     8192 },
		{     2048,        0,     8192,     8192 },
		{     3072,        0,     8192,     8192 },
		{     4096,        0,    65536,    65536 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::SMALL_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_FRONT_END
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			(ROCKALL_BACK_END::RockallBackEnd()),
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::~SMALL_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\RockallDebugFrontEnd.hpp ===
#ifndef _ROCKALL_DEBUG_FRONT_END_HPP_
#define _ROCKALL_DEBUG_FRONT_END_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the initial size of various tables.      */
    /*                                                                  */
    /********************************************************************/

const int MaxFunctions				  = 5;

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL_DEBUG_FRONT_END : public ROCKALL_FRONT_END
    {
    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        ROCKALL_DEBUG_FRONT_END
			( 
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  MaxFreeSpace,
			ROCKALL_BACK_END		  *RockallBackEnd,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        virtual ~ROCKALL_DEBUG_FRONT_END( void );

	protected:
		//
		//   Guard word functions.
		//
		//   The guard word functions create, maintain,
		//   verify and delete guard words around
		//   debug memory allocations.
		//
		virtual void DeleteGuard( void *Address ) = 0;

		virtual bool NewGuard( void **Address,int Size,int *Space ) = 0;

		virtual bool VerifyGuard( void *Address,int *Size,int *Space ) = 0;

		virtual bool WalkGuard( bool *Active,void **Address,int *Space ) = 0;

		virtual void UserError( void *Address,void *Header,char *Message ) = 0;

	private:
		//
		//   Execptional situations.
		//
		//   The third group of functions are called in
		//   exceptional situations.
		//
		virtual void Exception( char *Message );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL_DEBUG_FRONT_END( const ROCKALL_DEBUG_FRONT_END & Copy );

        void operator=( const ROCKALL_DEBUG_FRONT_END & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\smpheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Dll.hpp"
#include "List.hpp"
#include "New.hpp"
#include "Sharelock.hpp"
#include "SmpHeap.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Structures local to the class.                                 */
    /*                                                                  */
    /*   The structures supplied here describe the layout of the        */
    /*   private per thread heap structures.                            */
    /*                                                                  */
    /********************************************************************/

typedef struct PRIVATE_HEAP : public LIST
	{
	SMP_HEAP_TYPE					  Heap;
	}
PRIVATE_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC SHARELOCK Sharelock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::SMP_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe,
		bool						  DeleteHeapOnExit
		) :
		//
		//   Call the constructors for the contained classes.
		//
		MaxFreeSpace(MaxFreeSpace),
		Recycle(Recycle),
		SingleImage(True),
		ThreadSafe(ThreadSafe),
		SMP_HEAP_TYPE( 0,false,true,true )
	{
	//
	//   Setup various control variables.
	//
	Active = false;
	DeleteOnExit = DeleteHeapOnExit;

	//
	//   Create the linked list headers and a thread 
	//   local store variable to point at each threads
	//   private heap.
	//
	ActiveHeaps = ((LIST*) SMP_HEAP_TYPE::New( sizeof(LIST) ));
	DllEvents = ((DLL*) SMP_HEAP_TYPE::New( sizeof(DLL) ));
	FreeHeaps = ((LIST*) SMP_HEAP_TYPE::New( sizeof(LIST) ));
	HeapWalk = NULL;
	Tls = ((TLS*) SMP_HEAP_TYPE::New( sizeof(TLS) ));

	//
	//   We can only activate the the heap if we manage
	//   to allocate space we requested.
	//
	if 
			( 
			(ActiveHeaps != NULL) 
				&& 
			(DllEvents != NULL) 
				&& 
			(FreeHeaps != NULL) 
				&& 
			(Tls != NULL) 
			)
		{
		//
		//   Execute the constructors for each linked list
		//   and for the thread local store.
		//
		PLACEMENT_NEW( ActiveHeaps,LIST );
#ifdef COMPILING_ROCKALL_DLL
		PLACEMENT_NEW( DllEvents,DLL )( ThreadDetach,this );
#endif
		PLACEMENT_NEW( FreeHeaps,LIST );
		PLACEMENT_NEW( Tls,TLS );

		//
		//   Activate the heap.
		//
		ActiveLocks = 0;

		Active = true;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   When we delete an allocation we try to delete it in the        */
    /*   private per thread heap if it exists.                          */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Delete( void *Address,int Size )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = 
			((PRIVATE_HEAP*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a heap for the current thread.  
		//   If not we just use the internal heap.
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.Delete( Address,Size )); }
		else
			{ return (SMP_HEAP_TYPE::Delete( Address,Size )); }
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We walk the list of all the heaps and instruct each heap       */
    /*   to delete everything.                                          */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::DeleteAll( bool Recycle )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as everything gets
		//   blown away.
		//
		for 
				( 
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First());
				(Current != NULL);
				Current = ((PRIVATE_HEAP*) Current -> Next())
				)
			{ Current -> Heap.DeleteAll( Recycle ); }

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();

		//
		//   Claim a process wide exclusive lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimExclusiveLock();

		//
		//   We walk the free list of heaps and
		//   delete everything.
		//
		for 
				(
				Current = ((PRIVATE_HEAP*) FreeHeaps -> First());
				Current != NULL;
				Current = ((PRIVATE_HEAP*) FreeHeaps -> First())
				)

			{
			//
			//   Delete each heap from the free list,
			//   call the destructor and delete any
			//   associated space.
			//   
			Current -> Delete( FreeHeaps );	

			PLACEMENT_DELETE( Current,PRIVATE_HEAP );

			SMP_HEAP_TYPE::Delete( Current );
			}

		//
		//   Release the lock.
		//
		Sharelock.ReleaseExclusiveLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   When we are asked for details we try to the private per        */
    /*   thread heap if it exists.                                      */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Details( void *Address,int *Space )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = 
			((PRIVATE_HEAP*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a heap for the current thread.  
		//   If not we just use the internal heap.
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.Details( Address,Space )); }
		else
			{ return (SMP_HEAP_TYPE::Details( Address,Space )); }
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Extract the private heap.                                      */
    /*                                                                  */
    /*   We need to provide all threads with a private heap.  When      */
    /*   we discover we need another heap we either recycle an          */
    /*   existing heap or create a new one.                             */
    /*                                                                  */
    /********************************************************************/

PRIVATE_HEAP *SMP_HEAP::GetPrivateHeap( void )
    {
	REGISTER PRIVATE_HEAP *PrivateHeap = ((PRIVATE_HEAP*) Tls -> GetPointer());

	//
	//   We need to examine the TLS pointer to make 
	//   sure we have a heap for the current thread.  
	//   If not we just create a new heap.
	//
	if ( PrivateHeap == NULL )
		{
		//
		//   Claim a process wide exclusive lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimExclusiveLock();

		//
		//   When there is an available free heap
		//   then extract it from the free list.
		//
		if ( (PrivateHeap = ((PRIVATE_HEAP*) FreeHeaps -> First())) != NULL )
			{
			//
			//   Delete the heap from the list of
			//   of free heaps.
			//
			PrivateHeap -> Delete( FreeHeaps );
			}

		//
		//   When there is no available free heap then
		//   we try to make a new heap.
		//
		if ( PrivateHeap == NULL )
			{
			//
			//   Release the lock.
			//
			Sharelock.ReleaseExclusiveLock();

			//
			//   Allocate space for the new private per 
			//   thread heap.
			//
			PrivateHeap = 
				((PRIVATE_HEAP*) SMP_HEAP_TYPE::New( sizeof(PRIVATE_HEAP) ));

			//
			//   We need to ensure that the allocation
			//   worked before we try to add it into
			//   the list of active heaps.
			//
			if ( PrivateHeap != NULL )
				{ 
				//
				//   Activate the new heap.
				//
				PLACEMENT_NEW( PrivateHeap,LIST );

				PLACEMENT_NEW( & PrivateHeap -> Heap,SMP_HEAP_TYPE )
					( 
					MaxFreeSpace,
					Recycle,
					SingleImage,
					ThreadSafe 
					);
				}

			//
			//   Claim a process wide exclusive lock
			//   to ensure the list of heaps does
			//   not change until we have finished.
			//
			Sharelock.ClaimExclusiveLock();
			}

		//
		//   We would expect to have a new heap by this
		//   point.  If not then we just exit.
		//
		if ( PrivateHeap != NULL )
			{
			//
			//   Insert the new heap in the list
			//   of active heaps.
			//
			PrivateHeap -> Insert( ActiveHeaps );

			//
			//   Nasty: we may have an outstanding lock
			//   on the rest of the heaps.  If so claim
			//   it for this heap as well.
			//
			if ( ActiveLocks > 0 )
				{ PrivateHeap -> Heap.LockAll(); }

			//
			//   Update the TLS pointer.
			//
			Tls -> SetPointer( ((VOID*) PrivateHeap) ); 
			}

		//
		//   Release the lock.
		//
		Sharelock.ReleaseExclusiveLock();
		}

	return PrivateHeap;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   When we are asked about an address we try to the private per   */
    /*   thread heap if it exists.                                      */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::KnownArea( void *Address )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = 
			((PRIVATE_HEAP*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a heap for the current thread.  
		//   If not we just use the internal heap.
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.KnownArea( Address )); }
		else
			{ return (SMP_HEAP_TYPE::KnownArea( Address )); }
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   We claim all of the heap locks so that it is safe to do        */
    /*   operations like walking all of the heaps.                      */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::LockAll( VOID )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   Nasty: We may actually create or delete
		//   a heap between locking all the heaps and
		//   unlocking them.  Thus, we need to keep a
		//   count of the outstanding locks to keep 
		//   this all consistent.
		//
		ASSEMBLY::AtomicIncrement( ((SBIT32*) & ActiveLocks) );

		//
		//   You just have to hope the user knows
		//   what they are doing as we claim all
		//   of the heap locks.
		//
		for 
				( 
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First());
				(Current != NULL);
				Current = ((PRIVATE_HEAP*) Current -> Next())
				)
			{ Current -> Heap.LockAll(); }

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When we delete multiple allocations we try to delete them on   */
    /*   the private per thread heap if it exists.                      */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = 
			((PRIVATE_HEAP*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a heap for the current thread.  
		//   If not we just use the internal heap.
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.MultipleDelete(Actual,Array,Size)); }
		else
			{ return (SMP_HEAP_TYPE::MultipleDelete( Actual,Array,Size )); }
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We allocate space for the current thread from the local        */
    /*   private per thread heap.  If we do not have a local private    */
    /*   per thread heap then we create one and use it.                 */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = GetPrivateHeap();

		//
		//   We need to examine private heap to make 
		//   sure we have a heap for the current thread.  
		//
		if ( PrivateHeap != NULL )
			{
			//
			//   Allocate the memory requested on the local
			//   private per thread heap.
			//
			return 
				(
				PrivateHeap -> Heap.MultipleNew
					( 
					Actual,
					Array,
					Requested,
					Size,
					Space,
					Zero
					)
				);
			}
		else
			{
			//
			//   We were unable to create a new heap
			//   so exit.
			//
			(*Actual) = 0;

			return false;
			}
		}
	else
		{
		//
		//   We are not active yet so exit.
		//
		(*Actual) = 0;

		return false;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate space for the current thread from the local        */
    /*   private per thread heap.  If we do not have a local private    */
    /*   per thread heap then we create one and use it.                 */
    /*                                                                  */
    /********************************************************************/

void *SMP_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = GetPrivateHeap();

		//
		//   We need to examine private heap to make 
		//   sure we have a heap for the current thread.  
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.New( Size,Space,Zero )); }
		else
			{ return NULL; }
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We reallocate space for the current thread on the local        */
    /*   private per thread heap.  If we do not have a local private    */
    /*   per thread heap then we create one and use it.                 */
    /*                                                                  */
    /********************************************************************/

void *SMP_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = GetPrivateHeap();

		//
		//   We need to examine private heap to make 
		//   sure we have a heap for the current thread.  
		//
		if ( PrivateHeap != NULL )
			{
			//
			//   Reallocate the memory requested on 
			//   the local private per thread heap.
			//
			return 
				(
				PrivateHeap -> Heap.Resize
					( 
					Address,
					NewSize,
					Move,
					Space,
					NoDelete,
					Zero
					)
				);
			}
		else
			{ return NULL; }
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *SMP_HEAP::SpecialNew( int Size )
	{ return SMP_HEAP_TYPE::New( Size ); }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a local heap.                                           */
    /*                                                                  */
    /*   Delete a local per thread heap and return all the outstanding  */
    /*   memory to the operating system.                                */
    /*                                                                  */
    /********************************************************************/
 
void SMP_HEAP::ThreadDetach( void *Parameter,int Reason )
	{

	//
	//  We only take any action on a thread detach
	//  notification.  All other notifications are
	//  not actioned.
	//
	if ( Reason == DLL_THREAD_DETACH )
		{
		REGISTER SMP_HEAP *SmpHeap = ((SMP_HEAP*) Parameter);

		//
		//   Claim a process wide exclusive lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimExclusiveLock();

		//
		//   There is a nasty situation where the
		//   destructor is called before a thread
		//   fully terminates so ensure the heap
		//   is still active.
		//
		if ( SmpHeap -> Active )
			{
			REGISTER PRIVATE_HEAP *PrivateHeap = 
				((PRIVATE_HEAP*) SmpHeap -> Tls -> GetPointer());

			//
			//   We need to examine the TLS pointer to make 
			//   sure we have a heap for the current thread.  
			//   If not we just use the internal heap.
			//
			if ( PrivateHeap != NULL )
				{
				//
				//   Update the TLS pointer.
				//
				SmpHeap -> Tls -> SetPointer( NULL ); 

				//
				//   Insert the new heap in the list
				//   of active heaps.
				//
				PrivateHeap -> Delete( SmpHeap -> ActiveHeaps );

				//
				//   When we are not allowed to delete 
				//   the heap we put it on the free list.
				//
				if ( ! SmpHeap -> DeleteOnExit )
					{ PrivateHeap -> Insert( SmpHeap -> FreeHeaps ); }

				//
				//   Nasty: we may have an outstanding lock
				//   on this heap.  If so then free it.
				//
				if ( SmpHeap -> ActiveLocks > 0 )
					{ PrivateHeap -> Heap.UnlockAll(); }

				//
				//   Release the lock.
				//
				Sharelock.ReleaseExclusiveLock();

				//
				//   When we are allowed to delete the
				//   heap we do it here.
				//
				if ( ! SmpHeap -> DeleteOnExit )
					{
					//
					//   Truncate the heap to remove any 
					//   unwanted space.
					//
					PrivateHeap -> Heap.Truncate( 0 );
					}
				else
					{
#ifdef COMPLAIN_ABOUT_SMP_HEAP_LEAKS
					//
					//   We have finished with the private
					//   heap so now is a good time to complain
					//   about leaks.
					//
					PrivateHeap -> Heap.HeapLeaks();

#endif
					//
					//   We have finished with the private
					//   heap so delete it.
					//
					PLACEMENT_DELETE( PrivateHeap,PRIVATE_HEAP );

					SmpHeap -> SMP_HEAP_TYPE::Delete( PrivateHeap );
					}
				}
			else
				{ Sharelock.ReleaseExclusiveLock(); }
			}
		else
			{ Sharelock.ReleaseExclusiveLock(); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Truncate( int MaxFreeSpace )
    {
	REGISTER bool Result = true;

	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as we are truncating
		//   all of the heaps.
		//
		for 
				( 
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First());
				(Current != NULL);
				Current = ((PRIVATE_HEAP*) Current -> Next())
				)
			{
			//
			//   If faulty delete is noted during the
			//   cache flushes then exit with the
			//   correct status.
			//
			if ( ! Current -> Heap.Truncate( MaxFreeSpace ) )
				{ Result = false; }
			}

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We unlock all of the heap locks so normal processing can       */
    /*   continue on the heaps.                                         */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::UnlockAll( VOID )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *Current;

		//
		//   Claim a process wide shared lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimShareLock();

		//
		//   You just have to hope the user knows
		//   what they are doing as we claim all
		//   of the heap locks.
		//
		for 
				( 
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First());
				(Current != NULL);
				Current = ((PRIVATE_HEAP*) Current -> Next())
				)
			{ Current -> Heap.UnlockAll(); }

		//
		//   Nasty: We may actually create or delete
		//   a private heap  for a thread between 
		//   locking an 'SMP_HEAP' and unlocking it.
		//   Thus, we need to keep a count of the
		//   outstanding locks to keep this all
		//   consistent.
		//
		ASSEMBLY::AtomicDecrement( ((SBIT32*) & ActiveLocks) );

		//
		//   Release the lock.
		//
		Sharelock.ReleaseShareLock();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   When we verify an allocation we try to verify it in the        */
    /*   private per thread heap if it exists.                          */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Verify( void *Address,int *Space )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *PrivateHeap = 
			((PRIVATE_HEAP*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a heap for the current thread.  
		//   If not we just use the internal heap.
		//
		if ( PrivateHeap != NULL )
			{ return (PrivateHeap -> Heap.Verify( Address,Space )); }
		else
			{ return (SMP_HEAP_TYPE::Verify( Address,Space )); }
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Walk( bool *Activity,void **Address,int *Space )
    {
	//
	//   Claim a process wide shared lock
	//   to ensure the list of heaps does
	//   not change until we have finished.
	//
	Sharelock.ClaimShareLock();

	//
	//   Nasty, in 'SMP_HEAP' we have multiple heaps
	//   to walk so if we don't have a current heap
	//   then just select the first available.
	//
	if ( ((*Address) == NULL) || (HeapWalk == NULL) )
		{ HeapWalk = ((PRIVATE_HEAP*) ActiveHeaps -> First()); }

	//
	//   Walk the heap.  When we come to the end of
	//   the current heap then move on to the next
	//   heap.
	//
	while 
			( 
			(HeapWalk != NULL)
				&& 
			(! HeapWalk -> Heap.Walk( Activity,Address,Space ))
			)
		{ HeapWalk = ((PRIVATE_HEAP*) HeapWalk -> Next()); }

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();

	return (HeapWalk != NULL);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::~SMP_HEAP( void )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER PRIVATE_HEAP *Current;

		//
		//   Deactivate the heap.
		//
		Active = false;

		//
		//   Claim a process wide exclusive lock
		//   to ensure the list of heaps does
		//   not change until we have finished.
		//
		Sharelock.ClaimExclusiveLock();

		//
		//   We walk the active list of heaps and
		//   delete everything.
		//
		for 
				(
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First());
				Current != NULL;
				Current = ((PRIVATE_HEAP*) ActiveHeaps -> First())
				)
			{
			//
			//   Delete each heap from the active list,
			//   call the destructor and delete any
			//   associated space.
			//   
			Current -> Delete( ActiveHeaps );	
#ifdef COMPLAIN_ABOUT_SMP_HEAP_LEAKS

			//
			//   We have finished with the private
			//   heap so now is a good time to complain
			//   about leaks.
			//
			Current -> Heap.HeapLeaks();
#endif

			//
			//   We have finished with the private
			//   heap so delete it.
			//
			PLACEMENT_DELETE( Current,PRIVATE_HEAP );

			SMP_HEAP_TYPE::Delete( Current );
			}

		//
		//   We walk the free list of heaps and
		//   delete everything.
		//
		for 
				(
				Current = ((PRIVATE_HEAP*) FreeHeaps -> First());
				Current != NULL;
				Current = ((PRIVATE_HEAP*) FreeHeaps -> First())
				)

			{
			//
			//   Delete each heap from the active list,
			//   call the destructor and delete any
			//   associated space.
			//   
			Current -> Delete( FreeHeaps );	
#ifdef COMPLAIN_ABOUT_SMP_HEAP_LEAKS

			//
			//   We have finished with the private
			//   heap so now is a good time to complain
			//   about leaks.
			//
			Current -> Heap.HeapLeaks();
#endif

			//
			//   We have finished with the private
			//   heap so delete it.
			//
			PLACEMENT_DELETE( Current,PRIVATE_HEAP );

			SMP_HEAP_TYPE::Delete( Current );
			}

		//
		//   Release the lock.
		//
		Sharelock.ReleaseExclusiveLock();

		//
		//   Call the list and TLS destructors.
		//
		PLACEMENT_DELETE( Tls,TLS );
		PLACEMENT_DELETE( FreeHeaps,LIST );
#ifdef COMPILING_ROCKALL_DLL
		PLACEMENT_DELETE( DllEvents,DLL );
#endif
		PLACEMENT_DELETE( ActiveHeaps,LIST );

		//
		//   Delete the space.
		//
		SMP_HEAP_TYPE::Delete( Tls );
		SMP_HEAP_TYPE::Delete( FreeHeaps );
		SMP_HEAP_TYPE::Delete( DllEvents );
		SMP_HEAP_TYPE::Delete( ActiveHeaps );

		//
		//   Zero the pointers just to be tidy.
		//
		Tls = NULL;
		HeapWalk = NULL;
		FreeHeaps = NULL;
		DllEvents = NULL;
		ActiveHeaps = NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\SingleSizeHeap.hpp ===
#ifndef _SINGLE_SIZE_HEAP_HPP_
#define _SINGLE_SIZE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/
 
#include "DefaultHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specify the size of local cache.                 */
    /*                                                                  */
    /********************************************************************/

const int MaxStackSize				  = 64;

    /********************************************************************/
    /*                                                                  */
    /*   A single size heap.                                            */
    /*                                                                  */
    /*   The vision for this class is to provide an extremely fast      */
    /*   simple single sized memory allocation class.  There are        */
    /*   claerly a large number of enhancemnts that could be made       */
    /*   such as locking, deleting all allocations in the destructor    */
    /*   and many others.  Nonetheless, such enhancements are not       */
    /*   covered as specific applications have differing requirements.  */
    /*   This class simply demonstrates how easy it is to build custom  */
    /*   functionality with Rockall.                                    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE = MaxStackSize> class SINGLE_SIZE_HEAP
    {
        //
        //   Private data.
        //
		int							  FillSize;
		int							  TopOfStack;

		ROCKALL_FRONT_END			  *Heap;
		TYPE						  *Stack[ STACK_SIZE ];

    public:
        //
        //   Public functions.
        //
        SINGLE_SIZE_HEAP( ROCKALL_FRONT_END *NewHeap = & DefaultHeap );

        TYPE *New( void );

        void Delete( TYPE *Type );

        ~SINGLE_SIZE_HEAP( void );

	private:
        //
        //   Disabled operations.
        //
        SINGLE_SIZE_HEAP( const SINGLE_SIZE_HEAP & Copy );

        void operator=( const SINGLE_SIZE_HEAP & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::SINGLE_SIZE_HEAP
		( 
		ROCKALL_FRONT_END			  *NewHeap
		)
    {
	//
	//   Zero the top of stack and setup 
	//   the heap.
	//
	FillSize = (STACK_SIZE / 2);
    TopOfStack = 0;

	Heap = NewHeap;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Single size allocation.                                        */
    /*                                                                  */
    /*   We will allocate a variable and call the constructor.          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> TYPE *SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::New( void )
    {
	//
	//   When we run out of allocations we fill the
	//   stack with a single call to Rockall.
	//
	if ( TopOfStack <= 0 )
		{
		Heap -> MultipleNew
			( 
			& TopOfStack,
			((void**) Stack),
			FillSize,
			sizeof(TYPE)
			);
		}

	//
	//   We will supply an allocation if one is available.
	//
	if ( TopOfStack > 0 )
		{
		TYPE *Type = Stack[ (-- TopOfStack) ];

		PLACEMENT_NEW( Type,TYPE );

		return Type; 
		}
	else
		{ return NULL; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Single size dellocation.                                       */
    /*                                                                  */
    /*   We will deallocate a variable and call the destructor.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> void SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::Delete
		( 
		TYPE						  *Type
		)
	{
	//
	//   When the supplied allocation is null we know
	//   we can skip the deallocation.
	//
	if ( Type != NULL )
		{
		//
		//   Delete the supplied allocation.
		//
		PLACEMENT_DELETE( Type,TYPE );

		Stack[ (TopOfStack ++) ] = Type;

		//
		//   Flush a portion of the stack if it
		//   is full.
		//
		if ( TopOfStack >= STACK_SIZE )
			{
			//
			//   Delete any outstanding memory 
			//   allocations.
			//
			Heap -> MultipleDelete
				(
				(TopOfStack -= FillSize),
				((void**) & Stack[ TopOfStack ])
				);
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,int STACK_SIZE> SINGLE_SIZE_HEAP<TYPE,STACK_SIZE>::~SINGLE_SIZE_HEAP( void )
    {
	//
	//   Delete any outstanding memory 
	//   allocations.
	//
	Heap -> MultipleDelete
		(
		TopOfStack,
		((void**) Stack)
		);

	TopOfStack = 0;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\SmpHeap.hpp ===
#ifndef _SMP_HEAP_HPP_
#define _SMP_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPLAIN_ABOUT_SMP_HEAP_LEAKS
#include "DebugHeap.hpp"
typedef DEBUG_HEAP					  SMP_HEAP_TYPE;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP					  SMP_HEAP_TYPE;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class DLL;
class LIST;
class TLS;

struct PRIVATE_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A SMP heap.                                                    */
    /*                                                                  */
    /*   A SMP heap is optimized for SMP performance.  Each thread      */
    /*   is given its own private per thread heap but the standard      */
    /*   Rockall API is maintained so it looks like a single heap.      */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMP_HEAP : public SMP_HEAP_TYPE
    {
		//
		//   Private data.
		//
		bool						  Active;
		bool						  DeleteOnExit;

		LIST						  *ActiveHeaps;
		DLL							  *DllEvents;
		LIST						  *FreeHeaps;
		PRIVATE_HEAP				  *HeapWalk;
		TLS							  *Tls;

		int							  ActiveLocks;
		int							  MaxFreeSpace;
		bool						  Recycle;
		bool						  SingleImage;
		bool						  ThreadSafe;

   public:
        //
        //   Public functions.
        //
        SMP_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = true,
			bool					  ThreadSafe = true,
			//
			//   Special flags for this heap.
			//
			bool					  DeleteHeapOnExit = false
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Special public functions
		//
		static void ThreadDetach( void *Parameter,int Reason );

        ~SMP_HEAP( void );

	protected:
		//
		//   Protected inline functions.
		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

   private:
		//
		//   Static private functions.
		//
	    PRIVATE_HEAP *GetPrivateHeap( void );


        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMP_HEAP( const SMP_HEAP & Copy );

        void operator=( const SMP_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\SmallHeap.hpp ===
#ifndef _SMALL_HEAP_HPP_
#define _SMALL_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A small heap.                                                  */
    /*                                                                  */
    /*   A small heap tries to significantly reduce memory usage        */
    /*   even if that comes at a significant cost in terms of           */
    /*   performance.                                                   */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMALL_HEAP : public ROCKALL_FRONT_END
    {
   public:
        //
        //   Public functions.
        //
        SMALL_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~SMALL_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMALL_HEAP( const SMALL_HEAP & Copy );

        void operator=( const SMALL_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\xalloc.cpp ===
#include "InterfacePCH.hpp"
#include "XAlloc.h"

#pragma init_seg(lib)

#if defined(_DEBUG)
#if defined(USE_PAGE_HEAP)
PAGE_HEAP g_XHeap(0, false, false, true, true, true);
#else
DEBUG_HEAP g_XHeap(0, false, false, true, true, true);
#endif
#else
BLENDED_HEAP g_XHeap;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\WindowsHeap.hpp ===
#ifndef WINDOWS_HEAP_HPP 
#define WINDOWS_HEAP_HPP 1                         
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Windows.h"

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

#ifdef __cplusplus
#define EXTERN_C			extern "C"
#else
#define EXTERN_C
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The shadow interface.                                          */
    /*                                                                  */
    /*   The shadow interface closely resembles the NT heap interface   */
    /*   and so enables the easy porting of applications.               */
    /*                                                                  */
    /********************************************************************/

EXTERN_C ROCKALL_DLL_LINKAGE HANDLE WindowsHeapCreate
	( 
	DWORD						  Flags,
	DWORD						  InitialSize,
	DWORD						  MaximumSize 
	);

EXTERN_C ROCKALL_DLL_LINKAGE LPVOID WindowsHeapAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	DWORD						  Size 
	);

EXTERN_C ROCKALL_DLL_LINKAGE UINT WindowsHeapCompact
	( 
	HANDLE						  Heap,
	DWORD						  Flags 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapFree
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapLock
	( 
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE LPVOID WindowsHeapReAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory,
	DWORD						  Size 
	);

EXTERN_C ROCKALL_DLL_LINKAGE VOID WindowsHeapReset
	(
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE DWORD WindowsHeapSize
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapUnlock
	(
	HANDLE						  Heap 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapValidate
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapWalk
	( 
	HANDLE						  Heap,
	LPPROCESS_HEAP_ENTRY		  Walk 
	);

EXTERN_C ROCKALL_DLL_LINKAGE BOOL WindowsHeapDestroy
	(
	HANDLE						  Heap 
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\dvt\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>

#include <zoneheap.hpp>
#include <rockallbackend.hpp>

#include <xalloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\zoneheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Assembly.hpp"
#include "Prefetch.hpp"
#include "RockallBackEnd.hpp"
#include "Spinlock.hpp"
#include "ZoneHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 AlignmentMask			  = (sizeof(double)-1);
CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 1024;
CONST SBIT32 Stride2				  = 1024;
CONST SBIT32 ZonePageSize			  = 4096;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        4,    16384,    16384 },
		{     2048,        4,    16384,    16384 },
		{     3072,        4,    16384,    16384 },
		{     4096,        8,    65536,    65536 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL_FRONT_END::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 2,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC PREFETCH Prefetch;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::ZONE_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL_FRONT_END
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			(ROCKALL_BACK_END::RockallBackEnd()),
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	AUTO ZONE NewZone = { NULL,NULL };

	//
	//   Setup the heap structures.
	//
	MaxSize = ZonePageSize;
	ThreadLocks = ThreadSafe;
	Zone = NewZone;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete all the heap allocations and return all the space       */
    /*   back to the operating system.                                  */
    /*                                                                  */
    /********************************************************************/

void ZONE_HEAP::DeleteAll( bool Recycle )
    {
	AUTO ZONE Update = { NULL,NULL };

	//
	//   Delete all outstanding allocations.
	//
	ROCKALL_FRONT_END::DeleteAll( Recycle );

	//
	//   Delete the stale zone pointers.
	//
	WriteZone( & Update );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   We simply call 'New' to create each element
	//   for a zone heap.
	//
	for ( (*Actual)=0;(*Actual) < Requested;(*Actual) ++ )
		{
		REGISTER VOID **Current = & Array[ (*Actual) ];

		//
		//   Create an allocation.
		//
		(*Current) = (ZONE_HEAP::New( Size,Space,Zero ));

		//
		//   Exit if there is no more space.
		//
		if ( (*Current) == NULL )
			{ return false; }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

void *ZONE_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   We would really hope that nobody would ask
	//   for a negative amount of memory but just to
	//   be sure we verify that this is not the case.
	//
	if ( Size >= 0 )
		{
		AUTO SBIT32 NewSize = ((Size + AlignmentMask) & ~AlignmentMask);
		AUTO ZONE Original;
		AUTO ZONE Update;

		//
		//   We would hope to create the allocation on the
		//   first try but there is a possibility that it
		//   may take serveral tries.
		do
			{
			//
			//   Extract a copy of the current zone pointers
			//   into local variables.
			//
			Original = Zone;
			Update = Original;

			//
			//   We need to ensure that there is enough space 
			//   in the zone for the current allocation.
			//
			if 
					( 
					(Update.Start == NULL)
						||
					((Update.Start += NewSize) > Update.End)
					)
				{
				//
				//   We do not have enough space.  If the size
				//   seems reasonable then get a new block from
				//   Rockall.  If not just pass the request along 
				//   to Rockall.
				//
				if ( NewSize < (MaxSize / 4) )
					{
					STATIC SPINLOCK Spinlock;

					//
					//   We need to create a new zone page
					//   so claim a lock.
					//
					Spinlock.ClaimLock();

					//
					//   We may find that the zone has
					//   already been updated.  If so
					//   just exit.
					//
					if ( Update.End == Zone.End )
						{
						//
						//   Try to allocate a new zone
						//   block.
						//
						Update.Start = 
							((CHAR*) ROCKALL_FRONT_END::New( MaxSize ));

						//
						//   Verify we were able to create
						//   a new zone page.
						//
						if ( Update.Start != NULL )
							{ Update.End = (Update.Start + MaxSize); }
						else
							{ Update.End = NULL; }

						//
						//   Update the zone.
						//
						WriteZone( & Update );
						}

					//
					//   Release the lock.
					//
					Spinlock.ReleaseLock();

					//
					//   If we were unable to get more
					//   space then exit.
					//
					if ( Update.Start == NULL )
						{ return NULL; }
					}
				else
					{ return (ROCKALL_FRONT_END::New( Size,Space,Zero )); }
				}
			}
		while ( ! UpdateZone( & Original,& Update ) );

		//
		//   Prefetch the first cache line of  
		//   the allocation if we are running
		//   a Pentium III or better.
		//
		Prefetch.L1( ((CHAR*) Original.Start),1 );

		//
		//   If the caller wants to know the real 
		//   size them we supply it.
		//
		if ( Space != NULL )
			{ (*Space) = NewSize; }

		//
		//   If we need to zero the allocation
		//   we do it here.
		//
		if ( Zero )
			{ ZeroMemory( Original.Start,NewSize ); }

		//
		//   Exit and return the address.
		//
		return (Original.Start);
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the zone.                                               */
    /*                                                                  */
    /*   We update the zone when we do an allocation.  We do this       */
    /*   atomically if there are multiple threads.                      */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::UpdateZone( ZONE *Original,ZONE *Update )
    {
	//
	//   Do we need to allow for multiple threads.  If 
	//   so we need to do the update atomically.  If 
	//   not then a simple assignment is fine.
	//
	if ( ThreadLocks )
		{
		REGISTER SBIT64 FinalValue =
			(
			ASSEMBLY::AtomicCompareExchange64
				(
				((SBIT64*) & Zone),
				(*((SBIT64*) Update)),
				(*((SBIT64*) Original))
				) 
			);

		return (FinalValue == (*((SBIT64*) Original)));
		}
	else
		{
		REGISTER BOOLEAN Result = 
			((*((SBIT64*) Original)) == (*((SBIT64*) & Zone)));

		//
		//   Lets just check that the current zone
		//   matches the original value.  It may
		//   not if we have had to move to a new page.
		//
		if ( Result )
			{ Zone = (*Update); }

		return Result;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Write to the zone.                                             */
    /*                                                                  */
    /*   We write to the zone when we need to overwrite it.  We do      */
    /*   this atomically if there are multiple threads.                 */
    /*                                                                  */
    /********************************************************************/

void ZONE_HEAP::WriteZone( ZONE *Update )
    {
	AUTO ZONE Original = Zone;

	while ( ! UpdateZone( & Original,Update ) )
		{ Original = Zone; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::~ZONE_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\dvt\dvt.cpp ===
// This is the main project file for VC++ application project 
// generated using an Application Wizard.

#include "stdafx.h"

#define TESTCASE_RESULT(e) (e ? "succeeded" : "failed")

void TC_RockallBackEnd_NewArea_Pos()
{
    ROCKALL_BACK_END heap;

    void* pv = heap.NewArea(heap.NaturalSize() + 1, 1024, true);

    printf("Test case TC_RockallBackEnd_NewArea_Pos %s.\r\n", TESTCASE_RESULT(pv != (void*)AllocationFailure));
}

void TC_RockallBackEnd_NewArea_Neg_48766()
{
    ROCKALL_BACK_END heap;

    void* pv = heap.NewArea(heap.NaturalSize() + 1, 0x7fffffff, true);

    printf("Test case TC_RockallBackEnd_NewArea_Neg_48766 %s.\r\n", TESTCASE_RESULT(pv == (void*)AllocationFailure));
}

void TC_ZoneHeap_New_Pos()
{
    ZONE_HEAP heap;

    void* pv = heap.New(1024);

    printf("Test case TC_ZoneHeap_New_Pos %s.\r\n", TESTCASE_RESULT(pv != NULL));
}

void TC_ZoneHeap_New_Neg_48834()
{
    ZONE_HEAP heap;

    void* pv = heap.New(0x7fffffff);

    printf("Test case TC_ZoneHeap_New_Neg_48834 %s.\r\n", TESTCASE_RESULT(pv == NULL));
}

void TC_XPtr_Ctor_Pos()
{
    try
    {
        XPtr<int> ptr(1024);

        printf("Test case TC_XPtr_Ctor_Pos succeeded.\r\n");
    }
    catch(...)
    {
        printf("Test case TC_XPtr_Ctor_Pos failed.\r\n");
    }

}

void TC_XPtr_Ctor_Neg_48768()
{
    try
    {
        XPtr<int> ptr(0x7fffffff);

        printf("Test case TC_XPtr_Ctor_Neg_48768 failed.\r\n");
    }
    catch(...)
    {
        printf("Test case TC_XPtr_Ctor_Neg_48768 succeeded.\r\n");
    }
}

void TC_XPtr_Alloc_Pos()
{
    try
    {
        XPtr<int> ptr;

        ptr.Alloc(1024);

        printf("Test case TC_XPtr_Alloc_Pos succeeded.\r\n");
    }
    catch(...)
    {
        printf("Test case TC_XPtr_Alloc_Pos failed.\r\n");
    }
}

void TC_XPtr_Alloc_Neg_48832()
{
    try
    {
        XPtr<int> ptr;

        ptr.Alloc(0x7fffffff);

        printf("Test case TC_XPtr_Alloc_Neg_48832 failed.\r\n");
    }
    catch(...)
    {
        printf("Test case TC_XPtr_Alloc_Neg_48832 succeeded.\r\n");
    }
}

void TC_Debug_Heap2()
{
   DEBUG_HEAP heap;

   void * pvv = heap.New(6334);
   byte * pv = (byte *)pvv;
   if ((SIZE_T)pvv != (SIZE_T)pv)
   {
        printf("Error they are not equal\r\n");
   }
   else
   {
        printf("No Problem\r\n");
   }
   for (int i=0;i<6334;i++)
   {
        pv[i] = 0xAA;
        if (i > 6328)
        {
            printf("%d \r\n", i);
            heap.HeapLeaks();
        }
   }
   
   heap.HeapLeaks();

   printf("Test case TC_Debug_Heap\r\n");
}

void TC_Debug_Heap()
{
       DEBUG_HEAP heap;

       byte * pv = (byte *)heap.New(5);
       
       for (int i=0;i<5;i++)
       {
            pv[i] = 0xAA;
       }

       heap.Delete(pv);
       

       printf("Test case TC_Debug_Heap\r\n");
   
}


int __cdecl _tmain()
{
TC_Debug_Heap();
    TC_RockallBackEnd_NewArea_Pos();
    TC_RockallBackEnd_NewArea_Neg_48766();

    TC_ZoneHeap_New_Pos();
    TC_ZoneHeap_New_Neg_48834();

    TC_XPtr_Ctor_Pos();
    TC_XPtr_Ctor_Neg_48768();

    TC_XPtr_Alloc_Pos();
    TC_XPtr_Alloc_Neg_48832();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xheap_none_12.4.56.0_none_f5203f4adf5f1666
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xheap
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.manifest
XP_MANIFEST_PATH=manifests\x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.cat
XP_CATALOG_PATH=manifests\x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.cat
XP_PAYLOAD_PATH=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xheap,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\windowsheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#include "Global.hpp"
#include "New.hpp"
#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here are for common values.             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoHeapSize				  = -1;
CONST SBIT32 ResizeDown				  = -64;
CONST SBIT32 StandardSize			  = (1024 * 1024);

    /********************************************************************/
    /*                                                                  */
    /*   Data structures local to the class.                            */
    /*                                                                  */
    /*   We need to keep various information along with the heap        */
    /*   so here we supply a structure to hold it all.                  */
    /*                                                                  */
    /********************************************************************/

typedef struct
    {
	DWORD							  Flags;
	DEFAULT_HEAP					  Rockall;
    }
WINDOWS_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Create a new heap.                                             */
    /*                                                                  */
    /*   Create a new heap and prepare it for use.  If any problems     */
    /*   are encountered the request is rejected.                       */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
		( 
		DWORD					  Flags,
		DWORD					  InitialSize,
		DWORD					  MaximumSize 
		)
	{
	//
	//   We do not support all the functionality with
	//   this interface so just reject any calls that
	//   require the unsupported features.
	//
	if ( MaximumSize <= 0 ) 
		{
		REGISTER WINDOWS_HEAP *WindowsHeap = 
#ifdef NO_DEFAULT_HEAP
			((WINDOWS_HEAP*) malloc( sizeof(WINDOWS_HEAP) ));
#else
			((WINDOWS_HEAP*) DefaultHeap.New( sizeof(WINDOWS_HEAP) ));
#endif

		//
		//   If we were unable to allocate space for  
		//   the root of the heap then we exit.
		//
		if ( WindowsHeap != NULL )
			{
			//
			//   Save the flags for later calls.
			//
			WindowsHeap -> Flags = Flags;

			//
			//   Call the heap constructor. 
			//
			PLACEMENT_NEW( & WindowsHeap -> Rockall,DEFAULT_HEAP ) 
				( 
				((SBIT32) (InitialSize + StandardSize)),
				True,
				False,
				((BOOLEAN) ((Flags & HEAP_NO_SERIALIZE) == 0))
				);

			//
			//   Ensure the heap is initialized correctly.
			//
			if ( ! WindowsHeap -> Rockall.Corrupt() )
				{ return ((HANDLE) WindowsHeap); }
			else
				{ free( WindowsHeap ); }
			}
		}

	return NULL;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocate memory. .                                             */
    /*                                                                  */
    /*   Create a new memory allocation and verify it works.  if        */
    /*   not then throw an exception or return a status.                */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapAlloc( HANDLE Heap,DWORD Flags,DWORD Size )
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.New
			( 
			Size,
			NULL,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compact the heap.                                              */
    /*                                                                  */
    /*   Compact the heap by returning any unallocated space to the     */
    /*   operating system.  This can prove to be very expensive if      */
    /*   the space is later reclaimed.                                  */
    /*                                                                  */
    /********************************************************************/

extern "C" UINT WindowsHeapCompact( HANDLE Heap,DWORD Flags )
	{
	//
	//   We instruct the heap to return any available
	//   space to the operating system.  If we later
	//   choose to regain this space it is very expensive
	//   so lets hope the user knew what he was doing.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.Truncate();

	return 1;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Free memory.                                                   */
    /*                                                                  */
    /*   Free a memory allocation so that the space may be recycled     */
    /*   for subsequent memory allocation requests.                     */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapFree( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	//
	//   We release the memory allocation if it belongs to us.
	//   If not then we simply fail the request.  Regardless,
	//   we are not negatively effected either way.
	//
	return ((BOOL) ((WINDOWS_HEAP*) Heap) -> Rockall.Delete( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Lock the heap.                                                 */
    /*                                                                  */
    /*   Lock the heap by claiming all of the associated heap locks.    */
    /*   All the locks associated with a heap help make the heap        */
    /*   scale well but are a big performance hit for this type of      */
    /*   request.                                                       */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapLock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.LockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reallocate memory.                                             */
    /*                                                                  */
    /*   Reallocate a portion of memory and possibly copy the data      */
    /*   to the enlarged memory area.                                   */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapReAlloc
		( 
		HANDLE					  Heap,
		DWORD					  Flags,
		LPVOID					  Memory,
		DWORD					  Size 
		)
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.Resize
			( 
			Memory,
			Size,
			((AllFlags & HEAP_REALLOC_IN_PLACE_ONLY) ? 0 : ResizeDown),
			false,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the heap.                                                */
    /*                                                                  */
    /*   Delete all outstanding memory allocations while leaving        */
    /*   the structure of the heap in place ready for new memory        */
    /*   allocation requests.                                           */
    /*                                                                  */
    /********************************************************************/

extern "C" VOID WindowsHeapReset( HANDLE Heap )
	{
	//
	//   We have been asked to delete all the outstanding 
	//   memory allocations.  This is significant and costly
	//   process.  Nonetheless, the overhead is the same as
	//   around 20-30 delete requested so it can be worthwhile
	//   in a number of cases.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.DeleteAll(); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocation size.                                               */
    /*                                                                  */
    /*   Although Rockall optionally supplies the allocation size       */
    /*   when a new allocation is requested.  Nonetheless, this has     */
    /*   to be done the hard way with other interfaces.                 */
    /*                                                                  */
    /********************************************************************/

extern "C" DWORD WindowsHeapSize( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	AUTO INT Size;

	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	if ( ((WINDOWS_HEAP*) Heap) -> Rockall.Details( Memory,& Size ) )
		{ return Size; }
	else
		{ return ((DWORD) NoHeapSize); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unlock the heap.                                               */
    /*                                                                  */
    /*   Unlock the heap and release all the associated heap locks.     */
    /*   The multiple locks that need to be released make this quite    */
    /*   an expensive request.                                          */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapUnlock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.UnlockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Validate the heap.                                             */
    /*                                                                  */
    /*   Validate the heap or a specific heap allocation to ensure      */
    /*   all is well.  We have to go to quite a bit of trouble to       */
    /*   figure this out so this call can be quite expensive.           */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapValidate( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{ 
	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	return (((WINDOWS_HEAP*) Heap) -> Rockall.Verify( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   Walk the heap and provide information about every allocated    */
    /*   and unallocated portion of memory.  Needless to say this is    */
    /*   typically a long process and the request is not cheap.         */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapWalk( HANDLE Heap,LPPROCESS_HEAP_ENTRY Walk )
	{
	AUTO bool Active;
	REGISTER BOOL Result =
		( 
		((WINDOWS_HEAP*) Heap) -> Rockall.Walk
			( 
			& Active,
			((void**) & Walk -> lpData),
			((int*) & Walk -> cbData)
			) 
		);

	//
	//   If we managed to find the next element we
	//   fill in all the other fields as needed.
	//
	if ( Result )
		{
		//
		//   Fill in all the addition fields just 
		//   to be compatible with the existing 
		//   functionality.
		//
		Walk -> cbOverhead = 0;
		Walk -> iRegionIndex = 0;
		Walk -> wFlags = 
			(
			(Active) 
				? ((WORD) PROCESS_HEAP_ENTRY_BUSY)
				: ((WORD) PROCESS_HEAP_UNCOMMITTED_RANGE)
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a heap.                                                 */
    /*                                                                  */
    /*   Delete a heap and release all the associated space.            */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapDestroy( HANDLE Heap )
	{
	if ( ! ((WINDOWS_HEAP*) Heap) -> Rockall.Corrupt() )
		{
		//
		//   We do not appear to have damaged the heap
		//   so it should be safe to delete it.
		//
		PLACEMENT_DELETE( & ((WINDOWS_HEAP*) Heap) -> Rockall,DEFAULT_HEAP );

#ifdef NO_DEFAULT_HEAP
		free( ((WINDOWS_HEAP*) Heap) );
#else
		DefaultHeap.Delete( ((WINDOWS_HEAP*) Heap) );
#endif

		return TRUE;
		}
	else
		{ return FALSE; }
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\ZoneHeap.hpp ===
#ifndef _ZONE_HEAP_HPP_
#define _ZONE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "RockallFrontEnd.hpp"

#pragma warning( disable : 4100 )

    /********************************************************************/
    /*                                                                  */
    /*   A zone heap.                                                   */
    /*                                                                  */
    /*   A zone heap simply allocates a large amount of space and       */
    /*   allocates space by advancing a pointer down an array.          */
    /*   There is no way to free space except by deleting it all.       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ZONE_HEAP : public ROCKALL_FRONT_END
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			char					  *Start;
			char					  *End;
			}
		ZONE;

		//
		//   Private data.
		//
		int							  MaxSize;
		bool						  ThreadLocks;
		ZONE						  Zone;

   public:
        //
        //   Public functions.
        //
        ZONE_HEAP
			( 
			int						  MaxFreeSpace = (2 * HalfMegabyte),
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
				( 
				void				  *Address,
				int					  Size = NoSize 
				)
			{ return false; }

		virtual bool Details
				( 
				void				  *Address,
				int					  *Space = NULL 
				)
			{ return false; }

		virtual bool MultipleDelete
				( 
				int					  Actual,
				void				  *Array[],
				int					  Size = NoSize
				)
			{ return false; }

		virtual bool MultipleNew
				( 
				int					  *Actual,
				void				  *Array[],
				int					  Requested,
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *New
				( 
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *Resize
				( 
				void				  *Address,
				int					  NewSize,
				int					  Move = -64,
				int					  *Space = NULL,
				bool				  NoDelete = false,
				bool				  Zero = false
				)
			{ return NULL; }

		virtual bool Verify
				( 
				void				  *Address = NULL,
				int					  *Space = NULL 
				)
			{ return false; }

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
				(
				bool				  *Active,
				void				  **Address,
				int					  *Space
				)
			{ return false; }

        ~ZONE_HEAP( void );

	private:
		//
		//   Private functions.
		//
		bool UpdateZone( ZONE *Original,ZONE *Update );

		void WriteZone( ZONE *Update );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ZONE_HEAP( const ZONE_HEAP & Copy );

        void operator=( const ZONE_HEAP & Copy );
    };

#pragma warning( default : 4100 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xheap\xheap\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xheap_none_12.4.56.0_none_f5203f4adf5f1666
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xheap
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.manifest
XP_MANIFEST_PATH=manifests\x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.cat
XP_CATALOG_PATH=manifests\x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da.cat
XP_PAYLOAD_PATH=x86_xheap_no-public-key_12.4.56.0_x-ww_05eaf3da
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xheap,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\socket.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

class CSGSocket
{
protected:
    SOCKET  m_Socket;
    bool    m_bInitialized;

public:
    CSGSocket(void);
    ~CSGSocket(void);

    BOOL Initialized(void);
    BOOL SendTo(SOCKADDR_IN addr, LPCSTR szBuffer, ULONG ulBufferLen);
    BOOL RecvFrom(LPSTR szBuffer, PULONG pulBufferLen);
    void Drain(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\socketcache.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "xalloc.h"
#include "socketcache.h"
#include "socket.h"

CSGSocketCache::CSGSocketCache(void)
{
}

CSGSocketCache::~CSGSocketCache(void)
{
    m_Sockets.Clear();
}

CSGSocket* CSGSocketCache::AcquireSocket()
{
    CSGSocket*	pSocket = NULL;

    pSocket = m_Sockets.Remove();

    //
    //  Did we get a socket?  If not, create one.
    //

    if(pSocket == NULL)
    {
        pSocket = new CSGSocket();
    }
    else
    {
        pSocket->Drain();
    }

    return pSocket;
}


void CSGSocketCache::ReleaseSocket(
    CSGSocket*  pSocket
    )
{
    m_Sockets.Insert(pSocket);
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\stdafx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#include <atlbase.h>
#include <atlcom.h>
#include <atlcoll.h>
#include <stdio.h>
#include <stdarg.h>

#include <winsock2.h>

#include <wsockntp.h>
#include <xonlinep.h>
#include <xmgmt.h>
#include <xlocks.h>

XomImportArea(DefaultTrace);

#include "socketcache.h"
#include "socket.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\socketcache.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once
#include "Socket.h"

//
//  A list of individual sockets.  Sockets are added at the head
//  and removed from the tail.
//

typedef CAtlList<CSGSocket*> SOCKET_LIST;

class CSGSocketList
{
protected:
    xlocks::CSmallSpinLock  m_csList;
    SOCKET_LIST             m_List;

public:

    CSGSocketList(void)  
    { 
    }

    ~CSGSocketList(void) 
    {
        CSGSocket* pSocket;

        m_csList.WriteLock();

        while(!m_List.IsEmpty())
        {
            pSocket = m_List.RemoveHead();
            delete pSocket;
        }

        m_csList.WriteUnlock();
    }

	void Clear(void)
	{
		CSGSocket*	pSocket;

		m_csList.WriteLock();

		while(m_List.GetCount() != 0)
		{
			pSocket = m_List.RemoveTail();
			delete pSocket;
		}

		m_csList.WriteUnlock();
	}

    void Insert(CSGSocket* pSocket) 
    {
        if(pSocket == NULL)
            return;

        m_csList.WriteLock();

        m_List.AddHead(pSocket);

        m_csList.WriteUnlock();
    }

    CSGSocket* Remove(void)
    {
        CSGSocket*    pSocket;

        m_csList.WriteLock();

        if(m_List.GetCount() == 0)
            pSocket = NULL;
        else
            pSocket = m_List.RemoveTail();

        m_csList.WriteUnlock();

        return pSocket;
    }
};


class CSGSocketCache
{
protected:
    CSGSocketList   m_Sockets;

public:
    CSGSocketCache(void);
    ~CSGSocketCache(void);

    CSGSocket* AcquireSocket(void);
    void ReleaseSocket(CSGSocket* pSocket);
};

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\socket.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "xalloc.h"
#include "socket.h"

CXomSettingEx g_Timeout(
                        CXomOption(CXomSetting::O_NAME, "VALUES.XSGInfoTimeout") +
                        CXomOption(CXomSetting::O_DEFAULT, 1000));

CSGSocket::CSGSocket()
{
    int nTimeout = g_Timeout.GetDw();

    m_bInitialized = false;

    //  Create a socket that is totally synchronous.
    m_Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(m_Socket == INVALID_SOCKET)
    {
        XomTrace(DefaultTrace,
                  L_ERROR,
                  "CSGSocket::CSGSocket - Failed to create socket, error = 0x%08X.",
                  HRESULT_FROM_WIN32(WSAGetLastError()));
        return;
    }

    //  Set any socket options

    setsockopt(m_Socket, SOL_SOCKET, SO_RCVTIMEO, (char*)&nTimeout, sizeof(nTimeout));

    //  Initialized successfully.

    XomTrace(DefaultTrace,
              L_LOW,
              "CSGSocket::CSGSocket - Socket initialized.");

    m_bInitialized = true;
}

CSGSocket::~CSGSocket(void)
{
    if(m_Socket != INVALID_SOCKET)
        closesocket(m_Socket);
}

BOOL CSGSocket::Initialized()
{
    return m_bInitialized ? TRUE : FALSE;
}

//
//  If this returns FALSE, call WSAGetLastError to get specific error code
//

BOOL CSGSocket::SendTo(
    SOCKADDR_IN addr,
    LPCSTR      szBuffer,
    ULONG       ulBufferLen
    )
{
    if(!m_bInitialized || m_Socket == INVALID_SOCKET)
    {
        XomTrace(DefaultTrace,
                  L_NORMAL,
                  "CSGSocket::SendTo - Socket not properly initialized.");
        WSASetLastError(WSAENOTSOCK);
        return FALSE;
    }

    if(sendto(m_Socket, szBuffer, ulBufferLen, 0, (const sockaddr *)&addr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        XomTrace(DefaultTrace,
                  L_ERROR,
                  "CSGSocket::SendTo - sendto failed with error = 0x%08X.",
                  HRESULT_FROM_WIN32(WSAGetLastError()));
        return FALSE;
    }

    return TRUE;
}

//
//  If this returns FALSE, call WSAGetLastError to get specific error code
//  Wait until timeout to receive the number of bytes we expect
//

BOOL CSGSocket::RecvFrom(
    LPSTR   szBuffer,
    PULONG  pulBufferLen
    )
{
    int nBytesReceived = recvfrom(m_Socket, 
                                  szBuffer, 
                                  *pulBufferLen,
                                  0,
								  NULL,
								  NULL);
    if(nBytesReceived == SOCKET_ERROR)
    {
        XomTrace(DefaultTrace,
                  L_ERROR,
                  "CSGSocket::RecvFrom - recvfrom failed with error = 0x%08X.",
                  HRESULT_FROM_WIN32(WSAGetLastError()));
        return FALSE;
    }

    XomTrace(DefaultTrace,
              L_LOW,
              "CSGSocket::RecvFrom - Received %d bytes.",
              nBytesReceived);

    *pulBufferLen = nBytesReceived;

    return TRUE;
}

//
// This drains the socket of any extraneous packets that may be sitting on the socket awaiting
// processing.
//

void CSGSocket::Drain(void)
{
    if(!m_bInitialized || m_Socket == INVALID_SOCKET)
    {
        return;
    }

    fd_set sockets;

    sockets.fd_count = 1;
    sockets.fd_array[0] = m_Socket;

    timeval timeOut = {0};

    // Drain packets that may still be left from retries on the use of the socket.

    int err = select(0, &sockets, NULL, NULL, &timeOut);
    while (err > 0 && err != SOCKET_ERROR)
    {
        char dontCare = 0;

        // Since the traffic is UDP, the extra data will be dropped, but we don't
        // care about the results.
        recvfrom(m_Socket, &dontCare, 1, 0, NULL, NULL);
        err = select(0, &sockets, NULL, NULL, &timeOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xsginfo_none_12.4.56.0_none_7a7be2fb3ff1b980
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xsginfo
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.manifest
XP_MANIFEST_PATH=manifests\x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.cat
XP_CATALOG_PATH=manifests\x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.cat
XP_PAYLOAD_PATH=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xsginfo,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\inc\xsginfo.h ===
#pragma once

struct CSgMsgSpiRep;


// ---------------------------------------------------------------------------------------
// GetSGInfo - Takes the Datacenter IP and port a request came in on and returns Spi and Auth data 
// ---------------------------------------------------------------------------------------
HRESULT __stdcall GetSGInfo( ULONG ulSGAddr, USHORT nSGPort, CSgMsgSpiRep* pMsg, DWORD cbMsg );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\XSGClientInfo.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// XSGClientInfo.cpp

#include "stdafx.h"
#include "socket.h"

CXomSettingEx g_Retries(
                        CXomOption(CXomSetting::O_NAME, "VALUES.XSGInfoRetries") +
                        CXomOption(CXomSetting::O_DEFAULT, 3));


// Globals
static CSGSocketCache g_SocketCache;
static LONG g_lReqNum = 1;

//
//  Utility function for sending binary blob to trace output
//

void TraceBlob(
    LPBYTE  pBlob,
    ULONG   ulBlobLen
    )
{
    ULONG ulLine;
    ULONG ulLineStart;
    const ULONG ulWholeLines = ulBlobLen >> 3;

    //
    //  Loop through blob in 8 byte chunks, spewing out lines of 8 bytes
    //

    for(ulLine = 0; ulLine < ulWholeLines; ++ulLine)
    {
        ulLineStart = ulLine << 3;

        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X %02X %02X %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2],
                  pBlob[ulLineStart + 3],
                  pBlob[ulLineStart + 4],
                  pBlob[ulLineStart + 5],
                  pBlob[ulLineStart + 6],
                  pBlob[ulLineStart + 7]);
    }

    //
    //  Now print out any remaining bytes
    //

    ulLineStart = ulWholeLines << 3;

    switch(ulBlobLen % 8)
    {
    case 0:
        // no more bytes to output!
        break;

    case 1:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0]);
        break;

    case 2:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1]);
        break;

    case 3:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2]);
        break;

    case 4:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2],
                  pBlob[ulLineStart + 3]);
        break;

    case 5:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2],
                  pBlob[ulLineStart + 3],
                  pBlob[ulLineStart + 4]);
        break;

    case 6:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2],
                  pBlob[ulLineStart + 3],
                  pBlob[ulLineStart + 4],
                  pBlob[ulLineStart + 5]);
        break;

    case 7:
        XomTrace(DefaultTrace, L_LOW, "%08X: %02X %02X %02X %02X %02X %02X %02X",
                  ulLineStart,
                  pBlob[ulLineStart + 0],
                  pBlob[ulLineStart + 1],
                  pBlob[ulLineStart + 2],
                  pBlob[ulLineStart + 3],
                  pBlob[ulLineStart + 4],
                  pBlob[ulLineStart + 5],
                  pBlob[ulLineStart + 6]);
        break;
    }
}

HRESULT __stdcall GetSGInfo(
    ULONG         ulSGAddr,
    USHORT        nSGPort,
    CSgMsgSpiRep* pMsg,
    DWORD         cbMsg )
{
    HRESULT         hr;
    CSGSocket*      pSocket = NULL;
    CSgMsgSpiReq    SpiReq;
    SOCKADDR_IN     SGAddr;
    ULONG           ulCurTry;

    if( NULL == pMsg )
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Invalid parameter (message pointer is zero)" );
        hr = E_POINTER;
        goto Cleanup;
    }

    if( CBSGSPIREPMSG != cbMsg )
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Invalid parameter (expected message size is incorrect)" );
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Get a socket to use.
    pSocket = g_SocketCache.AcquireSocket();
    if(pSocket == NULL)
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Out of memory allocating socket." );
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //  Format the SG address
    SGAddr.sin_family = AF_INET;
    SGAddr.sin_addr.S_un.S_addr = ulSGAddr;
    SGAddr.sin_port = 0xFFFF;

    //  Format the SG request
    SpiReq._wType = SGMSG_TYPE_SPIDATA_REQ;
    SpiReq._cbEnt = sizeof( SpiReq );
    SpiReq._dwReqNum = (DWORD) InterlockedIncrement( &g_lReqNum );
    SpiReq._ipaZ.S_un.S_addr = ulSGAddr;
    SpiReq._ipportZ = nSGPort;

    //  Retry loop.  Keep trying to send if timeouts occur.
    ulCurTry = 0;
    do
    {
        //  Send the request
        if( !pSocket->SendTo( SGAddr, (LPCSTR) &SpiReq, sizeof( SpiReq ) ) )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - SendTo failed with error 0x%08X.", hr );
            goto Cleanup;
        }

        ulCurTry++;

        //  Wait for the response
        cbMsg = CBSGSPIREPMSG;
        if( !pSocket->RecvFrom( (LPSTR) pMsg, &cbMsg ) )
        {
            // See if an unexpected failure occurred
            if( WSAETIMEDOUT != WSAGetLastError() )
            {
                hr = HRESULT_FROM_WIN32(WSAGetLastError());
                XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - RecvFrom failed with error = 0x%08X.", hr );
                goto Cleanup;
            }
            else
            {
                // Timeout, resend and increment retry counter
                XomTrace( DefaultTrace, L_NORMAL, "CXSGClientInfo::GetSGInfo - Attempt number %u timed out, retrying %u more times.", ulCurTry, g_Retries.GetDw() - ulCurTry );
                continue;
            }
        }

        // Check the size of the reply header
        if( sizeof( *pMsg ) > cbMsg ||
            sizeof( *pMsg ) > pMsg->_cbEnt )
        {
            XomTrace( DefaultTrace, L_NORMAL, "CXSGClientInfo::GetSGInfo - Response too small for header, retrying %u more times.", g_Retries.GetDw() - ulCurTry );
            continue;
        }

        // Check the type of the reply header
        if( SGMSG_TYPE_SPIDATA_REP != pMsg->_wType )
        {
            XomTrace( DefaultTrace, L_NORMAL, "CXSGClientInfo::GetSGInfo - Response type is incorrect, retrying %u more times.", g_Retries.GetDw() - ulCurTry );
            continue;
        }

        // Validate the req num
        if( pMsg->_dwReqNum != SpiReq._dwReqNum )
        {
            XomTrace( DefaultTrace, L_NORMAL, "CXSGClientInfo::GetSGInfo - Request number mismatch, retrying %u more times.", g_Retries.GetDw() - ulCurTry );
            continue;
        }

        // we found an entry, break out of retry loop
        break;

    } while( ulCurTry < g_Retries.GetDw() );

    //  Did we get anything?
    if( ulCurTry >= g_Retries.GetDw() )
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Failed to get information from security gateway after %u attempts.", ulCurTry );
        hr = E_FAIL;
        goto Cleanup;
    }

    //  Did we get auth data back?
    if( pMsg->_fNotFound )
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Security gateway reported user not found." );
        hr = E_FAIL;
        goto Cleanup;
    }

    // The user was found, so we should have Spi data and Auth data
    if( CBSGSPIREP3MSG != cbMsg &&
        CBSGSPIREPMSG  != cbMsg)
    {
        XomTrace( DefaultTrace, L_ERROR, "CXSGClientInfo::GetSGInfo - Response too small for header, SpiData, and AuthData." );
        hr = E_FAIL;
        goto Cleanup;
    }

    XomTrace( DefaultTrace, L_LOW,
              "CXSGClientInfo::GetSGInfo - Received auth data from security gateway.  Entire auth data buffer follows...");
    TraceBlob( (BYTE*) pMsg, cbMsg );

    hr = S_OK;

Cleanup:

    if(pSocket != NULL)
    {
        g_SocketCache.ReleaseSocket(pSocket);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spilrun_none_12.4.56.0_none_c00856316fad6cc8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spilrun
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.manifest
XP_MANIFEST_PATH=manifests\msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.cat
XP_CATALOG_PATH=manifests\msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.cat
XP_PAYLOAD_PATH=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spilrun,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\xsginfo\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xsginfo_none_12.4.56.0_none_7a7be2fb3ff1b980
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xsginfo
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.manifest
XP_MANIFEST_PATH=manifests\x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.cat
XP_CATALOG_PATH=manifests\x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10.cat
XP_PAYLOAD_PATH=x86_xsginfo_no-public-key_12.4.56.0_x-ww_9e46cb10
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xsginfo,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spilrun_none_12.4.56.0_none_c00856316fad6cc8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spilrun
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.manifest
XP_MANIFEST_PATH=manifests\msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.cat
XP_CATALOG_PATH=manifests\msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce.cat
XP_PAYLOAD_PATH=msil_spilrun_no-public-key_12.4.56.0_x-ww_db7134ce
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spilrun,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\CsvFileConverter.cs ===
using System;
using System.Data;
using System.Data.OleDb;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Convert a CSV file to <see cref="DataSet"/>
	/// </summary>
	public class CsvFileConverter : IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="filePath"></param>
		public void ReadFromFile(DataSet ds, string filePath)
		{
			string pathName = Path.GetDirectoryName(filePath);
			string fileName = Path.GetFileName(filePath);
			using(OleDbConnection excelConnection = new OleDbConnection(@"Provider=Microsoft.Jet.OLEDB.4.0;Data Source="+pathName+";Extended Properties=Text;"))
			{
				OleDbCommand excelCommand = new OleDbCommand(@"SELECT * FROM "+fileName,excelConnection);
				OleDbDataAdapter excelAdapter = new OleDbDataAdapter(excelCommand);
				excelConnection.Open();
				excelAdapter.Fill(ds);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			throw new NotSupportedException("csv string is not supported.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\ConnectionManagerBase.cs ===
using System;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Base class for creating Connection Manager. Defines common properties available to connection manager.
	/// 
	/// This class implements <see cref="ISpilConnectionManager"/> interface which defines the common methods available
	/// to connection manager.
	/// </summary>
	public abstract class ConnectionManagerBase : ISpilConnectionManager
	{
        #region Fields
        /// <summary>
        /// connection timeout value
        /// </summary>
        protected int connTimeOut = 30;
        /// <summary>
        /// command timeout value
        /// </summary>
        protected int commTimeOut = 30;
        /// <summary>
        /// return value
        /// </summary>
        protected int returnVal = ProcedureResults.InvalidProcedureReturnValue;
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets connection Timeout value 
        /// </summary>
        public virtual int ConnectionTimeOut
        {
            get { return this.connTimeOut; }
            set { this.connTimeOut = value; }
        }
        
        
        /// <summary>
        /// Gets or sets command Timeout value 
        /// </summary>
        public virtual int CommandTimeOut
        {
            get { return this.commTimeOut; }
            set { this.commTimeOut = value; }
        }

        /// <summary>
        /// Gets or sets the return value of the query
        /// </summary>
        public  virtual int ReturnValue
        {
            get { return this.returnVal; }
            set { this.returnVal = value ;}
        }
        #endregion

        #region ISpilConnectionManager Members

        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection GetConnection(string databaseName, string connectionString, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection[] GetAllConnections(string databaseName, string connectionString);
        /// <summary>
        /// 
        /// </summary>
        public abstract void CloseConnections();
        /// <summary>
        /// 
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract object GetPhysicalInstanceId(string storeName, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <returns></returns>
        public abstract object[] GetAllPhysicalInstances(string logicalStoreName);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <param name="connectionString"></param>
        /// <param name="physicalInstanceKey"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection GetConnectionForPhysicalInstance(string logicalStoreName, string connectionString, object physicalInstanceKey);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract System.Data.IDbCommand GetCommand(string databaseName, string connectionString, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <param name="connectionString"></param>
        /// <param name="physicalInstanceKey"></param>
        /// <returns></returns>
        public abstract System.Data.IDbCommand GetCommandForPhysicalInstance(string logicalStoreName, string connectionString, object physicalInstanceKey);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="cmd"></param>
        /// <returns></returns>
        public abstract System.Data.IDataAdapter GetDataAdapterForCommand(System.Data.IDbCommand cmd);

        #endregion

        #region IDisposable Members
        /// <summary>
        /// 
        /// </summary>
        public abstract void Dispose();
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\AssertionException.cs ===
namespace Microsoft.Subscriptions.Data
{
	using System;
	using System.Runtime.Serialization;
	
	/// <summary>
	/// Thrown when an assertion failed.
	/// </summary>
	/// 
	[Serializable]
	public class DbAssertionException : System.Exception
	{
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message"></param>
		public DbAssertionException (string message) : base(message) 
		{}

		/// <summary>
		/// Standard constructor
		/// </summary>
		/// <param name="message">The error message that explains 
		/// the reason for the exception</param>
		/// <param name="inner">The exception that caused the 
		/// current exception</param>
		public DbAssertionException(string message, Exception inner) :
			base(message, inner) 
		{}

		/// <summary>
		/// Serialization Constructor
		/// </summary>
		protected DbAssertionException(SerializationInfo info, 
			StreamingContext context) : base(info,context)
		{}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\DataStoreComponent.cs ===
/*
 *  DataStoreComponent.cs
 * 
 *  Base class for interacting with DataStores.
 *  It consists of properties and methods to call stored procedures 
 *    on associated data stores.
 * 
 * Revision History:
 *  Feb 2003    - TaoH  - Add command timeout support.
 *                      - Add IDataReader support, rearranged code structure for reuse
 *  Aug 2002    - MuraliK  - created initial version
 */

using System;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.XPath;
using System.IO;
using System.Text;
using System.Collections;
using System.Runtime.CompilerServices;
using Microsoft.Webstore.WstClient; // for webstore connectivity

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// class DataStoreComponent
    /// o  base component for interacting with the databases
    /// It stores the connection string and provides accessors to create 
    ///     new SqlConnection class for talking with the databases.
    /// 
    /// TODO: Add auding/trace logic support
    /// </summary>
    public class DataStoreComponent
    {
        /// <summary>
        /// Reserved hash value to indicate that any physical instance may be used
        ///  when dealing with partitioned instances of same logical database
        /// </summary>
        public const int HashValueForAnyInstance = -1;

        /// <summary>
        /// info message handler
        /// </summary>
        protected static SqlInfoMessageEventHandler infoMessageEventHandler;
        /// <summary>
        /// Default constructor. The class is not directly instantiable.
        /// </summary>
        private DataStoreComponent() {}


        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public object ExecuteScalarStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {
            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteScalarOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);
        }

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public IDataReader ExecuteReaderStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteReaderOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // ExecuteReaderStoredProcedure

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public int ExecuteNonQueryStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteNonQueryOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // ExecuteNonQueryStoredProcedure

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the procedure results are returned.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results that contains the dataset and return value</returns>
        static public ProcedureResults ExecuteStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // protected ProcedureResults ExecuteStoredProcedure()


        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns the datareader.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>Always throws NotImplementedException</returns>
        static public IDataReader ExecuteReaderOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {
            throw new NotImplementedException("ExecuteReaderOnAllPartitions is not supported.");
        } // protected ProcedureResults ExecuteReaderOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns the datareader.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>array of returned scalar objects, one for each partition</returns>
        static public object[] ExecuteScalarOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {
            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            object[] scalarObjects = new object[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                scalarObjects[i] = ExecuteScalarOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return scalarObjects;
        } // protected ProcedureResults ExecuteReaderOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns ALL the procedure results as an array.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results array that contains the dataset and return value
        /// for each partition.</returns>
        static public ProcedureResults[] ExecuteProcedureOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {

            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            ProcedureResults[] allProcedureResults = new ProcedureResults[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                allProcedureResults[i] = ExecuteOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return allProcedureResults;
        } // protected ProcedureResults ExecuteProcedureOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns ALL the procedure results as an array.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results array that contains the dataset and return value
        /// for each partition.</returns>
        static public int[] ExecuteNonQueryOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {

            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            int[] allRowsAffected = new int[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                allRowsAffected[i] = ExecuteNonQueryOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return allRowsAffected;
        } // protected ProcedureResults ExecuteNonQueryOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the procedure results are returned.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results that contains the dataset and return value</returns>
        static public ProcedureResults ExecuteOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            return ExecuteCommandAndFetchResults(context, scm, cmd);
        } // public ProcedureResults ExecuteOnPhysicalInstance()


        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The scalar object from the stored procedure</returns>
        static public object ExecuteScalarOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            object returnObject;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                returnObject = cmd.ExecuteScalar();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the returnObject;

            return returnObject;
        }

        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The number of the rows affected</returns>
        static public int ExecuteNonQueryOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            int numberOfRowsAffected;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                numberOfRowsAffected = cmd.ExecuteNonQuery();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the returnObject;

            return numberOfRowsAffected;
        }
        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The datareader from the stored procedure</returns>
        static public IDataReader ExecuteReaderOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            IDataReader reader;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                reader = cmd.ExecuteReader();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the reader;

            return reader;
        } // ExecuteReaderOnPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Builds the command for executing the stored procedure.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The datareader from the stored procedure</returns>
        static public IDbCommand BuildCommand( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            if ((procedureName == null) || (procedureName.Length == 0)) 
            {
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");
            }

            // get the connection for the specified parameters
            IDbConnection dbconn = scm.GetConnectionForPhysicalInstance(logicalDatabaseName, partialConnectionString, physicalInstanceId);
            IDbCommand cmd = scm.GetCommandForPhysicalInstance(logicalDatabaseName, partialConnectionString, physicalInstanceId);

            if (dbconn is SqlConnection)
            {
                SqlConnection sqlc = dbconn as SqlConnection;
                
                if (infoMessageEventHandler == null)
                    infoMessageEventHandler = new SqlInfoMessageEventHandler(context.SqlInfo);
                
                // KLUDGE: this is not very good but I cannot find out how to check
                // only one event handler is registered without creating a memory structure (hashtable?)
                sqlc.InfoMessage -= infoMessageEventHandler;
                sqlc.InfoMessage += infoMessageEventHandler;
            }
            // WstCommands have parameters outside the IDbCommand interface.
            if (cmd is WstCommand)
            {
                ((WstCommand)(cmd)).Partition = (int)physicalInstanceId;
                ((WstCommand)(cmd)).PartitionType = WstPartitionType.Physical;
            }

            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = procedureName;           
            //add command timeout value.
            cmd.CommandTimeout = scm.CommandTimeOut;
            // fill in the parameters for the call 
            FillInProcedureParameters( cmd.Parameters, paramList);

            // set conect command
            context.command = cmd;
            context.connection = dbconn;
            return cmd;
        } // ExecuteReaderOnPhysicalInstance

        /// <summary>
        ///  Helper function to add the set of input parameters to the command's parameter collection.
        ///  As part of the add, it also will 'clone' parameters if required. 
        ///  Cloning (or making a copy) of parameters is required to ensure that we have unique
        ///     copies for each call made to the databases. ADO.NET/WebStore insist on this unique
        ///     instance of SqlParameter per collection.
        ///  It also adds the special return value parameter at the very end of the parameters list
        /// </summary>
        /// <param name="paramCollection">Parameter collection object that belongs to a command object</param>
        /// <param name="masterParamList">array of parameters to be included in the collection</param>
        /// <remarks>
        ///  The cloning of <see cref="SqlParameter"/> is required so that when we make calls against a set of databases
        ///  with the same parameter values. ADO.NET requires unique instances 
        ///  within a collection of parameters in order to maintain unique states.
        /// </remarks>
        static private void FillInProcedureParameters( 
            IDataParameterCollection paramCollection, 
            IDataParameter[] masterParamList) 
        {
            // TODO: Is there a better way than this exhaustive add of parameters?
            for (int i = 0; i < masterParamList.Length; ++i)
            {
                 paramCollection.Add(masterParamList[i]);
            }

            // Add special parameter for the 'retval' from procedure call
            SqlParameter retvalParam = new SqlParameter();
            retvalParam.Direction = ParameterDirection.ReturnValue;
            retvalParam.SqlDbType = SqlDbType.Int;
            paramCollection.Add(retvalParam);
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Given a list of parameters, find the return value and returns the
        /// value of that parameter.
        /// </summary>
        /// <param name="context">The DataStoreContext</param>
        /// <returns>The value of the SQL return parameter</returns>
        public static int GetReturnValue(DataStoreContext context)
        {
            if (context != null && context.Command != null)
            {
                return GetReturnValue(context.Command.Parameters);
            }

            return ProcedureResults.InvalidProcedureReturnValue;
        } // GetReturnValue        

        //---------------------------------------------------------------------
        /// <summary>
        /// Given a list of parameters, find the return value and returns the
        /// value of that parameter.
        /// </summary>
        /// <param name="paramList"></param>
        /// <returns>The value of the SQL return parameter</returns>
        public static int GetReturnValue(IDataParameterCollection paramList)
        {
            // TODO: Optimize the following linear search
            // TODO: Won't it be sufficient to just fetch 
            //    the last parameter in the cmd.Parameters collection?
            foreach (IDataParameter param in paramList) 
            {
                if (param.Direction == ParameterDirection.ReturnValue && param.Value != null) 
                {
                    return (int)(param.Value);
                }    
            }

            return ProcedureResults.InvalidProcedureReturnValue;
        } // GetReturnValue

        //---------------------------------------------------------------------
        /// <summary>
        /// Helper function to execute the supplied SQL Command and fetch 
        /// results of the call.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">
        /// The connection manager object that created the command.
        /// </param>
        /// <param name="cmd">
        /// SQL command object with stored procedure and parameters for 
        /// execution.
        /// </param>
        static private ProcedureResults ExecuteCommandAndFetchResults(DataStoreContext context, ISpilConnectionManager scm, IDbCommand cmd) 
        {
            // TODO: Isn't SqlReader a better method for this fwd R/O dataset caching?
            IDataAdapter da = scm.GetDataAdapterForCommand(cmd);
            DataSet ds = new DataSet();

            // FXCOP: Set the locale to invariant as mandated by FxCOP
            ds.Locale = System.Globalization.CultureInfo.InvariantCulture;
            ProcedureResults procedureResults = null;
            int returnValue = 0;
            try 
            {
                context.StartQuery();
                da.Fill(ds);
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                returnValue = GetReturnValue(cmd.Parameters);
                procedureResults = new ProcedureResults(returnValue, ds);
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), procedureResults, sqle);
            }
            catch( Exception e) 
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                returnValue = GetReturnValue(cmd.Parameters);
                procedureResults = new ProcedureResults(returnValue, ds);
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, procedureResults, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            procedureResults = new ProcedureResults(returnValue, ds);

            return procedureResults;
        }

        /// <summary>
        /// Helper function to execute the supplied WST Command and fetch results of the call
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="cmd">The command to execute</param>
        /// <param name="scm">The connection manager</param>
        static private ProcedureResults ExecuteWstCommandAndFetchResults(DataStoreContext context, ISpilConnectionManager scm, WstCommand cmd) 
        {
            int retVal = ProcedureResults.InvalidProcedureReturnValue;
            // TODO: Isn't SqlReader a better method for this fwd R/O dataset caching?
            WstDataAdapter da = new WstDataAdapter();
            da.SelectCommand = cmd;
            
            //cmd.Connection.Open();
            DataSet ds = new DataSet();

            // FXCOP: Set the locale to invariant as mandated by FxCOP
            ds.Locale = System.Globalization.CultureInfo.InvariantCulture;
            ProcedureResults procedureResults = null;
            try 
            {
                context.StartQuery();
                da.Fill( ds);
                context.EndQuery();
                retVal = GetReturnValue(cmd.Parameters);
            }
            catch( Exception e) 
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( e.Message, "SPIL");
                retVal = GetReturnValue(cmd.Parameters);
                context.LastReturnValue = retVal;
                procedureResults = new ProcedureResults(retVal, ds);
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, procedureResults, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = retVal;
                scm.ReturnValue = retVal;
            }

            // retrieve return value from command object
            // TODO: Optimize the following linear search
            // TODO: Won't it be sufficient to just fetch 
            //    the last parameter in the cmd.Parameters collection?
            procedureResults = new ProcedureResults(retVal, ds);

            return procedureResults;
        }

        /// <summary>
        /// Internal utility function to make a clone of a SqlParameter array
        /// </summary>
        /// <param name="masterParamList">The sql parameter array to be copied</param>
        /// <returns>The new array containing the same copy of sqlparameters</returns>
        static private SqlParameter[] CloneParameterList(SqlParameter[] masterParamList)
        {
            SqlParameter[] newParamList = new SqlParameter[masterParamList.Length];
            for( int i = 0; i < masterParamList.Length; i++)
            {
                SqlParameter newParam = 
                    new SqlParameter( masterParamList[i].ParameterName,
                    masterParamList[i].SqlDbType);
                newParam.Value       = masterParamList[i].Value;
                newParam.IsNullable  = masterParamList[i].IsNullable;
                newParam.Direction   = masterParamList[i].Direction;
                newParamList[i] = newParam;
            }
            return newParamList;
        }

    } // class DataStoreComponent

   
    /// <summary>
    /// DataStoreException
    /// o Custom exception class that captures errors for 
    ///  stored procedure calls to the datastore calls.
    /// </summary>
    [Serializable()]
    public sealed class DataStoreException: ApplicationException 
    {

        ProcedureResults procedureResults = null;

        /// <summary>
        /// stores the procedure results when an exception is thrown.
        /// The exception handler can get the results from this property.
        /// </summary>
        public ProcedureResults ProcedureResults 
        {
            get { return  procedureResults; }
            set { procedureResults = value; }
        }

        /// <summary>
        /// default constructor for DataStoreException
        /// </summary>
        public DataStoreException()
            : base() {}

        /// <summary>
        /// constructor for DataStoreException that accepts a string message
        /// </summary>
        /// <param name="message">exception message</param>
        public DataStoreException( string message)
            : base( message) {}

        /// <summary>
        /// constructor for DataStoreException that accepts a procedure results
        /// </summary>
        /// <param name="procedureResults">the procedure results for the particular query</param>
        public DataStoreException(ProcedureResults procedureResults)
            : base()
        {
            this.procedureResults = procedureResults;
        }

        /// <summary>
        /// constructor for DataStoreException that accepts a procedure results and an inner exception
        /// </summary>
        /// <param name="procedureResults">the procedure results for the particular query</param>
        /// <param name="innerException">inner exception</param>
        /// <param name="message">exception message</param> 
        public DataStoreException(string message, ProcedureResults procedureResults, Exception innerException)
            : base( message, innerException)
        {
            this.procedureResults = procedureResults;
        }
        /// <summary>
        /// constructor for DataStoreException that accepts a string message and innerException
        /// </summary>
        /// <param name="message">exception message</param>
        /// <param name="innerException"></param>
        public DataStoreException( string message, Exception innerException) 
            : base( message, innerException) {}
        
        /// <summary>
        /// constructor for DataStoreException that supports serialization
        /// </summary>
        /// <param name="sinfo"></param>
        /// <param name="scontext"></param>
        internal DataStoreException( System.Runtime.Serialization.SerializationInfo sinfo, System.Runtime.Serialization.StreamingContext scontext)
            : base( sinfo, scontext) {}
    }

    /// <summary>
    /// class ProcedureResults
    /// o  Encapsulates return results for a stored procedure calls 
    ///  done using the DataStoreComponent (or its derivative)
    ///  
    ///  Usually an instance is created after successful execution of 
    ///   a stored procedure. A failure to execute stored procedure will
    ///   usually throw an exception and return null value for ProcedureResults.
    ///  
    ///  Notes: This does not keep track of "what" stored procedure executed 
    ///   and "what" were the input values. I believe those belong within
    ///   the ProcedureCallContext and is not required.
    /// </summary>
    public class ProcedureResults 
    {

        /// <summary>
        /// Specifies the value for errored stored procedure return value
        /// </summary>
        public const int InvalidProcedureReturnValue = -1;

        internal bool      fExecutionDone = false;
        internal int       procReturnValue = 0;     // the integer return value from call
        internal DataSet   dsResults = null;

        /// <summary>
        /// Creates an empty ProcedureResults instance.
        /// The results will be marked with execution NOT done and no results.
        /// </summary>
        public ProcedureResults() {}


        /// <summary>
        /// Creates a new ProcedureResults with the supplied return value and dataset
        /// </summary>
        /// <param name="retVal">return value from stored procedure. 
        ///     interpretation of the value is subject to individual stored procedures
        /// </param>
        /// <param name="results">DataSet returned as a result of executing stored procedure</param>
        public ProcedureResults( int retVal, DataSet results) 
        {
            SetResults( retVal, results);
        }

        /// <summary>
        /// Stores the results provided none is already stored.
        /// </summary>
        /// <param name="results">new set of results to be stored</param>
        /// <param name="retVal">return value from stored procedure.</param>
        [MethodImpl( MethodImplOptions.Synchronized)]
        private void SetResults( int retVal, DataSet results) 
        {
            if ( fExecutionDone) 
                throw new DataStoreException( "Already results are stored from a previous execution. Cannot store duplicate results.");
            fExecutionDone = true;
            dsResults = results;
            procReturnValue = retVal;
        }

        /// <summary>
        /// Method returned value - interpretation is subject to specific stored procedure executed.
        /// </summary>
        public int ReturnValue 
        {
            get { return procReturnValue; }
        }

        /// <summary>
        /// Returns the results in the form of a DataSet
        /// Returned values are organized in whatever form 
        ///     the stored procedure had returned them.
        /// No attempt is made to parse out data from this DataSet!
        /// </summary>
        public DataSet  Results 
        {
            get 
            { 
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");
                return dsResults;
            }
        }

        /// <summary>
        /// Returns the results as an XML structure using the standard DataSet to XML conversion.
        /// NOTE: for most part the caller should be pretty happy with the returned DataSet
        /// </summary>
        public string ResultsXml 
        {
            get 
            { 
                // Implements default XML Transformation of result set
                return this.Results.GetXml(); 
            }
        }

        /// <summary>
        /// Returns the results as an XML Document object.
        /// NOTE: This dynamically creates the XML Document object by linearizing
        ///  the data set into an XML document. Hence getting this value can be 
        ///  inefficient compared to the "Results" property fetch.
        /// </summary>
        public XmlDocument ResultsXmlDocument 
        {
            get 
            {
                // The only way to create a DOM for the results xml 
                //  is by loading the results XML string into a DOM.
                //  TODO: Is there a more efficient way?
                XmlDocument xd = new XmlDocument();
                xd.LoadXml( this.ResultsXml);
                return xd;
            }
        }

        /// <summary>
        /// Returns the results as an XMLDataDocument object.
        /// NOTE: This creates an XmlDataDocument directly from the data set. Any changes
        /// made to this XmlDataDocument will be reflectd in the data set as well.
        /// An exception is thrown if the execution is not done or results are null.
        /// </summary>
        public XmlDataDocument ResultsXmlDataDocument 
        {
            get 
            {
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");

                XmlDataDocument xdd = new XmlDataDocument( dsResults);
                return xdd;
            }
        }

        /// <summary>
        /// Returns the results as an XmlPathNavigator object.
        /// NOTE: This creates an XPathNavigator object directly from the data set. This
        /// property provides read-only random-access to the data set. It can also be used
        /// to perform XSL Transform efficiently.
        /// An exception is thrown if the execution is not done or results are null.
        /// </summary>
        public XPathNavigator ResultsXmlNavigator
        {
            get
            {
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");

                XmlDataDocument xdd = new XmlDataDocument( dsResults);
                return xdd.CreateNavigator();
            }
        }

        /// <summary>
        /// Merges the supplied array of ProcedureResults to produce a single
        ///  ProcedureResults object.
        /// </summary>
        /// <param name="allResults">array of ProcedureResults containing results
        /// from executing a method on ALL database instances.</param>
        /// <returns>single ProcedureResults object containing the summary of method execution</returns>
        static public ProcedureResults MergeResults( ProcedureResults[] allResults) 
        {
            
            if( allResults.Length > 0)
            {
                ProcedureResults prAll = allResults[0];
                for(int i = 1; i < allResults.Length; i ++)
                {
                    prAll.Results.Merge(allResults[i].Results);
                }
                return prAll;
            }
            return null;
        }
    } // class ProcedureResults
} // namespace Microsoft.Subscriptions.Data
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\Assertion.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for Assertion.
	/// </summary>
	public class DbAssertion
	{
		private DbAssertion()
		{
			
		}

		/// <summary>
		/// Assert the data is DBNull
		/// </summary>
		/// <param name="value"></param>
		public static void AssertDbNull(object value)
		{
			if (!(value is INullable) || !((INullable)value).IsNull)
			{
				throw new DbAssertionException(String.Format("Data is not null. Expected: Null, Actual: {0}", 
					value.ToString()));
			}
	}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="filter"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		/// <param name="databaseName"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatabaseEquals(string fileName, string filter, string databaseName, string connectionString, ISpilConnectionManager scm, bool strictCompare)
		{
			SqlCommand command = new SqlCommand(filter, (SqlConnection)scm.GetConnection(databaseName, connectionString, 0));
			IDataAdapter adapter = scm.GetDataAdapterForCommand(command);
			DataSet ds = new DataSet();
			adapter.Fill(ds);
			AssertDatasetEqualsFile(fileName, "xml", ds, strictCompare);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="filter"></param>
        /// <param name="scm"></param>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="strictCompare"></param>
        public static void AssertDatabaseEqualsXml(string xml, string filter, string databaseName, string connectionString, ISpilConnectionManager scm, bool strictCompare)
        {
            SqlCommand command = new SqlCommand(filter, (SqlConnection)scm.GetConnection(databaseName, connectionString, 0));
            IDataAdapter adapter = scm.GetDataAdapterForCommand(command);
            DataSet ds = new DataSet();
            adapter.Fill(ds);
            AssertDatasetEqualsXml(xml, ds, strictCompare);
        }
		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsFile(string fileName, DataSet ds)
		{
			DataSet expected = new DataSet(); //ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsXml(string xml, DataSet ds)
		{
			DataSet expected = ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromString(expected, xml);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="ds"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEqualsXml(string xml, DataSet ds, bool strictCompare)
		{
			DataSet expected = ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromString(expected, xml);
			AssertDatasetEquals(expected, ds, strictCompare);
		}

		
		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="fileType"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsFile(string fileName, string fileType, DataSet ds)
		{
			DataSet expected = ds.Clone(); // here we have to use clone
			IFileConverter converter = GetConverterFromType(fileType);
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="fileType"></param>
		/// <param name="ds"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEqualsFile(string fileName, string fileType, DataSet ds, bool strictCompare)
		{
			DataSet expected = ds.Clone(); // here we have to use clone
			IFileConverter converter = GetConverterFromType(fileType);
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, strictCompare);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="expected"></param>
		/// <param name="actual"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEquals(DataSet expected, DataSet actual, bool strictCompare)
		{
			if (strictCompare && expected.Tables.Count != actual.Tables.Count)
			{
				throw new DbAssertionException(String.Format("DataSet has different table counts. Expected: {0}, Actual: {1}", expected.Tables.Count, actual.Tables.Count));
			}
			for(int i = 0; i < expected.Tables.Count; i ++)
			{
				DataTable expectedTable = expected.Tables[i];
				DataTable actualTable = actual.Tables[expectedTable.TableName];
				if (actualTable == null)
				{
					throw new DbAssertionException("Cannot find table. Expected: " + expectedTable.TableName);
				}
				AssertDataTableEquals(expectedTable, actualTable, strictCompare);
			}
		}
			
		/// <summary>
		/// 
		/// </summary>
		/// <param name="expected"></param>
		/// <param name="actual"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDataTableEquals(DataTable expected, DataTable actual, bool strictCompare)
		{
			if (strictCompare && expected.Rows.Count != actual.Rows.Count)
			{
				throw new DbAssertionException(String.Format("{0} has different row counts. Expected: {1}, Actual: {2}", expected.TableName, expected.Rows.Count, actual.Rows.Count));
			}
			if (strictCompare && expected.Columns.Count != actual.Columns.Count)
			{
				throw new DbAssertionException(String.Format("{0} has different column counts. Expected: {1}, Actual: {2}", expected.TableName, expected.Columns.Count, actual.Columns.Count));
			}
			for(int i = 0; i < expected.Rows.Count; i ++)
			{
				DataRow expectedRow = expected.Rows[i];
				DataRow actualRow = actual.Rows[i];

				for(int j = 0; j < expected.Columns.Count; j ++)
				{
					string columnName = expected.Columns[j].ColumnName;
					if(expectedRow[j].ToString() != "" && expectedRow[j].ToString().ToLower() != actualRow[columnName].ToString().ToLower())
					{
						throw new DbAssertionException(String.Format("DataSet is different at {0}[Row {1}]. Expected: {2}, Actual: {3}",
							expected.TableName, i, expectedRow[j].ToString(), actualRow[j].ToString()));
					}
				}
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileType"></param>
		/// <returns></returns>
		internal static IFileConverter GetConverterFromType(string fileType)
		{
			if (fileType == "xml")
			{
				return new XmlFileConverter();
			}
			else if (fileType == "csv")
			{
				return new CsvFileConverter();
			}
			else if (fileType == "excel")
			{
				return new ExcelFileConverter();
			}
			else
			{
				throw new DbAssertionException("Cannot find converter for input file type :" + fileType);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\DataLoader.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for DataLoader.
	/// </summary>
	public class DataLoader
	{
		private DataLoader()
		{
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="database"></param>
		/// <param name="sql"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		public static void LoadSql(string database, string sql, ISpilConnectionManager scm, string connectionString)
		{
			SqlConnection conn = (SqlConnection)scm.GetConnection(database, connectionString, 0);
				SqlCommand cmd = new SqlCommand(sql, conn);
				cmd.CommandType = CommandType.Text;
				cmd.ExecuteNonQuery();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="database"></param>
		/// <param name="tableName"></param>
		/// <param name="fileName"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		public static void LoadFile(string database, string tableName, string fileName, ISpilConnectionManager scm, string connectionString)
		{
			// load xml from file
			DataSet ds = new DataSet();
			ds.ReadXml(fileName, XmlReadMode.InferSchema);
			if (ds.Tables.Count != 1)
			{
				throw new DbAssertionException("Load file failed during setup. Table count is more than 1 in Xml data file");
			}
			DataTable dt = ds.Tables[0];
			StringBuilder sb = new StringBuilder();
			sb.AppendFormat("insert into [{0}] (", tableName);
			// Iterate the datatable columns
			for(int i = 0; i < dt.Columns.Count; i++)
			{
				// Add the column name
				sb.Append(dt.Columns[i].ColumnName);
				if (i != dt.Columns.Count - 1)
					sb.Append(" ,");
			}
			sb.Append(") values (");
			string header = sb.ToString();
			SqlConnection conn = (SqlConnection)scm.GetConnection(database, connectionString, 0);
			// Iterate rows in the dataset
			foreach(DataRow dr in dt.Rows)
			{
				// Create the sql insert command for each row
				sb = new StringBuilder(header);
			
				// Iterate the datatable columns
				for(int i = 0; i < dt.Columns.Count; i++)
				{
					// Add the column value for this row
					sb.Append("'").Append(dr[i].ToString().Replace("'","''")).Append("'");
					if (i != dt.Columns.Count - 1)
						sb.Append(" ,");
				}
				sb.Append(")");
				Console.WriteLine(sb.ToString());
				// Create and execute the insert command
				SqlCommand cmd = new SqlCommand(sb.ToString(), conn);
				cmd.CommandType = CommandType.Text;
				cmd.ExecuteNonQuery();
			}	
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="bcp"></param>
		public static void LoadBcp(string bcp)
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\DataStoreContext.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// DataStoreContext exposes run time information about the current running 
    /// query.
    /// </summary>
    public sealed class DataStoreContext
    {
        // event set
        private EventHandlerSet eventSet = new EventHandlerSet();
        
        // because c# doesn't allow us to have different access permissions for getter and setter
        // we have to set the variable as internal so it can be set internally
        internal IDbCommand command;
        internal IDbConnection connection;
        private int lastReturnValue;

        #region DataStoreTraceEvent
        /// <summary>
        /// Type definining the prototype of the callback method that receivers must implement
        /// </summary>
        public delegate void DataStoreTraceEventHandler(object sender, DataStoreTraceEventArgs e);

        /// <summary>
        /// Type definining the call back method that receivers must implement
        /// </summary>
        public event DataStoreTraceEventHandler OnTraceMessage;

        private void TraceMessage(DataStoreTraceEventArgs e)
        {
            if (OnTraceMessage != null)
            {
                OnTraceMessage(this, e);
            }
        }

        internal void SqlInfo(object sender, SqlInfoMessageEventArgs e)
        {
            // trace the information
            Trace(TraceLevel.Info, e.Message, e.Source);
        }

        /// <summary>
        /// Trace a message and notify all receivers
        /// </summary>
        /// <param name="level">The trace level</param>
        /// <param name="message">The trace message</param>
        /// <param name="source">The source object of the trace message</param>
        internal void Trace(TraceLevel level, string message, string source)
        {
            DataStoreTraceEventArgs e = new DataStoreTraceEventArgs(level, message, source);
            TraceMessage(e);
        }
        #endregion

        #region QueryEndEvent
        private static readonly Object queryEndEventKey = new object();
        /// <summary>
        /// Query End Arguments
        /// </summary>
        public class QueryEndEventArgs : EventArgs {}
        /// <summary>
        /// type defining handler for Query End Event
        /// </summary>
        public delegate void QueryEndEventHandler(object sender, QueryEndEventArgs e);

        /// <summary>
        /// event for query end
        /// </summary>
        public event QueryEndEventHandler OnQueryEnd
        {
            add { eventSet.AddHandler(queryEndEventKey, value);}
            remove {eventSet.RemoveHandler(queryEndEventKey, value);}
        }
        private void QueryEnd(QueryEndEventArgs e)
        {
            eventSet.Fire(queryEndEventKey, this, e);
        }
        internal void EndQuery()
        {
            QueryEnd(new QueryEndEventArgs());
        }
        #endregion

        #region QueryStartEvent
        private static readonly Object queryStartEventKey = new object();
        /// <summary>
        /// type defining arguments for query start
        /// </summary>
        public class QueryStartEventArgs : EventArgs {}
        /// <summary>
        /// type defining delegates for query start
        /// </summary>
        public delegate void QueryStartEventHandler(object sender, QueryStartEventArgs e);
        /// <summary>
        /// type definining query start event handler
        /// </summary>
        public event QueryStartEventHandler OnQueryStart 
        {
            add { eventSet.AddHandler(queryStartEventKey, value);}
            remove {eventSet.RemoveHandler(queryStartEventKey, value);}
        }
        private void QueryStart(QueryStartEventArgs e)
        {
            eventSet.Fire(queryStartEventKey, this, e);
        }
        internal void StartQuery()
        {
            QueryStart(new QueryStartEventArgs());
        }
        #endregion

        /// <summary>
        /// Gets the current command. The command object is not thread-safe.
        /// </summary>
        public IDbCommand Command
        {
            get { return command;}
        }

        /// <summary>
        /// Gets the current connection. The connection object is not thread-safe.
        /// </summary>
        public IDbConnection Connection
        {
            get { return connection; }
        }

        /// <summary>
        /// Gets or sets the last return value
        /// </summary>
        public int LastReturnValue
        {
            get { return this.lastReturnValue; }
            set { this.lastReturnValue = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\EventHandlerSet.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Runtime.CompilerServices;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for EventHandlerSet.
	/// </summary>
	public class EventHandlerSet : IDisposable
	{
        private Hashtable events = new Hashtable();
		
        /// <summary>
        /// An index property that gets or sets the delegate associated with the hash key
        /// </summary>
        public virtual Delegate this[Object eventKey]
        {
            get { return (Delegate) events[eventKey]; }
            set { events[eventKey] = value; }
        }

        /// <summary>
        /// Add a delegate for the indicated event with given hash key
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="handler"></param>
        public virtual void AddHandler(Object eventKey, Delegate handler)
        {
            events[eventKey] = Delegate.Combine((Delegate) events[eventKey], handler);
        }

        /// <summary>
        /// Removes a delegate for the indicated event with given hash key
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="handler"></param>
        public virtual void RemoveHandler(Object eventKey, Delegate handler)
        {
            events[eventKey] = Delegate.Remove((Delegate) events[eventKey], handler);
        }

        /// <summary>
        /// Fire the event
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void Fire(Object eventKey, Object sender, EventArgs e)
        {
            Delegate d = (Delegate) events[eventKey];
            if (d!=null) d.DynamicInvoke(new Object[]{sender, e});
        }

        /// <summary>
        /// Synchronized version
        /// </summary>
        /// <param name="eventHandlerSet"></param>
        /// <returns></returns>
        public static EventHandlerSet Synchronized(EventHandlerSet eventHandlerSet)
        {
            if (eventHandlerSet == null)
            {
                throw new ArgumentNullException("eventHandlerSet");
            }
            return new SynchronizedEventHandlerSet(eventHandlerSet);
        }
        
        private class SynchronizedEventHandlerSet : EventHandlerSet
        {
            private EventHandlerSet eventHandlerSet;

            public SynchronizedEventHandlerSet(EventHandlerSet eventHandlerSet)
            {
                this.eventHandlerSet = eventHandlerSet;
                Dispose(); // let the base type's hash table object be freed
            }

            public override Delegate this[Object eventKey]
            {
                [MethodImpl(MethodImplOptions.Synchronized)]
                get { return eventHandlerSet[eventKey];}
                [MethodImpl(MethodImplOptions.Synchronized)]
                set { eventHandlerSet[eventKey] = value;}
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void AddHandler(Object eventKey, Delegate handler)
            {
                eventHandlerSet.AddHandler(eventKey, handler);
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void RemoveHandler(Object eventKey, Delegate handler)
            {
                eventHandlerSet.RemoveHandler(eventKey, handler);
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void Fire(Object eventKey, Object sender, EventArgs e)
            {
                eventHandlerSet.Fire(eventKey, sender, e);
            }
        }

        #region IDisposable Members

        /// <summary>
        /// Disposing the object
        /// </summary>
        public void Dispose()
        {
            events = null;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\IDataStore.cs ===
using System;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Interface for generated data caller
	/// </summary>
	public interface IDataStore
	{
        /// <summary>
        /// Gets the current <see cref="DataStoreContext"/>
        /// </summary>
        DataStoreContext Context {get;}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\IFileConverter.cs ===
using System;
using System.Data;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for IFileConverter.
	/// </summary>
	public interface IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="fileName"></param>
		void ReadFromFile(DataSet ds, string fileName);
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="input"></param>
		void ReadFromString(DataSet ds, string input);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\DataStoreInterfaces.cs ===
/*
 *  DataStoreInterfaces.cs
 * 
 *  Defines the interfaces required for any data store connection
 *  manager implementation. These Data store connection manager 
 *  interfaces support query and translation of virtual values 
 *  into required connection for the physical instance of database.
 * 
 * Revision History:
 *  Aug 2002    - MuraliK  - created initial version
 */
using System;
using System.Data;
using System.Collections;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// ISpilConnectionManager defines the interface that helps
    ///  to translate the supplied (databaseName, hashValue) into
    ///  a SQL connection object. Additional parameter of connectionString
    ///  is supplied to formulate the full connection string for a connection.
    ///  
    /// A partition aware object implementing this interface will do all it could
    ///  to use the partition id and fetch the right Sql connection.
    /// 
    /// A non-partition aware object implementing this interface may ignore
    ///  the partition id and return connection based on predefined heuristics.
    ///  
    /// In addition the object implementing this interface may also maintain a 
    ///  stateful local cache of connections associated with the object's context.
    ///  This provides a means for transactions to utilize the same connection
    ///   for the same (databaseName, hashValue) combo.
    /// 
    /// </summary>
    public interface ISpilConnectionManager : IDisposable{

        /// <summary>
        /// Provides a SQL connection based on supplied parameters.
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database.
        /// The value of DataStoreComponent.HashValueForAnyInstance (-1) is reserved to indicate ANY partition.
        /// </param>
        /// <returns></returns>
        IDbConnection GetConnection( string databaseName, string connectionString, int hashValue);

        /// <summary>
        /// Provides an array of SQL connections for the 
        ///  the individual physical partitions of a single database resource
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns></returns>
        IDbConnection[] GetAllConnections( string databaseName, string connectionString);

        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// The caller should call at the end of sequence of calls.
        /// Not doing such proactive means:
        ///  - connections will be drained from the connection pool 
        ///  - big memory commitment
        ///  - the system has to wait for garbage collector to search
        ///   and free the connections.
        ///  So it is best that the caller call this function proactively
        /// </summary>
        void CloseConnections();

        /// <summary>
        /// Gets the physical partition id corresponding to the logical partition id.
        /// The physical instance id can be of any type so an object is returned by this function.
        /// In most cases, it will be an integer such as physical partition number.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="hashValue">the logical partition id</param>
        /// <returns>the physical partition id</returns>
        object GetPhysicalInstanceId( string storeName, int hashValue);

        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical Webstore application</param>
        /// <returns>a collection object consisting of a "cookie" data or handle or key
        ///  to identify the distinct physical instances</returns>
        object[] GetAllPhysicalInstances( string logicalStoreName);

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        ///  returns a connection object for accessing the specific database.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical WebStore application</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceKey">Key (or cookie data) for specifying the target physical instance.
        ///  The caller cannot fabricate these values. The values passed in here should have obtained from 
        ///  a prior call to the GetAllPhysicalInstances()
        /// </param>
        /// <returns>an interface to the database connection object</returns>
        IDbConnection GetConnectionForPhysicalInstance( string logicalStoreName, string connectionString, object physicalInstanceKey); 

        //---------------------------------------------------------------------
        /// <summary>
        /// Provides a command object for the connection created with the given
        /// parameters.  Using this function rather than the GetCommand() 
        /// function of the connection object will ensure that the command will
        /// utilize any transactional support, or other features, provided by
        /// the connection manager object.
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database.
        /// The value of DataStoreComponent.HashValueForAnyInstance (-1) is reserved to indicate ANY partition.
        /// </param>
        /// <returns>an interface to the database command object</returns>
        IDbCommand GetCommand(string databaseName, string connectionString, int hashValue);

        //---------------------------------------------------------------------
        /// <summary>
        /// Given the (logical database, physical instance id/key) this 
        /// function returns a command object for the specified connection.
        /// Using this function rather than the GetCommand() function of the 
        /// connection object will ensure that the command will utilize any 
        /// transactional support, or other features, provided by the 
        /// connection manager object.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical WebStore application</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceKey">Key (or cookie data) for specifying the target physical instance.
        ///  The caller cannot fabricate these values. The values passed in here should have obtained from 
        ///  a prior call to the GetAllPhysicalInstances()
        /// </param>
        /// <returns>an interface to the database command object</returns>
        IDbCommand GetCommandForPhysicalInstance( string logicalStoreName, string connectionString, object physicalInstanceKey); 

        /// <summary>
        /// Gets the timeout value(in seconds) for the connection. All
        /// connections in a connection manager share the same timeout value.
        /// </summary>
        int ConnectionTimeOut {get;}  

        /// <summary>
        /// Gets or sets the timeout value(in seconds) for the command. All
        /// commands in a connection manager share the same timeout value.
        /// </summary>
        int CommandTimeOut {get; set;}

        /// <summary>
        /// Gets or sets the return value for the command. This value is only set when the query
        /// has completed. Otherwise its value equals to <see cref="ProcedureResults.InvalidProcedureReturnValue"/>
        /// </summary>
        int ReturnValue { get; set; }
        //---------------------------------------------------------------------
        /// <summary>
        /// Creates an appropriate data adapter object for the types of 
        /// connections managed by the connection manager object.
        /// </summary>
        IDataAdapter GetDataAdapterForCommand(IDbCommand cmd);

    } // interface ISpilConnectionManager

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\ExcelFileConverter.cs ===
using System;
using System.Data;
using System.Data.OleDb;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Convert an Excel file to <see cref="DataSet"/>
	/// </summary>
	public class ExcelFileConverter : IFileConverter
	{

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="filePath"></param>
		public void ReadFromFile(DataSet ds, string filePath)
		{
			string pathName = Path.GetDirectoryName(filePath);
			string fileName = Path.GetFileName(filePath);
			int workSheetNumber = 0; // use default 
			using(OleDbConnection excelConnection = new OleDbConnection(@"Provider=Microsoft.Jet.OLEDB.4.0;Data Source="+pathName+@"\"+fileName+";Extended Properties=Excel 8.0;"))
			{
				OleDbCommand excelCommand = new OleDbCommand();
				excelCommand.Connection = excelConnection;
				OleDbDataAdapter excelAdapter = new OleDbDataAdapter(excelCommand);

				excelConnection.Open();
				DataTable excelSheets = excelConnection.GetOleDbSchemaTable(System.Data.OleDb.OleDbSchemaGuid.Tables,new object[] {null, null, null, "TABLE"});
				string SpreadSheetName = "["+excelSheets.Rows[workSheetNumber]["TABLE_NAME"].ToString()+"]";

				excelCommand.CommandText = @"SELECT * FROM "+SpreadSheetName;
				excelAdapter.Fill(ds);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			throw new NotSupportedException("csv string is not supported.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\DataStoreTraceEventArgs.cs ===
using System;
using System.Diagnostics;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Type defining information passed to the receiver of trace message
	/// </summary>
	[Serializable]
	public class DataStoreTraceEventArgs : EventArgs
	{
        /// <summary>
        /// Constructor. Create a trace event argument with designated trace level and message
        /// </summary>
        /// <param name="level"></param>
        /// <param name="message"></param>
        /// <param name="source"></param>
        public DataStoreTraceEventArgs(TraceLevel level, string message, string source)
		{
		    this.TraceLevel = level;
	        this.Message = message;
		}

        /// <summary>
        /// Get the trace level of this message
        /// </summary>
        public readonly TraceLevel TraceLevel;
        /// <summary>
        /// Get the content of the message
        /// </summary>
        public readonly string Message;
        /// <summary>
        /// Get the source object of the event
        /// </summary>
        public readonly string Source;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__spilrun_4_none_12.4.56.0_none_c07d660cfcb443ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_spilrun_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.manifest
XP_MANIFEST_PATH=manifests\x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.cat
XP_CATALOG_PATH=manifests\x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.cat
XP_PAYLOAD_PATH=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_spilrun_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__spilrun_4_none_12.4.56.0_none_c07d660cfcb443ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_spilrun_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.manifest
XP_MANIFEST_PATH=manifests\x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.cat
XP_CATALOG_PATH=manifests\x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7.cat
XP_PAYLOAD_PATH=x86__spilrun_4_no-public-key_12.4.56.0_x-ww_11f724b7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_spilrun_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\SimpleConnectionManager.cs ===
/*
 *  SimpleConnectionManager.cs
 * 
 *  This class is an implementation of ISpilConnectionManager 
 *  using ADO.NET. 
 *  SimpleConnectionManager only manages one physical server for a logical database. 
 * 
 * Revision History:
 *  Dec 2002    - TaoH   - added IDisposable interface support
 *  Sep 2002    - TaoH   - added GetPhysicalInstanceId
 *  Aug 2002    - Muralik - created.
 */
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;

namespace Microsoft.Subscriptions.Data {

    /// <summary>
    /// Provides a simple connection manager for use 
    ///  with a single physical instance of logical database.
    /// This object inherits from <see cref="ConnectionManagerBase"/> and 
    ///  supports method to translate logical (databaseName, partitionId) 
    ///  into SqlConnection object.
    /// This object implements the IDisposable interface so the users of this
    /// class can dispose the resources it uses.
    /// 
    /// No connection caching is done, although underlying ADO.NET does 
    ///  connection pooling for the connections with same connectionString
    /// NOTE: The class as a whole is NOT multi-thread safe. It is intended
    ///  that the instance of each class is used completely within a single 
    ///  thread and hence no multi-thread protection is built. However, 
    ///  different instances can be used within different threads.
    /// </summary>
    public class SimpleConnectionManager : ConnectionManagerBase
    {

        internal class CachedConnectionItem {
            internal string databaseName;
            internal string partialConnectionString;
            internal SqlConnection sqlConn;

            internal CachedConnectionItem( string databaseName, string connString, SqlConnection conn) {
                this.databaseName = databaseName;
                this.partialConnectionString = connString;
                this.sqlConn = conn;
            }
        }

        internal class CachedConnectionList {

            // TODO: May be use a hash table
            private ArrayList cachedConnections = null; // array of CachedConnectionItems

            internal CachedConnectionList() {}

            internal SqlConnection FindConnection( string databaseName, string connString) {

                if ( cachedConnections == null)
                    return null;

                for( int i =0; i < cachedConnections.Count; i++) 
                {
                    CachedConnectionItem cci = cachedConnections[i] as CachedConnectionItem;
                    if (cci.databaseName == databaseName && cci.partialConnectionString == connString)
                    {
                        return cci.sqlConn;
                    }
                }

                return null;
            }

            /// <summary>
            /// Adds the provided connection combo to the lookup table.
            /// No duplicate checks are made.
            /// </summary>
            /// <param name="databaseName"></param>
            /// <param name="connString"></param>
            /// <param name="conn"></param>
            internal void AddConnection( string databaseName, string connString, SqlConnection conn) {
                if ( cachedConnections == null) 
                    cachedConnections = new ArrayList();

                CachedConnectionItem cci = new CachedConnectionItem( databaseName, connString, conn);
                cachedConnections.Add( cci);
            }

            internal void CloseConnections() {
                if ( cachedConnections != null) {
                    for(int i = 0; i < cachedConnections.Count; i++) {
                        CachedConnectionItem cci = cachedConnections[i] as CachedConnectionItem;
                        if (cci.sqlConn != null) {
                            TransactionWrapper.CloseConnection(cci.sqlConn);
                        }
                    }
                    // also remove the cached connections array
                    cachedConnections = null;
                }
            }

        } // class CachedConnectionList

        
        private string serverName = null;
        private CachedConnectionList cachedList = null;
        
        /// <summary>
        /// Construct a connection manager that talks to localhost
        /// </summary>
        public SimpleConnectionManager() {
            this.serverName = "localhost";
        }
        /// <summary>
        /// Construct a connection manager that talks to localhost
        /// </summary>
        /// <param name="connectionTimeOut">the connection timeout value in seconds
        /// </param>
        public SimpleConnectionManager(int connectionTimeOut) : this()
        {
            this.connTimeOut = connectionTimeOut;
        }

        /// <summary>
        /// Construct a connection manager that talks to specified server 
        /// </summary>
        /// <param name="serverName">the server name the connection manager is connected to</param>
        /// <param name="connectionTimeOut">the connection timeout value in seconds
        /// </param>
        public SimpleConnectionManager(string serverName, int connectionTimeOut) : this(serverName)
        {
            this.connTimeOut = connectionTimeOut;
        }

        /// <summary>
        /// Default finalizer, called when this object is garbage collected.
        /// </summary>
        ~SimpleConnectionManager()
        {
            Dispose(false);
        }
        /// <summary>
        /// Construct a connection manager that talks to specified server
        /// </summary>
        /// <param name="serverName"></param>
        public SimpleConnectionManager( string serverName) {
            this.serverName = serverName;
        }

        private SqlConnection GetCachedConnection( string databaseName, string connectionString) {
 
            SqlConnection conn = null;
            
            if ( cachedList == null) {
                cachedList = new CachedConnectionList();
            } else {
                conn = cachedList.FindConnection( databaseName, connectionString);
            }

            if ( conn == null) {

                // create a connection and cache it
                string fullConnectionString = (( this.serverName == null)? connectionString : 
                    "data source=" + this.serverName + ";" 
                    + "Initial Catalog=" + databaseName + ";"
                    + "Connect TimeOut=" + this.connTimeOut + ";"
                    + connectionString); 

                conn = TransactionWrapper.OpenConnection(fullConnectionString);
                
                // TODO: Throw an exception if there is no connection formed!
                cachedList.AddConnection( databaseName, connectionString, conn);
            }

            return conn;
        }

        #region interface ISpilConnectionManager
        /// <summary>
        /// Provides a SQL connection based on supplied parameters.
        /// Since we only have one server for all databases and logical partitions
        ///  this function just returns a single standard connection.
        ///  The hashValue supplied will be ignored completely.
        /// If a previous connection request was made and that connection was cached,
        ///  then the same connection will be returned!
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database</param>
        /// <returns></returns>
        public override IDbConnection GetConnection( string databaseName, string connectionString, int hashValue) {

            return GetCachedConnection( databaseName, connectionString);
        }


        /// <summary>
        /// Provides an array of SQL connections for the 
        ///  the individual physical partitions of a single database resource
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns></returns>
        public override IDbConnection[] GetAllConnections( string databaseName, string connectionString) {

            // since we are simple connection manager, we only have at most one physical partition.
            // just use the cached connection if any (or create new one and cache it)
            return new SqlConnection[] {
                        GetCachedConnection( databaseName, connectionString)
                    };
        }

        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// </summary>
        public override void CloseConnections() {
            if(cachedList != null)
            {
                cachedList.CloseConnections();
            }
        }

        /// <summary>
        /// Gets the physical instance id given a logical partition id
        /// </summary>
        /// <param name="storeName">name of the catalog</param>
        /// <param name="hashValue">logical partition id</param>
        /// <returns>physical instance id</returns>
        public override object GetPhysicalInstanceId( string storeName, int hashValue)
        {
            return 0;// since we have just one instance, always use 0;
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommand(string databaseName, string connectionString, int hashValue) 
        {

            IDbCommand command = this.GetCachedConnection(databaseName, connectionString).CreateCommand();
            TransactionWrapper.InitCommand(command);
            return command;
        } // GetCommand

        #endregion interface ISpilConnectionManager

        #region interface ISpilPhysicalConnectionManager
        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="logicalDatabaseName">name of the logical database</param>
        /// <returns>a collection object consisting of a set of physical instance IDs</returns>
        public override object[] GetAllPhysicalInstances( string logicalDatabaseName) {

            // since we have just one instance, just return an array with one entry in it.
            object[] physicalIDs = new object[1];
            physicalIDs[0] = 0;
            return physicalIDs;
        }

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        ///  returns a connection object for accessing the specific database.
        /// </summary>
        /// <param name="logicalDatabaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceId">ID or key for specifying the target physical instance</param>
        /// <returns>an interface to the database connection object</returns>
        public override IDbConnection GetConnectionForPhysicalInstance( string logicalDatabaseName, string connectionString, object physicalInstanceId) {

            int instanceId = (int ) physicalInstanceId;

            if ( instanceId == 0) {

                return GetCachedConnection( logicalDatabaseName, connectionString);
            }
            else
                throw new DataStoreException( "Invalid Physical instance ID supplied");
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommandForPhysicalInstance(string logicalDatabaseName, string connectionString, object physicalInstanceId) 
        {
            if (0 == (int)physicalInstanceId) 
            {
                IDbCommand command = this.GetCachedConnection(logicalDatabaseName, connectionString).CreateCommand();
                TransactionWrapper.InitCommand(command);
                return command;
            }

            throw new DataStoreException( "Invalid Physical instance ID supplied");
        } // GetCommandForPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDataAdapter GetDataAdapterForCommand(IDbCommand cmd)
        {
            return new SqlDataAdapter((SqlCommand)(cmd));
        } // GetDataAdapterForCommand

        #endregion interface ISpilPhysicalConnectionManager

        #region interface IDisposable
        /// <summary>
        /// This method should be called explicitly by the user to close the
        /// resources the connection manager uses.
        /// </summary>
        public override void Dispose()
        {
            // suppress the garbage collector clean up
            GC.SuppressFinalize(this);
            // Call the method that actually does the cleanup
            Dispose(true);
        }

        /// <summary>
        /// The common method that does the actual clean up. This method is protected
        /// because the connection manager can be inherited by other connection managers.
        /// </summary>
        /// <param name="disposing">the flag to indicate whether to dispose explicitly
        /// or by GC</param>
        protected void Dispose(bool disposing)
        {
            // need to synchronize the dispose
            lock(this)
            {
                if(disposing)
                {
                    //explicit clean up. It is safe here to dispose any objects
                    //referenced by this object.
                    CloseConnections();
                }
                //note: we cannot call CloseConnections here because by the time
                //the connection manager is GCed, we're not sure if the connection cache
                //and the connections are already GCed or not.
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\XmlFileConverter.cs ===
using System;
using System.Data;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for XmlFileConverter.
	/// </summary>
	public class XmlFileConverter : IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		public XmlFileConverter()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="fileName"></param>
		public void ReadFromFile(DataSet ds, string fileName)
		{
			// read a file into dataset
			ds.ReadXml(fileName, XmlReadMode.InferSchema);
			return;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			using(StringReader sr = new StringReader(xml))
			{
				ds.ReadXml(sr);
			}
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\WebStoreConnectionManager.cs ===
/*
 *  WebStoreConnectionManager.cs
 * 
 *  This class is an implementation of ISpilConnectionManager 
 *  using WebStore. 
 * 
 * 
 * Revision History:
 *  Dec 2002    - TaoH   - added IDisposable interface support
 *  Sep 2002    - TaoH   - created
 */
using System;
using System.Data;
using System.Collections;
using System.Data.SqlTypes;
using Microsoft.Webstore.WstClient;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// Provides a webstore connection manager for use 
    ///  with a webstore application.
    /// This object inherits from <see cref="ConnectionManagerBase"/> and 
    ///  supports method to translate logical (storeName, partitionId) 
    ///  into WstConnection object.
    /// This object implements the IDisposable interface so the users of this
    /// class can dispose the resources it uses.
    /// 
    /// The webstore connection is cached based on the storeName and the connection string
    /// This class is not thread-safe.
    /// </summary>
    public class WebStoreConnectionManager  : ConnectionManagerBase
    {
        // We cannot use SimpleConnectionManager.CachedConnectionItem
        // Because it only caches SqlConnection :-(
        // So we use a hashtable instead.
        /// <summary>
        /// Local connection cache.
        /// </summary>
        protected Hashtable connCache = new Hashtable();
        
        /// <summary>
        /// Default constructor
        /// </summary>
        public WebStoreConnectionManager()
        {
        }
        /// <summary>
        /// Construct a webstore connection manager
        /// </summary>
        public WebStoreConnectionManager(int connTimeOut)
        {
            this.connTimeOut = connTimeOut;
        }

        /// <summary>
        /// Default finalizer, called when this object is garbage collected.
        /// </summary>
        ~WebStoreConnectionManager()
        {
            Dispose(false);
        }

        

	    ///<summary>
	    ///Gets the Cached Connection based on Store Name and Connection String
	    ///</summary>
        protected IDbConnection GetCachedConnection( string storeName, string connectionString)
        {
            if(storeName == null)
                throw new DataStoreException(" store name cannot be null!");
            
            // build a key based on storeName 
            // connectionString is useless in WebStore connection
            string key = storeName.ToLower();
            WstConnection wstConn = connCache[key] as WstConnection;
            if(wstConn == null)
            {
                wstConn = TransactionWrapper.OpenConnection(storeName, typeof(WstConnection)) as WstConnection;
                connCache.Add(key, wstConn);
            }
            return wstConn;
        }

        #region interface ISpilConnectionManager
        /// <summary>
        /// Provides a WST connection based on supplied parameters.
        /// Since webstore handles the logical partitions at command level,
        ///  this function just returns a single webstore connection.
        ///  The hashValue supplied will be ignored completely.
        /// If a previous connection request was made and that connection was cached,
        ///  then the same connection will be returned!
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database</param>
        /// <returns>A webstore connection to the application</returns>
        public override IDbConnection GetConnection( string storeName, string connectionString, int hashValue) 
        {
            return GetCachedConnection( storeName, connectionString);
        }

        /// <summary>
        /// Returns webstore connections to an application as an array.
        /// Because webstore manages connection at the application level, only one connection is
        /// actually returned by this function. 
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns>A webstore connection to the application, packaged as an array for interface conformance.</returns>
        public override IDbConnection[] GetAllConnections( string storeName, string connectionString) 
        {
            return new IDbConnection[] {
                GetCachedConnection( storeName, connectionString)
            };
        }


        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// This method is not thread safe.
        /// </summary>
        public override void CloseConnections() 
        {
            if(connCache != null)
            {
                IDictionaryEnumerator ide = connCache.GetEnumerator();
                while(ide.MoveNext())
                {
                    WstConnection conn = ide.Value as WstConnection;
                    if(conn != null)
                        TransactionWrapper.CloseConnection(conn);
                }

                // also clear the connection cache
                connCache.Clear();
                // clear reference to connection cache
                connCache = null;
            }
        }

        /// <summary>
        /// Gets the physical instance id given a logical partition id and store name.
        /// </summary>
        /// <param name="storeName">name of the webstore application</param>
        /// <param name="hashValue">logical partition id</param>
        /// <returns>physical instance id corresponding to the logical hashValue</returns>
        public override object GetPhysicalInstanceId( string storeName, int hashValue)
        {
            WstConnection conn = GetCachedConnection(storeName, "") as WstConnection;
            //return conn.GetPhysicalPartition(hashValue);
            return conn.GetSqlPartition(hashValue); // NOTE: Custom Xonline change to avoid Compiler Level-2 Warning CS0618
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommand(string databaseName, string connectionString, int hashValue) 
        {
            IDbCommand command = this.GetCachedConnection(databaseName, connectionString).CreateCommand();
			TransactionWrapper.InitCommand(command);
			return command;
		} // GetCommand
        #endregion

        #region interface ISpilPhysicalConnectionManager
        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <returns>a collection object consisting of a set of physical instance partition numbers.</returns>
        public override object[] GetAllPhysicalInstances( string storeName) 
        {
            if( storeName == null)
                throw new DataStoreException( " store name cannot be null!");
            // probably should use application specific mapping
            WstConnection conn = GetCachedConnection( storeName, null) as WstConnection;
            
            //int n = conn.PhysicalPartitions;
            int n = conn.SqlPartitions.Count; // NOTE: Custom Xonline change to avoid Compiler Level-2 Warning CS0618
            if( n == 0)
                throw new DataStoreException( " No physical partitions found for connection: "+storeName);
            // even though our physical instances are consecutive integers, we have to
            // package into an integer array.
            object[] physicalIds = new object[n];
            for(int i = 0; i < n; i ++)
            {
                physicalIds[i] = i;
            }
            return physicalIds;
        }

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        /// returns a connection object for accessing the specific webstore application.
        /// Because webstore maintains a connection at the logical application level, the physical
        /// instance id is ignored. 
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceId">ID or key for specifying the target physical instance</param>
        /// <returns>an interface to the database connection object</returns>
        public override IDbConnection GetConnectionForPhysicalInstance( string storeName, string connectionString, object physicalInstanceId) 
        {
             return GetCachedConnection( storeName, connectionString);
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommandForPhysicalInstance(string logicalDatabaseName, string connectionString, object physicalInstanceId) 
        {
            IDbCommand command = this.GetCachedConnection(logicalDatabaseName, connectionString).CreateCommand();
			TransactionWrapper.InitCommand(command);
			return command;
		} // GetCommandForPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDataAdapter GetDataAdapterForCommand(IDbCommand cmd)
        {
            WstDataAdapter da = new WstDataAdapter();
            da.SelectCommand = (WstCommand)(cmd);
            return da;
        } // GetDataAdapterForCommand

        #endregion interface ISpilPhysicalConnectionManager

        #region interface IDisposable
        /// <summary>
        /// This method should be called explicitly by the user to close the
        /// resources the connection manager uses.
        /// </summary>
        public override void Dispose()
        {
            // suppress the garbage collector clean up
            GC.SuppressFinalize(this);
            // Call the method that actually does the cleanup
            Dispose(true);
        }

        /// <summary>
        /// The common method that does the actual clean up. This method is protected
        /// because the connection manager can be inherited by other connection managers.
        /// </summary>
        /// <param name="disposing">the flag to indicate whether to dispose explicitly
        /// or by GC</param>
        protected void Dispose(bool disposing)
        {
            // need to synchronize the dispose
            lock(this)
            {
                if(disposing)
                {
                    //explicit clean up. It is safe here to dispose any objects
                    //referenced by this object.
                    CloseConnections();
                }
                //note: we cannot call CloseConnections here because by the time
                //the connection manager is GCed, we're not sure if the connection cache
                //and the connections are already GCed or not.
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\spilrun\spilrun\TransactionWrapper.cs ===
using System;
using System.Runtime.InteropServices;
using System.EnterpriseServices;
using System.Reflection;
using System.Threading;
using System.Data.SqlClient;
using System.Data;
using System.Collections;

namespace Microsoft.Subscriptions.Data
{

    /// <summary>
    /// encapsulates the gross logic of having to dispense transaction from DTC directly
    /// </summary>
    internal class TransactionDispenser
    {
        internal static readonly Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

        [DllImport("XOLEHLP", PreserveSig=false)]
        internal static extern void
            DtcGetTransactionManagerEx(int pszHost, 
            int pszTmName, 
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid iid,
            int grfOptions,
            int pvConfigParams,
            [Out, MarshalAs(UnmanagedType.Interface)] out Object pDisp);


        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool OpenThreadToken(
            IntPtr ThreadHandle,  
            System.UInt32 DesiredAccess,  
            bool OpenAsSelf,      
            ref IntPtr TokenHandle   
            );

        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool SetThreadToken(
            IntPtr Thread,
            IntPtr Token   
            );

        [DllImport("ADVAPI32", SetLastError=true)]
        internal static extern bool RevertToSelf( );
        
        [ DllImport( "Kernel32", CharSet=CharSet.Auto )]
        internal static extern IntPtr GetCurrentThread();

        [DllImport("Kernel32", SetLastError=true)]
        internal static extern bool CloseHandle( IntPtr handle );

        /// <summary>
        /// This interface is implemented by the DTC to create transactions
        /// </summary>
        [
            ComImport,
            Guid("3A6AD9E1-23B9-11cf-AD60-00AA00A74CCD"),
            InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
            ]
            internal interface ITransactionDispenser
        {
            void GetOptionsObject( [Out, MarshalAs(UnmanagedType.Interface)] out Object ppoptions);

            void BeginTransaction (
                IntPtr punkOuter,
                int isoLevel,
                int isoFlags,
                IntPtr pOptions,
                [Out, MarshalAs(UnmanagedType.Interface)] out Object ppTransaction );
        }

        private ITransactionDispenser m_dispenser;

        public TransactionDispenser()
        {
            try
            {
                // first revert to impersonating the process token, otherwise DTC blows up
                const int TOKEN_IMPERSONATE = 4;
                const int TOKEN_QUERY = 8;

                IntPtr threadtoken  = IntPtr.Zero;
                OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_QUERY, true, ref threadtoken);
                try
                {
                    if (threadtoken != IntPtr.Zero)
                    {
                        RevertToSelf();
                    }

                    // get the dispenser
                    Object dispenser = null;
                    DtcGetTransactionManagerEx(0, 0, IID_IUnknown, 0, 0, out dispenser);
                    m_dispenser = dispenser as ITransactionDispenser;
                }
                finally
                {
                    // go back
                    if (threadtoken != IntPtr.Zero)
                    {
                        SetThreadToken(IntPtr.Zero,threadtoken);
                        CloseHandle(threadtoken);
                    }
                }
            }
            catch(Exception)
            {
                // this keeps the exception from getting filtered, avoid a security hole in VB.Net
                throw;
            }
        }

        ~TransactionDispenser()
        {
            Marshal.ReleaseComObject(m_dispenser);
            m_dispenser = null;
        }

        public ITransaction BeginTransaction(IsolationLevel isolevel)
        {
            Object pTransaction = null;
            m_dispenser.BeginTransaction(IntPtr.Zero, (int)isolevel,0, IntPtr.Zero, out pTransaction);
            return pTransaction as ITransaction;
        }
    }

    /// <summary>TIP (transaction internet protocol) transaction interface</summary>
    [ComImport,
     Guid("17CF72D0-BAC5-11d1-B1BF-00C04FC2F3EF"),
     InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITipTransaction
    {
        /// <summary>send TIP push command</summary>
        /// <param name="remoteTmUrl">destination transaction manager's TIP URL</param>
        /// <param name="remoteTxUrl">TIP URL</param>
        void Push(
            [In, MarshalAs(UnmanagedType.LPStr)]
            string remoteTmUrl,
            [Out, MarshalAs(UnmanagedType.LPStr)] 
            out string remoteTxUrl);

        /// <summary>Get the TIP URL of this transaction</summary>
        /// <param name="localTxUrl">the TIP URL</param>
        void GetTransactionUrl(
            [Out, MarshalAs(UnmanagedType.LPStr)] 
            out string localTxUrl);
    }


    /// <summary>
    /// Specifies the scope of transaction that is supported by the transaction wrapper. SingleSqlDatabase
    /// transactions are much faster than DTC transactions, but cannot span multiple databases.
    /// </summary>
    public enum TransactionScope
    {
        /// <summary>
        /// Does not use any transactioning within this context. This scope may be contained within other transaction scopes, but
        /// other transaction scopes may not be contained within it.
        /// </summary>
        None,
        /// <summary>
        /// Uses the DTC to coordinate the transaction commit
        /// </summary>
        DTC,
        /// <summary>
        /// Uses native SQL transactions to provide support on a single database
        /// </summary>
        SingleSqlDatabase
    }

   
    /// <summary>
    /// A smartpointer type class for creating transaction contexts. These may be nested
    /// as many levels deep as is wanted. However, only the final commit will commit if all
    /// of the nested transactions called SetComplete.
    /// 
    /// This class is designed to be used with the "using" statement in C#. Unpredictable behaviour
    /// will result if this object is created in a different manner.
    /// </summary>
    public class TransactionWrapper : IDisposable
    {
        /// <summary>
        /// Contains all the data that should be stored on the thread local context
        /// </summary>
        private class TransactionRootData
        {
            public ITransaction m_transaction = null;
            public TransactionScope m_transactionScope = TransactionScope.DTC;
            public bool m_hasAborted = false;

            public string m_singleDatabaseString = null;
            public IDbTransaction m_singleDatabaseTransaction = null;
            public IsolationLevel m_isolationLevel = IsolationLevel.ReadCommitted;
            public int m_noneReferenceCount = 0;

            /// <summary>
            /// stores all the connections we have retrieved so far
            /// </summary>
            public Hashtable m_connections;
        }

        [ThreadStatic] private static TransactionRootData ms_root;
        private static TransactionDispenser ms_dispenser = new TransactionDispenser();
        /// <summary>
        /// Records wether SetComplete was called. If the wrapper is destroyed before this flag is set, we assume that the
        /// transaction was aborted.
        /// </summary>
        private bool m_hasCommitted = false;
        /// <summary>
        /// Records whether this is the root wrapper. Only the root wrapper actually commits the transaction.
        /// </summary>
        private bool m_isRoot = false;

        /// <summary>
        /// Constructs a new TransactionWrapper with the default scope of DTC and isolation level
        /// of ReadCommitted.
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        public TransactionWrapper() : this(TransactionScope.DTC)
        {
        }

        /// <summary>
        /// Constructs a new TransactionWrapper with the isolation level
        /// of ReadCommitted. 
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        /// <param name="scope">Specifies the scope of the wrapper. DTC scoped transaction can
        /// contain Sql scoped transaction, but not vice versa.</param>
        public TransactionWrapper(TransactionScope scope) : this(scope, IsolationLevel.ReadCommitted)
        {
        }

        /// <summary>
        /// Constructs a new TransactionWrapper. 
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        /// <param name="scope">Specifies the scope of the wrapper. DTC scoped transaction can
        /// contain Sql scoped transaction, but not vice versa. None scoped transactions can be wrapped inside any
        /// transaction, but no transactions may be wrapped inside None scoped transactions</param>
        /// <param name="isoLevel">Specifies the isolation level of the transaction. If this transaction
        /// is contained within another transaction, the isolation level must be equal or lower than the
        /// outer transaction, or we throw an exception. Ignored for None scoped transactions.</param>
        public TransactionWrapper(TransactionScope scope, IsolationLevel isoLevel)
        {
            if (ms_root == null)
            {
                ms_root = new TransactionRootData();
                ms_root.m_transactionScope = scope;
                ms_root.m_isolationLevel = isoLevel;
                m_isRoot = true;
            }
            else
            {
                if (scope != TransactionScope.None && isoLevel > ms_root.m_isolationLevel)
                {
                    throw new ApplicationException("Isolation level of outer TransactionWrapper is lower than the current transaction");
                }
                if (scope == TransactionScope.DTC &&
                    ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
                {
                    throw new ApplicationException("Cannot have DTC transaction scope inside a single database transaction scope");
                }
                if (scope != TransactionScope.None && 
                    (ms_root.m_transactionScope == TransactionScope.None || ms_root.m_noneReferenceCount > 0) )
                {
                    throw new ApplicationException("Cannot contain transactions within a non-transacted scope");
                }
                if (scope == TransactionScope.None)
                {
                    ms_root.m_noneReferenceCount++;
                }
            }
        }

        /// <summary>
        /// Frees a TransactionWrapper. Dispose MUST be called before the finalizer happens, or very
        /// bad things will happen.
        /// </summary>
        public void Dispose()
        {
            if (ms_root == null)
                return;

            if (m_isRoot)
            {
                try
                {
                    if (ms_root.m_transaction != null)
                    {
                        // We are a DTC transaction
                        try
                        {
                            if (m_hasCommitted && !ms_root.m_hasAborted)
                            {
                                ms_root.m_transaction.Commit(0,0,0);
                            }
                            else
                            {
                                BOID boid = new BOID();
                                ms_root.m_transaction.Abort(ref boid, 0, 0);
                            }
                        }
                        finally
                        {
                            Marshal.ReleaseComObject(ms_root.m_transaction);
                            ms_root.m_transaction = null;
                        }
                    }
                    else if (ms_root.m_singleDatabaseTransaction != null)
                    {
                        // We are a SQL transaction
                        try
                        {
                            if (m_hasCommitted && !ms_root.m_hasAborted)
                            {
                                ms_root.m_singleDatabaseTransaction.Commit();
                            }
                            else
                            {
                                ms_root.m_singleDatabaseTransaction.Rollback();
                            }
                        }
                        finally
                        {
                            ms_root.m_singleDatabaseTransaction.Dispose();
                            ms_root.m_singleDatabaseTransaction = null;
                        }
                    }
                }
                finally
                {
                    // we need to close the connections after the transaction commits, or we will
                    // hang DTC
                    if (ms_root.m_connections!=null)
                    {
                        foreach(DictionaryEntry entry in ms_root.m_connections)
                        {
                            try
                            {
                                (entry.Value as IDbConnection).Close();
                            }
                            catch(Exception)
                            {
                                // ignore exceptions that happen during Close
                            }
                        }
                        ms_root.m_connections = null;
                    }

                    ms_root = null;
                }
            }
            else
            {
                if (ms_root!=null && ms_root.m_noneReferenceCount > 0)
                {
                    // none transactions can't do a setcomplete
                    ms_root.m_noneReferenceCount--;
                }
                else
                {
                    if (!m_hasCommitted && ms_root!=null)
                    {
                        ms_root.m_hasAborted = true;
                    }
                }
            }
        }

		/// <summary>
		/// Backwards compatibility wrapper for OpenConnection that returns a SqlConnection 
		/// </summary>
		/// <param name="connectionString">The connection string to use</param>
		/// <returns>The connection we have created</returns>
		public static SqlConnection OpenConnection(string connectionString)
		{
			return OpenConnection(connectionString, typeof(SqlConnection)) as SqlConnection;
		}

        /// <summary>
        /// Creates and opens a connection of user specified type, taking into account the current transactional state. 
        /// 
        /// If we are currently within a DTC transaction, the connection is automatically enlisted in 
        /// that transaction.
        /// 
        /// If we are within a Sql transaction, we begin a transaction. Note that only one unique connection
        /// is allowed within a Sql transaction (since we cannot span databases), so we throw an exception
        /// if this is called for more than one unique connection string.
        /// 
        /// If we are not within a transaction, we simply create the SqlConnection and open it.
        /// 
        /// We must use the static CloseConnection method to close the connection, otherwise DTC will hang
        /// when trying to commit the transaction.
        /// </summary>
        /// <param name="connectionString">The connection string to use</param>
        /// <param name="connectionObjectType">The type of connection to create</param>
        /// <returns>The connection we have created</returns>
        public static Object OpenConnection(string connectionString, Type connectionObjectType)
        {
			Object conn;

            // if we are not in a transaction, just act normal
            if (CurrentScope == TransactionScope.None)
            {
				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
                ((IDbConnection)conn).Open();
                return conn;
            }

            if (ms_root.m_hasAborted)
            {
                throw new ApplicationException("Transaction has been aborted");
            }

            if (ms_root.m_connections==null)
            {
                ms_root.m_connections = new Hashtable();
            }

            conn = ms_root.m_connections[ connectionString ];
            if (conn!=null)
                return conn;

            if (ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
            {
                if (ms_root.m_connections.Count > 0)
                {
                    throw new InvalidOperationException("Cannot use a SingleSqlDatabase transaction on more than one connection");
                }

				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
				((IDbConnection)conn).Open();
				
				ms_root.m_connections.Add( connectionString, conn );

                ms_root.m_singleDatabaseTransaction = ((IDbConnection)conn).BeginTransaction(ms_root.m_isolationLevel);
            }
            else
            {
                if (ms_root.m_transaction == null)
                {
                    ms_root.m_transaction = ms_dispenser.BeginTransaction(ms_root.m_isolationLevel);
                }

				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
				((IDbConnection)conn).Open();
				
				ms_root.m_connections.Add( connectionString, conn );

                // Call 1.1 Framework method to enlist in transaction. We want to bind to the 1.1 runtime if it is available,
                // but we can't compile to it, since the 1.0 framework isn't "unified"
                conn.GetType().InvokeMember("EnlistDistributedTransaction", BindingFlags.InvokeMethod, null, conn, new Object[] {ms_root.m_transaction} );
            }

            return conn;
        }

        /// <summary>
        /// Creates a new SqlCommand object. If we are within a Sql transaction, we also set the
        /// Transaction field of the SqlCommand to the current transaction object. 
        /// 
        /// If we are within a DTC transaction or not within a transaction, we just create a new 
        /// SqlCommand.
        /// </summary>
        /// <param name="command">The command to initialize</param>
        public static void InitCommand(IDbCommand command)
        {
            // if we are not in a transaction, just act normal
            if (CurrentScope == TransactionScope.None)
            {
                return;
            }

            if (ms_root.m_hasAborted)
            {
                throw new ApplicationException("Transaction has been aborted");
            }

            if (ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
            {
                command.Transaction = ms_root.m_singleDatabaseTransaction;
            }
        }

        /// <summary>
        /// Closes the connection if we are not within a transaction. If we are in a transaction, Dispose
        /// will close the connection after it has been committed or rolled  back.
        /// </summary>
        /// <param name="conn"></param>
        public static void CloseConnection(Object conn)
        {
            if (CurrentScope == TransactionScope.None ||
                ms_root.m_connections==null || 
                !ms_root.m_connections.ContainsValue(conn))
            {
                ((IDbConnection)conn).Close();
            }
        }

        /// <summary>
        /// Returns the current scope we are running as
        /// </summary>
        public static TransactionScope CurrentScope
        {
            get
            {
                if (ms_root==null || ms_root.m_noneReferenceCount > 0)
                {
                    return TransactionScope.None;
                }
                else
                {
                    return ms_root.m_transactionScope;
                }
            }
        }


        /// <summary>
        /// Thows an exception if the current thread is running within a transaction
        /// </summary>
        public static void AssertNoTransaction()
        {
            if (CurrentScope != TransactionScope.None)
            {
                throw new InvalidOperationException("Operation cannot be run within the context of a transaction");
            }
        }

        /// <summary>
        /// This method should be called just before the end of the "using" block. It lets the TransactionWrapper
        /// know that the block completed without throwing an exception. If SetComplete was not called
        /// before Dispose was called, then we automatically abort the transaction.
        /// </summary>
        public void SetComplete()
        {
            if (CurrentScope == TransactionScope.None)
            {
                throw new InvalidOperationException("Cannot call SetComplete on a None transaction scope");
            }

            m_hasCommitted = true;
        }

        /// <summary>get the TIP url of the current DTC transaction</summary>
        /// <remarks>The current thread's transaction is used to get the TIP URL. Make
        /// sure you have a running DTC transaction before calling this method.</remarks>
        /// <returns>TIP URL</returns>
        /// <exception cref="InvalidOperationException">if no DTC transaction is running
        /// </exception>
        public static string CurrentTipUrl {
            get 
            {
                if(CurrentScope != TransactionScope.DTC)
                    throw new InvalidOperationException("no running DTC transaction");

                if(ms_root.m_transaction == null)
                {
                    ms_root.m_transaction = ms_dispenser.BeginTransaction(
                        ms_root.m_isolationLevel);
                }
                ITipTransaction tipTransaction = (ITipTransaction) ms_root.m_transaction;
                string url;
                tipTransaction.GetTransactionUrl(out url);
                return url;
            }
        }
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwbind2.h ===
/*************************************************************************
  Microsoft Network
  Copyright (C) Microsoft Corporation, 2000

*************************************************************************/

#ifndef __ODBWBIND2_H__
#define __ODBWBIND2_H__

/******************************************************************************/

#ifdef WSBIND
#undef WSBIND
#endif

#define WSBIND(ulColumn,ulDataOff,wType,cMaxLen) { \
	(ulColumn), \
	(ulDataOff), \
	0, \
	0, \
	NULL, \
	NULL, \
	NULL, \
	DBPART_VALUE, \
	DBMEMOWNER_CLIENTOWNED, \
	DBPARAMIO_NOTPARAM, \
	(wType) != DBTYPE_WSTR ? (cMaxLen) : (cMaxLen) * sizeof(WCHAR), \
	0, \
	(wType), \
	0, \
	0 \
}

#ifdef WSBIND2
#undef WSBIND2
#endif

#define WSBIND2(ulColumn,ulDataOff,wType,cMaxLen,dwPart,ulLengthOff,ulStatusOff) { \
	(ulColumn), \
	(ulDataOff), \
	(ulLengthOff), \
	(ulStatusOff), \
	NULL, \
	NULL, \
	NULL, \
	(dwPart), \
	DBMEMOWNER_CLIENTOWNED, \
	DBPARAMIO_NOTPARAM, \
	(wType) != DBTYPE_WSTR ? (cMaxLen) : (cMaxLen) * sizeof(WCHAR), \
	0, \
	(wType), \
	0, \
	0 \
}

/******************************************************************************/

#endif // __ODBWBIND2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwbind.h ===
/*************************************************************************
  Microsoft Network
  Copyright (C) Microsoft Corporation, 1999


*************************************************************************/

#ifndef __ODBWBIND_H__
#define __ODBWBIND_H__

/******************************************************************************/

class CODBWParameterInfo {
public:	
	enum{
		MAXPARAMETERS = 150
	};
	
	ULONG m_cParamCount;

	DBORDINAL m_rgParamOrdinals[MAXPARAMETERS];
	DBPARAMBINDINFO m_rgParamBindingInfo[MAXPARAMETERS];
	DBBINDING m_rgDBBinding[MAXPARAMETERS];

	CODBWParameterInfo()
		: m_cParamCount(0) { }
	
	void SetParam_int(ULONG obValue, BOOL bInput)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = L"DBTYPE_I4";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = sizeof(long);
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 11;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(long);
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		m_rgDBBinding[m_cParamCount].wType = DBTYPE_I4;
		m_rgDBBinding[m_cParamCount].bPrecision = 11;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		m_cParamCount++;
	}

	void SetParam_bool(ULONG obValue, BOOL bInput)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = L"DBTYPE_BOOL";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = sizeof(BOOL);
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(BOOL);
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		m_rgDBBinding[m_cParamCount].wType = DBTYPE_BOOL;
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		m_cParamCount++;
	}

	void SetParam_date(ULONG obValue, BOOL bInput)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = L"DBTYPE_DATE";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = sizeof(DATE);
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(DATE);
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		m_rgDBBinding[m_cParamCount].wType = DBTYPE_DATE;
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		m_cParamCount++;
	}

	void SetParam_UUID(ULONG obValue, BOOL bInput)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;

		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = L"DBTYPE_GUID";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = sizeof(GUID);
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(GUID);
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		m_rgDBBinding[m_cParamCount].wType = DBTYPE_GUID;
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		m_cParamCount++;
	}

	void SetParam_char(ULONG obValue, BOOL bInput, ULONG cSize, BOOL bUnicode, BOOL bRef)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = bUnicode ? L"DBTYPE_WVARCHAR" : L"DBTYPE_VARCHAR";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = cSize;
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;

		m_rgDBBinding[m_cParamCount].cbMaxLen = cSize * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		if (bUnicode) {
			m_rgDBBinding[m_cParamCount].wType = DBTYPE_WSTR;
		}
		else {
			m_rgDBBinding[m_cParamCount].wType = DBTYPE_STR;
		}
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		if(bRef) {
			m_rgDBBinding[m_cParamCount].wType |= DBTYPE_BYREF;
			m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(VOID*);
		}

		m_cParamCount++;
	}

	void SetParam_varchar(ULONG obValue, BOOL bInput, ULONG cSize, BOOL bUnicode, BOOL bRef)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType = bUnicode ? L"DBTYPE_WVARCHAR" : L"DBTYPE_VARCHAR";
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = cSize;
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = cSize * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		if (bUnicode) {
			m_rgDBBinding[m_cParamCount].wType = DBTYPE_WSTR;
		}
		else {
			m_rgDBBinding[m_cParamCount].wType = DBTYPE_STR;
		}
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		if(bRef) {
			m_rgDBBinding[m_cParamCount].wType |= DBTYPE_BYREF;
			m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(VOID*);
		}


		m_cParamCount++;
	}

	void SetParam_Binary(ULONG obValue, BOOL bInput, ULONG cbSize, BOOL bRef)
	{
		m_rgParamOrdinals[m_cParamCount] = m_cParamCount + 1;
		
		m_rgParamBindingInfo[m_cParamCount].pwszDataSourceType =  L"DBTYPE_BINARY"; 
		m_rgParamBindingInfo[m_cParamCount].pwszName = NULL;
		m_rgParamBindingInfo[m_cParamCount].ulParamSize = cbSize;
		m_rgParamBindingInfo[m_cParamCount].dwFlags = bInput ? DBPARAMFLAGS_ISINPUT : DBPARAMFLAGS_ISOUTPUT;
		m_rgParamBindingInfo[m_cParamCount].bPrecision = 0;
		m_rgParamBindingInfo[m_cParamCount].bScale = 0;
		
		m_rgDBBinding[m_cParamCount].iOrdinal = m_cParamCount + 1;
		m_rgDBBinding[m_cParamCount].obValue = obValue;
		m_rgDBBinding[m_cParamCount].obLength = 0;
		m_rgDBBinding[m_cParamCount].obStatus = 0;
		m_rgDBBinding[m_cParamCount].pTypeInfo = NULL;
		m_rgDBBinding[m_cParamCount].pObject = NULL;
		m_rgDBBinding[m_cParamCount].pBindExt = NULL;
		m_rgDBBinding[m_cParamCount].dwPart = DBPART_VALUE;
		m_rgDBBinding[m_cParamCount].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_rgDBBinding[m_cParamCount].eParamIO = bInput ? DBPARAMIO_INPUT : DBPARAMIO_OUTPUT;
		m_rgDBBinding[m_cParamCount].cbMaxLen = cbSize;
		m_rgDBBinding[m_cParamCount].dwFlags = 0;
		m_rgDBBinding[m_cParamCount].wType = DBTYPE_BYTES;
		m_rgDBBinding[m_cParamCount].bPrecision = 0;
		m_rgDBBinding[m_cParamCount].bScale = 0;

		if(bRef) {
			m_rgDBBinding[m_cParamCount].wType |= DBTYPE_BYREF;
			m_rgDBBinding[m_cParamCount].cbMaxLen = sizeof(PVOID);
		}

		m_cParamCount++;
	}
	
	void SetStatus(LONG obStatus)
	{
		m_rgDBBinding[m_cParamCount-1].dwPart |= DBPART_STATUS;
		m_rgDBBinding[m_cParamCount-1].obStatus = obStatus;
	}
	
	void SetLength(LONG obLength)
	{
		m_rgDBBinding[m_cParamCount-1].dwPart |= DBPART_LENGTH;
		m_rgDBBinding[m_cParamCount-1].obLength = obLength;
	}


};



inline void ODBWBindingAdd_bigint(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(ULONGLONG);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_I8;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}


inline void ODBWBindingAdd_int(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(long);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_I4;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

inline void ODBWBindingAdd_bool(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG) obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(BOOL);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_BOOL;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

inline void ODBWBindingAdd_date(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(long);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_DATE;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

inline void ODBWBindingAdd_char(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, ULONG cMaxLen, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = cMaxLen != 0 ? cMaxLen * sizeof(CHAR) : sizeof(VOID*);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_STR;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;

	if(cMaxLen == 0) pDBB->wType |= DBTYPE_BYREF;
}

inline void ODBWBindingAdd_nchar(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, ULONG cMaxLen, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = cMaxLen != 0 ? cMaxLen * sizeof(WCHAR) : sizeof(VOID*);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_WSTR;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;

	if(cMaxLen == 0) pDBB->wType |= DBTYPE_BYREF;
}

inline void ODBWBindingAdd_Binary(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, ULONG cMaxLen, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = cMaxLen != 0 ? cMaxLen : sizeof(PVOID);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_BYTES;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;

	if(cMaxLen == 0) pDBB->wType |= DBTYPE_BYREF;
}

// Binding used to only get the length and optionally the status of a ntext value, without actually retrieving the data 
inline void ODBWBindingAdd_ntextinfo(DBBINDING* pDBB, ULONG iOrdinal, ULONG obLength, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = 0;
	pDBB->obLength = obLength;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_LENGTH | DBPART_STATUS : DBPART_LENGTH;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = 0;
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_WSTR;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

inline void ODBWBindingAdd_double(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(double);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_R8;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

inline void ODBWBindingAdd_GUID(DBBINDING* pDBB, ULONG iOrdinal, ULONG obValue, LONG obStatus = -1)
{
	pDBB->iOrdinal = iOrdinal;
	pDBB->obValue = obValue;
	pDBB->obLength = 0;
	pDBB->obStatus = (ULONG)obStatus;
	pDBB->pTypeInfo = NULL;
	pDBB->pObject = NULL;
	pDBB->pBindExt = NULL;
	pDBB->dwPart = obStatus > 0 ? DBPART_VALUE | DBPART_STATUS : DBPART_VALUE;
	pDBB->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pDBB->eParamIO = DBPARAMIO_NOTPARAM;
	pDBB->cbMaxLen = sizeof(GUID);
	pDBB->dwFlags = 0;
	pDBB->wType = DBTYPE_GUID;
	pDBB->bPrecision = 0;
	pDBB->bScale = 0;
}

/******************************************************************************/

#endif // __ODBWBIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwerror.cpp ===
#include "stdafx.h"
#include "oledbwrapper.h"

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

/******************************************************************************/

HRESULT CODBWError::ShowError
    (
    LPCSTR pszInfo,
    ...
    )
{
    clearBuffer();

    va_list marker;
    va_start(marker, pszInfo);

    addVFmtMsg(pszInfo, marker);

    va_end(marker);

    addCommandAndConnection();

    sendMessage();
    
    return S_OK;
}

/******************************************************************************/

HRESULT CODBWError::HandleError
    (
    HRESULT hrReturned,
    LPCSTR pszInfo,
    ...
    )
{
    HRESULT hr = S_OK;
    CComPtr<IErrorInfo> pIErrorInfo;
    CComQIPtr<IErrorRecords> pIErrorRecords;
    ULONG cRecords = 0;
    ULONG iErr = 0;

    if(FAILED(hrReturned))
    {
        addFmtMsg("\r\n");
        
        // Add the info passed by the caller
        va_list marker;
        va_start(marker, pszInfo);
        addVFmtMsg(pszInfo, marker);
        va_end(marker);

        addCommandAndConnection();
        
        // Add the HRESULT
        addFmtMsg("\r\n(hr = %08x)", hrReturned);

        // Now try to get more data from OLE DB
        hr = GetErrorInfo(0, &pIErrorInfo);
        
        if((S_OK == hr)  && (pIErrorInfo != NULL))
        {
            pIErrorRecords = pIErrorInfo;
            if(pIErrorRecords != NULL)
            {
                hr = pIErrorRecords->GetRecordCount(&cRecords);

                if(SUCCEEDED(hr))
                {
                    for( iErr = 0; iErr < cRecords; iErr++ )
                    {
                        processErrorRecord(iErr, pIErrorRecords);
                    }
                }
            }
            else
            {
                processErrorInfo(pIErrorInfo);
            }
        }

        sendMessage();
    }
    
    return hr;
}

/******************************************************************************/

void CODBWError::clearBuffer()
{
    m_szBuffer[0] = 0;
    m_cchBuffer = 0;
}

/******************************************************************************/

void CODBWError::addFmtMsg(
    LPCSTR pszFormat,
    ...
)
{
    va_list marker;
    va_start(marker, pszFormat);

    addVFmtMsg(pszFormat, marker);

    va_end(marker);
}

/******************************************************************************/

void CODBWError::addVFmtMsg(
    LPCSTR pszFormat,
    va_list argptr
)
{
    m_cchBuffer += _vsnprintf(
        m_szBuffer + m_cchBuffer,
        MAX_ERROR_MSG_SIZE - m_cchBuffer,
        pszFormat,
        argptr);

    m_szBuffer[m_cchBuffer] = 0;
}

/******************************************************************************/

void CODBWError::sendMessage()
{
    if(m_lpEventCallback)
    {
        (*m_lpEventCallback)(0, m_szBuffer);
    }
}

/******************************************************************************/

HRESULT CODBWError::processErrorRecord
    (
    ULONG iRecord,
    IErrorRecords* _pIErrorRecords
    )
{
    static LCID lcid = GetUserDefaultLCID();    
    CComPtr<IErrorRecords>  pIErrorRecords(_pIErrorRecords);
    CComPtr<IErrorInfo>     pIErrorInfo;
    CComBSTR    bstrDescription;
    CComBSTR    bstrSource;
    CComBSTR    bstrSQLInfo;
    LONG        lNativeError = 0;
    ERRORINFO   ErrorInfo;
    HRESULT hr = S_OK;
    
    hr = pIErrorRecords->GetErrorInfo(iRecord, lcid, &pIErrorInfo);
    
    if(SUCCEEDED(hr))
    {
        ErrorInfo.hrError = 0;
        
        pIErrorInfo->GetDescription(&bstrDescription);
        pIErrorInfo->GetSource(&bstrSource);
        pIErrorRecords->GetBasicErrorInfo(iRecord, &ErrorInfo);
        getSQLErrorInfo(iRecord, pIErrorRecords, &bstrSQLInfo, &lNativeError);

        addFmtMsg(
            "\r\n------------------------------------------------------"
            "\r\nHResult: %08x"
            "\r\nDescription: %S"
            "\r\nSQL Info: %S"
            "\r\nSource: %S"
            "\r\n",
            ErrorInfo.hrError,
            (bstrDescription != NULL ? bstrDescription : L"(N/A)"),
            (bstrSQLInfo != NULL ? bstrSQLInfo : L"(N/A)"),
            (bstrSource != NULL ? bstrSource : L"(N/A)") );
    }
    
    return hr;
}

/******************************************************************************/

HRESULT CODBWError::processErrorInfo
    (
    IErrorInfo* _pIErrorInfo
    )
{
    CComPtr<IErrorInfo> pIErrorInfo(_pIErrorInfo);
    CComBSTR    bstrDescription;
    CComBSTR    bstrSource;
    HRESULT hr = S_OK;

    pIErrorInfo->GetDescription(&bstrDescription);
    pIErrorInfo->GetSource(&bstrSource);

    addFmtMsg(
        "\r\n"
        "\r\n----------------"
        "\r\nDescription: %S"
        "\r\nSource: %S"
        "\r\n",
        (bstrDescription != NULL ? bstrDescription : L"(N/A)"),
        (bstrSource != NULL ? bstrSource : L"(N/A)") );

    return hr;
}


/******************************************************************************/

HRESULT CODBWError::getSQLErrorInfo
    (
    ULONG           iRecord,
    IErrorRecords*  pIErrorRecords,
    BSTR*           pBstr,
    LONG*           plNativeError
    )
{

    ISQLErrorInfo*  pISQLErrorInfo = NULL;
    LONG            lNativeError = 0;
    HRESULT         hr = S_OK;

    hr = pIErrorRecords->GetCustomErrorObject(
        iRecord,
        IID_ISQLErrorInfo,
        (IUnknown**) &pISQLErrorInfo);

    if(FAILED(hr))
        goto _out;

    if(pISQLErrorInfo != NULL)
    {
        hr = pISQLErrorInfo->GetSQLInfo(pBstr, &lNativeError);
    }

_out:

    if(plNativeError != NULL)
        *plNativeError = lNativeError;

    if(pISQLErrorInfo != NULL)
        pISQLErrorInfo->Release();

    return hr;
}

/******************************************************************************/

HRESULT CODBWError::addCommandAndConnection()
{
    HRESULT hr = S_OK;
    CComBSTR m_bstrConnection;
    CComBSTR m_bstrCommand;
    
    hr = m_pConnectionPoint->GetConnectionInfo(&m_bstrConnection);
    if(S_OK == hr)
    {
        addFmtMsg(
            "\r\n------------------------------------------------------"
            "\r\nConnection: "
            "\r\n%S",
            m_bstrConnection);
    }

    hr = m_pConnectionPoint->GetCommandInfo(&m_bstrCommand);
    if(S_OK == hr)
    {
        addFmtMsg(
            "\r\n------------------------------------------------------"
            "\r\nCommand: "
            "\r\n%S"
            "\r\n",
            m_bstrCommand);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\ODBWCallProc.cpp ===
/*******************************************************************************

  Microsoft Network
  Copyright (C) Microsoft Corporation, 2000

*******************************************************************************/

#include "stdafx.h"
#include "OleDBWrapper.h"

/******************************************************************************/

HRESULT CODBWSession::CallProc(
	CWSProcCache* pCache,
	LPCWSTR pwszProc,
	...
)
{
	HRESULT hr = S_OK;
	
	va_list arg_list;

	va_start(arg_list, pwszProc);

	hr = VCallProc(pCache, pwszProc, arg_list);

	va_end(arg_list);

	return hr;
}

HRESULT CODBWSession::VCallProc(
	CWSProcCache* pCache,
	LPCWSTR pwszProc,
	va_list arg_list
)
{
	int iParamCount = 0;
	COMMAND_INFO* pCommandInfo = NULL;

	HRESULT hr = S_OK;

	if( (NULL == pCache) ||
		(NULL == pCache->GetData()) )
	{
		// Pre-parse pwszProc to get the parameter count
		iParamCount = getParamCount(pwszProc);

		_ASSERT(iParamCount >= 0);
		
		int iSizeAlloc = sizeof(COMMAND_INFO) + 
						(sizeof(DBORDINAL) + sizeof(DBPARAMBINDINFO) + sizeof(DBBINDING)) * iParamCount;

		
        // Allocate command info stuff on the stack

        __try
        {
    		pCommandInfo = (COMMAND_INFO*) _alloca(iSizeAlloc);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_OUTOFMEMORY;
            
            if(GetExceptionCode() == STATUS_STACK_OVERFLOW)
            {
                // Best effort to restore stack status
                
                _resetstkoflw();
            }
        }

        if(SUCCEEDED(hr))
        {
    		pCommandInfo->rgParamOrdinal = (DBORDINAL*)((BYTE*)pCommandInfo + sizeof(COMMAND_INFO));
    		pCommandInfo->rgParamBindInfo = (DBPARAMBINDINFO*)
    			((BYTE*)pCommandInfo->rgParamOrdinal + sizeof(DBORDINAL) * iParamCount);
    		pCommandInfo->rgBinding = (DBBINDING*)
    			((BYTE*)pCommandInfo->rgParamBindInfo + sizeof(DBPARAMBINDINFO) * iParamCount);
    		
    		pCommandInfo->ulParamCount = (ULONG) iParamCount;

    		hr = parseStoredProcCall(pwszProc, pCommandInfo);

    		if(SUCCEEDED(hr))
    		{
    			if(pCache != NULL)
    			{
    				COMMAND_INFO* pAllocCommandInfo = (COMMAND_INFO*) CoTaskMemAlloc(iSizeAlloc);

    				if(pAllocCommandInfo)
    				{
    					memcpy(pAllocCommandInfo, pCommandInfo, iSizeAlloc);

    					pAllocCommandInfo->rgParamOrdinal = 
    						(DBORDINAL *)((BYTE*)pAllocCommandInfo + sizeof(COMMAND_INFO));

    					pAllocCommandInfo->rgParamBindInfo = (DBPARAMBINDINFO*)
    						((BYTE*)pAllocCommandInfo->rgParamOrdinal + sizeof(DBORDINAL) * iParamCount);
    					
    					pAllocCommandInfo->rgBinding = (DBBINDING*)
    						((BYTE*)pAllocCommandInfo->rgParamBindInfo + sizeof(DBPARAMBINDINFO) * iParamCount);

    					if(! pCache->SetData(pAllocCommandInfo))
    					{
    						CoTaskMemFree(pAllocCommandInfo);
    					}
    				}
    				else
    				{
    					// Failed to allocate the memory for the cached buffer
    					// but will not fail because it can still go on.
    				}
    			}
    		}
        }
	}
	else
	{
		
		// Use the cached parameter binding stuff
		
		pCommandInfo = (COMMAND_INFO*) pCache->GetData();
	}

	if(SUCCEEDED(hr))
	{
		if(pCommandInfo->ulParamCount > m_ParamBufferSize)
		{
			if(m_pHeapParamBuffer)
			{
				delete m_pHeapParamBuffer;
				m_pHeapParamBuffer = NULL;
			}

			m_pHeapParamBuffer = new PARAMETER_DATA [pCommandInfo->ulParamCount];
			
			if(m_pHeapParamBuffer)
			{
				m_pParamBuffer = m_pHeapParamBuffer;
				m_ParamBufferSize = pCommandInfo->ulParamCount;
			}
			else
			{
				m_pParamBuffer = m_StackParamBuffer;
				m_ParamBufferSize = MAX_PARAM_COUNT;
			}
		}

		if(m_ParamBufferSize >= pCommandInfo->ulParamCount)
		{
			for(ULONG ulParamNdx=0; ulParamNdx < pCommandInfo->ulParamCount; ulParamNdx++)
			{
				if( (pCommandInfo->rgBinding[ulParamNdx].eParamIO & DBPARAMFLAGS_ISOUTPUT) &&
					! (pCommandInfo->rgBinding[ulParamNdx].eParamIO & DBPARAMFLAGS_ISINPUT) )
				{
					m_pParamBuffer[0].iData = NOTAVAILABLE;
					continue;
				}
				
				if(pCommandInfo->rgBinding[ulParamNdx].dwPart & DBPART_VALUE)
				{
					DBTYPE wType = pCommandInfo->rgBinding[ulParamNdx].wType;

					if( wType == DBTYPE_I4 )
					{
						m_pParamBuffer[ulParamNdx].iData = 
							va_arg(arg_list, INT);
					}
					else if( wType == DBTYPE_I8 )
					{
						m_pParamBuffer[ulParamNdx].qwData = 
							va_arg(arg_list, ULONGLONG);
					}
					else if ( wType == DBTYPE_DATE )
					{
						m_pParamBuffer[ulParamNdx].dtData = 
							va_arg(arg_list, DATE);
					}
					else if ( wType == DBTYPE_GUID )
					{
						m_pParamBuffer[ulParamNdx].guidData = 
							va_arg(arg_list, GUID);
					}
					else if ( wType == (DBTYPE_STR | DBTYPE_BYREF) )
					{
						m_pParamBuffer[ulParamNdx].pszData = 
							va_arg(arg_list, LPCSTR);
					}
					else if ( wType == (DBTYPE_WSTR | DBTYPE_BYREF) )
					{
						m_pParamBuffer[ulParamNdx].pwszData = 
							va_arg(arg_list, LPCWSTR);
					}
					else if ( wType == (DBTYPE_BYTES | DBTYPE_BYREF) )
					{
						m_pParamBuffer[ulParamNdx].pData = 
							va_arg(arg_list, BYTE*);
					}
					else if ( wType == DBTYPE_R8 )
					{
						m_pParamBuffer[ulParamNdx].fData =
							va_arg(arg_list, DOUBLE);
					}
                    else if ( wType == DBTYPE_I2 )
                    {
                        m_pParamBuffer[ulParamNdx].nData = 
                            va_arg(arg_list, SHORT);
                    }
                    else if ( wType == DBTYPE_I1 )
                    {
                        m_pParamBuffer[ulParamNdx].cData = 
                            va_arg(arg_list, CHAR);
                    }
					else
					{
						hr = E_INVALIDARG;
						break;
					}
				}
				
				if(pCommandInfo->rgBinding[ulParamNdx].dwPart & DBPART_LENGTH)
				{
					m_pParamBuffer[ulParamNdx].dwLength = 
						va_arg(arg_list, DWORD);
				}
				
				if(pCommandInfo->rgBinding[ulParamNdx].dwPart & DBPART_STATUS)
				{
					m_pParamBuffer[ulParamNdx].dwStatus =
						va_arg(arg_list, DWORD);
				}
			}

			if(SUCCEEDED(hr))
			{
				hr = RunCommandEx(
					pCommandInfo->wszProc,
					pCommandInfo->ulParamCount,
					pCommandInfo->rgParamOrdinal,
					pCommandInfo->rgParamBindInfo,
					pCommandInfo->rgBinding,
					m_pParamBuffer);
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

int CODBWSession::getParamCount(
	LPCWSTR pwszProc
)
{
	LPCWSTR p = pwszProc;
	
	int iParamCount = 0;

	while(NULL != (p = wcschr(p, L'%')))
	{
		if(p[1] != L'%')
		{
			p++;
			iParamCount++;
		}
		else if(p[1] != L'\0')
		{
			p+=2;
		}
		else
		{
			break;
		}
	}

	return iParamCount;
}


	
HRESULT CODBWSession::parseStoredProcCall(
	LPCWSTR pwszProc,
	COMMAND_INFO* pCommandInfo
)
{
	HRESULT hr = S_OK;
	int iParamCount = 0;
	LPWSTR pWrite = pCommandInfo->wszProc;

	for(LPCWSTR pRead = pwszProc; *pRead != L'\0';)
	{
		if(L'%' == pRead[0])
		{
			if(L'%' == pRead[1])
			{
				// Double % found. Replace it for a single %
				// This way we can still have % in the body of the proc call

				*pWrite++ = *pRead++;
				continue;
			}
			else
			{
				hr = parseStoredProcParam(&pRead, iParamCount, pCommandInfo);

				iParamCount++;

				if(FAILED(hr))
				{
					break;
				}

				// Replace parameter declaration by ODBC parameter declaration '?'
				*pWrite++ = L'?';
			}
		}
		else
		{
			*pWrite++ = *pRead++;
		}
	}

	*pWrite = L'\0';

	return hr;
}

// Format is %[flags][size][type]	
HRESULT CODBWSession::parseStoredProcParam(
	LPCWSTR* ppwszParam,
	int iParamNdx,
	COMMAND_INFO* pCommandInfo
)
{
	HRESULT hr = S_OK;
	LPCWSTR p = *ppwszParam;

	bool bValuePart = false;
	bool bLengthPart = false;
	bool bStatusPart = false;
	bool bInput = false;
	bool bOutput = false;
	bool bRef = false;
	bool bFixedSize = false;

	long lSize = 0;


	pCommandInfo->rgParamOrdinal[iParamNdx] = iParamNdx + 1;

	if(L'%' == *p)
	{
		p++;
		
		// [flags]
		bool bNoMoreFlags = false;
		while((! bNoMoreFlags) && (*p != L'\0'))
		{
			switch(*p)
			{
			case L'+':
				bInput = true;
				break;
			case L'-':
				bOutput = true;
				break;
			
			case L'v':	// Value part available
				bValuePart = true;
				break;
			case L'l':	// Length part available
				bLengthPart = true;
				break;
			case L's':	// Status part available
				bStatusPart = true;
				break;

			case L'f':	// fixed size (for strings only)
				bFixedSize = true;
				break;
		
			default:
				bNoMoreFlags = true;
			}

			if(bNoMoreFlags)
				break;

			p++;
		}
		
		if( (!bValuePart) && (!bLengthPart) && (!bStatusPart) )
		{
			bValuePart = true; // default
		}
		
		if( (!bInput) && (!bOutput) )
		{
			bInput = true; // default
		}

		// [size]
		WCHAR *pEndPtr = NULL;
		lSize = wcstol(p, &pEndPtr, 10);	// Size is a base 10 integer

		_ASSERT(pEndPtr != NULL);			// Should never happen. Doc says that
											// pEndPtr will never be NULL
        // Default size is 1GB
		if (0 == lSize)
            lSize = 1024 * 1024 * 1024;

		p = pEndPtr;

		DBPART dwPart = 
			(bValuePart ? DBPART_VALUE : 0) |
			(bLengthPart ? DBPART_LENGTH : 0) |
			(bStatusPart ? DBPART_STATUS : 0);

		DBPARAMFLAGS dwFlags = 
			(bInput ? DBPARAMFLAGS_ISINPUT : 0) |
			(bOutput ? DBPARAMFLAGS_ISOUTPUT : 0);

		DBPARAMIO eParamIO =
			(bInput ? DBPARAMIO_INPUT : 0) |
			(bOutput ? DBPARAMIO_OUTPUT : 0);

		// [type]
		switch(*p)
		{
        case L'C':          // 2-byte Int
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_I1",
				sizeof(char),
				dwFlags,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_I1,
				sizeof(char),
				11);
            break;

        case L'N':          // 2-byte Int
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_I2",
				sizeof(short),
				dwFlags,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_I2,
				sizeof(short),
				11);
            break;

		case L'I':			// Integer
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_I4",
				sizeof(long),
				dwFlags,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_I4,
				sizeof(long),
				11);
			break;

		case L'Q':			// Quadword (64bit integer)
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_I8",
				sizeof(ULONGLONG),
				dwFlags,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_I8,
				sizeof(ULONGLONG),
				11);
			break;
	
		case L'T':			// Status (special case)
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_I4",
				sizeof(long),
				DBPARAMFLAGS_ISOUTPUT,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				DBPARAMIO_OUTPUT,
				DBTYPE_I4,
				sizeof(long),
				11);
			break;
		
		case L'D':			// Date
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_DATE",
				sizeof(DATE),
				dwFlags,
				0);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_DATE,
				sizeof(DATE),
				0);
			break;

		case L'G':			// GUID
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_GUID",
				sizeof(GUID),
				dwFlags,
				0);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_GUID,
				sizeof(GUID),
				0);
			break;

		case L'S':			// String (ANSI)
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				bFixedSize ? L"DBTYPE_CHAR" : L"DBTYPE_VARCHAR",
				lSize,
				DBPARAMFLAGS_ISINPUT,
				0);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				DBPARAMIO_INPUT,
				DBTYPE_STR | DBTYPE_BYREF,
				lSize * sizeof(CHAR),
				0);
			break;

		case L'W':			// String (Unicode)
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				bFixedSize ? L"DBTYPE_WCHAR" : L"DBTYPE_WVARCHAR",
				lSize,
				DBPARAMFLAGS_ISINPUT,
				0);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				DBPARAMIO_INPUT,
				DBTYPE_WSTR | DBTYPE_BYREF,
				lSize * sizeof(WCHAR),
				0);
			break;


		case L'B':			// Binary
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_BINARY",
				lSize,
				DBPARAMFLAGS_ISINPUT,
				0);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				DBPARAMIO_INPUT,
				DBTYPE_BYTES | DBTYPE_BYREF,
				lSize,
				0);
			break;

		case L'F':			// Float
			fillout_dbparambindinfo(&pCommandInfo->rgParamBindInfo[iParamNdx],
				L"DBTYPE_R8",
				sizeof(DOUBLE),
				dwFlags,
				11);

			fillout_dbbinding(&pCommandInfo->rgBinding[iParamNdx],
				iParamNdx + 1,
				dwPart,
				NULL,
				eParamIO,
				DBTYPE_R8,
				sizeof(long),
				11);
            break;

        default:
			hr = E_FAIL;
			break;
		}

		if(SUCCEEDED(hr))
		{
			*ppwszParam = p + 1;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

void CODBWSession::fillout_dbparambindinfo(
	DBPARAMBINDINFO* pBindInfo,
	LPOLESTR pwszType,
	ULONG ulSize,
	DBPARAMFLAGS dwFlags,
	BYTE cPrecision
)
{
	pBindInfo->pwszDataSourceType = pwszType;
	pBindInfo->pwszName = NULL;
	pBindInfo->ulParamSize = ulSize;
	pBindInfo->dwFlags = dwFlags;
	pBindInfo->bPrecision = cPrecision;
	pBindInfo->bScale = 0;
}

void CODBWSession::fillout_dbbinding(
	DBBINDING* pBind,
	INT iOrdinal,
	DBPART dwPart,
	DBOBJECT* pObject,
	DBPARAMIO eParamIO,
	DBTYPE wType,
	DWORD cbMaxLen,
	BYTE cPrecision
)
{
	pBind->iOrdinal = iOrdinal;
	pBind->obValue = ((iOrdinal-1) * sizeof(PARAMETER_DATA)) + offsetof(PARAMETER_DATA, iData);
	pBind->obLength = ((iOrdinal-1) * sizeof(PARAMETER_DATA)) + offsetof(PARAMETER_DATA, dwLength);
	pBind->obStatus = ((iOrdinal-1) * sizeof(PARAMETER_DATA)) + offsetof(PARAMETER_DATA, dwStatus);
	pBind->pTypeInfo = NULL;
	pBind->pObject = pObject;
	pBind->pBindExt = NULL;
	pBind->dwPart = dwPart;
	pBind->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	pBind->eParamIO = eParamIO;
	pBind->cbMaxLen = cbMaxLen;
	pBind->dwFlags = 0;
	pBind->wType = wType;
	pBind->bPrecision = cPrecision;
	pBind->bScale = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwfastload.h ===
//+-----------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      OleDbWrapper.h
//
//  Contents:  OleDbWrapper - header file
//             CODBWSession and CODBWResult declaration
//
//  Author:    Daniel Caiafa (dcaiafa@microsoft.com)
//
//  Revision History:
//
//    04/03/99	dcaiafa	created
//
//------------------------------------------------------------------------

#ifndef __ODBWFASTLOAD_H__
#define __ODBWFASTLOAD_H__

/******************************************************************************/

#include "oledbwrapper.h"
#include <sqloledb.h>

/******************************************************************************/

class CODBWFastLoad :
public CODBWErrorConnectionPoint
{
public:
	CODBWFastLoad();
	
	// Fast Bulk-row copying methods
	HRESULT FastLoadInitialize(
		LPCWSTR pwszDBServer,
		LPCWSTR pwszDBDatabase,
		LPCWSTR pwszDBUser,
		LPCWSTR pwszDBPwd);

	HRESULT FastLoadOpenTable(
		LPCWSTR pwszTableName, 
		DBBINDING* rgBindings, 
		ULONG cBindings);

	HRESULT FastLoadInsertRow(
		void* pData);

	HRESULT FastLoadCommitRows(BOOL bDone = TRUE);

	HRESULT FastLoadAbortRows();

	HRESULT FastLoadClose();

	// Error support
	virtual HRESULT GetConnectionInfo(
		BSTR* pbstrConnInfo)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT GetCommandInfo(
		BSTR* pbstrCommandInfo)
	{
		return E_NOTIMPL;
	}

protected:
	CComPtr<IOpenRowset> m_pIOpenRowset;
	CComPtr<IRowsetFastLoad> m_pIFastLoad;
	HACCESSOR m_hFastLoadAccessor;
	CODBWError m_ErrorHandler;

	HRESULT fastLoadSetProperty(
	    DBPROPID PropID,
	    BSTR bstrVal,
	    DBPROP * pDBProp);

	HRESULT fastLoadSetProperties(
		LPCWSTR pwszDBServer,
		LPCWSTR pwszDBDatabase,
		LPCWSTR pwszDBUser,
		LPCWSTR pwszDBPwd,
		IDBInitialize* pIDBInit);
	
	HRESULT setFastLoadProperty(
		BOOL fSet, 
		IDBInitialize* pIDBInit);
};

#endif // __ODBWFASTLOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwerror.h ===
#ifndef __SCMERROR_H__
#define __SCMERROR_H__

/******************************************************************************/

typedef HRESULT (*LPEVENTCALLBACK)(HRESULT, LPCSTR);

/******************************************************************************/

class CODBWErrorConnectionPoint
{
public:
	virtual HRESULT GetConnectionInfo(
		BSTR* pbstrConnInfo) = 0;

	virtual HRESULT GetCommandInfo(
		BSTR* pbstrCommandInfo) = 0;
};


/******************************************************************************/

class CODBWError
{
public:
	CODBWError(CODBWErrorConnectionPoint* pConnectionPoint) :
	  m_lpEventCallback(NULL), m_pConnectionPoint(pConnectionPoint), m_cchBuffer(0)
	  {}
	
	HRESULT ShowError
		(
		LPCSTR szInfo,
		...
		);
	  
	HRESULT HandleError
		(
		HRESULT hrReturned,
		LPCSTR szInfo,
		...
		);

	void SetCallback( LPEVENTCALLBACK lpEventCallback )
		{ m_lpEventCallback = lpEventCallback; }

protected:
	
	void clearBuffer();

	void addFmtMsg(
		LPCSTR pszFormat,
		...);

	void addVFmtMsg(
		LPCSTR pszFormat,
		va_list argptr);


	void sendMessage();
	
	HRESULT processErrorRecord
		(
		ULONG iRecord,
		IErrorRecords* _pIErrorRecords
		);

	HRESULT processErrorInfo
		(
		IErrorInfo* _pIErrorInfo
		);

	HRESULT	getSQLErrorInfo
		(
		ULONG			iRecord,
		IErrorRecords*	pIErrorRecords,
		BSTR*			pBstr,
		LONG*			plNativeError
		);

	HRESULT addCommandAndConnection();


	enum { MAX_ERROR_MSG_SIZE = 2048 };
	
	CODBWErrorConnectionPoint* m_pConnectionPoint;
	LPEVENTCALLBACK m_lpEventCallback;
	
	CHAR m_szBuffer[MAX_ERROR_MSG_SIZE + 1];
	DWORD m_cchBuffer;
};

/******************************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\odbwfastload.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      ODBWFASTCOPY.cpp
//
//  Contents:  Methods to perform bulk-row copying
//
//  Author:    Daniel Caiafa (dcaiafa@microsoft.com)
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "ODBWFastLoad.h"

CODBWFastLoad::CODBWFastLoad()
: m_ErrorHandler((CODBWErrorConnectionPoint*)this)
{
	m_hFastLoadAccessor = 0;
}

/*******************************************************************************
CODBWFastLoad::FastLoadInitialize


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadInitialize(
	LPCWSTR pwszDBServer,
	LPCWSTR pwszDBDatabase,
	LPCWSTR pwszDBUser,
	LPCWSTR pwszDBPwd
)
{
	CComPtr<IDBInitialize> pIDBInit;
	CComQIPtr<IDataInitialize>  pIDataInit;
	CComQIPtr<IDBCreateSession> pIDBCreateSession;
	HRESULT hr = S_OK;
	
	hr = CoCreateInstance(CLSID_SQLOLEDB, NULL, CLSCTX_INPROC_SERVER, 
		IID_IDBInitialize, (void**) &pIDBInit);

	if(FAILED(hr))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::FastLoadInitialize(%S, %S, %S, %S) - CoCreateInstance failed", 
			pwszDBServer, pwszDBDatabase, pwszDBUser, pwszDBPwd);
		goto lDone;
	}

	if(FAILED(hr = fastLoadSetProperties(pwszDBServer, pwszDBDatabase,
		pwszDBUser, pwszDBPwd, pIDBInit)))
	{
		// fastLoadSetProperties will send the error
		goto lDone;
	}

	// Initialize the provider
	if(FAILED(hr = pIDBInit->Initialize()))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::Initialize(%S, %S, %S, %S) - IDBInitialize::Initialize",
			pwszDBServer, pwszDBDatabase, pwszDBUser, pwszDBPwd);

		goto lDone;
	}

	if(FAILED(hr = setFastLoadProperty(TRUE, pIDBInit)))
	{
		// setFastLoadProperty sends the error
		goto lDone;
	}
	
	// Get the "create session" interface
	pIDBCreateSession = pIDBInit;
	if(pIDBCreateSession == NULL)
	{
		hr = E_FAIL;
		m_ErrorHandler.ShowError("BeginFastDataLoad, QI to IDBCreateSession failed");
		goto lDone;
	}


	// Create the damn session
	if(FAILED(hr = pIDBCreateSession->CreateSession(NULL, IID_IOpenRowset, 
		(IUnknown**) &m_pIOpenRowset)))
	{
		m_ErrorHandler.HandleError(hr,
			"BeginFastDataLoad, IDBCreateSession::CreateSession failed");
		goto lDone;
	}

	// TODO : Transaction stuff

lDone:
	return hr;
}

/*******************************************************************************
CODBWFastLoad::FastLoadOpenTable


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadOpenTable(
	LPCWSTR pwszTableName, 
	DBBINDING* rgBindings, 
	ULONG cBindings
)
{
	DBID sTableId;
	WCHAR wszTableName[128];
	CComQIPtr<IAccessor> pIA;
	HRESULT hr = S_OK;
	
	// Clean previous operations
	hr = FastLoadAbortRows();
	if(FAILED(hr))
	{
		m_ErrorHandler.ShowError(
			"CODBWSession::FastLoadOpenTable, FastLoadAbortRows failed(hr = 0x%x) (continuing)", hr);
		
		// BUGBUG: Abort?
	}

	wcsncpy(wszTableName, pwszTableName, ARRAY_ELEMENTS(wszTableName)-1);
	wszTableName[ARRAY_ELEMENTS(wszTableName)-1] = 0;
		
	// Open the connection to the target table
	sTableId.eKind = DBKIND_NAME;
	sTableId.uName.pwszName = wszTableName;
	
	if(FAILED(hr = m_pIOpenRowset->OpenRowset(NULL, &sTableId, NULL, 
		IID_IRowsetFastLoad, 0, NULL, (IUnknown**) &m_pIFastLoad)))
	{
		m_ErrorHandler.HandleError(hr,
			"BeginFastDataLoad, IOpenRowset::OpenRowset failed");
		goto lDone;
	}
	
	// Set the bindings
	pIA = m_pIFastLoad;

	if(pIA == NULL)
	{
		m_ErrorHandler.ShowError(
			"CODBWSession::FastLoadOpenTable, QI to IAccessor failed");
		hr = E_FAIL;
	}
	
	// Create the accessor
	hr = pIA->CreateAccessor(
		DBACCESSOR_ROWDATA, 
		cBindings, 
		rgBindings, 
		0, 
		&m_hFastLoadAccessor, 
		NULL
		);

	if(FAILED(hr))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWResult::SetBindings - IAccessor::CreateAccessor");
		goto lDone;
	}

lDone:
	return hr;
}


/*******************************************************************************
CODBWFastLoad::FastLoadInsertRow


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadInsertRow(void* pData)
{
	HRESULT hr = S_OK;

	// Initialized ?
	if(m_pIFastLoad == NULL)
	{
		m_ErrorHandler.ShowError(
			"CODBWSession::FastLoadInsertRow, called before initialization");
		hr = E_FAIL;
		goto lDone;
	}

	_ASSERT(m_hFastLoadAccessor);
	
	// Insert the row
	if(FAILED(hr = m_pIFastLoad->InsertRow(m_hFastLoadAccessor, pData)))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::FastLoadInsertRow, IRowsetFastLoad::InsertRow failed");
		goto lDone;
	}

lDone:
	return hr;
}

/*******************************************************************************
CODBWFastLoad::FastLoadCommitRows


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadCommitRows(BOOL bDone)
{
	HRESULT hr = S_OK;

	// The call to commit will send the rows through the wire
	// TRUE indicates that we want to close the rowset
	if(FAILED(hr = m_pIFastLoad->Commit(bDone)))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::FastLoadCommitRows, IRowsetFastLoad::Commit failed");
		goto lDone;
	}

lDone:
	return hr;
}

/*******************************************************************************
CODBWFastLoad::FastLoadAbortRows


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadAbortRows()
{
	CComQIPtr<IAccessor> pIA;
	HRESULT hr = S_OK;

	if(m_hFastLoadAccessor && m_pIFastLoad) 
	{
		pIA = m_pIFastLoad;
		
		if(pIA == NULL || FAILED(hr = pIA->ReleaseAccessor(m_hFastLoadAccessor, NULL)))
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::FastLoadAbortRows - IAccessor::ReleaseAccessor (continuing)");
		}
	}
	m_hFastLoadAccessor = 0;
	
	if(m_pIFastLoad != NULL)
	{
		m_pIFastLoad.Release();
		// ATL will set it to NULL
	}
	
	return hr;
}

/*******************************************************************************
CODBWFastLoad::FastLoadClose


*******************************************************************************/
HRESULT CODBWFastLoad::FastLoadClose()
{
	HRESULT hr = S_OK;

	// TODO : Transaction stuff

	hr = FastLoadAbortRows();

	if(m_pIOpenRowset != NULL)
	{
		m_pIOpenRowset.Release();
		// ATL will set it to NULL
	}

	return hr;
}

	
/*******************************************************************************
CODBWFastLoad::fastLoadSetProperty


*******************************************************************************/
HRESULT CODBWFastLoad::fastLoadSetProperty(
    DBPROPID PropID,
    BSTR bstrVal,
    DBPROP * pDBProp
)
{
    pDBProp->dwPropertyID = PropID;
    pDBProp->dwOptions = DBPROPOPTIONS_REQUIRED;
    pDBProp->colid = DB_NULLID;
    pDBProp->vValue.vt = VT_BSTR;
    pDBProp->vValue.bstrVal = bstrVal;

	return S_OK;
}

/*******************************************************************************
CODBWFastLoad::fastLoadSetProperties


*******************************************************************************/
HRESULT CODBWFastLoad::fastLoadSetProperties(
	LPCWSTR pwszDBServer,
	LPCWSTR pwszDBDatabase,
	LPCWSTR pwszDBUser,
	LPCWSTR pwszDBPwd,
	IDBInitialize* pIDBInit
)
{
	CComQIPtr<IDBProperties> pIDBProperties(pIDBInit);
	CComBSTR bstrDBServer(pwszDBServer);
	CComBSTR bstrDBDatabase(pwszDBDatabase);
	CComBSTR bstrDBUser(pwszDBUser);
	CComBSTR bstrDBPwd(pwszDBPwd);

    DBPROP rgDBProperties[4];
    DBPROPSET rgPropertySets[1];

	HRESULT hr = S_OK;
	
	if(pIDBProperties == NULL)
	{
		m_ErrorHandler.ShowError(
			"CODBWSession::fastLoadSetProperties, QI to IDBProperties failed");
		hr = E_FAIL;
		goto lDone;
	}

    fastLoadSetProperty(DBPROP_INIT_CATALOG, 
                 bstrDBDatabase, 
                 &rgDBProperties[0]);
    fastLoadSetProperty(DBPROP_AUTH_USERID, 
                bstrDBUser,  
                &rgDBProperties[1]);
    fastLoadSetProperty(DBPROP_AUTH_PASSWORD, 
                bstrDBPwd,  
                &rgDBProperties[2]);
    fastLoadSetProperty(DBPROP_INIT_DATASOURCE, 
                bstrDBServer,  
               &rgDBProperties[3]);

    rgPropertySets[0].rgProperties = rgDBProperties;
    rgPropertySets[0].cProperties = 4;
    rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

	if(FAILED(hr = pIDBProperties->SetProperties(1, rgPropertySets)))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::fastLoadSetProperties, IDBProperties::SetProperties failed");

		goto lDone;
	}

lDone:
	// ATL will release everything for us
	return hr;
}

/*******************************************************************************
CODBWFastLoad::setFastLoadProperty


*******************************************************************************/
HRESULT CODBWFastLoad::setFastLoadProperty(
	BOOL fSet, 
	IDBInitialize* pIDBInit
)
{
	CComQIPtr<IDBProperties> pIDBProps(pIDBInit);
    DBPROP rgProps[1];
    DBPROPSET sPropSet;
    HRESULT hr = S_OK;

    VariantInit(&rgProps[0].vValue);

	if(pIDBProps == NULL)
	{
		m_ErrorHandler.ShowError(
			"CODBWSession::setFastLoadProperty, QI to IDBProperties failed");
		hr = E_FAIL;
		goto lDone;
	}

    rgProps[0].dwOptions    = DBPROPOPTIONS_REQUIRED;
    rgProps[0].colid        = DB_NULLID;
    rgProps[0].vValue.vt    = VT_BOOL;
    rgProps[0].dwPropertyID = SSPROP_ENABLEFASTLOAD;
    rgProps[0].vValue.boolVal = VARIANT_TRUE;

    sPropSet.rgProperties    = rgProps;
    sPropSet.cProperties     = 1;
    sPropSet.guidPropertySet = DBPROPSET_SQLSERVERDATASOURCE;
	
    if(FAILED(hr = pIDBProps->SetProperties(1, &sPropSet)))
	{
		m_ErrorHandler.HandleError(hr,
			"CODBWSession::setFastLoadProperty, IDBProperties::SetProperties failed");
		hr = E_FAIL;
		goto lDone;
	}

lDone:
	
	VariantClear(&rgProps[0].vValue); 

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\ODBWResult.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      ODBWResult.cpp
//
//  Contents:  CODBWSession declaration
//
//  Author:    Daniel Caiafa (dcaiafa@microsoft.com)
//
//  Revision History:
//
//    04/03/99	dcaiafa	created
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "OleDBWrapper.h"

/******************************************************************************/

#define DW_ALIGN(x) (x + 3 & ~ 3)

/*******************************************************************************
CODBWSession::Clear

Releases any allocated memory and initializes the internal states

Parameters:
	None

Returns:
	S_OK if succeeded
	Redirects errors from IRowset::ReleaseRows, IAccessor::ReleaseAccessor
*******************************************************************************/
HRESULT CODBWSession::Clear()
{
	HRESULT hr = S_OK;

	// Release row

	if(m_hLastRow != 0)
	{
		hr = m_pIRowset->ReleaseRows(1, &m_hLastRow, NULL,	NULL, NULL);
		
		if(FAILED(hr)) 
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::Clear - IRowset::ReleaseRows");
		}

		m_hLastRow = 0;
	}

	// Release accessor
	if(m_hAccessor) {
		CComQIPtr<IAccessor> pIA(m_pIRowset);
		hr = pIA->ReleaseAccessor(m_hAccessor, NULL);
		if(FAILED(hr)) 
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::Clear - IAccessor::ReleaseAccessor");
		}
		
		m_hAccessor = 0;
	}

	// Release IRowset object
	if(m_pIRowset) {
		m_pIRowset.Release();
	}

	if(m_pIRowsetChange) {
		m_pIRowsetChange.Release();
	}
	
	// Initial state
	m_cRowsAffected = 0;
	m_bAvailable = FALSE;
	m_pLastBind = NULL;
	m_cLastBind = 0;

	return hr;
}

/*******************************************************************************
CODBWSession::InitializeWithIRowset

Initializes the object with an IRowset. This means that the client will be
able to fetch for rows using GetRows()

(internal use) called by CODBWSession::RunCommand

Parameters:
	[in] IRowset* pIRs

Returns:
	Nothing
*******************************************************************************/
HRESULT CODBWSession::InitializeWithIRowset(IRowset* pIRs)
{
	_ASSERT(NULL != pIRs);

	HRESULT hr = S_OK;

	hr = Clear();
	if(SUCCEEDED(hr)) {
		m_pIRowset = pIRs;
		m_bAvailable = TRUE;
	}
	
	return hr;
}

/*******************************************************************************
CODBWSession::InitializeWithRowsAffected

Initializes the object with the number of rows affected by the command execution. 
This means that the client won't be able to fetch for rows but he will be able 
to get the Rows affected using GetRowsAffected()

(internal use) called by CODBWSession::RunCommand

Parameters:
	[in] LONG cRowsAffected 

Returns:
	S_OK if succeeded
	Redirects Clear() errors
*******************************************************************************/
HRESULT CODBWSession::InitializeWithRowsAffected(DBROWCOUNT cRowsAffected)
{
	HRESULT hr = S_OK;
	
	hr = Clear();
	if(SUCCEEDED(hr)) {
		m_cRowsAffected = cRowsAffected;
		m_bAvailable = TRUE;
	}

	return hr;
}

/*******************************************************************************
CODBWSession::SetBindings

Set the bindings for accessing the rows' data. 
Use the ODBWBinding* inline functions to help filling the DBBINDING array

Parameters:
	[in] const DBBINDING* rgBindings (see OLE DB docs for IAccessor::CreateAccessor)
	[in] ULONG cBindings

Returns:
	S_OK if succeeded
	Redirects IAccessor::ReleaseAccessor, IAccessor::CreateAccessor errors
*******************************************************************************/
HRESULT CODBWSession::SetBindings(const DBBINDING* rgBindings, ULONG cBindings)
{
	_ASSERT(m_pIRowset);
	_ASSERT(rgBindings);
	_ASSERT(cBindings > 0);

	HRESULT hr = S_OK;
    
    // I love ATL
	CComQIPtr<IAccessor> pIA;
	
    if ( m_pIRowset == NULL )
    {
        hr = E_POINTER;
        goto _out;
    }

    pIA = m_pIRowset;

    if ( pIA == NULL)
    {
        hr = E_NOINTERFACE;
        goto _out;
    }
    
	// We're going to create an accessor. If we already have one, destroy it
	if(m_hAccessor) 
	{
		hr = pIA->ReleaseAccessor(m_hAccessor, NULL);
		if(SUCCEEDED(hr)) 
		{
			m_hAccessor = 0;
		}
		else
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::SetBindings - IAccessor::ReleaseAccessor");
			goto _out;
		}
	}
	
	if(SUCCEEDED(hr))					// Testing if ReleaseAccessor succeeded
	{
		// Create the accessor
		hr = pIA->CreateAccessor(
			DBACCESSOR_ROWDATA, 
			cBindings, 
			rgBindings, 
			0, 
			&m_hAccessor, 
			NULL
			);

		if(SUCCEEDED(hr))
		{
			m_pLastBind = rgBindings;
			m_cLastBind = cBindings;
		}
		else
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::SetBindings - IAccessor::CreateAccessor");
		}

	}
	
 _out:
    return hr;
}

/*******************************************************************************
CODBWSession::Restart

Set the "cursor" to the beginning of the rowset

Parameters:
	None

Returns:
	Redirects IRowset->RestartPosition results
*******************************************************************************/
HRESULT CODBWSession::Restart()
{
	_ASSERT(m_pIRowset);
	
	HRESULT hr = S_OK;
	hr = m_pIRowset->RestartPosition(DB_NULL_HCHAPTER);

	return hr;
}

/*******************************************************************************
CODBWSession::GetRows

Get a bunch of rows at a time. 
MUST call SetBindings before using this method.

Parameters:
	[in,out] ULONG* cRows: [in]#of rows to be read [out]#of rows actually read
	[out] VOID* pBuffer: buffer pre-allocated by the client
	[int] ULONG iElemSize: sizeof one element of the buffer
	[in]  LONG	lOffset : number of rows to skip (only supported on 1st call)
	[in]  CODBWDeferedBindings* pDeferedBindings : callback object for additional bindings

Returns:
	S_OK if succeeded
	DB_S_ENDOFROWSET no more rows to read. No rows read.
	Redirects the IRowset->ReleaseRows, IRowset->GetNextRows, IRowset->GetData
*******************************************************************************/
HRESULT CODBWSession::GetRows(
	DBCOUNTITEM* pcRows, 
	VOID* pBuffer, 
	ULONG dwElemSize, 
	LONG lOffset, 
	CODBWDeferedBindings* pDeferedBindings
)
{
	HRESULT hr = S_OK;

	// Requirements check
	
	if( m_pIRowset != NULL && 
		m_hAccessor != NULL)
	{

		DBCOUNTITEM cTotal = 0;

		while( (S_OK == hr) &&
			(cTotal < (DBCOUNTITEM)*pcRows) )
		{
			
			DBCOUNTITEM cRowsRead = 0;

			// Release previous rows
			
			if(m_hLastRow != NULL)
			{
				
				hr = m_pIRowset->ReleaseRows(1, &m_hLastRow, NULL, NULL, NULL);

				if(FAILED(hr))
				{
					m_ErrorHandler.HandleError(hr,
						"CODBWSession::GetRows - IRowset::ReleaseRows");
				}

				m_hLastRow = NULL;
			}

			if(SUCCEEDED(hr))
			{

				// Read one row
				
				HROW* phRow = &m_hLastRow;
				
				hr = m_pIRowset->GetNextRows(DB_NULL_HCHAPTER, lOffset, 1, 
					(DBCOUNTITEM*) &cRowsRead, &phRow);

				if(	SUCCEEDED(hr) && 
					cRowsRead > 0)
				{

					// Read it into the caller buffer

					hr = m_pIRowset->GetData(m_hLastRow, m_hAccessor, 
						(char*)pBuffer + (dwElemSize * cTotal) );

					if(hr != S_OK)
					{
						m_ErrorHandler.ShowError(
							"CODBWSession::GetRows - IRowset::GetData returned 0x%08x", hr);
					}

					// Apply extra bindings if necessary

					if (pDeferedBindings && !FAILED(hr))
					{
						hr = pDeferedBindings->Apply(m_pIRowset, m_hLastRow, cTotal);
					}
				}
			}
		
			cTotal += cRowsRead;
		}

		*pcRows = cTotal;

		// This check is for backwards compability. We cannot returns 
		// DB_S_ENDOFROWSET if we're returning any rows. 
		
		if(	DB_S_ENDOFROWSET == hr && 
			cTotal > 0  )
		{
			hr = S_OK;
		}
	}
	else
	{
		hr = E_FAIL;

		m_ErrorHandler.ShowError("CODBWSession::GetRows - No IRowset or hAccessor");
	}
	
	
	
	return hr;
}


/*******************************************************************************
CODBWSession::GetLastRow

  Get the last row read with GetRows. Very useful with multiple bindings.

Returns:
  S_OK Succeeded
  S_FALSE No last row
  HRESULT errors
*******************************************************************************/
HRESULT CODBWSession::GetLastRow(VOID* pBuffer)
{
	_ASSERT(m_pIRowset);
	_ASSERT(m_hAccessor);
	HRESULT hr = S_OK;

	if(m_hLastRow != 0)
	{
		hr = m_pIRowset->GetData(
			m_hLastRow, 
			m_hAccessor, 
			pBuffer);

		if(hr != S_OK)
		{
			m_ErrorHandler.HandleError(hr,
				"CODBWSession::GetLastRow - IRowset::GetData");
		}
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}

HRESULT CODBWSession::SetLastRow(VOID* pBuffer)
{
	_ASSERT(m_pIRowsetChange);
	_ASSERT(m_hAccessor);

	HRESULT hr = S_OK;

	if(	(m_pIRowsetChange != NULL) &&
		(m_hAccessor != NULL) )
	{
		if(m_hLastRow != 0)
		{
			hr = m_pIRowsetChange->SetData(m_hLastRow,
				m_hAccessor,
				pBuffer);
		}
		else
		{
			hr = E_FAIL;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

HRESULT CODBWSession::InitializeBuffer(
	void* pBuffer,
	ULONG cBuffer
)
{
	HRESULT hr = S_OK;

	// We're mostly concerned about strings

	for(ULONG ulBindNdx = 0; SUCCEEDED(hr) && (ulBindNdx < m_cLastBind); ulBindNdx++)
	{
		const DBBINDING* pBind = &m_pLastBind[ulBindNdx];
		if( (pBind->dwPart & DBPART_VALUE) == DBPART_VALUE)
		{
			switch(pBind->wType)
			{
			case DBTYPE_I4:
				if(pBind->obValue + sizeof(INT) <= cBuffer)
					*((INT*)((BYTE*)pBuffer + pBind->obValue)) = 0;
				else
					hr = E_FAIL;
                break;

			case DBTYPE_STR:
				if(pBind->obValue + sizeof(CHAR) <= cBuffer)
					*((CHAR*)((BYTE*)pBuffer + pBind->obValue)) = 0;
				else
					hr = E_FAIL;
                break;
		
			case DBTYPE_WSTR:
				if(pBind->obValue + sizeof(WCHAR) <= cBuffer)
					*((WCHAR*)((BYTE*)pBuffer + pBind->obValue)) = 0;
				else
					hr = E_FAIL;
                break;

			case DBTYPE_DATE:
				if(pBind->obValue + sizeof(DATE) <= cBuffer)
					*((DATE*)((BYTE*)pBuffer + pBind->obValue)) = 0;
				else
					hr = E_FAIL;
                break;
            }
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED_)
#define AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_FREE_THREADED

#include <atlbase.h>
#include <stdio.h>
#include <stdafx.h>

#ifndef ARRAY_ELEMENTS
    #define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\webstore\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_oledbw_none_12.4.56.0_none_5181c5a7cff24069
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=oledbw
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.manifest
XP_MANIFEST_PATH=manifests\x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.cat
XP_CATALOG_PATH=manifests\x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.cat
XP_PAYLOAD_PATH=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=oledbw,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\ODBWSession.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      ODBWSession.cpp
//
//  Contents:  CODBWSession
//
//  Author:    Daniel Caiafa (dcaiafa@microsoft.com)
//
//  Revision History:
//
//    04/03/99    dcaiafa    created
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "OleDBWrapper.h"

const GUID CLSID_SQLOLEDB = {0xc7ff16cL,0x38e3,0x11d0,{0x97,0xab,0x0,0xc0,0x4f,0xc2,0xad,0x98}};

IUnknown* CODBWSession::s_punkDataInitialize = NULL;
LONG CODBWSession::s_lRefs = 0;





/******************************************************************************/

CODBWSession::CODBWSession()
    : m_ErrorHandler((CODBWErrorConnectionPoint*)this)
{
    m_pIDBCreateCommand = NULL;
    m_pIMultipleResults = NULL;

    m_wszConnStr[0] = 0;
    m_wszCommand[0] = 0;

    // Connection and command time-outs in seconds    
    m_lConnTimeOut = 15;
    m_lCommandTimeOut = 60;

    // Cached rows and accessors
    m_hAccessor = 0;                        
    m_hLastRow = 0;

    // Buffer to store parameters
    m_pHeapParamBuffer = NULL;
    m_pParamBuffer = m_StackParamBuffer;
    m_ParamBufferSize = MAX_PARAM_COUNT;

    // Last binding pointer. Used by InitializeBuffer
    m_pLastBind = NULL;
    m_cLastBind = 0;

    // Prevent infinite recursion in ClearConnection
    m_bAvoidRecursion = FALSE;

    // Enable a rowset returned by a query to be changed
    m_bChangeRowset = FALSE;

    // Debugging level
    m_iDebugLevel = 1;

    // Enable random column access order
    m_bRandomAccessOrder = FALSE;
}

CODBWSession::~CODBWSession()
{
    Clear();
    ReleaseConnection();

    if(m_pHeapParamBuffer)
    {
        delete m_pHeapParamBuffer;
        m_pHeapParamBuffer = NULL;
    }
}

/*******************************************************************************
CODBWSession::InitializeConnectionPooling

Allows OLE DB to cache the connections.
Should be called before using any connections.
Call TerminateConnectionPooling at the end of the program.

Parameters:
    none
  
Returns:
    S_OK if succeeded
    Redirects ::CoCreateInstance errors
*******************************************************************************/
HRESULT CODBWSession::InitializeConnectionPooling()
{
    HRESULT hr = S_OK;
    
    // So here is the trick:
    // OLE DB requires one living component to keep the connections cache. 
    // This method creates one instance of MSDAINITIALIZE and keeps it
    // until TerminateConnectionPooling is called

    if((InterlockedIncrement(&s_lRefs) == 1) && (NULL == s_punkDataInitialize))
    {
        hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_ALL, IID_IUnknown, (LPVOID*)&s_punkDataInitialize);
        if(FAILED(hr))
        {
            s_punkDataInitialize = NULL;
        }
    }

    return hr;
}

/*******************************************************************************
CODBWSession::TerminateConnectionPooling

Release the resources allocated for connection pooling

Parameters:
    none
  
Returns:
    S_OK if succeeded
*******************************************************************************/
HRESULT CODBWSession::TerminateConnectionPooling()
{
    HRESULT hr = S_OK;

    if((InterlockedDecrement(&s_lRefs) == 0) && (NULL != s_punkDataInitialize))
    {
        s_punkDataInitialize->Release();
        s_punkDataInitialize = NULL;
    }

    return hr;
}

/*******************************************************************************
CODBWSession::SetEventCallback

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::SetEventCallback(LPEVENTCALLBACK lpEventCallback)
{
    m_ErrorHandler.SetCallback(lpEventCallback);
    return S_OK;
}

/*******************************************************************************
CODBWSession::Initialize
(obsolete, use InitializeEx)

Opens a OLE DB connection to a SQL Server. The wszConnStr is a connection 
string in the SQL Server specific style
  
Parameters:
  
Returns:

*******************************************************************************/
// BUGBUG: Call InitializeEx to avoid redundant code
HRESULT CODBWSession::Initialize(
    LPCWSTR wszConnStr, 
    BOOL bRead /* = TRUE */
)
{
    HRESULT hr = S_OK;
    CComQIPtr<IDBProperties> pIDBProp;
    CComQIPtr<IDBCreateSession> pIDBCS;
    CComQIPtr<IDataInitialize>  pIDataInit;
    CComPtr<IDBInitialize> pIDBInit;
    DBPROP rgProps[2];
    DBPROPSET rgPropSet;
    CComBSTR bstrConnStr(wszConnStr);

    wcsncpy(m_wszConnStr, wszConnStr, ARRAY_ELEMENTS(m_wszConnStr));
    m_wszConnStr[ARRAY_ELEMENTS(m_wszConnStr) - 1] = 0;

    // Get the ROOT Enumerator Object 
    if(s_punkDataInitialize != NULL) 
    {
        pIDataInit = s_punkDataInitialize;
        if(pIDataInit == NULL)
        {
            hr = E_FAIL;
            m_ErrorHandler.ShowError("Failed to create MSDAINITIALIZE class (Wrong DAO version?)");
            goto _out;
        }
    }
    else 
    {
        hr = pIDataInit.CoCreateInstance(CLSID_MSDAINITIALIZE);
        if(FAILED(hr))
        {
            m_ErrorHandler.ShowError("Failed to create MSDAINITIALIZE class (Wrong DAO version?)");
            goto _out;
        }
    }
    
    // Create the OLE DB data source
    hr = pIDataInit->CreateDBInstance(
        CLSID_SQLOLEDB, 
        NULL, 
        CLSCTX_ALL, 
        NULL, 
        IID_IDBInitialize, 
        (IUnknown**) &pIDBInit
        );
    
    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDataInitialize::CreateDBInstance", wszConnStr);
        goto _out;
    }


    // Set the properties (Provider connection string and connection time-out)
    VariantInit(&rgProps[0].vValue);
    rgProps[0].dwPropertyID        = DBPROP_INIT_PROVIDERSTRING;
    rgProps[0].dwOptions        = DBPROPOPTIONS_REQUIRED;
    rgProps[0].vValue.vt        = VT_BSTR;
    rgProps[0].vValue.bstrVal    = bstrConnStr;

    VariantInit(&rgProps[1].vValue);
    rgProps[1].dwPropertyID        = DBPROP_INIT_TIMEOUT;
    rgProps[1].dwOptions        = DBPROPOPTIONS_REQUIRED;
    rgProps[1].vValue.vt        = VT_I4;
    rgProps[1].vValue.lVal        = m_lConnTimeOut;

    rgPropSet.rgProperties = rgProps;
    rgPropSet.cProperties = 2;
    rgPropSet.guidPropertySet = DBPROPSET_DBINIT;

    pIDBProp = pIDBInit;
    hr = pIDBProp->SetProperties(1, &rgPropSet);
    
    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDBProperties::SetProperties", wszConnStr);
        goto _out;
    }

    // Initialize the provider
    hr = pIDBInit->Initialize();

    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDBInitialize::Initialize", wszConnStr);
        goto _out;
    }

    // Create the session
    pIDBCS = pIDBInit;
    hr = pIDBCS->CreateSession(
        NULL, 
        IID_IDBCreateCommand, 
        (IUnknown**) &m_pIDBCreateCommand
        );

    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDBCreateSession::CreateSession", wszConnStr);
        goto _out;
    }

    // Query for the ITransaction interface
    hr = m_pIDBCreateCommand->QueryInterface(__uuidof(ITransactionLocal), (void**)&m_pITransaction);
    
    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - failed to QI for ITransaction", wszConnStr);
        goto _out;
    }

_out:
    if(FAILED(hr))
    {
        // Although there will be no connection to be released, 
        // the connection counters will be decremented
        ReleaseConnection();
    }

    return hr;
}

/*******************************************************************************
CODBWSession::InitializeEx

Same as Initialize but uses OLE DB connection string syntax instead of 
SQL Server specific. The OLE DB connection string offer more options and 
allows the use of SQL Server specific parameters using the property "Extended
Properties" Ex: Provider=SQLOLEDB;ExtendedProperties="Server=spidey1; ..."
  
Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::InitializeEx(
    LPCWSTR wszConnStr, 
    BOOL bRead /* = TRUE */
)
{
    HRESULT hr = S_OK;
    CComQIPtr<IDBProperties> pIDBProp;
    CComQIPtr<IDBCreateSession> pIDBCS;
    CComQIPtr<IDataInitialize>  pIDataInit;
    CComPtr<IDBInitialize> pIDBInit;

    wcsncpy(m_wszConnStr, wszConnStr, ARRAY_ELEMENTS(m_wszConnStr));
    m_wszConnStr[ARRAY_ELEMENTS(m_wszConnStr) - 1] = 0;
    
    // Get the ROOT Enumerator Object 
    if(s_punkDataInitialize != NULL) 
    {
        pIDataInit = s_punkDataInitialize;
        if(pIDataInit == NULL)
        {
            hr = E_FAIL;
            m_ErrorHandler.ShowError("Failed to create MSDAINITIALIZE class (Wrong DAO version?)");
            goto _out;
        }
    }
    else 
    {
        hr = pIDataInit.CoCreateInstance(CLSID_MSDAINITIALIZE);
        if(FAILED(hr))
        {
            m_ErrorHandler.ShowError("Failed to create MSDAINITIALIZE class (Wrong DAO version?)");
            goto _out;
        }
    }
    
    // Create the OLE DB data source
    hr = pIDataInit->GetDataSource(
        NULL,
        CLSCTX_ALL,
        wszConnStr,
        IID_IDBInitialize,
        (IUnknown**) &pIDBInit);

    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDataInitialize::GetDataSource", wszConnStr);
        goto _out;
    }

    // Initialize the provider
    hr = pIDBInit->Initialize();

    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDBInitialize::Initialize", wszConnStr);
        goto _out;
    }

    // Create the session
    pIDBCS = pIDBInit;
    hr = pIDBCS->CreateSession(
        NULL, 
        IID_IDBCreateCommand, 
        (IUnknown**) &m_pIDBCreateCommand
        );

    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - IDBCreateSession::CreateSession", wszConnStr);
        goto _out;
    }

    // Query for the ITransaction interface
    hr = m_pIDBCreateCommand->QueryInterface(__uuidof(ITransactionLocal), (void**)&m_pITransaction);
    
    if(FAILED(hr))
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Initialize(%S) - failed to QI for ITransaction", wszConnStr);
        goto _out;
    }

_out:
    if(FAILED(hr))
    {
        // Although there will be no connection to be released, 
        // the connection counters will be decremented
        ReleaseConnection();
    }

    return hr;
}

/*******************************************************************************
CODBWSession::ReleaseConnection

Parameters:
  
Returns:

*******************************************************************************/
void CODBWSession::ReleaseConnection()
{
    Clear();

    if(m_pIComm != NULL)
    {
        m_pIComm.Release();
        // ATL set the pointer to null
    }
    // Release any old results
    if(m_pIMultipleResults) 
    {
        m_pIMultipleResults.Release();
        // ATL set the pointer to null
    }
    if(m_pIRowsetChange)
    {
        m_pIRowsetChange.Release();
    }
    if(m_pIDBCreateCommand != NULL)
    {
        m_pIDBCreateCommand.Release();
    }
    if(m_pITransaction != NULL)
    {
        m_pITransaction.Release();
        // ATL set the pointer to null
    }
}


/*******************************************************************************
CODBWSession::RunCommand

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::RunCommand(
    LPCWSTR wszCommand,
    CODBWParameterInfo* pParameterInfo,
    void* pData
)
{
    if(pParameterInfo != NULL)
    {
        return RunCommandEx(
            wszCommand,
            pParameterInfo->m_cParamCount,
            pParameterInfo->m_rgParamOrdinals,
            pParameterInfo->m_rgParamBindingInfo,
            pParameterInfo->m_rgDBBinding,
            pData);
    }
    else
    {
        return RunCommandEx(
            wszCommand,
            0,
            NULL,
            NULL,
            NULL,
            NULL);
    }
}


/*******************************************************************************
CODBWSession::OpenTransaction

Parameters:
  
Returns:

*******************************************************************************/
 HRESULT CODBWSession::OpenTransaction(
     ITransaction **pITransaction // out parameter
 )
 {
    HRESULT hr = S_OK;

    ITransactionDispenser *pITransactionDispenser = NULL;

    if (NULL == pITransaction) 
    {
        hr =  E_INVALIDARG;
        goto _out;
    }

    *pITransaction = NULL; //initializing 

    // Obtain an interface pointer from MS DTC proxy.
    hr = DtcGetTransactionManager(NULL,      // LPTSTR    pszHost,
                                    NULL,                             
                                    IID_ITransactionDispenser,        
                                    0,                                
                                    0,                                 
                                    0,                                
                                    (void **)&pITransactionDispenser 
                                    ) ;
    if (FAILED (hr) || (pITransactionDispenser == NULL)){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::OpenTransaction - DtcGetTransactionManager failed");
        goto _out;
    }

    if (FAILED(hr = pITransactionDispenser->BeginTransaction( NULL, 
                                                            ISOLATIONLEVEL_READCOMMITTED, 
                                                            ISOFLAG_RETAIN_DONTCARE,
                                                            NULL, 
                                                            pITransaction))){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::OpenTransaction - pTransactionDispenser->BeginTransaction failed.");
        goto _out;
    
    }

    _out:
        if(pITransactionDispenser)
            pITransactionDispenser->Release();
        return hr;
 }

 /*******************************************************************************
CODBWSession::JoinTransaction

Parameters:
  
Returns:

*******************************************************************************/
 HRESULT CODBWSession::EnlistInTransaction(
     ITransaction *pITransaction 
 )
 {
    HRESULT hr = S_OK;
    ITransactionJoin *pITransactionJoin = NULL;

    if (NULL == pITransaction) 
    {
        hr =  E_INVALIDARG;
        goto _out;
    }

    hr = m_pIDBCreateCommand->QueryInterface(IID_ITransactionJoin, (void**) &pITransactionJoin);    
    if (FAILED (hr)){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::JoinTransaction - QueryInterface for ITransactionJoin failed");
        goto _out;
    }
    _ASSERT (pITransactionJoin);   

    if (FAILED(hr = pITransactionJoin->JoinTransaction((IUnknown*) pITransaction,
                                                       ISOLATIONLEVEL_READCOMMITTED,
                                                        0,
                                                        NULL))){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::JoinTransaction - pITransactionJoin->JoinTransaction failed.");
        goto _out;
    }
    _out:
        if(pITransactionJoin)
            pITransactionJoin->Release();
        return hr;
 } 

 /*******************************************************************************
CODBWSession::UnEnlistFromTransaction

Parameters:
  
Returns:

*******************************************************************************/
 HRESULT CODBWSession::UnEnlistFromTransaction()
 {
    HRESULT hr = S_OK;
    ITransactionJoin *pITransactionJoin = NULL;

    hr = m_pIDBCreateCommand->QueryInterface(IID_ITransactionJoin, (void**) &pITransactionJoin);    
    if (FAILED (hr)){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::JoinTransaction - QueryInterface for ITransactionJoin failed");
        goto _out;
    }
    _ASSERT (pITransactionJoin);   

    if (FAILED(hr = pITransactionJoin->JoinTransaction((IUnknown*) NULL,
                                                        0,
                                                        0,
                                                        NULL))){
        m_ErrorHandler.HandleError(hr,
                "CODBWSession::UnEnlistFromTransaction- pITransactionJoin->JoinTransaction failed.");
        goto _out;
    }

    _out:
        if(pITransactionJoin)
            pITransactionJoin->Release();
        return hr;
 } 

/*******************************************************************************
CODBWSession::RunCommandEx

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::RunCommandEx(
    LPCWSTR wszCommand,
    ULONG cParamCount,
    DBORDINAL* rgParamOrdinals,
    DBPARAMBINDINFO* rgParamBindInfo,
    DBBINDING* rgBinding,
    void* pData,
        BOOL fSaveCommand  // Used to print the command in debug spew, but it is expensive so it is allowed to be turned off.
)
{
    HRESULT hr = S_OK;
    DBPROP rgProps[3];
    DWORD cProps = 0;
    DBPROPSET rgPropSet;
    CComQIPtr<ICommandText> pICT;
    CComQIPtr<ICommandWithParameters> pICWP;
    CComQIPtr<IAccessor> pIA;
    CComQIPtr<ICommandProperties> pICP;
    DBPARAMS Params;
    DBPARAMS* pParams = NULL;
    HACCESSOR hAccessor = NULL;

    _ASSERT(m_pIDBCreateCommand != NULL);
    if(m_pIDBCreateCommand == NULL)
    {
        m_ErrorHandler.ShowError(
            "CODBWSession::RunCommandEx called before a session was opened !!!");
        hr = E_FAIL;
        goto out;
    }

        // This is expensive, so only do it if the caller asked us to
        if( fSaveCommand )
        {
            saveCommand(
                wszCommand,
                cParamCount,
                rgParamOrdinals,
                rgParamBindInfo,
                rgBinding,
                pData);
        }
        else
        {
            m_wszCommand[ 0 ] = 0;
        }
    
    if(m_pIComm != NULL)
    {
        m_pIComm.Release();
        // ATL set the pointer to null
    }
        
    // Create a command
    hr = m_pIDBCreateCommand->CreateCommand(
        NULL, 
        IID_ICommandText, 
        (IUnknown**) &m_pIComm
        );
    
    if(FAILED(hr)) 
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::RunCommandEx(%S) - IDBCreateCommand::CreateCommand", wszCommand);

        goto out;
    }

    // Set the text
    pICT = m_pIComm;
    hr = pICT->SetCommandText(
        DBGUID_DBSQL, 
        wszCommand
        );
    
    if(FAILED(hr)) 
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::RunCommandEx(%S) - ICommandText::SetCommandText", wszCommand);

        goto out;
    }

    // Properties setting
    
    // Command time out
    
    VariantInit(&rgProps[cProps].vValue);
    rgProps[cProps].dwPropertyID    = DBPROP_COMMANDTIMEOUT;
    rgProps[cProps].dwOptions        = DBPROPOPTIONS_REQUIRED;
    rgProps[cProps].colid            = DB_NULLID;
    rgProps[cProps].vValue.vt        = VT_I4;
    rgProps[cProps].vValue.lVal        = m_lCommandTimeOut;
    cProps++;

    // Access order

    VariantInit(&rgProps[cProps].vValue);
    rgProps[cProps].dwPropertyID    = DBPROP_ACCESSORDER;
    rgProps[cProps].dwOptions        = DBPROPOPTIONS_REQUIRED;
    rgProps[cProps].dwStatus        = 0;
    rgProps[cProps].colid            = DB_NULLID;
    rgProps[cProps].vValue.vt        = VT_I4;
    V_I4(&rgProps[cProps].vValue)    = m_bRandomAccessOrder ? DBPROPVAL_AO_RANDOM : DBPROPVAL_AO_SEQUENTIAL;
    cProps++;

    if(m_bChangeRowset)
    {
    
        // Change rowset
        
        VariantInit(&rgProps[cProps].vValue);
        rgProps[cProps].dwPropertyID    = DBPROP_UPDATABILITY;
        rgProps[cProps].dwOptions        = DBPROPOPTIONS_REQUIRED;
        rgProps[cProps].dwStatus        = DBPROPSTATUS_OK;
        rgProps[cProps].colid            = DB_NULLID;
        rgProps[cProps].vValue.vt        = VT_I4;
        V_I4(&rgProps[cProps].vValue)    = DBPROPVAL_UP_CHANGE;
        
        cProps++;
    }

    // Link the properties

    rgPropSet.rgProperties = rgProps;
    rgPropSet.guidPropertySet = DBPROPSET_ROWSET;
    rgPropSet.cProperties = cProps;

     // Set the properties
    pICP = m_pIComm;
    hr = pICP->SetProperties(1, &rgPropSet);
    
    if(FAILED(hr)) 
    {
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::RunCommandEx(%S) - ICommandProperties::SetProperties", wszCommand);

        goto out;
    }

    // Release any old results
    if(m_pIMultipleResults) 
        m_pIMultipleResults.Release();
            
    if(cParamCount != 0) {

        // Set parameters binding
        pICWP = m_pIComm;
        hr = pICWP->SetParameterInfo(
            cParamCount, 
            rgParamOrdinals,
            rgParamBindInfo
            );
        
        if(FAILED(hr)) 
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RunCommandEx(%S) - ICommandWithParameters::SetParameterInfo", wszCommand);

            goto out;
        }
        
        // Create the accessor
        pIA = m_pIComm;
        
        hr = pIA->CreateAccessor(
            DBACCESSOR_PARAMETERDATA,
            cParamCount,
            rgBinding,
            0,
            &hAccessor,
            NULL);
        
        if(FAILED(hr)) 
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RunCommandEx(%S) - IAccessor::CreateAccessor", wszCommand);
            
            goto out;
        }
        
        Params.pData = pData;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;
        
        pParams = &Params;

    }

    if(m_bChangeRowset)
    {
        hr = m_pIComm->Execute(NULL, IID_IRowsetChange, pParams, NULL, (IUnknown**) &m_pIRowsetChange);

        if(FAILED(hr)) 
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RunCommandEx(%S) - ICommand::Execute - ConnStr = %S", wszCommand, m_wszConnStr);

            goto out;
        }

        hr = m_pIRowsetChange->QueryInterface(IID_IRowset, (void**) &m_pIRowset);
        
        if(    FAILED(hr) ||
            m_pIRowset == NULL)
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RunCommandEx(%S) - QI for IRowset failed - ConnStr = %S", wszCommand, m_wszConnStr);
        }
    }
    else
    {
        hr = m_pIComm->Execute(NULL, IID_IMultipleResults, pParams, NULL, (IUnknown**) &m_pIMultipleResults);


        if(FAILED(hr))
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RunCommandEx(%S) - ICommand::Execute - ConnStr = %S", wszCommand, m_wszConnStr);

            goto out;
        }
    
        hr = NextResult();
    }

out :
    
    if(hAccessor && pIA != NULL)
    {
        pIA->ReleaseAccessor(hAccessor, NULL);
    }        


    return hr;
}

 
/*******************************************************************************
CODBWSession::NextResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::NextResult()
{
    _ASSERT(m_pIMultipleResults);    // Cannot be called before an RunCommand

    HRESULT hr = S_OK;
    
    if( (m_pIMultipleResults != NULL) &&
        ! m_bChangeRowset)
    {
        // Release the former result (if it exists)
        Clear();                // In order to GetResult succeed we MUST release
                                        // the former IRowset.

        // Get the next result    
        DBROWCOUNT cRowsAffected;
        CComPtr<IRowset> pIRowset;

        hr = m_pIMultipleResults->GetResult(
            NULL,
            0,
            IID_IRowset,
            &cRowsAffected,
            (IUnknown**) &pIRowset
            );
        
        if(SUCCEEDED(hr)) {
            switch(hr) 
            {
            case DB_S_NORESULT:
            case DB_S_STOPLIMITREACHED:
                break;
            
            default:
                if(pIRowset) 
                {
                    // The result is a rowset
                    InitializeWithIRowset(pIRowset);
                }
                else
                {
                    // The result isn't a rowset
                    InitializeWithRowsAffected(cRowsAffected);
                }
            }
        }
        else
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::NextResult - IMultipleResults::GetResult");
        }
        

        if(FAILED(hr))
        {
            clearConnection();
        }
    }
    else
    {
        
        // Rowset is updatable or no results were returned by the stored procedure. 

        hr = DB_S_NORESULT;
    }
    
    return hr;
}

/*******************************************************************************
CODBWSession::NextRowsetResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::NextRowsetResult()
{
    _ASSERT(m_pIMultipleResults);    // Cannot be called before an RunCommand

    HRESULT hr;

    do {
        hr = NextResult();
    } while (SUCCEEDED(hr) && hr != DB_S_NORESULT && !IsRowset());

    return hr;
}


/*******************************************************************************
CODBWSession::CleanUpResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::CleanUpResult()
{
    HRESULT hr = S_OK;

    if(m_pIMultipleResults != NULL)
    {
        while(S_OK == hr)
        {
            hr = NextResult();
        }
    }
    else
    {
        // CleanUpResults was called before RunCommand. No results need to
        // be cleaned up. No work to do. Return S_OK.
    }

    return hr;
}


/*******************************************************************************
CODBWSession::BeginTransaction

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::BeginTransaction()
{
    HRESULT hr = S_OK;

    if(m_pITransaction != NULL)
    {
        // I know that this looks strange and it looks like there is a QueryInterface
        // missing here but that's the way this is implemented. Actually ILocalTransaction
        // is derivated directly from ITransaction
        ITransactionLocal* pITransactionLocal = (ITransactionLocal*) ((ITransaction*)m_pITransaction);
        
        hr = pITransactionLocal->StartTransaction(ISOLATIONLEVEL_REPEATABLEREAD,
            0, NULL, NULL);

        if(FAILED(hr))
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::BeginTransaction() - failed to start transaction "
                "(ITransactionLocal::StartTransaction failed) ");
        }

    }
    else
    {
        hr = E_FAIL;
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::BeginTransaction() - Session not initialized (m_pITransaction == NULL)");
    }

    return hr;
}

/*******************************************************************************
CODBWSession::Commit

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::Commit()
{
    HRESULT hr = S_OK;

    if(m_pITransaction != NULL)
    {
        if(FAILED(hr = m_pITransaction->Commit(FALSE, XACTTC_SYNC, 0)))
        {
            m_ErrorHandler.HandleError(hr,
                "CODBWSession::Commit() - failed to commit (ITransaction::Commit failed) ");
        }
    }
    else
    {
        hr = E_FAIL;
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::Commit() - Session not initialized (m_pITransaction == NULL)");
        
    }

    return hr;
}

/*******************************************************************************
CODBWSession::RollBack

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CODBWSession::RollBack()
{
    HRESULT hr = S_OK;

    if(m_pITransaction != NULL)
    {
        if(FAILED(hr = m_pITransaction->Abort(NULL, FALSE, FALSE)))
        {
            /* LOG SPAMMER 
            
              // The transaction have probably been cleared by the stored procedure
              // itself. This is not really an error and an event should not be logged

            m_ErrorHandler.HandleError(hr,
                "CODBWSession::RollBack() - failed to rollback (ITransaction::Abort failed) ");

            */
        }
    }
    else
    {
        hr = E_FAIL;
        m_ErrorHandler.HandleError(hr,
            "CODBWSession::RollBack() - Session not initialized (m_pITransaction == NULL)");
        
    }

    return hr;
}

/*******************************************************************************
CODBWSession::GetConnectionInfo

*******************************************************************************/
HRESULT CODBWSession::GetConnectionInfo(
    BSTR* pbstrConnInfo
)
{
    HRESULT hr = S_OK;

    if(*m_wszConnStr != 0)
    {
        *pbstrConnInfo = SysAllocString(m_wszConnStr);
        if(NULL == *pbstrConnInfo)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/*******************************************************************************
CODBWSession::GetCommandInfo

*******************************************************************************/
HRESULT CODBWSession::GetCommandInfo(
    BSTR* pbstrCommandInfo
)
{
    HRESULT hr = S_OK;

    if(*m_wszCommand != 0)
    {
        *pbstrCommandInfo = SysAllocString(m_wszCommand);
        if(NULL == *pbstrCommandInfo)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/*******************************************************************************
CODBWSession::saveCommand

*******************************************************************************/
void CODBWSession::saveCommand(
    LPCWSTR pwszCommand,
    ULONG cParamCount,
    DBORDINAL * rgParamOrdinals,
    DBPARAMBINDINFO* rgParamBindInfo,
    DBBINDING* rgBinding,
    void* pData
)
{
//    SN_CONTEXT("OLEDBW!CODBWSession::saveCommand");
    
    DWORD cchCommand = 0;
    DWORD cchCopied = 0;

    m_wszCommand[0] = 0;
    
    if(pwszCommand != NULL)
    {
        // BUGBUG: Perf issue. Consider using special string copy functions
        // instead of snwprintf
        
        // Add the command
        cchCopied = wcslen(pwszCommand);
        wcsncpy(m_wszCommand + cchCommand, pwszCommand, MAX_SIZE_COMMAND - cchCommand - 2);
        cchCommand += cchCopied;
        
        // If the parameter count is > 0 AND the debug level is >= 2
        // Add the parameters passed by this command
//        if(    cParamCount != 0 && (m_iDebugLevel >= 2 || SN_ISDEBUG() ))
        if(    cParamCount != 0 && (m_iDebugLevel >= 2))
        {
            
            for(ULONG ulParam=0; ulParam < cParamCount; ulParam++)
            {
                BOOL bAvailable = TRUE;
                BOOL  bLength = FALSE;
                DWORD dwLength = 0;

                cchCommand += _snwprintf(
                    m_wszCommand + cchCommand,
                    MAX_SIZE_COMMAND - cchCommand - 2,
                    L" %d:",ulParam);
                
                if(rgBinding[ulParam].dwPart & DBPART_STATUS)
                {
                    DWORD dwStatus = *((DWORD*)((BYTE*)pData + rgBinding[ulParam].obStatus));

                    if(    dwStatus == DBSTATUS_S_OK || 
                        dwStatus == DBSTATUS_S_TRUNCATED )
                    {
                        bAvailable = TRUE;
                    }
                    else if ( dwStatus == DBSTATUS_S_ISNULL )
                    {
                        cchCommand += _snwprintf(
                            m_wszCommand + cchCommand,
                            MAX_SIZE_COMMAND - cchCommand - 2,
                            L"(null)");
                        bAvailable = FALSE;
                    }
                }

                if(bAvailable)
                {
                    if(rgBinding[ulParam].dwPart & DBPART_LENGTH)
                    {
                        bLength = TRUE;
                        dwLength = *((DWORD*)((BYTE*)pData + rgBinding[ulParam].obLength));
                    }

                    if(rgBinding[ulParam].dwPart & DBPART_VALUE)
                    {
                        void* pDataUnit = NULL;
                        
                        if(rgBinding[ulParam].wType & DBTYPE_BYREF)
                        {
                            pDataUnit = *((void**)((BYTE*)pData + rgBinding[ulParam].obValue));
                        }
                        else
                        {
                            pDataUnit = (BYTE*)pData + rgBinding[ulParam].obValue;
                        }
                        
                        if((rgBinding[ulParam].wType & DBTYPE_I4) == DBTYPE_I4)
                        {
                            cchCommand += _snwprintf(
                                m_wszCommand + cchCommand,
                                __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                L"%d",
                                *((int*)pDataUnit));
                        }
                        else if((rgBinding[ulParam].wType & DBTYPE_DATE) == DBTYPE_DATE)
                        {
                            SYSTEMTIME sTime;
                            if(VariantTimeToSystemTime(*((DATE*)pDataUnit), &sTime))
                            {
                                cchCommand += _snwprintf(
                                    m_wszCommand + cchCommand,
                                    __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                    L"%d/%d/%d",
                                    sTime.wYear,
                                    sTime.wMonth,
                                    sTime.wDay);
                            }
                            else
                            {
                                cchCommand += _snwprintf(
                                    m_wszCommand + cchCommand,
                                    __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                    L"(error)");
                            }
                        }
                        else if((rgBinding[ulParam].wType & DBTYPE_GUID) == DBTYPE_GUID)
                        {
                            OLECHAR ochGuid[128];

                            if(StringFromGUID2(*((GUID*)pDataUnit), ochGuid, ARRAY_ELEMENTS(ochGuid)))
                            {
                                cchCommand += _snwprintf(
                                    m_wszCommand + cchCommand,
                                    __max(50, MAX_SIZE_COMMAND - cchCommand - 2),
                                    L"%s", ochGuid);
                            }
                            else
                            {
                                cchCommand += _snwprintf(
                                    m_wszCommand + cchCommand,
                                    __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                    L"(error)");
                            }

                        }
                        else if((rgBinding[ulParam].wType & DBTYPE_STR) == DBTYPE_STR)
                        {
                            cchCommand += _snwprintf(
                                m_wszCommand + cchCommand,
                                __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                L"%S",
                                (CHAR*)pDataUnit);
                        }
                        else if((rgBinding[ulParam].wType & DBTYPE_WSTR) == DBTYPE_WSTR)
                        {
                            cchCommand += _snwprintf(
                                m_wszCommand + cchCommand,
                                __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                L"%s",
                                (WCHAR*)pDataUnit);
                        }
                        else if((rgBinding[ulParam].wType & DBTYPE_BYTES) == DBTYPE_BYTES)
                        {
                            LARGE_INTEGER liData;
                            liData.QuadPart = 0;
                            DBLENGTH uDataLength = 0;
                            ULONG ulNdx = 0;

                            if(bLength)
                            {
                                uDataLength = (DBLENGTH)dwLength;
                            }
                            else
                            {
                                uDataLength = rgBinding[ulParam].cbMaxLen;
                            }
                            
                            if(uDataLength > sizeof(LARGE_INTEGER))
                                uDataLength = sizeof(LARGE_INTEGER);        
                                
                            for(ulNdx = 0; ulNdx < uDataLength; ulNdx++)
                            {
                                *((BYTE*)(&liData) + ulNdx) = *((BYTE*)pDataUnit + ulNdx);
                            }
                            
                            cchCommand += _snwprintf(
                                m_wszCommand + cchCommand,
                                __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                L"0x%08x%08x",
                                liData.HighPart,
                                liData.LowPart);
                        }
                        else
                        {
                            cchCommand += _snwprintf(
                                m_wszCommand + cchCommand,
                                __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                                L"(not supported)");
                        }
                    }
                    else
                    {
                        cchCommand += _snwprintf(
                            m_wszCommand + cchCommand,
                            __max(MAX_SIZE_PARAMETER, MAX_SIZE_COMMAND - cchCommand - 2),
                            L"(not available)");
                    }
                }
                
                m_wszCommand[cchCommand] = 0;
            }
        }
    }

//    SN_TRACE(("%S", m_wszCommand));

//    SN_RETURN;
}    

/*******************************************************************************
CODBWSession::clearConnection

*******************************************************************************/
HRESULT CODBWSession::clearConnection()
{
    HRESULT hr = S_OK;
    
    if(! m_bAvoidRecursion)
    {    
        m_bAvoidRecursion = TRUE;

        static WCHAR wszClearTranCmd[] = 
            L"select @@trancount, @@spid \r\n"
            L"if @@trancount > 0\r\n"
            L"  rollback";

        hr = RunCommand(
            wszClearTranCmd);

        if(SUCCEEDED(hr))
        {
            if(    GetResult()->IsAvailable() &&
                GetResult()->IsRowset() )
            {
                struct CONNINFO
                {
                    INT iTranCount;
                    INT iSPID;
                } sConnInfo = {0, 0};

                DBBINDING rgBinding[2];

                ODBWBindingAdd_int(rgBinding+0,   1,   offsetof(CONNINFO, iTranCount));
                ODBWBindingAdd_int(rgBinding+1,   2,   offsetof(CONNINFO, iSPID));

                hr = GetResult()->SetBindings(rgBinding, ARRAY_ELEMENTS(rgBinding));

                if(SUCCEEDED(hr))
                {
                    DBCOUNTITEM cRows = 1;
                    hr = GetResult()->GetRows(&cRows, &sConnInfo, sizeof(CONNINFO));
                    if(    (S_OK == hr) &&
                        (cRows == 1) )
                    {
                        if(sConnInfo.iTranCount > 0)
                        {
                            m_ErrorHandler.ShowError(
                                "Connection with opened transactions detected and cleaned");
                        }
                    }
                    else
                    {
                        m_ErrorHandler.ShowError(
                            "CODBWSession::clearConnection - GetRows failed or returned no rows (0x08x)", hr);
                    }
                }
                else
                {
                    m_ErrorHandler.ShowError(
                        "CODBWSession::clearConnection - SetBindings failed (0x08x)", hr);
                }
            }
            else
            {
                m_ErrorHandler.ShowError(
                    "CODBWSession::clearConnection - No rowset returned - Unexpected");
            }
        }
        else
        {
            m_ErrorHandler.ShowError(
                "CODBWSession::clearConnection - RunCommand failed (0x08x)", hr);
        }
    
        m_bAvoidRecursion = FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\OleDBWrapper.h ===
//+-----------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      OleDbWrapper.h
//
//  Contents:  OleDbWrapper - header file
//             CODBWSession and CODBWResult declaration
//
//  Author:    Daniel Caiafa (dcaiafa@microsoft.com)
//
//  Revision History:
//
//    04/03/99    dcaiafa    created
//
//------------------------------------------------------------------------

#ifndef __OLEDBWRAPPER_H__
#define __OLEDBWRAPPER_H__

/******************************************************************************/

class CODBWSession;
class CODBWParameterInfo;

/******************************************************************************/

#include <atlbase.h>
#include <msdasc.h>
#include <msdaguid.h>
#include <oledb.h>
#include <oledberr.h>
#include <txdtc.h>
#include <XoleHlp.H> 
#include <mtx.h>
#include <Transact.h>

/******************************************************************************/

#include "odbwerror.h"
#include "odbwbind.h"
#include "odbwbind2.h"



/******************************************************************************/

// Interface of object called back in GetRows if consumer wants to apply extra 
// bindings, particularly to retrieve values of ntext columns
class CODBWDeferedBindings
{
public:
    virtual HRESULT Apply(IRowset*, HROW, DBCOUNTITEM ulElemIndex) = 0;
};

/******************************************************************************/

// An instance of CWSProcCache can be passed to CODBWSession::CallProc in order 
// to get the parameter binding stuff cached for subsequent calls. The easiest
// way to do it is to declare the object as global or as static to the function
// scope. C++ will take care of releasing it at the end of the process life.

class CWSProcCache
{
    
    // CODBWSession must have access to the protected session
    
    friend CODBWSession;

public:
        
    CWSProcCache()
        : m_pStuff(NULL)
    { }
    
    ~CWSProcCache()
    {
        if(m_pStuff)
        {
            CoTaskMemFree(m_pStuff);
        }
    }

protected:
    
    // SetData
    // Called by CODBWSession::CallProc. Returns TRUE if successfully set the
    // stuff pointer. (Meaning: if it was the first to set it). Returns FALSE
    // otherwise.
    
    BOOL SetData(VOID* pData)
    {
        return NULL == InterlockedCompareExchangePointer(&m_pStuff, pData, NULL);
    }

    // GetData
    // Called by CODBWSession::CallProc to get the pointer to the cached
    // parameter stuff.
    
    VOID* GetData()
    {
        return m_pStuff;
    }
    
private:
    
    // Pointer to memory allocated by CODBWSession::CallProc containing 
    // parameter binding stuff

    VOID* m_pStuff;
};

/******************************************************************************/

class CODBWSession : 
public CODBWErrorConnectionPoint
{
public:
    enum {
        MAX_SIZE_CONNSTR = 512,
        MAX_SIZE_COMMAND = 1024,
        MAX_SIZE_PARAMETER = 20,
        MAX_PARAM_COUNT = 150,
    };
    enum {
        NOTAVAILABLE = ~0
    };

    struct PARAMETER_DATA {
        union {
            CHAR cData;
            INT iData;
            SHORT nData;
            ULONGLONG qwData;
            DATE dtData;
            GUID guidData;
            DOUBLE fData;
            LPCSTR pszData;
            LPCWSTR pwszData;
            BYTE* pData;
        };
        DWORD dwLength;
        DWORD dwStatus;
    };
    
    struct COMMAND_INFO {
        WCHAR wszProc[MAX_SIZE_COMMAND];
        ULONG ulParamCount;
        DBORDINAL* rgParamOrdinal;
        DBPARAMBINDINFO* rgParamBindInfo;
        DBBINDING* rgBinding;
    };

    CODBWSession();
    virtual ~CODBWSession();

    HRESULT Initialize(
        LPCWSTR wszConnStr, 
        BOOL bRead = TRUE
    );

    HRESULT InitializeEx(
        LPCWSTR wszConnStr, 
        BOOL bRead = TRUE
    );

    void ReleaseConnection();

    HRESULT SetEventCallback(
        LPEVENTCALLBACK lpEventCallback
    );
    
    HRESULT RunCommand(
        LPCWSTR wszCommand,                                
        CODBWParameterInfo* pParametersInfo = NULL,        
        void* pData = NULL                                
    );

    HRESULT RunCommandEx(
        LPCWSTR wszCommand,
        ULONG cParamCount,
        DBORDINAL * rgParamOrdinals,
        DBPARAMBINDINFO* rgParamBindInfo,
        DBBINDING* rgBinding,
        void* pData,
                BOOL fSaveCommand = TRUE // Used to print the command in debug spew, but it is expensive so it is allowed to be turned off.
        );

    HRESULT CallProc(
        CWSProcCache* pCache,
        LPCWSTR pwszProc,
        ...);

    HRESULT VCallProc(
        CWSProcCache* pCache,
        LPCWSTR pwszProc,
        va_list arg_list);

    HRESULT NextResult();

    HRESULT NextRowsetResult();

    HRESULT CleanUpResult();
    
    static HRESULT InitializeConnectionPooling();
    static HRESULT TerminateConnectionPooling();

    CODBWSession* GetResult() 
    { return this; }

    BOOL IsInitialized()
    { return m_pIDBCreateCommand != NULL; }

    void SetConnectionTimeOut(LONG lConnTimeOut)
    { m_lConnTimeOut = lConnTimeOut; }

    void SetCommandTimeOut(LONG lCommandTimeOut)
    { m_lCommandTimeOut = lCommandTimeOut; }

    void SetChangeRowsetMode(BOOL bChangeRowset)
    { m_bChangeRowset = bChangeRowset; }

    void SetDebugLevel(INT iDebugLevel)
    { m_iDebugLevel = iDebugLevel; }

    void SetRandomAccessOrder(BOOL bRandomAccessOrder)
    { m_bRandomAccessOrder = bRandomAccessOrder; }
    
    // Transaction methods
    
    HRESULT BeginTransaction();
    
    HRESULT Commit();
    
    HRESULT RollBack();

    HRESULT OpenTransaction(ITransaction **pITransaction);

    HRESULT EnlistInTransaction(ITransaction *pITransaction);

    HRESULT UnEnlistFromTransaction();

    // Result methods

    HRESULT InitializeWithIRowset(
        IRowset* pIRs
    );
    
    HRESULT InitializeWithRowsAffected(
        DBROWCOUNT cRowsAffected
    );

    HRESULT Clear();
    
    HRESULT SetBindings(
        const DBBINDING* rgBindings, 
        ULONG cBindings
    );    

    HRESULT Restart();

    HRESULT GetRows(
        DBCOUNTITEM* cRows, 
        VOID* pBuffer, 
        ULONG iElemSize,
        LONG lOffset = 0,
        CODBWDeferedBindings* pDeferedBindings = NULL
    );

    HRESULT GetLastRow(VOID* pBuffer);

    HRESULT SetLastRow(VOID* pBuffer);

    HRESULT InitializeBuffer(
        void* pBuffer,
        ULONG cBuffer
    );

    BOOL IsRowset() 
    { return IsAvailable() && (m_pIRowset != NULL); }
    BOOL IsAvailable() 
    { return m_bAvailable; }
    DBROWCOUNT GetRowsAffected() 
    { return m_cRowsAffected; }
    HRESULT GetRowset(IUnknown** ppiRowsetUnk)
    { return m_pIRowset->QueryInterface(ppiRowsetUnk); }

    INT GetStatus()
    { return m_pParamBuffer[0].iData; }

    VOID* GetParam(int ndx)
    { return &m_pParamBuffer[ndx - 1].iData; }
    
    LPCWSTR GetConnectionString()
    { return m_wszConnStr; }

    // Error support
    
    virtual HRESULT GetConnectionInfo(
        BSTR* pbstrConnInfo);

    virtual HRESULT GetCommandInfo(
        BSTR* pbstrCommandInfo);

private:
    
    void saveCommand(
        LPCWSTR pwszCommand,
        ULONG cParamCount,
        DBORDINAL * rgParamOrdinals,
        DBPARAMBINDINFO* rgParamBindInfo,
        DBBINDING* rgBinding,
        void* pData);

    int getParamCount(
    LPCWSTR pwszProc);

    HRESULT parseStoredProcCall(
        LPCWSTR pwszProc,
        COMMAND_INFO* pCommandInfo);

    HRESULT parseStoredProcParam(
        LPCWSTR* ppwszParam,
        int iParamNdx,
        COMMAND_INFO* pParamBind);

    void fillout_dbparambindinfo(
        DBPARAMBINDINFO* pBindInfo,
        LPOLESTR pwszType,
        ULONG ulSize,
        DBPARAMFLAGS dwFlags,
        BYTE cPrecision);

    void fillout_dbbinding(
        DBBINDING* pBind,
        INT iOrdinal,
        DBPART dwPart,
        DBOBJECT* pObject,
        DBPARAMIO eParamIO,
        DBTYPE wType,
        DWORD cbMaxLen,
        BYTE cPrecision);

    HRESULT clearConnection();

    static IUnknown* s_punkDataInitialize;
    static LONG s_lRefs;

    const DBBINDING* m_pLastBind;
    ULONG m_cLastBind;

    WCHAR m_wszConnStr[MAX_SIZE_CONNSTR];
    WCHAR m_wszCommand[MAX_SIZE_COMMAND + 10];

    PARAMETER_DATA m_StackParamBuffer[MAX_PARAM_COUNT];
    PARAMETER_DATA* m_pHeapParamBuffer;
    PARAMETER_DATA* m_pParamBuffer;
    ULONG m_ParamBufferSize;

    LONG m_lConnTimeOut;
    LONG m_lCommandTimeOut;

    CComPtr<IDBCreateCommand> m_pIDBCreateCommand;
    CComPtr<ICommandText> m_pIComm;
    CComPtr<ITransaction> m_pITransaction;
    CComPtr<IMultipleResults> m_pIMultipleResults;

    CComPtr<IRowset> m_pIRowset;
    CComPtr<IRowsetChange> m_pIRowsetChange;
    
    HACCESSOR m_hAccessor;
    DBROWCOUNT m_cRowsAffected;
    BOOL m_bAvailable;
    
    HROW m_hLastRow;
    
    CODBWError m_ErrorHandler;

    BOOL m_bAvoidRecursion;

    BOOL m_bChangeRowset;

    INT m_iDebugLevel;

    BOOL m_bRandomAccessOrder;
};


/******************************************************************************/


#endif // __OLEDBWRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\oledbw\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_oledbw_none_12.4.56.0_none_5181c5a7cff24069
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=oledbw
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.manifest
XP_MANIFEST_PATH=manifests\x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.cat
XP_CATALOG_PATH=manifests\x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47.cat
XP_PAYLOAD_PATH=x86_oledbw_no-public-key_12.4.56.0_x-ww_f9e55a47
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=oledbw,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED_)
#define AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_FREE_THREADED

#include <atlbase.h>
#include <stdio.h>
#include <stdafx.h>


#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2C7515B0_E3BC_11D2_BE88_00C04F5C7F34__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\wsoledberror.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __WSOLEDBERROR_H__
#define __WSOLEDBERROR_H__

/******************************************************************************/

typedef HRESULT (*LPEVENTCALLBACK)(HRESULT, LPCSTR);

/******************************************************************************/

class CWSODBWError
{
public:
	CWSODBWError(LPEVENTCALLBACK lpEventCallback) :
	  m_lpEventCallback(lpEventCallback), 
      m_cchBuffer(0)
	  {}
	
	HRESULT ShowError
		(
		LPCSTR szInfo,
		...
		);
	  
	HRESULT HandleError
		(
		HRESULT hrReturned,
		LPCSTR szInfo,
		...
		);

protected:
	
	void clearBuffer();

	void addFmtMsg(
		LPCSTR pszFormat,
		...);

	void addVFmtMsg(
		LPCSTR pszFormat,
		va_list argptr);


	void sendMessage();
	
	HRESULT processErrorRecord
		(
		ULONG iRecord,
		IErrorRecords* _pIErrorRecords
		);

	HRESULT processErrorInfo
		(
		IErrorInfo* _pIErrorInfo
		);

	HRESULT	getSQLErrorInfo
		(
		ULONG			iRecord,
		IErrorRecords*	pIErrorRecords,
		BSTR*			pBstr,
		LONG*			plNativeError
		);


	enum { MAX_ERROR_MSG_SIZE = 2048 };
	
	LPEVENTCALLBACK m_lpEventCallback;
	
	CHAR m_szBuffer[MAX_ERROR_MSG_SIZE + 1];
	DWORD m_cchBuffer;
};

/******************************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\wsoledbbind.h ===
/*************************************************************************
  Microsoft Network
  Copyright (C) Microsoft Corporation, 2000

*************************************************************************/

#ifndef __WSODBWBIND_H__
#define __WSODBWBIND_H__

/******************************************************************************/

#define WSBIND(ulColumn,ulDataOff,wType,cMaxLen) { \
	ulColumn, \
	ulDataOff, \
	0, \
	0, \
	NULL, \
	NULL, \
	NULL, \
	DBPART_VALUE, \
	DBMEMOWNER_CLIENTOWNED, \
	DBPARAMIO_NOTPARAM, \
	wType != DBTYPE_WSTR ? cMaxLen : cMaxLen * sizeof(WCHAR), \
	0, \
	wType, \
	0, \
	0 \
}

#define WSBIND2(ulColumn,ulDataOff,wType,cMaxLen,dwPart,ulLengthOff,ulStatusOff) { \
	ulColumn, \
	ulDataOff, \
	ulLengthOff, \
	ulStatusOff, \
	NULL, \
	NULL, \
	NULL, \
	dwPart, \
	DBMEMOWNER_CLIENTOWNED, \
	DBPARAMIO_NOTPARAM, \
	wType != DBTYPE_WSTR ? cMaxLen : cMaxLen * sizeof(WCHAR), \
	0, \
	wType, \
	0, \
	0 \
}

/******************************************************************************/

#endif // __WSODBWBIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\WSOLEDBResult.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __WSOLEDBRESULT_H__
#define __WSOLEDBRESULT_H__

/******************************************************************************/

#include <atlbase.h>
#include <msdasc.h>
#include <msdaguid.h>
#include <oledb.h>
#include <oledberr.h>
#include <txdtc.h>
#include <XoleHlp.H> 
#include <mtx.h>
#include <Transact.h>

#include "wsoledbbind.h"
#include "wsoledberror.h"

/******************************************************************************/

// Interface of object called back in GetRows if consumer wants to apply extra 
// bindings, particularly to retrieve values of ntext columns
class CWSODBWDeferedBindings
{
public:
    virtual HRESULT Apply(IRowset*, HROW, DBCOUNTITEM ulElemIndex) = 0;
};

/******************************************************************************/

class CWSODBWResult
{
public:
    // Done

    CWSODBWResult(LPEVENTCALLBACK lpEventCallback);
    ~CWSODBWResult();

    HRESULT SetResults(IMultipleResults *pIMultipleResults);

    CWSODBWError *GetErrorHandler() { return &m_ErrorHandler; }

    HRESULT Clear();

    HRESULT NextResult();

    HRESULT NextRowsetResult();

    HRESULT CleanUpResult();

    HRESULT InitializeWithIRowset(
        IRowset* pIRs
    );

    HRESULT InitializeWithRowsAffected(
        DBROWCOUNT cRowsAffected
    );

    HRESULT SetBindings(
        const DBBINDING* rgBindings, 
        ULONG cBindings
    );

    HRESULT Restart();

    HRESULT GetRows(
        DBCOUNTITEM* cRows, 
        VOID* pBuffer, 
        ULONG iElemSize,
        LONG lOffset = 0,
        CWSODBWDeferedBindings* pDeferedBindings = NULL
    );

    HRESULT GetLastRow(VOID* pBuffer);

    HRESULT InitializeBuffer(
        void* pBuffer,
        ULONG cBuffer
    );

    BOOL IsRowset() 
        { return IsAvailable() && (m_pIRowset != NULL); }

    BOOL IsAvailable() 
        { return m_bAvailable; }

    DBROWCOUNT GetRowsAffected() 
        { return m_cRowsAffected; }

    HRESULT GetRowset(IUnknown** ppiRowsetUnk)
        { return m_pIRowset->QueryInterface(ppiRowsetUnk); }

protected:
    void fillout_dbparambindinfo(
        DBPARAMBINDINFO* pBindInfo,
        LPOLESTR pwszType,
        ULONG ulSize,
        DBPARAMFLAGS dwFlags,
        BYTE cPrecision);

    void fillout_dbbinding(
        DBBINDING* pBind,
        INT iOrdinal,
        DBPART dwPart,
        DBOBJECT* pObject,
        DBPARAMIO eParamIO,
        DBTYPE wType,
        DWORD cbMaxLen,
        BYTE cPrecision);

    const DBBINDING* m_pLastBind;
    ULONG m_cLastBind;

    CComPtr<IMultipleResults> m_pIMultipleResults;

    CComPtr<IRowset> m_pIRowset;
    
    HACCESSOR m_hAccessor;
    DBROWCOUNT m_cRowsAffected;
    BOOL m_bAvailable;
    
    HROW m_hLastRow;

    CWSODBWError m_ErrorHandler;
};

#endif //#ifndef __WSOLEDBRESULT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wsoledbw_none_12.4.56.0_none_79e9e11632425cd5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsoledbw
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.manifest
XP_MANIFEST_PATH=manifests\x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.cat
XP_CATALOG_PATH=manifests\x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.cat
XP_PAYLOAD_PATH=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsoledbw,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\wsoledberror.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved


#include "stdafx.h"
#include "WSOLEDBResult.h"


/******************************************************************************/

HRESULT CWSODBWError::ShowError
	(
	LPCSTR pszInfo,
	...
	)
{
	clearBuffer();

	va_list marker;
	va_start(marker, pszInfo);

	addVFmtMsg(pszInfo, marker);

	va_end(marker);

	sendMessage();
	
	return S_OK;
}

/******************************************************************************/

HRESULT CWSODBWError::HandleError
	(
	HRESULT hrReturned,
	LPCSTR pszInfo,
	...
	)
{
	HRESULT hr = S_OK;
	CComPtr<IErrorInfo> pIErrorInfo;
	CComQIPtr<IErrorRecords> pIErrorRecords;
	ULONG cRecords = 0;
	ULONG iErr = 0;

	if(FAILED(hrReturned))
	{
		addFmtMsg("\r\n");
		
		// Add the info passed by the caller
		va_list marker;
		va_start(marker, pszInfo);
		addVFmtMsg(pszInfo, marker);
		va_end(marker);
		
		// Add the HRESULT 
		addFmtMsg("\r\n(hr = 0x%08x)", hrReturned);

		// Now try to get more data from OLE DB
		hr = GetErrorInfo(0, &pIErrorInfo);
		
		if((S_OK == hr)  && (pIErrorInfo != NULL))
		{
			pIErrorRecords = pIErrorInfo;
			if(pIErrorRecords != NULL)
			{
				hr = pIErrorRecords->GetRecordCount(&cRecords);

				if(SUCCEEDED(hr))
				{
					for( iErr = 0; iErr < cRecords; iErr++ )
					{
						processErrorRecord(iErr, pIErrorRecords);
					}
				}
			}
			else
			{
				processErrorInfo(pIErrorInfo);
			}
		}

		sendMessage();
	}
	
	return hr;
}

/******************************************************************************/

void CWSODBWError::clearBuffer()
{
	m_szBuffer[0] = 0;
	m_cchBuffer = 0;
}

/******************************************************************************/

void CWSODBWError::addFmtMsg(
	LPCSTR pszFormat,
	...
)
{
	va_list marker;
	va_start(marker, pszFormat);

	addVFmtMsg(pszFormat, marker);

	va_end(marker);
}

/******************************************************************************/

void CWSODBWError::addVFmtMsg(
	LPCSTR pszFormat,
	va_list argptr
)
{
	m_cchBuffer += _vsnprintf(
		m_szBuffer + m_cchBuffer,
		MAX_ERROR_MSG_SIZE - m_cchBuffer,
		pszFormat,
		argptr);

	m_szBuffer[m_cchBuffer] = 0;
}

/******************************************************************************/

void CWSODBWError::sendMessage()
{
#ifdef _DEBUG
	OutputDebugStringA(m_szBuffer);
#endif
	
	if(m_lpEventCallback)
	{
		(*m_lpEventCallback)(0, m_szBuffer);
	}
}

/******************************************************************************/

HRESULT CWSODBWError::processErrorRecord
	(
	ULONG iRecord,
	IErrorRecords* _pIErrorRecords
	)
{
	static LCID	lcid = GetUserDefaultLCID();	
	CComPtr<IErrorRecords>	pIErrorRecords(_pIErrorRecords);
	CComPtr<IErrorInfo>		pIErrorInfo;
	CComBSTR	bstrDescription;
	CComBSTR	bstrSource;
	CComBSTR	bstrSQLInfo;
	LONG		lNativeError = 0;
	ERRORINFO	ErrorInfo;
	HRESULT hr = S_OK;
	
	hr = pIErrorRecords->GetErrorInfo(iRecord, lcid, &pIErrorInfo);
	
	if(SUCCEEDED(hr))
	{
		ErrorInfo.hrError = 0;
		
		pIErrorInfo->GetDescription(&bstrDescription);
		pIErrorInfo->GetSource(&bstrSource);
		pIErrorRecords->GetBasicErrorInfo(iRecord, &ErrorInfo);
		getSQLErrorInfo(iRecord, pIErrorRecords, &bstrSQLInfo, &lNativeError);

		addFmtMsg(
			"\r\n------------------------------------------------------"
			"\r\nHResult: 0x%08x"
			"\r\nDescription: %S"
			"\r\nSQL Info: %S"
            "\r\nNative Error: 0x%08x"
			"\r\nSource: %S"
			"\r\n",
			ErrorInfo.hrError,
			(bstrDescription != NULL ? bstrDescription : L"(N/A)"),
			(bstrSQLInfo != NULL ? bstrSQLInfo : L"(N/A)"),
            lNativeError,
			(bstrSource != NULL ? bstrSource : L"(N/A)") );
	}
	
	return hr;
}

/******************************************************************************/

HRESULT CWSODBWError::processErrorInfo
	(
	IErrorInfo* _pIErrorInfo
	)
{
	CComPtr<IErrorInfo> pIErrorInfo(_pIErrorInfo);
	CComBSTR	bstrDescription;
	CComBSTR	bstrSource;
	HRESULT hr = S_OK;

	pIErrorInfo->GetDescription(&bstrDescription);
	pIErrorInfo->GetSource(&bstrSource);

	addFmtMsg(
		"\r\n"
		"\r\n----------------"
		"\r\nDescription: %S"
		"\r\nSource: %S"
		"\r\n",
		(bstrDescription != NULL ? bstrDescription : L"(N/A)"),
		(bstrSource != NULL ? bstrSource : L"(N/A)") );

	return hr;
}


/******************************************************************************/

HRESULT CWSODBWError::getSQLErrorInfo
	(
	ULONG			iRecord,
	IErrorRecords*	pIErrorRecords,
	BSTR*			pBstr,
	LONG*			plNativeError
	)
{

	ISQLErrorInfo*	pISQLErrorInfo = NULL;
	LONG			lNativeError = 0;
	HRESULT			hr = S_OK;

	hr = pIErrorRecords->GetCustomErrorObject(
		iRecord,
		IID_ISQLErrorInfo,
		(IUnknown**) &pISQLErrorInfo);

	if(FAILED(hr))
		goto _out;

	if(pISQLErrorInfo != NULL)
	{
		hr = pISQLErrorInfo->GetSQLInfo(pBstr, &lNativeError);
	}

_out:

	if(plNativeError != NULL)
		*plNativeError = lNativeError;

	if(pISQLErrorInfo != NULL)
		pISQLErrorInfo->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wsoledbw_none_12.4.56.0_none_79e9e11632425cd5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsoledbw
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.manifest
XP_MANIFEST_PATH=manifests\x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.cat
XP_CATALOG_PATH=manifests\x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803.cat
XP_PAYLOAD_PATH=x86_wsoledbw_no-public-key_12.4.56.0_x-ww_afb9f803
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsoledbw,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\sql\wsoledbw\WSOLEDBResult.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "WSOleDBResult.h"

/******************************************************************************/

#define DW_ALIGN(x) (x + 3 & ~ 3)

/******************************************************************************/


CWSODBWResult::CWSODBWResult(LPEVENTCALLBACK lpEventCallback) :
    m_pLastBind(NULL),
    m_cLastBind(0),
    m_pIMultipleResults(NULL),
    m_pIRowset(NULL),
    m_hAccessor (0),
    m_cRowsAffected (0),
    m_bAvailable (FALSE),
    m_hLastRow (0),
    m_ErrorHandler(lpEventCallback)
{
}

CWSODBWResult::~CWSODBWResult()
{
    Clear();

    if(m_pIMultipleResults) 
    {
        m_pIMultipleResults.Release();
        // ATL set the pointer to null
    }
}


HRESULT CWSODBWResult::SetResults(IMultipleResults *pIMultipleResults)
{
    HRESULT hr = S_OK;

    Clear();

    m_pIMultipleResults = pIMultipleResults;

    hr = NextResult();

    return hr;
}

/*******************************************************************************
CWSODBWResult::Clear

Releases any allocated memory and initializes the internal states

Parameters:
    None

Returns:
    S_OK if succeeded
    Redirects errors from IRowset::ReleaseRows, IAccessor::ReleaseAccessor
*******************************************************************************/
HRESULT CWSODBWResult::Clear()
{
    HRESULT hr = S_OK;

    // Release row

    if(m_hLastRow != 0)
    {
        hr = m_pIRowset->ReleaseRows(1, &m_hLastRow, NULL,    NULL, NULL);
        
        if(FAILED(hr)) 
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWResult::Clear - IRowset::ReleaseRows");
        }

        m_hLastRow = 0;
    }

    // Release accessor
    if(m_hAccessor) {
        CComQIPtr<IAccessor> pIA(m_pIRowset);
        hr = pIA->ReleaseAccessor(m_hAccessor, NULL);
        if(FAILED(hr)) 
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWResult::Clear - IAccessor::ReleaseAccessor");
        }
        
        m_hAccessor = 0;
    }

    // Release IRowset object
    if(m_pIRowset) {
        m_pIRowset.Release();
    }
    
    // Initial state
    m_cRowsAffected = 0;
    m_bAvailable = FALSE;
    m_pLastBind = NULL;
    m_cLastBind = 0;

    return hr;
}

/*******************************************************************************
CWSODBWSession::NextResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CWSODBWResult::NextResult()
{
    HRESULT hr = S_OK;
    
    if(m_pIMultipleResults != NULL)
    {
        // Release the former result (if it exists)
        Clear();                // In order to GetResult succeed we MUST release
                                // the former IRowset.

        // Get the next result    
        DBROWCOUNT cRowsAffected;
        CComPtr<IRowset> pIRowset;

        hr = m_pIMultipleResults->GetResult(
            NULL,
            0,
            IID_IRowset,
            &cRowsAffected,
            (IUnknown**) &pIRowset
            );

        if (FAILED(hr))
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWSession::NextResult - IMultipleResults::GetResult");
            goto _out;
        }
        
        switch(hr) 
        {
        case DB_S_NORESULT:
        case DB_S_STOPLIMITREACHED:
            break;
        
        default:
            if(pIRowset) 
            {
                // The result is a rowset
                InitializeWithIRowset(pIRowset);
            }
            else
            {
                // The result isn't a rowset
                InitializeWithRowsAffected(cRowsAffected);
            }
        }
    }
    else
    {
        
        // No results were returned by the stored procedure. 

        hr = DB_S_NORESULT;
    }

_out:
    
    return hr;
}

/*******************************************************************************
CWSODBWResult::NextRowsetResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CWSODBWResult::NextRowsetResult()
{
    HRESULT hr = S_OK;

    if (m_pIMultipleResults == NULL)
    {
        return E_UNEXPECTED;
    }

    do {
        hr = NextResult();
    } while (SUCCEEDED(hr) && hr != DB_S_NORESULT && !IsRowset());

    return hr;
}

/*******************************************************************************
CWSODBWResult::CleanUpResult

Parameters:
  
Returns:

*******************************************************************************/
HRESULT CWSODBWResult::CleanUpResult()
{
    HRESULT hr = S_OK;

    if(m_pIMultipleResults != NULL)
    {
        while(S_OK == hr)
        {
            hr = NextResult();
        }
    }

    return hr;
}

/*******************************************************************************
CWSODBWResult::InitializeWithIRowset

Initializes the object with an IRowset. This means that the client will be
able to fetch for rows using GetRows()

(internal use) called by CWSODBWResult::RunCommand

Parameters:
    [in] IRowset* pIRs

Returns:
    Nothing
*******************************************************************************/
HRESULT CWSODBWResult::InitializeWithIRowset(IRowset* pIRs)
{
    _ASSERT(NULL != pIRs);

    HRESULT hr = S_OK;

    hr = Clear();
    if(SUCCEEDED(hr)) {
        m_pIRowset = pIRs;
        m_bAvailable = TRUE;
    }
    
    return hr;
}

/*******************************************************************************
CWSODBWResult::InitializeWithRowsAffected

Initializes the object with the number of rows affected by the command execution. 
This means that the client won't be able to fetch for rows but he will be able 
to get the Rows affected using GetRowsAffected()

(internal use) called by CWSODBWResult::RunCommand

Parameters:
    [in] LONG cRowsAffected 

Returns:
    S_OK if succeeded
    Redirects Clear() errors
*******************************************************************************/
HRESULT CWSODBWResult::InitializeWithRowsAffected(DBROWCOUNT cRowsAffected)
{
    HRESULT hr = S_OK;
    
    hr = Clear();
    if(SUCCEEDED(hr)) {
        m_cRowsAffected = cRowsAffected;
        m_bAvailable = TRUE;
    }

    return hr;
}

/*******************************************************************************
CWSODBWResult::SetBindings

Set the bindings for accessing the rows' data. 
Use the ODBWBinding* inline functions to help filling the DBBINDING array

Parameters:
    [in] const DBBINDING* rgBindings (see OLE DB docs for IAccessor::CreateAccessor)
    [in] ULONG cBindings

Returns:
    S_OK if succeeded
    Redirects IAccessor::ReleaseAccessor, IAccessor::CreateAccessor errors
*******************************************************************************/
HRESULT CWSODBWResult::SetBindings(const DBBINDING* rgBindings, ULONG cBindings)
{
    _ASSERT(m_pIRowset);
    _ASSERT(rgBindings);
    _ASSERT(cBindings > 0);

    HRESULT hr = S_OK;
    
    // I love ATL
    CComQIPtr<IAccessor> pIA;
    
    if ( m_pIRowset == NULL )
    {
        hr = E_POINTER;
        goto _out;
    }

    pIA = m_pIRowset;

    if ( pIA == NULL)
    {
        hr = E_NOINTERFACE;
        goto _out;
    }
    
    // We're going to create an accessor. If we already have one, destroy it
    if(m_hAccessor) 
    {
        hr = pIA->ReleaseAccessor(m_hAccessor, NULL);
        if(SUCCEEDED(hr)) 
        {
            m_hAccessor = 0;
        }
        else
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWResult::SetBindings - IAccessor::ReleaseAccessor");
            goto _out;
        }
    }
    
    if(SUCCEEDED(hr))                    // Testing if ReleaseAccessor succeeded
    {
        // Create the accessor
        hr = pIA->CreateAccessor(
            DBACCESSOR_ROWDATA, 
            cBindings, 
            rgBindings, 
            0, 
            &m_hAccessor, 
            NULL
            );

        if(SUCCEEDED(hr))
        {
            m_pLastBind = rgBindings;
            m_cLastBind = cBindings;
        }
        else
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWResult::SetBindings - IAccessor::CreateAccessor");
        }

    }
    
 _out:
    return hr;
}

/*******************************************************************************
CWSODBWResult::Restart

Set the "cursor" to the beginning of the rowset

Parameters:
    None

Returns:
    Redirects IRowset->RestartPosition results
*******************************************************************************/
HRESULT CWSODBWResult::Restart()
{
    _ASSERT(m_pIRowset);
    
    HRESULT hr = S_OK;
    hr = m_pIRowset->RestartPosition(DB_NULL_HCHAPTER);

    return hr;
}

/*******************************************************************************
CWSODBWResult::GetRows

Get a bunch of rows at a time. 
MUST call SetBindings before using this method.

Parameters:
    [in,out] ULONG* cRows: [in]#of rows to be read [out]#of rows actually read
    [out] VOID* pBuffer: buffer pre-allocated by the client
    [int] ULONG iElemSize: sizeof one element of the buffer
    [in]  LONG    lOffset : number of rows to skip (only supported on 1st call)
    [in]  CWSODBWDeferedBindings* pDeferedBindings : callback object for additional bindings

Returns:
    S_OK if succeeded
    DB_S_ENDOFROWSET no more rows to read. No rows read.
    Redirects the IRowset->ReleaseRows, IRowset->GetNextRows, IRowset->GetData
*******************************************************************************/
HRESULT CWSODBWResult::GetRows(
    DBCOUNTITEM* pcRows, 
    VOID* pBuffer, 
    ULONG dwElemSize, 
    LONG lOffset, 
    CWSODBWDeferedBindings* pDeferedBindings
)
{
    HRESULT hr = S_OK;

    // Requirements check
    
    if( m_pIRowset != NULL && 
        m_hAccessor != NULL)
    {

        DBCOUNTITEM cTotal = 0;

        while( (S_OK == hr) &&
            (cTotal < (DBCOUNTITEM)*pcRows) )
        {
            
            DBCOUNTITEM cRowsRead = 0;

            // Release previous rows
            
            if(m_hLastRow != NULL)
            {
                
                hr = m_pIRowset->ReleaseRows(1, &m_hLastRow, NULL, NULL, NULL);

                if(FAILED(hr))
                {
                    m_ErrorHandler.HandleError(hr,
                        "CWSODBWResult::GetRows - IRowset::ReleaseRows");
                }

                m_hLastRow = NULL;
            }

            if(SUCCEEDED(hr))
            {

                // Read one row
                
                HROW* phRow = &m_hLastRow;
                
                hr = m_pIRowset->GetNextRows(DB_NULL_HCHAPTER, lOffset, 1, 
                    (DBCOUNTITEM*) &cRowsRead, &phRow);

                if(    SUCCEEDED(hr) && 
                    cRowsRead > 0)
                {

                    // Read it into the caller buffer

                    hr = m_pIRowset->GetData(m_hLastRow, m_hAccessor, 
                        (char*)pBuffer + (dwElemSize * cTotal) );

                    if(hr != S_OK)
                    {
                        m_ErrorHandler.ShowError(
                            "CWSODBWResult::GetRows - IRowset::GetData returned 0x%08x", hr);
                    }

                    // Apply extra bindings if necessary

                    if (pDeferedBindings && !FAILED(hr))
                    {
                        hr = pDeferedBindings->Apply(m_pIRowset, m_hLastRow, cTotal);
                    }
                }
            }
        
            cTotal += cRowsRead;
        }

        *pcRows = cTotal;

        // This check is for backwards compability. We cannot returns 
        // DB_S_ENDOFROWSET if we're returning any rows. 
        
        if(    DB_S_ENDOFROWSET == hr && 
            cTotal > 0  )
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = E_FAIL;

        m_ErrorHandler.ShowError("CWSODBWResult::GetRows - No IRowset or hAccessor");
    }
    
    
    
    return hr;
}


/*******************************************************************************
CWSODBWResult::GetLastRow

  Get the last row read with GetRows. Very useful with multiple bindings.

Returns:
  S_OK Succeeded
  S_FALSE No last row
  HRESULT errors
*******************************************************************************/
HRESULT CWSODBWResult::GetLastRow(VOID* pBuffer)
{
    _ASSERT(m_pIRowset);
    _ASSERT(m_hAccessor);
    HRESULT hr = S_OK;

    if(m_hLastRow != 0)
    {
        hr = m_pIRowset->GetData(
            m_hLastRow, 
            m_hAccessor, 
            pBuffer);

        if(hr != S_OK)
        {
            m_ErrorHandler.HandleError(hr,
                "CWSODBWResult::GetLastRow - IRowset::GetData");
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CWSODBWResult::InitializeBuffer(
    void* pBuffer,
    ULONG cBuffer
)
{
    HRESULT hr = S_OK;

    // We're mostly concerned about strings

    for(ULONG ulBindNdx = 0; SUCCEEDED(hr) && (ulBindNdx < m_cLastBind); ulBindNdx++)
    {
        const DBBINDING* pBind = &m_pLastBind[ulBindNdx];
        if( (pBind->dwPart & DBPART_VALUE) == DBPART_VALUE)
        {
            switch(pBind->wType)
            {
            case DBTYPE_I4:
                if(pBind->obValue + sizeof(INT) <= cBuffer)
                    *((INT*)((BYTE*)pBuffer + pBind->obValue)) = 0;
                else
                    hr = E_FAIL;
                break;

            case DBTYPE_STR:
                if(pBind->obValue + sizeof(CHAR) <= cBuffer)
                    *((CHAR*)((BYTE*)pBuffer + pBind->obValue)) = 0;
                else
                    hr = E_FAIL;
                break;
        
            case DBTYPE_WSTR:
                if(pBind->obValue + sizeof(WCHAR) <= cBuffer)
                    *((WCHAR*)((BYTE*)pBuffer + pBind->obValue)) = 0;
                else
                    hr = E_FAIL;
                break;

            case DBTYPE_DATE:
                if(pBind->obValue + sizeof(DATE) <= cBuffer)
                    *((DATE*)((BYTE*)pBuffer + pBind->obValue)) = 0;
                else
                    hr = E_FAIL;
                break;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\IStateMachineAuditor.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System.Collections.Generic;

namespace xonline.common.statemachine
{
    public interface IStateMachineAuditor
    {
        void AuditStateResult(State state, Context context, IActionResult result);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\IActionResult.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------
using System;

namespace xonline.common.statemachine
{
    public interface IActionResult
    {
        string EventRaised { get; }
        Exception Exception { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\Context.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

namespace xonline.common.statemachine
{
    public abstract class Context
    {
        protected Context() { }

        public string CurrentStateName { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\State.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace xonline.common.statemachine
{
    public sealed class State
    {
        // The signature that each EntryAction or ExitAction must have
        public delegate IActionResult ActionDelegate(Context context);

        public string StateName { get; private set; }
        public string ActionName
        {
            get
            {
                return StateEntryAction.ActionName;
            }
        }
        private TransitionAction StateEntryAction;

        public State(string stateName, string actionName, ActionDelegate doAction)
        {
            this.StateName = stateName;
            this.StateEntryAction = new TransitionAction(actionName, doAction);
        }

        public IActionResult OnStateEntry(Context context)
        {
            return StateEntryAction.DoAction(context);;
        }

        private class TransitionAction
        {
            public string ActionName { get; private set; }
            public ActionDelegate DoAction { get; private set; }

            public TransitionAction(string actionName, ActionDelegate doAction)
            {
                this.ActionName = actionName;
                this.DoAction = doAction;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\StateMachineInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


namespace xonline.common.statemachine
{
    public sealed class StateMachineInfo
    {
        public Dictionary<string, State> States { get; private set; }
        public Dictionary<Transition, State> StateTransitions { get; private set; }

        public StateMachineInfo()
        {
            States = new Dictionary<string, State>();
            StateTransitions = new Dictionary<Transition, State>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\Transition.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace xonline.common.statemachine
{
    public sealed class Transition : IEquatable<Transition>
    {
        public string EventName { get; private set; }
        public string CurrentStateName { get; private set; }

        public Transition(string eventName, string currentStateName)
        {
            if (eventName == null)
            {
                throw new ArgumentNullException("eventName");
            }

            if (currentStateName == null)
            {
                throw new ArgumentNullException("currentStateName");
            }

            this.EventName = eventName;
            this.CurrentStateName = currentStateName;
        }

        #region IEquatable<Transition> Members

        public bool Equals(Transition other)
        {
            if (other == null)
            {
                return false;
            }

            return String.Equals(EventName, other.EventName) && String.Equals(CurrentStateName, other.CurrentStateName);
        }

        #endregion

        public override int GetHashCode()
        {
            return CurrentStateName.GetHashCode() ^ EventName.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as Transition);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\StateManager.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace xonline.common.statemachine
{
    public class StateManager
    {
        public State CurrentState { get { return States[StateContext.CurrentStateName]; } }
        public IStateMachineAuditor Auditor { get; private set; }

        private Dictionary<string, State> States { get { return StateInfo.States; } }

        private Dictionary<Transition, State> TransitionTable { get { return StateInfo.StateTransitions; } }

        private Context StateContext;
        private StateMachineInfo StateInfo;

        public StateManager(StateMachineInfo stateInfo, IStateMachineAuditor auditor, Context context)
        {
            StateInfo = stateInfo;
            StateContext = context;
            Auditor = auditor;

            State startState;

            if (!States.TryGetValue(context.CurrentStateName, out startState))
            {
                throw new InvalidOperationException(String.Format("Error: Illegal Context used to construct state machine.\n" +
                                                                  "The number of states loaded for this FSM is: {0}.\n" +
                                                                  "Context.CurrentStateName: {1}\n",
                                                                  States.Count,
                                                                  startState));
            }
        }

        public void StartExecution()
        {
            State nextState = null;
            string eventRaised = null;

            eventRaised = ExecuteAndAuditState(CurrentState);

            while (!String.IsNullOrEmpty(eventRaised))
            {
                // First make sure the requested transition is legal given the event and current state 
                nextState = GetNextState(eventRaised);

                eventRaised = ExecuteAndAuditState(nextState);
            }

        }

        private State GetNextState(string eventRaised)
        {
            State nextState;

            Transition requestedTransition = new Transition(eventRaised, CurrentState.StateName);

            if (!TransitionTable.TryGetValue(requestedTransition, out nextState))
            {
                // The event/currentState combination was illegal
                // TODO: Log this - faulty state machine!
                throw new InvalidOperationException(String.Format("Error: Illegal transition in state machine.\n" +
                                                    "Current state: {0}\n" +
                                                    "Produced event: {1}\n",
                                                    CurrentState.StateName,
                                                    eventRaised));
            }
            return nextState;
        }

        private string ExecuteAndAuditState(State newState)
        {
            IActionResult result;

            StateContext.CurrentStateName = newState.StateName;
            result = newState.OnStateEntry(StateContext);

            Auditor.AuditStateResult(newState, StateContext, result);

            return result.EventRaised;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\statemachine\dll\StateMachineFactory.cs ===
﻿//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace xonline.common.statemachine
{
    abstract public class StateMachineFactory<TInstance>
        where TInstance : StateMachineFactory<TInstance>
    {
        protected StateMachineFactory() { }

        private static readonly object lockObject = new object();
        private static volatile StateMachineInfo singleton;

        private static StateMachineInfo Instance
        {
            get
            {
                if (singleton == null)
                {
                    lock (lockObject)
                    {
                        if (singleton == null)
                        {
                            TInstance temp = (TInstance)Activator.CreateInstance(typeof(TInstance), true);
                            singleton = temp.BuildStateMachineInfo();
                        }
                    }
                }

                return singleton;
            }
        }

        public static StateManager Create(IStateMachineAuditor auditor, Context context)
        {
            return new StateManager(Instance, auditor, context);
        }

        protected abstract StateMachineInfo BuildStateMachineInfo();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\AppliesToCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;


namespace xonline.config.sts.configFileImpl
{
    public class AppliesToCollection : ConfigurationElementCollection
    {
        public AppliesToCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new AppliesTo();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((AppliesTo)element).AppliesToUri;
        }

        public AppliesTo this[int index]
        {
            get
            {
                return (AppliesTo)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public AppliesTo this[string appliesToUri]
        {
            get
            {
                return BaseGet(appliesToUri) as AppliesTo;
            }
        }

        public int IndexOf(AppliesTo parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(AppliesTo parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(AppliesTo parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.AppliesToUri);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string appliesToUri)
        {
            BaseRemove(appliesToUri);
        }

        public void Clear()
        {
            BaseClear();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\AppliesToClaimTypeCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class AppliesToClaimTypeCollection : ConfigurationElementCollection
    {
        public AppliesToClaimTypeCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new AppliesToClaimType();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((AppliesToClaimType)element).ClaimTypeUri;
        }

        public AppliesToClaimType this[int index]
        {
            get
            {
                return (AppliesToClaimType)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public AppliesToClaimType this[string claimTypeUri]
        {
            get
            {
                return BaseGet(claimTypeUri) as AppliesToClaimType;
            }
        }

        public int IndexOf(AppliesToClaimType parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(AppliesToClaimType parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(AppliesToClaimType parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.ClaimTypeUri);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string claimTypeUri)
        {
            BaseRemove(claimTypeUri);
        }

        public void Clear()
        {
            BaseClear();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\AppliesTo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class AppliesTo : ConfigurationElement, IAppliesTo
    {
        public AppliesTo()
        {
        }

        [ConfigurationProperty(
            "AnonymizingId",
             IsRequired = true,
             DefaultValue = "")]
        public string AnonymizingId
        {
            get 
            { 
                return this["AnonymizingId"] as string;    
            }
            set
            {
                this["AnonymizingId"] = value;
            }
        }

        [ConfigurationProperty(
            "AppliesToUri",
             IsRequired = true,
             DefaultValue = "")]
        public Uri AppliesToUri
        {
            get 
            {
                return this["AppliesToUri"] as Uri;
            }
            set
            {
                this["AppliesToUri"] = value;
            }
        }

        [ConfigurationProperty(
            "ValidityInterval",
             IsRequired = true)]
        public TimeSpan ValidityInterval
        {
            get 
            { 
                return  new TimeSpan(0, (int) this["ValidityInterval"], 0);
            }
            set
            {
                this["ValidityInterval"] = (int) value.TotalMinutes;
            }
        }

        private System.Security.Cryptography.X509Certificates.X509Certificate2 privateCertificate = null;
        private object certLock = new Object();

        [ConfigurationProperty(
            "AppliesToCertificate",
             IsRequired = true)]
        internal string AppliesToCertificateElement
        {
            get
            {
                return this["AppliesToCertificate"] as string;
            }
            set
            {
                this["AppliesToCertificate"] = value;
            }
        }

        public System.Security.Cryptography.X509Certificates.X509Certificate2 AppliesToCertificate
        {
            get
            {
                if (this.privateCertificate == null && this.AppliesToCertificateElement != null)
                {
                    lock (this.certLock)
                    {
                        string certStr = this.AppliesToCertificateElement;
                        if (!string.IsNullOrEmpty(certStr))
                        {
                            this.privateCertificate = new System.Security.Cryptography.X509Certificates.X509Certificate2(Convert.FromBase64String(certStr));
                        }
                    }
                }
                return this.privateCertificate;
            }
        }

        [ConfigurationProperty("Claims", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(AppliesToClaimTypeCollection),
            AddItemName = "AppliesToClaimType",
            ClearItemsName = "clearAppliesToClaimTypes",
            RemoveItemName = "removeAppliesToClaimTypes")]
        internal AppliesToClaimTypeCollection AppliesToClaimTypesElement
        {
            get
            {
                return base["Claims"] as AppliesToClaimTypeCollection;
            }
        }

        private IDictionary<Uri, IAppliesToClaimType> privateAppliesToClaimTypes = null;
        private object syncLock = new Object();

        public IDictionary<Uri, IAppliesToClaimType> ClaimTypes
        {
            get
            {
                if (this.privateAppliesToClaimTypes == null && this.AppliesToClaimTypesElement != null)
                {
                    lock (this.syncLock)
                    {
                        if (this.privateAppliesToClaimTypes == null)
                        {
                            this.privateAppliesToClaimTypes = new Dictionary<Uri, IAppliesToClaimType>();

                            foreach (AppliesToClaimType atct in this.AppliesToClaimTypesElement)
                            {
                                this.privateAppliesToClaimTypes.Add(atct.ClaimTypeUri,atct);
                            }
                        }
                    }
                }

                return this.privateAppliesToClaimTypes;
            }
        }
        
        [ConfigurationProperty(
                     "TokenType",
                      IsRequired = true)]
        internal TokenType TokenTypeElement
        {
            get
            {
                return this["TokenType"] as TokenType;
            }
            set
            {
                this["TokenType"] = value;
            }
        }

        public ITokenType TokenType
        {
            get
            {
                return this.TokenTypeElement;
            }
        }

        [ConfigurationProperty(
                     "BusinessPartner",
                     IsRequired = false)]
        internal IEBBusinessPartner BusinessPartnerElement
        {
            get
            {
                return this["BusinessPartner"] as IEBBusinessPartner;
            }
            set
            {
                this["BusinessPartner"] = value;
            }
        }

        public IIEBBusinessPartner BusinessPartner
        {
            get
            {
                return this.BusinessPartnerElement;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ClaimTypeProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class ClaimTypeProvider : ConfigurationElement, IClaimTypeProvider
    {

        public ClaimTypeProvider()
        {
        }

       
        [ConfigurationProperty(
             "Type",
              IsRequired = true,
              IsKey = true)]
        public string Type
        {
            get
            {
                return (string)this["Type"];
            }
            set
            {
                this["Type"] = value;
            }
        }

        [ConfigurationProperty("ClaimTypes", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(ClaimTypeCollection),
            AddItemName = "ClaimType",
            ClearItemsName = "clearClaimTypes",
            RemoveItemName = "removeClaimType")]
        internal  ClaimTypeCollection ClaimTypesElement
        {
            get
            {
                return base["ClaimTypes"] as ClaimTypeCollection;
            }
        }

        private IDictionary<Uri, IClaimType> privateDict = null;
        private object syncLock = new Object();

        public IDictionary<Uri, IClaimType> ClaimTypes
        {
            get
            {
                if (this.privateDict == null && this.ClaimTypesElement != null)
                {
                    lock(this.syncLock)
                    {
                        if (this.privateDict == null)
                        {
                            this.privateDict = new Dictionary<Uri, IClaimType>();

                            foreach (ClaimType ct in this.ClaimTypesElement)
                            {
                                this.privateDict.Add(ct.ClaimTypeUri, ct);
                            }
                        }
                    }
                }

                return this.privateDict;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ClaimTypeProviderCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class ClaimTypeProviderCollection : ConfigurationElementCollection
    {
        public ClaimTypeProviderCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new ClaimTypeProvider();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((ClaimTypeProvider)element).Type;
        }

        public ClaimTypeProvider this[int index]
        {
            get
            {
                return (ClaimTypeProvider)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public ClaimTypeProvider this[string type]
        {
            get
            {
                return BaseGet(type) as ClaimTypeProvider;
            }
        }

        public int IndexOf(ClaimTypeProvider parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(ClaimTypeProvider parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(ClaimTypeProvider parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.Type);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string type)
        {
            BaseRemove(type);
        }

        public void Clear()
        {
            BaseClear();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\AppliesToClaimType.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class AppliesToClaimType : ConfigurationElement, IAppliesToClaimType
    {
        public AppliesToClaimType()
        {
        }

        [ConfigurationProperty(
            "ClaimTypeUri",
             IsRequired = true,
             IsKey = true)]
        public Uri ClaimTypeUri
        {
            get 
            { 
                return this["ClaimTypeUri"] as Uri;
            }
            set
            {
                this["ClaimTypeUri"] = value;
            }
        }

        [ConfigurationProperty(
            "Required",
             IsRequired = false,
             DefaultValue = false)]
        public bool Required
        {
            get 
            { 
                return (bool)this["Required"]; 
            }
            set
            {
                this["Required"] = value;
            }
        }

        [ConfigurationProperty(
            "ClaimType",
             IsRequired = true)]
        internal ClaimType ClaimTypeElement
        {
            get
            {
                return this["ClaimType"] as ClaimType;
            }
            set
            {
                this["ClaimType"] = value;
            }
        }

        public IClaimType ClaimType
        {
            get 
            { 
                return this.ClaimTypeElement; 
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ClaimTypeCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class ClaimTypeCollection : ConfigurationElementCollection
    {
        public ClaimTypeCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new ClaimType();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((ClaimType)element).ClaimTypeUri;
        }

        public ClaimType this[int index]
        {
            get
            {
                return (ClaimType)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public ClaimType this[string ClaimTypeUri]
        {
            get
            {
                return BaseGet(ClaimTypeUri) as ClaimType;
            }
        }

        public int IndexOf(ClaimType parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(ClaimType parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(ClaimType parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.ClaimTypeUri);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string claimTypeUri)
        {
            BaseRemove(claimTypeUri);
        }

        public void Clear()
        {
            BaseClear();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ClaimType.cs ===
﻿using System;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class ClaimType : ConfigurationElement, IClaimType
    {

        public ClaimType(Uri Uri, string Title, string Description, bool Encrypted)
        {
            this.ClaimTypeUri = Uri;
            this.Title = Title;
            this.Description = Description;
            this.Encrypted = Encrypted;
        }

        public ClaimType()
        {
        }

        [ConfigurationProperty(
            "ClaimTypeUri",
             IsRequired = true,
             IsKey = true)]
        public System.Uri ClaimTypeUri
        {
            get
            {
                return this["ClaimTypeUri"] as System.Uri;
            }
            set
            {
                this["ClaimTypeUri"] = value;
            }
        }

        [ConfigurationProperty(
            "Encrypted",
             IsRequired = false,
             DefaultValue = false)]
        public bool Encrypted
        {
            get
            {
                return (bool)this["Encrypted"];
            }
            set
            {
                this["Encrypted"] = value;
            }
        }


        [ConfigurationProperty(
            "Title",
             IsRequired = true)]
        public string Title
        {
            get
            {
                return (string)this["Title"];
            }
            set
            {
                this["Title"] = value;
            }
        }

        [ConfigurationProperty(
            "Description",
            IsRequired = false,
            DefaultValue = "")]
        public string Description
        {
            get
            {
                return (string)this["Description"];
            }
            set
            {
                this["Description"] = value;
            }
        }

        [ConfigurationProperty(
            "Anonymized",
            IsRequired = false,
            DefaultValue = false)]
        public bool Anonymized
        {
            get
            {
                return (bool)this["Anonymized"];
            }
            set
            {
                this["Anonymized"] = value;
            }
        }

        [ConfigurationProperty(
            "ValueType",
            IsRequired = true,
            DefaultValue = "")]
        public string ValueType 
        {
            get
            {
                return (string)this["ValueType"];
            }
            set
            {
                this["ValueType"] = "true";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\Endpoint.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class Endpoint : ConfigurationElement, IEndpoint
    {
        public Endpoint()
        {
        }

        [ConfigurationProperty(
            "Hostname",
             IsRequired = false,
             DefaultValue = "")]
        public string Hostname
        {
            get 
            {
                return this["Hostname"] as string;
            }
            set
            {
                this["Hostname"] = value;
            }
        }

        [ConfigurationProperty(
            "Path",
             IsRequired = false,
             DefaultValue = "")]
        public string Path 
        {
            get 
            {
                return this["Path"] as string;
            }
            set
            {
                this["Path"] = value;
            }
        }

        [ConfigurationProperty(
            "Protocol",
             IsRequired = true,
             DefaultValue = "None")]
        public string Protocol
        {
            get 
            {
                return this["Protocol"] as string;
            }
            set
            {
                this["Protocol"] = value;
            }
        }

        [ConfigurationProperty(
            "ProtocolID",
             IsRequired = true,
             DefaultValue = "0")]
        public ushort ProtocolID
        {
            get 
            {
                return (ushort)this["ProtocolID"];
            }
            set
            {
                this["ProtocolID"] = value;
            }
        }

        [ConfigurationProperty(
            "FromIP",
             IsRequired = false,
             DefaultValue = (uint)0)]
        public uint FromIP
        {
            get 
            {
                return (uint)this["FromIP"];
            }
            set
            {
                this["FromIP"] = value;
            }
        }

        [ConfigurationProperty(
            "ToIP",
             IsRequired = false,
             DefaultValue = (uint)0)]
        public uint ToIP
        {
            get
            {
                return (uint)this["ToIP"];
            }
            set
            {
                this["ToIP"] = value;
            }
        }

        [ConfigurationProperty(
            "Port",
             IsRequired = true,
             DefaultValue = 0)]
        public int Port
        {
            get 
            {
                return (int)this["Port"];
            }
            set
            {
                this["Port"] = value;
            }
        }

        [ConfigurationProperty(
            "AppliesTo",
             IsRequired = false)]
        internal AppliesTo AppliesToElement
        {
            get
            {
                return this["AppliesTo"] as AppliesTo;
            }
            set
            {
                this["AppliesTo"] = value;
            }
        }

        public IAppliesTo AppliesTo
        {
            get
            {
                return this.AppliesToElement;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\EndpointCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
   
    public class EndpointCollection : ConfigurationElementCollection
    {
        public EndpointCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new Endpoint();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            Endpoint ep = (Endpoint)element;
            return ep.Hostname + ep.Path;
        }

        public Endpoint this[int index]
        {
            get
            {
                return (Endpoint)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public Endpoint this[string uri]
        {
            get
            {
                return BaseGet(uri) as Endpoint;
            }
        }

        public int IndexOf(Endpoint parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(Endpoint parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(Endpoint parameter)
        {
            int index = BaseIndexOf(parameter);
            if (index >= 0)
                BaseRemoveAt(index);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string uri)
        {
            BaseRemove(uri);
        }

        public void Clear()
        {
            BaseClear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBBusinessPartner.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBBusinessPartner : ConfigurationElement, IIEBBusinessPartner
    {
        public Guid Id
        {
            get
            {
                return new Guid(this.BusinessPartnerID);
            }
            set
            {
                this.BusinessPartnerID = value.ToString();
            }
        }

        [ConfigurationProperty(
            "BusinessPartnerID",
             IsRequired = false,
             DefaultValue = "")]
        protected string BusinessPartnerID
        {
            get
            {
                return this["BusinessPartnerID"] as string;
            }
            set
            {
                this["BusinessPartnerID"] = value;
            }
        }

        [ConfigurationProperty(
            "Name",
             IsRequired = true,
             DefaultValue = "")]
        public string  Name
        {
	        get 
            { 
                return this["Name"] as string;
            }
            set
            {
                this["Name"] = value;
            }
        }

        [ConfigurationProperty(
            "AnonymizingSalt",
             IsRequired = true,
             DefaultValue = "")]
        public string AnonymizingSalt
        {
            get
            {
                return this["AnonymizingSalt"] as string;
            }
            set
            {
                this["AnonymizingIdSalt"] = value;
            }
        }

        [ConfigurationProperty("Titles", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(TitleCollection),
            AddItemName = "Title",
            ClearItemsName = "clearTitles",
            RemoveItemName = "removeTitles")]
        internal TitleCollection TitlesElement
        {
            get
            {
                return base["Titles"] as TitleCollection;
            }
        }

        private IDictionary<uint, ITitle> privateTitles = null;
        private object syncLock = new Object();

        public IDictionary<uint, ITitle> Titles
        {
            get
            {
                if (this.privateTitles == null && this.TitlesElement != null)
                {
                    lock (this.syncLock)
                    {
                        if (this.privateTitles == null)
                        {
                            this.privateTitles = new Dictionary<uint, ITitle>();

                            foreach (Title tl in this.TitlesElement)
                            {
                                this.privateTitles.Add(tl.TitleID, tl);
                            }
                        }
                    }
                }

                return this.privateTitles;
            }
        }
        
        [ConfigurationProperty("IEBPartnerConnectionInfoes", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(IEBPartnerConnectionInfoCollection),
            AddItemName = "IEBPartnerConnectionInfo",
            ClearItemsName = "clearIEBPartnerConnectionInfoes",
            RemoveItemName = "removeIEBPartnerConnectionInfoes")]
        internal  IEBPartnerConnectionInfoCollection IEBPartnerConnectionInfoesElement
        {
            get
            {
                return base["IEBPartnerConnectionInfoes"] as IEBPartnerConnectionInfoCollection;
            }
        }

        private IList<IIEBPartnerConnectionInfo> privatePartnerConnectionInfoes = null;
        private object infoesLock = new Object();

        public IList<IIEBPartnerConnectionInfo> IEBPartnerConnectionInfoes
        {
            get
            {
                if (this.privatePartnerConnectionInfoes == null && this.IEBPartnerConnectionInfoesElement != null)
                {
                    lock(this.infoesLock)
                    {
                        if (this.privatePartnerConnectionInfoes == null)
                        {
                            this.privatePartnerConnectionInfoes = new List<IIEBPartnerConnectionInfo>();

                            foreach (IEBPartnerConnectionInfo pci in this.IEBPartnerConnectionInfoesElement)
                            {
                                this.privatePartnerConnectionInfoes.Add(pci);
                            }
                        }
                    }
                }

                return this.privatePartnerConnectionInfoes;
            }
        }

        [ConfigurationProperty("IEBBusinessPartnerKeys", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(IEBBusinessPartnerKeyCollection),
            AddItemName = "IEBBusinessPartnerKey",
            ClearItemsName = "clearIEBBusinessPartnerKeys",
            RemoveItemName = "removeIEBBusinessPartnerKeys")]
        internal IEBBusinessPartnerKeyCollection IEBBusinessPartnerKeysElement
        {
            get
            {
                return base["IEBBusinessPartnerKeys"] as IEBBusinessPartnerKeyCollection;
            }
        }

        private IList<IIEBBusinessPartnerKey> privatePartnerKeys = null;
        private object keysLock = new Object();

        public IList<IIEBBusinessPartnerKey> Keys
        {
            get
            {
                if (this.privatePartnerKeys == null && this.IEBBusinessPartnerKeysElement != null)
                {
                    lock (this.keysLock)
                    {
                        if (this.privatePartnerKeys == null)
                        {
                            this.privatePartnerKeys = new List<IIEBBusinessPartnerKey>();

                            foreach (IEBBusinessPartnerKey pk in this.IEBBusinessPartnerKeysElement)
                            {
                                this.privatePartnerKeys.Add(pk);
                            }
                        }
                    }
                }

                return this.privatePartnerKeys;
            }
        }

        public IIEBBusinessPartnerType Type
        {
            get { return null; }
        }

        public IList<Uri> Claims
        {
            get { return null; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBBusinessPartnerKey.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Security.Cryptography.X509Certificates;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBBusinessPartnerKey : ConfigurationElement, IIEBBusinessPartnerKey
    {
        public IEBBusinessPartnerKey()
        {
        }

        [ConfigurationProperty(
            "KeyVersion",
             IsRequired = true,
             DefaultValue = 1)]
        public int KeyVersion
        {
            get
            {
                return (int) this["KeyVersion"];
            }
            set
            {
                this["KeyVersion"] = value;
            }
        }

        private object lockIEBBusinessPartnerKey = new Object();
        private byte[] privateSymmetricKey = null;

        [ConfigurationProperty(
            "SymmetricKey",
             IsRequired = true)]
        private string SymmetricKeyElement
        {
            get
            {
                return this["SymmetricKey"] as string;
            }
            set
            {
                this["SymmetricKey"] = value;
            }
        }

        public byte[] SymmetricKey
        {
            get
            {
                if (this.privateSymmetricKey == null && this.SymmetricKeyElement != null)
                {
                    lock (this.lockIEBBusinessPartnerKey)
                    {
                        string k = this.SymmetricKeyElement;
                        if (!string.IsNullOrEmpty(k))
                        {
                            this.privateSymmetricKey = Convert.FromBase64String(k);
                        }
                    }
                }
                return this.privateSymmetricKey;
            }
        }

        private byte[] privateSymmetricIV = null;

        [ConfigurationProperty(
            "SymmetricIV",
             IsRequired = true)]
        private string SymmetricIVElement
        {
            get
            {
                return this["SymmetricIV"] as string;
            }
            set
            {
                this["SymmetricIV"] = value;
            }
        }

        public byte[] SymmetricIV
        {
            get
            {
                if (this.privateSymmetricIV == null && this.SymmetricIVElement != null)
                {
                    lock (this.lockIEBBusinessPartnerKey)
                    {
                        string k = this.SymmetricIVElement;
                        if (!string.IsNullOrEmpty(k))
                        {
                            this.privateSymmetricIV = Convert.FromBase64String(k);
                        }
                    }
                }
                return this.privateSymmetricIV;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBBusinessPartnerKeyCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBBusinessPartnerKeyCollection : ConfigurationElementCollection
    {
        public IEBBusinessPartnerKeyCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new IEBBusinessPartnerKey();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return string.Empty;
        }

        public IEBBusinessPartnerKey this[int index]
        {
            get
            {
                return (IEBBusinessPartnerKey)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        public int IndexOf(IEBBusinessPartnerKey parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(IEBBusinessPartnerKey parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(IEBBusinessPartnerKey parameter)
        {
            int index = BaseIndexOf(parameter);
            if (index >= 0)
                BaseRemoveAt(index);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Clear()
        {
            BaseClear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBPartnerConnectionInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Security.Cryptography.X509Certificates;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBPartnerConnectionInfo : ConfigurationElement, IIEBPartnerConnectionInfo
    {
        public IEBPartnerConnectionInfo()
        {
        }

        private System.Security.Cryptography.X509Certificates.X509Certificate2 privateCertificate = null;
        private object certLock = new Object();

        [ConfigurationProperty(
            "SecurityGatewayCertificate",
             IsRequired = true)]
        internal string SecurityGatewayCertificateElement
        {
            get
            {
                return this["SecurityGatewayCertificate"] as string;
            }
            set
            {
                this["SecurityGatewayCertificate"] = value;
            }
        }

        public X509Certificate2 SecurityGatewayCertificate
        {
            get
            {
                if (this.privateCertificate == null && this.SecurityGatewayCertificateElement != null)
                {
                    lock (this.certLock)
                    {
                        string certStr = this.SecurityGatewayCertificateElement;
                        if (!string.IsNullOrEmpty(certStr))
                        {
                            this.privateCertificate = new System.Security.Cryptography.X509Certificates.X509Certificate2(Convert.FromBase64String(certStr));
                        }
                    }
                }
                return this.privateCertificate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBPartnerConnectionInfoCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBPartnerConnectionInfoCollection : ConfigurationElementCollection
    {
        public IEBPartnerConnectionInfoCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new IEBPartnerConnectionInfo();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return string.Empty;
        }

        public IEBPartnerConnectionInfo this[int index]
        {
            get
            {
                return (IEBPartnerConnectionInfo)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        public int IndexOf(IEBPartnerConnectionInfo parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(IEBPartnerConnectionInfo parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(IEBPartnerConnectionInfo parameter)
        {
            int index = BaseIndexOf(parameter);
            if (index >= 0)
                BaseRemoveAt(index);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Clear()
        {
            BaseClear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBBusinessPartnerCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBBusinessPartnerCollection : ConfigurationElementCollection
    {
        public IEBBusinessPartnerCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new IEBBusinessPartner();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((IEBBusinessPartner)element).Name;
        }

        public IEBBusinessPartner this[int index]
        {
            get
            {
                return (IEBBusinessPartner)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public IEBBusinessPartner this[string name]
        {
            get
            {
                return BaseGet(name) as IEBBusinessPartner;
            }
        }

        public int IndexOf(IEBBusinessPartner parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(IEBBusinessPartner parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(IEBBusinessPartner parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.Name);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string name)
        {
            BaseRemove(name);
        }

        public void Clear()
        {
            BaseClear();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\IEBBusinessPartnerConfigurationProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class IEBBusinessPartnerConfigurationProvider : ConfigurationElement, IIEBBusinessPartnerConfigurationProvider
    {
        public IEBBusinessPartnerConfigurationProvider()
        {
        }

        [ConfigurationProperty("IEBBusinessPartners", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(IEBBusinessPartnerCollection),
            AddItemName = "IEBBusinessPartner",
            ClearItemsName = "clearIEBBusinessPartners",
            RemoveItemName = "removeIEBBusinessPartners")]
        internal  IEBBusinessPartnerCollection IEBBusinessPartnersElement
        {
            get
            {
                return base["IEBBusinessPartners"] as IEBBusinessPartnerCollection;
            }
        }

        private IDictionary<string, IIEBBusinessPartner> privateBusinessPartners = null;
        private object syncLock = new Object();

        public IDictionary<string, IIEBBusinessPartner> IEBBusinessPartners
        {
            get
            {
                if (this.privateBusinessPartners == null && this.IEBBusinessPartnersElement != null)
                {
                    lock(this.syncLock)
                    {
                        if (this.privateBusinessPartners == null)
                        {
                            this.privateBusinessPartners = new Dictionary<string, IIEBBusinessPartner>();

                            foreach (IEBBusinessPartner ibp in this.IEBBusinessPartnersElement)
                            {
                                this.privateBusinessPartners.Add(ibp.Name, ibp);
                            }
                        }
                    }
                }

                return this.privateBusinessPartners;
            }
        }
       

        public void  Init(IDictionary<string,string> parameters)
        {
 	        
        }

        public void  Load()
        {
 	        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\STSConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class STSConfiguration : ConfigurationElement, ISTSConfiguration
    {
        public STSConfiguration()
        {
        }

        [ConfigurationProperty(
            "IssuerName",
             IsRequired = true,
             DefaultValue = "")]
        public string IssuerName
        {
            get
            {
                return this["IssuerName"] as string;
            }
            set
            {
                this["IssuerName"] = value;
            }
        }

        [ConfigurationProperty(
            "IssuerUri",
             IsRequired = true,
             DefaultValue = "")]
        public Uri IssuerUri
        {
            get 
            { 
                return this["IssuerUri"] as Uri; 
            }
            set
            {
                this["IssuerUri"] = value;
            }
        }

        private System.Security.Cryptography.X509Certificates.X509Certificate2 privIssuerCertificate = null;
        private object certLock = new Object();

        [ConfigurationProperty(
            "IssuerCertificate",
             IsRequired = true)]
        internal string AppliesToCertificateElement
        {
            get
            {
                return this["IssuerCertificate"] as string;
            }
            set
            {
                this["IssuerCertificate"] = value;
            }
        }

        public System.Security.Cryptography.X509Certificates.X509Certificate2 IssuerCertificate
        {
            get
            {
                if (privIssuerCertificate == null)
                {
                    lock (this.certLock)
                    {
                        string certStr = this.AppliesToCertificateElement;
                            
                        if (!string.IsNullOrEmpty(certStr))
                        {
                            this.privIssuerCertificate = new System.Security.Cryptography.X509Certificates.X509Certificate2(Convert.FromBase64String(certStr));
                        }
                    }
                }
                return privIssuerCertificate;
            }
        }

        [ConfigurationProperty("AppliesToes", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(AppliesToCollection),
            AddItemName = "AppliesTo",
            ClearItemsName = "clearAppliesToes",
            RemoveItemName = "removeAppliesToes")]
        internal AppliesToCollection AppliesToesElement
        {
            get
            {
                return base["AppliesToes"] as AppliesToCollection;
            }
        }

        private IDictionary<Uri, IAppliesTo> privateAppliesToes = null;
        private object appliesToesLock = new Object();

        public IDictionary<Uri, IAppliesTo> AppliesToes
        {
            get
            {
                if (this.privateAppliesToes == null && this.AppliesToesElement != null)
                {
                    lock (this.appliesToesLock)
                    {
                        if (this.privateAppliesToes == null)
                        {
                            this.privateAppliesToes = new Dictionary<Uri, IAppliesTo>();

                            foreach (AppliesTo at in this.AppliesToesElement)
                            {
                                this.privateAppliesToes.Add(at.AppliesToUri, at);
                            }
                        }
                    }
                }

                return this.privateAppliesToes;
            }
        }

        [ConfigurationProperty("ClaimTypeProviders", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(ClaimTypeProviderCollection),
            AddItemName = "ClaimTypeProvider",
            ClearItemsName = "clearClaimTypeProviders",
            RemoveItemName = "removeClaimTypeProviders")]
        internal  ClaimTypeProviderCollection ClaimTypeProvidersElement
        {
            get
            {
                return base["ClaimTypeProviders"] as ClaimTypeProviderCollection;
            }
        }

        private IList<IClaimTypeProvider> privateClaimTypeProviders = null;
        private object claimTypeProvidersLock = new Object();

        public IList<IClaimTypeProvider> ClaimTypeProviders
        {
            get
            {
                if (this.privateClaimTypeProviders == null && this.ClaimTypeProvidersElement != null)
                {
                    lock(this.claimTypeProvidersLock)
                    {
                        if (this.privateClaimTypeProviders == null)
                        {
                            this.privateClaimTypeProviders = new List<IClaimTypeProvider>();

                            foreach (ClaimTypeProvider ctp in this.ClaimTypeProvidersElement)
                            {
                                this.privateClaimTypeProviders.Add(ctp);
                            }
                        }
                    }
                }

                return this.privateClaimTypeProviders;
            }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\TokenType.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class TokenType : ConfigurationElement, ITokenType
    {
        public TokenType (Uri uri, string Description = "")
        {
            this.Uri = uri;
            this.Description = Description;
        }

        public TokenType()
        {
        }   

        [ConfigurationProperty(
            "Uri",
             IsRequired = true,
             IsKey = true)]
        public Uri Uri
        {
            get
            {
                return this["Uri"] as Uri;
            }
            set
            {
                this["Uri"] = value;
            }
        }

        [ConfigurationProperty(
            "Description",
            IsRequired = false,
            DefaultValue = "")]
        public string Description
        {
            get
            {
                return (string)this["Description"];
            }
            set
            {
                this["Description"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\STSConfigurationProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class STSConfigurationProvider : ConfigurationElement, ISTSConfigurationProvider
    {
        public STSConfigurationProvider()
        {
        }

        [ConfigurationProperty("STSConfiguration", IsRequired = true)]
        internal STSConfiguration STSConfigurationElement
        {
            get
            {
                return this["STSConfiguration"] as STSConfiguration;
            }

            set
            {
                this["STSConfiguration"] = value;
            }
        }

        public ISTSConfiguration STSConfiguration
        {
            get 
            {
                return this.STSConfigurationElement;
            }
        }

       
        public void Init(IDictionary<string, string> parameters)
        {
            
        }

        public void Load()
        {
            
        }
 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\Title.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{
    public class Title : ConfigurationElement, ITitle
    {
        [ConfigurationProperty(
             "TitleID",
             IsRequired = true,
             IsKey  = true)]
        public uint TitleID
        {
            get 
            {
                return (uint)this["TitleID"];
            }
            set
            {
                this["TitleID"] = value;
            }
        }

        [ConfigurationProperty("Endpoints", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(EndpointCollection),
            AddItemName = "Endpoint",
            ClearItemsName = "clearEndpoints",
            RemoveItemName = "removeEndpoints")]
        internal EndpointCollection EndpointsElement
        {
            get
            {
                return base["Endpoints"] as EndpointCollection;
            }
        }

        private IList<IEndpoint> privateEndpoints = null;
        private object syncLock = new Object();

        public IList<IEndpoint> Endpoints
        {
            get
            {
                if (this.privateEndpoints == null && this.EndpointsElement != null)
                {
                    lock (this.syncLock)
                    {
                        if (this.privateEndpoints == null)
                        {
                            this.privateEndpoints = new List<IEndpoint>();

                            foreach (Endpoint ep in this.EndpointsElement)
                            {
                                this.privateEndpoints.Add(ep);
                            }
                        }
                    }
                }

                return this.privateEndpoints;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\TitleCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.configFileImpl
{

    public class TitleCollection : ConfigurationElementCollection
    {
        public TitleCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new Title();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((Title)element).TitleID;
        }

        public Title this[int index]
        {
            get
            {
                return (Title)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public Title this[string titleID]
        {
            get
            {
                return BaseGet(Convert.ToUInt32(titleID)) as Title;
            }
        }

        public int IndexOf(Title parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(Title parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(Title parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.TitleID);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(uint titleID)
        {
            BaseRemove(titleID);
        }

        public void Clear()
        {
            BaseClear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ConfigFileImpl_UnitTests\TokenType_UnitTests.cs ===
﻿using xonline.config.sts.configFileImpl;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;

namespace ConfigFileImpl_UnitTests
{
    
    
    /// <summary>
    ///This is a test class for TokenType_UnitTests and is intended
    ///to contain all TokenType_UnitTests Unit Tests
    ///</summary>
    [TestClass()]
    public class TokenType_UnitTests
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A test for TokenType Constructor
        ///</summary>
        [TestMethod()]
        public void TokenTypeConstructorTest()
        {
            TokenType target = new TokenType();
            Assert.AreEqual(null, target.Uri);
            Assert.AreEqual(string.Empty, target.Description);
        }

        /// <summary>
        ///A test for TokenType Constructor
        ///</summary>
        [TestMethod()]
        public void TokenTypeConstructorTest1()
        {
            Uri uri = new Uri("http://www.tokentype.com/");
            string Description = "SomeDescription";
            TokenType target = new TokenType(uri, Description);
            Assert.AreEqual(uri, target.Uri);
            Assert.AreEqual(Description, target.Description);
        }

        /// <summary>
        ///A test for Description
        ///</summary>
        [TestMethod()]
        public void DescriptionTest()
        {
            TokenType target = new TokenType(); 
            string expected = "SomeDescription";
            target.Description = expected;
            string actual;
            actual = target.Description;
            Assert.AreEqual(expected, actual);
        }

        /// <summary>
        ///A test for Uri
        ///</summary>
        [TestMethod()]
        public void UriTest()
        {
            TokenType target = new TokenType();
            Uri expected = new Uri("http://www.tokentype.com/");
            target.Uri = expected;
            Uri actual;
            actual = target.Uri;
            Assert.AreEqual(expected, actual);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ConfigFileImpl_UnitTests\ClaimType_UnitTests.cs ===
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.config.sts.configFileImpl;

namespace ConfigFileImpl_UnitTests
{
    
    
    /// <summary>
    ///This is a test class for Claim_UnitTests and is intended
    ///to contain all Claim_UnitTests Unit Tests
    ///</summary>
    [TestClass()]
    public class ClaimType_UnitTests
    {

        /// <summary>
        /// The test context
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A test for the default ClaimType Constructor
        ///</summary>
        [TestMethod()]
        public void ClaimConstructor_Test()
        {
            ClaimType target = new ClaimType();
            Assert.AreEqual(null, target.ClaimTypeUri);
            Assert.AreEqual(string.Empty, target.Title);
            Assert.AreEqual(string.Empty, target.Description);
            Assert.AreEqual(false, target.Private);
            Assert.IsFalse(target.Encrypted);
        }

        /// <summary>
        ///A test for ClaimType Constructor
        ///</summary>
        [TestMethod()]
        public void ClaimConstructor_Test1()
        {
            Uri uri = new Uri("http://www.firstclaimtype.com/");
            string Title = "SomeTitle";
            string Description = "SomeDescription";
            bool Encrypted = true;
            bool Private = true;
            ClaimType target = new ClaimType(uri, Title, Description, Encrypted, Private);
            Assert.AreEqual(new Uri("http://www.firstclaimtype.com/"), target.ClaimTypeUri);
            Assert.AreEqual(Title, target.Title);
            Assert.AreEqual(Description, target.Description);
            Assert.AreEqual(Private, target.Private);
            Assert.AreEqual(Encrypted, target.Encrypted);
        }

        /// <summary>
        ///A test for Description
        ///</summary>
        [TestMethod()]
        public void Description_Test()
        {
            ClaimType target = new ClaimType();
            string expected = "SomeDescription";
            string actual;
            target.Description = expected;
            actual = target.Description;
            Assert.AreEqual(expected, actual);
        }

        /// <summary>
        ///A test for Encrypted
        ///</summary>
        [TestMethod()]
        public void Encrypted_Test()
        {
            ClaimType target = new ClaimType();
            bool expected = true;
            bool actual;
            target.Encrypted = expected;
            actual = target.Encrypted;
            Assert.AreEqual(expected, actual);
        }

        /// <summary>
        ///A test for Private
        ///</summary>
        [TestMethod()]
        public void Private_Test()
        {
            ClaimType target = new ClaimType();
            bool expected = true;
            bool actual;
            target.Private = true;
            actual = target.Private;
            Assert.AreEqual(expected, actual);
        }

        /// <summary>
        ///A test for Title
        ///</summary>
        [TestMethod()]
        public void Title_Test()
        {
            ClaimType target = new ClaimType();
            string expected = "SomeClaim";
            string actual;
            target.Title = expected;
            actual = target.Title;
            Assert.AreEqual(expected, actual);
        }

        /// <summary>
        ///A test for ClaimTypeUri
        ///</summary>
        [TestMethod()]
        public void Uri_Test()
        {
            ClaimType target = new ClaimType();
            Uri expected = new Uri("http://www.firstclaimtype.com/");
            Uri actual;
            target.ClaimTypeUri = expected;
            actual = target.ClaimTypeUri;
            Assert.AreEqual(expected, actual);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ConfigFileImpl_UnitTests\ClaimTypeProvider_UnitTests.cs ===
﻿using xonline.config.sts.configFileImpl;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using xonline.config.sts.interfaces;
using System.Collections.Generic;

namespace ConfigFileImpl_UnitTests
{
    
    
    /// <summary>
    ///This is a test class for ClaimTypeProvider_UnitTests and is intended
    ///to contain all ClaimTypeProvider_UnitTests Unit Tests
    ///</summary>
    [TestClass()]
    public class ClaimTypeProvider_UnitTests
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A test for ClaimTypeProvider Constructor
        ///</summary>
        [TestMethod()]
        public void ClaimTypeProviderConstructorTest()
        {
            ClaimTypeProvider target = new ClaimTypeProvider();

            Assert.AreEqual(string.Empty, target.Type);
        }

        /// <summary>
        ///A test for ClaimTypes
        ///</summary>
        [TestMethod()]
        public void ClaimTypesTest()
        {
            //ClaimTypeProvider target = new ClaimTypeProvider();
            //ClaimTypeCollection expected = new ClaimTypeCollection();
            //expected.Add(new ClaimType());
            //expected[0].Title = "ClaimTypeTitle";
            //target.ClaimTypeElements = expected;
            //Assert.AreEqual(1, target.ClaimTypeElements.Count);
            //IDictionary<string, IClaimType> actual;
            //actual = target.ClaimTypes;
            //Assert.AreEqual(1, actual.Count);
            //ICollection<string> keys = actual.Keys;
            //IEnumerator<string> enumerator = keys.GetEnumerator();
            //enumerator.MoveNext();
            //string actualkey = enumerator.Current;
         
            //Assert.AreEqual("ClaimTypeTitle", actualkey);
        }

        /// <summary>
        ///A test for Type
        ///</summary>
        [TestMethod()]
        public void TypeTest()
        {
            ClaimTypeProvider target = new ClaimTypeProvider(); 
            string expected = "ClaimTypeProviderType";
            target.Type = expected;
            string actual;
            actual = target.Type;
            Assert.AreEqual(expected, actual);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ConfigFileImpl_UnitTests\ConfigFile_UnitTests.cs ===
﻿using System;
using System.Configuration;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.config.sts.configFileImpl;
using xonline.config.sts.interfaces;
using System.Collections.Generic;
using System.Collections;

namespace ConfigFileImpl_UnitTests
{
    [TestClass]
    public class ConfigFile_UnitTests
    {
        /// <summary>
        /// The config file used for test purposes.
        /// </summary>
        private static Configuration config = null;
 
        /// <summary>
        /// Loads the config file into memory.
        /// </summary>
        /// <param name="testContext">Not used.</param>
        [ClassInitialize()]
        public static void LoadConfigFile_Test(TestContext testContext)
        {
            string configFileName = "Test.config";
            ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap();
            fileMap.ExeConfigFilename = configFileName;
            ConfigFile_UnitTests.config = 
                ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);
            Assert.IsNotNull(config);
        }

        /// <summary>
        /// Test the functioning of the ClaimType Element.
        /// </summary>
        [TestMethod]
        public void ClaimElement_Test()
        {
            string claimTestSectionName = "ClaimTest";
            ClaimTestConfigurationSectionHandler testConfigHandler = 
                ConfigFile_UnitTests.config.GetSection(claimTestSectionName) as ClaimTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);

            IClaimType claim = testConfigHandler.Claim;
            Assert.AreEqual("ClaimDescription", claim.Description);
            Assert.AreEqual("ClaimTitle", claim.Title);
            Assert.AreEqual(true, claim.Private);
            Assert.AreEqual(new Uri("http://www.claimtype.com/"), claim.ClaimTypeUri);
            Assert.AreEqual(true, claim.Encrypted);
        }

        /// <summary>
        /// Test the functioning of the TokenType Element.
        /// </summary>
        [TestMethod]
        public void TokenTypeElement_Test()
        {
            string tokenTypeTestSectionName = "TokenTypeTest";
            TokenTypeTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(tokenTypeTestSectionName) as TokenTypeTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);

            ITokenType tokenType = testConfigHandler.TokenType;
            Assert.AreEqual("TokenTypeDescription", tokenType.Description);
            Assert.AreEqual(new Uri("http://www.tokentype.com/"), tokenType.Uri);
        }

        /// <summary>
        /// Test the functioning of the ClaimTypeProvider Element.
        /// </summary>
        [TestMethod]
        public void ClaimTypeProviderElement_Test()
        {
            string claimTypeProviderTestSectionName = "ClaimTypeProviderTest";
            ClaimTypeProviderTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(claimTypeProviderTestSectionName) as ClaimTypeProviderTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            IClaimTypeProvider claimTypeProvider = testConfigHandler.ClaimTypeProvider;
            
            Assert.AreEqual("ProviderType",claimTypeProvider.Type );
            Assert.AreEqual(2, claimTypeProvider.ClaimTypes.Count);
            Assert.AreEqual("FirstClaimTitle", claimTypeProvider.ClaimTypes[new Uri("http://www.firstclaimtype.com/")].Title);
            Assert.AreEqual("SecondClaimTitle", claimTypeProvider.ClaimTypes[new Uri("http://www.secondclaimtype.com/")].Title);
        }

        /// <summary>
        /// Test the functioning of the STSConfiguration Element.
        /// </summary>
        [TestMethod]
        public void STSConfigurationElement_Test()
        {
            string stsConfigurationTestSectionName = "STSConfigurationTest";
            STSConfigurationTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(stsConfigurationTestSectionName) as STSConfigurationTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            ISTSConfiguration stsConfiguration = testConfigHandler.STSConfiguration;

            Assert.AreEqual("IssuerName", stsConfiguration.IssuerName);
            Assert.AreEqual(new Uri("http://www.teststs.com"), stsConfiguration.IssuerUri);
            Assert.IsNotNull(stsConfiguration.IssuerCertificate);
            Assert.AreEqual(1, stsConfiguration.ClaimTypeProviders.Count);
            Assert.AreEqual("ProviderType", stsConfiguration.ClaimTypeProviders[0].Type);
          
            Assert.AreEqual(2, stsConfiguration.AppliesToes.Count);
            //Assert.AreEqual("FirstAnonId", stsConfiguration.AppliesToes[new Uri("http://www.firstappliesto.com")].AnonymizingId);
            //Assert.AreEqual("SecondAnonId", stsConfiguration.AppliesToes[new Uri("http://www.secondappliesto.com")].AnonymizingId);

        }

        /// <summary>
        /// Test the functioning of the STSConfigurationProvider Element.
        /// </summary>
        [TestMethod]
        public void STSConfigurationProviderElement_Test()
        {
            string stsConfigurationProviderTestSectionName = "STSConfigurationProviderTest";
            STSConfigurationProviderTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(stsConfigurationProviderTestSectionName) as STSConfigurationProviderTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            ISTSConfigurationProvider stsConfigurationProvider = testConfigHandler.STSConfigurationProvider;

            Assert.AreEqual("IssuerName", stsConfigurationProvider.STSConfiguration.IssuerName);
            Assert.AreEqual(new Uri("http://www.teststs.com"), stsConfigurationProvider.STSConfiguration.IssuerUri);
            Assert.IsNotNull(stsConfigurationProvider.STSConfiguration.IssuerCertificate);
            Assert.AreEqual(1, stsConfigurationProvider.STSConfiguration.ClaimTypeProviders.Count);
            Assert.AreEqual("ProviderType", stsConfigurationProvider.STSConfiguration.ClaimTypeProviders[0].Type);

            Assert.AreEqual(2, stsConfigurationProvider.STSConfiguration.AppliesToes.Count);
            //Assert.AreEqual("FirstAnonId", stsConfigurationProvider.STSConfiguration.AppliesToes[new Uri("http://www.firstappliesto.com")].AnonymizingId);
            //Assert.AreEqual("SecondAnonId", stsConfigurationProvider.STSConfiguration.AppliesToes[new Uri("http://www.secondappliesto.com")].AnonymizingId);

        }

        /// <summary>
        /// Test the functioning of the AppliesTo Element.
        /// </summary>
        [TestMethod]
        public void AppliesToElement_Test()
        {
            string appliesToTestSectionName = "AppliesToTest";
            AppliesToTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(appliesToTestSectionName) as AppliesToTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            AppliesTo appliesTo = testConfigHandler.AppliesTo;

            Assert.AreEqual(new Uri("http://www.appliesto.com/"), appliesTo.AppliesToUri);
            Assert.AreEqual("AnonId", appliesTo.AnonymizingId);
            Assert.IsNotNull(appliesTo.AppliesToCertificate);
           
        }

        /// <summary>
        /// Test the functioning of the Title Element.
        /// </summary>
        [TestMethod]
        public void TitleElement_Test()
        {
            string titleTestSectionName = "TitleTest";
            TitleTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(titleTestSectionName) as TitleTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            Title title = testConfigHandler.Title;

            Assert.AreEqual((uint)1, title.TitleID);
            Assert.AreEqual(2, title.Endpoints.Count);
            Assert.AreEqual("FirstEndpointProtocol", title.Endpoints[0].Protocol);
            Assert.AreEqual("SecondEndpointProtocol", title.Endpoints[1].Protocol);
        }

        /// <summary>
        /// Test the functioning of the IEBBusinessPartner Element.
        /// </summary>
        [TestMethod]
        public void IEBBusinessPartnerElement_Test()
        {
            string iebBusinessPartnerTestSectionName = "IEBBusinessPartnerTest";
            IEBBusinessPartnerTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(iebBusinessPartnerTestSectionName) as IEBBusinessPartnerTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            IEBBusinessPartner iebBusinessPartner = testConfigHandler.IEBBusinessPartner;

            Assert.AreEqual(new Guid("10000000-0000-0000-0000-000000000000"), iebBusinessPartner.Id);
            Assert.AreEqual("BusinessPartnerName", iebBusinessPartner.Name);
            //Assert.AreEqual("AnonId", iebBusinessPartner.AnonymizingId);
            Assert.AreEqual(1, iebBusinessPartner.Titles.Count);
            Assert.AreEqual(1, iebBusinessPartner.IEBPartnerConnectionInfoes.Count);
            foreach (IIEBPartnerConnectionInfo pci in iebBusinessPartner.IEBPartnerConnectionInfoes)
            {
                Assert.IsNotNull(pci.SecurityGatewayCertificate);
            }
        }

        /// <summary>
        /// Test the functioning of the IEBBusinessPartnerConfigurationProvider Element.
        /// </summary>
        [TestMethod]
        public void IEBBusinessPartnerConfigurationProviderElement_Test()
        {
            string iebBusinessPartnerConfigurationProviderTestSectionName = "IEBBusinessPartnerConfigurationProviderTest";
            IEBBusinessPartnerConfigurationProviderTestConfigurationSectionHandler testConfigHandler =
                ConfigFile_UnitTests.config.GetSection(iebBusinessPartnerConfigurationProviderTestSectionName) as IEBBusinessPartnerConfigurationProviderTestConfigurationSectionHandler;
            Assert.IsNotNull(testConfigHandler);
            IEBBusinessPartnerConfigurationProvider iebBusinessPartnerConfigurationProvider = testConfigHandler.IEBBusinessPartnerConfigurationProvider;

            Assert.AreEqual(1, iebBusinessPartnerConfigurationProvider.IEBBusinessPartners.Count);
            //Assert.AreEqual("AnonId", iebBusinessPartnerConfigurationProvider.IEBBusinessPartners["BusinessPartnerName"].AnonymizingId);
        }
    }


    /// <summary>
    /// Config handler for a section that contains a ClaimType Element.  For testing only.
    /// </summary>
    public class ClaimTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("ClaimType", IsRequired = true)]
        public ClaimType Claim
        {
            get
            {
                return this["ClaimType"] as ClaimType;
            }

            set
            {
                this["ClaimType"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a TokenType Element.  For testing only.
    /// </summary>
    public class TokenTypeTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("TokenType", IsRequired = true)]
        public TokenType TokenType
        {
            get
            {
                return this["TokenType"] as TokenType;
            }

            set
            {
                this["TokenType"] = value;
            }
        }
    }
    /// <summary>
    /// Config handler for a section that contains a ClaimTypeProvider Element.  For testing only.
    /// </summary>
    public class ClaimTypeProviderTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("ClaimTypeProvider", IsRequired = true)]
        public ClaimTypeProvider ClaimTypeProvider
        {
            get
            {
                return this["ClaimTypeProvider"] as ClaimTypeProvider;
            }

            set
            {
                this["ClaimTypeProvider"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a STSConfiguration Element.  For testing only.
    /// </summary>
    public class STSConfigurationTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("STSConfiguration", IsRequired = true)]
        public STSConfiguration STSConfiguration
        {
            get
            {
                return this["STSConfiguration"] as STSConfiguration;
            }

            set
            {
                this["STSConfiguration"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a STSConfigurationProvider Element.  For testing only.
    /// </summary>
    public class STSConfigurationProviderTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("STSConfigurationProvider", IsRequired = true)]
        public STSConfigurationProvider STSConfigurationProvider
        {
            get
            {
                return this["STSConfigurationProvider"] as STSConfigurationProvider;
            }

            set
            {
                this["STSConfigurationProvider"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a AppliesTo Element.  For testing only.
    /// </summary>
    public class AppliesToTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("AppliesTo", IsRequired = true)]
        public AppliesTo AppliesTo
        {
            get
            {
                return this["AppliesTo"] as AppliesTo;
            }

            set
            {
                this["AppliesTo"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a Title Element.  For testing only.
    /// </summary>
    public class TitleTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("Title", IsRequired = true)]
        public Title Title
        {
            get
            {
                return this["Title"] as Title;
            }

            set
            {
                this["Title"] = value;
            }
        }
    }

    /// <summary>
    /// Config handler for a section that contains a IEBBusinessPartner Element.  For testing only.
    /// </summary>
    public class IEBBusinessPartnerTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("IEBBusinessPartner", IsRequired = true)]
        public IEBBusinessPartner IEBBusinessPartner
        {
            get
            {
                return this["IEBBusinessPartner"] as IEBBusinessPartner;
            }

            set
            {
                this["IEBBusinessPartner"] = value;
            }
        }
    }
    /// <summary>
    /// Config handler for a section that contains a IEBBusinessPartnerCongurationProvider Element.  For testing only.
    /// </summary>
    public class IEBBusinessPartnerConfigurationProviderTestConfigurationSectionHandler : ConfigurationSection
    {
        [ConfigurationProperty("IEBBusinessPartnerConfigurationProvider", IsRequired = true)]
        public IEBBusinessPartnerConfigurationProvider IEBBusinessPartnerConfigurationProvider
        {
            get
            {
                return this["IEBBusinessPartnerConfigurationProvider"] as IEBBusinessPartnerConfigurationProvider;
            }

            set
            {
                this["IEBBusinessPartnerConfigurationProvider"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:25:32 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.31.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:10:24 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\ConfigFileImpl_UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConfigFileImpl_UnitTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ConfigFileImpl_UnitTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c9200e19-9021-47d9-a507-a3a6b7517495")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\AppliesTo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class AppliesTo : IAppliesTo
    {
        public AppliesTo()
        {
            ClaimTypes = new Dictionary<Uri, IAppliesToClaimType>();
        }

        public static AppliesTo FromDbObject(DatabaseObjectFactory objFac, AppliesToDB atdb)
        {
            AppliesTo a = new AppliesTo();

            a.AppliesToUri = new Uri(atdb.AppliesToUrl);
            a.ValidityInterval = atdb.ValidityInterval;
            a.BusinessPartner = objFac.CreatedBusinessPartners[atdb.BusinessPartnerID];
            a.TokenType = xonline.config.sts.databaseconfig.TokenType.FromDbObject(objFac, objFac.TokenTypes[atdb.TokenType]);

            if (!string.IsNullOrEmpty(atdb.AppliesToCert))
            {
                byte[] rawCertificate = Convert.FromBase64String(atdb.AppliesToCert);
                a.AppliesToCertificate = new X509Certificate2(rawCertificate);
            }
            else
            {
                a.AppliesToCertificate = null;
            }

            if(objFac.AppliesToClaims.ContainsKey(atdb.AppliesToUrl))
            {
                foreach(AppliesToClaimTypeDB atcdb in objFac.AppliesToClaims[atdb.AppliesToUrl])
                {
                    AppliesToClaimType atc = AppliesToClaimType.FromDbObject(objFac, atcdb);
                    a.ClaimTypes.Add(atc.ClaimTypeUri, atc);
                }
            }

            return a;
        }

        public AppliesToDB ToDbObject()
        {
            AppliesToDB atdb = new AppliesToDB();

            atdb.AppliesToUrl = AppliesToUri.ToString();

            if(AppliesToCertificate != null)
            {
                atdb.AppliesToCert = Convert.ToBase64String(AppliesToCertificate.RawData);
            }
            else
            {
                atdb.AppliesToCert = "";
            }

            atdb.TokenType = TokenType.Uri.ToString();
            atdb.ValidityInterval = ValidityInterval;
            atdb.BusinessPartnerID = ((IEBBusinessPartner)BusinessPartner).Id;

            return atdb;
        }

        public IIEBBusinessPartner BusinessPartner { get; set; }
        public Uri AppliesToUri { get; set; }
        public TimeSpan ValidityInterval { get; set; }
        public X509Certificate2 AppliesToCertificate { get; set; }
        public IDictionary<Uri, IAppliesToClaimType> ClaimTypes { get; set; }
        public ITokenType TokenType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\STSConfigurationInterfaces_UnitTests\ConfigurationProviderBase_UnitTests.cs ===
﻿using System.Configuration;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.config.sts.interfaces;

namespace STSConfigurationInterfaces_UnitTests
{
    
    
    /// <summary>
    ///This is a test class for ConfigurationProviderBase_UnitTests and is intended
    ///to contain all ConfigurationProviderBase_UnitTests Unit Tests
    ///</summary>
    [TestClass()]
    public class ConfigurationProviderBase_UnitTests
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion

        private static Configuration config = null;

        /// <summary>
        /// Loads the config file into memory.
        /// </summary>
        /// <param name="testContext">Not used.</param>
        [ClassInitialize()]
        public static void LoadConfigFile_Test(TestContext testContext)
        {
            string configFileName = "STSConfigurationInterfaces_UnitTests.config";
            ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap();
            fileMap.ExeConfigFilename = configFileName;
            ConfigurationProviderBase_UnitTests.config =
                ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);
            Assert.IsNotNull(config);
        }

        /// <summary>
        ///A test for Load
        ///</summary>
        [TestMethod()]
        public void Load_Test()
        {
            string claimTestSectionName = "ConfigurationProviderTestSection";
            ConfigurationProviderBase testConfigHandler =
                ConfigurationProviderBase_UnitTests.config.GetSection(claimTestSectionName) as ConfigurationProviderBase;
            testConfigHandler.Load();
        }

        /// <summary>
        ///A test for ConfigurationProviderBase Constructor
        ///</summary>
        [TestMethod()]
        public void ConfigurationProviderBaseConstructor_Test()
        {
            ConfigurationProviderBase target = new ConfigurationProviderBase();
        }

        /// <summary>
        ///A test for Parameters
        ///</summary>
        [TestMethod()]
        public void Parameters_Test()
        {
            string claimTestSectionName = "ConfigurationProviderTestSection";
            ConfigurationProviderBase testConfigHandler =
                ConfigurationProviderBase_UnitTests.config.GetSection(claimTestSectionName) as ConfigurationProviderBase;
            Assert.IsNotNull(testConfigHandler);
            Assert.IsNotNull(testConfigHandler.Parameters);
            Assert.AreEqual<int>(2, testConfigHandler.Parameters.Count);
            Assert.AreEqual<string>("7", testConfigHandler.Parameters["foo"].Value);
            Assert.AreEqual<string>("555", testConfigHandler.Parameters["bar"].Value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\Claim.cs ===
﻿using System;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class ClaimType : IClaimType
    {
        public ClaimType()
        {

        }

        public static ClaimType FromDbObject(DatabaseObjectFactory objFac, ClaimTypeDB claimdb)
        {
            ClaimType c = new ClaimType();

            c.ClaimTypeUri = new Uri(claimdb.ClaimUri);
            c.Encrypted = claimdb.Encrypted;
            c.Title = claimdb.FriendlyTitle;
            c.Description = claimdb.FriendlyDescription;
            c.Anonymized = claimdb.Anonymized;
            c.ValueType = claimdb.ValueType;

            return c;
        }

        public ClaimTypeDB ToDbObject()
        {
            ClaimTypeDB c = new ClaimTypeDB();

            c.ClaimUri = ClaimTypeUri.ToString();
            c.FriendlyTitle = Title;
            c.FriendlyDescription = Description;
            c.Anonymized = Anonymized;
            c.Encrypted = Encrypted;
            c.ValueType = ValueType;

            return c;
        }

        public Uri ClaimTypeUri { get; set; }
        public bool Encrypted { get; set; }
        public string Title { get; set; }
        public string Description { get; set; }
        public bool Anonymized { get; set; }
        public string ValueType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\DatabaseConfigurationProvider.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * DatabaseConfigurationProvider.cs
 *
 * Database layer that interfaces with the STS object model interface rather than the 
 * flat database object model.
 *
 */

using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class DatabaseConfigurationProvider : IIEBBusinessPartnerConfigurationProvider, ISTSConfigurationProvider
    {
        public void Init(IDictionary<string, string> parameters)
        {

        }

        public void Load()
        {
            // Here is where we call the factory to create these objects.  This will call below to
            // hit the database.
            //
            DatabaseObjectFactory dof = new DatabaseObjectFactory();

            dof.Load();

            // The calls to create the business partners actually make the graph, but STSConfiguration is
            // mostly just another view.  For the small parts that aren't common, STSConfiguration will load
            // those.
            IEBBusinessPartners = new Dictionary<string, IIEBBusinessPartner>();

            foreach(BusinessPartnerDB bp in dof.BusinessPartners.Values)
            {
                IEBBusinessPartner part = IEBBusinessPartner.FromDbObject(dof, bp);
                IEBBusinessPartners.Add(part.Name, part);
            }

            foreach(IEBBusinessPartner p in IEBBusinessPartners.Values)
            {
                p.Deserialize(dof);
            }

            STSConfiguration = new STSConfiguration(dof);
        }

        public IDictionary<string, IIEBBusinessPartner> IEBBusinessPartners { get; set; }
        public ISTSConfiguration STSConfiguration { get; set; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\ClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.config.sts.interfaces;
using xonline.config.sts.databaseconfig;

namespace xonline.config.sts.databaseconfig
{
    public class ClaimTypeProvider : IClaimTypeProvider
    {
        public ClaimTypeProvider()
        {
            ClaimTypes = new Dictionary<Uri, IClaimType>();
            Id = new Guid();
        }

        public static ClaimTypeProvider FromDbObject(DatabaseObjectFactory factory, ClaimTypeProviderDB cpdb)
        {
            ClaimTypeProvider c = new ClaimTypeProvider();

            c.Id = cpdb.ClaimProviderID;
            c.Type = cpdb.AssemblyName;
            c.Name = cpdb.FriendlyName;
            if (factory.ClaimProviderClaims.ContainsKey(cpdb.ClaimProviderID))
            {
               foreach(ClaimTypeProviderClaimDB ctc in factory.ClaimProviderClaims[cpdb.ClaimProviderID])
               {
                  IClaimType claim = ClaimType.FromDbObject(factory, factory.Claims[ctc.ClaimUri]);
                  c.ClaimTypes.Add(claim.ClaimTypeUri, claim);
               }
            }
            return c;
        }

        public ClaimTypeProviderDB ToDbObject()
        {
            ClaimTypeProviderDB c = new ClaimTypeProviderDB();

            c.ClaimProviderID = Id;
            c.FriendlyName = Name;
            c.AssemblyName = Type;

            return c;
        }

        public Guid Id { get; set; }

        public string Type { get; set; }
        public string Name { get; set; }
        public IDictionary<Uri, IClaimType> ClaimTypes { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\ConfigFileImpl\STSConfigurationInterfaces_UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("STSConfigurationInterfaces_UnitTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("STSConfigurationInterfaces_UnitTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5119fb9e-e2bb-45b7-9cad-4dd0660929fc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\AppliesToClaim.cs ===
﻿using System;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class AppliesToClaimType : IAppliesToClaimType
    {
        public AppliesToClaimType()
        {

        }

        public static AppliesToClaimType FromDbObject(DatabaseObjectFactory objFac, AppliesToClaimTypeDB atcdb)
        {
            AppliesToClaimType a = new AppliesToClaimType();

            a.AppliesToUrl = new Uri(atcdb.AppliesToUrl);
            a.ClaimTypeUri = new Uri(atcdb.ClaimUrl);
            a.Required = atcdb.Required;
            a.ClaimType = xonline.config.sts.databaseconfig.ClaimType.FromDbObject(objFac, objFac.Claims[atcdb.ClaimUrl]);

            return a;
        }

        public AppliesToClaimTypeDB ToDbObject()
        {
            AppliesToClaimTypeDB atctdb = new AppliesToClaimTypeDB();
            atctdb.AppliesToUrl = AppliesToUrl.ToString();
            atctdb.ClaimUrl = ClaimTypeUri.ToString();
            atctdb.Required = Required;

            return atctdb;
        }

        public Uri AppliesToUrl { get; set; }
        public Uri ClaimTypeUri { get; set; }
        public bool Required { get; set; }
        public IClaimType ClaimType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\DatabaseLookupTable.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * STS Config
 *
 * DatabaseLookupTable.cs
 *
 * A simple class to wrap around a lookup but read from a table.
 *
 */

using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;


namespace xonline.config.sts.databaseconfig
{
    public class DatabaseLookupTable<TKey, TValue> : Dictionary<TKey, TValue>
    {
        public DatabaseLookupTable(string db, string sproc, string keycol, string valcol, IEqualityComparer<TKey> comparer) :
            base(comparer)
        {
            using (WSClient client = new WSClient(db, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = sproc;
                using (WstDataReader reader = client.Execute())
                {
                    while (reader.Read())
                    {
                        TKey key = (TKey)reader[keycol];
                        TValue val = (TValue)reader[valcol];
                        Add(key, val);
                    }
                }
            }
        }

        public DatabaseLookupTable(string db, string sproc, string keycol, string valcol) :
            this(db, sproc, keycol, valcol, EqualityComparer<TKey>.Default)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\DatabaseObjects.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * DatabaseObjects.cs
 *
 * Flat database objects to read from the database.  These will be combined into the more complex types
 * for the ISTSConfiguration and IIEBBusinessPartner interfaces that are more complex.
 *
 */

using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;
using System.Xml.Linq;


namespace xonline.config.sts.databaseconfig
{
    public class AppliesToDB
    {
        public string AppliesToUrl;
        public string AppliesToCert;
        public string TokenType;
        public TimeSpan ValidityInterval;
        public Guid BusinessPartnerID;
    }

    public class AppliesToClaimTypeDB
    {
        public string AppliesToUrl;
        public string ClaimUrl;
        public bool Required;

        public string ToXmlString()
        {
            return string.Format(
                "<item appliesToUrl='{0}' claimUrl='{1}' required='{2}' />",
                AppliesToUrl,
                ClaimUrl,
                Required ? "1" : "0");
        }
    }

    public class BusinessPartnerDB
    {
        public Guid BusinessPartnerID;
        public string FriendlyName;
        public string AnonymizingSalt;
        public int BusinessPartnerTypeId;

        public string ToXmlString()
        {
            return string.Format(
                "<item businessPartnerID='{0}' friendlyName='{1}' anonymizingSalt='{2}' businessPartnerType='{3}'/>",
                BusinessPartnerID.ToString(),
                FriendlyName,
                AnonymizingSalt,
                BusinessPartnerTypeId);
        }
    }

    public class BusinessPartnerConnectionInfoDB
    {
        public Guid BusinessPartnerID;
        public string FriendlyName;
        public string PartnerSgCert;

        public string ToXmlString()
        {
            return string.Format(
                "<item businessPartnerId='{0}' friendlyName='{1}' partnersgcert='{2}'/>",
                BusinessPartnerID.ToString(),
                FriendlyName,
                PartnerSgCert);
        }
    }

    public class BusinessPartnerKeyDB
    {
        public Guid BusinessPartnerID;
        public int KeyVersion;
        public int MasterKeyVersion;
        public byte[] SymmetricKey;
        public byte[] SymmetricIV;
    }

    public class BusinessPartnerTitleDB
    {
        public Guid BusinessPartnerID;
        public uint TitleID;

        public string ToXmlString()
        {
            return string.Format(
                "<item businessPartnerId='{0}' titleID='{1}' />",
                BusinessPartnerID,
                (int)TitleID);
        }
    }

    public class BusinessPartnerTypeClaimTypeDB
    {
        public int BusinessPartnerTypeId;
        public string BusinessPartnerType;
        public string ClaimUrl;
    }

    public class BusinessPartnerTypeDB
    {
        public int TypeId;
        public string FriendlyName;
        public bool RequiresCert;
    }

    public class ClaimTypeDB
    {
        public string ClaimUri;
        public string FriendlyTitle;
        public string FriendlyDescription;
        public bool Encrypted;
        public bool Anonymized;
        public string ValueType;
    }

    public class ClaimTypeProviderDB
    {
        public Guid ClaimProviderID;
        public string FriendlyName;
        public string AssemblyName;
    }

    public class ClaimTypeProviderClaimDB
    {
        public Guid ClaimProviderID;
        public string ClaimUri;

        public string ToXmlString()
        {
            return string.Format(
                "<item claimproviderid='{0}' claimuri='{1}' />",
                ClaimProviderID.ToString(),
                ClaimUri);
        }
    }

    public class TitleEndpointHistory
    {
        public TitleEndpointHistory()
        {
            EndpointInfo = new TitleEndpointDB();
        }

        public TitleEndpointDB EndpointInfo;
        public DateTime Start;
        public DateTime End;
    }

    public class TitleEndpointDB
    {
        public uint TitleID;
        public string Protocol;
        public int Port;
        public string Hostname;
        public uint FromIP;
        public uint ToIP;
        public string Path;
        public string AppliesToUrl;

        public string ToXmlString()
        {
            return new XElement("item",
                       new XAttribute("titleID", unchecked((int)TitleID)),
                       new XAttribute("protocol", Protocol),
                       new XAttribute("port", Port),
                       new XAttribute("hostname", Hostname),
                       new XAttribute("fromip", unchecked((int)FromIP)),
                       new XAttribute("toip", unchecked((int)ToIP)),
                       new XAttribute("path", Path),
                       AppliesToUrl != null ? new XAttribute("appliesToUrl", AppliesToUrl) : null).ToString();
        }
    }

    public class TokenTypeDB
    {
        public string TokenTypeUri;
        public string Description;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\DatabaseWriter.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * DatabaseWriter.cs
 *
 * Database layer to write information about STS configuration
 *
 */

using System;
using System.Collections.Generic;
using System.Data.SqlClient;


using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class DatabaseWriter
    {
        public static void SetAppliesTo(AppliesTo at)
        {
            AppliesToDB atdb = at.ToDbObject();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_applies_to_set";

                client.AddParameter("vc_applies_to_uri", atdb.AppliesToUrl);
                client.AddParameter("vc_applies_to_cert", atdb.AppliesToCert);
                client.AddParameter("vc_token_type_uri", atdb.TokenType);

                client.Parameters.AddWithValue("t_validity_interval", atdb.ValidityInterval);
                client.Parameters.AddWithValue("uid_business_partner_id", atdb.BusinessPartnerID);
                client.AddParameter("i_validity_minutes", (int) atdb.ValidityInterval.TotalMinutes);

                client.ExecuteNonQuery();
            }
        }

        public static void RemoveAppliesTo(string appliesToUri)
        {
            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_applies_to_remove";
                client.AddParameter("vc_applies_to_uri", appliesToUri);
                client.ExecuteNonQuery();
            }
        }

        public static void SetAppliesToClaimTypes(AppliesTo at)
        {
            string xmlString = string.Empty;

            foreach(IAppliesToClaimType iact in at.ClaimTypes.Values)
            {
                AppliesToClaimType act = iact as AppliesToClaimType;
                AppliesToClaimTypeDB actdb = act.ToDbObject();
                xmlString += actdb.ToXmlString();
            }

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_applies_to_claim_set";
                client.AddParameter("xmlList", xmlString);
                client.AddParameter("vc_applies_to_uri", at.AppliesToUri.ToString());
                client.ExecuteNonQuery();
            }
        }

        public static void SetBusinessPartner(IEBBusinessPartner bp)
        {
            BusinessPartnerDB bpdb = bp.ToDbObject();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_set";

                client.AddParameter("uid_business_partner_id", bpdb.BusinessPartnerID);
                client.AddParameter("vc_friendly_name", bpdb.FriendlyName);
                client.AddParameter("vc_anonymizing_salt", bpdb.AnonymizingSalt);
                client.AddParameter("i_business_partner_type", bpdb.BusinessPartnerTypeId);

                client.ExecuteNonQuery();
            }
        }

        public static void SetBusinessPartnerConnectionInfos(IEBBusinessPartner bp)
        {
            string xmlString = string.Empty;

            foreach(IIEBPartnerConnectionInfo connInfo in bp.IEBPartnerConnectionInfoes)
            {
                IEBPartnerConnectionInfo conn = connInfo as IEBPartnerConnectionInfo;
                BusinessPartnerConnectionInfoDB connDB = conn.ToDbObject();
                xmlString += connDB.ToXmlString();
            }

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_connection_info_set";
                client.AddParameter("xmlList", xmlString);
                client.AddParameter("uid_business_partner_id", bp.Id);
                client.ExecuteNonQuery();
            }
        }

        public static void SetBusinessPartnerTitles(IEBBusinessPartner bp)
        {
            string xmlString = string.Empty;

            foreach(ITitle title in bp.Titles.Values)
            {
                Title t = title as Title;
                BusinessPartnerTitleDB titleDB = t.ToDbObject();
                xmlString += titleDB.ToXmlString();
            }

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_title_set";
                client.AddParameter("xmlList", xmlString);
                client.AddParameter("uid_business_partner_id", bp.Id);
                client.ExecuteNonQuery();
            }
        }

        public static void SetBusinessPartnerKeys(IEBBusinessPartner bp)
        {
            string xmlString = string.Empty;

            foreach(IIEBBusinessPartnerKey key in bp.Keys)
            {
                IEBBusinessPartnerKey k = key as IEBBusinessPartnerKey;
                BusinessPartnerKeyDB keyDB = k.ToDbObject();

                using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    client.StoredProc = "p_sts_business_partner_keys_set";
                    client.AddParameter("uid_business_partner_id", keyDB.BusinessPartnerID);
                    client.AddParameter("i_key_version", keyDB.KeyVersion);
                    client.AddParameter("i_master_key_version", keyDB.MasterKeyVersion);
                    client.AddParameter("vb_encrypted_key", keyDB.SymmetricKey);
                    client.AddParameter("vb_encrypted_iv", keyDB.SymmetricIV);
                    client.ExecuteNonQuery();
                }
            }
        }

        public static void SetTitleEndpoints(Title title)
        {
            string xmlString = string.Empty;

            foreach(IEndpoint endpoint in title.Endpoints)
            {
                Endpoint e = endpoint as Endpoint;
                TitleEndpointDB endpointDB = e.ToDbObject();
                xmlString += endpointDB.ToXmlString();
            }

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_title_endpoint_set";
                client.AddParameter("xmlList", xmlString);
                client.AddParameter("i_title_id", title.TitleID);
                client.ExecuteNonQuery();
            }
        }

        public static void SetClaimType(ClaimType claim)
        {
            ClaimTypeDB ctdb = claim.ToDbObject();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_set";

                client.AddParameter("vc_claim_uri", ctdb.ClaimUri);
                client.AddParameter("vc_friendly_title", ctdb.FriendlyTitle);
                client.AddParameter("vc_friendly_description", ctdb.FriendlyDescription);
                client.AddParameter("b_encrypted", IntOption(ctdb.Encrypted));
                client.AddParameter("vc_value_type", ctdb.ValueType);

                client.ExecuteNonQuery();
            }
        }

        public static void RemoveClaimType(string claimTypeUri)
        {
            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_remove";
                client.AddParameter("vc_claim_uri", claimTypeUri);
                client.ExecuteNonQuery();
            }
        }

        public static void SetClaimTypeProvider(ClaimTypeProvider provider)
        {
            ClaimTypeProviderDB ctpdb = provider.ToDbObject();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_provider_set";

                client.AddParameter("uid_claim_provider_id", ctpdb.ClaimProviderID);
                client.AddParameter("vc_friendly_name", ctpdb.FriendlyName);
                client.AddParameter("vc_assembly", ctpdb.AssemblyName);

                client.ExecuteNonQuery();
            }
        }

        public static void RemoveClaimTypeProvider(Guid providerId)
        {
            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_provider_remove";
                client.AddParameter("uid_claim_provider_id", providerId);
                client.ExecuteNonQuery();
            }
        }

        public static void SetClaimTypeProviderClaims(ClaimTypeProvider provider)
        {
            string xmlString = string.Empty;

            foreach(IClaimType c in provider.ClaimTypes.Values)
            {
                ClaimType ct = c as ClaimType;
                ClaimTypeProviderClaimDB ctp = new ClaimTypeProviderClaimDB();

                ctp.ClaimProviderID = provider.Id;
                ctp.ClaimUri = ct.ClaimTypeUri.ToString();

                xmlString += ctp.ToXmlString();
            }

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_provider_claim_type_set";
                client.AddParameter("xmlList", xmlString);
                client.AddParameter("uid_claim_provider_id", provider.Id);
                client.ExecuteNonQuery();
            }
        }

        public static void SetTokenType(TokenType tokentype)
        {
            TokenTypeDB ttdb = tokentype.ToDbObject();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_token_type_set";

                client.AddParameter("vc_token_type_uri", ttdb.TokenTypeUri);
                client.AddParameter("vc_token_type_description", ttdb.Description);

                client.ExecuteNonQuery();
            }
        }

        public static void RemoveTokenType(string tokenTypeUri)
        {
            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_token_type_remove";
                client.AddParameter("vc_token_type_uri", tokenTypeUri);
                client.ExecuteNonQuery();
            }
        }

        private static int IntOption(bool bVal)
        {
            if(bVal)
                return 1;
            else
                return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\DatabaseObjectFactory.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * ReliantPartyDatabase.cs
 *
 * Database layer for reliant party information and datastructures
 *
 */

using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class DatabaseObjectFactory
    {
        public IDictionary<Guid, IEBBusinessPartner> CreatedBusinessPartners = new Dictionary<Guid, IEBBusinessPartner>();
        public IDictionary<string, AppliesToDB> AppliesTo = new Dictionary<string, AppliesToDB>();
        public IDictionary<string, List<AppliesToClaimTypeDB>> AppliesToClaims = new Dictionary<string, List<AppliesToClaimTypeDB>>();
        public IDictionary<Guid, BusinessPartnerDB> BusinessPartners = new Dictionary<Guid, BusinessPartnerDB>();
        public IDictionary<Guid, List<BusinessPartnerConnectionInfoDB>> BusinessPartnerConnectionInfos = new Dictionary<Guid, List<BusinessPartnerConnectionInfoDB>>();
        public IDictionary<Guid, List<BusinessPartnerKeyDB>> BusinessPartnerKeys = new Dictionary<Guid, List<BusinessPartnerKeyDB>>();
        public IDictionary<Guid, List<BusinessPartnerTitleDB>> BusinessPartnerTitles = new Dictionary<Guid, List<BusinessPartnerTitleDB>>();
        public IDictionary<string, ClaimTypeDB> Claims = new Dictionary<string, ClaimTypeDB>();
        public IDictionary<Guid, ClaimTypeProviderDB> ClaimProviders = new Dictionary<Guid, ClaimTypeProviderDB>();
        public IDictionary<Guid, List<ClaimTypeProviderClaimDB>> ClaimProviderClaims = new Dictionary<Guid, List<ClaimTypeProviderClaimDB>>();
        public IDictionary<uint, List<TitleEndpointDB>> TitleEndpoints = new Dictionary<uint, List<TitleEndpointDB>>();
        public IDictionary<string, TokenTypeDB> TokenTypes = new Dictionary<string, TokenTypeDB>();
        public List<BusinessPartnerTypeClaimTypeDB> BusinessPartnerTypeClaimTypes = new List<BusinessPartnerTypeClaimTypeDB>();
        static public List<BusinessPartnerTypeDB> BusinessPartnerTypes = new List<BusinessPartnerTypeDB>();

        public void Load()
        {
            CreatedBusinessPartners.Clear();

            Claims.Clear();

            foreach(ClaimTypeDB c in GetAllClaimTypes())
            {
                Claims.Add(c.ClaimUri, c);
            }

            AppliesTo.Clear();

            foreach(AppliesToDB a in GetAllAppliesTo())
            {
                AppliesTo.Add(a.AppliesToUrl, a);
            }

            AppliesToClaims.Clear();

            foreach(AppliesToClaimTypeDB a in GetAllAppliesToClaimTypes())
            {
                if(AppliesToClaims.Keys.Contains(a.AppliesToUrl))
                {
                    ((List<AppliesToClaimTypeDB>)AppliesToClaims[a.AppliesToUrl]).Add(a);
                }
                else
                {
                    List<AppliesToClaimTypeDB> newList = new List<AppliesToClaimTypeDB>();
                    newList.Add(a);

                    AppliesToClaims.Add(a.AppliesToUrl, newList);
                }
            }

            // MUST be done before BusinessPartners
            BusinessPartnerTypes.Clear();

            foreach (BusinessPartnerTypeDB bpt in GetAllBusinessPartnerTypes())
            {
                BusinessPartnerTypes.Add(bpt);
            }

            BusinessPartners.Clear();

            foreach(BusinessPartnerDB b in GetAllBusinessPartners())
            {
                BusinessPartners.Add(b.BusinessPartnerID, b);
            }

            BusinessPartnerConnectionInfos.Clear();

            foreach(BusinessPartnerConnectionInfoDB bpci in GetAllBusinessPartnerConnectionInfos())
            {
                if(!BusinessPartnerConnectionInfos.Keys.Contains(bpci.BusinessPartnerID))
                {
                    List<BusinessPartnerConnectionInfoDB> newConnInfoList = new List<BusinessPartnerConnectionInfoDB>();
                    BusinessPartnerConnectionInfos.Add(bpci.BusinessPartnerID, newConnInfoList);
                }

                ((List<BusinessPartnerConnectionInfoDB>)BusinessPartnerConnectionInfos[bpci.BusinessPartnerID]).Add(bpci);
            }

            BusinessPartnerKeys.Clear();

            foreach (BusinessPartnerKeyDB bpk in GetAllBusinessPartnerKeys())
            {
                if (!BusinessPartnerKeys.Keys.Contains(bpk.BusinessPartnerID))
                {
                    List<BusinessPartnerKeyDB> newKeyList = new List<BusinessPartnerKeyDB>();
                    BusinessPartnerKeys.Add(bpk.BusinessPartnerID, newKeyList);
                }

                ((List<BusinessPartnerKeyDB>)BusinessPartnerKeys[bpk.BusinessPartnerID]).Add(bpk);
            }

            BusinessPartnerTitles.Clear();

            foreach(BusinessPartnerTitleDB bpt in GetAllBusinessPartnerTitles())
            {
                if(!BusinessPartnerTitles.Keys.Contains(bpt.BusinessPartnerID))
                {
                    BusinessPartnerTitles.Add(bpt.BusinessPartnerID, new List<BusinessPartnerTitleDB>());
                }

                ((List<BusinessPartnerTitleDB>)BusinessPartnerTitles[bpt.BusinessPartnerID]).Add(bpt);
            }

            BusinessPartnerTypeClaimTypes.Clear();

            foreach (BusinessPartnerTypeClaimTypeDB bptct in GetAllBusinessPartnerTypeClaimTypes())
            {
                BusinessPartnerTypeClaimTypes.Add(bptct);
            }

            TitleEndpoints.Clear();

            foreach(TitleEndpointDB te in GetAllTitleEndpoints())
            {
                if(!TitleEndpoints.Keys.Contains(te.TitleID))
                {
                    TitleEndpoints.Add(te.TitleID, new List<TitleEndpointDB>());
                }

                ((List<TitleEndpointDB>)TitleEndpoints[te.TitleID]).Add(te);
            }

            TokenTypes.Clear();
            foreach(TokenTypeDB tt in GetAllTokenTypes())
            {
                TokenTypes[tt.TokenTypeUri] = tt;
            }

            ClaimProviders.Clear();
            foreach(ClaimTypeProviderDB cp in GetAllClaimTypeProviders())
            {
                ClaimProviders.Add(cp.ClaimProviderID, cp);
            }

            ClaimProviderClaims.Clear();
            foreach(ClaimTypeProviderClaimDB cpt in GetAllClaimTypeProviderClaims())
            {
                if(!ClaimProviderClaims.Keys.Contains(cpt.ClaimProviderID))
                {
                    ClaimProviderClaims.Add(cpt.ClaimProviderID, new List<ClaimTypeProviderClaimDB>());
                }

                ((List<ClaimTypeProviderClaimDB>)ClaimProviderClaims[cpt.ClaimProviderID]).Add(cpt);
            }
        }

        private static List<AppliesToDB> GetAllAppliesTo()
        {
            List<AppliesToDB> allAppliesTo = new List<AppliesToDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_applies_to_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        AppliesToDB appliesTo = new AppliesToDB();
                        appliesTo.AppliesToUrl = (string)reader["vc_applies_to_uri"];
                        appliesTo.AppliesToCert = (string)reader["vc_applies_to_cert"];
                        appliesTo.ValidityInterval = TimeSpan.FromMinutes(WSClient.GetInt32(reader, "i_validity_minutes"));
                        appliesTo.BusinessPartnerID = (Guid)reader["uid_business_partner_id"];
                        appliesTo.TokenType = (string)reader["vc_token_type_uri"];
                        allAppliesTo.Add(appliesTo);
                    }
                }
            }

            return allAppliesTo;
        }

        private static List<AppliesToClaimTypeDB> GetAllAppliesToClaimTypes()
        {
            List<AppliesToClaimTypeDB> allAppliesToClaim = new List<AppliesToClaimTypeDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_applies_to_claim_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        AppliesToClaimTypeDB appliesToClaim = new AppliesToClaimTypeDB();
                        appliesToClaim.AppliesToUrl = (string)reader["vc_applies_to_uri"];
                        appliesToClaim.ClaimUrl = (string)reader["vc_claim_uri"];
                        appliesToClaim.Required = IsOptionSet(reader, "b_required");

                        allAppliesToClaim.Add(appliesToClaim);
                    }
                }
            }

            return allAppliesToClaim;
        }

        private static List<BusinessPartnerDB> GetAllBusinessPartners()
        {
            List<BusinessPartnerDB> businessPartners = new List<BusinessPartnerDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        BusinessPartnerDB bp = new BusinessPartnerDB();
                        bp.BusinessPartnerID = (Guid)reader["uid_business_partner_id"];
                        bp.FriendlyName = (string)reader["vc_friendly_name"];
                        bp.AnonymizingSalt = (string)reader["vc_anonymizing_salt"];
                        bp.BusinessPartnerTypeId = (int)reader["i_business_partner_type"];

                        businessPartners.Add(bp);
                    }
                }
            }

            return businessPartners;
        }

        private static List<BusinessPartnerConnectionInfoDB> GetAllBusinessPartnerConnectionInfos()
        {
            List<BusinessPartnerConnectionInfoDB> connInfos = new List<BusinessPartnerConnectionInfoDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_connection_info_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        BusinessPartnerConnectionInfoDB ci = new BusinessPartnerConnectionInfoDB();
                        ci.BusinessPartnerID = (Guid)reader["uid_business_partner_id"];
                        ci.PartnerSgCert = (string)reader["vc_partner_sg_cert"];

                        connInfos.Add(ci);
                    }
                }
            }

            return connInfos;
        }

        private static List<BusinessPartnerKeyDB> GetAllBusinessPartnerKeys()
        {
            List<BusinessPartnerKeyDB> keys = new List<BusinessPartnerKeyDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_keys_get";

                using (WstDataReader reader = client.Execute())
                {
                    while (reader.Read())
                    {
                        BusinessPartnerKeyDB k = new BusinessPartnerKeyDB();
                        k.BusinessPartnerID = (Guid)reader["uid_business_partner_id"];
                        k.KeyVersion = (int)reader["i_key_version"];
                        k.MasterKeyVersion = (int)reader["i_master_key_version"];

                        // SymmetricKey
                        byte[] symmetricKey = (byte[])reader["vb_encrypted_key"];
                        /*
                        if (0 != k.MasterKeyVersion)
                        {   // Decrypt
                            k.SymmetricKey = MasterKey.Decrypt(k.MasterKeyVersion, symmetricKey);
                        }
                        else
                        {   // Make sure not the default 0
                            UInt32 keyCheck = BitConverter.ToUInt32(symmetricKey, 0);
                            if (4 != symmetricKey.Length || 0 != keyCheck)
                            {
                                k.SymmetricKey = symmetricKey;
                            }
                        }*/
                        k.SymmetricKey = symmetricKey;

                        // SymmetricIV
                        byte[] symmetricIV = (byte[])reader["vb_encrypted_iv"];
                        /*
                        if (0 != k.MasterKeyVersion)
                        {   // Decrypt
                            k.SymmetricIV = MasterKey.Decrypt(k.MasterKeyVersion, symmetricIV);
                        }
                        else
                        {
                            if (null != k.SymmetricKey)
                            {
                                k.SymmetricIV = symmetricIV;
                            }
                        }*/
                        k.SymmetricIV = symmetricIV;

                        keys.Add(k);
                    }
                }
            }

            return keys;
        }

        private static List<BusinessPartnerTitleDB> GetAllBusinessPartnerTitles()
        {
            List<BusinessPartnerTitleDB> titles = new List<BusinessPartnerTitleDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_title_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        BusinessPartnerTitleDB bpt = new BusinessPartnerTitleDB();
                        bpt.BusinessPartnerID = (Guid)reader["uid_business_partner_id"];
                        bpt.TitleID = (uint)(int)reader["i_title_id"];

                        titles.Add(bpt);
                    }
                }
            }

            return titles;
        }

        private static List<BusinessPartnerTypeClaimTypeDB> GetAllBusinessPartnerTypeClaimTypes()
        {
            List<BusinessPartnerTypeClaimTypeDB> businessPartnerTypeClaimTypes = new List<BusinessPartnerTypeClaimTypeDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_type_claim_type_get";

                using (WstDataReader reader = client.Execute())
                {
                    while (reader.Read())
                    {
                        BusinessPartnerTypeClaimTypeDB bptct = new BusinessPartnerTypeClaimTypeDB();
                        bptct.BusinessPartnerTypeId = (int)reader["i_business_partner_type"];
                        bptct.BusinessPartnerType = (string)reader["vc_friendly_name"];
                        bptct.ClaimUrl = (string)reader["vc_claim_uri"];

                        businessPartnerTypeClaimTypes.Add(bptct);
                    }
                }
            }

            return businessPartnerTypeClaimTypes;
        }

        private static List<BusinessPartnerTypeDB> GetAllBusinessPartnerTypes()
        {
            List<BusinessPartnerTypeDB> businessPartnerTypes = new List<BusinessPartnerTypeDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_business_partner_type_get";

                using (WstDataReader reader = client.Execute())
                {
                    while (reader.Read())
                    {
                        BusinessPartnerTypeDB bpt = new BusinessPartnerTypeDB();
                        bpt.TypeId = (int)reader["i_business_partner_type"];
                        bpt.FriendlyName = (string)reader["vc_friendly_name"];
                        bpt.RequiresCert = IsOptionSet(reader, "b_requirescert");

                        businessPartnerTypes.Add(bpt);
                    }
                }
            }

            return businessPartnerTypes;
        }

        private static List<ClaimTypeDB> GetAllClaimTypes()
        {
            List<ClaimTypeDB> claims = new List<ClaimTypeDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        ClaimTypeDB claim = new ClaimTypeDB();
                        claim.ClaimUri = (string)reader["vc_claim_uri"];
                        claim.FriendlyTitle = (string)reader["vc_friendly_title"];
                        claim.FriendlyDescription = (string)reader["vc_friendly_description"];
                        claim.Encrypted = IsOptionSet(reader, "b_encrypted");
                        claim.Anonymized = IsOptionSet(reader, "b_anonymized");
                        claim.ValueType = (string)reader["vc_value_type"];

                        claims.Add(claim);
                    }
                }
            }

            return claims;
        }

        private static List<ClaimTypeProviderDB> GetAllClaimTypeProviders()
        {
            List<ClaimTypeProviderDB> claimProviders = new List<ClaimTypeProviderDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_provider_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        ClaimTypeProviderDB claimProvider = new ClaimTypeProviderDB();
                        claimProvider.ClaimProviderID = (Guid)reader["uid_claim_provider_id"];
                        claimProvider.FriendlyName = (string)reader["vc_friendly_name"];
                        claimProvider.AssemblyName = (string)reader["vc_assembly"];

                        claimProviders.Add(claimProvider);
                    }
                }
            }

            return claimProviders;
        }

        private static List<ClaimTypeProviderClaimDB> GetAllClaimTypeProviderClaims()
        {
            List<ClaimTypeProviderClaimDB> claimProvidersTypes = new List<ClaimTypeProviderClaimDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_claim_provider_claim_type_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        ClaimTypeProviderClaimDB claimProviderType = new ClaimTypeProviderClaimDB();
                        claimProviderType.ClaimProviderID = (Guid)reader["uid_claim_provider_id"];
                        claimProviderType.ClaimUri = (string)reader["vc_claim_uri"];

                        claimProvidersTypes.Add(claimProviderType);
                    }
                }
            }

            return claimProvidersTypes;
        }

        private static List<TitleEndpointDB> GetAllTitleEndpoints()
        {
            List<TitleEndpointDB> titleEndpoints = new List<TitleEndpointDB>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_title_endpoint_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        TitleEndpointDB titleEndpoint = new TitleEndpointDB();
                        titleEndpoint.TitleID = (uint)(int)reader["i_title_id"];
                        titleEndpoint.Protocol = (string)reader["vc_protocol"];
                        titleEndpoint.Port = (int)reader["i_port"];
                        titleEndpoint.Hostname = (string)reader["vc_hostname"];
                        titleEndpoint.FromIP = (uint)(int)reader["i_from_ip"];
                        titleEndpoint.ToIP = (uint)(int)reader["i_to_ip"];
                        titleEndpoint.Path = (string)reader["vc_path"];
                        titleEndpoint.AppliesToUrl = (string)WSClient.GetNullableString(reader, "vc_applies_to_uri");
                        titleEndpoints.Add(titleEndpoint);
                    }
                }
            }

            return titleEndpoints;
        }

        public static List<TitleEndpointHistory> GetTitleEndpointHistoryByTitleID(uint titleID, bool bFull)
        {
            List<TitleEndpointHistory> titleEndpoints = new List<TitleEndpointHistory>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_title_endpoint_get_by_title";
                client.AddParameter("i_title_id", titleID);
                client.AddParameter("i_full_history", bFull ? 1 : 0);

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        TitleEndpointHistory titleEndpoint = new TitleEndpointHistory();
                        titleEndpoint.EndpointInfo.TitleID = (uint)(int)reader["i_title_id"];
                        titleEndpoint.EndpointInfo.Protocol = (string)reader["vc_protocol"];
                        titleEndpoint.EndpointInfo.Port = (int)reader["i_port"];
                        titleEndpoint.EndpointInfo.Hostname = (string)reader["vc_hostname"];
                        titleEndpoint.EndpointInfo.FromIP = (uint)(int)reader["i_from_ip"];
                        titleEndpoint.EndpointInfo.ToIP = (uint)(int)reader["i_to_ip"];
                        titleEndpoint.EndpointInfo.Path = (string)reader["vc_path"];
                        titleEndpoint.EndpointInfo.AppliesToUrl = (string)WSClient.GetNullableString(reader, "vc_applies_to_uri");
                        titleEndpoint.Start = (DateTime)reader["dt_start"];
                        titleEndpoint.End = (DateTime)reader["dt_end"];

                        titleEndpoints.Add(titleEndpoint);
                    }
                }
            }

            return titleEndpoints;
        }

        public static List<TitleEndpointHistory> GetTitleEndpointHistoryByAppliesTo(string appliesTo, bool bFull)
        {
            List<TitleEndpointHistory> titleEndpoints = new List<TitleEndpointHistory>();

            using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_title_endpoint_get_by_title_id";
                client.AddParameter("vc_applies_to", appliesTo);
                client.AddParameter("i_full_history", bFull ? 1 : 0);

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        TitleEndpointHistory titleEndpoint = new TitleEndpointHistory();
                        titleEndpoint.EndpointInfo.TitleID = (uint)(int)reader["i_title_id"];
                        titleEndpoint.EndpointInfo.Protocol = (string)reader["vc_protocol"];
                        titleEndpoint.EndpointInfo.Port = (int)reader["i_port"];
                        titleEndpoint.EndpointInfo.Hostname = (string)reader["vc_hostname"];
                        titleEndpoint.EndpointInfo.FromIP = (uint)(int)reader["i_from_ip"];
                        titleEndpoint.EndpointInfo.ToIP = (uint)(int)reader["i_to_ip"];
                        titleEndpoint.EndpointInfo.Path = (string)reader["vc_path"];
                        titleEndpoint.EndpointInfo.AppliesToUrl = (string)WSClient.GetNullableString(reader, "vc_applies_to_uri");
                        titleEndpoint.Start = (DateTime)reader["dt_start"];
                        titleEndpoint.End = (DateTime)reader["dt_end"];

                        titleEndpoints.Add(titleEndpoint);
                    }
                }
            }

            return titleEndpoints;
        }
        private static List<TokenTypeDB> GetAllTokenTypes()
        {
            List<TokenTypeDB> tokenTypes = new List<TokenTypeDB>();

            using(WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                client.StoredProc = "p_sts_token_type_get";

                using(WstDataReader reader = client.Execute())
                {
                    while(reader.Read())
                    {
                        TokenTypeDB tokenType = new TokenTypeDB();
                        tokenType.TokenTypeUri = (string)reader["vc_token_type_uri"];
                        tokenType.Description = (string)reader["vc_token_type_description"];
                        tokenTypes.Add(tokenType);
                    }
                }
            }

            return tokenTypes;
        }
        
        private static bool IsOptionSet(WstDataReader reader, string colName)
        {
            return ((bool)reader[colName]);
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\Endpoint.cs ===
﻿using System;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class Endpoint : IEndpoint
    {
        public Endpoint(Title title)
        {
            Title = title;
        }

        public static Endpoint FromDbObject(DatabaseObjectFactory objFac, TitleEndpointDB endpointdb, Title title)
        {
            Endpoint e = new Endpoint(title);
            e.Protocol = endpointdb.Protocol;
            e.ProtocolID = (ushort)ProtocolLookupTable.GetInstance()[endpointdb.Protocol];
            e.Hostname = endpointdb.Hostname;
            e.FromIP = endpointdb.FromIP;
            e.ToIP = endpointdb.ToIP;
            e.Port = endpointdb.Port;
            e.Path = endpointdb.Path;
            if (!String.IsNullOrEmpty(endpointdb.AppliesToUrl))
            {
                e.AppliesTo = xonline.config.sts.databaseconfig.AppliesTo.FromDbObject(objFac, objFac.AppliesTo[endpointdb.AppliesToUrl]);
            }
            return e;
        }

        public TitleEndpointDB ToDbObject()
        {
            TitleEndpointDB e = new TitleEndpointDB();

            e.TitleID = Title.TitleID;
            e.Protocol = Protocol;
            e.Port = Port;
            e.Hostname = Hostname;
            e.FromIP = FromIP;
            e.ToIP = ToIP;
            e.Path = Path;
            e.AppliesToUrl = AppliesTo != null ? AppliesTo.AppliesToUri.ToString() : null;

            return e;
        }

        public string Protocol { get; set; }
        public ushort ProtocolID { get; set; }
        public string Hostname { get; set; }
        public uint FromIP { get; set; }
        public uint ToIP { get; set; }
        public int Port { get; set; }
        public string Path { get; set; }
        public IAppliesTo AppliesTo { get; set; }
        public ITitle Title { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\IEBBusinessPartner.cs ===
﻿using System;
using System.Collections.Generic;
using xonline.config.sts.interfaces;

using xonline.config.sts.databaseconfig;

namespace xonline.config.sts.databaseconfig
{
    public class IEBBusinessPartner : IIEBBusinessPartner
    {
        public IEBBusinessPartner()
        {
            Titles = new Dictionary<uint, ITitle>();
            IEBPartnerConnectionInfoes = new List<IIEBPartnerConnectionInfo>();
            Keys = new List<IIEBBusinessPartnerKey>();
            Claims = new List<Uri>();

        }

        public static IEBBusinessPartner FromDbObject(DatabaseObjectFactory objFac, BusinessPartnerDB bpdb)
        {
            IEBBusinessPartner p = new IEBBusinessPartner();

            p.Name = bpdb.FriendlyName;
            p.Id = bpdb.BusinessPartnerID;
            p.AnonymizingSalt = bpdb.AnonymizingSalt;
            p.SetType(bpdb.BusinessPartnerTypeId);

            // Add a reference back so that when we deserialize these parts below, that we
            // can work a circular reference on the business partner
            objFac.CreatedBusinessPartners.Add(p.Id, p);

            return p;
        }

        public void Deserialize(DatabaseObjectFactory objFac)
        {
            if(objFac.BusinessPartnerTitles.ContainsKey(Id))
            {
                foreach(BusinessPartnerTitleDB bptdb in objFac.BusinessPartnerTitles[Id])
                {
                    Title t = Title.FromDbObject(objFac, bptdb.TitleID, this);
                    Titles.Add(bptdb.TitleID, t);
                }
            }

            if(objFac.BusinessPartnerConnectionInfos.ContainsKey(Id))
            {
                foreach(BusinessPartnerConnectionInfoDB connInfo in objFac.BusinessPartnerConnectionInfos[Id])
                {
                    IEBPartnerConnectionInfo pci = IEBPartnerConnectionInfo.FromDbObject(objFac, connInfo, this);
                    IEBPartnerConnectionInfoes.Add(pci);
                }
            }

            if (objFac.BusinessPartnerKeys.ContainsKey(Id))
            {
                foreach (BusinessPartnerKeyDB key in objFac.BusinessPartnerKeys[Id])
                {
                    IEBBusinessPartnerKey pk = IEBBusinessPartnerKey.FromDbObject(objFac, key, this);
                    Keys.Add(pk);
                }
            }

            foreach (BusinessPartnerTypeClaimTypeDB bptct in objFac.BusinessPartnerTypeClaimTypes)
            {
                if (this.Type.Type == bptct.BusinessPartnerType)
                {
                    Claims.Add(new Uri(bptct.ClaimUrl));
                }
            }
        }

        public BusinessPartnerDB ToDbObject()
        {
            BusinessPartnerDB p = new BusinessPartnerDB();
            p.BusinessPartnerID = Id;
            p.FriendlyName = Name;
            p.AnonymizingSalt = AnonymizingSalt;
            p.BusinessPartnerTypeId = TypeId;

            // TODO: Anonmoys ID stuff?

            return p;
        }

        public bool SetType(string businessPartnerType)
        {
            foreach (BusinessPartnerTypeDB bpt in DatabaseObjectFactory.BusinessPartnerTypes)
            {
                if (businessPartnerType == bpt.FriendlyName)
                {
                    this.TypeId = bpt.TypeId;
                    this.Type = IEBBusinessPartnerType.FromDbObject(null, bpt);
                    return true;
                }
            }
            return false;
        }

        private bool SetType(int typeId)
        {
            foreach (BusinessPartnerTypeDB bpt in DatabaseObjectFactory.BusinessPartnerTypes)
            {
                if (typeId == bpt.TypeId)
                {
                    this.TypeId = typeId;
                    this.Type = IEBBusinessPartnerType.FromDbObject(null, bpt);
                    return true;
                }
            }
            return false;
        }

        public Guid Id { get; set; }
        public string Name { get; set; }
        public string AnonymizingSalt { get; set; }
        protected int TypeId = 1;   // Default: Partner
        public IIEBBusinessPartnerType Type { get; protected set; }
        public IDictionary<uint, ITitle> Titles { get; set; }
        public IList<IIEBPartnerConnectionInfo> IEBPartnerConnectionInfoes { get; set; }
        public IList<IIEBBusinessPartnerKey> Keys { get; set; }
        public IList<Uri> Claims { get; set; }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\ProtocolLookupTable.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * STS Config
 *
 * ProtocolLookupTable.cs
 *
 * A simple class to wrap around looking up the protocol id from a string.
 *
 */

using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;


namespace xonline.config.sts.databaseconfig
{
    public class ProtocolLookupTable : DatabaseLookupTable<string, int>
    {
        private static ProtocolLookupTable _table = null;

        public static ProtocolLookupTable GetInstance()
        {
            if(_table == null)
            {
                _table = new ProtocolLookupTable();
            }

            return _table;
        }

        private ProtocolLookupTable() :
            base(ConfigUtil.SecDbWebstoreApp, "p_sts_title_endpoint_protocol_get", "vc_protocol", "i_protocol_id", StringComparer.OrdinalIgnoreCase)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\IEBBusinessPartnerType.cs ===
﻿using System;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class IEBBusinessPartnerType : IIEBBusinessPartnerType
    {
        public IEBBusinessPartnerType()
        {
        }

        public static IEBBusinessPartnerType FromDbObject(DatabaseObjectFactory factory, BusinessPartnerTypeDB bptDB)
        {
            IEBBusinessPartnerType bpt = new IEBBusinessPartnerType();
            bpt.Type = bptDB.FriendlyName;
            bpt.RequiresCert = bptDB.RequiresCert;

            return bpt;
        }

        public string Type { get; protected set; }
        public bool RequiresCert { get; protected set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\IEBBusinessPartnerKey.cs ===
﻿using System;
using System.Security.Cryptography.X509Certificates;
using xonline.config.sts.interfaces;
using xonline.common.service;

namespace xonline.config.sts.databaseconfig
{
    public class IEBBusinessPartnerKey : IIEBBusinessPartnerKey
    {
        public IEBBusinessPartnerKey(IEBBusinessPartner partner)
        {
            BusinessPartner = partner;
        }

        public static IEBBusinessPartnerKey FromDbObject(DatabaseObjectFactory objFac, BusinessPartnerKeyDB bpkdb, IEBBusinessPartner partner)
        {
            IEBBusinessPartnerKey k = new IEBBusinessPartnerKey(partner);

            k.KeyVersion = bpkdb.KeyVersion;
            k.MasterKeyVersion = bpkdb.MasterKeyVersion;

            MasterKey mk = new MasterKey(k.MasterKeyVersion);

            k.SymmetricKey = mk.Decrypt(bpkdb.SymmetricKey);
            k.SymmetricIV = mk.Decrypt(bpkdb.SymmetricIV);

            return k;
        }

        public BusinessPartnerKeyDB ToDbObject()
        {
            BusinessPartnerKeyDB bpk = new BusinessPartnerKeyDB();

            bpk.BusinessPartnerID = BusinessPartner.Id;
            bpk.KeyVersion = KeyVersion;
            bpk.MasterKeyVersion = MasterKeyVersion;

            MasterKey mk = new MasterKey(MasterKeyVersion);

            bpk.SymmetricKey = mk.Encrypt(SymmetricKey);
            bpk.SymmetricIV = mk.Encrypt(SymmetricIV);

            return bpk;
        }

        public IEBBusinessPartner BusinessPartner { get; set; }
        public int KeyVersion { get; set; }
        public int MasterKeyVersion { get; set; }
        public byte[] SymmetricKey { get; set; }
        public byte[] SymmetricIV { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\Title.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class Title : ITitle
    {
        public Title(uint titleID, IEBBusinessPartner partner)
        {
            TitleID = titleID;
            IEBBusinessPartner = partner;
            Endpoints = new List<IEndpoint>();
        }

        public static Title FromDbObject(DatabaseObjectFactory factory, uint titleID, IEBBusinessPartner partner)
        {
            Title t = new Title(titleID, partner);

            if(factory.TitleEndpoints.ContainsKey(titleID))
            {
                foreach(TitleEndpointDB titleendpoint in factory.TitleEndpoints[titleID])
                {
                    Endpoint e = Endpoint.FromDbObject(factory, titleendpoint, t);
                    t.Endpoints.Add(e);
                }
            }

            return t;
        }

        public BusinessPartnerTitleDB ToDbObject()
        {
            BusinessPartnerTitleDB bptdb = new BusinessPartnerTitleDB();

            bptdb.BusinessPartnerID = (IEBBusinessPartner as IEBBusinessPartner).Id;
            bptdb.TitleID = TitleID;

            return bptdb;
        }

        public uint TitleID { get; set; }
        public IList<IEndpoint> Endpoints { get; set; }
        public IIEBBusinessPartner IEBBusinessPartner { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\IEBBusinessPartnerTypeClaimType.cs ===
﻿using System;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class IEBBusinessPartnerTypeClaimType : IIEBBusinessPartnerTypeClaimType
    {
        public IEBBusinessPartnerTypeClaimType()
        {
        }

        public static IEBBusinessPartnerTypeClaimType FromDbObject(DatabaseObjectFactory factory, BusinessPartnerTypeClaimTypeDB bptctDB)
        {
            IEBBusinessPartnerTypeClaimType bptct = new IEBBusinessPartnerTypeClaimType();
            bptct.ClaimTypeUri = new Uri(bptctDB.ClaimUrl);
            bptct.BusinessPartnerType = bptctDB.BusinessPartnerType;

            return bptct;
        }

        public string BusinessPartnerType { get; set; }
        public Uri ClaimTypeUri { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\IEBPartnerConnectionInfo.cs ===
﻿using System;
using System.Security.Cryptography.X509Certificates;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class IEBPartnerConnectionInfo : IIEBPartnerConnectionInfo
    {
        public IEBPartnerConnectionInfo(IEBBusinessPartner partner)
        {
            BusinessPartner = partner;
        }

        public static IEBPartnerConnectionInfo FromDbObject(DatabaseObjectFactory objFac, BusinessPartnerConnectionInfoDB bpdcidb, IEBBusinessPartner partner)
        {
            IEBPartnerConnectionInfo ci = new IEBPartnerConnectionInfo(partner);

            byte[] rawCertificate = Convert.FromBase64String(bpdcidb.PartnerSgCert);
            ci.SecurityGatewayCertificate = new X509Certificate2(rawCertificate);

            ci.FriendlyName = bpdcidb.FriendlyName;

            return ci;
        }

        public BusinessPartnerConnectionInfoDB ToDbObject()
        {
            BusinessPartnerConnectionInfoDB bpci = new BusinessPartnerConnectionInfoDB();

            bpci.BusinessPartnerID = BusinessPartner.Id;
            bpci.PartnerSgCert = Convert.ToBase64String(SecurityGatewayCertificate.RawData);
            bpci.FriendlyName = FriendlyName;

            return bpci;
        }

        public string FriendlyName { get; set; }
        public IEBBusinessPartner BusinessPartner { get; set; }
        public X509Certificate2 SecurityGatewayCertificate { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\STSConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class STSConfiguration : ISTSConfiguration
    {
        private string _issuerName;
        private Uri _issuerUri;
        private X509Certificate2 _issuerCert;
        private Dictionary<Uri, IAppliesTo> _appliesToes = new Dictionary<Uri, IAppliesTo>();
        private List<IClaimTypeProvider> _claimTypeProviders = new List<IClaimTypeProvider>();
        private List<string> _businessPartnerTypes = new List<string>();
        private List<IIEBBusinessPartnerTypeClaimType> _businessPartnerTypeClaimTypes = new List<IIEBBusinessPartnerTypeClaimType>();
        private IDictionary<string, IClaimType> _claims = new Dictionary<string, IClaimType>();
        private IDictionary<string, ITokenType> _tokenTypes = new Dictionary<string, ITokenType>();

        public STSConfiguration(DatabaseObjectFactory factory)
        {
            // TODO: FIX
            _issuerUri = new Uri("http://blahhost.com");
            _issuerCert = null;
            _issuerName = null;

            // We have to pull the applies to from the partners, since we need the IEBBusinessPartner set
            // in the applies to.  So we're not really shortcuting anything here, we're using the other graph
            // which has more data to help construct this one.
            foreach(IEBBusinessPartner partner in factory.CreatedBusinessPartners.Values)
            {
                foreach(ITitle title in partner.Titles.Values)
                {
                    foreach(IEndpoint endpoint in title.Endpoints)
                    {
                        if(endpoint.AppliesTo != null && !_appliesToes.ContainsKey(endpoint.AppliesTo.AppliesToUri))
                        {
                            _appliesToes.Add(endpoint.AppliesTo.AppliesToUri, endpoint.AppliesTo);
                        }
                    }
                }
            }

            foreach(Guid claimProviderID in factory.ClaimProviders.Keys)
            {
                ClaimTypeProvider cp = ClaimTypeProvider.FromDbObject(factory, factory.ClaimProviders[claimProviderID]);
                _claimTypeProviders.Add(cp);

                foreach(IClaimType ct in cp.ClaimTypes.Values)
                {
                    _claims.Add(ct.ClaimTypeUri.ToString(), ct);
                }
            }

            foreach (KeyValuePair<string,AppliesToDB> kvAppliesTo in factory.AppliesTo)
            {
                AppliesTo to = AppliesTo.FromDbObject(factory, kvAppliesTo.Value);

                if(!_appliesToes.ContainsKey(to.AppliesToUri))
                {
                    _appliesToes.Add(to.AppliesToUri, to);
                }
            }

            foreach(KeyValuePair<string, TokenTypeDB> kvTokenTypes in factory.TokenTypes)
            {
                TokenType tt = TokenType.FromDbObject(factory, kvTokenTypes.Value);
                _tokenTypes.Add(kvTokenTypes.Key, tt);
            }

            foreach (BusinessPartnerTypeDB bpt in DatabaseObjectFactory.BusinessPartnerTypes)
            {
                _businessPartnerTypes.Add(bpt.FriendlyName);
            }

            foreach (BusinessPartnerTypeClaimTypeDB bptctdb in factory.BusinessPartnerTypeClaimTypes)
            {
                IEBBusinessPartnerTypeClaimType bptct = IEBBusinessPartnerTypeClaimType.FromDbObject(factory, bptctdb);
                _businessPartnerTypeClaimTypes.Add(bptct);
            }
        }

        public string IssuerName { get { return _issuerName; } }
        public Uri IssuerUri { get { return _issuerUri; } }
        public X509Certificate2 IssuerCertificate { get { return _issuerCert; } }
        public IDictionary<Uri, IAppliesTo> AppliesToes { get { return _appliesToes; } }
        public IList<IClaimTypeProvider> ClaimTypeProviders { get { return _claimTypeProviders; } }
        public IList<string> BusinessPartnerTypes { get { return _businessPartnerTypes; } }
        public IList<IIEBBusinessPartnerTypeClaimType> BusinessPartnerTypeCaimTypes { get { return _businessPartnerTypeClaimTypes; } }
        public IDictionary<string, IClaimType> ClaimTypes { get { return _claims; } }
        public IDictionary<string, ITokenType> TokenTypes { get { return _tokenTypes; } }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\TokenType.cs ===
﻿using System;
using xonline.config.sts.interfaces;

namespace xonline.config.sts.databaseconfig
{
    public class TokenType : ITokenType
    {
        public TokenType()
        {

        }

        public static TokenType FromDbObject(DatabaseObjectFactory factory, TokenTypeDB token)
        {
            TokenType t = new TokenType();
            t.Uri = new Uri(token.TokenTypeUri);
            t.Description = token.Description;

            return t;
        }

        public TokenTypeDB ToDbObject()
        {
            TokenTypeDB tt = new TokenTypeDB();

            tt.TokenTypeUri = Uri.ToString();
            tt.Description = Description;

            return tt;
        }

        public Uri Uri { get; set; }
        public string Description { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:25:31 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\DatabaseImpl\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.31.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:10:23 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IClaimType.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface IClaimType
    {
        Uri ClaimTypeUri
        {
            get;
        }

        bool Encrypted
        {
            get;
        }

        string Title
        {
            get;
        }

        string Description
        {
            get;
        }

        bool Anonymized
        {
            get;
        }

        string ValueType
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IClaimTypeProvider.cs ===
﻿using System.Collections.Generic;
using System;

namespace xonline.config.sts.interfaces
{
    public interface IClaimTypeProvider
    {
        string Type
        {
            get;
        }

        IDictionary<Uri, IClaimType> ClaimTypes
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IAppliesToClaimType.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface IAppliesToClaimType
    {
        Uri ClaimTypeUri
        {
            get;
        }

        bool Required
        {
            get;
        }

        IClaimType ClaimType
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IConfigurationProvider.cs ===
﻿using System.Collections.Generic;
namespace xonline.config.sts.interfaces
{
    public interface IConfigurationProvider
    {
        /// <summary>
        /// Initializes the provider with parameters needed, if any, for it to do its thing.
        /// </summary>
        /// <param name="parameters">N/V parameter names and values.</param>
        void Init(IDictionary<string, string> parameters);

        /// <summary>
        /// Causes the provider to load the requested config.
        /// </summary>
        void Load();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IAppliesTo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

namespace xonline.config.sts.interfaces
{
    public interface IAppliesTo
    {
        IIEBBusinessPartner BusinessPartner
        {
            get; // To traverse to the AnonId of the associated IIEBBusinessPartner
        }

        Uri AppliesToUri
        {
            get;
        }

        TimeSpan ValidityInterval
        {
            get;
        }

        X509Certificate2 AppliesToCertificate
        {
            get;
        }

        // the Key is the UriClaimType of the given AppliesToClaimType object
        IDictionary<Uri, IAppliesToClaimType> ClaimTypes
        {
            get;
        }

        ITokenType TokenType
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ConfigurationProviderBase.cs ===
﻿using System.Collections.Generic;
using System.Configuration;

namespace xonline.config.sts.interfaces
{
    public class ConfigurationProviderBase : ConfigurationSection, IConfigurationProvider
    {

        public virtual void Init(IDictionary<string, string> parameters)
        {
            // Override this method to do what you like.
        }

        public virtual void Load()
        {
            IDictionary<string, string> parameters = null;

            if ((this.Parameters != null) &&
                (this.Parameters.Count > 0))
            {
               parameters = new Dictionary<string, string>();

                foreach (ParameterConfigElement pce in this.Parameters)
                {
                    parameters.Add(pce.Name, pce.Value);
                }
            }

            this.Init(parameters);
        }

        [ConfigurationProperty("parameters", IsDefaultCollection = false, IsRequired = false)]
        [ConfigurationCollection(typeof(ParametersCollection),
            AddItemName = "addParameter",
            ClearItemsName = "clearParameters",
            RemoveItemName = "removeParameter")]
        public ParametersCollection Parameters
        {
            get
            {
                return base["parameters"] as ParametersCollection;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IEndpoint.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface IEndpoint
    {
        string Protocol
        {
            get;
        }

        ushort ProtocolID
        {
            get;
        }

        string Hostname
        {
            get;
        }

        uint FromIP
        {
            get;
        }

        uint ToIP
        {
            get;
        }

        string Path
        {
            get;
        }

        int Port
        {
            get;
        }

        IAppliesTo AppliesTo
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBBusinessPartner.cs ===
﻿using System;
using System.Collections.Generic;

namespace xonline.config.sts.interfaces
{
    public interface IIEBBusinessPartner
    {
        Guid Id
        {
            get;
        }

        string Name
        {
            get;
        }

        string AnonymizingSalt
        {
            get;
        }

        IDictionary<uint, ITitle> Titles
        {
            get;
        }

        IList<IIEBPartnerConnectionInfo> IEBPartnerConnectionInfoes
        {
            get;
        }

        IList<IIEBBusinessPartnerKey> Keys
        {
            get;
        }

        IIEBBusinessPartnerType Type
        {
            get;
        }

        IList<Uri> Claims
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBBusinessPartnerKey.cs ===
﻿namespace xonline.config.sts.interfaces
{
    public interface IIEBBusinessPartnerKey
    {
        int KeyVersion
        {
            get;
        }

        byte[] SymmetricKey
        {
            get;
        }

        byte[] SymmetricIV
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBBusinessPartnerConfigurationProvider.cs ===
﻿using System.Collections.Generic;

namespace xonline.config.sts.interfaces
{
    public interface IIEBBusinessPartnerConfigurationProvider : IConfigurationProvider
    {
        IDictionary<string, IIEBBusinessPartner> IEBBusinessPartners
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBPartnerConnectionInfo.cs ===
﻿using System.Security.Cryptography.X509Certificates;
namespace xonline.config.sts.interfaces
{
    public interface IIEBPartnerConnectionInfo
    {
        X509Certificate2 SecurityGatewayCertificate
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBBusinessPartnerTypeClaimType.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface IIEBBusinessPartnerTypeClaimType
    {
        string BusinessPartnerType
        {
            get;
        }

        Uri ClaimTypeUri
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\IIEBBusinessPartnerType.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface IIEBBusinessPartnerType
    {
        string Type
        {
            get;
        }

        bool RequiresCert
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ISTSConfigurationProvider.cs ===
﻿namespace xonline.config.sts.interfaces
{
    public interface ISTSConfigurationProvider : IConfigurationProvider
    {
        ISTSConfiguration STSConfiguration
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ISTSConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

namespace xonline.config.sts.interfaces
{
    public interface ISTSConfiguration
    {
        string IssuerName
        {
            get;
        }

        Uri IssuerUri
        {
            get;
        }

        X509Certificate2 IssuerCertificate
        {
            get;
        }

        // the Key is the Uri of the given AppliesTo object
        IDictionary<Uri, IAppliesTo> AppliesToes
        {
            get;
        }

        IList<IClaimTypeProvider> ClaimTypeProviders
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ITitle.cs ===
﻿using System;
using System.Collections.Generic;

namespace xonline.config.sts.interfaces
{
    public interface ITitle
    {
        uint TitleID
        {
            get;
        }

        IList<IEndpoint> Endpoints
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:25:31 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ITokenType.cs ===
﻿using System;

namespace xonline.config.sts.interfaces
{
    public interface ITokenType
    {
        Uri Uri
        {
            get;
        }

        string Description
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.31.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:10:22 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\BIF\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\BIF\makefile.inc ===
!include $(NTMAKEENV)\msbuild.def
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\BIF\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ParameterConfigElement.cs ===
﻿using System;
using System.Configuration;
namespace xonline.config.sts.interfaces
{
    public class ParameterConfigElement : ConfigurationElement
    {
        public ParameterConfigElement(String name, String value)
        {
            this.Name = name;
            this.Value = value;
        }

        public ParameterConfigElement()
        {
        }

        [ConfigurationProperty("name",
            IsRequired = true,
            IsKey = true)]
        public string Name
        {
            get
            {
                return (string)this["name"];
            }
            set
            {
                this["name"] = value;
            }
        }

        [ConfigurationProperty("value",
            IsRequired = true)]
        public string Value
        {
            get
            {
                return (string)this["value"];
            }
            set
            {
                this["value"] = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\STSConfig\Interfaces\ParametersCollection.cs ===
﻿using System;
using System.Configuration;
namespace xonline.config.sts.interfaces
{
    public class ParametersCollection : ConfigurationElementCollection
    {
        public ParametersCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new ParameterConfigElement();
        }

        protected override Object GetElementKey(ConfigurationElement element)
        {
            return ((ParameterConfigElement)element).Name;
        }

        public ParameterConfigElement this[int index]
        {
            get
            {
                return (ParameterConfigElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }
                BaseAdd(index, value);
            }
        }

        new public ParameterConfigElement this[string Name]
        {
            get
            {
                return (ParameterConfigElement)BaseGet(Name);
            }
        }

        public int IndexOf(ParameterConfigElement parameter)
        {
            return BaseIndexOf(parameter);
        }

        public void Add(ParameterConfigElement parameter)
        {
            BaseAdd(parameter);
        }
        protected override void BaseAdd(ConfigurationElement element)
        {
            BaseAdd(element, false);
        }

        public void Remove(ParameterConfigElement parameter)
        {
            if (BaseIndexOf(parameter) >= 0)
                BaseRemove(parameter.Name);
        }

        public void RemoveAt(int index)
        {
            BaseRemoveAt(index);
        }

        public void Remove(string name)
        {
            BaseRemove(name);
        }

        public void Clear()
        {
            BaseClear();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\BIF\BIF.cs ===
﻿using System;
using System.Collections;
using System.IO;
using System.Text;

using live.client;
using live.common;
using live.internaltest;
using live.protocol;
using live.server;

using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using SettingState = ServerTestFramework.LiveService.SettingState;
using stfu = ServerTestFramework.Utilities;
using XSigSignature = xonline.common.protocol.XSigSignature;

namespace BIF.Functional
{
    /// <HighLevel>
    /// The goal of this test plan is to define the test coverage for the components of the Behavior Injection Framework.  
    /// 
    /// <b>What is the Behavior Injection Framework (BIF)?</b>
    /// The BIF provides a way for tests to inject failure into certain components or features to simplify testing.  By allowing tests to simulate failure points that would otherwise be difficult to force, we can improve the code coverage and improve component reliability.
    /// 
    /// <b>How does the BIF work?</b>
    /// At the basic level, BIF works by adding one or more BehaviorInjection headers to any web request.  Based on the content of these headers, they can simulate a number of things ranging from NPDB Setting overrides, to database wide sproc failures.  On the server side, all behavior injection headers are automatically parsed and exposed to the component.  If a component wants to allow behavior injection, they simply check for the presence of any behavior injections of the type they're interested and execute them at the appropriate time.
    /// </HighLevel>
    /// 
    /// <Goals>
    ///     <UL>
    ///         <LI>Verify that each type of behavior injection performs as expected</LI>
    ///         <LI>Ensure that the behavior injections do not compromise the normal operation of the components</LI>
    ///     </UL>
    /// </Goals>
    /// <NonGoals>
    ///     <UL>
    ///         <LI>Test the functionality of any of the server components</LI>
    ///     </UL>
    /// </NonGoals>
    /// <Implementation>
    ///     .../private/common/core/service/BehaviorInjection.cs
    /// </Implementation>
    [TestGroup, Owner("BenRan"), Description("Test the Behavior Injection Framework")]
    public class BIF : LiveTestNode
    {
        /// <summary>
        ///     Using SprocFailure this test will simulate the either a single sproc failure or the failure of all sprocs on a given db with/without a delay.  A test matrix is used to cover a wide variety of cases.
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> SprocFailure
        ///         <b>Input:</b> Sproc: p_xuacs_get_user_account_info <i>or<i> DB: UODB
        ///         <b>Request:</b> GetUserInfoRequest
        ///         <table border="1">
        ///             <tr>
        ///                 <td><b>Test Name:</b></td>
        ///                 <td><b>Sproc:</b></td>
        ///                 <td><b>Database:</b></td>
        ///                 <td><b>Exception:</b></td>
        ///                 <td><b>Timeout (ms):</b></td>
        ///             </tr>
        ///             <tr>
        ///                 <td>SingleSprocException</td>
        ///                 <td>p_xuacs_get_user_account_info</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>System.Exception</td>
        ///                 <td>0</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>SingleSprocTimout</td>
        ///                 <td>p_xuacs_get_user_account_info</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>3000</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>SingleSprocExceptionTimout</td>
        ///                 <td>p_xuacs_get_user_account_info</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>System.Exception</td>
        ///                 <td>3000</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>SingleSprocOddCaseException</td>
        ///                 <td>p_XuACs_gET_USeR_aCcOuNt_inFO</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>System.Exception</td>
        ///                 <td>0</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>FullDBException</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>uodb</td>
        ///                 <td>System.Exception</td>
        ///                 <td>0</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>FullDBTimeout</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>uodb</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>3000</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>FullDBExceptionTimeout</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>uodb</td>
        ///                 <td>System.Exception</td>
        ///                 <td>3000</td>
        ///             </tr>
        ///             <tr>
        ///                 <td>FullDBOddCaseException</td>
        ///                 <td>&nbsp;</td>
        ///                 <td>uODb</td>
        ///                 <td>System.Exception</td>
        ///                 <td>0</td>
        ///             </tr>
        ///         </table>
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         Since GetUserInfo doesn't return an exception to us the test verifies that it failed by checking the users age. If the age is zero it means the call failed.
        ///     </verification>
        /// 
        ///     <dependencies>
        ///         <UL>
        ///             <LI>UACS [User Creation]</LI>
        ///         </UL>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("Sproc Failure Test Matrix"), TestFrequency("Regression"), TestCasePriority(2)]
        [SupportedClients(SupportedClient.Xbox360)]
        [CompoundCase("NoSprocFailureParams",        "p_xuacs_get_user_account_info", "",     "",                 0,    false, false),
         CompoundCase("IncorrectSprocNameException", "p_xuacs_invalid_sproc_name",    "",     "System.Exception", 0,    false, true), 
         CompoundCase("SingleSprocException",        "p_xuacs_get_user_account_info", "",     "System.Exception", 0,    false, false),
         CompoundCase("SingleSprocTimout",           "p_xuacs_get_user_account_info", "",     "",                 3000, false, true),
         CompoundCase("SingleSprocExceptionTimout",  "p_xuacs_get_user_account_info", "",     "System.Exception", 3000, false, false),
         CompoundCase("SingleSprocOddCaseException", "p_XuACs_gET_USeR_aCcOuNt_inFO", "",     "System.Exception", 0,    false, false),
         CompoundCase("FullDBException",             "",                              "uodb", "System.Exception", 0,    false, false),
         CompoundCase("FullDBTimeout",               "",                              "uodb", "",                 3000, false, true),
         CompoundCase("FullDBExceptionTimeout",      "",                              "uodb", "System.Exception", 3000, false, false),
         CompoundCase("FullDBOddCaseException",      "",                              "uODb", "System.Exception", 0,    false, false)
        ]
        public class SprocFailureMatrix_LiveLib : LiveTestNode
        {
            GetUserInfoRequest request;
            GetUserInfoResponse response;
            XblUser user;

            public override void Setup()
            {
                user = ClientProvider.CreateUser(XblUserTier.Silver, PassportType.Fake);

                request = new GetUserInfoRequest();
                request.userPuid = user.Puid;
                request.machinePuid = Client.MachinePuid;
                request.titleId = 0xFFFE07D1;

                // We want to test the call once to ensure that it's working with no injection
                response = new GetUserInfoResponse();

                Global.RO.Info("Verifying that the request works before behavior injection");
                live.server.UACS.SendRequest(Client, user, request, response);

                if (response.age == 0)
                {
                    throw new UnexpectedTestResultException("Normal request failed.  Ensure that server is functioning correctly.");
                }
            }

            public override void Execute()
            {
                bool caughtException = false;
                DateTime startTime;
                TimeSpan elapsedTime = TimeSpan.Zero;

                // Grab the values we need and setup the behavior injection
                string sprocName = (String)MyValues[0];
                string dbName = (String)MyValues[1];
                string exceptionType = (String)MyValues[2];
                uint timeout = (uint)(int)MyValues[3];
                bool passthrough = (bool)MyValues[4];
                bool shouldPass = (bool)MyValues[5];

                // If the sproc name is NOT null or empty then we have a sproc
                bool hasSproc = !String.IsNullOrEmpty(sprocName);
                // If the exception type is NOT null or empty then we have an exception
                bool hasException = !String.IsNullOrEmpty(exceptionType);
                // If the timeout is greater than 0 then we have a timeout.
                bool hasTimeout = (timeout > 0);

                Global.RO.Info("Injecting Sproc Failure for {0}. {1}{2}",
                    hasSproc ? "Sproc " + sprocName : "DB " + dbName,
                    hasException ? "Exception: " + exceptionType + " " : "",
                    hasTimeout ? "Timeout: " + timeout.ToString() : "");
                
                // Add behavior injection to the sproc
                request.BehaviorInjection.AddSprocFailure(sprocName, dbName, exceptionType, timeout, passthrough);

                response = new GetUserInfoResponse();
                startTime = DateTime.Now;
                try
                {
                    uint hr = live.server.UACS.SendRequest(Client, user, request, response);
                    if (HResult.Failed(hr))
                    {
                        throw new Exception(Global.XErrToString(hr));
                    }
                }
                catch (Exception)
                {
                    caughtException = true;
                }
                elapsedTime = DateTime.Now - startTime;

                // Now we go through and check everything
                ResultCode = TEST_RESULTS.PASSED;

                // Check if the timeout was handled correctly
                if (hasTimeout)
                {
                    if (elapsedTime.TotalMilliseconds < timeout)
                    {
                        Global.RO.Error("Sleep time passed into behavior injection was not followed. Expected {0}ms, got {1}ms.", timeout, elapsedTime.Milliseconds);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Success("Sleep time passed into behavior injection was followed.");
                    }
                }

                // Check if the exception was handled correctly
                // We only care about the listed exception if it's expected to fail
                if (hasException && !shouldPass)
                {
                    if (!caughtException)
                    {
                        Global.RO.Error("Injected exeception was not thrown.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Success("Injected exception was thrown as expected.");
                    }
                }

                // Check if the call succeeded or failed as expected
                if (shouldPass)
                {
                    if (response.age != 0)
                    {
                        Global.RO.Success("Request succeeded as expected.");
                    }
                    else
                    {
                        Global.RO.Error("Request failed when it was expected to succeed");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                else
                {
                    if (response.age == 0)
                    {
                        Global.RO.Success("Request failed as expected.");
                    }
                    else
                    {
                        Global.RO.Error("Request passed when it was expected to fail");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

            }
        }

        /// <summary>
        ///     Using NpdbOverride allows us to specify a value for a setting in NPDB without having to actually change the setting, this is good for failure testing so that we don't interrupt any other operations or requests coming in.
        ///
        ///	    I used NpdbOverride to set signature_serviceKeyVersion to 1014. The value is normally 1. 
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> NpdbOverride
        ///         <b>Input:</b> signature_serviceKeyVersion, 1014
        ///         <b>Request:</b> XSigSignOnBehalf
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         Since XsigSignOnBehalf doesn't thrown an exception when the keyVersion is incorrect, I can simply verify that the signature that comes back is NULL. Also looking in the event log on the server shows the failure. 
        ///     </verification>
        /// 
        ///     <dependencies>
        ///         <UL>
        ///             <LI>UACS [User Creation]</LI>
        ///         </UL>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("NpdbOverride With A Single Setting"), TestFrequency("Regression"), TestCasePriority(1)]
        public class NpdbOverrideSingleSetting_LiveLib : TestNode
        {
            XRLXSigSignOnBehalf signOnBehalf;

            public override void PreRun()
            {
                signOnBehalf = new XRLXSigSignOnBehalf(1);

                // Setup the request
                signOnBehalf.Requests[0] = XRLXSigSignOnBehalf.CreateSignRequest(1, RandomEx.GlobalRandGen.GenerateRandomBlob(20));
                signOnBehalf.Requests[0]._authData._userID1 = 0x123412341;
                signOnBehalf.Requests[0]._authData._userID2 = 0x123412342;
                signOnBehalf.Requests[0]._authData._userID3 = 0x123412343;
                signOnBehalf.Requests[0]._authData._userID4 = 0x123412344;

                Global.RO.Info("Verifying that the request works before behavior injection");
                if(!signOnBehalf.Execute() || signOnBehalf.Responses[0]._hresult != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException("Request without Behavior Injection failed. Verify the environment is working correctly.");
                }
            }

            public override void Run()
            {
                Global.RO.Info("Signature = " + ServerTestFramework.Utilities.Hexer.tohex(signOnBehalf.Responses[0]._signature.GetBytes()));

                //request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddNpdbOverride(verSetting, keyVersion.ToString(), false);
                //request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddNpdbOverride(typeSetting, keyType.ToString(), false);

                signOnBehalf.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("signature_serviceKeyVersion", "1014", false);

                Global.RO.Info("Sending request with Behavior Injection");

                if (!signOnBehalf.Execute())
                {
                    throw new UnexpectedTestResultException("SignOnBehalf request failed unexpectedly");
                }

                if (signOnBehalf.Responses[0]._hresult != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException("SignOnBehalf request succeded with invalid service key version overrride");
                }
            }
        }

        /// <summary>
        ///     Specify overrides for multiple Npdb values and determine that all the values are being overridden.
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> NpdbOverride
        ///         <b>Input:</b> signature_serviceKeyVersion: 1, signature_serviceKeyType: 7
        ///         <b>Request:</b> XRLGetSigningKey
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         We know that the request should succeed normally, so we override the values in NPDB to be invalid,
        ///         which causes the call to fail.  Then, by injecting the correct values, if the call succeeds, we know
        ///         that all behavior injected values are being used.
        ///     </verification>
        /// 
        ///     <dependencies>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("NpdbOverride Multiple Settings"), TestFrequency("Regression"), TestCasePriority(2)]
        public class NpdbOverrideMultipleSetting : TestNode
        {
            private static readonly String verSetting = "signature_serviceKeyVersion";
            private static readonly String typeSetting = "signature_serviceKeyType";

            XSigSignature signature = null;
            XRLGetSigningKey request;
            
            short keyVersion;
            short keyType;
            SettingState keyVerState;
            SettingState keyTypeState;

            public override void  PreRun()
            {
                request = new XRLGetSigningKey();

                signature = request.Execute();

                if (signature == null)
                {
                    throw new UnexpectedTestResultException("GetSigningKey call failed.  Please ensure the service is functioning correctly");
                }

                signature = null;

                // Get the 'default' values
                keyVersion = (short)Global.XEnv.GetIntSetting(verSetting);
                keyType = (short)Global.XEnv.GetIntSetting(typeSetting);

                // Then override the database values with something invalid and force a reload
                keyVerState = Global.XEnv.OverrideSetting("ALL", "ALL", verSetting, "9999", -1);
                keyTypeState = Global.XEnv.OverrideSetting("ALL", "ALL", typeSetting, "8888", -1);

                String xmgmtText = String.Empty;
                bool result = ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(xonline.common.config.Interface.xsig, "xsig", "xsig configcacherefresh", out xmgmtText);
                Global.RO.Info(xmgmtText);
                if (!result)
                {
                    Global.RO.Warn("There was a problem issuing the cache refresh command.  There may be errors running the tests.");
                }
            }

            public override void Run()
            {
                // Perform a request with the invalid setting values
                signature = request.Execute();

                // The request should fail
                if (signature != null)
                {
                    throw new UnexpectedTestResultException("GetSigningKey request still succeded with invalid type and version settings");
                }
                else
                {
                    Global.RO.Info("NPDB Settings for version and type overridden successfully.");

                    // Add setting overrides for both settings BACK to the default values
                    request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddNpdbOverride(verSetting, keyVersion.ToString(), false);
                    request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddNpdbOverride(typeSetting, keyType.ToString(), false);

                    // Perform the request again and it should succeed
                    signature = request.Execute();

                    if (signature == null || signature._signature == null)
                    {
                        throw new UnexpectedTestResultException(
                            "GetSigningKey failed using multiple default settings as injected overrides");
                    }

                    Global.RO.Success("Multiple NPDB Setting Behavior Injections were successful");
                }
            }

            public override void PostRun()
            {
                // Restore the prior settings
                Global.XEnv.RestoreOverrideSettingState(keyVerState);
                Global.XEnv.RestoreOverrideSettingState(keyTypeState);

                String xmgmtText;
                ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAll(xonline.common.config.Interface.xsig, "e :xsig configcacherefresh", out xmgmtText);
                Global.RO.Info(xmgmtText);
            }
        }

        /*
        [TestCase, Owner("BenRan"), Description("NpdbOverride Multiple Settings"), TestFrequency("Regression"), Ignore]
        [SupportedClients(SupportedClient.Xbox360)]
        public class NpdbOverrideValueWithColon : LiveTestNode
        {
            public static readonly String casvcSetting = "casvc_genericSslIssuerName";
            public static readonly String testIssuerName = @"test-issuer.xboxlive.com";

            public XmacsClient client = null;
            public UserEditor user = null;

            public XRLCreateCertificate xrl = null;

            public override void Setup()
            {
                client = new XmacsClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                client .SignInXmacs();

                user = UserEditor.CreateNew();

                xrl = new XRLCreateCertificate();
                xrl.Request.PubKey = new byte[272];
                xrl.Request.appId = "generic_ssl";
                xrl.Request.userPuid = user.Puid;

                Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig flushcasettings");
            }

            public override void Execute()
            {
                /*
                XeUser user = XbosUser.XenonGoldUser();

                string paymentInstrumentId = user.AddPaymentInstrumentVisa();

                XRLXeOfferPurchase request = new XRLXeOfferPurchase();

                request.UserPuid = user.UserPuid;
                //request.OfferID = XeOfferPurchaseMusicNetSubscription.MusicNetSubTestBase.MUSICNET_MONTHLY_SUB_OFFERID; // monthly cc offer
                //request.SchemaVersion = WireData.MakeSchemaVersion(1,0);
                request.LanguageID = user.LanguageId;
                request.CountryID = user.CountryId;
                request.Tier = (byte)UodbWS.GetUserTier(user.UserPuid);
                request.PaymentType = (uint)live.common.PaymentTypeEnum.CreditCard;
                request.PaymentInstrumentID = paymentInstrumentId; //paymentInstrumentId;

                request.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("musicnet_getServiceConfigurationUrl", "http//GARYT-DEV1/MusicNot.asmx?wsdl", false);
                request.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("crux_useMusicNetForProvisioning", "no", false);


                if (!request.Execute())
                    throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));

                ResultCode = TEST_RESULTS.PASSED;

                /*

                xrl.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddNpdbOverride(casvcSetting, testIssuerName, false);

                if (!xrl.Execute(client.GetMachinePuid()))
                {
                    Global.RO.Error("Unable to create certificate: " + xrl.GetDumpString());
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }

                X509Certificate2 cert = new X509Certificate2(xrl.Response.Certificate);

                if (!cert.Issuer.Contains(testIssuerName))
                {
                    Global.RO.Error("Issuer name does not have the overridden issuer name");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Error("Overriden issuername present in certificate");
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            public override void TearDown()
            {
                Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig flushcasettings");
            }
        }
        */

        /// <summary>
        ///     Using AlternateBillingUrl will point billing calls to a Url other than the normal one (pretty obvious)
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> Alternate Billing Url
        ///         <b>Input:</b> http://www.aol.com
        ///         <b>Request:</b> XRLXeGetUserInfo
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         When XRLXeGetUserInfo fails the response is set to null. If the response is null, I know that the injection worked.
        ///     </verification>
        /// 
        ///     <dependencies>
        ///         <UL>
        ///             <LI>UACS [User Creation]</LI>
        ///         </UL>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("Adds an alternate billing url"), TestFrequency("Regression"), TestCasePriority(2), Ignore("It looks like the billing code has been changed to ignore the alternate billing url")]
        [SupportedClients(SupportedClient.Xbox360)]
        public class AlternateBillingUrl : LiveTestNode
        {
            XblUser user;

            XRLXeGetPointsBalance request;
            XRLXeGetPointsBalanceResponse response;

            public override void Setup()
            {
                user = ClientProvider.CreateUser(XblUserTier.Silver, PassportType.Real);

                request = new XRLXeGetPointsBalance();
                response = new XRLXeGetPointsBalanceResponse();

                request.userPuid = user.Puid;
                request.machinePuid = Client.MachinePuid;

                uint balance = UACS.XeGetPointsBalance(Client, user);
                if (balance != 0)
                {
                    throw new UnexpectedTestResultException("Points Balance on new user is not 0.");
                }
                else
                {
                    // Purchase some points for this user
                    Billing.XeOfferPurchase(Client, user, Offers.GetOfferId(Offers.PointsOffers.PP4000),
                        PaymentTypeEnum.Token, Offers.GetPrepaidVoucherCode(Offers.PointsOffers.PP4000));
                }

                Global.RO.Info("Verifying that the request works before behavior injection");
                request.Execute(out response);
                Global.RO.Info("Price Balence = " + response.PointsBalance);

                if (response == null)
                {
                    throw new UnexpectedTestResultException("Unable to perform request without Behavior Injection.  Verify server is working correctly.");
                }
            }

            public override void Execute()
            {
                // Create a response
                response = new XRLXeGetPointsBalanceResponse();

                // Add the AlternateBillingUrl injection
                request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddAlternateBillingUrl("http://www.aol.com", true);


                Global.RO.Info("Validating failure after behavior injection");
                request.Execute(out response);

                if (null == response)
                {
                    Global.RO.Success("Request failed as expected after redirecting billing URL to an invalid address");
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Error("Request succeeded with invalid billing URL specified.  Injected URL may have been igonored.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// <summary>
        ///     Using AlternateDmpUrl will point dmp calls to a Url other than the normal one (pretty obvious)
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> Alternate Dmp Url
        ///         <b>Input:</b> XRLXeGetUserInfo
        ///         <b>Request:</b> http://www.aol.com 
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         When XRLXeGetUserInfo fails the response is set to null. If the response is null, I know that the injection worked
        ///     </verification>
        /// 
        ///     <dependencies>
        ///         <UL>
        ///             <LI>UACS [User Creation]</LI>
        ///         </UL>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("Adds an alternate DMP url"), TestFrequency("Regression"), TestCasePriority(2)]
        [SupportedClients(SupportedClient.Xbox360)]
        public class AlternateDmpUrl : LiveTestNode
        {
            XRLXeGetPointsBalance request;
            XRLXeGetPointsBalanceResponse response;

            public override void Setup()
            {
                User = ClientProvider.CreateUser(XblUserTier.Silver, PassportType.Real);

                uint balance = UACS.XeGetPointsBalance(Client, User);
                if (balance != 0)
                {
                    throw new UnexpectedTestResultException("Points Balance on new user is not 0.");
                }
                else
                {
                    // Purchase some points for this user
                    Billing.XeOfferPurchase(Client, User, Offers.GetOfferId(Offers.PointsOffers.PP4000),
                        PaymentTypeEnum.Token, Offers.GetPrepaidVoucherCode(Offers.PointsOffers.PP4000));
                }
                
                Global.RO.Info("Verifying that the request works before behavior injection");
                request = new XRLXeGetPointsBalance();
                response = new XRLXeGetPointsBalanceResponse();

                request.userPuid = User.Puid;
                request.machinePuid = Client.MachinePuid;
                request.Execute(out response);
                Global.RO.Info("Price Balance = " + response.PointsBalance);

                if (response == null)
                {
                    throw new UnexpectedTestResultException("Unable to perform request without Behavior Injection.  Verify server is working correctly.");
                }
            }

            public override void Execute()
            {
                // Create a response
                response = new XRLXeGetPointsBalanceResponse();

                // Add the AlternateDmpUrl injection
                request.CustomHeader += ServerTestFramework.Utilities.BehaviorInjection.AddAlternateDmpUrl("http://www.aol.com", true);

                Global.RO.Info("Validating failure after behavior injection");
                request.Execute(out response);

                if (null == response)
                {
                    Global.RO.Success("Request failed as expected after redirecting billing URL to an invalid address");
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Error("Request succeeded with invalid DMP URL specified.  Injected URL may have been igonored.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

            }
        }

        /// <summary>
        ///     Using AlternatePassportURL, we can redirect calls to the passport service to an alternate location
        /// </summary>
        /// <remarks>
        ///     <scenarios>
        ///         <b>Injection:</b> AlternatePassportURL
        ///         <b>Input:</b> http://www.aol.com
        ///         <b>Request:</b> XEPassportLoginRequest
        ///     </scenarios>
        ///     
        ///     <verification>
        ///         If the requests are being redirected to a different location the call will fail. So if the call fails, then we will know it was redirected.
        ///     </verification>
        /// 
        ///     <dependencies>
        ///         <UL>
        ///             <LI>UACS [User Creation]</LI>
        ///         </UL>
        ///     </dependencies>
        /// </remarks>
        [TestCase, Owner("BenRan"), Description("Adds an alternate Passport url"), TestFrequency("Regression"), TestCasePriority(1)]
        [SupportedClients(SupportedClient.Xbox360)]
        public class AlternatePassportUrl : LiveTestNode
        {
            public override void Execute()
            {
                XblUser user = ClientProvider.CreateUser(XblUserTier.Silver, PassportType.Real);
                live.common.PassportInfo ppInfo = user.Settings.UserPassportInfo;

                XePassportLoginRequest req = new XePassportLoginRequest();
                live.server.UACS.LLPassportLoginResponse resp = new live.server.UACS.LLPassportLoginResponse(req.serviceId);

                byte[] encSessionKey, encPassword, encLoginTokenRequest;
                PassportUtils.GenerateEncryptedLoginParts(Client, ppInfo,
                    out encSessionKey, out encPassword, out encLoginTokenRequest);

                req.encryptedPassword = encPassword;
                req.encryptedPasswordLength = (ushort)req.encryptedPassword.Length;
                req.encryptedSessionKey = encSessionKey;
                req.encryptedSessionKeyLength = (ushort)req.encryptedSessionKey.Length;
                req.encryptedTokenRequest = encLoginTokenRequest;
                req.encryptedTokenRequestLength = (ushort)req.encryptedTokenRequest.Length;
                req.passportMemberName = ppInfo.MemberName;
                req.passportMemberNameLength = (ushort)req.passportMemberName.Length;
                req.serviceId = 0;

                req.BehaviorInjection.AddAlternatePassportUrl("http://www.aol.com", true);

                uint hr = live.server.UACS.SendRequest(Client, null, req, resp);
                if (live.common.HResult.Failed(hr))
                {
                    Global.RO.Info(live.common.HResult.XErrToString(hr));
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\AddPayPal.cs ===
using System;
using System.Xml;
using System.Net;
using System.IO;
using System.Web;
using System.Text;
using System.Xml.Serialization;

using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;

namespace XeXbos
{
    [XmlRootAttribute("PaymentInstrumentInfoSet", IsNullable = false, Namespace = "urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSet {

        [XmlElement(ElementName = "PaymentInstrumentInfo")]
        public PayPalPaymentInfo[] PaymentInstrumentInfoItem;    
    }


   
    public class PayPalPayinInfo {
        [XmlElement(ElementName = "BillingAgreementDetails")]
        public BdkBillingAgreementDetails BillingAgreementDetail;  
    }

    
    public class BdkBillingAgreementDetails {
        [XmlElement]
        public string PayerEmail;
        [XmlElement]
        public string BillingAgreementId;
        [XmlElement]
        public string FirstName;
        [XmlElement]
        public string MiddleName;
        [XmlElement]
        public string LastName;
        [XmlElement]
        public string PayerBusiness;
        [XmlElement]
        public string PayerCountry;
        [XmlElement]
        public string BillingAgreementDescription;
    }

    public class PayPalPaymentInfo
    {

        uint puidHigh = 0;
        uint PuidLow = 0;
        [XmlElement]
        public string PaymentInstrumentId;
        [XmlElement]
        public string FriendlyName;
        [XmlElement (ElementName = "PayPalPayinInfo")]
        public PayPalPayinInfo PayPalPayinInfoItem;

        XeUser.Country countryId = XeUser.Country.US;

        public string ToXml(XeUser.Country countryId)
        {
            this.countryId = countryId;                       
            return ToXml();            
        }


        public string ToXml()
        {
            StringBuilder xmlBldr = new StringBuilder();
             xmlBldr.Append("<" + "PaymentInstrumentInfo" + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<PaymentInstrumentType>");
            xmlBldr.Append("PAYPALPAYIN");
            xmlBldr.Append("</PaymentInstrumentType>");

            xmlBldr.Append("<FriendlyName>");
            xmlBldr.Append("PayPal test");
            xmlBldr.Append("</FriendlyName>");

            xmlBldr.Append("<PayPalPayinInfo><PayPalTokenizeInfo><ReturnURL>http://www.live.com</ReturnURL><CancelURL>http://www.live.com</CancelURL><Description>PaypalPayinDescription</Description></PayPalTokenizeInfo></PayPalPayinInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>123</PhonePrefix><PhoneNumber>4567890</PhoneNumber><PhoneExtension>67890</PhoneExtension>");
            xmlBldr.Append("<CountryCode>");
            xmlBldr.Append(countryId.ToString());
            xmlBldr.Append("</CountryCode></Phone><AddressInfo><AddressId></AddressId><FriendlyName>Foo Bar's Address</FriendlyName><UnitNumber>12</UnitNumber>");

            xmlBldr.Append("<Street1>123 Main Street</Street1><Street2>Street2</Street2><Street3></Street3>");
            AddressInfoData addressInfo = new AddressInfoData();
            addressInfo.SetDefaultAddress(countryId);

            xmlBldr.Append(string.Format("<City>{0}</City><District></District><State>{1}</State><CountryCode>{2}</CountryCode><PostalCode>{3}</PostalCode>",
                addressInfo.City, addressInfo.State, countryId.ToString(), addressInfo.PostalCode));
            xmlBldr.Append("<AddressMapAttempted>false</AddressMapAttempted><AddressMapSucceeded>false</AddressMapSucceeded><AddressMapFailureReason>2</AddressMapFailureReason><AddressMapConfidenceScore>0.5</AddressMapConfidenceScore><ManualAddressSpecified>false</ManualAddressSpecified></AddressInfo></PaymentInstrumentInfo>"); 

             return xmlBldr.ToString();
        }


        const string viewStateNameDelimiter = "__VIEWSTATE";
        const string eventValidationNameDelimiter = "__EVENTVALIDATION";
        // used to retrive the view state of paypal sign up page for post the  sign up info back later.  
        private string ExtractViewState(string s, string nameDelimiter)
        {

            string valueDelimiter = "value=\"";

            int viewStateNamePosition = s.IndexOf(nameDelimiter);
            int viewStateValuePosition = s.IndexOf(
                  valueDelimiter, viewStateNamePosition
               );

            int viewStateStartPosition = viewStateValuePosition +
                                         valueDelimiter.Length;
            int viewStateEndPosition = s.IndexOf("\"", viewStateStartPosition);

            return HttpUtility.UrlEncodeUnicode(
                     s.Substring(
                        viewStateStartPosition,
                        viewStateEndPosition - viewStateStartPosition
                     )
                  );
        }

        //go to PayPal emulator to sign up a paypal account using the returned url from AddPaymentInstrument 
        private void SignuPayPal(string paypalUrl)
        {
            // first, request the login form to get the viewstate value
            HttpWebRequest webRequest = WebRequest.Create(paypalUrl) as HttpWebRequest;
            StreamReader responseReader = new StreamReader(
                  webRequest.GetResponse().GetResponseStream()
               );
            string responseData = responseReader.ReadToEnd();
            responseReader.Close();

            // extract the viewstate value and build out POST data
            string viewState = ExtractViewState(responseData, viewStateNameDelimiter);
            string eventValidation = ExtractViewState(responseData, eventValidationNameDelimiter);
            string postData =
                  String.Format(
                     "__EVENTTARGET=&__EVENTARGUMENT=&__VIEWSTATE={0}&__EVENTVALIDATION={1}&EMAIL={2}@xbltest.com&ACCEPT=Accept",
                     viewState, eventValidation, "paypal" + new Guid()
                  );


            // now post to the login form
            webRequest = WebRequest.Create(paypalUrl) as HttpWebRequest;
            webRequest.Method = "POST";
            webRequest.ContentType = "application/x-www-form-urlencoded";


            // write the form values into the request message
            StreamWriter requestWriter = new StreamWriter(webRequest.GetRequestStream());
            requestWriter.Write(postData);
            requestWriter.Close();

            responseReader = new StreamReader(webRequest.GetResponse().GetResponseStream());
            // and read the response
            responseData = responseReader.ReadToEnd();
            responseReader.Close();

        }

        static PaymentInstrumentInfoSet ConvertToPayPalPaymentInfo(string pbstrPaymentInstrumentInfoSetXML)
        {

            XmlSerializer ser = new XmlSerializer(typeof(PaymentInstrumentInfoSet), "urn:schemas-microsoft-com:billing-data");
            StringReader sr = new StringReader(pbstrPaymentInstrumentInfoSetXML);
            return ((PaymentInstrumentInfoSet)ser.Deserialize(sr));        
        }


        // automate the process of create PayPal account and add PayPal payment instrument 
        //using one box PayPal emulator and spk web service call. 
        public PaymentInstrumentInfoSet AddToBillingAccount(BdkInterface bdk, XeUser user, bool acceptBillingAgreement)
        {

            
            string accountId = null;
            string guid = Guid.NewGuid().ToString();
            string errorXml = null;
            
            string paypalUrl = null;
            string paymentInstrumentInfo = this.ToXml((XeUser.Country) user.CountryId);
            //ulong userPuid;

            UserInfo userInfo;
            

            if (UodbWS.GetUserInfo(user.UserPuid, out  userInfo))
            {
                accountId = userInfo.billingAccountId;
            }
            else
                throw new Exception("can not get the billingAccountId from uodb");


            ulong passportPuid = UodbWS.GetUserPassportUserPuid(user.UserPuid);

            puidHigh = (uint)((passportPuid & 0xffffffff00000000) >> 32);
            PuidLow = (uint)(passportPuid & 0xffffffff);


            try
            {
                bdk.AddPaymentInstrument(
                    0x1,
                    0x1,
                    (int)puidHigh,
                    (int)PuidLow,
                    guid,
                    accountId,
                    paymentInstrumentInfo,
                    out errorXml,
                    out PaymentInstrumentId,
                    out paypalUrl);


                if (acceptBillingAgreement)
                {
                    //get paypal sign up Url
                    if (paypalUrl != null)
                    {
                        //go to PayPal emulator to sign up 
                        SignuPayPal(paypalUrl);
                    }
                    else throw new Exception("PayPal URL is null");

                    //Finsh the last step to link paypal account using paymentInstrumentId from AddPaymentInstrument
                    bdk.UpdatePaymentInstrumentInfo(0, 0, (int)puidHigh, (int)PuidLow, PaymentInstrumentId, paymentInstrumentInfo, out errorXml);
                }
                
                string pbstrErrorXML;
                string pbstrPaymentInstrumentInfoSetXML;
                int plPaymentInstrumentInfoCount;

                bdk.GetPaymentInstrumentsEx(1, 1, (int)puidHigh, (int)PuidLow, PaymentInstrumentId, true, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pbstrPaymentInstrumentInfoSetXML);

                return ConvertToPayPalPaymentInfo(pbstrPaymentInstrumentInfoSetXML);
            }
            catch (Exception e)
            {
                throw e;
            }
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\DBHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;

using xonline.common.sql.sqlclient;

//using ServerTestFramework.Utilities;

namespace XeXbos
{
    public class DBHelper
    {
        public static List<Guid> GetMediaOrInstanceIdFromDB(string db, string sql)
        {
            List<Guid> ids = new List<Guid>(16);
            using (SqlClient client = new SqlClient(db, true))
            {
                using (SqlDataReader reader = client.Execute(sql))
                {
                    while (reader.Read())
                    {
                        ids.Add(reader.GetGuid(0));
                    }

                    reader.Close();
                    return ids;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\EmulatorClient.cs ===
using System;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Web.Services.Protocols; // SoapException
using System.Collections;
using System.Xml.Schema;
using System.IO;
using System.Runtime.Serialization;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.WebWidget;

using xonline.common.utilities;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using Microsoft.XBox.Live.Server.Emulators.FinBus;
using microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrder;
using microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemption;
using microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo;
using microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse;
using Microsoft.XBox.Live.Server.Emulators.TransactionService;


namespace XeXbos
{
    public class SCSHelper
    {
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // the Receipt classed used by SCS:PurchaseItem
        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class Receipt
        {
            [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
            public ItemReceipt[] ItemReceiptSet;
            public RedirectOutputInfo RedirectOutputInfo;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class ItemReceipt
        {
            public AmountCharged AmountCharged;
            public string ItemInstanceId;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class RedirectOutputInfo
        {
            public string RedirectURL;
            public string ConfirmationNumber;
            public string EncryptedInfo;
            public string ContextInfo;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class AmountCharged
        {
            public System.Decimal Gross;
            public System.Decimal Charge;
            public string Locale;
            public string Currency;

            [System.Xml.Serialization.XmlArrayItemAttribute("Tax", IsNullable = false)]
            public taxSet25TypeTax[] TaxSet;
            public chargeStatusType ChargeStatus;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        public enum chargeStatusType
        {
            SUCCESS,
            FAIL,
            PENDING,
            COMPUTE,
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        public class taxSet25TypeTax
        {
            public taxType TaxType;
            public System.Decimal TaxAmount;
            public string Rate;
            public Exempt Exempt;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        public enum taxType
        {
            CITY,
            CITY2,
            COUNTRY,
            COUNTY,
            COUNTY2,
            DISTRICT,
            GST,
            PST,
            STATE,
            STATE2,
            TERRITORY,
            VAT,
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public enum Exempt
        {
            TRUE,
            FALSE
        }
    }


    /// <summary>
    /// The emulator client to use Dmp emulator, billing emulator, or musicnet emulator
    /// </summary>
    public class EmulatorClient
    {
        /* MusicNet SoapException
        <?xml version="1.0" encoding="utf-16"?>
        <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <soap:Body>
            <soap:Fault>
              <faultcode>soap:Server</faultcode>
              <faultstring>SoldForPrice Value not defined.</faultstring>
              <detail>
                <EcommerceB2BServiceException xmlns="http://ws.musicnet.com">
                  <code>800</code>
                  <details>SoldForPrice Value not defined.</details>
                  <message>SoldForPrice Value not defined.</message>
                  <server>WSMUSICNET/4.2.0.176/mfn_dev2dev/tkmsbl01/127.0.0.1</server>
                  <transactionId>0x0x0x0x0x0x0x0</transactionId>
                </EcommerceB2BServiceException>
              </detail>
            </soap:Fault>
          </soap:Body>
        */

        public static readonly string InvalidOrderId = "209";
        public static readonly string AccountSuspendedOrClosed = "424";

        // new MNErrorMapping(209, xonline.common.service.HResult.XONLINE_E_MUSICNET_INVALID_ORDER_ID),
        // new MNErrorMapping(424, xonline.common.service.HResult.XONLINE_E_MUSICNET_ACCOUNT_SUSPENDED_OR_CLOSED)
        public static SoapException MakeMusicNetSoapException(string errorCode)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml("<detail>" +
                "<EcommerceB2BServiceException xmlns=\"http://ws.musicnet.com\">" +
                  "<code>" + errorCode + "</code>" +
                  "<details>SoldForPrice Value not defined.</details>" +
                  "<message>SoldForPrice Value not defined.</message>" +
                  "<server>WSMUSICNET/4.2.0.176/mfn_dev2dev/tkmsbl01/127.0.0.1</server>" +
                  "<transactionId>0x0x0x0x0x0x0x0</transactionId>" +
                "</EcommerceB2BServiceException>" +
              "</detail>");

            XmlNode node = doc.FirstChild;
            SoapException musicnetSoap = new SoapException("MusicNet soap error occurred", SoapException.ClientFaultCode, "http//musicnetfakeurl", node);

            return musicnetSoap;
        }

        public static SoapException MakeDmpSoapException()
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml("<detail><DMPErrorInfo xmlns=\"http://schemas.microsoft.com/DMP/2004/09/API\">" +
                        "<Property>DMP</Property>" +
                        "<Error>DMP_E_SYSTEM_INTERNAL_ERROR</Error>" +
                        "<DetailMessage>Some detail message</DetailMessage>" +
                        "<CanRetry>false</CanRetry>" +
                        "<ErrorBlob>Encrypted blah blah blah</ErrorBlob>" +
                       "</DMPErrorInfo></detail>");

            XmlNode node = doc.FirstChild;
            SoapException dmpSoap = new SoapException("DMP Fault occurred", SoapException.ClientFaultCode, "http//fakeurl", node);

            return dmpSoap;
        }

        // prepare the dmp items
        public static char[] g_unsafeDMPCharacters = {
                '\u003B',
                '\u003C',
                '\u003E',
                '\u0028',
                '\u0029',
                '\u005C',
                '\u0022',
                '\u0024',
                '\u0026',
                '\u0025'
            };

        public static string MakeDMPSafeString(string s, int maxChars)
        {
            if (s.Length > maxChars)
                s = s.Substring(0, maxChars);

            if (s.IndexOfAny(g_unsafeDMPCharacters) == -1)
                return s;

            StringBuilder sb = new StringBuilder(s);
            int startingIndex = 0;
            while (true)
            {
                int badCharIndex = s.IndexOfAny(g_unsafeDMPCharacters, startingIndex);
                if (badCharIndex == -1)
                    break;
                sb[badCharIndex] = ' ';
                startingIndex = badCharIndex + 1;
            }

            return sb.ToString();
        }

        public static void PrintDmpItems(Item[] dmpItems)
        {
            Global.RO.Info("Number of dmp items: " + dmpItems.GetLength(0));
            for (int i = 0; i < dmpItems.GetLength(0); i++)
            {
                Global.RO.Info("-------- dmp item # " + i);
                Global.RO.Info("ExternalId: " + dmpItems[i].ExternalId);
                Global.RO.Info("Title: " + dmpItems[i].Title);
                Global.RO.Info("Price: " + dmpItems[i].Price);
                Global.RO.Info("SKU: " + dmpItems[i].SKU);
                Global.RO.Info("Item Category: " + dmpItems[i].ItemCategory);
            }
        }

        private static Hashtable responseTimeTbl;

        //To do: get the response time from xml file.
        public static Hashtable GetBillingCallResponseTimeTbl()
        {
            if (responseTimeTbl != null) return responseTimeTbl;
            responseTimeTbl = new Hashtable();

            responseTimeTbl.Add("GetAccountInfo", 100);
            responseTimeTbl.Add("CreateAccount", 3000);//500
            responseTimeTbl.Add("GetSubscriptions", 100);
            responseTimeTbl.Add("GetPaymentInstruments", 46);
            responseTimeTbl.Add("ProvisionServices", 320);
            responseTimeTbl.Add("AddPaymentInstrument", 4500);//2063
            responseTimeTbl.Add("PurchaseOfferingEx", 1169);
            responseTimeTbl.Add("UpdateAccountInfo", 235);
            responseTimeTbl.Add("SCSPurchaseItem", 4500);//2209
            responseTimeTbl.Add("DMPPurchaseItem", 220);//200
            responseTimeTbl.Add("GetBalance", 176);//100
            responseTimeTbl.Add("GetKey", 50);
            responseTimeTbl.Add("TransferBalance", 50);
            responseTimeTbl.Add("SubmitOrder", 2500);
            responseTimeTbl.Add("OffsetOrder", 2500);
            responseTimeTbl.Add("CalculateTax", 500);
            responseTimeTbl.Add("ComputeOnlyPurchase", 400);
            responseTimeTbl.Add("SubscriptionPurchase", 1600);
            responseTimeTbl.Add("TransferPoints", 2400);
            return responseTimeTbl;
        }
        // for Xbox live content dmp purchase, don't need to GetPointsBalance
        public static void CallDmpPurchaseEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid, Item[] items)
        {
            CallDmpPurchaseEmulator(DmpEmu, ref Idmp, passportPuid, items, false);
        }

        // for Music, the dmp purchase also includes GetPointsBalance
        public static void CallDmpPurchaseEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid, Item[] items, bool getPointsBalance)
        {
            Guid trackingGuid = Guid.NewGuid();

            TransactionContext context = new TransactionContext();
            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = "DmpPurchaseItemComfirmationId";

            Idmp = DmpEmu.StartRecording();
            Idmp.PurchaseItem(trackingGuid, (long)passportPuid, 0, items, context, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore transaction context
            //?????
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds(220));
            LastCall.On(Idmp).OutArguments(null, null, null, null, null, receipt);

            if (getPointsBalance)
            {
                int balance = 5000;
                bool aboveLowBalance = true;
                Status status = Status.Active;
                string country = "US";

                Idmp.GetBalance((long)passportPuid, 0, out balance, out aboveLowBalance, out status, out country);
                LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);
            }

            DmpEmu.StopRecording(Idmp);
        }

        public static void DmpGetPointsBalance(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid, int balance, byte accountStatus)
        {
            bool aboveLowBalance = false;   // not used
            Status status = (Status)accountStatus;
            string country = "US";

            Idmp.GetBalance((long)passportPuid, 0, out balance, out aboveLowBalance, out status, out country);
            //??????
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds(100));
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            DmpEmu.StopRecording(Idmp);
        }

        public static void CallDmpEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid,
            DMPTransactionStatus dmpStatus, Exception exPurchase, Exception exCancel, bool cancelTimeout, bool secondCancelTimeout)
        {
            Guid trackingGuid = Guid.NewGuid();
            Item[] dmpItems = new Item[1];
            TransactionContext context = new TransactionContext();
            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = "DmpPurchaseItemComfirmationId";

            Idmp = DmpEmu.StartRecording();
            Idmp.PurchaseItem(trackingGuid, (long)passportPuid, 0, dmpItems, context, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(3);   // ignore the items
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore transaction context
            if (dmpStatus == DMPTransactionStatus.Timeout)
            {
                LastCall.On(Idmp).ClosesConnection();   // close connection, treated as timteout. Will try dmp cancel immediately
                // make the CancelPurchase timeout or other exception, so the status will not change
                Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
                LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
                LastCall.On(Idmp).ClosesConnection();
            }
            else if (dmpStatus == DMPTransactionStatus.Success)
            {
                //???
                LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds(220));
                LastCall.On(Idmp).OutArguments(null, null, null, null, null, receipt);
            }
            else
                LastCall.On(Idmp).Throws(exPurchase);   // throw an exception

            if (exCancel != null || cancelTimeout)
            {
                Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
                LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
                if (cancelTimeout)
                    LastCall.On(Idmp).ClosesConnection();
                else
                    LastCall.On(Idmp).Throws(exCancel);

                if (secondCancelTimeout)
                {
                    Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
                    LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
                    LastCall.On(Idmp).ClosesConnection();
                }
            }
            DmpEmu.StopRecording(Idmp);
        }

        public static void CallDmpCancelEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid, DMPTransactionStatus dmpStatus, Exception cancelEx)
        {
            CallDmpCancelEmulator(DmpEmu, ref Idmp, passportPuid, dmpStatus, cancelEx, DMPTransactionStatus.NoStatus, null);
        }

        public static void CallDmpCancelEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid, DMPTransactionStatus dmpStatus, Exception cancelEx,
            DMPTransactionStatus retryStatus, Exception retryEx)
        {
            Guid trackingGuid = Guid.NewGuid();
            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = "DmpCancelPurchaseComfirmationId";

            Idmp = DmpEmu.StartRecording();

            Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
            LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
            if (dmpStatus == DMPTransactionStatus.Timeout)
                LastCall.On(Idmp).ClosesConnection();
            else if (dmpStatus == DMPTransactionStatus.Success)
                LastCall.On(Idmp).OutArguments(null, null, null, receipt);
            else
                LastCall.On(Idmp).Throws(cancelEx);

            if (retryStatus != DMPTransactionStatus.NoStatus)
            {
                Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
                LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
                if (retryStatus == DMPTransactionStatus.Timeout)
                    LastCall.On(Idmp).ClosesConnection();
                else if (retryStatus == DMPTransactionStatus.Success)
                    LastCall.On(Idmp).OutArguments(null, null, null, receipt);
                else
                    LastCall.On(Idmp).Throws(retryEx);
            }
            DmpEmu.StopRecording(Idmp);
        }

        public static void CallDmpRewardEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid,
            DMPTransactionStatus dmpStatus, Exception exPurchase, Exception exRetry, bool retryTimeout)
        {
            /*DMPRewardDetails details = GetDMPRewardDetails(rewardID, cultureID);
            string acquisitionTitle = MakeDMPSafeString(details.AcquisitionTitle, MaxAcquisitionTitleLength);
            AddPromotionalBalance(trackingGuid, userPassportPuid, details.PointsRewarded, trackingGuid.ToString(),
                details.PromoSKU, details.CampaignID, (short) details.RewardLifetime, acquisitionTitle,
                details.AcquisitionType, out receipt);*/

            Guid trackingGuid = Guid.NewGuid();
            string externalReferenceId = trackingGuid.ToString();

            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = "DmpAddPromotionalBalanceComfirmationId";

            string tenantID = Global.XEnv.GetSetting("dmp_tenantID");
            if (tenantID == "" || tenantID == string.Empty)
                throw new UnexpectedTestResultException("The dmp_tenantID setting is not configured");
            Guid TenantID = new Guid(tenantID);

            int balanceToAdd = 0;
            string promoSKU = "";
            int campaignId = 0;
            short expirationLen = 0;
            string acquisitionTitle = "";
            int acquisitionType = 0;

            Idmp = DmpEmu.StartRecording();
            Idmp.AddPromotionalBalance(trackingGuid, (long)passportPuid, 0, TenantID, balanceToAdd, externalReferenceId,
                promoSKU, campaignId, expirationLen, acquisitionTitle, acquisitionType, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore the balanceToAdd
            LastCall.On(Idmp).IgnoresArgument(5);   // ignore externalReferenceId
            LastCall.On(Idmp).IgnoresArgument(6);   // ignore promoSKU
            LastCall.On(Idmp).IgnoresArgument(7);   // ignore campaignId
            LastCall.On(Idmp).IgnoresArgument(8);   // ignore expirationLength
            LastCall.On(Idmp).IgnoresArgument(9);   // ignore acquisitionTitle
            LastCall.On(Idmp).IgnoresArgument(10);  // ignore acquisitionType

            if (dmpStatus == DMPTransactionStatus.Timeout)
                LastCall.On(Idmp).ClosesConnection();   // close connection, treated as timteout. Pump threads will try re-purchase later
            else if (dmpStatus == DMPTransactionStatus.Success)
                LastCall.On(Idmp).OutArguments(null, null, null, null, null, null, null, null, null, null, null, receipt);
            else
                LastCall.On(Idmp).Throws(exPurchase);   // throw an exception

            if (exRetry != null || retryTimeout)
            {
                // retry addPromoPointss
                Idmp.AddPromotionalBalance(trackingGuid, (long)passportPuid, 0, TenantID, balanceToAdd, externalReferenceId,
                    promoSKU, campaignId, expirationLen, acquisitionTitle, acquisitionType, out receipt);
                LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
                LastCall.On(Idmp).IgnoresArgument(4);   // ignore the balanceToAdd
                LastCall.On(Idmp).IgnoresArgument(5);   // ignore externalReferenceId
                LastCall.On(Idmp).IgnoresArgument(6);   // ignore promoSKU
                LastCall.On(Idmp).IgnoresArgument(7);   // ignore campaignId
                LastCall.On(Idmp).IgnoresArgument(8);   // ignore expirationLength
                LastCall.On(Idmp).IgnoresArgument(9);   // ignore acquisitionTitle
                LastCall.On(Idmp).IgnoresArgument(10);  // ignore acquisitionType

                if (retryTimeout)
                    LastCall.On(Idmp).ClosesConnection();
                else
                    LastCall.On(Idmp).Throws(exRetry);
            }
            DmpEmu.StopRecording(Idmp);
        }

        public static void CallAddPointsStressEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp)
        {

            Idmp = DmpEmu.StartRecording();

            int balance = 5000;
            bool aboveLowBalance = true;
            Status status = Status.Active;
            string country = "US";

            Idmp.GetBalance(0, 0, out balance, out aboveLowBalance, out status, out country);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore passport
            //LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            DmpEmu.StopRecording(Idmp);
        }


        public static void CallDmpStressEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp)
        {
            CallDmpStressEmulator(DmpEmu, ref Idmp, (string)null);
        }

        public static void CallDmpStressEmulator(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, string confirmId)
        {
            Guid trackingGuid = Guid.NewGuid();
            Item[] dmpItems = new Item[1];
            TransactionContext context = new TransactionContext();

            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = confirmId;
            if (string.IsNullOrEmpty(confirmId))
                receipt.ConfirmationId = "DmpPurchaseItemComfirmationId";

            Idmp = DmpEmu.StartRecording();

            /*

            Idmp.RegisterUser(trackingGuid, 0, 0, "", out receipt);
            LastCall.On(Idmp).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, null, null, receipt);

            Idmp.CancelPurchaseItem(0, 0, trackingGuid, out receipt);
            LastCall.On(Idmp).Arguments(Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, null, receipt);
            */

            Idmp.PurchaseItem(trackingGuid, 0, 0, dmpItems, context, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(1);   // ignore the passportPuid
            LastCall.On(Idmp).IgnoresArgument(3);   // ignore the items
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore transaction context
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, null, null, null, receipt);

            int balance = 5000;
            bool aboveLowBalance = true;
            Status status = Status.Active;
            string country = "US";

            Idmp.GetBalance(0, 0, out balance, out aboveLowBalance, out status, out country);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore passport
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            DmpEmu.StopRecording(Idmp);
        }


        public static void CallDmpStressEmulator(Hashtable responseTimeTbl, DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp)
        {
            CallDmpStressEmulator(responseTimeTbl, DmpEmu, ref Idmp, null);
        }




        public static void CallDmpStressEmulator(Hashtable responseTimeTbl, DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, string confirmId)
        {
            Guid trackingGuid = Guid.NewGuid();
            Item[] dmpItems = new Item[1];
            TransactionContext context = new TransactionContext();

            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = confirmId;
            if (string.IsNullOrEmpty(confirmId))
                receipt.ConfirmationId = "DmpPurchaseItemComfirmationId";

            Idmp = DmpEmu.StartRecording();

            /*

            Idmp.RegisterUser(trackingGuid, 0, 0, "", out receipt);
            LastCall.On(Idmp).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, null, null, receipt);

            Idmp.CancelPurchaseItem(0, 0, trackingGuid, out receipt);
            LastCall.On(Idmp).Arguments(Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).OutArguments(null, null, null, receipt);
            */

            Idmp.PurchaseItem(trackingGuid, 0, 0, dmpItems, context, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(1);   // ignore the passportPuid
            LastCall.On(Idmp).IgnoresArgument(3);   // ignore the items
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore transaction context
            LastCall.On(Idmp).ExpectedAnytime();
            //????
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["DMPPurchaseItem"]));
           LastCall.On(Idmp).OutArguments(null, null, null, null, null, receipt);


            int balance = 5000;
            bool aboveLowBalance = true;
            Status status = Status.Active;
            string country = "US";

            Idmp.GetBalance(0, 0, out balance, out aboveLowBalance, out status, out country);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore passport
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetBalance"]));
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            // Get new balance
            Idmp.GetBalance(0, 0, out balance, out aboveLowBalance, out status, out country);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore passport
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetBalance"]));
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            // IdmpTransferBalance
            context = null;
            Receipt sourceReceipt, transferReceipt;

            sourceReceipt = new Receipt();
            sourceReceipt.ConfirmationDate = DateTime.Now;
            sourceReceipt.ConfirmationId = "confirmation";

            transferReceipt = new Receipt();
            transferReceipt.ConfirmationDate = DateTime.Now;
            transferReceipt.ConfirmationId = "confirmation";

            // Get old balance again before transfer
            Idmp.GetBalance(0, 0, out balance, out aboveLowBalance, out status, out country);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore passport
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetBalance"]));
            LastCall.On(Idmp).OutArguments(null, null, balance, aboveLowBalance, status, country);

            
            // Do the actual transfer
            Idmp.TransferBalance(Guid.Empty, 0, 0, 0, (int)0, context, out sourceReceipt, out transferReceipt);
            LastCall.On(Idmp).ExpectedAnytime();
            LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["TransferBalance"]));
            LastCall.On(Idmp).OutArguments(Guid.Empty, 0, 0, 0, 0, context, sourceReceipt, transferReceipt);

            //TransferPoints
            if (responseTimeTbl["TransferPoints"] != null)
            {
                Idmp.TransferPoints(Guid.Empty, 0, 0, 0, 100, null, out sourceReceipt, out  transferReceipt);
                LastCall.On(Idmp).IgnoresArgument(0);
                LastCall.On(Idmp).IgnoresArgument(1);
                LastCall.On(Idmp).IgnoresArgument(2);
                LastCall.On(Idmp).IgnoresArgument(3);
                LastCall.On(Idmp).IgnoresArgument(5);
                LastCall.On(Idmp).ExpectedAnytime();
                LastCall.On(Idmp).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["TransferPoints"]));
                LastCall.On(Idmp).OutArguments(Guid.Empty, 0, 0, 0, 100, null, sourceReceipt, transferReceipt);
            }
           

            DmpEmu.StopRecording(Idmp);
        }

        //////////////////////////////////////////////////////////////////////////////
        // billing related

        public static void CallBillingEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk,
            DMPTransactionStatus dmpStatus, Exception exPurchase, Exception exRetry, bool retryTimeout)
        {
            CallBillingEmulator(BdkEmu, ref Ibdk, dmpStatus, exPurchase, exRetry, retryTimeout, false);
        }

        public static void CallBillingEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk,
            DMPTransactionStatus dmpStatus, Exception exPurchase, Exception exRetry, bool retryTimeout, bool secondTimeout)
        {
            Ibdk = BdkEmu.StartRecording();

            // purchase starts to check for light weight account
            string pbstrErrorXML = "";
            string pbstrAccountInfoXML = AccountInfoXML;

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(57));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);

            /*string receiptXml = "";
            SCSHelper.Receipt receipt = new SCSHelper.Receipt();
            receipt.ItemReceiptSet = new SCSHelper.ItemReceipt[] { new SCSHelper.ItemReceipt() };
            receipt.ItemReceiptSet[0].ItemInstanceId = "SCSPurchaseItemEmulator";
            receipt.ItemReceiptSet[0].AmountCharged = new SCSHelper.AmountCharged();
            receipt.ItemReceiptSet[0].AmountCharged.ChargeStatus = SCSHelper.chargeStatusType.SUCCESS;
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet = new SCSHelper.taxSet25TypeTax[] { new SCSHelper.taxSet25TypeTax() };
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet[0].Exempt = SCSHelper.Exempt.FALSE;

            System.Xml.Serialization.XmlSerializer s =
                new System.Xml.Serialization.XmlSerializer(typeof(SCSHelper.Receipt));
            System.IO.StringWriter sw = new System.IO.StringWriter();
            s.Serialize(sw, receipt);
            receiptXml = sw.ToString();*/

            string receiptXml = "<Receipt xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\">"
                + "<ItemReceiptSet><ItemReceipt><AmountCharged><Gross>0</Gross><Charge>0</Charge><Locale>en-US</Locale><Currency>USD</Currency><TaxSet /></AmountCharged><ItemInstanceId>G0ECAAAAAAABAADQ</ItemInstanceId></ItemReceipt>"
                + "</ItemReceiptSet></Receipt>";

            Ibdk.PurchaseItem(0, 0, 0, 0, "", "", "", "", out receiptXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            if (dmpStatus == DMPTransactionStatus.Timeout)
                LastCall.On(Ibdk).ClosesConnection();   // close connection, treated as timteout. Pump threads will try re-purchase later
            else if (dmpStatus == DMPTransactionStatus.Success)
            {
                LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(3279));        // the line added
                LastCall.On(Ibdk).OutArguments(null, null, null, null, null, null, null, null, receiptXml);

            }
            else
                LastCall.On(Ibdk).Throws(exPurchase);   // throw an exception

            if (exRetry != null || retryTimeout)
            {
                // retry SCS:PurchaseItem
                Ibdk.PurchaseItem(0, 0, 0, 0, "", "", "", "", out receiptXml);
                LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());

                if (retryTimeout)
                    LastCall.On(Ibdk).ClosesConnection();
                else
                    LastCall.On(Ibdk).Throws(exRetry);

                if (secondTimeout)
                {
                    Ibdk.PurchaseItem(0, 0, 0, 0, "", "", "", "", out receiptXml);
                    LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
                   LastCall.On(Ibdk).ClosesConnection();
                }
            }
            BdkEmu.StopRecording(Ibdk);
        }

        public static void CallBillingStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            Ibdk = BdkEmu.StartRecording();

            // purchase starts to check for light weight account
            string pbstrErrorXML = "";
            string pbstrAccountInfoXML = AccountInfoXML;

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);

            //string receiptXml = "";

            //string receiptXml = "";
            //SCSHelper.Receipt receipt = new SCSHelper.Receipt();
            string receiptXml = "<Receipt xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\">"
                + "<ItemReceiptSet><ItemReceipt><AmountCharged><Gross>0</Gross><Charge>0</Charge><Locale>en-US</Locale><Currency>USD</Currency><TaxSet /></AmountCharged><ItemInstanceId>G0ECAAAAAAABAADQ</ItemInstanceId></ItemReceipt>"
                + "</ItemReceiptSet></Receipt>";
            /*SCSHelper.Receipt receipt = new SCSHelper.Receipt();
            receipt.ItemReceiptSet = new SCSHelper.ItemReceipt[] { new SCSHelper.ItemReceipt() };
            receipt.ItemReceiptSet[0].ItemInstanceId = "SCSPurchaseItemEmulator";
            receipt.ItemReceiptSet[0].AmountCharged = new SCSHelper.AmountCharged();
            receipt.ItemReceiptSet[0].AmountCharged.ChargeStatus = SCSHelper.chargeStatusType.SUCCESS;
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet = new SCSHelper.taxSet25TypeTax[] { new SCSHelper.taxSet25TypeTax() };
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet[0].Exempt = SCSHelper.Exempt.FALSE;

            System.Xml.Serialization.XmlSerializer s = new System.Xml.Serialization.XmlSerializer(typeof(SCSHelper.Receipt));
            System.IO.StringWriter sw = new System.IO.StringWriter();
            s.Serialize(sw, receipt);
            receiptXml = sw.ToString();*/

            Ibdk.PurchaseItem(0, 0, 0, 0, "", "", "", "", out receiptXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).OutArguments(null, null, null, null, null, null, null, null, receiptXml);
            LastCall.On(Ibdk).ExpectedAnytime();

            BdkEmu.StopRecording(Ibdk);
        }

        public static void CallBillingStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, Hashtable responseTimeTbl)
        {
            Ibdk = BdkEmu.StartRecording();


            //GetKey       GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml)
            string pbstrErrorXML = null;
            string pbstrKeyXml = null;// "<KeySet xmlns=\"urn:schemas-microsoft-com:billing-data\"><Key><Type>PUBLIC</Type><Version>07051601</Version><Data>0x300037003000350031003600300031005500940000000602000000a40000525341310004000001000100755d78048229cc02f58d163ff96c6f6dbed3f1add81b3eae60875d6d3678f1b5f7ce300e789316c2a6ae15b4bb916f6f7fa701e4cbd451005b071729ea89af518802534c111884b5a15d7da8bb64e75b257a4116cf9e96c9f4614a78db24afae95041496858d03951fd53a840c1bde7c60058138a128d09a22b8b4ff95b3fbbf</Data></Key></KeySet>";


            Ibdk.GetKey(0x1, 0x1, "", out pbstrErrorXML, out pbstrKeyXml);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            //LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(57));        // the line added
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetKey"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, "", pbstrErrorXML, pbstrKeyXml);

            // purchase starts to check for light weight account
            pbstrErrorXML = "";
            string pbstrAccountInfoXML = AccountInfoXML;


            string pbstrAccountId = "8BcAAAAAAAAAAAAA";
            string pbstrPaymentInstrumentId = "";
            string pbstrDate = "16";
            string bstrRequiredPaperWorkURL = "";

            Ibdk.CreateAccount(0, 0, 0, 0, "", "", "", "", out pbstrErrorXML, out pbstrAccountId, out pbstrPaymentInstrumentId, out pbstrDate, out bstrRequiredPaperWorkURL);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            //LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["CreateAccount"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", "", "", "", pbstrErrorXML, pbstrAccountId, pbstrPaymentInstrumentId, pbstrDate, bstrRequiredPaperWorkURL);
            LastCall.On(Ibdk).ExpectedAnytime();

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(57));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);

            //string receiptXml = "";
            SCSHelper.Receipt receipt = new SCSHelper.Receipt();
            string receiptXml = "<Receipt xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\">"
                + "<ItemReceiptSet><ItemReceipt><AmountCharged><Gross>0</Gross><Charge>0</Charge><Locale>en-US</Locale><Currency>USD</Currency><TaxSet /></AmountCharged><ItemInstanceId>G0ECAAAAAAABAADQ</ItemInstanceId></ItemReceipt>"
                + "</ItemReceiptSet></Receipt>";

            /*SCSHelper.Receipt receipt = new SCSHelper.Receipt();
            receipt.ItemReceiptSet = new SCSHelper.ItemReceipt[] { new SCSHelper.ItemReceipt() };
            receipt.ItemReceiptSet[0].ItemInstanceId = "SCSPurchaseItemEmulator";
            receipt.ItemReceiptSet[0].AmountCharged = new SCSHelper.AmountCharged();
            receipt.ItemReceiptSet[0].AmountCharged.ChargeStatus = SCSHelper.chargeStatusType.SUCCESS;
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet = new SCSHelper.taxSet25TypeTax[] { new SCSHelper.taxSet25TypeTax() };
            receipt.ItemReceiptSet[0].AmountCharged.TaxSet[0].Exempt = SCSHelper.Exempt.FALSE;

            System.Xml.Serialization.XmlSerializer s = new System.Xml.Serialization.XmlSerializer(typeof(SCSHelper.Receipt));
            System.IO.StringWriter sw = new System.IO.StringWriter();
            s.Serialize(sw, receipt);
            string receiptXml = sw.ToString();*/


            Ibdk.PurchaseItem(0, 0, 0, 0, "", "", "", "", out receiptXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["SCSPurchaseItem"]));
            LastCall.On(Ibdk).OutArguments(null, null, null, null, null, null, null, null, receiptXml);
            LastCall.On(Ibdk).ExpectedAnytime();

            bool fComputeOnly = true;
            string pbstrSubscriptionId = "tLMAAAAAAAAAAAEA";
            string pbstrAmountChargedXML;
            // string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><PaymentInstrumentInfo><PaymentInstrumentId>BULKPYMTIDPVAACA</PaymentInstrumentId>";

            string pbstrAddedServiceInstanceSetXML = " <ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        @"<ServiceInstance>
                          <Role>User</Role>
                          <PUIDHigh>590604</PUIDHigh>
                          <PUIDLow>1201741870</PUIDLow>
                          <PMN>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</PMN>
                          <ServiceComponentId>D98F9DB2-4E41-4737-A238-523B27B8FD85</ServiceComponentId>
                          <ServiceInstanceId>Hl8AAAAAAAABAAEA</ServiceInstanceId>
                          <ServiceInstanceFriendlyName>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</ServiceInstanceFriendlyName>
                          <BaseServiceInstanceId>D98F9DB2-4E41-4737-A238-523B27B8FD85</BaseServiceInstanceId>
                          </ServiceInstance>
                          </ServiceInstanceSet>";

            int plAddedServiceInstanceCount;

            Ibdk.PurchaseOfferingEx(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", "", "", 0, "",
               out pbstrErrorXML, out  pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(),
                Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["PurchaseOfferingEx"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", "", "", 0, "", null, pbstrSubscriptionId,
                null, 1, pbstrAddedServiceInstanceSetXML);
            LastCall.On(Ibdk).ExpectedAnytime();


            /*
                        public void PurchaseOffering(
                                int lDelegateIdHigh,
                                int lDelegateIdLow,
                                int lRequesterIdHigh,
                                int lRequesterIdLow,
                                string bstrTrackingGUID,
                                bool fComputeOnly,
                                string bstrSubscriptionName,
                                string bstrAccountId,
                                string bstrBaseSubscriptionId,
                                string bstrOfferingGUID,
                                int lOverrideAmount,
                                string bstrPaymentInstrumentId,
                                string bstrShippingAddressId,
                                string bstrActivationDate,
                                string bstrSubscriptionEndDate,
                                string bstrReferralSetXML,
                                out string pbstrErrorXML,
                                out string pbstrSubscriptionId,
                                out string pbstrAmountChargedXML,
                                out int plAddedServiceInstanceCount,
                                out string pbstrAddedServiceInstanceSetXML)

            */


            Ibdk.PurchaseOffering(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "",
               out pbstrErrorXML, out  pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(),
                Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["PurchaseOfferingEx"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", "", pbstrSubscriptionId,
                null, 1, pbstrAddedServiceInstanceSetXML);
            LastCall.On(Ibdk).ExpectedAnytime();


            //ProvisionServices
            string bstrServiceInstanceSetXML = null;
            Ibdk.ProvisionServices(0, 0, 0, 0, bstrServiceInstanceSetXML, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["ProvisionServices"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null);
            LastCall.On(Ibdk).ExpectedAnytime();

            string instanceId = pbstrSubscriptionId;
            string pbstrSubscriptionInfoSetXML = CreateSubscriptionXml(instanceId, "ENABLED");
            int plSubscriptionInfoCount = 1;

            Ibdk.GetSubscriptions(0, 0, 0, 0, "", out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetSubscriptions"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plSubscriptionInfoCount, pbstrSubscriptionInfoSetXML);

            OffsetOrderEmulator(ref Ibdk, null, (int)responseTimeTbl["OffsetOrder"]);
            CalculateTaxEmulator(ref Ibdk, null, (int)responseTimeTbl["CalculateTax"]);
            SubmitOrderEmulator(ref Ibdk, null, (int)responseTimeTbl["SubmitOrder"]);
           
            BdkEmu.StopRecording(Ibdk);
        }


        public static void CallUacsBillingStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, Hashtable responseTimeTbl)
        {
            CallUacsBillingStressEmulator(BdkEmu, ref Ibdk, responseTimeTbl, false);
        }

        public static void CallUacsBillingStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, Hashtable responseTimeTbl, bool silverUser)
        {
            Ibdk = BdkEmu.StartRecording();

            string errorXml = "";

            //GetKey       GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml)
            string pbstrGetKeyErrorXML = "";
            string pbstrKeyXml = "<KeySet xmlns=\"urn:schemas-microsoft-com:billing-data\"><Key><Type>PUBLIC</Type><Version>07051601</Version><Data>0x300037003000350031003600300031005500940000000602000000a40000525341310004000001000100755d78048229cc02f58d163ff96c6f6dbed3f1add81b3eae60875d6d3678f1b5f7ce300e789316c2a6ae15b4bb916f6f7fa701e4cbd451005b071729ea89af518802534c111884b5a15d7da8bb64e75b257a4116cf9e96c9f4614a78db24afae95041496858d03951fd53a840c1bde7c60058138a128d09a22b8b4ff95b3fbbf</Data></Key></KeySet>";
            Ibdk.GetKey(0x1, 0x1, "", out pbstrGetKeyErrorXML, out pbstrKeyXml);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On( Ibdk ).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetKey"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, "",  "", pbstrKeyXml);

            //GetAccountInfo
            string pbstrErrorXML = "";
            string pbstrAccountInfoXML = AccountInfoXML;
            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetAccountInfo"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);

            /*CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow,
             * string bstrPPMemberName,
             * string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL)*/
            //CreateAccount
            string pbstrAccountId = "8BcAAAAAAAAAAAAA";
            string pbstrPaymentInstrumentId = "";
            string pbstrDate = "16";
            string bstrRequiredPaperWorkURL = "";

            Ibdk.CreateAccount(0, 0, 0, 0, "", "", "", "", out pbstrErrorXML, out pbstrAccountId, out pbstrPaymentInstrumentId, out pbstrDate, out bstrRequiredPaperWorkURL);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["CreateAccount"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", "", "", "", pbstrErrorXML, pbstrAccountId, pbstrPaymentInstrumentId, pbstrDate, bstrRequiredPaperWorkURL);
            LastCall.On(Ibdk).ExpectedAnytime();


            //GetSubscriptions
            string instanceId = "PVsAAAAAAAABAAEA";
            string pbstrSubscriptionInfoSetXML = CreateSubscriptionXml(instanceId, "ENABLED");
            int plSubscriptionInfoCount = 1;
            if (silverUser)
            {
                pbstrSubscriptionInfoSetXML = "<SubscriptionInfoSet xmlns:obj=\"urn:olsextensions\" xmlns=\"urn:schemas-microsoft-com:billing-data\"></SubscriptionInfoSet>";
                plSubscriptionInfoCount = 0;
            }

            Ibdk.GetSubscriptions(0, 0, 0, 0, "", out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetSubscriptions"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plSubscriptionInfoCount, pbstrSubscriptionInfoSetXML);

            //GetPaymentInstruments
            int plPaymentInstrumentInfoCount = 1;
            string bstrObjectId = null;
            string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><PaymentInstrumentInfo><PaymentInstrumentId>BULKPYMTIDPVAACA</PaymentInstrumentId>";

            pi += "<PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName>";

            pi += "<CreditCardInfo><AccountHolderName>Bob</AccountHolderName><AccountNumberLastFour>7714</AccountNumberLastFour><CardType>VISA</CardType>";

            pi += "<ExpirationDate>102016</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>5555555</PhoneNumber>";

            pi += "<PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><AddressId>PVsAAAAAAAACAACg</AddressId>";

            pi += "<FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1><Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City>";

            pi += "<District></District><State>WA</State><CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></PaymentInstrumentInfo></PaymentInstrumentInfoSet>";


            Ibdk.GetPaymentInstruments(0, 0, 0, 0, bstrObjectId, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetPaymentInstruments"]));
            //LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, 0, bstrObjectId, pbstrErrorXML, plPaymentInstrumentInfoCount, pi);
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plPaymentInstrumentInfoCount, pi);

            //GetPaymentInstrumentsEx
            bool fReturnRemoved = false;

            Ibdk.GetPaymentInstrumentsEx(0, 0, 0, 0, bstrObjectId, fReturnRemoved, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetPaymentInstruments"]));
            //LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, 0, bstrObjectId, pbstrErrorXML, plPaymentInstrumentInfoCount, pi);
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, false, null, plPaymentInstrumentInfoCount, pi);

            //ProvisionServices
            string bstrServiceInstanceSetXML = null;
            Ibdk.ProvisionServices(0, 0, 0, 0, bstrServiceInstanceSetXML, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["ProvisionServices"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null);

            //DeprovisionServices
            bstrServiceInstanceSetXML = null;
            Ibdk.DeprovisionServices(0, 0, 0, 0, bstrServiceInstanceSetXML, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["ProvisionServices"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null);

            //AddRoleAssignment
            string bstrRoleAssignmentXML = null;
            Ibdk.AddRoleAssignment(0, 0, 0, 0, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["AddRoleAssignment"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, null);

            //AddRoleAssignment
            bstrRoleAssignmentXML = null;
            Ibdk.AddRoleAssignment(0, 0, 0, 0, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["AddRoleAssignment"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, null);

            // RemoveRoleAssignment
            Ibdk.RemoveRoleAssignment(0, 0, 0, 0, "", "", out errorXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["RemoveRoleAssignment"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", "", "");

            // GetPermitsForObjectId
            int permitCount = 0;
            string permitSetXml = "<PermitSet xmlns=\"urn:schemas-microsoft-com:billing-data\"></PermitSet>";

            Ibdk.GetPermitsForObjectId(0, 0, 0, 0, "", false, out errorXml, out permitCount, out permitSetXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetPermitsForObjectId"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", false, errorXml, permitCount, permitSetXml);

            Ibdk.GetPermitsForObjectId(0, 0, 0, 0, "", false, out errorXml, out permitCount, out permitSetXml);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetPermitsForObjectId"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", false, errorXml, permitCount, permitSetXml);


            //AddPaymentInstrument
            string bstrTrackingGUID = null;
            string bstrAccountId = "8BcAAAAAAAAAAAAA";
            string bstrPaymentInstrumentInfoXML = null;
            string pbstrRequiredPaperWorkURL = "";

            Ibdk.AddPaymentInstrument(0, 0, 0, 0, bstrTrackingGUID, bstrAccountId, bstrPaymentInstrumentInfoXML, out pbstrErrorXML, out pbstrPaymentInstrumentId, out pbstrRequiredPaperWorkURL);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["AddPaymentInstrument"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, bstrTrackingGUID, bstrAccountId, bstrPaymentInstrumentInfoXML, null, pbstrPaymentInstrumentId, pbstrRequiredPaperWorkURL);

            //RemovePaymentInstrument
            Ibdk.RemovePaymentInstrument(0, 0, 0, 0, pbstrPaymentInstrumentId, out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["RemovePaymentInstrument"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, pbstrPaymentInstrumentId, null);

            //PurchaseOffering
            bool fComputeOnly = true;
            string pbstrSubscriptionId = "tLMAAAAAAAAAAAEA";
            string pbstrAmountChargedXML;


            string pbstrAddedServiceInstanceSetXML = " <ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        @"<ServiceInstance>
                          <Role>User</Role>
                          <PUIDHigh>590604</PUIDHigh>
                          <PUIDLow>1201741870</PUIDLow>
                          <PMN>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</PMN>
                          <ServiceComponentId>bbbe8103-bb3c-40cd-96bd-a37a7ca73314</ServiceComponentId>
                          <ServiceInstanceId>Hl8AAAAAAAABAAEA</ServiceInstanceId>
                          <ServiceInstanceFriendlyName>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</ServiceInstanceFriendlyName>
                          <BaseServiceInstanceId>D98F9DB2-4E41-4737-A238-523B27B8FD85</BaseServiceInstanceId>
                          </ServiceInstance>
                          </ServiceInstanceSet>";

            int plAddedServiceInstanceCount;

            Ibdk.PurchaseOffering(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "",
               out pbstrErrorXML, out  pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(),
                                                            Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["PurchaseOffering"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", null, pbstrSubscriptionId, null, 1, pbstrAddedServiceInstanceSetXML);
            LastCall.On(Ibdk).ExpectedAnytime();

            //PurchaseOfferingEx
            pbstrAddedServiceInstanceSetXML = " <ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        @"<ServiceInstance>
                          <Role>User</Role>
                          <PUIDHigh>590604</PUIDHigh>
                          <PUIDLow>1201741870</PUIDLow>
                          <PMN>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</PMN>
                          <ServiceComponentId>b4ddce9d-dd08-4273-8919-705e5be296fe</ServiceComponentId>
                          <ServiceInstanceId>Hl8AAAAAAAABAAEA</ServiceInstanceId>
                          <ServiceInstanceFriendlyName>xbltest-30abe056-e9f9-4942-a62e-3756b9d9d4e8@example.com</ServiceInstanceFriendlyName>
                          <BaseServiceInstanceId>D98F9DB2-4E41-4737-A238-523B27B8FD85</BaseServiceInstanceId>
                          </ServiceInstance>
                          </ServiceInstanceSet>";

            Ibdk.PurchaseOfferingEx(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", "", "", 0, "",
               out pbstrErrorXML, out  pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(),
                Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["PurchaseOfferingEx"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", fComputeOnly, "", "", "", "", 0, "", "", "", "", "", "", "", 0, "", null, pbstrSubscriptionId,
                null, 1, pbstrAddedServiceInstanceSetXML);
            LastCall.On(Ibdk).ExpectedAnytime();

            //UpdateAccountInfo
            //UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL)
            Ibdk.UpdateAccountInfo(0, 0, 0, 0, bstrAccountId, "", out pbstrErrorXML, out  pbstrRequiredPaperWorkURL);
           LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdateAccountInfo"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, bstrAccountId, "", null, null);
            LastCall.On(Ibdk).ExpectedAnytime();

            //TransferBalance
            Ibdk.TransferBalance(0, 0, "", "", "", out pbstrErrorXML, out  pbstrAmountChargedXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdateAccountInfo"]));
            LastCall.On(Ibdk).OutArguments(0, 0, "", "", "", null, null);
            LastCall.On(Ibdk).ExpectedAnytime();

            //UpdatePaymentInstrumentInfo
            Ibdk.UpdatePaymentInstrumentInfo(0, 0, 0, 0, "", "", out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdatePaymentInstrumentInfo"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", "", null);
            LastCall.On(Ibdk).ExpectedAnytime();

            //GetAccountIdFromAdminPuid
            bool fFullData = true;
            int pfMoreRows = 0;
           int plAccountInfoCount = 1;
            string pbstrAccountInfoSetXML = null;

            Ibdk.GetAccountIdFromAdminPUID(0, 0, 0, 0, fFullData, 0, out pbstrErrorXML, out pfMoreRows, out plAccountInfoCount, out pbstrAccountInfoSetXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetAccountIdFromAdminPUID"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, fFullData, 0, null, pfMoreRows, plAccountInfoCount, pbstrAccountInfoSetXML);
            LastCall.On(Ibdk).ExpectedAnytime();

            //SwitchPaymentInstruments
            Ibdk.SwitchPaymentInstruments(0, 0, 0, 0, "", "", "", out pbstrErrorXML, out pbstrAmountChargedXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["SwitchPaymentInstruments"]));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, "", "", "", null, null);
            LastCall.On(Ibdk).ExpectedAnytime();

            //UpdateSubscriptionInfo
            Ibdk.UpdateSubscriptionInfo(0, 0, 0, 0, "", "", "", "", out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdateSubscriptionInfo"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, null, null, null);

            //SettleBalance
            Ibdk.SettleBalance(0, 0, "", "", out pbstrErrorXML, out pbstrAmountChargedXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["SettleBalance"]));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, null, null, null, null);


            BdkEmu.StopRecording(Ibdk);
        }

        public static void GetTwoCreditCardPaymentInstruments(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\">";
            //first card card ,expired
            pi += "<PaymentInstrumentInfo><PaymentInstrumentId>QOcAAAAAAAABAACA</PaymentInstrumentId>";

            pi += "<PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName>";

            pi += "<CreditCardInfo><AccountHolderName>Bob</AccountHolderName><AccountNumberLastFour>7714</AccountNumberLastFour><CardType>VISA</CardType>";

            pi += "<ExpirationDate>082006</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>5555555</PhoneNumber>";

            pi += "<PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><AddressId>PVsAAAAAAAACAACg</AddressId>";

            pi += "<FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1><Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City>";

            pi += "<District></District><State>WA</State><CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></PaymentInstrumentInfo>";
            //second card card
            pi += "<PaymentInstrumentInfo><PaymentInstrumentId>BULKPYMTIDPVAACA</PaymentInstrumentId>";

            pi += "<PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName>";

            pi += "<CreditCardInfo><AccountHolderName>Bob</AccountHolderName><AccountNumberLastFour>7714</AccountNumberLastFour><CardType>VISA</CardType>";

            pi += "<ExpirationDate>082030</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>5555555</PhoneNumber>";

            pi += "<PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><AddressId>PVsAAAAAAAACAACg</AddressId>";

            pi += "<FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1><Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City>";

            pi += "<District></District><State>WA</State><CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></PaymentInstrumentInfo>";

            pi += "</PaymentInstrumentInfoSet>";

            Ibdk = BdkEmu.StartRecording();

            int PaymentInstrumentInfoCount = 2;
            string pbstrErrorXML = "<ErrorPackage><ErrorHResult>0x0</ErrorHResult><ErrorMessage /><Retryable>false</Retryable><ErrorDebugInfo><DebugInfo>0x0</DebugInfo><DebugInfo><![CDATA[   ]]></DebugInfo><ComputerName>VM1BOX</ComputerName></ErrorDebugInfo></ErrorPackage>";

            Ibdk.GetPaymentInstrumentsEx(0, 0, 0, 0, null, true, out pbstrErrorXML, out PaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).IgnoresArgument(5);


            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, true, pbstrErrorXML, PaymentInstrumentInfoCount, pi);

            BdkEmu.StopRecording(Ibdk);

        }


        public static void GetPayPalPaymentInstruments(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\">"
                + "<PaymentInstrumentInfo><PaymentInstrumentId>2B8AAAAAAAABAACA</PaymentInstrumentId><PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>PAYPALPAYIN</PaymentInstrumentType><FriendlyName>PayPal test</FriendlyName><PayPalPayinInfo><BillingAgreementDetails><PayerEmail>tst001@xbltest.com</PayerEmail><BillingAgreementId>B-241921fe75e3f5afd</BillingAgreementId><FirstName>24b0cc5-0a69-4d0a-b</FirstName><LastName>24b0cc5-0a69-4d0a-b</LastName><MiddleName>24b0cc5-0a69-4d0a-b</MiddleName><PayerBusiness></PayerBusiness><PayerCountry></PayerCountry><PayerId></PayerId><BillingAgreementDescription>PaypalPayinDescription</BillingAgreementDescription></BillingAgreementDetails></PayPalPayinInfo></PaymentInstrumentInfo></PaymentInstrumentInfoSet>";

            Ibdk = BdkEmu.StartRecording();

            int PaymentInstrumentInfoCount = 1;
            string pbstrErrorXML = "<ErrorPackage><ErrorHResult>0x0</ErrorHResult><ErrorMessage /><Retryable>false</Retryable><ErrorDebugInfo><DebugInfo>0x0</DebugInfo><DebugInfo><![CDATA[   ]]></DebugInfo><ComputerName>VM1BOX</ComputerName></ErrorDebugInfo></ErrorPackage>";

            Ibdk.GetPaymentInstrumentsEx(0, 0, 0, 0, null, true, out pbstrErrorXML, out PaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).IgnoresArgument(5);


            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, true, pbstrErrorXML, PaymentInstrumentInfoCount, pi);

            BdkEmu.StopRecording(Ibdk);

        }

        public static void CallAddPIStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><PaymentInstrumentInfo><PaymentInstrumentId>BULKPYMTIDPVAACA</PaymentInstrumentId>";

            pi += "<PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName>";

            pi += "<CreditCardInfo><AccountHolderName>Bob</AccountHolderName><AccountNumberLastFour>7714</AccountNumberLastFour><CardType>VISA</CardType>";

            pi += "<ExpirationDate>102016</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>5555555</PhoneNumber>";

            pi += "<PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><AddressId>PVsAAAAAAAACAACg</AddressId>";

            pi += "<FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1><Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City>";

            pi += "<District></District><State>WA</State><CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></PaymentInstrumentInfo></PaymentInstrumentInfoSet>";

            Ibdk = BdkEmu.StartRecording();

            int PaymentInstrumentInfoCount = 1;
            string pbstrErrorXML = "";

            Ibdk.GetPaymentInstruments(0, 0, 0, 0, "", out pbstrErrorXML, out PaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);

            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, PaymentInstrumentInfoCount, pi);

            BdkEmu.StopRecording(Ibdk);

        }

        public static string CreateSubscriptionXml(string serviceInstanceId, string subscriptionStatus)
        {
            return CreateSubscriptionXml(serviceInstanceId, subscriptionStatus, new Guid("0AF0A491-66B1-47A6-A15B-411AC45A8CD3"));
        }

        public static string CreateSubscriptionXml(string serviceInstanceId, string subscriptionStatus, Guid offeringGUID)
        {
            DateTime now = DateTime.Now;
            return String.Format("<?xml version=\"1.0\" encoding=\"UTF-16\"?>"
            + "<SubscriptionInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\">"
             + @"<SubscriptionInfo>
            <SubscriptionId>4OMGAAAAAAAAAAEA</SubscriptionId>
            <AnniversaryDate>{2}</AnniversaryDate>
            <OfferingGUID>{5}</OfferingGUID>
            <AllowNonCSRCancel>false</AllowNonCSRCancel>
            <OngoingSubscription>true</OngoingSubscription>
            <SubscriptionCycleStartDate>{0}</SubscriptionCycleStartDate>
            <ResourceBillingMethod>None</ResourceBillingMethod>
            <ProductGuid>E6734CC2-0324-419C-B01D-1CD06EA4DDB8</ProductGuid>
            <ProductName>Xbox 360 LIVE Gold Membership</ProductName>
            <ProductDescription>Xbox 360 LIVE Gold Membership</ProductDescription>
            <ProductClassGuid>8F79F122-1147-44D6-8065-740583606C91</ProductClassGuid>
            <SupportEnabled>0</SupportEnabled>
            <SubscriptionDescription>Xbox LIVE Monthly Gold Membership</SubscriptionDescription>
            <SubscriptionPriceDescription>Xbox LIVE Monthly Gold Membership</SubscriptionPriceDescription>
            <InternalSubscriptionDescription>XBX-11467 Xbox360 Monthly Gold Xbox Live Basic Subscription (7.99) US</InternalSubscriptionDescription>
            <TimeBasedConversionCreditsDays>0</TimeBasedConversionCreditsDays>
            <FriendlyName>Xbox LIVE Monthly Gold Membership</FriendlyName>
            <ShippingAddressId>4OMGAAAAAAABAACg</ShippingAddressId>
            <SubscriptionStatusInfo>
             <SubscriptionStatus>{4}</SubscriptionStatus>
            <ViolationSet></ViolationSet>
            </SubscriptionStatusInfo>
            <PurchaseDate>{0}</PurchaseDate>
            <ActivationDate>{0}</ActivationDate>
            <EndDate>{1}</EndDate>
            <DelayedCancel>FALSE</DelayedCancel>
            <BillingPeriod>201010</BillingPeriod>
            <RenewalGracePeriod>0</RenewalGracePeriod>
            <RenewOfferingId></RenewOfferingId>
            <PaymentInstrumentId>4OMGAAAAAAACAACA</PaymentInstrumentId>
            <PaymentInstrumentSet>
              <PaymentInstrumentId>2</PaymentInstrumentId>
            </PaymentInstrumentSet>
            <HasTermCommit>FALSE</HasTermCommit>
            <TermCommitStartDate>{0}</TermCommitStartDate>
            <TermCommitDescription>Xbox Live Monthly Gold Membership</TermCommitDescription>
            <TermCommitPriceDescription>Welcome to the future of gaming and online entertainment. As a new Xbox Live Gold member, you will enjoy access to demos, trailers, downloads, tournaments, friends, and your gamertag, your unique digital identity. For only $7.99 plus applicable taxes per month, your monthly Xbox Live Gold Membership gives you all the rewards, privileges, and possibilities that come with being a Gold member. Your membership will automatically renew to a monthly membership at the then current price, unless you change your renewal or cancel before your membership ends. Pricing details can be viewed in the Account Management area of your gamer profile. For information about changing or canceling your membership and your membership refund policy, go to www.xbox.com/live/accounts.</TermCommitPriceDescription>
            <TermCommitCyclesRemaining>0</TermCommitCyclesRemaining>
            <ServiceInstanceSet>
              <ServiceInstance>
                <ServiceInstanceId>{3}</ServiceInstanceId>
                <ServiceComponentId>B4DDCE9D-DD08-4273-8919-705E5BE296FE</ServiceComponentId>
                <ServiceComponentName>Xbox Live Gold Service</ServiceComponentName>
                <ServiceComponentDescription></ServiceComponentDescription>
                <UserCount>1</UserCount>
                <ProvisioningStatus>PROVISIONED</ProvisioningStatus>
                <ProvisioningErrorCode>0</ProvisioningErrorCode>
                <Evict>FALSE</Evict>
                <IsPMNBased>FALSE</IsPMNBased>
              </ServiceInstance>
            </ServiceInstanceSet>
            <SubscriptionCoBrand>MSFT</SubscriptionCoBrand>
            <Prepaid>FALSE</Prepaid>
            <TokenInfoSet></TokenInfoSet>
            <Currency>USD</Currency>
            <PrepaidRenewal>FALSE</PrepaidRenewal>
            <CurrentSubscriptionAgreementId></CurrentSubscriptionAgreementId>
            <CurrentSubscriptionAgreementVersion></CurrentSubscriptionAgreementVersion>
            <PrivacyPolicyID></PrivacyPolicyID>
            <PrivacyPolicyVersion></PrivacyPolicyVersion>
            <SignatureInfoSet></SignatureInfoSet>
            <HasResources>NO</HasResources>
            <SupportOfferingDescription>Xbox LIVE Monthly Gold Membership</SupportOfferingDescription>
            <SupportOfferingPriceDescription>Xbox LIVE Monthly Gold Membership</SupportOfferingPriceDescription>
            <FreeTrial>false</FreeTrial>
            <IsReinstatable>false</IsReinstatable>
          </SubscriptionInfo>
        </SubscriptionInfoSet>",   now.ToString("yyyy-MM-dd"), now.AddYears(1).ToString("yyyy-MM-dd"), now.Day.ToString(),
                                 serviceInstanceId, subscriptionStatus, offeringGUID.ToString("D").ToUpper());
        }


        public static string CreateMonthlyCCSubscriptionXml()
        {

            return "<?xml version=\"1.0\" encoding=\"utf-16\"?><SubscriptionInfoSet xmlns:obj=\"urn:olsextensions\" xmlns=\"urn:schemas-microsoft-com:billing-data\"><SubscriptionInfo><SubscriptionId>4OMGAAAAAAAAAAEA</SubscriptionId><AnniversaryDate>6</AnniversaryDate><OfferingGUID>0AF0A491-66B1-47A6-A15B-411AC45A8CD3</OfferingGUID><AllowNonCSRCancel>false</AllowNonCSRCancel><OngoingSubscription>true</OngoingSubscription><SubscriptionCycleStartDate>2010-09-06</SubscriptionCycleStartDate><ResourceBillingMethod>None</ResourceBillingMethod><ProductGuid>E6734CC2-0324-419C-B01D-1CD06EA4DDB8</ProductGuid><ProductName>Xbox 360 LIVE Gold Membership</ProductName><ProductDescription>Xbox 360 LIVE Gold Membership</ProductDescription><ProductClassGuid>8F79F122-1147-44D6-8065-740583606C91</ProductClassGuid><SupportEnabled>0</SupportEnabled><SubscriptionDescription>Xbox LIVE Monthly Gold Membership</SubscriptionDescription><SubscriptionPriceDescription>Xbox LIVE Monthly Gold Membership</SubscriptionPriceDescription><InternalSubscriptionDescription>XBX-11467 Xbox360 Monthly Gold Xbox Live Basic Subscription (7.99) US</InternalSubscriptionDescription><TimeBasedConversionCreditsDays>0</TimeBasedConversionCreditsDays><FriendlyName>Xbox LIVE Monthly Gold Membership</FriendlyName><ShippingAddressId>4OMGAAAAAAABAACg</ShippingAddressId><SubscriptionStatusInfo><SubscriptionStatus>ENABLED</SubscriptionStatus><ViolationSet></ViolationSet></SubscriptionStatusInfo><PurchaseDate>2010-09-06</PurchaseDate><ActivationDate>2010-09-06</ActivationDate><OfferSKU>XMR-00001</OfferSKU><EndDate>9999-12-06</EndDate><DelayedCancel>FALSE</DelayedCancel><BillingPeriod>201010</BillingPeriod><RenewalGracePeriod>0</RenewalGracePeriod><RenewOfferingId></RenewOfferingId><PaymentInstrumentId>4OMGAAAAAAACAACA</PaymentInstrumentId><PaymentInstrumentSet><PaymentInstrumentId>2</PaymentInstrumentId></PaymentInstrumentSet><HasTermCommit>FALSE</HasTermCommit><TermCommitStartDate>2010-09-06</TermCommitStartDate><TermCommitDescription>Xbox Live Monthly Gold Membership</TermCommitDescription><TermCommitPriceDescription>Welcome to the future of gaming and online entertainment. As a new Xbox Live Gold member, you will enjoy access to demos, trailers, downloads, tournaments, friends, and your gamertag, your unique digital identity. For only $7.99 plus applicable taxes per month, your monthly Xbox Live Gold Membership gives you all the rewards, privileges, and possibilities that come with being a Gold member. Your membership will automatically renew to a monthly membership at the then current price, unless you change your renewal or cancel before your membership ends. Pricing details can be viewed in the Account Management area of your gamer profile. For information about changing or canceling your membership and your membership refund policy, go to www.xbox.com/live/accounts.</TermCommitPriceDescription><TermCommitCyclesRemaining>0</TermCommitCyclesRemaining><ServiceInstanceSet><ServiceInstance><ServiceInstanceId>4OMGAAAAAAABAAEA</ServiceInstanceId><ServiceComponentId>B4DDCE9D-DD08-4273-8919-705E5BE296FE</ServiceComponentId><ServiceComponentName>Xbox Live Gold Service</ServiceComponentName><ServiceComponentDescription></ServiceComponentDescription><UserCount>1</UserCount><ProvisioningStatus>PROVISIONED</ProvisioningStatus><ProvisioningErrorCode>0</ProvisioningErrorCode><Evict>FALSE</Evict><IsPMNBased>FALSE</IsPMNBased></ServiceInstance></ServiceInstanceSet><SubscriptionCoBrand>MSFT</SubscriptionCoBrand><Prepaid>FALSE</Prepaid><TokenInfoSet></TokenInfoSet><Currency>USD</Currency><PrepaidRenewal>FALSE</PrepaidRenewal><CurrentSubscriptionAgreementId></CurrentSubscriptionAgreementId><CurrentSubscriptionAgreementVersion></CurrentSubscriptionAgreementVersion><PrivacyPolicyID></PrivacyPolicyID><PrivacyPolicyVersion></PrivacyPolicyVersion><SignatureInfoSet></SignatureInfoSet><HasResources>NO</HasResources><SupportOfferingDescription>Xbox LIVE Monthly Gold Membership</SupportOfferingDescription><SupportOfferingPriceDescription>Xbox LIVE Monthly Gold Membership</SupportOfferingPriceDescription><FreeTrial>false</FreeTrial><IsReinstatable>false</IsReinstatable></SubscriptionInfo></SubscriptionInfoSet>";
      
        }

        public static void GetSubscriptionsEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, string status)
        {
            GetSubscriptionsEmulator(BdkEmu, ref Ibdk, status, null);
        }


        public static void GetSubscriptionsMonthlyEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {

            Ibdk = BdkEmu.StartRecording();

            string pbstrErrorXML = "";
            string pbstrSubscriptionInfoSetXML = CreateMonthlyCCSubscriptionXml();
            int plSubscriptionInfoCount = 1;

            Ibdk.GetSubscriptions(0, 0, 0, 0, "", out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(80));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plSubscriptionInfoCount, pbstrSubscriptionInfoSetXML);


            string pbstrAccountInfoXML = AccountInfoXML;

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);


            //TransferBalance
            string pbstrAmountChargedXML;
            Ibdk.TransferBalance(0, 0, "", "", "", out pbstrErrorXML, out  pbstrAmountChargedXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(50));
            LastCall.On(Ibdk).OutArguments(0, 0, "", "", "", null, null);
            LastCall.On(Ibdk).ExpectedAnytime();

            //UpdateSubscriptionInfo
            Ibdk.UpdateSubscriptionInfo(0, 0, 0, 0, "", "", "", "", out pbstrErrorXML);
            LastCall.On(Ibdk).Arguments(Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any(), Is.Any());
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(100));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, null, null, null);
            BdkEmu.StopRecording(Ibdk);
        }


        public static void GetNullSubscriptionsEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            Ibdk = BdkEmu.StartRecording();

            string pbstrErrorXML = "";
            string pbstrSubscriptionInfoSetXML ="<SubscriptionInfoSet xmlns:obj=\"urn:olsextensions\" xmlns=\"urn:schemas-microsoft-com:billing-data\"></SubscriptionInfoSet>";
            int plSubscriptionInfoCount = 0;
            string pbstrAccountInfoXML = AccountInfoXML;

            Ibdk.GetSubscriptions(0, 0, 0, 0, "", out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(80));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plSubscriptionInfoCount, pbstrSubscriptionInfoSetXML);



            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(57));        // the line added
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);
            BdkEmu.StopRecording(Ibdk);
        }

        //   status - "PENDING", "ENABLED", "SUSPENDED", "EXPIRED", "CANCELED"
        public static void GetSubscriptionsEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, string status, string instanceIdEx)
        {
            Ibdk = BdkEmu.StartRecording();

            string instanceId = "PVsAAAAAAAABAAEA";
            if (instanceIdEx != null)
                instanceId = instanceIdEx;
            string pbstrErrorXML = "";
            string pbstrSubscriptionInfoSetXML = CreateSubscriptionXml(instanceId, status);
            int plSubscriptionInfoCount = 1;

            Ibdk.GetSubscriptions(0, 0, 0, 0, "", out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(80));
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, plSubscriptionInfoCount, pbstrSubscriptionInfoSetXML);

            BdkEmu.StopRecording(Ibdk);
        }

        private static string AccountInfoXML
        {
            get
            {
                string pbstrAccountInfoXML = "<AccountInfo xmlns=\"urn:schemas-microsoft-com:billing-data\"><AccountId>PVsAAAAAAAAAAAAA</AccountId><AccountStatusInfo>";
                pbstrAccountInfoXML += "<AccountStatus>ACTIVE</AccountStatus><ViolationSet></ViolationSet></AccountStatusInfo><AccountCreationDate>2005-10-10T21:41:30</AccountCreationDate>";
                pbstrAccountInfoXML += "<AccountHistoryDate>2005-10-10T21:41:30</AccountHistoryDate><AccountSource>SPS 2.6</AccountSource><LegacyAccountId></LegacyAccountId>";
                pbstrAccountInfoXML += "<AnniversaryDate>10</AnniversaryDate><CustomerType>PERSONAL</CustomerType><DefaultAddressId>PVsAAAAAAAABAACg</DefaultAddressId>";
                pbstrAccountInfoXML += "<FriendlyName>XBOX Live</FriendlyName><CorporateIdentity>1010</CorporateIdentity><CorporateVatId>0</CorporateVatId>";
                pbstrAccountInfoXML += "<CorporateLegalEntity>Microsoft Corporation</CorporateLegalEntity><CorporateAddress><CorporateStreet1>One Microsoft Way</CorporateStreet1>";
                pbstrAccountInfoXML += "<CorporateStreet2></CorporateStreet2><CorporateStreet3></CorporateStreet3><CorporateCity>Redmond</CorporateCity><CorporateDistrict>";
                pbstrAccountInfoXML += "</CorporateDistrict><CorporateState>WA</CorporateState><CorporateCountryCode>US</CorporateCountryCode>";
                pbstrAccountInfoXML += "<CorporatePostalCode>98052</CorporatePostalCode></CorporateAddress><FirstName>Jacob</FirstName><FirstNamePronunciation>";
                pbstrAccountInfoXML += "</FirstNamePronunciation><LastName>Repp</LastName><LastNamePronunciation></LastNamePronunciation><Email>xboxstress@winisp.net</Email>";
                pbstrAccountInfoXML += "<CompanyName></CompanyName><CompanyNamePronunciation></CompanyNamePronunciation><Locale>en-US</Locale><HCI>NO</HCI><HCIValid>NO</HCIValid>";
                pbstrAccountInfoXML += "<Currency>USD</Currency><CountryCode>US</CountryCode><PhoneSet><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix>";
                pbstrAccountInfoXML += "<PhoneNumber>5555555</PhoneNumber><PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone></PhoneSet><AddressInfoSet>";
                pbstrAccountInfoXML += "<AddressInfo><AddressId>PVsAAAAAAAABAACg</AddressId><FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1>";
                pbstrAccountInfoXML += "<Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City><District></District><State>WA</State>";
                pbstrAccountInfoXML += "<CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></AddressInfoSet><TaxExemptionInfoSet></TaxExemptionInfoSet>";
                pbstrAccountInfoXML += "<AccountAttributeInfoSet><AttributeInfo><AttributeName>NAME</AttributeName><AttributeUse>REQUIRED</AttributeUse>";
                pbstrAccountInfoXML += "<AttributeExists>True</AttributeExists></AttributeInfo><AttributeInfo><AttributeName>ADDRESS</AttributeName>";
                pbstrAccountInfoXML += "<AttributeUse>REQUIRED</AttributeUse><AttributeExists>True</AttributeExists></AttributeInfo><AttributeInfo>";
                pbstrAccountInfoXML += "<AttributeName>PHONE_NUMBER</AttributeName><AttributeUse>REQUIRED</AttributeUse><AttributeExists>True</AttributeExists></AttributeInfo>";
                pbstrAccountInfoXML += "</AccountAttributeInfoSet><PendingTransactionExists>False</PendingTransactionExists></AccountInfo>";
                return pbstrAccountInfoXML;
            }
        }

        public static void GetAccountInfoEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, bool emptyAddress, bool emptyPhone)
        {
            GetAccountInfoEmulator(BdkEmu, ref Ibdk, DMPTransactionStatus.Success, null, emptyAddress, emptyPhone);
        }

        public static void GetAccountInfoEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, DMPTransactionStatus status, Exception ex)
        {
            GetAccountInfoEmulator(BdkEmu, ref Ibdk, status, ex, false, false);
        }

        public static void GetAccountInfoEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk, DMPTransactionStatus status, Exception ex, bool emptyAddress, bool emptyPhone)
        {
            Ibdk = BdkEmu.StartRecording();

            string pbstrErrorXML = "";

            string pbstrAccountInfoXML = "<AccountInfo xmlns=\"urn:schemas-microsoft-com:billing-data\"><AccountId>PVsAAAAAAAAAAAAA</AccountId><AccountStatusInfo>";
            pbstrAccountInfoXML += "<AccountStatus>ACTIVE</AccountStatus><ViolationSet></ViolationSet></AccountStatusInfo><AccountCreationDate>2005-10-10T21:41:30</AccountCreationDate>";
            pbstrAccountInfoXML += "<AccountHistoryDate>2005-10-10T21:41:30</AccountHistoryDate><AccountSource>SPS 2.6</AccountSource><LegacyAccountId></LegacyAccountId>";
            pbstrAccountInfoXML += "<AnniversaryDate>10</AnniversaryDate><CustomerType>PERSONAL</CustomerType><DefaultAddressId>PVsAAAAAAAABAACg</DefaultAddressId>";
            pbstrAccountInfoXML += "<FriendlyName>XBOX Live</FriendlyName><CorporateIdentity>1010</CorporateIdentity><CorporateVatId>0</CorporateVatId>";
            pbstrAccountInfoXML += "<CorporateLegalEntity>Microsoft Corporation</CorporateLegalEntity><CorporateAddress><CorporateStreet1>One Microsoft Way</CorporateStreet1>";
            pbstrAccountInfoXML += "<CorporateStreet2></CorporateStreet2><CorporateStreet3></CorporateStreet3><CorporateCity>Redmond</CorporateCity><CorporateDistrict>";
            pbstrAccountInfoXML += "</CorporateDistrict><CorporateState>WA</CorporateState><CorporateCountryCode>US</CorporateCountryCode>";
            pbstrAccountInfoXML += "<CorporatePostalCode>98052</CorporatePostalCode></CorporateAddress>";

            pbstrAccountInfoXML += "<FirstName>Jacob</FirstName>";

            pbstrAccountInfoXML += "<FirstNamePronunciation>";
            pbstrAccountInfoXML += "</FirstNamePronunciation>";

            pbstrAccountInfoXML += "<LastName>Repp</LastName>";

            pbstrAccountInfoXML += "<LastNamePronunciation></LastNamePronunciation><Email>xboxstress@winisp.net</Email>";
            pbstrAccountInfoXML += "<CompanyName></CompanyName><CompanyNamePronunciation></CompanyNamePronunciation><Locale>en-US</Locale><HCI>NO</HCI><HCIValid>NO</HCIValid>";
            pbstrAccountInfoXML += "<Currency>USD</Currency><CountryCode>US</CountryCode>";

            if (!emptyPhone)
            {
                pbstrAccountInfoXML += "<PhoneSet><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix>";
                pbstrAccountInfoXML += "<PhoneNumber>5555555</PhoneNumber><PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone></PhoneSet>";
            }
            if (!emptyAddress)
            {
                pbstrAccountInfoXML += "<AddressInfoSet>";
                pbstrAccountInfoXML += "<AddressInfo><AddressId>PVsAAAAAAAABAACg</AddressId><FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1>";
                pbstrAccountInfoXML += "<Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City><District></District><State>WA</State>";
                pbstrAccountInfoXML += "<CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></AddressInfoSet>";
            }

            pbstrAccountInfoXML += "<TaxExemptionInfoSet></TaxExemptionInfoSet>";
            pbstrAccountInfoXML += "<AccountAttributeInfoSet><AttributeInfo><AttributeName>NAME</AttributeName><AttributeUse>REQUIRED</AttributeUse>";
            pbstrAccountInfoXML += "<AttributeExists>True</AttributeExists></AttributeInfo><AttributeInfo><AttributeName>ADDRESS</AttributeName>";
            pbstrAccountInfoXML += "<AttributeUse>REQUIRED</AttributeUse><AttributeExists>True</AttributeExists></AttributeInfo><AttributeInfo>";
            pbstrAccountInfoXML += "<AttributeName>PHONE_NUMBER</AttributeName><AttributeUse>REQUIRED</AttributeUse><AttributeExists>True</AttributeExists></AttributeInfo>";
            pbstrAccountInfoXML += "</AccountAttributeInfoSet><PendingTransactionExists>False</PendingTransactionExists></AccountInfo>";

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);

            if (status == DMPTransactionStatus.Timeout)
                LastCall.On(Ibdk).Waits(TimeSpan.FromSeconds(35));
            //LastCall.On(Ibdk).ClosesConnection();   // close connection, treated as timteout.
            else if (status == DMPTransactionStatus.Success)
                LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);
            else
                LastCall.On(Ibdk).Throws(ex);   // throw an exception

            BdkEmu.StopRecording(Ibdk);
        }

        //CalculateTaxEmulator(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, out string returnOrderDetailXml)
        public static void CalculateTaxEmulator(ref IBdkSoap Ibdk, Exception ex, int waitTime)
        {
            string returnOrderDetailXml = "<OrderDetail xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\"><Timestamp>2009-06-23T18:11:06</Timestamp><BillingMode>ImmediateSettle</BillingMode><ExternalId>f6620183-0e70-418a-96d4-ca5de2fc7231</ExternalId><Description>Description</Description><Currency>USD</Currency><ItemEntrySet><ItemEntry><ItemExternalId>00010001-0000-4000-8000-000030133300</ItemExternalId><ItemName>CC Dolphin 1: The Return</ItemName><ItemDescription>CC Dolphin 1: The Return</ItemDescription><ItemCategory>Game</ItemCategory><ItemType>PURCHASE</ItemType><RevenueSKU>XBX-00005</RevenueSKU><ProductType>OnlineDownload</ProductType><UnitPrice>19.99</UnitPrice><Quantity>1</Quantity><IsTaxIncluded>false</IsTaxIncluded><TaxEntrySet><TaxEntry><Jurisdiction>COUNTRY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>STATE</Jurisdiction><TaxAmount>1.3</TaxAmount><TaxRate>0.065</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>COUNTY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>CITY</Jurisdiction><TaxAmount>0.42</TaxAmount><TaxRate>0.021</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>DISTRICT</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>TERRITORY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>STATE2</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>COUNTY2</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>CITY2</Jurisdiction><TaxAmount>0.08</TaxAmount><TaxRate>0.004</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TotalTaxAmount>1.8</TotalTaxAmount><TotalTaxRate>0.09</TotalTaxRate></TaxEntrySet></ItemEntry></ItemEntrySet></OrderDetail>";

            //<OrderDetail xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:schemas-microsoft-com:billing-data"><Timestamp>2009-07-01T00:28:50</Timestamp><BillingMode>ImmediateSettle</BillingMode><ExternalId>60626823-6a9c-4109-9091-c156e5db9415</ExternalId><Description>Description</Description><Currency>USD</Currency><ItemEntrySet><ItemEntry><ItemExternalId>00010001-0000-4000-8000-000030133300</ItemExternalId><ItemName>CC Dolphin 1: The Return</ItemName><ItemDescription>CC Dolphin 1: The Return</ItemDescription><ItemCategory>Game</ItemCategory><ItemType>PURCHASE</ItemType><RevenueSKU>XBX-00005</RevenueSKU><ProductType>OnlineDownload</ProductType><UnitPrice>19.99</UnitPrice><Quantity>1</Quantity><IsTaxIncluded>false</IsTaxIncluded><TaxEntrySet><TaxEntry><Jurisdiction>COUNTRY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>STATE</Jurisdiction><TaxAmount>1.3</TaxAmount><TaxRate>0.065</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>COUNTY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>CITY</Jurisdiction><TaxAmount>0.42</TaxAmount><TaxRate>0.021</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>DISTRICT</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>TERRITORY</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>STATE2</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>COUNTY2</Jurisdiction><TaxAmount>0</TaxAmount><TaxRate>0</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TaxEntry><Jurisdiction>CITY2</Jurisdiction><TaxAmount>0.08</TaxAmount><TaxRate>0.004</TaxRate><Exempt>FALSE</Exempt></TaxEntry><TotalTaxAmount>1.8</TotalTaxAmount><TotalTaxRate>0.09</TotalTaxRate></TaxEntrySet></ItemEntry></ItemEntrySet></OrderDetail>


            Ibdk.CalculateTax("", "", "", "", "", out returnOrderDetailXml);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);


            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(waitTime));

            LastCall.On(Ibdk).OutArguments("", "", "", "", "", returnOrderDetailXml);

        }

        //void OffsetOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, out string orderReceiptXml);
        public static void OffsetOrderEmulator(ref IBdkSoap Ibdk, Exception ex, int waitTime)
        {

            
            string orderReceiptXml = "<OrderReceipt xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\"><OrderId>28002</OrderId><OrderPaymentStatus>RefundSucceeded</OrderPaymentStatus><TotalAmount>-19.99</TotalAmount><TotalTaxAmount>-1.80</TotalTaxAmount><IsTaxIncluded>false</IsTaxIncluded><PaymentInstrumentId>YG0AAAAAAAABAACA</PaymentInstrumentId><CorrelationInfo><DisplayInfo>12100</DisplayInfo><CorrelationData>Ym0AAAAAAAA=</CorrelationData></CorrelationInfo></OrderReceipt>";
            Guid trackingGuid = new Guid();

            Ibdk.OffsetOrder("", trackingGuid, "", "", "", "", "", out orderReceiptXml);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).IgnoresArgument(5);

            LastCall.On(Ibdk).ExpectedAnytime();

            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(waitTime));

            LastCall.On(Ibdk).OutArguments("", "", "", "", "", "", orderReceiptXml);

        }


        //void SubmitOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, out string orderReceiptXml);
        public static void SubmitOrderEmulator(ref IBdkSoap Ibdk, Exception ex, int waitTime)
        {
           

            string orderReceiptXml = "<OrderReceipt xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:schemas-microsoft-com:billing-data\"><OrderId>28000</OrderId><OrderPaymentStatus>ImmediateSettleSucceeded</OrderPaymentStatus><TotalAmount>19.99</TotalAmount><TotalTaxAmount>1.8</TotalTaxAmount><IsTaxIncluded>false</IsTaxIncluded><PaymentInstrumentId>YG0AAAAAAAABAACA</PaymentInstrumentId><CorrelationInfo><DisplayInfo>12100</DisplayInfo><CorrelationData>YG0AAAAAAAA=</CorrelationData></CorrelationInfo></OrderReceipt>";
            Guid trackingGuid = new Guid();

            Ibdk.SubmitOrder("", trackingGuid, "", "", "", "", out orderReceiptXml);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).IgnoresArgument(5);

            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).Waits(TimeSpan.FromMilliseconds(waitTime));

            LastCall.On(Ibdk).OutArguments("", "", "", "", "", "", orderReceiptXml);

        }
        // GetAccountSummary
        public static void CallAccSumStressEmulator(BdkEmulator BdkEmu, ref IBdkSoap Ibdk)
        {
            Ibdk = BdkEmu.StartRecording();

            string pbstrErrorXML = "";
            string pbstrAccountInfoXML = AccountInfoXML;

            Ibdk.GetAccountInfo(0x1, 0x1, 0, 0, "", out pbstrErrorXML, out pbstrAccountInfoXML);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, pbstrAccountInfoXML);


            string pi = "<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><PaymentInstrumentInfo><PaymentInstrumentId>BULKPYMTIDPVAACA</PaymentInstrumentId>";

            pi += "<PaymentInstrumentStatus>GOOD</PaymentInstrumentStatus><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName>";

            pi += "<CreditCardInfo><AccountHolderName>Bob</AccountHolderName><AccountNumberLastFour>7714</AccountNumberLastFour><CardType>VISA</CardType>";

            pi += "<ExpirationDate>102016</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>5555555</PhoneNumber>";

            pi += "<PhoneExtension></PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><AddressId>PVsAAAAAAAACAACg</AddressId>";

            pi += "<FriendlyName>XBOX Live</FriendlyName><Street1>Lovely Lane 31337</Street1><Street2>#1085618612</Street2><Street3></Street3><City>STILLWATER</City>";

            pi += "<District></District><State>WA</State><CountryCode>US</CountryCode><PostalCode>98014</PostalCode></AddressInfo></PaymentInstrumentInfo></PaymentInstrumentInfoSet>";

            int PaymentInstrumentInfoCount = 1;


            Ibdk.GetPaymentInstruments(0, 0, 0, 0, "", out pbstrErrorXML, out PaymentInstrumentInfoCount, out pi);
            LastCall.On(Ibdk).IgnoresArgument(0);
            LastCall.On(Ibdk).IgnoresArgument(1);
            LastCall.On(Ibdk).IgnoresArgument(2);
            LastCall.On(Ibdk).IgnoresArgument(3);
            LastCall.On(Ibdk).IgnoresArgument(4);
            LastCall.On(Ibdk).ExpectedAnytime();
            LastCall.On(Ibdk).OutArguments(0, 0, 0, 0, null, null, PaymentInstrumentInfoCount, pi);

            BdkEmu.StopRecording(Ibdk);
        }
        
        //-------------------------------------------------------------------------------------
        // Call CTP Transaction emulator        
        public static void CallCTPTransactionServiceEmulatorStress(CTPTransactionEmulator emulator, ref TransactionService iEmulator, string responseFilePath, bool computeOnly)
        {
            
           
            PurchaseInput requestPurchase = new PurchaseInput();

            PurchaseOutput responsePurchase;
            using (FileStream fileStream = new FileStream(responseFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlDictionaryReader reader = XmlDictionaryReader.CreateTextReader(
                                                 fileStream, new XmlDictionaryReaderQuotas());
                DataContractSerializer ser = new DataContractSerializer(typeof(PurchaseOutput));
               responsePurchase = (PurchaseOutput)ser.ReadObject(reader, true);
            }

            
            
            iEmulator = emulator.StartRecording();

            iEmulator.Purchase(requestPurchase);
            LastCall.On(iEmulator).IgnoresArgument(0);
            
            LastCall.On(iEmulator).ExpectedAnytime().Returns(responsePurchase);

            if(computeOnly)
                LastCall.On(iEmulator).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["ComputeOnlyPurchase"]));
            else
                LastCall.On(iEmulator).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["SubscriptionPurchase"]));
            
            emulator.StopRecording(iEmulator);
        }


        //-------------------------------------------------------------------------------------

        // Call CTP Transaction emulator        
        public static void CallCTPTransactionServiceTimeOutEmulator(CTPTransactionEmulator emulator, ref TransactionService iEmulator, string responseFilePath, bool computeOnly)
        {


            PurchaseInput requestPurchase = new PurchaseInput();

            PurchaseOutput responsePurchase;
            using (FileStream fileStream = new FileStream(responseFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlDictionaryReader reader = XmlDictionaryReader.CreateTextReader(
                                                 fileStream, new XmlDictionaryReaderQuotas());
                DataContractSerializer ser = new DataContractSerializer(typeof(PurchaseOutput));
                responsePurchase = (PurchaseOutput)ser.ReadObject(reader, true);
            }



            iEmulator = emulator.StartRecording();

            iEmulator.Purchase(requestPurchase);
            LastCall.On(iEmulator).IgnoresArgument(0);

            LastCall.On(iEmulator).ExpectedAnytime().Returns(responsePurchase);

           
            if (computeOnly)
                LastCall.On(iEmulator).Waits(TimeSpan.FromMilliseconds(35000));
            else
                LastCall.On(iEmulator).Waits(TimeSpan.FromMilliseconds(35000));

            emulator.StopRecording(iEmulator);
        }

        //-------------------------------------------------------------------------------------
        // FinBus emulator

        public static void CallFinBusPurchaseOrderEmulator(FinBusEmulator emulator, ref IInjectionService iEmulator,
            DMPTransactionStatus status, Exception exception, PurchaseOrder purchaseOrder)
        {
            MessageInfoResponse response = new MessageInfoResponse();
            response.MessageId = Guid.NewGuid();
            response.MessageDate = DateTime.UtcNow;

            iEmulator = emulator.StartRecording();
            iEmulator.PublishMessage(purchaseOrder);

            if (status == DMPTransactionStatus.Timeout)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                // simulate timeout by closing connection
                LastCall.On(iEmulator).ClosesConnection();
            }
            else if (status == DMPTransactionStatus.LongWaitTimeout)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                // wait 5 minutes to cause a timeout
                LastCall.On(iEmulator).Waits(new TimeSpan(0, 5, 0)).Returns(response);
            }
            else if (status == DMPTransactionStatus.Failed)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                LastCall.On(iEmulator).Throws(exception);
            }
            else
            {
                LastCall.On(iEmulator).Returns(response);
            }
            emulator.StopRecording(iEmulator);
        }

        public static void CallFinBusTokenRedemptionEmulator(FinBusEmulator emulator, ref IInjectionService iEmulator,
            DMPTransactionStatus status, Exception exception, TokenRedemption tokenRedemption)
        {
            MessageInfoResponse response = new MessageInfoResponse();
            response.MessageId = Guid.NewGuid();
            response.MessageDate = DateTime.UtcNow;
            
            iEmulator = emulator.StartRecording();
            iEmulator.PublishMessage(tokenRedemption);
            if (status == DMPTransactionStatus.Timeout)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                // simulate timeout by closing connection
                LastCall.On(iEmulator).ClosesConnection();
            }
            else if (status == DMPTransactionStatus.LongWaitTimeout)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                // wait 5 minutes to cause a timeout
                LastCall.On(iEmulator).Waits(new TimeSpan(0, 5, 0)).Returns(response);
            }
            else if (status == DMPTransactionStatus.Failed)
            {
                LastCall.On(iEmulator).IgnoresArgument(0);
                LastCall.On(iEmulator).Throws(exception);
            }
            else
            {
                LastCall.On(iEmulator).Returns(response);
            }
            emulator.StopRecording(iEmulator);
        }

        // used by stress test cases, cover both PurchaseOrder and TokenRedemption calls
        public static void CallFinBusStressEmulator(FinBusEmulator emulator, ref IInjectionService iEmulator)
        {
            MessageInfo messageInfo = new MessageInfo();
            MessageInfoResponse response = new MessageInfoResponse();
            response.MessageId = Guid.NewGuid();
            response.MessageDate = DateTime.UtcNow;

            iEmulator = emulator.StartRecording();

            iEmulator.PublishMessage(messageInfo);
            LastCall.On(iEmulator).IgnoresArgument(0);
            // simulate FinBus latency of 400 ms
            LastCall.On(iEmulator).Waits(TimeSpan.FromMilliseconds(400));
            LastCall.On(iEmulator).ExpectedAnytime().Returns(response);

            emulator.StopRecording(iEmulator);
        }

        //////////////////////////////////////////////////////////////////////////////
        // Music purchase related

        // for music purchase only and used in this file only
        public static void CallDmpEmulatorForMusic(DMPEmulator DmpEmu, ref IDMPTransactionSoap Idmp, ulong passportPuid,
            DMPTransactionStatus dmpStatus, Exception exPurchase, Exception exCancel, bool cancelSuccess)
        {
            Guid trackingGuid = Guid.NewGuid();
            Item[] dmpItems = new Item[1];
            TransactionContext context = new TransactionContext();
            Receipt receipt = new Receipt();
            receipt.TrackingGuid = trackingGuid; // ignored
            receipt.NewBalance = 0;              // ignored
            receipt.ConfirmationDate = DateTime.UtcNow;
            receipt.ConfirmationId = "DmpPurchaseItemComfirmationId";

            Idmp = DmpEmu.StartRecording();
            Idmp.PurchaseItem(trackingGuid, (long)passportPuid, 0, dmpItems, context, out receipt);
            LastCall.On(Idmp).IgnoresArgument(0);   // ignore tracking guid
            LastCall.On(Idmp).IgnoresArgument(3);   // ignore the items
            LastCall.On(Idmp).IgnoresArgument(4);   // ignore transaction context
            if (dmpStatus == DMPTransactionStatus.Timeout)
                LastCall.On(Idmp).ClosesConnection();   // close connection, treated as timteout. Will try dmp cancel immediately

            else if (dmpStatus == DMPTransactionStatus.Success)
                LastCall.On(Idmp).OutArguments(null, null, null, null, null, receipt);
            else
                LastCall.On(Idmp).Throws(exPurchase);   // throw an exception

            if (exCancel != null || cancelSuccess)
            {
                Idmp.CancelPurchaseItem((long)passportPuid, 0, trackingGuid, out receipt);
                LastCall.On(Idmp).IgnoresArgument(2);   // ignore tracking guid
                if (cancelSuccess)
                    LastCall.On(Idmp).OutArguments(null, null, null, receipt);
                else
                    LastCall.On(Idmp).Throws(exCancel);
            }
            DmpEmu.StopRecording(Idmp);
        }

        public static void CallMusicNetStressEmulator(MusicNetEmulator emu, ref IMusicNet mn,
            string RetailerId, string CustomerId, XeUser.Country countryId, WebMusic.Item[] Items)
        {
            mn = emu.StartRecording();

            mn.CreateAccount(null, RetailerId, CustomerId, null, null);
            LastCall.On(mn).ExpectedAnytime();

            MockPurchaseAssets(RetailerId, CustomerId, countryId, CreatePurchases(Items), mn);
            LastCall.On(mn).IgnoresArgument(1);     // ignore CustomerId
            LastCall.On(mn).IgnoresArgument(3);     // ignore Items for now until the emulator can verify an array of items
            LastCall.On(mn).ExpectedAnytime();
            LastCall.On(mn).Returns(SuccessfullPurchase());

            emu.StopRecording(mn);
        }

        public static void CallMusicNetEmulator(MusicNetEmulator emu, ref IMusicNet mn, DMPTransactionStatus status, Exception mnException,
            string RetailerId, string CustomerId, XeUser.Country countryId, WebMusic.Item[] Items, bool newAccount)
        {
            CallMusicNetEmulator(emu, ref mn, status, mnException, RetailerId, CustomerId, countryId, Items, newAccount, DMPTransactionStatus.NoStatus, null);
        }

        public static void CallMusicNetEmulator(MusicNetEmulator emu, ref IMusicNet mn, DMPTransactionStatus status, Exception mnException,
            string RetailerId, string CustomerId, XeUser.Country countryId, WebMusic.Item[] Items, bool newAccount, DMPTransactionStatus retryStatus, Exception retryEx)
        {
            CallMusicNetEmulator(emu, ref mn, status, mnException, RetailerId, CustomerId, countryId, Items, newAccount, retryStatus, retryEx, false);
        }

        // the retry status and secondTimeout are added for the music purchase queue
        public static void CallMusicNetEmulator(MusicNetEmulator emu, ref IMusicNet mn, DMPTransactionStatus status, Exception mnException, string RetailerId,
            string CustomerId, XeUser.Country countryId, WebMusic.Item[] Items, bool newAccount, DMPTransactionStatus retryStatus, Exception retryEx, bool secondTimeout)
        {
            mn = emu.StartRecording();
            if (newAccount)
                mn.CreateAccount(null, RetailerId, CustomerId, null, null);
            MockPurchaseAssets(RetailerId, CustomerId, countryId, CreatePurchases(Items), mn);
            if (status == DMPTransactionStatus.Timeout)
                LastCall.On(mn).ClosesConnection();
            else if (status == DMPTransactionStatus.Success)
                LastCall.On(mn).Returns(SuccessfullPurchase());
            else
                LastCall.On(mn).Throws(mnException);

            // retry status
            if (retryStatus != DMPTransactionStatus.NoStatus)
            {
                MockPurchaseAssets(RetailerId, CustomerId, countryId, CreatePurchases(Items), mn);

                if (retryStatus == DMPTransactionStatus.Timeout)
                    LastCall.On(mn).ClosesConnection();
                else if (retryStatus == DMPTransactionStatus.Success)
                    LastCall.On(mn).Returns(SuccessfullPurchase());
                else
                    LastCall.On(mn).Throws(retryEx);

                if (secondTimeout)
                {
                    MockPurchaseAssets(RetailerId, CustomerId, countryId, CreatePurchases(Items), mn);
                    LastCall.On(mn).ClosesConnection();
                }
            }

            emu.StopRecording(mn);
        }

        public static void CallMNCreateAccountEmulator(MusicNetEmulator emu, ref IMusicNet mn, Exception mnException, string RetailerId, string CustomerId)
        {
            mn = emu.StartRecording();
            mn.CreateAccount(null, RetailerId, CustomerId, null, null);

            if (mnException != null)
                LastCall.On(mn).Throws(mnException);

            emu.StopRecording(mn);
        }

        public static void MockPurchaseAssets(string retailer, string customer, XeUser.Country countryId, PurchaseItem[] items, IMusicNet mn)
        {
            string authToken = null;
            string retailerId = retailer;
            string customerId = customer;
            string orderId = "ignore";
            //string isoCountryCode = CountryDictionary.CountryCode(u.CountryId);
            //string isoCountryCode = Enum.GetName(typeof(CountryId), uacs.GetBillingInfo(user).CountryId);
            string isoCountryCode = Enum.GetName(typeof(XeUser.Country), countryId);
            bool allowPartialPurchases = false;
            CustomProperty[] extraParameters = null;

            mn.PurchaseAssets(authToken, retailerId, customerId, orderId, items,
                isoCountryCode, allowPartialPurchases, extraParameters);
            LastCall.On(mn).IgnoresArgument(3);
            LastCall.On(mn).IgnoresArgument(4);
        }

        public static ItemPrice NewUSDPrice(string amount)
        {
            ItemPrice p = new ItemPrice();
            p.amount = amount;
            p.currency = Currency.USD;

            return p;
        }

        public static PurchaseItem[] CreatePurchases(WebMusic.Item[] items)
        {
            PurchaseItem[] purchaseItems = new PurchaseItem[items.Length];
            for (int i = 0; i < items.Length; i++)
            {
                WebMusic.Item item = items[i];

                PurchaseItem purchaseItem = new PurchaseItem();
                purchaseItem.mnetId = item.componentIdField;
                purchaseItem.type = item.virtualSkuField == WebMusic.ComponentType.Album ?
                    PurchaseItemType.Album : PurchaseItemType.Track;

                // 63363: Remove dummy "99 cent" information being sent on MusicNet.PurchaseAssets calls
                purchaseItem.soldForPrice = NewUSDPrice(item.retailPriceInCurrency.ToString());
                //purchaseItem.suggestedRetailPrice = NewUSDPrice("0");

                purchaseItems[i] = purchaseItem;
            }

            return purchaseItems;
        }

        // in musicnet.cs, TryPurchaseAssets() never check the returned Purchase
        // for emulator verification purpose
        public static Purchase SuccessfullPurchase()
        {
            Purchase p = new Purchase();
            p.itemsWithErrors = new Microsoft.XBox.Live.Server.Emulators.MusicNet.PurchaseItemResponse[0];

            return p;
        }

#if false
        public static WebMusic.Item[] ConvertXeMusicItemToWebMusic(MusicItem[] musicItems)
        {
            WebMusic.Item[] items = new WebMusic.Item[musicItems.GetLength(0)];

            int i = 0;
            foreach (MusicItem musicItem in musicItems)
            {
                WebMusic.Item item = new WebMusic.Item();

                // the XeMusicItem and WebMusice have the opposite order of the componentType
                item.virtualSkuField = (WebMusic.ComponentType)((musicItem.ComponentType == 0) ? 1 : 0);
                item.componentIdField = musicItem.MnetID;
                item.artistNameField = musicItem.ArtistName;
                item.titleField = musicItem.TitleField;
                item.retailPriceInPoints = musicItem.RetailPriceInPoints;
                item.retailPriceInCurrency = musicItem.RetailPriceInCurrency;
                item.wholesalePriceInCurrency = musicItem.WholesalePriceInCurrency;

                items[i++] = item;
            }
            return items;
        }
#endif

    }
}

namespace WebMusic
{
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Music/")]
    public partial class Item
    {

        private ComponentType virtualSkuFieldField;

        private string componentIdFieldField;

        private string artistNameFieldField;

        private string titleFieldField;

        private int retailPriceInPointsField;

        private decimal retailPriceInCurrencyField;

        private decimal wholesalePriceInCurrencyField;

        /// <remarks/>
        public ComponentType virtualSkuField
        {
            get
            {
                return this.virtualSkuFieldField;
            }
            set
            {
                this.virtualSkuFieldField = value;
            }
        }

        /// <remarks/>
        public string componentIdField
        {
            get
            {
                return this.componentIdFieldField;
            }
            set
            {
                this.componentIdFieldField = value;
            }
        }

        /// <remarks/>
        public string artistNameField
        {
            get
            {
                return this.artistNameFieldField;
            }
            set
            {
                this.artistNameFieldField = value;
            }
        }

        /// <remarks/>
        public string titleField
        {
            get
            {
                return this.titleFieldField;
            }
            set
            {
                this.titleFieldField = value;
            }
        }

        /// <remarks/>
        public int retailPriceInPoints
        {
            get
            {
                return this.retailPriceInPointsField;
            }
            set
            {
                this.retailPriceInPointsField = value;
            }
        }

        /// <remarks/>
        public decimal retailPriceInCurrency
        {
            get
            {
                return this.retailPriceInCurrencyField;
            }
            set
            {
                this.retailPriceInCurrencyField = value;
            }
        }

        /// <remarks/>
        public decimal wholesalePriceInCurrency
        {
            get
            {
                return this.wholesalePriceInCurrencyField;
            }
            set
            {
                this.wholesalePriceInCurrencyField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Music/")]
    public enum ComponentType
    {

        /// <remarks/>
        Album,

        /// <remarks/>
        Single,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\BdkInterface.cs ===
using System;
using System.Xml;
using System.Net;
using System.Net.Security;
using System.Security.Principal;
using System.Security.Cryptography.X509Certificates;


using xonline.common.utilities2;


namespace XeXbos
{
  
    /// <summary>
    /// Summary description for BdkInterface.
    /// </summary>
    public class BdkInterface : bdk
    {
        public string LastError;
        public int LastErrorCode;
        private static X509Certificate ClientCert;
        protected const Int32 CERT_SYSTEM_STORE_LOCATION_SHIFT = 16;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE = (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_STORE_READONLY_FLAG = 0x00008000;

        public void ParseError(string ErrorXml)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(ErrorXml);
            XmlElement root = doc.DocumentElement;
            XmlNode node = root.SelectSingleNode(@"ErrorHResult");
            LastErrorCode = Convert.ToInt32(node.InnerText, 16);
            node = root.SelectSingleNode(@"ErrorMessage");
            LastError = node.InnerText;
        }

        public BdkInterface()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy(); - this is obsolete in .net 2.0
            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(this.AcceptAllCerts);
            ServicePointManager.DefaultConnectionLimit = 220;
            GetClientCertificate();
            this.ClientCertificates.Add(ClientCert);
            this.Timeout = 120000;
            //this.Credentials=new NetworkCredential("XBL1BX05DOM\\XboxRenewalTesting","Jelram1!");
        }

        // Right now this handler accepts all the server certificates, however can be configured to accept only a specific certificate.
        private bool AcceptAllCerts(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            // using cert parameter we can have a validation logic whether we will be accepting the certificate or not.
            return true;
        }

        private static void GetClientCertificate()
        {
            string clientCertSubject = "onebox-sps.xboxlive.com";
            if (ClientCert == null)
            {
                ClientCert = CertUtil.GetCertificate(CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG, clientCertSubject);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\StressHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.Utilities;

namespace XeXbos
{
    public class StressHelper
    {
        public static T GetInputValue<T>(T[] values, uint[] distributions)
        {
            int i;
            int count = values.GetLength(0);
            // make sure the two array the same size
            if (count != distributions.GetLength(0))
                throw new Exception(string.Format("Values array and distributions array are not the same size. values: {0}, distributions: {1}", values.GetLength(0), distributions.GetLength(0)));
            int total = 0;
            for (i = 0; i < count; i++)
            {
                total = total + (int)distributions[i];
            }
            int chance = RandomEx.GlobalRandGen.Next(0, total);
            int current = 0;
            for (i = 0; i < count; i++)
            {
                current = current + (int)distributions[i];
                if (chance < current)
                    return values[i];
            }
            // shouldn't get here, will return the first one as the default one
            return (T) values[0];
        }

        public static List<T> GetInputValue<T>(T[] values, uint [] arraySize, uint[] arraySizeDistributions)
        {
            // Determine the size of the array we should use
            int count = values.Length;
            uint currentSize = GetInputValue<uint>(arraySize, arraySizeDistributions);

            List<T> list = new List<T>();
            
            for (int i = 1; i <= currentSize; i++) 
            {
                int chance = RandomEx.GlobalRandGen.Next(0, values.Length);
                list.Add(values[chance]);            
            }

            if (currentSize == 0)
            {
                return null;
            }
            else
            {
                return list;
            }
        }

        /// <summary>
        /// Returns an array of values based on the given inputs.  This is really simple right
        /// now and simply picks some random ones.  May return duplicates.
        /// </summary>
        public static T[] GetInputValueArray<T>(T[] values, uint[] arraySizes, uint[] arraySizeDistributions)
        {
            List<T> results = GetInputValue(values, arraySizes, arraySizeDistributions);

            return (results == null?new T[0]:results.ToArray());
        }
        /// <summary>
        /// Generates a random string with the given length
        /// </summary>
        /// <param name="size">Size of the string</param>
        /// <param name="lowerCase">If true, generate lowercase string</param>
        /// <returns>Random string</returns>
        public static String GetRandomString(int size, bool lowerCase)
        {
            Random random = new Random();
            StringBuilder sb = new StringBuilder();

            Char ch;
            for (int i = 0; i < size; i++)
            {
                ch = Convert.ToChar(Convert.ToInt32(Math.Floor(26 * random.NextDouble() + 65)));
                sb.Append(lowerCase ? Char.ToLower(ch) : ch);
            }

            return sb.ToString();
        }

        public static Guid CreateGuid(string group, int index)
        {
            string sample = "df5cfb00-0001-0000-0001-000000000000";
            StringBuilder IdStr = new StringBuilder();
            String indexStr = index.ToString();
            IdStr.Append(string.Format("{0}", group));

            int len = IdStr.Length;
            for (int i = len; i < sample.Length - indexStr.Length; i++)
            {
                IdStr.Append("0");
            }

            IdStr.Append(indexStr);
            return (new Guid(IdStr.ToString()));
        }

        public static Guid[] CreateGuidArray(String[] strs)
        {
            Guid[] array = new Guid[strs.Length];

            for (int i = 0; i < strs.Length; i++)
            {
                array[i] = new Guid(strs[i]);
            }

            return array;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__billing_4_none_12.4.56.0_none_34e119ac9f38ca7b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_billing_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.manifest
XP_MANIFEST_PATH=manifests\x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.cat
XP_CATALOG_PATH=manifests\x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.cat
XP_PAYLOAD_PATH=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_billing_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__billing_4_none_12.4.56.0_none_34e119ac9f38ca7b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_billing_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.manifest
XP_MANIFEST_PATH=manifests\x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.cat
XP_CATALOG_PATH=manifests\x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527.cat
XP_PAYLOAD_PATH=x86__billing_4_no-public-key_12.4.56.0_x-ww_e38fc527
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_billing_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\UserHelper.cs ===
using System;

using live.common;
using live.client;
using live.protocol.next;

namespace XeXbos
{
    public class UserHelper
    {
        public enum UserType : int
        {
            Xbox1,
            Silver,
            Gold,
            MigratedAccount,
            ChildAccount,
            Lightweight,
            Zune,
            Panaroma
        }

        // the user is always created using real passport by default
        public static XblUser CreateUser(IClient client, UserType userType, CountryId country)
        {
            return CreateUser(client, userType, country, PassportType.Real);
        }

        public static XblUser CreateUser(IClient client, UserType userType, CountryId country, PassportType passport)
        {
            XblUserSettings settings;

            switch (userType)
            {
                case UserType.Gold:
                    settings = new XblUserSettings(XblUserTier.Gold, passport);
                    SetAddress(settings, country);
                    break;
                case UserType.Lightweight:
                    settings = new XblUserSettings(XblUserTier.Silver, passport);
                    SetLightWeight(settings, country);
                    break;
                case UserType.Zune:
                    settings = new XblUserSettings(XblUserTier.Silver, passport);
                    SetAddress(settings, country);
                    settings.CreateZuneProfile = true;
                    break;
                default:
                    settings = new XblUserSettings(XblUserTier.Silver, passport);
                    SetAddress(settings, country);
                    break;
            }

            return CreateUser(client, settings);
        }

        // create user without logon
        public static XblUser CreateUser(IClient client, XblUserSettings settings)
        {
            PassportUtils.CreatePassportAccounts(client, settings, true);

            XblUser user;
            uint hr = live.server.UACS.XeCreateLiveAccount(client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }
            Console.WriteLine(string.Format("Created User: 0x{0} on client: {1} with passport puid 0x{2}", user.Puid.ToString("X"), client.ClientType.ToString(), user.Settings.UserPassportInfo.PassportPuid.ToString("X")));

            if (client.ClientType == ClientType.Xenon)
            {
                ITransaction transObj = client.GetTransactionObject(XOService.PresNotification);
                uint flags = 0;

                Xbox360Client.SetUserFlagCountry(ref flags, (uint)user.Settings.PersonalInfo.CountryId);
                Xbox360Client.SetUserFlagLanguage(ref flags, (uint)user.Settings.PersonalInfo.LanguageId);
                Xbox360Client.SetUserFlagTier(ref flags, (uint)user.Settings.UserType);

                transObj.SecurityProvider.AddUser(user, flags);
            }

            return user;
        }

        public static uint GetPointsBalance(IClient client, XblUser user)
        {
            //Call Get Points balance before purchasing points
            uint pBalance = 0;
            pBalance = live.server.UACS.XeGetPointsBalance(client, user);
            return pBalance;
        }

        public static void AddPoints(IClient client, XblUser user)
        {
            AddPoints(client, user, live.common.Offers.GetOfferId(live.common.Offers.PointsOffers.CC5000US));
        }

        public static void AddPoints(IClient client, XblUser user, ulong offerId)
        {
            //Call Get Points balance before you purchase points
            GetPointsBalance(client, user);

            live.server.UACS.XeAddPaymentInstrument(client, user, Randomizer.CreditCards.CardInfoForPerson(
                    CreditCardType.Visa, user.Settings.PersonalInfo));

            //Purchase the points offer
            live.server.Billing.XeOfferPurchase(client, user,
                offerId,live.common.PaymentTypeEnum.CreditCard, user.Settings.BillingInfo.ActivePaymentInstrumentId);
          
        }

        private static void SetAddress(XblUserSettings settings, CountryId country)
        {
            settings.PersonalInfo.CountryId = country;
            CountryInfo countryInfo = Countries.CountryInfo(country);
            settings.PersonalInfo.AddressInfo = countryInfo.Addresses[0];
        }

        private static void SetLightWeight(XblUserSettings settings, CountryId country)
        {
            settings.PersonalInfo.LastName = "";
            settings.PersonalInfo.FirstName = "";
            settings.PersonalInfo.AddressInfo = new AddressInfo();
            settings.PersonalInfo.AddressInfo.City = "";
            settings.PersonalInfo.AddressInfo.District = "";
            settings.PersonalInfo.AddressInfo.PostalCode = "";
            settings.PersonalInfo.AddressInfo.State = "";
            settings.PersonalInfo.AddressInfo.Street1 = "";
            settings.PersonalInfo.AddressInfo.Street2 = "";
            settings.PersonalInfo.PhoneInfo = new PhoneInfo();
            settings.PersonalInfo.PhoneInfo.PhoneExtension = "";
            settings.PersonalInfo.PhoneInfo.PhoneNumber = "";
            settings.PersonalInfo.PhoneInfo.PhonePrefix = "";
            settings.PersonalInfo.CountryId = country;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_testbilling_none_12.4.56.0_none_50fc192dfbe3237c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=testbilling
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.manifest
XP_MANIFEST_PATH=manifests\msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.cat
XP_CATALOG_PATH=manifests\msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.cat
XP_PAYLOAD_PATH=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=testbilling,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_testbilling_none_12.4.56.0_none_50fc192dfbe3237c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=testbilling
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.manifest
XP_MANIFEST_PATH=manifests\msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.cat
XP_CATALOG_PATH=manifests\msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c.cat
XP_PAYLOAD_PATH=msil_testbilling_no-public-key_12.4.56.0_x-ww_50697c8c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=testbilling,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\AffiliateListTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;


using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol.SubNoti;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using STFUtil = ServerTestFramework.Utilities;
using xonline.common.stfutil;
using xonline.server.XConnSrv;

namespace xonline.common.community.test.dvt
{
    [TestGroup, DVT]
    public class AffiliateListDVT : TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void TearDown()
        {
        }

        [TestCase]
        public void AddAndRemoveAffiliates()
        {
            Global.RO.Info("AddAffiliates");

            ulong[] affiliateIds = GetUserIds(10);

            AffiliateList TestAffiliateList = new AffiliateList();
            CacheUtil.RemoveFromCache(TestAffiliateList.CacheKey); // clean up from last run
            
            uint dateUpdated = MsgDefs.DateTimeToMsgTime(DateTime.UtcNow);
            TestAffiliateList.AddAffiliates(affiliateIds, FriendsCommon.DefaultXenonTitleId, dateUpdated);

            Assert.AreEqual(TestAffiliateList.cAffiliates, affiliateIds.Length);
            ulong[] resultAffiliates = new ulong[affiliateIds.Length];
            
            for (int i = 0; i < resultAffiliates.Length; i++)
            {
                resultAffiliates[i] = TestAffiliateList.rgAffiliates[i].qwAffiliateID;
                Assert.AreEqual(TestAffiliateList.rgAffiliates[i].dwTitleID, FriendsCommon.DefaultXenonTitleId);
                Assert.AreEqual(TestAffiliateList.rgAffiliates[i].mtDateUpdated, dateUpdated);
            }
            Array.Sort(affiliateIds);
            Array.Sort(resultAffiliates);
            Assert.AreEqual(resultAffiliates, affiliateIds);

            Global.RO.Info("RemoveAffiliates");

            TestAffiliateList.RemoveAffiliates(affiliateIds);
            Assert.AreEqual(TestAffiliateList.cAffiliates, 0);

        }

        [TestCase]
        public void IsAffiliate()
        {
            ulong[] affiliateIds = GetUserIds(10);

            AffiliateList TestAffiliateList = new AffiliateList();
            CacheUtil.RemoveFromCache(TestAffiliateList.CacheKey); // clean up from last run

            // should be no affiliates
            for (int i = 0; i < affiliateIds.Length; i++)
            {
                Assert.IsTrue(!TestAffiliateList.IsAffiliate(affiliateIds[i]));
            }
            
            uint dateUpdated = MsgDefs.DateTimeToMsgTime(DateTime.UtcNow);
            TestAffiliateList.AddAffiliates(affiliateIds, FriendsCommon.DefaultXenonTitleId, dateUpdated);

            for (int i = 0; i < affiliateIds.Length; i++)
            {
                Assert.IsTrue(TestAffiliateList.IsAffiliate(affiliateIds[i]));
            }

            TestAffiliateList.RemoveAffiliates(new ulong[] { affiliateIds[0] });
            Assert.IsTrue(!TestAffiliateList.IsAffiliate(affiliateIds[0]));
        }

        [TestCase]
        public void PersistAndLoad()
        {
            ulong[] affiliateIds = GetUserIds(10);

            FriendsCommon fc = new FriendsCommon();
            PNUser user = fc.CreateUser(true);

            AffiliateList TestAffiliateList = new AffiliateList(user.UserId, (ushort)PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX);
            
            // add affiliates
            uint dateUpdated = MsgDefs.DateTimeToMsgTime(DateTime.UtcNow);
            TestAffiliateList.AddAffiliates(affiliateIds, FriendsCommon.DefaultXenonTitleId, dateUpdated);

            // persist then remove from cache
            AffiliateList.PersistToDatabase(user.UserId);
            CacheUtil.RemoveFromCache(TestAffiliateList.CacheKey);

            // load
            AffiliateList LoadedAffiliateList = AffiliateList.Load(user.UserId, (ushort)PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX);

            // verify contents
            Assert.IsTrue(LoadedAffiliateList != null);
            Assert.AreEqual(TestAffiliateList.cAffiliates, LoadedAffiliateList.cAffiliates);

            ulong[] testIds = new ulong[LoadedAffiliateList.cAffiliates];
            for (int i = 0; i < testIds.Length; i++)
            {
                testIds[i] = LoadedAffiliateList.rgAffiliates[i].qwAffiliateID;
            }
            Array.Sort(testIds);
            Array.Sort(affiliateIds);
            
            Assert.AreEqual(testIds, affiliateIds);
        }

        [TestCase]
        public void VerifyListOrder()
        {
            ulong[] affiliateIds = GetUserIds(10);
            Affiliate[] affiliates = new Affiliate[10];
            FriendsCommon fc = new FriendsCommon();
            PNUser user = fc.CreateUser(true);

            AffiliateList TestAffiliateList = new AffiliateList(user.UserId, (ushort)PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX);
            
            for (int i = 0; i < affiliateIds.Length; i++)
            {
                uint time = MsgDefs.DateTimeToMsgTime(DateTime.UtcNow);
                TestAffiliateList.AddAffiliates(new ulong[] { affiliateIds[i] }, FriendsCommon.DefaultXenonTitleId, time);
                affiliates[i] = new Affiliate();
                affiliates[i].qwAffiliateID = affiliateIds[i];
                affiliates[i].dwTitleID = FriendsCommon.DefaultXenonTitleId;
                affiliates[i].mtDateUpdated = time;
            }

            // sort expected list

            Array.Sort(affiliates, (x, y) => { return (int)(y.mtDateUpdated - x.mtDateUpdated); });

            // affiliate list should end up sorted newest first
            Assert.AreEqual(TestAffiliateList.cAffiliates, affiliateIds.Length);
            for (int i = 0; i < TestAffiliateList.cAffiliates; i++)
            {
                Assert.AreEqual(TestAffiliateList.rgAffiliates[i].mtDateUpdated, affiliates[i].mtDateUpdated);
            }

            
        }

        private ulong[] GetUserIds(int numUsers)
        {
            FriendsCommon fc = new FriendsCommon();
            ulong[] userIds = new ulong[numUsers];
            for (int i = 0; i < numUsers; i++)
            {
                PNUser user = fc.CreateUser(true);
                userIds[i] = user.UserId;
            }

            return userIds;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\concurrencytests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol.SubNoti;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using STFUtil = ServerTestFramework.Utilities;
using xonline.common.stfutil;
using xonline.server.XConnSrv;

namespace xonline.common.community.test.dvt
{

    [TestGroup, DVT]
    public class OptimisticConcurrencyDVT : TestNode
    {
        public const uint TITLEID = 0xffff2003;
        public const uint INTPROPERTYID = 0x10000001;
        public IMemCache cache;

        [TestGroupSetup]
        public void Setup()
        {
            cache = new MockAccelCache(true, 3);
            CacheUtil.SetNotiCache(cache);
            CacheUtil.SetPresCache(cache);

        }

        [TestGroupTearDown]
        public void TearDown()
        {
        }

        //    //[TestCase]
        //    //public void WritePresenceRecord()
        //    //{
        //    //    Global.RO.Info("WritePresenceRecord");

        //    //    ulong userId = 0x1234567812345678;
        //    //    string name = "Iamthelolrus";


        //    //    PresenceRecord newPresence = new PresenceRecord();
        //    //    newPresence.qwUserID = userId;
        //    //    newPresence.sGamertag = name;
        //    //    newPresence.sGamertagLen = (uint)name.Length;
        //    //    newPresence.dwTitleID = TITLEID;
        //    //    newPresence.dwState = PresDefs.P_STATE_FLAG_ONLINE;
        //    //    newPresence.dtLastSeen = DateTime.Now;


        //    //    PresenceUtil.WritePresenceRecord(newPresence, null, null);

        //    //    // Mock accel cache should return ERROR_ACCESS_DENIED 3 times, then write

        //    //    PresenceRecord presResult = PresenceUtil.GetPresenceRecord(userId);

        //    //    Assert.AreEqual(newPresence.sGamertag, presResult.sGamertag);

        //    //    // cleanup

        //    //    string sPresenceRecordKey = CacheUtil.GetPresenceRecordKey(userId);
        //    //    CacheUtil.RemoveFromPresenceCache(sPresenceRecordKey);

        //    //    Global.RO.Info("WritePresenceRecord - Complete");
        //    //}

        [TestCase]
        public void AddUserRemoveUser()
        {
            Global.RO.Info("AddUserToMachine");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            xonline.common.protocol.SGADDR sg = new xonline.common.protocol.SGADDR();
            sg.inaSg = u1.Xbox.IpSg;
            sg.dwSpiSg = u1.Xbox.SpiSg;
            sg.qwXboxId = u1.Xbox.XboxId;

            // Overwrite anything already in the cache
            MachineUserList machineList = new MachineUserList();
            machineList.sgaddr = sg;
            ulong qw = (sg.inaSg << 32) | (sg.dwSpiSg);
            machineList.OwnerID = qw;
            
            CacheUtil.OverwriteCache(machineList);


            MachineUserList expectList = new MachineUserList();
            expectList.rgUsers = new ulong[] { u1.UserId };
            expectList.rgUsersLen = 1;
            expectList.sgaddr = sg;

            PresenceUtil.AddUserToMachine(u1.UserId, sg);

            MachineUserList resultList = PresenceUtil.GetMachineUserList(sg);

            Assert.AreEqual(resultList.rgUsersLen, expectList.rgUsersLen);
            Assert.AreEqual(resultList.rgUsers, resultList.rgUsers);
            Assert.AreEqual(resultList.sgaddr, sg);

            Global.RO.Info("AddUserToMachine - successful");

            Global.RO.Info("RemoveUserFromMachine");


            expectList = new MachineUserList();
            expectList.rgUsers = null;
            expectList.rgUsersLen = 0;
            expectList.sgaddr = sg;

            PresenceUtil.RemoveUserFromMachine(u1.UserId, sg);

            resultList = PresenceUtil.GetMachineUserList(sg);

            Assert.AreEqual(resultList.rgUsersLen, expectList.rgUsersLen);
            Assert.AreEqual(resultList.rgUsers, resultList.rgUsers);
            Assert.AreEqual(resultList.sgaddr, sg);

            Global.RO.Info("RemoveUserFromMachine - successful");
            Global.RO.Info("AddUserRemoveUser - Complete");

        }

        [TestCase]
        public void CreateOrAddInvite()
        {
            Global.RO.Info("CreateOrAddInvite");

            FriendsCommon fc = new FriendsCommon();
            PNUser sender = fc.CreateXenonUser(true);
            PNUser invitee = fc.CreateXenonUser(true);
            uint titleId = TITLEID;
            ulong sessionId = 0x1000000000000000;

            ulong[] invitees = new ulong[] { invitee.UserId };

            ulong[] newInvitees = PresenceUtil.CreateOrAddInvite(sender.UserId, titleId, sessionId, invitees);


            string sInviteKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInvitation, sender.UserId);
            Invitation resultInvitation = (Invitation)CacheUtil.ReadFromCache(sInviteKey);
            Assert.AreEqual(resultInvitation.cInvitees, invitees.Length);
            Assert.AreEqual(resultInvitation.dwTitleID, titleId);
            Assert.AreEqual(resultInvitation.qwInvitees, invitees);
            Assert.AreEqual(resultInvitation.qwMatchSessionID, sessionId);

            // cleanup
            CacheUtil.RemoveFromCache(sInviteKey);

            Global.RO.Info("CreateOrAddInvite - Complete");

        }

            [TestCase]
            public void AddAndDeleteTransientMessage()
            {
                Global.RO.Info("AddTransientMessage");

                TransientMessage msg = new TransientMessage();
                FriendsCommon fc = new FriendsCommon();
                PNUser recipient = fc.CreateXenonUser(true);
                PNUser sender = fc.CreateXenonUser(true);

                MessageSummary summary = new MessageSummary();
                summary.qwSenderID = sender.UserId;
                summary.szSenderName = sender.Name;
                msg.Summary = summary;

                uint msgId = MessagingUtil.AddTransientMessage(recipient.UserId, msg);
                TransientMessage resultMsg = MessagingUtil.GetTransientMessage(recipient.UserId, msgId);

                Assert.AreEqual(resultMsg, msg);

                Global.RO.Info("AddTransientMessage successful");

                TransientMessage xmsgDeleted = MessagingUtil.DeleteTransientMessage(recipient.UserId, msgId);

                Assert.IsTrue(xmsgDeleted != null);

                // verify message is not still in cache
                string sRecipientKey = CacheUtil.BuildCacheKey(DATA_TYPES.eTransientMessages, recipient.UserId);
                TransientMessages resultMessages = (TransientMessages)CacheUtil.ReadFromCache(sRecipientKey);
                 foreach (TransientMessage msgIter in resultMessages.Messages)
                 {
                     Assert.IsTrue(!msgIter.Equals(msg));
                 }

                Global.RO.Info("DeleteTransientMessage successful");
                Global.RO.Info("AddAndDeleteTransientMessage - Complete");
            }

        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\FriendListUtilTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol.SubNoti;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using STFUtil = ServerTestFramework.Utilities;
using xonline.common.stfutil;

using xonline.server.XConnSrv;
using Microsoft.MMF;

namespace xonline.common.community.test.dvt
{
    [TestGroup, DVT]
    public class FriendsListUtilDVT: TestNode
    {
        public const uint TITLEID = 0xffff2003;
        public const uint INTPROPERTYID = 0x10000001;
        private static uint _usersInTest = 30;
        private const ulong _friendListOwner = 1L;

        [TestGroupSetup]
        public void Setup()
        {
            //Config.ComponentName = "common_communitydvt";

            //// Allow this test to run on a machine that is not yet in t_servers
            //Global.XEnv.InitializeTestServer();

            //// Let the fake SG know where to send state updates
            //IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.reflectorfd);
            //string endpoint = viInfo.IPAddressString + ":" + viInfo.Port.ToString();
            //GlobalFakeSG.FakeSG.SetStateEndpoint(endpoint);

            //// Setup default log targets
            //XomLoggingControl.Init();
        }

        [TestGroupTearDown]
        public void TearDown()
        {
        }

        [TestCase]
        public void GetFriendsListForXuid()
        { 
            // Test case not defined as this function is exercised by other tests.
        }

        [TestCase]
        public void Add()
        {
            Global.RO.Info("Add");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);

            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Add - something went wrong. HR: {0}", hr));

            FriendsList friendList = FriendsListUtil.GetFriendsListForXuid(u1.UserId);

            Assert.IsTrue(1 == friendList.rgUsers.Length, string.Format("Add - Expected 1 for length of friend list. Got {0}", friendList.rgUsers.Length));

            Assert.IsTrue(u2.UserId == friendList.rgUsers[0].qwXUID, string.Format("Add - Expected user2's xuid in the friend list. Got {0} Expected {1}", friendList.rgUsers[0].qwXUID, u2.UserId));
            uint status = CacheUtil.GetFriendStatus(friendList.rgUsers[0].dwUserFlags);
            Assert.IsTrue(PresDefs.P_BUDDY_STATUS_PENDING == status, string.Format("Add - Expected friend list entry's status to be 'pending'. Got {0}", status));

            Assert.IsTrue(ValidateFriendsListWithCache(u1.UserId, friendList), "Add - Friends list returned does not match the cache layer's record");
            Assert.IsTrue(ValidateFriendsListWithDatabase(u1.UserId, friendList), "Add - Friends list returned does not match the database layer's record");

            Global.RO.Info("Add - Complete");
        }

        [TestCase]
        public void Accept()
        {
            Global.RO.Info("Accept");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;
            hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);

            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Accept - something went wrong calling Add. HR: {0}", hr));


            hr = FriendsListUtil.Accept(u2.UserId, u1.UserId);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Accept - something went wrong calling Accept. HR: {0}", hr));

            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;
            Assert.IsTrue(1 == friendList1.Length, string.Format("Accept - Expected 1 for length of friend list 1. Got {0}", friendList1.Length));
            Assert.IsTrue(u2.UserId == friendList1[0].qwXUID, string.Format("Accept - Expected user2's xuid in the friend list 1. Got {0} Expected {1}", friendList1[0].qwXUID, u2.UserId));
            uint status1 = CacheUtil.GetFriendStatus(friendList1[0].dwUserFlags);
            Assert.IsTrue(PresDefs.P_BUDDY_STATUS_OK == status1, string.Format("Accept - Expected friend list 1 entry's status to be 'Accepted'. Got {0}", status1));

            Assert.IsTrue(1 == friendList2.Length, string.Format("Accept - Expected 1 for length of friend list 2. Got {0}", friendList2.Length));
            Assert.IsTrue(u1.UserId == friendList2[0].qwXUID, string.Format("Accept - Expected user1's xuid in the friend list 2. Got {0} Expected {1}", friendList2[0].qwXUID, u1.UserId));
            uint status2 = CacheUtil.GetFriendStatus(friendList2[0].dwUserFlags);
            Assert.IsTrue(PresDefs.P_BUDDY_STATUS_OK == status2, string.Format("Accept - Expected friend list 2 entry's status to be 'Accepted'. Got {0}", status2));

            Assert.IsTrue(FriendsListUtil.GetFriendsListForXuid(u1.UserId).IsAcceptedBuddy(u2.UserId), "Accept - Test of IsAcceptedBuddy returned false");

            Global.RO.Info("Accept - Complete");
        }

        [TestCase]
        public void Delete()
        {
            Global.RO.Info("Delete");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;

            hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Delete - something went wrong calling Add. HR: {0}", hr));

            hr = FriendsListUtil.Accept(u2.UserId, u1.UserId);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Delete - something went wrong calling Accept. HR: {0}", hr));

            hr = FriendsListUtil.Delete(u1.UserId, u2.UserId);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("Delete - something went wrong calling Delete. HR: {0}", hr));

            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            Assert.IsTrue(0 == friendList1.Length, string.Format("Delete- Expected 0 for length of friend list 1. Got {0}", friendList1.Length));

            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;
            Assert.IsTrue(0 == friendList2.Length, string.Format("Delete - Expected 0 for length of friend list 2. Got {0}", friendList2.Length));

            Global.RO.Info("Delete - Complete");
        }

        [TestCase]
        public void DeleteBeforeAccept()
        {
            Global.RO.Info("DeleteBeforeAccept");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;
            hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("DeleteBeforeAccept - something went wrong calling Add. HR: {0}", hr));

            hr = FriendsListUtil.Delete(u1.UserId, u2.UserId);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("DeleteBeforeAccept - something went wrong calling Delete. HR: {0}", hr));

            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            Assert.IsTrue(0 == friendList1.Length, string.Format("DeleteBeforeAccept- Expected 0 for length of friend list 1. Got {0}", friendList1.Length));

            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;
            Assert.IsTrue(0 == friendList2.Length, string.Format("DeleteBeforeAccept - Expected 0 for length of friend list 2. Got {0}", friendList2.Length));

            hr = FriendsListUtil.Accept(u2.UserId, u1.UserId);
            Assert.IsTrue(HResult.Failed(hr), "DeleteBeforeAccept - Accept succeded when it should have failed.");

            Global.RO.Info("DeleteBeforeAccept - Complete");
        }

        [TestCase]
        public void RejectNoBlock()
        {
            Global.RO.Info("RejectNoBlock");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;
            hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);

            Assert.IsTrue(HResult.Succeeded(hr), string.Format("RejectNoBlock - something went wrong calling Add. HR: {0}", hr));

            hr = FriendsListUtil.Reject(u2.UserId, u1.UserId, false);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("RejectNoBlock - something went wrong calling Accept. HR: {0}", hr));

            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            Assert.IsTrue(0 == friendList1.Length, string.Format("RejectNoBlock- Expected 0 for length of friend list 1. Got {0}", friendList1.Length));

            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;
            Assert.IsTrue(0 == friendList2.Length, string.Format("RejectNoBlock - Expected 0 for length of friend list 2. Got {0}", friendList2.Length));

            Global.RO.Info("RejectNoBlock - Complete");
        }

        [TestCase]
        public void RejectBlock()
        {
            Global.RO.Info("RejectBlock");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;
            hr = FriendsListUtil.Add(u1.UserId, u2.UserId, u1.Name, u2.Name);

            Assert.IsTrue(HResult.Succeeded(hr), string.Format("RejectBlock - something went wrong calling Add. HR: {0}", hr));

            hr = FriendsListUtil.Reject(u2.UserId, u1.UserId, true);
            Assert.IsTrue(HResult.Succeeded(hr), string.Format("RejectBlock - something went wrong calling Accept. HR: {0}", hr));
            // TODO: Need to validate that user1 wound up on user2's block list.

            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            Assert.IsTrue(0 == friendList1.Length, string.Format("RejectBlock- Expected 0 for length of friend list 1. Got {0}", friendList1.Length));

            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;
            Assert.IsTrue(0 == friendList2.Length, string.Format("RejectBlock - Expected 0 for length of friend list 2. Got {0}", friendList2.Length));

            Global.RO.Info("RejectBlock - Complete");
        }

        [TestCase]
        public void MakeFriends()
        {
            Global.RO.Info("MakeFriends");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            HResult hr = HResult.S_OK;
            hr = FriendsListUtil.MakeFriends(u1.UserId, u2.UserId, u1.Name, u2.Name);

            Assert.IsTrue(HResult.Succeeded(hr), string.Format("MakeFriends - something went wrong calling MakeFriends. HR: {0}", hr));
            UserData[] friendList1 = FriendsListUtil.GetFriendsListForXuid(u1.UserId).rgUsers;
            UserData[] friendList2 = FriendsListUtil.GetFriendsListForXuid(u2.UserId).rgUsers;

            Assert.IsTrue(1 == friendList1.Length, string.Format("MakeFriends - Expected 1 for length of friend list 1. Got {0}", friendList1.Length));
            Assert.IsTrue(u2.UserId == friendList1[0].qwXUID, string.Format("MakeFriends - Expected user2's xuid in the friend list 1. Got {0} Expected {1}", friendList1[0].qwXUID, u2.UserId));
            uint status1 = CacheUtil.GetFriendStatus(friendList1[0].dwUserFlags);
            Assert.IsTrue(PresDefs.P_BUDDY_STATUS_OK == status1, string.Format("MakeFriends - Expected friend list 1 entry's status to be 'Accepted'. Got {0}", status1));

            Assert.IsTrue(1 == friendList2.Length, string.Format("MakeFriends - Expected 1 for length of friend list 2. Got {0}", friendList2.Length));
            Assert.IsTrue(u1.UserId == friendList2[0].qwXUID, string.Format("MakeFriends - Expected user1's xuid in the friend list 2. Got {0} Expected {1}", friendList2[0].qwXUID, u1.UserId));
            uint status2 = CacheUtil.GetFriendStatus(friendList2[0].dwUserFlags);
            Assert.IsTrue(PresDefs.P_BUDDY_STATUS_OK == status2, string.Format("MakeFriends - Expected friend list 2 entry's status to be 'Accepted'. Got {0}", status2));

            Global.RO.Info("MakeFriends - Complete");
        }

        /// COMMENTING OUT AS Presence DATA in the FetchUserFromDataStoreMethod breaks this test and 
        /// we can't mock XCache currently
        /// <summary>
        /// Tests fetching from data store with a mocked cache layer.
        /// NOTE: If you get exceptions referencing not being able to intialize counters,
        /// run installutil on xblcore.dll
        /// </summary>
        //[TestCase]
        //public void FetchUserFromDataStore()
        //{
        //   List<IUserListEntry> userList = new List<IUserListEntry>(30);
        //   StubObjectWrapper<IMemCache> notiWrapper = StubFactory.Create<IMemCache>();
        //   StubObjectWrapper<IMemCache> presWrapper = StubFactory.Create<IMemCache>();
        //   CacheUtil.SetNotiCache(notiWrapper.Target);
        //   CacheUtil.SetPresCache(presWrapper.Target);

        //   string[] keys = { CacheUtil.BuildCacheKey(DATA_TYPES.eFriendsList, _friendListOwner) };
        //   byte[] notiCacheValue = CreateFriendsListByteArray((int)_usersInTest);
        //   byte[][] presCacheValue = CreateFriendsListPrivileges();
        //   uint version;
           

        //   using (Recorder.StartUnorderedRecording())
        //   {
        //       notiWrapper.
        //           IgnoresAllArguments().
        //           AssignsOutParameters((uint)0).
        //           AndReturns(notiCacheValue).
        //           On(c => c.RequestData(keys[0], null, out version));

        //       presWrapper.
        //           IgnoresAllArguments().
        //           AndReturns(presCacheValue).
        //           On(pc => pc.BulkRequestData(keys, new object[] { 1 }));
        //   }

        //    FriendsListUtil.FetchUserListFromDataStore(userList, _friendListOwner); 

        //    if (userList.Count!= _usersInTest) throw new Exception(
        //        string.Format("Expected {0} users, got {1}", 
        //            _usersInTest, 
        //            userList.Count));

        //    for (int idx = 0; idx < _usersInTest; idx++)
        //    {
        //        if (userList[idx].Xuid != (ulong)(idx + 2))
        //        {
        //            throw new Exception(string.Format("Xuid mismatch at index {0}", idx));
        //        }
        //    }
        //}

        internal static unsafe byte[] CreateFriendsListByteArray(int usersToMock)
        {
            FriendsList returnList = new FriendsList();
            returnList.OwnerID = _friendListOwner;
            returnList.HeaderFlags |= CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
            returnList.HeaderFlags |= 0;
            returnList.dwListVersion = 1;
            returnList.dwNumUsers = _usersInTest;
            returnList.rgUsers = new UserData[_usersInTest];
            for (int iFriend = 0; iFriend < usersToMock; iFriend++)
            {

                returnList.rgUsers[iFriend] = new UserData();
                returnList.rgUsers[iFriend].qwXUID = (ulong)(iFriend + 2);
                returnList.rgUsers[iFriend].dwUserFlags = 0;
            }

            return returnList.ToArray();
        }

        internal static unsafe byte[][] CreateFriendsListPrivileges()
        {
            UserPrivileges privs = new UserPrivileges();
            privs.OwnerID = _friendListOwner;
            return new byte[][] { privs.ToArray() };
        }


        /// <summary>
        /// Validates the submitted list is the same as the list stored in the cache layer
        /// </summary>
        /// <param name="userId">xuid of list owner</param>
        /// <param name="validateValue">list to comapre to</param>
        /// <returns>flag indicating success or failure</returns>
        private unsafe bool ValidateFriendsListWithCache(ulong userId, FriendsList validateValue)
        {
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eFriendsList, userId);
            FriendsList listInCache = (FriendsList)CacheUtil.ReadFromCache(sKey);

            return validateValue.Equals(listInCache);
        }

        /// <summary>
        /// Validates the submitted list is the same as the list stored in the database layer
        /// </summary>
        /// <param name="userId">xuid of list owner</param>
        /// <param name="validateValue">list to comapre to</param>
        /// <returns>flag indicating success or failure</returns>
        private unsafe bool ValidateFriendsListWithDatabase(ulong userId, FriendsList validateValue)
        {
            List<UserData> lFriends = new List<UserData>();
            int listVersion = -1;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xprof_get_friends";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);

                WstDataReader reader = ws.Execute();
                while (reader.Read())
                {
                    UserData f = new UserData();
                    f.qwXUID = (ulong)(long)reader["bi_friend_puid"];
                    f.dwUserFlags = (uint)(byte)reader["ti_status"];  // TODO:   will we use more flags than just status?  SubNotiDefs.BuildUserFlags() ?
                    lFriends.Add(f);
                }

                if (reader.NextResult() && reader.Read())
                {
                    listVersion = reader.GetInt32(0);
                }
            }

            FriendsList listInDatabase = new FriendsList();
            listInDatabase.OwnerID = userId;
            listInDatabase.dwListVersion = unchecked((uint)(listVersion));
            listInDatabase.rgUsers = lFriends.ToArray();

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(userId);
            listInDatabase.ApplySharingPermissions(privs);

            return validateValue.Equals(listInDatabase);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\MockAccelCache.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.XConnSrv;

namespace xonline.common.community.test
{

public class MockAccelCache : IMemCache
    {
        protected IMemCache m_realCache;
        private int m_numRetries;
        private int m_retryCount = 0;
        private bool m_forceRetry;

        public MockAccelCache() { }
        public MockAccelCache(bool fUseRealCache)
        {
            if (fUseRealCache)
            {
                m_realCache = new MemCacheImpl();
            }
        }

        public MockAccelCache(bool forceRetry, int numRetries)
        {
            m_realCache = new MemCacheImpl();
            m_numRetries = numRetries;
            m_forceRetry = true;
        }
        public string GetImplementationName()
        {
            return "MockAccelCache";
        }
        
        public virtual byte[] RequestData(string sKey, Object keyState)
        {
            uint version;
            return RequestData(sKey, keyState, out version);
        }
        public virtual byte[] RequestData(string sKey, Object keyState, out uint version)
        {
            uint[] rgVersions;
            byte[][] rgbValues = BulkRequestData(new string[] { sKey }, new Object[] { keyState }, out rgVersions);
            version = rgVersions[0];
            return rgbValues[0];
        }
        public virtual uint RequestData(string sKey, Object keyState, out uint version, out byte[] rgbData)
        {
            return m_realCache.RequestData(sKey, keyState, out version, out rgbData);
        }
        public virtual byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            return m_realCache.BulkRequestData(rgKeys, rgKeyStates);
        }
        public virtual byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions)
        {
            return m_realCache.BulkRequestData(rgKeys, rgKeyStates, out rgVersions);
        }
        public virtual uint[] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions, out byte[][]rgbData)
        {
            return m_realCache.BulkRequestData(rgKeys, rgKeyStates, out rgVersions, out rgbData);
        }
        
        public virtual void PublishData(string sKey, byte[] rgbValue, Object keyState)
        {
            m_realCache.PublishData(sKey, rgbValue, keyState);
        }
        public virtual uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version)
        {
            return PublishData(sKey, rgbValue, keyState, ref version, 0);
        }
        public virtual uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version, uint expirySeconds)
        {
            if (version != AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE && m_forceRetry && (m_retryCount < m_numRetries))
            {
                m_retryCount++;
                return HResult.E_ACCESSDENIED;
            }
            else
            {
                m_retryCount = 0;
                return m_realCache.PublishData(sKey, rgbValue, keyState, ref version, expirySeconds);
            }
        }
        public virtual void BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates)
        {
            BulkPublishData(rgKeys, rgbValues, rgKeyStates, new uint[] { 0 });
        }
        public virtual uint[] BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates, uint[] rgVersions)
        {
            uint[] retvals = new uint[rgbValues.Length];
            
            if (m_forceRetry && (m_retryCount < m_numRetries))
            {
                for (int i = 0; i < retvals.Length; i++)
                {
                    retvals[i] = HResult.E_ACCESSDENIED;
                }
                m_retryCount++;
            }
            else
            {
                retvals = m_realCache.BulkPublishData(rgKeys, rgbValues, rgKeyStates, rgVersions);
                m_retryCount = 0;
            }

            return retvals;
        }
        
        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            m_realCache.RegisterNotificationHandler(notificationCallback);
        }
        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            m_realCache.RegisterNotificationFailureHandler(failureCallback);
        }
        public void UnregisterHandlers()
        {
            m_realCache.UnregisterHandlers();
        }

        public virtual void RemoveData(string sKey)
        {
            m_realCache.RemoveData(sKey);
        }
        public virtual void BulkRemoveData(string[] sKeys)
        {
            m_realCache.BulkRemoveData(sKeys);
        }
    }

public class TestCache : MockAccelCache
{
    private Dictionary<string, byte[]> m_Items;

    public TestCache()
    {
        m_Items = new Dictionary<string, byte[]>();
        
    }

    public override void PublishData(string sKey, byte[] rgbValue, Object keyState)
    {
        BulkPublishData(new string[] { sKey }, new byte[][] { rgbValue }, new Object[] { keyState }, null);
    }

    public override uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version)
    {
        uint[] versions = new uint[]{version};
        uint[] retVals = BulkPublishData(new string[] { sKey }, new byte[][] { rgbValue }, new Object[] { keyState }, versions);
        version = versions[0];
        return retVals[0];
    }

    public override byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
    {
        uint[] rgVersions = new uint[rgKeys.Length];
        return BulkRequestData(rgKeys, rgKeyStates, out rgVersions);
    }
    
    public override byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions)
    {
        rgVersions = new uint[20];
        byte[][] rgbValues = new byte[rgKeys.Length][];
        for (int i = 0; i < rgKeys.Length; i++)
        {
            byte[] value;
            if (m_Items.TryGetValue(rgKeys[i], out value))
            {
                rgbValues[i] = value;
            }
            rgVersions[i] = 0;
        }
        return rgbValues;

    }

    public override uint[] BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates, uint[] rgVersions)
    {
        uint[] retvals = new uint[rgKeys.Length];
        BulkRemoveData(rgKeys);
        for (int i = 0; i < rgKeys.Length; i++)
        {
            m_Items.Add(rgKeys[i], rgbValues[i]);
            retvals[i] = HResult.S_OK;
        }

        return retvals;
    }

    public override void RemoveData(string sKey)
    {
        BulkRemoveData(new string[] { sKey });
    }

    public override void BulkRemoveData(string[] sKeys)
    {
        for (int i = 0; i < sKeys.Length; i++)
        {
            m_Items.Remove(sKeys[i]);
        }
    }

    public bool VerifyCacheEntry(string sKey, out byte[] rgbValue)
    {
        return m_Items.TryGetValue(sKey, out rgbValue);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\CacheUtilTests.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;


using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol.SubNoti;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using STFUtil = ServerTestFramework.Utilities;
using xonline.common.stfutil;
using xonline.server.XConnSrv;

namespace xonline.common.community.test.dvt
{
    [TestGroup, DVT]
    public class CacheUtilDVT : TestNode
	{
        public IMemCache cache;
        [TestGroupSetup]
        public void Setup()
        {
            cache = new TestCache();
            CacheUtil.SetNotiCache(cache);
            CacheUtil.SetPresCache(cache);
        }

        [TestGroupTearDown]
        public void TearDown()
        {
        }

        [TestCase]
        public void GetBasicPresenceKey()
        {
            Global.RO.Info("GetBasicPresenceKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eBasicPresence", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eBasicPresence, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetBasicPresenceKey - Complete");

        }

        [TestCase]
        public void GetRichPresenceKey()
        {
            Global.RO.Info("GetRichPresenceKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eRichPresenceString", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eRichPresenceString, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetRichPresenceKey - Complete");
        }

        [TestCase]
        public void GetFriendsListKey()
        {
            Global.RO.Info("GetFriendsListKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eFriendsList", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eFriendsList, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetFriendsListKey - Complete");
        }

        [TestCase]
        public void GetPresenceRecordKey()
        {
            Global.RO.Info("GetPresenceRecordKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eInternalPresence", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetPresenceRecordKey - Complete");
        }

        [TestCase]
        public void GetMachineUserListKey()
        {
            Global.RO.Info("GetMachineUserListKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            xonline.common.protocol.SGADDR sgaddr = new xonline.common.protocol.SGADDR();
            sgaddr.inaSg = u1.Xbox.IpSg;
            sgaddr.dwSpiSg = u1.Xbox.SpiSg;
            ulong qw = (sgaddr.inaSg << 32) | (sgaddr.dwSpiSg);

            string sExpected = BuildExpectedKey("eMachineUserList", qw);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eMachineUserList, qw);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetMachineUserListKey - Complete");
        }

        [TestCase]
        public void GetUserPrivilegesKey()
        {
            Global.RO.Info("GetUserPrivilegesKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eUserPrivileges", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eUserPrivileges, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetUserPrivilegesKey - Complete");
        }

        [TestCase]
        public void GetNeverListKey()
        {
            Global.RO.Info("GetNeverListKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eUserNeverList", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eUserNeverList, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetNeverListKey - Complete");
        }

        [TestCase]
        public void GetTransientMessagesKey()
        {
            Global.RO.Info("GetTransientMessagesKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eTransientMessages", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eTransientMessages, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetTransientMessagesKey - Complete");
        }

        [TestCase]
        public void GetInvitationKey()
        {
            Global.RO.Info("GetInvitationKey");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            string sExpected = BuildExpectedKey("eInvitation", u1.UserId);

            string sResult = CacheUtil.BuildCacheKey(DATA_TYPES.eInvitation, u1.UserId);
            Assert.AreEqual(sExpected, sResult);

            Global.RO.Info("GetInvitationKey - Complete");
        }

        [TestCase]
        public void WriteAndReadPresenceRecord()
        {
            Global.RO.Info("WriteAndReadPresenceRecord");

            FriendsCommon fc = new FriendsCommon();
            PNUser user = fc.CreateXenonUser(true);
            
            PresenceRecord testItem = new PresenceRecord();
            testItem = new PresenceRecord();
            testItem.OwnerID = user.UserId;
            testItem.dtLastSeen = DateTime.Now;
            testItem.sGamertag = user.Name;
            testItem.sgaddr = new xonline.common.protocol.SGADDR();

            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, testItem.OwnerID);
            
            uint result = CacheUtil.WriteToCache(testItem);
            Assert.AreEqual(result, HResult.S_OK);
            
            byte[] rgbResults;
            bool fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out rgbResults);
            Assert.IsTrue(fFound);
            PresenceRecord resultItem = new PresenceRecord();
            resultItem.ReadBytes(rgbResults);
            Assert.AreEqual(resultItem.OwnerID, testItem.OwnerID);
            Assert.AreEqual(resultItem.sGamertag, testItem.sGamertag);
            //Assert.AreEqual(resultItems[i].dtLastSeen, testItems[i].dtLastSeen);
            Assert.AreEqual(resultItem.sgaddr, testItem.sgaddr);
            
            Global.RO.Info("ReadFromCache");

            resultItem = (PresenceRecord)CacheUtil.ReadFromCache(sKey);

            Assert.AreEqual(resultItem.OwnerID, testItem.OwnerID);
            //Assert.AreEqual(resultItems[i].dtLastSeen, testItems[i].dtLastSeen);
            Assert.AreEqual(resultItem.sgaddr, testItem.sgaddr);

            Global.RO.Info(resultItem.ToString());
            
            Global.RO.Info("ReadFromCache with cache miss");

            PresenceRecord missedItem = (PresenceRecord)CacheUtil.ReadFromCache(CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, 1));
            Assert.AreEqual(missedItem, null);

            Global.RO.Info("WriteAndReadPresenceRecord - Complete");
        }

        [TestCase]
        public void WriteAndReadBasicPresence()
        {
            Global.RO.Info("WriteAndReadBasicPresence");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            //// build a byte array from basic presence data
            //byte[] rgbCacheData;
            //int offsetGT;
            //unsafe
            //{
            //    rgbCacheData = new byte[sizeof(BASIC_PRESENCE_DATA)];
            //    fixed (byte* pBuf = rgbCacheData)
            //    {
            //        BASIC_PRESENCE_DATA* pBasic = (BASIC_PRESENCE_DATA*)pBuf;
            //        pBasic->header.doSpec.qwOwnerXUID = u1.UserId;
            //        pBasic->header.doSpec.wDataType = (ushort)DATA_TYPES.eBasicPresence;
            //        pBasic->header.doSpec.wObjectSize = (ushort)rgbCacheData.Length;
            //        pBasic->mtLastSeen = MsgDefs.DateTimeToMsgTime(DateTime.Now);
            //        offsetGT = (int)((byte*)&(pBasic->gt_reserved1) - pBuf);
            //    }
            //}

            //byte[] rgbGT = Encoding.Unicode.GetBytes(u1.Name);
            //Buffer.BlockCopy(rgbGT, 0, rgbCacheData, offsetGT, rgbGT.Length);

            Global.RO.Info("WriteBasicPresence");

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord presRecord = PresenceRecord.Init(u1.UserId, u1.Name, u1.TitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));
            
            BasicPresence basicExpected = new BasicPresence();
            basicExpected.OwnerID = u1.UserId;
            basicExpected.sGamertag = u1.Name;
            basicExpected.dwTitleID = u1.TitleId;
            basicExpected.header.doSpec.wObjectSize = (ushort)basicExpected.Size(); // serialize to fill in wObjectSize
            basicExpected.HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE : 0;
            basicExpected.HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS : 0;

            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eBasicPresence, presRecord.OwnerID);

            Global.RO.Info("ReadFromNotificationCache");

            BasicPresence cacheReturnValue = (BasicPresence)CacheUtil.ReadFromCache(sKey);

            //byte[] resultValue;
            //bool fFound;
            //fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out resultValue);
            //Assert.IsTrue(fFound);
            //Assert.AreEqual(resultValue, (byte[])basicExpected);

            Assert.AreEqual(basicExpected, cacheReturnValue);

            Global.RO.Info(cacheReturnValue.ToString());

            Global.RO.Info("WriteToAndReadFromNotificationCache - Complete");

        }

        [TestCase]
        public void WriteAndReadRichPresence()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord presRecord = PresenceRecord.Init(u1.UserId, u1.Name, u1.TitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));

            presRecord.SetState(u1.TitleId, 1, 0, new byte[8], new string[] { "en-US", "fr-FR", "jp-JP", "zh-CHT" }, new string[] { "english", "french", "japanese", "chinese" }, presRecord.sgaddr);

            LanguageSpecificData lsBlob = (LanguageSpecificData)CacheUtil.ReadFromCache(CacheUtil.BuildCacheKey(DATA_TYPES.eRichPresenceString, u1.UserId));
            Global.RO.Info(lsBlob.ToString());

            FriendsList friends = FriendsListUtil.GetFriendsListForXuid(u1.UserId);
            string sRp = PresenceUtil.GetRichPresenceStringForUsers(friends, new string[] { "jp-JP" }, new ulong[] { u1.UserId })[0];
            Assert.AreEqual("japanese", sRp);
            
        }

        [TestCase]
        public void PrintAllCacheObjectTypes()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord presRecord = PresenceRecord.Init(u1.UserId, u1.Name, u1.TitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));

            presRecord.SetState(u1.TitleId, PresDefs.P_STATE_FLAG_ONLINE, 0, new byte[8], new string[] { "en-US", "fr-FR", "jp-JP", "zh-CHT" }, new string[] { "english", "french", "japanese", "chinese" }, presRecord.sgaddr);

            FriendsListUtil.MakeFriends(u1.UserId, u2.UserId, u1.Name, u2.Name);

            LanguageSpecificData lsBlob = (LanguageSpecificData)CacheUtil.ReadFromCache(CacheUtil.BuildCacheKey(DATA_TYPES.eRichPresenceString, u1.UserId));

            FriendsList friends = FriendsListUtil.GetFriendsListForXuid(u1.UserId);

            BasicPresence basic = PresenceUtil.GetBasicPresenceForUsers(friends, new ulong[] { u1.UserId })[0];

            UserQueue uq = new UserQueue(u1.UserId, (ushort)P_QUEUE_TYPES.PQUEUE_LIST_CHANGE);

            MessagingData msgData = MessagingUtil.GetMessagingDataRecord(u1.UserId);

            MachineUserList muList = PresenceUtil.GetMachineUserList(presRecord.sgaddr);

            Global.RO.Info("Presence Record:\r\n" + presRecord.ToString());
            Global.RO.Info("User Privileges:\r\n" + privs.ToString());
            Global.RO.Info("Basic Presence:\r\n" + basic.ToString());
            Global.RO.Info("Rich Presence:\r\n" + lsBlob.ToString());
            Global.RO.Info("Friends List:\r\n" + friends.ToString());            
            Global.RO.Info("User Queue:\r\n" + uq.ToString());
            Global.RO.Info("Messaging Data:\r\n" + msgData.ToString());
            Global.RO.Info("Machine User List:\r\n" + muList.ToString());

        }

        [TestCase]
        public void RemoveFromCache()
        {
            Global.RO.Info("RemoveFromCache");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord presRecord = PresenceRecord.Init(u1.UserId, u1.Name, u1.TitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, presRecord.OwnerID);

            // Add item to cache
            CacheUtil.WriteToCache(presRecord);

            // Remove item
            CacheUtil.RemoveFromCache(sKey);

            // Verify item no longer in cache
            byte[] resultValue;
            bool fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out resultValue);
            Assert.IsTrue(!fFound);

            // ReadFromPresenceCache should return null
            PresenceRecord result = (PresenceRecord)CacheUtil.ReadFromCache(sKey);
            Assert.AreEqual(null, result);

            Global.RO.Info("RemoveFromPresenceCache - Complete");

        }

        [TestCase]
        public void IsDataAccessible()
        {
            Global.RO.Info("IsDataAccessible");

            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateXenonUser(true);
            PNUser u2 = fc.CreateXenonUser(true);

            // Same user should return true
            bool fResult = CacheUtil.IsDataAccessible(u1.UserId, u1.UserId, 0, AreNotFriends);
            Assert.IsTrue(fResult);

            // Share everyone flag set - should return true for non-friends
            uint dwFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
            fResult = CacheUtil.IsDataAccessible(u1.UserId, u2.UserId, dwFlags, AreNotFriends);
            Assert.IsTrue(fResult);

            // Share everyone flag not set - should return false for non friends
            dwFlags = 0;
            fResult = CacheUtil.IsDataAccessible(u1.UserId, u2.UserId, dwFlags, AreNotFriends);
            Assert.IsTrue(!fResult);

            // Share friends flag set - should return false for non friends
            dwFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;
            fResult = CacheUtil.IsDataAccessible(u1.UserId, u2.UserId, dwFlags, AreNotFriends);
            Assert.IsTrue(!fResult);

            // Share friends flag set - should return true for friends
            fResult = CacheUtil.IsDataAccessible(u1.UserId, u2.UserId, dwFlags, AreFriends);
            Assert.IsTrue(fResult);

        }

        private string BuildExpectedKey(string sDataType, ulong userId)
        {
            return BuildExpectedKey(sDataType, userId, 0);
        }

        private string BuildExpectedKey(string sDataType, ulong userId, uint dwSubType)
        {
            return String.Join(":", new string[]{
                sDataType, 
                userId.ToString("X"), 
                dwSubType.ToString("X")});
        }

        private bool AreFriends(ulong user1, ulong user2)
        {
            return true;
        }

        private bool AreNotFriends(ulong user1, ulong user2)
        {
            return false;
        }

    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\community\dvt\PresenceUtilTests.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;


using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol.SubNoti;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Core.Utilities;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using STFUtil = ServerTestFramework.Utilities;
using xonline.common.stfutil;
using xonline.server.XConnSrv;


namespace xonline.common.community.test.dvt
{
    [TestGroup, Owner("rakern"), TestFrequency("Daily"), EnvRequirement("DVT")]
    public class PresenceUtilDVT : TestNode
    {
        public IMemCache cache;
        [TestGroupSetup]
        public void Setup()
        {
            cache = new TestCache();
            CacheUtil.SetNotiCache(cache);
            CacheUtil.SetPresCache(cache);
        }

        [TestGroupTearDown]
        public void TearDown()
        {
        }

        [TestCase]
        public void LoadOfflinePresenceFromDatabase()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(false);
            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord record = PresenceRecord.Init(u1.UserId, u1.Name, FriendsCommon.DefaultXenonTitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));

            PresenceRecord offlineRecord = PresenceRecord.LoadOfflinePresenceFromDatabase(u1.UserId);
            Assert.AreEqual(offlineRecord.OwnerID, u1.UserId);
            Assert.AreEqual(offlineRecord.sGamertag, u1.Name);
        }

        [TestCase]
        public void UpdateNameAll()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            string newName = String.Concat(u1.Name, "1");

            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord.Init(u1.UserId, u1.Name, FriendsCommon.DefaultXenonTitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));
            HResult hr = PresenceUtil.UpdateNameAll(u1.UserId, newName);
            
            Assert.AreEqual(hr, HResult.S_OK);
            PresenceRecord record = PresenceRecord.LoadOfflinePresenceFromDatabase(u1.UserId);
            Assert.AreEqual(newName, record.sGamertag);

        }

        [TestCase]
        public void GetNeverList()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong[] nevers = new ulong[2];
            BuildNeverList(u1.UserId, nevers);

            PresenceUtil.AddUsersToNeverList(u1.UserId, nevers);

            NeverList neverListForUser = PresenceUtil.GetNeverList(u1.UserId);
            Assert.IsTrue(neverListForUser != null);
            Assert.IsTrue(neverListForUser.rgNevers != null);
            
            for (int i = 0; i < neverListForUser.rgNevers.Length; i++)
            {
                Assert.AreEqual(nevers[i], neverListForUser.rgNevers[i]);
                Assert.IsTrue(neverListForUser.ContainsUser(nevers[i]));
            }
        }

        [TestCase]
        public void RemoveUsersFromNeverList()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong[] nevers = new ulong[5];
            BuildNeverList(u1.UserId, nevers);

            ulong[] usersToRemove = new ulong[2];
            usersToRemove[0] = nevers[1];
            usersToRemove[1] = nevers[3];

            PresenceUtil.RemoveUsersFromNeverList(u1.UserId, usersToRemove);
            NeverList resultList = PresenceUtil.GetNeverList(u1.UserId);
            Assert.IsTrue(resultList != null);
            Assert.IsTrue(resultList.rgNevers != null);
            Assert.AreEqual(nevers[0], resultList.rgNevers[0]);
            Assert.AreEqual(nevers[2], resultList.rgNevers[1]);
            Assert.AreEqual(nevers[4], resultList.rgNevers[2]);
        }

        [TestCase]
        public void WriteAndPurgeNeverListFromCache()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong[] nevers = new ulong[5];
            BuildNeverList(u1.UserId, nevers);
            NeverList neverList = PresenceUtil.GetNeverList(u1.UserId);
            PresenceUtil.WriteNeverListToCache(neverList);

            // verify never list was written to cache
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eUserNeverList, neverList.OwnerID);
            byte[] rgbResults;
            bool fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out rgbResults);
            Assert.IsTrue(fFound);

            // purge, then verify never list is not in cache
            PresenceUtil.PurgeNeverListFromCache(u1.UserId);
            fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out rgbResults);
            Assert.IsTrue(!fFound);
            
        }

        [TestCase]
        public void CreateAndClearAnyInvitation()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong sessionId = 0x1000000000000000;
            ulong[] invitees = new ulong[3];
            PNUser user;
            for (int i = 0; i < 3; i++)
            {
                user = fc.CreateUser(true);
                invitees[i] = user.UserId;
            }

            ulong[] resultInvitees = PresenceUtil.CreateOrAddInvite(u1.UserId, FriendsCommon.DefaultXenonTitleId, sessionId, invitees);

            Assert.AreEqual(invitees.Length, resultInvitees.Length);
            for (int i = 0; i < resultInvitees.Length; i++)
            {
                Assert.AreEqual(invitees[i], resultInvitees[i]);
            }

            PresenceUtil.PreserveSpecificInvitation(u1.UserId, 0);
            // verify invitation was removed from cache
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInvitation, u1.UserId);
            Invitation emptyInv = (Invitation)CacheUtil.ReadFromCache(sKey);
            Assert.IsTrue(emptyInv.qwMatchSessionID == 0);
            Assert.IsTrue(emptyInv.cInvitees == 0);

        }

        [TestCase]
        public void CreateAndClearSpecificInvitation()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong sessionId = 0x1000000000000000;
            ulong[] invitees = new ulong[3];
            PNUser user;
            for (int i = 0; i < 3; i++)
            {
                user = fc.CreateUser(true);
                invitees[i] = user.UserId;
            }

            ulong[] resultInvitees = PresenceUtil.CreateOrAddInvite(u1.UserId, FriendsCommon.DefaultXenonTitleId, sessionId, invitees);

            Assert.AreEqual(invitees.Length, resultInvitees.Length);
            for (int i = 0; i < resultInvitees.Length; i++)
            {
                Assert.AreEqual(invitees[i], resultInvitees[i]);
            }

            PresenceUtil.ClearSpecificInvitation(u1.UserId, sessionId);
            // verify invitation was removed from cache
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInvitation, u1.UserId);
            Invitation emptyInv = (Invitation)CacheUtil.ReadFromCache(sKey);
            Assert.IsTrue(emptyInv.qwMatchSessionID == 0);
            Assert.IsTrue(emptyInv.cInvitees == 0);

        }

        [TestCase]
        public void RemoveInvitees()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            ulong sessionId = 0x1000000000000000;
            ulong[] invitees = new ulong[3];
            PNUser user;
            for (int i = 0; i < 3; i++)
            {
                user = fc.CreateUser(true);
                invitees[i] = user.UserId;
            }

            ulong[] resultInvitees = PresenceUtil.CreateOrAddInvite(u1.UserId, FriendsCommon.DefaultXenonTitleId, sessionId, invitees);

            bool inviteesChanged = PresenceUtil.RemoveInvitees(u1.UserId, new ulong[] { resultInvitees[2] }, sessionId);

            Assert.IsTrue(inviteesChanged);

            // invitation should still be in cache for remaining invitees
            string sKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInvitation, u1.UserId);
            byte[] rgbResults;
            bool fFound = ((TestCache)cache).VerifyCacheEntry(sKey, out rgbResults);
            Assert.IsTrue(fFound);

        }

        [TestCase]
        public void PurgeUser()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            PresenceRecord.Init(u1.UserId, u1.Name, FriendsCommon.DefaultXenonTitleId, new xonline.common.protocol.SGADDR(), privs, new SGInfo(0, 0, 0));

            // Init will write basic presence, limited presence, and rich presence to the cache. Purge then check that they are gone
            PresenceUtil.PurgeUser(u1.UserId);

            string presenceKey = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u1.UserId);
            byte[] rgbResults;
            bool itemFound = ((TestCache)cache).VerifyCacheEntry(presenceKey, out rgbResults);
            Assert.IsTrue(!itemFound);
            presenceKey = CacheUtil.BuildCacheKey(DATA_TYPES.eRichPresenceString, u1.UserId);
            itemFound = ((TestCache)cache).VerifyCacheEntry(presenceKey, out rgbResults);
            Assert.IsTrue(!itemFound);
            
        }

        [TestCase]
        public void AddGetRemoveAffiliates()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(true);
            PNUser user;
            ulong[] affiliates = new ulong[5];
            for (int i = 0; i < affiliates.Length; i++)
            {
                user = fc.CreateUser(true);
                affiliates[i] = user.UserId;
            }

            PresenceUtil.AddAffiliates(u1.UserId, PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX, affiliates, FriendsCommon.DefaultXenonTitleId, MsgDefs.DateTimeToMsgTime(DateTime.UtcNow));
            Affiliate[] returnedAffiliates = PresenceUtil.GetAffiliates(u1.UserId, PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX);
            Assert.IsTrue(returnedAffiliates != null);
            Assert.AreEqual(affiliates.Length, returnedAffiliates.Length);
            ulong[] returnedXuids = new ulong[affiliates.Length];
            for (int i = 0; i < affiliates.Length; i++)
            {
                returnedXuids[i] = returnedAffiliates[i].qwAffiliateID;
            }
            // need to sort both lists before comparison; verification of correct sorting of affiliates is handled in the AffiliateList dvt
            Array.Sort(affiliates);
            Array.Sort(returnedXuids);
            for (int i = 0; i < affiliates.Length; i++)
            {
                Assert.AreEqual(affiliates[i], returnedXuids[i]);
            }

            // now add to negative list and verify users are removed from positive list
            PresenceUtil.AddAffiliates(u1.UserId, PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX, affiliates, FriendsCommon.DefaultXenonTitleId, MsgDefs.DateTimeToMsgTime(DateTime.UtcNow));
            Affiliate[] negativeAffiliates = PresenceUtil.GetAffiliates(u1.UserId, PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX);
            Assert.IsTrue(negativeAffiliates != null);
            Assert.AreEqual(affiliates.Length, negativeAffiliates.Length);
            ulong[] negativeXuids = new ulong[affiliates.Length];
            for (int i = 0; i < affiliates.Length; i++)
            {
                negativeXuids[i] = negativeAffiliates[i].qwAffiliateID;
            }

            Array.Sort(negativeXuids);
            for (int i = 0; i < affiliates.Length; i++)
            {
                Assert.AreEqual(affiliates[i], negativeXuids[i]);
            }

            Affiliate[] noAffiliates = PresenceUtil.GetAffiliates(u1.UserId, PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX);
            Assert.IsTrue(noAffiliates != null);
            Assert.AreEqual(0, noAffiliates.Length);

        }

        [TestCase]
        public void TestXOnWatchIPs()
        {
            IPAddress ipZero = IPAddress.Parse("0.0.0.0");
            Global.RO.Info("testing zero {0} ...", ipZero.ToString());
            Assert.IsTrue(!PresenceUtil.IsXOnWatchIP(ipZero));

            // taken from an xblob t_settings, Setting.presence_XonWatchIPs
            string[] rgIps = {"65.59.233.112", "255.255.255.240", "131.107.19.36", "255.255.255.252", "131.107.19.40", "255.255.255.252", "131.107.62.222", "255.255.255.254", "131.107.62.226", "255.255.255.254", "131.107.62.240", "255.255.255.254", "131.107.215.132", "255.255.255.252"};

            for (int iIp = 0; iIp < rgIps.Length / 2; iIp++)
            {
                IPAddress ip = IPAddress.Parse(rgIps[iIp * 2]);
                IPAddress mask = IPAddress.Parse(rgIps[(iIp * 2) + 1]);

                uint dwmask = BitConverter.ToUInt32(mask.GetAddressBytes(), 0);
                uint dwinvmask = ~dwmask;
                uint dwcount = (uint)IPAddress.NetworkToHostOrder((int)dwinvmask);

                uint dwip = BitConverter.ToUInt32(ip.GetAddressBytes(), 0);

                // test every xonwatch root ip, and every ip in its subnet mask.
                for (uint iOffset = 0; iOffset <= dwcount; iOffset++)
                {
                    uint dwTestIp = (dwip & dwmask) | (uint)IPAddress.HostToNetworkOrder((int)iOffset);
                    IPAddress testIp = new IPAddress(dwTestIp);

                    Global.RO.Info("testing xonwatchip {0} ...", testIp.ToString());
                    Assert.IsTrue(PresenceUtil.IsXOnWatchIP(testIp));
                }
            }

            // test some random ips.  dumb luck may cause this to fail if we happen to randgen a real xonwatch ip.
            for (int iTest = 0; iTest < 100; iTest++)
            {
                IPAddress testIp = new IPAddress(RandomEx.GlobalRandGen.Next());
                Global.RO.Info("testing random {0} ...", testIp.ToString());
                Assert.IsTrue(!PresenceUtil.IsXOnWatchIP(testIp));
            }
        }

        [TestCase]
        public void TitleChange0Nonce()
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser u1 = fc.CreateUser(false);
            UserPrivileges privs = PresenceUtil.GetUserPrivileges(u1.UserId);
            xonline.common.protocol.SGADDR addr =  new xonline.common.protocol.SGADDR();
            PresenceRecord record = PresenceRecord.Init(u1.UserId, u1.Name, FriendsCommon.DefaultXenonTitleId, addr, privs, new SGInfo(0, 0, 0));
            //set the record to get in to titlestart
            record.mtTitleStart = 0; //setting start time to 0. dwTitle doesn't matter yet. We are considering this as a new beginning.

            //set the params and invoke
            uint newTitleId = FriendsCommon.XenonDashTitleId ; //get in to the dash  title.
            List<string> logLines = new List<string>();
            object[] mparams = new object[]{newTitleId, new SGInfo(0, 0, 0), addr, logLines};
            ExecutePrivateMethod(record, "RecordTitleChange", mparams);

            //There should be one logline for TITLESTART
            Assert.IsTrue(logLines.Count == 1);
            // LineType|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey|Duration(ms)|States|Dequeues
            //"TITLESTART|0|20B00002|9000000003000|5|0|0|E2C9DE1"
            //string expected = "TITLESTART|"+ addr.qwXboxId.ToString()+newTitleId.ToString()+record.OwnerID.ToString()+record.dwState+record.ipaXbox.ToString()+record.ipportXbox.ToString()+record.mtTitleStart.ToString()+
            Assert.IsTrue(logLines[0].ToString().Contains("TITLESTART") == true);
            Assert.IsTrue(logLines[0].ToString().Contains("TITLEND") == false);
            Assert.IsTrue(logLines[0].ToString().Contains("TITLESTART2") == false);
            Assert.IsTrue(record.mtTitleStart != 0); //verify that start time is set now.

            //clear logs.
            logLines.Clear();

            //go back to title Default and invoke
            newTitleId = FriendsCommon.DefaultXenonTitleId;
            logLines = new List<string>();
            mparams = new object[] { newTitleId, new SGInfo(0, 0, 0), addr, logLines };
            ExecutePrivateMethod(record, "RecordTitleChange", mparams);

            //Now there should be two lines. for stop and start.
            Assert.IsTrue(logLines.Count == 2);
            //line 0 should be titlend
            Assert.IsTrue(logLines[0].ToString().Contains("TITLSTART") == false);
            Assert.IsTrue(logLines[0].ToString().Contains("TITLEND2") == false);
            //line 1 should be titlestart
            Assert.IsTrue(logLines[1].ToString().Contains("TITLEND") == false);
            Assert.IsTrue(logLines[1].ToString().Contains("TITLESTART2") == false);
            Assert.IsTrue(record.mtTitleStart != 0);
        }

        private object ExecutePrivateMethod(object instance, string name, params object[] paramList)
        {
            Type t = instance.GetType();
            Type[] paramTypes = new Type[paramList.Length];

            for (int i = 0; i < paramList.Length; i++)
            {
                paramTypes[i] = paramList[i].GetType();
            }

            MethodInfo m = t.GetMethod(name, BindingFlags.Instance
            | BindingFlags.NonPublic
            | BindingFlags.Public,
            null,
            paramTypes,
            null);

            return m.Invoke(instance, paramList);
        }
        private void BuildNeverList(ulong userId, ulong[] nevers)
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser neverUser;
            for (int i = 0; i < nevers.Length; i++)
            {
                neverUser = fc.CreateUser(true);
                nevers[i] = neverUser.UserId;
            }

            PresenceUtil.AddUsersToNeverList(userId, nevers);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConfigDevTest_Constants.cs ===
namespace ServerTestFramework.LiveService.common.config
{
    public class TestComponents
    {
        public const string dummy_component1 = "dummy_component1";
        public const string dummy_component2 = "dummy_component2";
        public const string dummy_component3 = "dummy_component3";
        public const string dummy_component4 = "dummy_component4";
        public const string dummy_component5 = "dummy_component5";
        public const string dummy_component11 = "dummy_component11";
        public const string dummy_component12 = "dummy_component12";
        public const string dummy_component13 = "dummy_component13";
        public const string dummy_component14 = "dummy_component14";
        public const string dummy_component15 = "dummy_component15";
        public const string dummy_component16 = "dummy_component16";
        public const string dummy_component17 = "dummy_component17";
    }

    public class TestInterfaces
    {
        public const string dummy_interface1A = "dummy_interface1A";
        public const string dummy_interface1B = "dummy_interface1B";
        public const string dummy_interface1C = "dummy_interface1C";
        public const string dummy_interface1D = "dummy_interface1D";
        public const string dummy_interface1E = "dummy_interface1E";
        public const string dummy_interface1F = "dummy_interface1F";
        public const string dummy_interface1G = "dummy_interface1G";
        public const string dummy_interface2A = "dummy_interface2A";
        public const string dummy_interface2B = "dummy_interface2B";
        public const string dummy_interface2C = "dummy_interface2C";
        public const string dummy_interface2D = "dummy_interface2D";
        public const string dummy_interface2E = "dummy_interface2E";
        public const string dummy_interface2F = "dummy_interface2F";
        public const string dummy_interface2G = "dummy_interface2G";
        public const string dummy_interface3A = "dummy_interface3A";
        public const string dummy_interface3B = "dummy_interface3B";
        public const string dummy_interface4 = "dummy_interface4";
        public const string dummy_interface5 = "dummy_interface5";
        public const string dummy_interface6 = "dummy_interface6";

    }

    public class TestVirtualInterfaces
    {
        public const string dummy_vinterface1A = "dummy_vinterface1A";
        public const string dummy_vinterface1B = "dummy_vinterface1B";
        public const string dummy_vinterface1C = "dummy_vinterface1C";
        public const string dummy_vinterface1D = "dummy_vinterface1D";
        public const string dummy_vinterface1E = "dummy_vinterface1E";
        public const string dummy_vinterface1F = "dummy_vinterface1F";
        public const string dummy_vinterface1G = "dummy_vinterface1G";
        public const string dummy_vinterface2A = "dummy_vinterface2A";
        public const string dummy_vinterface2B = "dummy_vinterface2B";
        public const string dummy_vinterface2C = "dummy_vinterface2C";
        public const string dummy_vinterface2D = "dummy_vinterface2D";
        public const string dummy_vinterface2E = "dummy_vinterface2E";
        public const string dummy_vinterface2F = "dummy_vinterface2F";
        public const string dummy_vinterface2G = "dummy_vinterface2G";
        public const string dummy_vinterface5 = "dummy_vinterface5";
    }

    public class TestSettings
    {
        public const string configunittest_setting1 = "configunittest_setting1";
        public const string configunittest_setting2 = "configunittest_setting2";
        public const string configunittest_setting3 = "configunittest_setting3";
        public const string configunittest_setting4 = "configunittest_setting4";
        public const string configunittest_setting5 = "configunittest_setting5";
        public const string configunittest_setting11 = "configunittest_setting11";
        public const string configunittest_setting12 = "configunittest_setting12";
        public const string configunittest_setting13 = "configunittest_setting13";
        public const string configunittest_setting14 = "configunittest_setting14";
        public const string configunittest_setting15 = "configunittest_setting15";
        public const string configunittest_setting16 = "configunittest_setting16";
        public const string configunittest_setting17 = "configunittest_setting17";
        public const string configunittest_setting_missing = "configunittest_setting_missing";
    }

    public class TestMultiSettings
    {
        public const string configunittest_multisetting1 = "configunittest_multisetting1";
        public const string configunittest_multisetting2 = "configunittest_multisetting2";
        public const string configunittest_multisetting3 = "configunittest_multisetting3";
        public const string configunittest_multisetting4 = "configunittest_multisetting4";
        public const string configunittest_multisetting5 = "configunittest_multisetting5";
        public const string configunittest_multisetting11 = "configunittest_multisetting11";
        public const string configunittest_multisetting12 = "configunittest_multisetting12";
        public const string configunittest_multisetting13 = "configunittest_multisetting13";
        public const string configunittest_multisetting14 = "configunittest_multisetting14";
        public const string configunittest_multisetting15 = "configunittest_multisetting15";
        public const string configunittest_multisetting16 = "configunittest_multisetting16";
        public const string configunittest_multisetting17 = "configunittest_multisetting17";
        public const string configunittest_multisetting_missing = "configunittest_multisetting_missing";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConnectionSettingsPerf.cs ===
using System;
using System.Data.SqlClient;
using System.Threading;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.diagnostics;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.stfutil;

[assembly: RootNode(typeof(ServerTestFramework.LiveService.common.config.ConnnectionStringPerf))]

namespace ServerTestFramework.LiveService.common.config
{
    /// <summary>
    ///      <TestSuite>SQL Connnection String configuration parameter testing</TestSuite>
    ///        <Tester>Jon Fleming</Tester>
    ///        <Developer>Stephane Plante</Developer>
    ///        <PM>Jason Ronald</PM>
    /// </summary>
    /// <remarks>
    ///        <Goal>Confirm that connection parameters found in SQL connection strings actually do something</Goal>
    ///        <NonGoal>The basic infrastructure of the configuration parameter storage is not tested here.</NonGoal>
    ///        <Description>
    ///                <p>
    ///                        Lots of interesting tests.
    ///                </p>
    ///      </Description>
    /// </remarks>
    public class ConnnectionStringPerf : TestNode
    {

    }

    /// <HighLevel>
    ///       [This suite confirms that the new configuration parameters for SQL connection strings take affect as observed in perf counters.] 
    /// </HighLevel>
    /// <Goals>
    ///       [Confirm that adding rows to the new SQL Connection String parameter table affects the way connections are made to the SQL server.]
    /// </Goals>
    /// <NonGoals>
    ///       [Basic unit testing is not a part of this suite.]
    /// </NonGoals>
    /// <Implementation>
    ///       [See Test Plan for Connection Pool Configurtation Settings]
    /// </Implementation>
    [TestGroup]
    public class ConnnectionStringEfficacy : TestNode
    {
        internal string _testServer;
        internal string _szConnectionString;
        internal const string _szComponent = "npdb";
        internal const string _szInterface = "npdb";

        internal const string _perfCategory = ".NET Data Provider for SqlServer";
        internal const string _perfNumPools = "NumberOfActiveConnectionPools";
        internal const string _perfNumPooledConnections = "NumberOfPooledConnections";
        internal const string _perfNumActiveConnections = "NumberOfActiveConnections";
        internal const string _perfNumFreeConnections = "NumberOfFreeConnections";
        internal const string _perfNumConnsPerSec = "SoftConnectsPerSecond";
        internal const string _perfNumDisconnsPerSec = "SoftDisconnectsPerSecond";

        int _numCurrentThreads = 0;
        int _numThreads = 0;
        int _duration = 0;

        /// <summary>
        ///       [Test a valid connection string]
        /// </summary>
        /// <remarks>
        ///    <description>
        ///            [This is a happy path test case.]
        ///     </desription>
        ///     <scenarios>
        ///             [This test is for original implementation and regression]
        ///     </scenarios>
        ///     <section name="Notes">
        ///             [None.]
        ///     </section>
        ///     <dependencies>
        ///             [NPDB database is required.]
        /// 
        ///     Also note that the following settings must exist in the <configuration> section of the stfgui.exe.config file,
        ///     in order to enable the off-by-default "NumberOfActiveConnections" performance counter (among others).  
        ///     The automated test does not depend on these counters, but they are useful for manual troubleshooting.
        /// 
        ///     See http://msdn.microsoft.com/en-us/library/ms254503.aspx for details on these performance counters.
        /// 
        ///     <system.diagnostics>
	    ///         <switches>
		///             <add name="ConnectionPoolPerformanceCounterDetail" value="4"/>
	    ///         </switches>
        ///     </system.diagnostics>
        /// 
        ///     </dependencies>
        /// </remarks>
        [TestCase, Description("Confirm that 10 Connections are created")]
        public void CheckConnectionString1()
        {
            // straight up easy case where we expect 10 connections to be created
            StressConnectionString(
                0, // minPoolSize = 0
                100, // maxPoolSize = 100
                20000, // connection timeout = 20 seconds
                30000, // load balance timeout = 30 seconds
                10, // number of connections = 10
                10 // duration of connections = 10 seconds
                );
        }

        [TestCase, Description("Confirm that 20 connections are created, 10 being empty.")]
        public void CheckConnectionString2()
        {
            // Set the minimum number of connections to 20, and make sure that many are created.
            StressConnectionString(
                20, // minPoolSize = 0
                100, // maxPoolSize = 100
                20000, // connection timeout = 20 seconds
                30000, // load balance timeout = 30 seconds
                10, // number of connections = 10
                10 // duration of connections = 10 seconds
                );
        }

        [TestCase, Description("Confirm that connections in pools are recycled (balanced) after 5 seconds.")]
        public void CheckConnectionString3()
        {
            // attempt to put 15 connections into a 10 connection pool, destroy opened connections 3 seconds after closing
            // Note that the load balance timeout will only trigger if the balance timeout is the less than the connection duration.
            StressConnectionString(
                0, // minPoolSize = 0
                10, // maxPoolSize = 10
                10000, // connection timeout = 10 seconds
                5000, // load balance timeout = 5 seconds
                15, // number of connections = 15
                7 // duration of connections = 6 seconds
                );
        }

        [TestCase, Description("Confirm that 5 connections are at first denied due to max pool size, but then accepted")]
        public void CheckConnectionString4()
        {
            // Limit connection pool to 10 connections, but create 15.  
            // Make sure the connection timeout (20 seconds) is longer than the connection duration (10 seconds).
            StressConnectionString(
                0, // minPoolSize = 0
                10, // maxPoolSize = 10
                20000, // connection timeout = 20 seconds
                30000, // load balance timeout = 30 seconds
                15, // number of connections = 15
                10 // duration of connections = 10 seconds
                );
        }

        [TestCase, Description("Confirm that connections timeout after 5 seconds.")]
        public void CheckConnectionString5()
        {
            // attempt to create 15 connections where only 10 are allowed.  Expect exception after timeout expires.
            StressConnectionString(
                0, // minPoolSize = 0
                10, // maxPoolSize = 100
                5000, // connection timeout = 5 seconds
                30000, // load balance timeout = 30 seconds
                15, // number of connections = 10
                10, // duration of connections = 10 seconds
                true // expect premature bailout
                );
        }

        [TestCase, Description("Connection timeout exactly equals connection duration.")]
        public void CheckConnectionString6()
        {
            // Set the minimum number of connections to 20, and make sure that many are created.
            StressConnectionString(
                0, // minPoolSize = 0
                100, // maxPoolSize = 100
                10000, // connection timeout = 20 seconds
                20000, // load balance timeout = 30 seconds
                10, // number of connections = 10
                10 // duration of connections = 10 seconds
                );
        }

        [TestCase, Description("No load balance timeout specified.")]
        public void CheckConnectionString7()
        {
            // Set the minimum number of connections to 20, and make sure that many are created.
            StressConnectionString(
                0, // minPoolSize = 0
                10, // maxPoolSize = 100
                15000, // connection timeout = 20 seconds
                0, // load balance timeout = 30 seconds
                15, // number of connections = 10
                10 // duration of connections = 10 seconds
                );
        }
 
        public void StressConnectionString(int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout, int numConnections, int duration)
        {
            StressConnectionString(minPoolSize, maxPoolSize, connTimeout, balanceTimeout, numConnections, duration, false);
        }

        public void StressConnectionString(int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout, int numConnections, int duration, bool bExpectFailure)
        {
            string szComponent = _szComponent;
            string szInterface = _szInterface;
            string szEnvironment = Config.Environment;

            // Get the name of the NPDB server (it's stored locally as an IP address)
            IPHostEntry ipHost = Dns.GetHostEntry(Config.NpdbServer);
            _testServer = ipHost.HostName;

            // remove the ".redmond.microsoft.com"
            int cutpoint = _testServer.IndexOf('.');
            _testServer = _testServer.Substring(0, cutpoint);

            // rteset the thread counter
            _numCurrentThreads = 0;

            Console.WriteLine("Found NPDB server at {0}, {1}", Config.NpdbServer, _testServer);

            Config.ComponentName = szComponent;

            // remove old just to be sure
            RemoveConnectionSetting(szComponent, szInterface, szEnvironment);

            // set the server
            Config.ServerSet_TestOnly_DoNotUse = _testServer;

            try
            {
                // add a row to the connection config setting table
                AddConnectionSetting(szComponent, szInterface, szEnvironment, minPoolSize, maxPoolSize, connTimeout, balanceTimeout);

                Console.WriteLine("Set: MinPool {0}, MaxPool {1}, ConnectionTimeout {2}, LoadBalanceTimeout {3}",
                    minPoolSize, maxPoolSize, connTimeout, balanceTimeout);

                // Calling this function should trigger the callbacks
                Config.CheckForUpdates();

                bool bOK = Config.CheckServerConfiguration(szEnvironment, _testServer, szComponent);

                Assert.IsTrue(bOK, "Server is not properly configured");

                IInterfaceInfo interfaceInfo = Config.GetInterface(szEnvironment, _testServer, szInterface);

                Console.WriteLine("Using: MinPool {0}, MaxPool {1}, ConnectionTimeout {2}, LoadBalanceTimeout {3}",
                    interfaceInfo.MinConnectionPoolSize, interfaceInfo.MaxConnectionPoolSize, interfaceInfo.ConnectionTimeout, interfaceInfo.LoadBalanceTimeout);

                _szConnectionString = interfaceInfo.SqlConnectionString;
                Console.WriteLine("Connection String: '{0}'", _szConnectionString);

                _numThreads = numConnections;
                _duration = duration;

                string szInstanceName = "stfgui[" + Process.GetCurrentProcess().Id + "]";

                PerformanceCounter pcNumPools = new PerformanceCounter(_perfCategory, _perfNumPools, szInstanceName, true);
                PerformanceCounter pcNumConns = new PerformanceCounter(_perfCategory, _perfNumPooledConnections, szInstanceName, true);
                PerformanceCounter pcNumActiveConns = new PerformanceCounter(_perfCategory, _perfNumActiveConnections, szInstanceName, true);
                PerformanceCounter pcNumFreeConns = new PerformanceCounter(_perfCategory, _perfNumFreeConnections, szInstanceName, true);
                PerformanceCounter pcNumConnsPerSec = new PerformanceCounter(_perfCategory, _perfNumConnsPerSec, szInstanceName, true);
                PerformanceCounter pcNumDisconnsPerSec = new PerformanceCounter(_perfCategory, _perfNumDisconnsPerSec, szInstanceName, true);

                float numPoolsB4 = pcNumPools.RawValue;
                float numPooledConnsB4 = pcNumConns.NextValue();
                float numActiveConnsB4 = pcNumActiveConns.NextValue();
                float numFreeConnsB4 = pcNumFreeConns.NextValue();

                Console.WriteLine("Before thread creation:  NumPools {0} NumPooledConnections {1} NumActiveConnections {2} NumFreeConnections {3}", 
                    numPoolsB4, numPooledConnsB4, numActiveConnsB4, numFreeConnsB4);

                // Spawn a bunch of SQL connection threads
                Thread lastThread = new Thread(SQLConnectionThread);
                lastThread.Start();

                for (int i = 1; i < _numThreads; i++)
                {
                    // spin up a new connection thread
                    lastThread = new Thread(SQLConnectionThread);
                    lastThread.Start();
                }

                // wait for a second so that threads can establish their connections
                Thread.Sleep(1000);

                float numPools = pcNumPools.NextValue();
                float numPooledConns = pcNumConns.NextValue();
                float numActiveConns = pcNumActiveConns.NextValue();
                float numFreeConns = pcNumFreeConns.NextValue();
                float numConnsPerSec = pcNumConnsPerSec.NextValue();
                float numDisconnsPerSec = pcNumDisconnsPerSec.NextValue();

                float numNewConnections = numPooledConns - numPooledConnsB4;

                // Make sure the minimum number of connections are created.
                Assert.IsTrue(numNewConnections >= minPoolSize, "Did not create the minimum number of connections");

                // Make sure the requested number of connections are created.
                if ((maxPoolSize < numConnections) && (numConnections < maxPoolSize))
                    Assert.IsTrue(numNewConnections == numConnections, "Did not create the requested number of connections");

                // make sure that number of created connections does not exceed maximum.
                if (numConnections >= maxPoolSize)
                    Assert.IsTrue(numNewConnections == maxPoolSize, "Did not create the requested number (max) of connections");

                // Wait for the last thread to pack it up
                int numSeconds = 0;
                while (lastThread.IsAlive)
                {
                    Console.WriteLine("{0} seconds after thread creation:  NumPools {1} NumPooledConnections {2} NumActiveConnections {3} NumFreeConnections {4} ConnsPerSec {5} DisconnsPerSec {6}",
                        numSeconds, numPools, numPooledConns, numActiveConns, numFreeConns, numConnsPerSec, numDisconnsPerSec);
                    numPools = pcNumPools.NextValue();
                    numPooledConns = pcNumConns.NextValue();
                    numActiveConns = pcNumActiveConns.NextValue();
                    numFreeConns = pcNumFreeConns.NextValue();
                    numConnsPerSec = pcNumConnsPerSec.NextValue();
                    numDisconnsPerSec = pcNumDisconnsPerSec.NextValue();
                    Thread.Sleep(1000);
                    numSeconds++;
                }

                if (bExpectFailure)
                {
                    Assert.IsTrue((numSeconds < duration), "Expected test to bail early but did not");
                }

                // refresh counters one last time
                numPools = pcNumPools.NextValue();
                numPooledConns = pcNumConns.NextValue();
                numActiveConns = pcNumActiveConns.NextValue();
                numFreeConns = pcNumFreeConns.NextValue();
                numConnsPerSec = pcNumConnsPerSec.NextValue();
                numDisconnsPerSec = pcNumDisconnsPerSec.NextValue();
                Console.WriteLine("After thread completion:  NumPools {0} NumPooledConnections {1} NumActiveConnections {2} NumFreeConnections {3} ConnsPerSec {4} DisconnsPerSec {5}",
                    numPools, numPooledConns, numActiveConns, numFreeConns, numConnsPerSec, numDisconnsPerSec);
            }
            finally
            {
                // delete the row to the connection config setting table
                RemoveConnectionSetting(szComponent, szInterface, szEnvironment);

                // Calling this function should clear the cache containing the connection strings
                Config.DiscardCachedValues();

                // clear the connection pools
                SqlConnection.ClearAllPools();
            }
        }

        // Helper thread to establish a SQL connection and get some traffic going
        public void SQLConnectionThread()
        {
            int numThread = _numCurrentThreads++;
            Console.WriteLine("Starting thread {0}.", numThread);
            try
            {
                // test new connection string to ensure it successfully connects
                SqlConnection sqlConnection = new SqlConnection(_szConnectionString);
                sqlConnection.Open();

                int numLoops = _duration;

                for (int i = 0; i < numLoops; i++)
                {
                    using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                    {
                        // create a bogus query that is different from the last one
                        sqlCommand.CommandText = String.Format(@"select * from  t_component_interface_connection_settings where i_connection_timeout = '{0}'", i);
                        SqlDataReader reader = sqlCommand.ExecuteReader();
                        reader.Read();
                        // leave reader open for one second
                        Thread.Sleep(1000);
                        reader.Close();
                    }
                }
                sqlConnection.Close();
            }

            catch (Exception e)
            {
                Console.WriteLine("Thread {0} had Exception: {1}", numThread, e.Message);
            }

            Console.WriteLine("Ending thread {0}.", numThread);
            _numCurrentThreads--;
        }

        public void RemoveConnectionSetting(string szComponent, string szInterface, string szEnvironment)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_component_interface_connection_settings where vc_environment = '{0}' and vc_component = '{1}' and vc_target_interface = '{2}'", 
                        szEnvironment, szComponent, szInterface);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        public void AddConnectionSetting(string szComponent, string szInterface, string szEnvironment, int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    try
                    {
                        sqlCommand.CommandText = String.Format(@"Insert into t_component_interface_connection_settings values('{0}', '{1}', '{2}', '{3}', '{4}', '{5}', '{6}')",
                            szEnvironment, szComponent, szInterface, minPoolSize, maxPoolSize, balanceTimeout, connTimeout);
                        sqlCommand.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        // if the insert fails, throw the exception up to the calling context.
                        throw (e);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConfigDevTest_UnitTests.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.common.config
{
    [TestGroup, DVT]
    public class ConfigDevTest_UnitTests : TestNode
    {
        readonly ConfigDevTest devTest = new ConfigDevTest();
        bool isInitialized;

        [TestCase]
        public void AddInterface_positive()
        {
            
            if (!isInitialized)            
                isInitialized = devTest.InitializeConfiguration();
            Console.WriteLine("Setup Initialization success = " + isInitialized);

            Console.WriteLine("Environment = {0}", devTest._npdbEnvironment);
            Console.WriteLine("Server = {0}", ConfigDevTest._testServer);
            Console.WriteLine("Interface = {0}", TestInterfaces.dummy_interface1A);

            //Add Interface config information
            Config.AddServerInterfaceConfiguration(devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A); 

            //Call GetInterface to validate
            bool matched = CheckInterfaceOnServer(devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A);

            if (matched)
            {
                Console.WriteLine(
                    " Succesfully added Interface={2} on server={1} in environment={0} ", 
                    devTest._npdbEnvironment, 
                    ConfigDevTest._testServer, 
                    TestInterfaces.dummy_interface1A);
            }
            else
            {
                throw new ArgumentException(
                    String.Format(
                        " Failed to add Interface={2} on server={1} in environment={0} ", 
                        devTest._npdbEnvironment, 
                        ConfigDevTest._testServer, 
                        TestInterfaces.dummy_interface1A));

            }
        }


        [TestCase]
        public void RemoveInterface_positive()
        {
            if (!isInitialized)
                isInitialized = devTest.InitializeConfiguration();          
            Console.WriteLine("Setup Initialization success = " + isInitialized);

            Console.WriteLine("Environment = {0}", devTest._npdbEnvironment);
            Console.WriteLine("Server = {0}", ConfigDevTest._testServer);
            Console.WriteLine("Interface = {0}", TestInterfaces.dummy_interface1A);

            //Add Interface config information
            Config.RemoveServerInterfaceConfiguration(devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A);

            //Call GetInterface to validate
            bool matched = CheckInterfaceOnServer(devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A);

            if (!matched)
            {
                Console.WriteLine(" Succesfully removed Interface={2} on server={1} in environment={0} ", devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A);

            }
            else
            {
                throw new ArgumentException(String.Format(" Failed to remove Interface={2} on server={1} in environment={0} ", devTest._npdbEnvironment, ConfigDevTest._testServer, TestInterfaces.dummy_interface1A));

            }
        }

        private static bool CheckInterfaceOnServer(string environment, string server, string anInterface)
        {
            string[] interfaces = Config.GetInterfaceListByServer(environment, server);

            foreach (string iface in interfaces)
            {
                if (String.Equals(iface , anInterface,StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }
            return false;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\billing\billing\WebReference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace XeXbos
{
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    // CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
    public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public bdk() {
            this.Url = "https://VM1BOX/scs/scsapiwebservice.asmx?wsdl"; 
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.Invoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
            object[] results = this.Invoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.Invoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.Invoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.Invoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.Invoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID});
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.Invoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID});
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.Invoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID});
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TestConnection(string bstrInputString, out string pbstrOutputString) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        bstrInputString});
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        bstrInputString}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.Invoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.Invoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.Invoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale});
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
            object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.Invoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid});
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.Invoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId});
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML});
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
            this.Invoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendHCI(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.Invoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML});
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale});
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.Invoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.Invoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory});
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML});
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.Invoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription});
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, out string pbstrErrorXML) {
            object[] results = this.Invoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndActivateToken(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConfigRefreshDevTest.cs ===
using System;
using System.Data.SqlClient;
using System.Threading;
using xonline.common.config;
using xonline.common.diagnostics;

namespace ServerTestFramework.LiveService.common.config
{
    [TestGroup, DVT]
    public class ConfigRefreshDevTest : TestNode
    {
        bool _bTestPass;
        readonly AutoResetEvent autoEvent = new AutoResetEvent(false);

        [TestGroupSetup]
        public void Setup()
        {
            Config.GetIntSetting(Setting.config_cacheRefreshInterval); //hit a random setting to get things initialized
            AddOneComponent();
            Config.InterfaceBucketChange += OnArbBucketChange;
        }

        public static void OnArbBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
        }

        [TestGroupTearDown]
        public void Teardown()
        {
            Config.InterfaceBucketChange -= OnArbBucketChange;
        }

        [TestCase]
        public void ReadSimpleSettings()
        {
            const string szCategory = "Config_Test";
            CleanupOneCategoryOfSetting(szCategory);
                
            for (int i = 0; i < 100; i++)
            {
                AddOneSetting(String.Format("{0}{1}", szCategory, i),String.Format("{0}{1}", szCategory, i));
            }
            
            //now that this is done Read all of them
            try
            {
                for (int i = 0; i < 100; i++)
                {
                    string szSetting = String.Format("{0}{1}", szCategory, i);
                    string szValue = Config.GetSetting(szSetting);

                    Assert.AreEqual(szSetting, szValue, "Got back the wrong setting value.");
                }
            }
            finally
            {
                CleanupOneCategoryOfSetting(szCategory);
            }
        }

        public void CleanupOneCategoryOfSetting(string szCategory)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_environment_type_setting_overrides where vc_setting like '{0}%'", szCategory);
                    sqlCommand.ExecuteNonQuery();
                }

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_setting_overrides where vc_setting like '{0}%'", szCategory);
                    sqlCommand.ExecuteNonQuery();
                }

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_settings where vc_setting like '{0}%'", szCategory);
                    sqlCommand.ExecuteNonQuery();
                    
                }
            }
            
        }

        public void AddOneSetting(string szSetting, string szValue)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"Insert into t_settings values('{0}', '{1}')", szSetting, szValue);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        public void AddOneSettingOverride(string szEnvironment, string szComponent , int iSiteId, string szServer, string szSetting, string szValue)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"Insert into t_setting_overrides values('{0}', '{1}', {2}, '{3}', '{4}', '{5}')", szEnvironment, szComponent, iSiteId, szServer, szSetting, szValue);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        
        
        [TestCase]
        public void SettingRank7Overide()
        {
            const string szSetting = "Config_Test_Perm_7";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1,  "all", szSetting, "7");

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("7", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }

        [TestCase]
        public void SettingRank6Overide()
        {
            const string szSetting = "Config_Test_Perm_6";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1,  "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1,  "all", szSetting, "6"); //matches the Sites


            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("6", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }
/*
          Found in t_settings_override:
                        vc_component   vc_server,   i_site_id,			rank
                        <match>        <match>,     <match>,				        0 (highest priority)
                        <match>        <match>,     -1,								1
                        <match>        ALL,         <match>,				        2
                        <match>        ALL,         -1,								3
                        ALL            <match>,     <match>,				        4
                        ALL            <match>,     -1,								5
                        ALL            ALL,         <match>,				        6
                        ALL            ALL,         -1,								7

               Found in t_environment_type_setting_overrides, 
                                                                                    8
               Found in t_settings, 
																					9 (lowest priority)*/

        [TestCase]
        public void SettingRank5Overide()
        {
            const string szSetting = "Config_Test_Perm_5";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;

            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only


            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("5", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }

        public void AddOneComponent()
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                
                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_setting_overrides where vc_component='unknown'");
                    sqlCommand.ExecuteNonQuery();
                }

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_components where vc_component='unknown'");
                    sqlCommand.ExecuteNonQuery();
                }
                
                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"Insert into t_components(vc_component, vc_install_unit) values('unknown', 'NOINSTALLUNIT')");
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }


        [TestCase]
        public void SettingRank4Overide()
        {   
            //add unknown component
            const string szSetting = "Config_Test_Perm_4";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);
            
                Assert.AreEqual("4", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }


        [TestCase]
        public void SettingRank3Overide()
        {   
            //add unknown component
            const string szSetting = "Config_Test_Perm_3";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, "all", szSetting, "3"); //matches the component only

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("3", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }


        [TestCase]
        public void SettingRank2Overide()
        {   
            //add unknown component
            const string szSetting = "Config_Test_Perm_2";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, "all", szSetting, "3"); //matches the component only
            AddOneSettingOverride("xblob", "unknown",1, "all", szSetting, "2"); //matches the component and i_site_id

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("2", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }

        [TestCase]
        public void SettingRank1Overide()
        {   
            //add unknown component
            const string szSetting = "Config_Test_Perm_1";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, "all", szSetting, "3"); //matches the component only
            AddOneSettingOverride("xblob", "unknown",1, "all", szSetting, "2"); //matches the component and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, szMachineName, szSetting, "1"); //matches the component and vc_server

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("1", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }

        [TestCase]
        public void SettingRank0Overide()
        {   
            //add unknown component
            const string szSetting = "Config_Test_Perm_0";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all",-1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all",-1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, "all", szSetting, "3"); //matches the component only
            AddOneSettingOverride("xblob", "unknown",1, "all", szSetting, "2"); //matches the component and i_site_id
            AddOneSettingOverride("xblob", "unknown",-1, szMachineName, szSetting, "1"); //matches the component and vc_server
            AddOneSettingOverride("xblob", "unknown", 1, szMachineName, szSetting, "0"); //ALL

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("0", szRankOverride, "Got back the wrong setting override.");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
            }
        }


        [TestCase]
        public void SettingRefreshVetoed()
        {
            autoEvent.Reset();
            //add unknown component
            const string szSetting = "Config_Test_Perm_0";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all", -1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all", -1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown", -1, "all", szSetting, "3"); //matches the component only
            AddOneSettingOverride("xblob", "unknown", 1, "all", szSetting, "2"); //matches the component and i_site_id
            AddOneSettingOverride("xblob", "unknown", -1, szMachineName, szSetting, "1"); //matches the component and vc_server
            AddOneSettingOverride("xblob", "unknown", 1, szMachineName, szSetting, "0"); //ALL

            //  Wait for any notifications to trickle through the system.
            TimeSpan refreshInterval = new TimeSpan(0, 0, 0, 0, Config.GetIntSetting("config_cacherefreshinterval") * 2);
            Thread.Sleep(refreshInterval);
            
            try
            {
                string szRankOverride = Config.GetSetting(szSetting);
                Assert.AreEqual("0", szRankOverride);

                _bTestPass = false;
                Config._npdbRefreshNotification += OnNpdbRefreshSetting;
                Config.RegisterDynamicSetting(szSetting);


                using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
                {
                    cxn.Open();

                    using (SqlCommand sqlCommand = cxn.CreateCommand())
                    {
                        sqlCommand.CommandText =
                            "update t_setting_overrides set vc_value = 'REFRESHED' where vc_setting = '" + szSetting + "'";
                        sqlCommand.ExecuteNonQuery();
                    }
                }

                Assert.IsTrue(
                    autoEvent.WaitOne(refreshInterval, false), 
                    "Setting Refresh test failed, change notification not received within configured interval.");

                Assert.IsTrue(_bTestPass, "Setting Refresh test failed.");

                szRankOverride = Config.GetSetting(szSetting);

                Assert.IsTrue(("REFRESHED" != szRankOverride),
                              "This setting refreshed is getting vetoed - update not possible");
            }
            finally
            {
                CleanupOneCategoryOfSetting(szSetting);
                Config.UnRegisterDynamicSetting(szSetting);
                Config._npdbRefreshNotification -= OnNpdbRefreshSetting;
            }
        }

        [TestCase]
        public void SettingRefresh()
        {
            autoEvent.Reset();
            Config.DiscardCachedValues();

            //add unknown component
            const string szSetting = "Config_Test_Perm_Refresh";
            CleanupOneCategoryOfSetting(szSetting);
            AddOneSetting(szSetting, "9");
            AddOneSettingOverride("xblob", "all", -1, "all", szSetting, "7");
            AddOneSettingOverride("xblob", "all", 1, "all", szSetting, "6"); //matches the Sites
            string szMachineName = Config.Server;
            AddOneSettingOverride("xblob", "all", -1, szMachineName, szSetting, "5"); //matches the server name only
            AddOneSettingOverride("xblob", "all", 1, szMachineName, szSetting, "4"); //maches vc_server and i_site_id
            AddOneSettingOverride("xblob", "unknown", -1, "all", szSetting, "3"); //matches the component only
            AddOneSettingOverride("xblob", "unknown", 1, "all", szSetting, "2"); //matches the component and i_site_id
            AddOneSettingOverride("xblob", "unknown", -1, szMachineName, szSetting, "1"); //matches the component and vc_server

            //  Wait for any notifications to trickle through the system.
            TimeSpan refreshInterval = new TimeSpan(0, 0, 0, 0, Config.GetIntSetting("config_cacherefreshinterval") * 2);
            Thread.Sleep(refreshInterval);

            try
            {
                string szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("1", szRankOverride);

                _bTestPass = false;
                Config._npdbRefreshNotification += OnNpdbRefreshSetting;
                Config.SettingChange += OnSettingChange;
                Config.RegisterDynamicSetting(szSetting);

                using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText =
                        "update t_setting_overrides set vc_value = 'REFRESHED1' where vc_setting = '" + szSetting + "'";
                    sqlCommand.ExecuteNonQuery();
                }

                Assert.IsTrue(
                    autoEvent.WaitOne(refreshInterval, false),
                    "Setting Refresh test failed, change notification not received within configured interval.");

                if (!_bTestPass)
                {
                    throw new Exception("Setting Refresh test failed");
                }

                szRankOverride = Config.GetSetting(szSetting);

                Assert.AreEqual("REFRESHED1", szRankOverride);
            }
            finally
            {
                Config.SettingChange -= OnSettingChange;
                Config._npdbRefreshNotification -= OnNpdbRefreshSetting;
                Config.UnRegisterDynamicSetting(szSetting);
                CleanupOneCategoryOfSetting(szSetting);
            }
        }
        

        [TestCase]        
        public void ReadNonExistingSetting()
        {
            try
            {
                Config.GetSetting("IDONTEXIST");
                throw new Exception("Non Existent Setting Returned without error");
            }
            catch (ApplicationException) {}
        }

        [TestCase]
        public void RefreshNonExistingSetting()
        {
            
        }
        

        [TestCase]
        public void NpdbRefreshSettingBasicTest()
        {
            autoEvent.Reset();
            _bTestPass = false;
            int originalRefreshInterface = Config.GetIntSetting(Setting.config_cacheRefreshInterval);

            Config._npdbRefreshNotification += OnNpdbRefreshSetting;
            
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText= string.Format("update t_settings set vc_value = '30000' where vc_setting = '{0}'", Setting.config_cacheRefreshInterval);
                    sqlCommand.ExecuteNonQuery();
                    
                }
            }

            try
            {
                autoEvent.WaitOne();

                Config._npdbRefreshNotification -= OnNpdbRefreshSetting;

                Assert.IsTrue(_bTestPass, "Setting Refresh test failed");
            }
            finally
            {
                using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
                {
                    cxn.Open();

                    using (SqlCommand sqlCommand = cxn.CreateCommand())
                    {
                        sqlCommand.CommandText = string.Format("update t_settings set vc_value = '{0}' where vc_setting = '{1}'", originalRefreshInterface, Setting.config_cacheRefreshInterval);
                        sqlCommand.ExecuteNonQuery();
                    }
                }
            }
        }

        public void OnSettingChange(object sender, SettingChangeEventArgs args)
        {
        }

        public void OnNpdbRefreshSetting(NpdbRefreshTypes npdbRefreshType)
        {
            //setting should not touch interface buckets
            if (npdbRefreshType == NpdbRefreshTypes.REFRESH_ENDS)
            {
                autoEvent.Set();
            }
            else if (npdbRefreshType == NpdbRefreshTypes.REFRESH_SETTINGS)
            {
                _bTestPass = true;
            }
        }

        [TestCase]
        public void NpdbRefreshInterfaceBucket()
        {
            try
            {
                autoEvent.Reset();
                //verify refreshing interface bucket does not touch settings
                _bTestPass = true;
                Config._npdbRefreshNotification += OnNpdbRefreshInterfaceBucket;

                using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText =
                        "update t_interface_buckets set dt_migration_start = getutcdate() where vc_interface='filterdb' and vc_environment = 'xblob'";
                    sqlCommand.ExecuteNonQuery();
                }


                Assert.IsTrue(autoEvent.WaitOne(Config.GetIntSetting("config_cacheRefreshInterval") * 2, false), "Setting Refresh test failed");

                Assert.IsTrue(_bTestPass, "Setting Refresh test failed");
            }
            finally
            {
                Config._npdbRefreshNotification -= OnNpdbRefreshInterfaceBucket;
            }
        }

        public void OnNpdbRefreshInterfaceBucket(NpdbRefreshTypes npdbRefreshType)
        {
            //setting should not touch interface buckets
            if (npdbRefreshType == NpdbRefreshTypes.REFRESH_ENDS)
            {
                autoEvent.Set();
            }
            else if (
                npdbRefreshType != NpdbRefreshTypes.REFRESH_STARTS &&
                npdbRefreshType != NpdbRefreshTypes.REFRESH_SETTINGS &&
                npdbRefreshType != NpdbRefreshTypes.REFRESH_INTERFACE_BUCKETS)
            {
                _bTestPass = false;
            }
        }

        public void OnNpdbRefreshInterfaceBucketNormal(NpdbRefreshTypes npdbRefreshType)
        {
            //setting should not touch interface buckets
            if (npdbRefreshType == NpdbRefreshTypes.REFRESH_ENDS)
            {
                autoEvent.Set();
            }
        }

        public void PrepareBuckets(uint iTitleId )
        {
            DeleteInterfaceBucketForTitle(iTitleId);
            for (int i=0;i<520;i++)
            {
                AddOneInterfaceBucket(Config.Environment, "lbsvr", iTitleId, i+1, Config.Server);
            }

        }

        [TestCase]        
        public void ReadNonExistingBucket()
        {
            try
            {
                Config.GetTitleBucketServer("IDONTEXIST", 1, 1);
                throw new Exception("Non Existent Bucket Returned without error");
            }
            catch (ApplicationException) {}
        }

        [TestCase]
        public void ReadbucketsInformationOnDemand()
        {
            const uint iTitleId = 1234567;

            PrepareBuckets(iTitleId);

            for (uint i=0;i<520;i++)
            {

                IBucketServer server = Config.GetTitleBucketServer("lbsvr", iTitleId, i+1);
                if (server.Info1 != "testinfo")
                {
                    throw new Exception("UnExpected interface bucket information");
                }
            }
        }

        public void UpdateInterfaceBuckets(uint iTitleId)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();

                string szCommand = String.Format(@"update t_interface_buckets set vc_info1='refreshed' where i_title_id = {0}", iTitleId);

                sqlCommand.CommandText = szCommand;
                sqlCommand.ExecuteNonQuery();
            }

        }

        [TestCase]
        public void ForceRefreshInterfaceBuckets()
        {
            const uint iTitleId = 1234567;
            autoEvent.Reset();
            //verify refreshing interface bucket does not touch settings
            _bTestPass = true;
            Config._npdbRefreshNotification += OnNpdbRefreshInterfaceBucketNormal;
            for (uint i=0;i<520;i++)
            {
                IBucketServer server = Config.GetTitleBucketServer("lbsvr", iTitleId, i+1);
                if (server.Info1 != "testinfo")
                {
                    throw new Exception("UnExpected interface bucket information");
                }
            }
             
            UpdateInterfaceBuckets(iTitleId);
            
            autoEvent.WaitOne();
            Config._npdbRefreshNotification -= OnNpdbRefreshInterfaceBucketNormal;

            for (uint i=0;i<520;i++)
            {
                IBucketServer server = Config.GetTitleBucketServer("lbsvr", iTitleId, i+1);
                if (server.Info1 != "refreshed")
                {
                    throw new Exception("UnExpected interface bucket information");
                }
            }
        }
        
        public void DeleteInterfaceBucketForTitle(uint iTitleId)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();

                string szCommand = String.Format(@"delete t_interface_buckets where i_title_id = {0}", iTitleId);

                sqlCommand.CommandText = szCommand;
                sqlCommand.ExecuteNonQuery();
            }
        }

        public void AddOneInterfaceBucket(string szEnvironment, string szInterface, uint iTitleId, int iBucket, string szServer)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();

                string szCommand = String.Format(@"insert into t_interface_buckets(vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4) 
                                                    values ('{0}', '{1}', {2}, {3}, '{4}', '{4}', getutcdate(), 'testinfo', 'testinfo2', 'testinfo3', 'testinfo4')",
                                                 szEnvironment, szInterface, iTitleId, iBucket, szServer);

                sqlCommand.CommandText = szCommand;
                sqlCommand.ExecuteNonQuery();
            }

        }   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConnectionSettingsTest.cs ===
using System;
using System.Data.SqlClient;
using System.Threading;
using xonline.common.config;
using xonline.common.diagnostics;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.stfutil;

//[assembly: RootNode(typeof(ServerTestFramework.LiveService.common.config.ConnnectionStringTests))]

namespace ServerTestFramework.LiveService.common.config
{
    /// <summary>
    ///      <TestSuite>SQL Connnection String configuration parameter testing</TestSuite>
    ///        <Tester>Jon Fleming</Tester>
    ///        <Developer>Stephane Plante</Developer>
    ///        <PM>Jason the Dude</PM>
    /// </summary>
    /// <remarks>
    ///        <Goal>Confirm that connection parameters are properly found in connection strings</Goal>
    ///        <NonGoal>The efficacy of the new parameters are not tested.</NonGoal>
    ///        <Description>
    ///                <p>
    ///                        Lots of interesting tests.
    ///                </p>
    ///      </Description>
    /// </remarks>
    ////public class ConnnectionStringTests : TestNode
    ////{
    ////}

    /// <HighLevel>
    ///       [This suite confirms that the new configuration parameters for SQL connection strings (stored in NPDB) are appropriately propagated.] 
    /// </HighLevel>
    /// <Goals>
    ///       [Confirm that adding configuration rows to the new table are used by conneciton strings.]
    /// </Goals>
    /// <NonGoals>
    ///       [Efficacy of these new parameters are not part of this test suite.]
    /// </NonGoals>
    /// <Implementation>
    ///       [See Test Plan for Connection Pool Configurtation Settings]
    /// </Implementation>
    [TestGroup]
    public class ConnnectionStringVerification : TestNode
    {
        internal string _testServer;
        internal const string _szComponent = "npdb";
        internal const string _szInterface = "npdb";

        /// <summary>
        ///       [Primary Key integrity: Component column]
        /// </summary>
        /// <remarks>
        ///    <description>
        ///            [Make sure that it is not possible to add a row to the table if a primary key is not found in a dependent table.]
        ///     </desription>
        ///     <scenarios>
        ///             [This test is for original implementation and regression]
        ///     </scenarios>
        ///     <section name="Notes">
        ///             [None.]
        ///     </section>
        ///     <dependencies>
        ///             [NPDB database is required.]
        ///     </dependencies>
        /// </remarks>
        [TestCase, Description("Confirm that we cannot add a row if the component key does not exist in NPDB.")]
        public void AddBadComponent()
        {
            string szComponent = "YumYum";
            string szInterface = _szInterface;
            string szEnvironment = Config.Environment;

            try
            {
                AddConnectionSetting(szComponent, szInterface, szEnvironment, 0, 10, 20, 20); 
            }
            catch
            {
                // do nothing:  expected an error.  
                return;
            }

            // If no exception was thrown, well, that's a problem.  
            Assert.IsTrue(false, "Added a bad database entry");
        }

        /// <summary>
        ///       [Primary Key integrity: Integrity column]
        /// </summary>
        /// <remarks>
        ///    <description>
        ///            [Make sure that it is not possible to add a row to the table if a primary key is not found in a dependent table.]
        ///     </desription>
        ///     <scenarios>
        ///             [This test is for original implementation and regression]
        ///     </scenarios>
        ///     <section name="Notes">
        ///             [None.]
        ///     </section>
        ///     <dependencies>
        ///             [NPDB database is required.]
        ///     </dependencies>
        /// </remarks>
        [TestCase, Description("Confirm that we cannot add a row if the interface key does not exist in NPDB.")]
        public void AddBadInterface()
        {
            string szComponent = _szComponent;
            string szInterface = "YumYum";
            string szEnvironment = Config.Environment;

            try
            {
                AddConnectionSetting(szComponent, szInterface, szEnvironment, 0, 10, 20, 20);
            }
            catch
            {
                // do nothing:  expected an error.  
                return;
            }

            // If no exception was thrown, well, that's a problem.  
            Assert.IsTrue(false, "Added a bad database entry");
        }

        /// <summary>
        ///       [Primary Key integrity: Environment column]
        /// </summary>
        /// <remarks>
        ///    <description>
        ///            [Make sure that it is not possible to add a row to the table if a primary key is not found in a dependent table.]
        ///     </desription>
        ///     <scenarios>
        ///             [This test is for original implementation and regression]
        ///     </scenarios>
        ///     <section name="Notes">
        ///             [None.]
        ///     </section>
        ///     <dependencies>
        ///             [NPDB database is required.]
        ///     </dependencies>
        /// </remarks>
        [TestCase, Description("Confirm that we cannot add a row if the environment key does not exist in NPDB.")]
        public void AddBadEnvironment()
        {
            string szComponent = _szComponent;
            string szInterface = _szInterface;
            string szEnvironment = "YumYum";

            try
            {
                AddConnectionSetting(szComponent, szInterface, szEnvironment, 0, 10, 20, 20);
            }
            catch
            {
                // do nothing:  expected an error.  
                return;
            }

            // If no exception was thrown, well, that's a problem.  
            Assert.IsTrue(false, "Added a bad database entry");
        }

        /// <summary>
        ///       [Test a valid connection string]
        /// </summary>
        /// <remarks>
        ///    <description>
        ///            [This is a happy path test case.]
        ///     </desription>
        ///     <scenarios>
        ///             [This test is for original implementation and regression]
        ///     </scenarios>
        ///     <section name="Notes">
        ///             [None.]
        ///     </section>
        ///     <dependencies>
        ///             [NPDB database is required.]
        ///     </dependencies>
        /// </remarks>
        [TestCase, Description("Confirm that connection strings are correct with normal parameters.")]
        public void CheckConnectionString1()
        {
            CheckConnectionString(10, 100, 20000, 30000);
        }

        [TestCase, Description("Confirm that connection strings are correct with allowable null parameters.")]
        public void CheckConnectionString2()
        {
            CheckConnectionString(0, 100, 0, 0);
        }

        [TestCase, Description("Confirm that a zero max pool size is not allowed.")]
        public void CheckConnectionString3()
        {
            CheckConnectionString(0, 0, 0, 0, true);
        }

        [TestCase, Description("Confirm that negative connection strings are invalid.")]
        public void CheckConnectionString4()
        {
            CheckConnectionString(-1, -10, -20000, 0, true);
        }

        [TestCase, Description("Confirm that reversed min/max strings are invalid.")]
        public void CheckConnectionString5()
        {
            CheckConnectionString(100, 50, 20000, 40000, true);
        }

        // need a member variable to tell the InterfaceChange handlers what event args to expect
        private InterfaceChangeEventArgs _interfaceChangeEventArgs;

        private bool _interfaceChangeFired;
        private bool _refreshChangeFired;

        // callback for config refresh event (used only by test code)
        public void OnMyNpdbRefreshSetting(NpdbRefreshTypes npdbRefreshType)
        {
            

            // Config update should trigger a refresh interfaces
            if (npdbRefreshType != NpdbRefreshTypes.REFRESH_INTERFACES)
            {
                _refreshChangeFired = true;
            }
        }

        // callback for config interface change event
        public void OnMyInterfaceChange(
            object sender,
            InterfaceChangeEventArgs e)
        {
            _interfaceChangeFired = true;
            
            string eEnvironment = null;
            string eServer = null;
            string eInterface = Interface.None;
            IInterfaceInfo eValueOld = null;
            IInterfaceInfo eValueNew = null;
            bool fUnexpected = false;

            if (0 != String.Compare(_interfaceChangeEventArgs.Environment, e.Environment))
            {
                eEnvironment = e.Environment;
                fUnexpected = true;
            }

            if (0 != String.Compare(_interfaceChangeEventArgs.Server, e.Server))
            {
                eServer = e.Server;
                fUnexpected = true;
            }

            if (_interfaceChangeEventArgs.Interface != e.Interface)
            {
                eInterface = e.Interface;
                fUnexpected = true;
            }

            if (0 != String.Compare(_interfaceChangeEventArgs.ValueOld.ToString(), e.ValueOld.ToString()))
            {
                eValueOld = e.ValueOld;
                fUnexpected = true;
            }

            if (0 != String.Compare(_interfaceChangeEventArgs.ValueNew.ToString(), e.ValueNew.ToString()))
            {
                eValueNew = e.ValueNew;
                fUnexpected = true;
            }

            // if the results are different than expected, update the global event args struct with new data.
            if (fUnexpected)
            {
                _interfaceChangeEventArgs
                    = new InterfaceChangeEventArgs(
                    eEnvironment,
                    eServer,
                    eInterface,
                    eValueOld,
                    eValueNew);
            }
        }

        public void CheckConnectionString(int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout)
        {
            CheckConnectionString(minPoolSize, maxPoolSize, connTimeout, balanceTimeout, false);
        }

        public void CheckConnectionString(int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout, bool shouldFail)
        {
            string szComponent = _szComponent;
            string szInterface = _szInterface;
            string szEnvironment = Config.Environment;

            // Get the name of the NPDB server (it's stored locally as an IP address)
            IPHostEntry ipHost = Dns.GetHostEntry(Config.NpdbServer);
            _testServer = ipHost.HostName;

            // remove the ".redmond.microsoft.com"
            int cutpoint = _testServer.IndexOf('.');
            _testServer = _testServer.Substring(0, cutpoint);

            Console.WriteLine("Found NPDB server at {0}, {1}", Config.NpdbServer, _testServer);

            Config.ComponentName = szComponent;

            // remove old just to be sure
            RemoveConnectionSetting(szComponent, szInterface, szEnvironment);

            // set the server
            Config.ServerSet_TestOnly_DoNotUse = _testServer;

            // read an interface to trigger cache creation
            IInterfaceInfo interfaceInfo = Config.GetInterface(szEnvironment, _testServer, szInterface);

            // build our expected interface info objects
            InterfaceInfo interfaceInfo_Old = new InterfaceInfo();
            InterfaceInfo interfaceInfo_New = new InterfaceInfo();

            interfaceInfo_Old = (InterfaceInfo)interfaceInfo;

            // set the variables for the expected change
            interfaceInfo_New.MaxConnectionPoolSize = maxPoolSize;
            interfaceInfo_New.MinConnectionPoolSize = minPoolSize;
            interfaceInfo_New.ConnectionTimeout = connTimeout;
            interfaceInfo_New.LoadBalanceTimeout = balanceTimeout;

            //Call GetInterface to validate
            bool matched = CheckInterfaceOnServer(szEnvironment, _testServer, szInterface);

            // create the expected variable list
            _interfaceChangeEventArgs = new InterfaceChangeEventArgs(
                    szEnvironment,
                    _testServer,
                    interfaceInfo_Old.Interface,
                    interfaceInfo_Old,
                    interfaceInfo_New);

            _interfaceChangeFired = false;
            _refreshChangeFired = false;

            // read an empty server list to trigger cache creation
            Config.GetServerListByInterface(Interface.None);

            try
            {
                // add the callbacks for config change events
                Config.InterfaceChange += OnMyInterfaceChange;
                Config._npdbRefreshNotification += OnMyNpdbRefreshSetting;

                // add a row to the connection config setting table
                AddConnectionSetting(szComponent, szInterface, szEnvironment, minPoolSize, maxPoolSize, connTimeout, balanceTimeout);

                // Calling this function should trigger the callbacks
                Config.CheckForUpdates();

                bool bOK = Config.CheckServerConfiguration(szEnvironment, _testServer, szComponent);

                Assert.IsTrue(bOK, "Server is not properly configured");
                Assert.IsTrue(_refreshChangeFired, "Refresh did not fire.");
                Assert.IsTrue(_interfaceChangeFired, "Interface Change event did not fire.");

                Console.WriteLine("Set: MaxPool {0}, MinPool {1}, ConnectionTimeout {2}, LoadBalanceTimeout {3}",
                    maxPoolSize, minPoolSize, connTimeout, balanceTimeout);

                Console.WriteLine("Result: MaxPool {0}, MinPool {1}, ConnectionTimeout {2}, LoadBalanceTimeout {3}",
                    _interfaceChangeEventArgs.ValueNew.MaxConnectionPoolSize, _interfaceChangeEventArgs.ValueNew.MinConnectionPoolSize,
                    _interfaceChangeEventArgs.ValueNew.ConnectionTimeout, _interfaceChangeEventArgs.ValueNew.LoadBalanceTimeout);

                Assert.AreEqual(_interfaceChangeEventArgs.ValueNew.MaxConnectionPoolSize, maxPoolSize, " Maximum Pool Size is unexpected.");
                Assert.AreEqual(_interfaceChangeEventArgs.ValueNew.MinConnectionPoolSize, minPoolSize, " Minimum Pool Size is unexpected.");
                Assert.AreEqual(_interfaceChangeEventArgs.ValueNew.ConnectionTimeout, connTimeout, " Connection Timeout is unexpected.");
                Assert.AreEqual(_interfaceChangeEventArgs.ValueNew.LoadBalanceTimeout, balanceTimeout, " Load Balance Timeout is unexpected.");

                // if shouldFail is true, expect connection string config settings to throw an exception
                if (!shouldFail)
                {
                        // test new connection string to ensure it successfully connects
                        string szConnectionString = _interfaceChangeEventArgs.ValueNew.SqlConnectionString;
                        Console.WriteLine("Testing SQL Connection String '{0}'", szConnectionString);
                        SqlConnection sqlConnection = new SqlConnection(szConnectionString);
                        sqlConnection.Open();
                        sqlConnection.Close();
                }
                else
                {
                        // expect wonky connection string to fail parsing
                        try
                        {
                            string szConnectionString = _interfaceChangeEventArgs.ValueNew.SqlConnectionString;
                            // if wonky connection string passed parsing, make sure it fails to connect
                            try
                            {
                                Console.WriteLine("Testing Invalid SQL Connection String '{0}'", szConnectionString);
                                SqlConnection sqlConnection = new SqlConnection(szConnectionString);
                                sqlConnection.Open();
                                Assert.IsTrue(false, "Invalid SQL Connection string passed verification");
                            }
                            catch
                            {
                                Console.WriteLine("SQL Connection string failed as expected: '{0}'", szConnectionString);
                            }
                        }
                        catch
                        {
                            // do nothing
                            Console.WriteLine("Captured an invalid SQL connection string.");
                        }
                }
            }
            finally
            {
                // remove the callbacks
                Config.InterfaceChange -= OnMyInterfaceChange;
                Config._npdbRefreshNotification -= OnMyNpdbRefreshSetting;

                // delete the row to the connection config setting table
                RemoveConnectionSetting(szComponent, szInterface, szEnvironment);
            }
        }

        private static bool CheckInterfaceOnServer(string environment, string server, string anInterface)
        {
            string[] interfaces = Config.GetInterfaceListByServer(environment, server);

            foreach (string iface in interfaces)
            {
                if (String.Equals(iface, anInterface, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }
            return false;
        }

        public void RemoveConnectionSetting(string szComponent, string szInterface, string szEnvironment)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    sqlCommand.CommandText = String.Format(@"delete t_component_interface_connection_settings where vc_environment = '{0}' and vc_component = '{1}' and vc_target_interface = '{2}'", 
                        szEnvironment, szComponent, szInterface);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        public void AddConnectionSetting(string szComponent, string szInterface, string szEnvironment, int minPoolSize, int maxPoolSize, int connTimeout, int balanceTimeout)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                using(SqlCommand sqlCommand = cxn.CreateCommand())
                {
                    try
                    {
                        sqlCommand.CommandText = String.Format(@"Insert into t_component_interface_connection_settings values('{0}', '{1}', '{2}', '{3}', '{4}', '{5}', '{6}')",
                            szEnvironment, szComponent, szInterface, minPoolSize, maxPoolSize, balanceTimeout, connTimeout);
                        sqlCommand.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        // if the insert fails, throw the exception up to the calling context.
                        throw (e);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\test\config\ConfigDevTest_CPP.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;

namespace ServerTestFramework.LiveService.common.config
{
    public partial class ConfigDevTest
    {

        //private AppEntry[] CPP_AppEntries 
        //{
        //    get 
        //    {
        //        AppEntry[]  appEntries = {
        //            new AppEntry(EventLogEntryType.Error, 3, "ServerSet_TestOnly_DoNotUse should never be called in Production!\nServer is being explicitly set to " + _testServer + ".\n"),
        //            new AppEntry(EventLogEntryType.Information, 1, "Using NPDB server specified by DNS for hostname 'npdb', value: " + _npdbServerIp),
        //            new AppEntry(EventLogEntryType.Information, 1, "Using default NPDB database name of 'npdb'"),
        //            new AppEntry(EventLogEntryType.Information, 1, "Current environment is " + _npdbEnvironment),
        //            new AppEntry(EventLogEntryType.Information, 1, "Current server is " + Environment.MachineName),
        //            new AppEntry(EventLogEntryType.Information, 1, "Unable to determine current component, using Component.unknown. Component specific overrides will not be used by this component."),
        //            new AppEntry(EventLogEntryType.Information, 1, "Current component is unknown"),
        //            new AppEntry(EventLogEntryType.Information, 1, "The minimum interval between consecutive stale data events is set to 100 milliseconds"),
        //            new AppEntry(EventLogEntryType.Information, 1, "This component will check for updates in NPDB every 60000 milliseconds"),
        //            new AppEntry(EventLogEntryType.Information, 1, "The NPDB refresh timer is being created by a thread using the following windows identity: " + Environment.UserDomainName + "\\" + Environment.UserName),
        //            new AppEntry(EventLogEntryType.Information, 1, "Attaching Config.OnControlRequest to XomControl.ControlRequestEventHandler"),
        //            new AppEntry(EventLogEntryType.Information, 1, "ComponentName is being explicitly set to " + _testComponentCPP),
        //            new AppEntry(EventLogEntryType.Error, 3, "ServerSet_TestOnly_DoNotUse should never be called in Production!\nServer is being explicitly set to " + _testServer + ".\n"),
        //            new AppEntry(EventLogEntryType.Information, 1, "Unable to determine current component, using Component.unknown. Component specific overrides will not be used by this component."),
        //            new AppEntry(EventLogEntryType.Information, 1, "Current component is unknown"),
        //            new AppEntry(EventLogEntryType.Information, 1, "ComponentName is being explicitly set to " + _testComponentCPP),
        //            new AppEntry(EventLogEntryType.Information, 1, "Unable to determine current component, using Component.unknown. Component specific overrides will not be used by this component."),
        //            new AppEntry(EventLogEntryType.Information, 1, "Current component is unknown"),
        //        };

        //        return appEntries;
        //    }
        //}

        public void CPP_Base()
        {
            CheckReady();

            ProcessStartInfo configtlbtestProcessInfo = new ProcessStartInfo();
            Process configtlbtestProcess = new Process();

            StackFrame sf = new StackFrame(1);
            MethodBase methodBase = sf.GetMethod();

            // Start configtlbtest
            configtlbtestProcessInfo.FileName = "ConfigTlbTest.exe";
            configtlbtestProcessInfo.Arguments = _npdbServer + " " + _npdbEnvironment + " " + _testComponentCPP + "  " + methodBase.Name;
            configtlbtestProcessInfo.UseShellExecute = false;
            configtlbtestProcessInfo.RedirectStandardError = true;
            configtlbtestProcessInfo.CreateNoWindow = true;
            configtlbtestProcess.StartInfo = configtlbtestProcessInfo;
            configtlbtestProcess.Start();

            // Get any standard error output
            string configtlbtestError = configtlbtestProcess.StandardError.ReadToEnd();

            // Get the exit code
            int configtlbtestExitCode = configtlbtestProcess.ExitCode;

            if (0 != configtlbtestExitCode)
            {
                TextWriter errorWriter = Console.Error;

                string[] configtlbtestErrorLines = ParseStandardError(configtlbtestError);
                foreach (string configtlbtestErrorLine in configtlbtestErrorLines)
                {
                    errorWriter.WriteLine(configtlbtestErrorLine);
                }
                throw new Exception(methodBase.Name + " failed: (0x" + configtlbtestExitCode.ToString("X") + ")");
            }
        }

        [TestCase]
        public void CPP_Component_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_ComponentName_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_ComponentToString_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_Environment_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_Server_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_SiteId_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetServerListByInterface_None()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetServerListByInterface_PosSingleServer()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetServerListByInterface_PosMultiServer()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetServerListByInterface_PosCache()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "A server list change has been accepted by this component (details below)\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "A server list change has been rejected by this component (details below)\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "This component is not using the latest server list information from NPDB (details below)\nOperator action may be required. Please investigate!\nNote: This event will not be logged again for this particular problem until at least 100 milliseconds have elapsed\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "ComponentName is being explicitly set to " + _testComponentCPP),
            //    new AppEntry(EventLogEntryType.Error, 3, "ServerSet_TestOnly_DoNotUse should never be called in Production!\nServer is being explicitly set to " + _testServer + ".\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "Current environment is " + _npdbEnvironment),
            //    new AppEntry(EventLogEntryType.Information, 1, "Unable to determine current component, using Component.unknown. Component specific overrides will not be used by this component."),
            //    new AppEntry(EventLogEntryType.Information, 1, "Current component is unknown"),
            //    new AppEntry(EventLogEntryType.Information, 1, "The minimum interval between consecutive stale data events is set to 100 milliseconds"),
            //    new AppEntry(EventLogEntryType.Information, 1, "This component will check for updates in NPDB every 60000 milliseconds"),
            //    new AppEntry(EventLogEntryType.Information, 1, "The NPDB refresh timer is being created by a thread using the following windows identity: " + Environment.UserDomainName + "\\" + Environment.UserName),
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "A server list change event was not handled by this component (details below)\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "This component is not using the latest server list information from NPDB (details below)\nOperator action may be required. Please investigate!\nNote: This event will not be logged again for this particular problem until at least 100 milliseconds have elapsed\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "ComponentName is being explicitly set to " + _testComponentCPP),
            //    new AppEntry(EventLogEntryType.Error, 3, "ServerSet_TestOnly_DoNotUse should never be called in Production!\nServer is being explicitly set to " + _testServer + ".\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "Current environment is " + _npdbEnvironment),
            //    new AppEntry(EventLogEntryType.Information, 1, "Unable to determine current component, using Component.unknown. Component specific overrides will not be used by this component."),
            //    new AppEntry(EventLogEntryType.Information, 1, "Current component is unknown"),
            //    new AppEntry(EventLogEntryType.Information, 1, "The minimum interval between consecutive stale data events is set to 100 milliseconds"),
            //    new AppEntry(EventLogEntryType.Information, 1, "This component will check for updates in NPDB every 60000 milliseconds"),
            //    new AppEntry(EventLogEntryType.Information, 1, "The NPDB refresh timer is being created by a thread using the following windows identity: " + Environment.UserDomainName + "\\" + Environment.UserName),
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "A server list change handler threw an exception! (details below)\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "A server list change has been rejected by this component (details below)\n"),
            //    new AppEntry(EventLogEntryType.Error, 3, "A server list change has been accepted by this component (details below)\nEnvironment: xblob\nInterface: dummy_interface5\nOld Value: {dummy_server5A,dummy_server5B}\nNew Value: {dummy_server5A}"),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_NegInvalidParam()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "System.ArgumentNullException: Value cannot be null.\r\nParameter name: server"),
            //    // BUGBUG: 35018
            //    new AppEntry(EventLogEntryType.Error, 3, "System.ArgumentNullException: Value cannot be null.\r\nParameter name: server"),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_NegNoServer()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Warning, 4, "System.ApplicationException: Interface '" + TestInterfaces.dummy_interface1A + "' not present on server 'not_a_valid_server'"),
            //    // BUGBUG: 35018
            //    new AppEntry(EventLogEntryType.Error, 3, "System.ApplicationException: Interface '" + TestInterfaces.dummy_interface1A + "' not present on server 'not_a_valid_server'"),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_NegNoInterface()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Warning, 4, "System.ApplicationException: Interface '" + Interface.xcbk + "' not present on server '" + _testServer + "'"),
            //    // BUGBUG: 35018
            //    new AppEntry(EventLogEntryType.Error, 3, "System.ApplicationException: Interface '" + Interface.xcbk + "' not present on server '" + _testServer + "'"),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_InterfaceInfo_SqlConnectionString()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface3B + " does not have a database name specified."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_InterfaceInfo_ToString()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_PosNotNull()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1A + " does not have a Protocol of 'sql'."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_PosNull()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2A + " does not have a Protocol of 'sql'."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_EnvironmentTypeOverride_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1B + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1C + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2B + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2C + " does not have a Protocol of 'sql'."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_EnvironmentOverride_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1D + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1E + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2D + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2E + " does not have a Protocol of 'sql'."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_ServerOverride_Pos()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1F + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface1G + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2F + " does not have a Protocol of 'sql'."),
            //    new AppEntry(EventLogEntryType.Error, 3, "InterfaceInfo.SqlConnectionString: Interface " + TestInterfaces.dummy_interface2G + " does not have a Protocol of 'sql'."),
            //};
            //Assert.IsTrue(LogVerifyEventList(CPP_AppEntries, appEntries));
        }

        [TestCase]
        public void CPP_GetInterface_PosCache()
        {
            CPP_Base();

            //AppEntry[]  appEntries = {
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "A configuration change has been detected in NPDB\nNPDB will now be examined for relevant changes\n"),
            //    new AppEntry(EventLogEntryType.Information, 1, "An interface change has been accepted 