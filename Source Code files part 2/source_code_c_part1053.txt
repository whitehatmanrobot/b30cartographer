izationMutexReleased = TRUE;
                    ExReleaseFastMutex(&RxContextPerFileSerializationMutex);
                }

                if (DropFcbLock && !FcbLockDropped) {
                    RxContext->FcbResourceAcquired = FALSE;
                    FcbLockDropped = TRUE;
                    RxReleaseFcb(RxContext,capFcb);
                }

                RxDbgTrace( 0, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock waiting, rxc=%08lx\n", RxContext ));

                RxWaitSync(RxContext);

                RxDbgTrace( 0, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock ubblocked, rxc=%08lx\n", RxContext ));
            } else {
                RxContext->StoredStatus = STATUS_PENDING;
                SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME);

                try {
                    RxPrePostIrp(RxContext,capReqPacket);
                } finally {
                    if (AbnormalTermination()) {
                        RxLog(("!!!!! RxContext %lx Status %lx\n",RxContext, RxContext->StoredStatus));
                        RxWmiLog(LOG,
                                 RxSynchronizeBlockingOperationsMaybeDroppingFcbLock,
                                 LOGPTR(RxContext)
                                 LOGULONG(Status));
                        RemoveEntryList(&RxContext->RxContextSerializationQLinks);

                        RxContext->RxContextSerializationQLinks.Flink = NULL;
                        RxContext->RxContextSerializationQLinks.Blink = NULL;

                        ClearFlag(
                            RxContext->FlagsForLowIo,
                            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

                        if (!SerializationMutexReleased) {
                            SerializationMutexReleased = TRUE;
                            ExReleaseFastMutex(&RxContextPerFileSerializationMutex);
                        }
                    } else {
                        InterlockedIncrement(&RxContext->ReferenceCount);
                    }
                }

                RxDbgTrace(-1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock asyncreturn, rxc=%08lx\n", RxContext ));
            }
        }

        Status = (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED) ?
                  STATUS_CANCELLED :
                  RxContext->StoredStatus);

    } else {
        Status = STATUS_CANCELLED;
    }

    if (!SerializationMutexReleased) {
        SerializationMutexReleased = TRUE;
        ExReleaseFastMutex(&RxContextPerFileSerializationMutex);
    }

    if (DropFcbLock && !FcbLockDropped) {
        RxContext->FcbResourceAcquired = FALSE;
        FcbLockDropped = TRUE;
        RxReleaseFcb(RxContext,capFcb);
    }

    RxDbgTrace(-1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock returning, rxc=%08lx, status=%08lx\n", RxContext, Status ));

    return(Status);
}

VOID
RxRemoveOperationFromBlockingQueue(
    IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine removes the context from the blocking queue if it is on it

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    PAGED_CODE();

    ExAcquireFastMutex(&RxContextPerFileSerializationMutex);

    if (FlagOn(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION)) {
        ClearFlag(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

        RemoveEntryList(&RxContext->RxContextSerializationQLinks);

        RxContext->RxContextSerializationQLinks.Flink = NULL;
        RxContext->RxContextSerializationQLinks.Blink = NULL;
    }

    ExReleaseFastMutex(&RxContextPerFileSerializationMutex);

    RxDbgTrace(-1, Dbg, ("RxRemoveOperationFromBlockingQueue, rxc=%08lx\n", RxContext ));
    return;
}

VOID
RxCancelBlockingOperation(
    IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine cancels the operation in the blocking queue

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    PAGED_CODE();

    ExAcquireFastMutex(&RxContextPerFileSerializationMutex);

    if (FlagOn(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION)) {
        ClearFlag(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

        RemoveEntryList(&RxContext->RxContextSerializationQLinks);

        RxContext->RxContextSerializationQLinks.Flink = NULL;
        RxContext->RxContextSerializationQLinks.Blink = NULL;

        if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            RxSignalSynchronousWaiter(RxContext);
        } else {
            // The reference taken in the synchronization routine is derefernced
            // by the post completion routine,
            RxFsdPostRequest(RxContext);
        }
    }

    ExReleaseFastMutex(&RxContextPerFileSerializationMutex);

    RxDbgTrace(-1, Dbg, ("RxCancelBlockedOperations, rxc=%08lx\n", RxContext ));
    return;
}

VOID
RxResumeBlockedOperations_Serially(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    )
/*++

Routine Description:

    This routine wakes up the next guy, if any, on the serialized blockingioQ. We know that the fcb must still be valid because
    of the reference that is being held by the IO system on the file object thereby preventing a close.

Arguments:

    RxContext    The context of the operation being synchronized
    BlockingIoQ  The queue to get on.

--*/
{
    PLIST_ENTRY ListEntry;
    BOOLEAN FcbLockHeld = FALSE;
    PRX_CONTEXT FrontRxContext = NULL;

    PAGED_CODE();

    RxDbgTrace(
        +1,
        Dbg,
        ("RxResumeBlockedOperations_Serially, rxc=%08lx, fobx=%08lx\n",
         RxContext,
         RxContext->pFobx ));

    //remove myself from the queue and check for someone else
    ExAcquireFastMutex(&RxContextPerFileSerializationMutex);

    if (FlagOn(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION)) {
        ClearFlag(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

//        ValidateBlockingIoQ(BlockingIoQ);
        RemoveEntryList(&RxContext->RxContextSerializationQLinks);
//        ValidateBlockingIoQ(BlockingIoQ);

        RxContext->RxContextSerializationQLinks.Flink = NULL;
        RxContext->RxContextSerializationQLinks.Blink = NULL;

        ListEntry = BlockingIoQ->Flink;

        if (BlockingIoQ != ListEntry) {
            FrontRxContext = CONTAINING_RECORD(
                                 ListEntry,
                                 RX_CONTEXT,
                                 RxContextSerializationQLinks);
            RxDbgTrace(
                -1,
                Dbg,
                ("RxResumeBlockedOperations unwaiting the next guy and returning, rxc=%08lx\n",
                 RxContext ));
        } else {
            FrontRxContext = NULL;
        }

        if (FrontRxContext != NULL) {
            if (!FlagOn(FrontRxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                RxSignalSynchronousWaiter(FrontRxContext);
            } else {
                // The reference taken in the synchronization routine is derefernced
                // by the post completion routine,
                RxFsdPostRequest(FrontRxContext);
            }
        }
    }

    ExReleaseFastMutex(&RxContextPerFileSerializationMutex);

    RxDbgTrace(-1, Dbg, ("RxResumeBlockedOperations_Serially returning, rxc=%08lx\n", RxContext ));
    return;
}

VOID
RxResumeBlockedOperations_ALL(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine wakes up all of the guys on the blocked operations queue. The controlling mutex is also
    stored in the RxContext block. the current implementation is that all of the guys must be waiting
    on the sync events.

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    LIST_ENTRY CopyOfQueue;
    PLIST_ENTRY ListEntry;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxResumeBlockedOperations_ALL, rxc=%08lx\n", RxContext ));

    RxTransferListWithMutex(
        &CopyOfQueue,
        &RxContext->BlockedOperations,
        RxContext->BlockedOpsMutex);

    for (ListEntry = CopyOfQueue.Flink;
         ListEntry != &CopyOfQueue;
         ){
        PRX_CONTEXT FrontRxContext = CONTAINING_RECORD(
                                         ListEntry,
                                         RX_CONTEXT,
                                         RxContextSerializationQLinks);

        RxSignalSynchronousWaiter(FrontRxContext);

        IF_DEBUG {
            PLIST_ENTRY PrevListEntry = ListEntry;
            ListEntry = ListEntry->Flink;
            PrevListEntry->Flink = PrevListEntry->Blink = NULL;
        } else {
            ListEntry = ListEntry->Flink;
        }
    }

    RxDbgTrace(
        -1,
        Dbg,
        ("RxResumeBlockedOperations_ALL returning, rxc=%08lx\n",
        RxContext ));

    return;
}


VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    )
{
    if ((NodeType(RxContext)!=RDBSS_NTC_RX_CONTEXT) ||
         (RxContext->SerialNumber != CapturedRxContextSerialNumber)) {
        RxLog(("NotSame!!!! %lx",RxContext));
        RxWmiLog(LOG,
                 RxItsTheSameContext,
                 LOGPTR(RxContext));

        DbgPrint("NOT THE SAME CONTEXT %08lx at Line %d in %s\n",
                   RxContext,Line,File);
        //DbgBreakPoint();
    }
}

#if 0
VOID
ValidateBlockingIoQ(
    PLIST_ENTRY BlockingIoQ
)
{
    PLIST_ENTRY pListEntry;
    ULONG cntFlink, cntBlink;
    
    cntFlink = cntBlink = 0;
    
    pListEntry = BlockingIoQ->Flink;

    while (pListEntry != BlockingIoQ) {
        PRX_CONTEXT pRxContext;

        pRxContext = (PRX_CONTEXT)CONTAINING_RECORD(
                        pListEntry,
                        RX_CONTEXT,
                        RxContextSerializationQLinks);


        if (!pRxContext || (NodeType(pRxContext) != RDBSS_NTC_RX_CONTEXT))
        {
            
            DbgPrint("ValidateBlockingIO:Invalid RxContext %x on Q %x\n",
                     pRxContext, BlockingIoQ);
            //DbgBreakPoint();
        }


        ++cntFlink;
        pListEntry = pListEntry->Flink;
    }

    // check backward list validity

    pListEntry = BlockingIoQ->Blink;

    while (pListEntry != BlockingIoQ) {
        PRX_CONTEXT pRxContext;

        pRxContext = (PRX_CONTEXT)CONTAINING_RECORD(
                        pListEntry,
                        RX_CONTEXT,
                        RxContextSerializationQLinks);


        if (!pRxContext || (NodeType(pRxContext) != RDBSS_NTC_RX_CONTEXT))
        {
            
            DbgPrint("ValidateBlockingIO:Invalid RxContext %x on Q %x\n",
                     pRxContext, BlockingIoQ);
            //DbgBreakPoint();
        }

        ++cntBlink;
        pListEntry = pListEntry->Blink;
    }

    // both counts should be the same
    if(cntFlink != cntBlink)
    {
        DbgPrint("ValidateBlockingIO: cntFlink %d cntBlink %d\n", cntFlink, cntBlink);
        //DbgBreakPoint();
    }
}

#endif

#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG RxContextField_##x = FIELD_OFFSET(RX_CONTEXT,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG RxContextField_##x##y = FIELD_OFFSET(RX_CONTEXT,x.y);

DECLARE_FIELD_HLPR(MajorFunction);
DECLARE_FIELD_HLPR(CurrentIrp);
DECLARE_FIELD_HLPR(pFcb);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(MRxContext);
DECLARE_FIELD_HLPR(MRxCancelRoutine);
DECLARE_FIELD_HLPR(SyncEvent);
DECLARE_FIELD_HLPR(BlockedOperations);
DECLARE_FIELD_HLPR(FlagsForLowIo);
DECLARE_FIELD_HLPR2(Create,CanonicalNameBuffer);
DECLARE_FIELD_HLPR2(Create,pSrvCall);
DECLARE_FIELD_HLPR2(Create,pNetRoot);
DECLARE_FIELD_HLPR2(Create,pVNetRoot);
DECLARE_FIELD_HLPR2(QueryDirectory,FileIndex);
DECLARE_FIELD_HLPR2(QueryEa,UserEaList);
DECLARE_FIELD_HLPR2(QuerySecurity,SecurityInformation);
DECLARE_FIELD_HLPR2(QuerySecurity,Length);
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxconnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxConnct.c

Abstract:

    This module implements the nt version of the high level routines dealing with
    connections including both the routines for establishing connections and the
    winnet connection apis.

Author:

    Joe Linn     [JoeLinn]   1-mar-95

Revision History:

    Balan Sethu Raman [SethuR] --

--*/

#include "precomp.h"
#pragma hdrstop
#include "prefix.h"
#include "secext.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxExtractServerName)
#pragma alloc_text(PAGE, RxFindOrCreateConnections)
#pragma alloc_text(PAGE, RxCreateNetRootCallBack)
#pragma alloc_text(PAGE, RxConstructSrvCall)
#pragma alloc_text(PAGE, RxConstructNetRoot)
#pragma alloc_text(PAGE, RxConstructVirtualNetRoot)
#pragma alloc_text(PAGE, RxFindOrConstructVirtualNetRoot)
#endif

//
//  The local trace mask for this part of the module
//

#define Dbg                              (DEBUG_TRACE_CONNECT)


// Internal helper functions for establishing connections through mini redirectors

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

VOID
RxCreateSrvCallCallBack (
    IN PMRX_SRVCALL_CALLBACK_CONTEXT Context
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest. any of the output can be null

Arguments:

    FilePathName -- the given file name

    xSrvCallName -- the srv call name

    xNetRootName -- the net root name

    RestOfName   -- the remaining portion of the name

--*/
{
    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;
    UNICODE_STRING xRestOfName;

    PAGED_CODE();

    ASSERT(SrvCallName);

    SrvCallName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ) break;
        w++;
    }
    SrvCallName->Length = SrvCallName->MaximumLength
                = (USHORT)((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    RxDbgTrace( 0,Dbg,("  RxExtractServerName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0,Dbg,("         Srv=%wZ,Rest=%wZ\n",
                        SrvCallName,RestOfName));

    return;
}

NTSTATUS
RxFindOrCreateConnections (
    IN     PRX_CONTEXT         RxContext,
    IN     PUNICODE_STRING     CanonicalName,
    IN     NET_ROOT_TYPE       NetRootType,
    OUT    PUNICODE_STRING     LocalNetRootName,
    OUT    PUNICODE_STRING     FilePathName,
    IN OUT LOCK_HOLDING_STATE  *pLockHoldingState,
    IN     PRX_CONNECTION_ID   RxConnectionId
    )
/*++

Routine Description:

    This routine handles the call down from the MUP to claim a name or from the
    create path. If we don't find the name in the netname table, we pass the name
    down to the minirdrs to be connected. in the few places where it matters, we use
    the majorcode to distinguish between in MUP and create cases. there are a million
    cases depending on what we find on the initial lookup.

    these are the cases:

          found nothing                                        (1)
          found intransition srvcall                           (2)
          found stable/nongood srvcall                         (3)
          found good srvcall                                   (4&0)
          found good netroot          on good srvcall          (0)
          found intransition netroot  on good srvcall          (5)
          found bad netroot           on good srvcall          (6)
          found good netroot          on bad  srvcall          (3)
          found intransition netroot  on bad  srvcall          (3)
          found bad netroot           on bad  srvcall          (3)
          found good netroot          on intransition srvcall  (2)
          found intransition netroot  on intransition srvcall  (2)
          found bad netroot           on intransition srvcall  (2)

          (x) means that the code to handle that case has a marker
          like "case (x)". could be a comment....could be a debugout.

Arguments:

    IN  PRX_CONTEXT     RxContext,
    IN  PUNICODE_STRING CanonicalName,
    IN  NET_ROOT_TYPE   NetRootType,
    OUT PUNICODE_STRING LocalNetRootName,
    OUT PUNICODE_STRING FilePathName,
    IN OUT PLOCK_HOLDING_STATE LockHoldingState

Return Value:

    RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    UNICODE_STRING UnmatchedName;

    PVOID       Container = NULL;
    PSRV_CALL   SrvCall  = NULL;
    PNET_ROOT   NetRoot  = NULL;
    PV_NET_ROOT VNetRoot = NULL;

    PRX_PREFIX_TABLE  pRxNetNameTable
                      = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxFindOrCreateConnections -> %08lx\n", RxContext));

    // Parse the canonical name into the local net root name and file path name
    *FilePathName      = *CanonicalName;
    LocalNetRootName->Length        = 0;
    LocalNetRootName->MaximumLength = 0;
    LocalNetRootName->Buffer        = CanonicalName->Buffer;

    if (FilePathName->Buffer[1] == L';') {
        PWCHAR  pFilePathName = &FilePathName->Buffer[2];
        BOOLEAN SeparatorFound = FALSE;
        ULONG   PathLength = 0;

        if (FilePathName->Length > sizeof(WCHAR) * 2) {
            PathLength = FilePathName->Length - sizeof(WCHAR) * 2;
        }

        while (PathLength > 0) {
            if (*pFilePathName == L'\\') {
                SeparatorFound = TRUE;
                break;
            }

            PathLength -= sizeof(WCHAR);
            pFilePathName++;
        }

        if (!SeparatorFound) {
            return STATUS_OBJECT_NAME_INVALID;
        }

        FilePathName->Buffer = pFilePathName;
        LocalNetRootName->Length =
            (USHORT)((PCHAR)pFilePathName - (PCHAR)CanonicalName->Buffer);

        LocalNetRootName->MaximumLength = LocalNetRootName->Length;
        FilePathName->Length -= LocalNetRootName->Length;
    }

    RxDbgTrace( 0, Dbg, ("RxFindOrCreateConnections Path     = %wZ\n", FilePathName));

    try {
        UNICODE_STRING SrvCallName,NetRootName;

  RETRY_LOOKUP:
        ASSERT(*pLockHoldingState != LHS_LockNotHeld);
        if (Container != NULL) {
           // This is the subsequent pass of a lookup after waiting for the transition
           // to the stable state of a previous lookup.
           // Dereference the result of the earlier lookup.

           switch (NodeType(Container)) {
           case RDBSS_NTC_V_NETROOT:
              RxDereferenceVNetRoot((PV_NET_ROOT)Container,*pLockHoldingState);
              break;
           case RDBSS_NTC_SRVCALL:
              RxDereferenceSrvCall((PSRV_CALL)Container,*pLockHoldingState);
              break;
           case RDBSS_NTC_NETROOT:
              RxDereferenceNetRoot((PNET_ROOT)Container,*pLockHoldingState);
              break;
           default:
              DbgPrint("RxFindOrCreateConnections -- Invalid Container Type\n");
              break;
           }
        }

        Container = RxPrefixTableLookupName(
                         pRxNetNameTable,
                         FilePathName,
                         &UnmatchedName,
                         RxConnectionId );
        RxLog(("FOrCC1 %x %x %wZ \n",RxContext,Container,FilePathName));
        RxWmiLog(LOG,
                 RxFindOrCreateConnections_1,
                 LOGPTR(RxContext)
                 LOGPTR(Container)
                 LOGUSTR(*FilePathName));

RETRY_AFTER_LOOKUP:
        NetRoot  = NULL;
        SrvCall  = NULL;
        VNetRoot = NULL;

        RxContext->Create.pVNetRoot = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pSrvCall  = NULL;
        RxContext->Create.Type     = NetRootType;

        if ( Container ) {
            if (NodeType(Container) == RDBSS_NTC_V_NETROOT) {
                VNetRoot = (PV_NET_ROOT)Container;
                NetRoot  = (PNET_ROOT)VNetRoot->NetRoot;
                SrvCall  = (PSRV_CALL)NetRoot->SrvCall;

                if (NetRoot->Condition == Condition_InTransition) {
                   RxReleasePrefixTableLock(pRxNetNameTable);

                   RxWaitForStableNetRoot(NetRoot,RxContext);

                   RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);
                   *pLockHoldingState = LHS_ExclusiveLockHeld;

                   //
                   //  Since we had to drop the table lock and reacquire it,
                   //  our NetRoot pointer may be stale.  Look it up again before
                   //  using it.
                   //
                   //  NOTE:  The NetRoot is still referenced, so it is safe to
                   //         look at its condition.
                   //

                   if (NetRoot->Condition == Condition_Good) {
                       goto RETRY_LOOKUP;
                   }
                }

                if ((NetRoot->Condition == Condition_Good) &&
                    (SrvCall->Condition == Condition_Good) &&
                    (SrvCall->RxDeviceObject == RxContext->RxDeviceObject)   ) {
                    //case (0)...the good case...see comments below
                    RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)VNetRoot;
                    RxContext->Create.pNetRoot  = (PMRX_NET_ROOT)NetRoot;
                    RxContext->Create.pSrvCall  = (PMRX_SRV_CALL)SrvCall;

                    try_return ( Status = (STATUS_CONNECTION_ACTIVE) );
                } else {
                    Status = VNetRoot->ConstructionStatus==STATUS_SUCCESS ?
                                 STATUS_BAD_NETWORK_PATH:
                                 VNetRoot->ConstructionStatus;

                    RxDereferenceVNetRoot(VNetRoot,*pLockHoldingState);
                    try_return ( Status );
                }
            } else {
                ASSERT ( NodeType(Container) == RDBSS_NTC_SRVCALL);
                SrvCall = (PSRV_CALL)Container;
#if 0
                if ((NetRootType != NET_ROOT_MAILSLOT) &&
                    (SrvCall->Flags & SRVCALL_FLAG_MAILSLOT_SERVER)) {
                   RxDereferenceSrvCall(SrvCall,*pLockHoldingState);
                   try_return(Status = (STATUS_BAD_DEVICE_TYPE));
                }
#endif
                // The associated SRV_CALL is in the process of construction.
                // await the result.

                if (SrvCall->Condition == Condition_InTransition) {
                    RxDbgTrace(0, Dbg, ("   Case(3)\n", 0));
                    RxReleasePrefixTableLock(pRxNetNameTable);

                    RxWaitForStableSrvCall(SrvCall,RxContext);

                    RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);
                    *pLockHoldingState = LHS_ExclusiveLockHeld;

                    if (SrvCall->Condition == Condition_Good) {
                       goto RETRY_LOOKUP;
                    }
                }

                if (SrvCall->Condition != Condition_Good) {
                    Status = SrvCall->Status == STATUS_SUCCESS ?
                             STATUS_BAD_NETWORK_PATH:
                             SrvCall->Status;

                    //in changing this...remember precious servers.......
                    RxDereferenceSrvCall(SrvCall,*pLockHoldingState);
                    try_return(Status);
                }
            }
        }

        if ( (SrvCall != NULL)
               && (SrvCall->Condition == Condition_Good)
               && (SrvCall->RxDeviceObject != RxContext->RxDeviceObject) ) {
           RxDereferenceSrvCall(SrvCall,*pLockHoldingState);
           try_return(Status = (STATUS_BAD_NETWORK_NAME));
        }

        if (*pLockHoldingState == LHS_SharedLockHeld) {
           // Upgrade the lock to an exclusive lock
           if (!RxAcquirePrefixTableLockExclusive(pRxNetNameTable, FALSE) ) {
              RxReleasePrefixTableLock(pRxNetNameTable);
              RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);
              *pLockHoldingState = LHS_ExclusiveLockHeld;
              goto RETRY_LOOKUP;
           } else {
              *pLockHoldingState = LHS_ExclusiveLockHeld;
           }
        }

        ASSERT(*pLockHoldingState == LHS_ExclusiveLockHeld);

        // A prefix table entry was found. Further construction is required
        // if either a SRV_CALL was found or a SRV_CALL/NET_ROOT/V_NET_ROOT
        // in a bad state was found.

        if (Container) {
           RxDbgTrace(0, Dbg, ("   SrvCall=%08lx\n", SrvCall));
           ASSERT((NodeType(SrvCall) == RDBSS_NTC_SRVCALL) &&
                  (SrvCall->Condition == Condition_Good));
           ASSERT((NetRoot == NULL) && VNetRoot == NULL);

           RxDbgTrace(0, Dbg, ("   Case(4)\n", 0));
           ASSERT (SrvCall->RxDeviceObject == RxContext->RxDeviceObject);
           SrvCall->RxDeviceObject->Dispatch->MRxExtractNetRootName(
                       FilePathName,
                       (PMRX_SRV_CALL)SrvCall,
                       &NetRootName,
                       NULL);

           NetRoot = RxCreateNetRoot(
                             SrvCall,
                             &NetRootName,
                             0,
                             RxConnectionId);

           if (NetRoot == NULL) {
               Status = (STATUS_INSUFFICIENT_RESOURCES);
               try_return(Status);
           }

           NetRoot->Type = NetRootType;

           // Decrement the reference created by lookup. Since the newly created
           // netroot holds onto a reference it is safe to do so.
           RxDereferenceSrvCall(SrvCall,*pLockHoldingState);

           // Also create the associated default virtual net root
           VNetRoot = RxCreateVNetRoot(
                                     RxContext,
                                     NetRoot,
                                     CanonicalName,
                                     LocalNetRootName,
                                     FilePathName,
                                     RxConnectionId);

           if (VNetRoot == NULL) {
              RxFinalizeNetRoot(NetRoot,TRUE,TRUE);
              Status = (STATUS_INSUFFICIENT_RESOURCES);
              try_return(Status);
           }

           // Reference the VNetRoot
           RxReferenceVNetRoot(VNetRoot);

           NetRoot->Condition = Condition_InTransition;

           RxContext->Create.pSrvCall  = (PMRX_SRV_CALL)SrvCall;
           RxContext->Create.pNetRoot  = (PMRX_NET_ROOT)NetRoot;
           RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)VNetRoot;

           Status = RxConstructNetRoot(
                         RxContext,
                         SrvCall,
                         NetRoot,
                         VNetRoot,
                         pLockHoldingState);

           if (Status == (STATUS_SUCCESS)) {
              ASSERT(*pLockHoldingState == LHS_ExclusiveLockHeld);
              if (!(capPARAMS->Parameters.Create.Options & FILE_CREATE_TREE_CONNECTION)) {
                 // do not release the lock acquired by the callback routine ....
                 RxExclusivePrefixTableLockToShared(pRxNetNameTable);
                 *pLockHoldingState = LHS_SharedLockHeld;
              }
           } else {
              // Dereference the Virtual net root
              RxTransitionVNetRoot(VNetRoot, Condition_Bad);
              RxLog(("FOrCC %x %x Failed %x VNRc %d \n", RxContext, VNetRoot, Status, VNetRoot->Condition));
              RxWmiLog(LOG,
                       RxFindOrCreateConnections_2,
                       LOGPTR(RxContext)
                       LOGPTR(VNetRoot)
                       LOGULONG(Status)
                       LOGULONG(VNetRoot->Condition));

              RxDereferenceVNetRoot(VNetRoot,*pLockHoldingState);

              RxContext->Create.pNetRoot  = NULL;
              RxContext->Create.pVNetRoot = NULL;
           }

           try_return (Status);
        }

        // No prefix table entry was found. A new SRV_CALL instance needs to be
        // constructed.
        ASSERT(Container == NULL);

        RxExtractServerName(FilePathName,&SrvCallName,NULL);
        SrvCall = RxCreateSrvCall(RxContext,&SrvCallName,NULL,RxConnectionId);
        if (SrvCall == NULL) {
           Status = (STATUS_INSUFFICIENT_RESOURCES);
           try_return(Status);
        }

        RxReferenceSrvCall(SrvCall);

        RxContext->Create.Type     = NetRootType;
        RxContext->Create.pSrvCall  = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pVNetRoot = NULL;

        Status = RxConstructSrvCall(
                     RxContext,
                     SrvCall,
                     pLockHoldingState);

        ASSERT(!(Status==(STATUS_SUCCESS)) ||
               RxIsPrefixTableLockAcquired(pRxNetNameTable));

        if (Status != STATUS_SUCCESS) {
           if (SrvCall != NULL) {
              RxAcquirePrefixTableLockExclusive( pRxNetNameTable, TRUE);

              RxDereferenceSrvCall(SrvCall,LHS_ExclusiveLockHeld);

              RxReleasePrefixTableLock( pRxNetNameTable );
           }

           try_return(Status);
        } else {
           Container = SrvCall;
           goto RETRY_AFTER_LOOKUP;
        }

try_exit: NOTHING;
    } finally {
        if ((Status != (STATUS_SUCCESS)) &&
            (Status != (STATUS_CONNECTION_ACTIVE))) {
           if (*pLockHoldingState != LHS_LockNotHeld) {
              RxReleasePrefixTableLock( pRxNetNameTable );
              *pLockHoldingState = LHS_LockNotHeld;
           }
        }
    }

    ASSERT(!(Status==(STATUS_SUCCESS)) ||
           RxIsPrefixTableLockAcquired(pRxNetNameTable));

    return Status;
}

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

    This routine gets called when the minirdr has finished processing on
    a CreateNetRoot calldown. It's exact function depends on whether the context
    describes IRP_MJ_CREATE or an IRP_MJ_IOCTL.

Arguments:

    NetRoot   - describes the Net_Root.

--*/
{
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxCreateNetRootCallBack pCreateNetRootContext = %08lx\n",
                        pCreateNetRootContext));
    KeSetEvent(&pCreateNetRootContext->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}


NTSTATUS
RxFinishSrvCallConstruction(
    IN OUT PMRX_SRVCALLDOWN_STRUCTURE pSrvCalldownStructure)
/*++

Routine Description:

    This routine completes the construction of the srv call instance on an
    asyhcnronous manner

Arguments:

   SCCBC -- Call back structure

--*/
{
    PRX_CONTEXT        RxContext;
    RX_BLOCK_CONDITION SrvCallCondition;
    NTSTATUS           Status;
    PSRV_CALL          pSrvCall;
    PRX_PREFIX_TABLE  pRxNetNameTable;



    RxContext = pSrvCalldownStructure->RxContext;
    pRxNetNameTable = RxContext->RxDeviceObject->pRxNetNameTable;
    pSrvCall  = (PSRV_CALL)pSrvCalldownStructure->SrvCall;

    if ( pSrvCalldownStructure->BestFinisher == NULL) {
        SrvCallCondition = Condition_Bad;
        Status           = pSrvCalldownStructure->CallbackContexts[0].Status;
    } else {
        PMRX_SRVCALL_CALLBACK_CONTEXT CallbackContext;

        // Notify the Winner
        CallbackContext = &(pSrvCalldownStructure->CallbackContexts[pSrvCalldownStructure->BestFinisherOrdinal]);
        RxLog(("WINNER %x %wZ\n",CallbackContext,&pSrvCalldownStructure->BestFinisher->DeviceName));
        RxWmiLog(LOG,
                 RxFinishSrvCallConstruction,
                 LOGPTR(CallbackContext)
                 LOGUSTR(pSrvCalldownStructure->BestFinisher->DeviceName));
        ASSERT(pSrvCall->RxDeviceObject == pSrvCalldownStructure->BestFinisher);
        MINIRDR_CALL_THROUGH(
            Status,
            pSrvCalldownStructure->BestFinisher->Dispatch,
            MRxSrvCallWinnerNotify,
            (
                (PMRX_SRV_CALL)pSrvCall,
                TRUE,
                CallbackContext->RecommunicateContext
            ));

        if (STATUS_SUCCESS != Status) {
            SrvCallCondition = Condition_Bad;
        } else {
            SrvCallCondition = Condition_Good;
        }
    }

    // Transition the SrvCall instance ...
    RxAcquirePrefixTableLockExclusive(pRxNetNameTable, TRUE);

    RxTransitionSrvCall(pSrvCall,SrvCallCondition);

    RxFreePool(pSrvCalldownStructure);

    if (FlagOn(
            RxContext->Flags,
            RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
        RxReleasePrefixTableLock( pRxNetNameTable );

        // Resume the request that triggered the construction of the SrvCall ...
        if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
            Status = STATUS_CANCELLED;
        }

        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            RxpPrepareCreateContextForReuse(RxContext);
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxContext->ResumeRoutine(RxContext);

            if (Status != STATUS_PENDING) {
                RxCompleteRequest(RxContext,Status);
            }
        } else {
            RxCaptureRequestPacket;
            RxCaptureParamBlock;

            RxContext->MajorFunction = capPARAMS->MajorFunction;

            if (RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
                if (RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL) {
                    RxFreePool(RxContext->PrefixClaim.SuppliedPathName.Buffer);
                    RxContext->PrefixClaim.SuppliedPathName.Buffer = NULL;
                }
            }

            capReqPacket->IoStatus.Status = Status;
            capReqPacket->IoStatus.Information = 0;

            RxCompleteRequest(RxContext,Status);
        }
    }

    RxDereferenceSrvCall(pSrvCall,LHS_LockNotHeld);

    return Status;
}

BOOLEAN RxSrvCallConstructionDispatcherActive = FALSE;

VOID
RxFinishSrvCallConstructionDispatcher(
    PVOID Context)
/*++

Routine Description:

    This routine provides us with a throttling mechanism for controlling
    the number of threads that can be consumed by srv call construction in the
    thread pool. Currently this limit is set at 1.
    gets called when a minirdr has finished processing on

--*/
{
    KIRQL   SavedIrql;
    BOOLEAN RemainingRequestsForProcessing;
    BOOLEAN ResumeRequestsOnDispatchError;


    ResumeRequestsOnDispatchError = (Context == NULL);

    for (;;) {
        PLIST_ENTRY pSrvCalldownListEntry;
        PMRX_SRVCALLDOWN_STRUCTURE pSrvCalldownStructure;

        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

        pSrvCalldownListEntry = RemoveHeadList(
                                    &RxSrvCalldownList);

        if (pSrvCalldownListEntry != &RxSrvCalldownList) {
            RemainingRequestsForProcessing = TRUE;
        } else {
            RemainingRequestsForProcessing = FALSE;
            RxSrvCallConstructionDispatcherActive = FALSE;
        }

        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

        if (!RemainingRequestsForProcessing) {
            break;
        }

        pSrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)
                                CONTAINING_RECORD(
                                    pSrvCalldownListEntry,
                                    MRX_SRVCALLDOWN_STRUCTURE,
                                    SrvCalldownList);

        if (ResumeRequestsOnDispatchError) {
            pSrvCalldownStructure->BestFinisher = NULL;
        }

        RxFinishSrvCallConstruction(pSrvCalldownStructure);
    }
}

VOID
RxCreateSrvCallCallBack (
    IN PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC
    )
/*++

Routine Description:

    This routine gets called when a minirdr has finished processing on
    a CreateSrvCall calldown. The minirdr will have set the status in the passed
    context to indicate success or failure. what we have to do is
       1) decrease the number of outstanding requests and set the event
          if this is the last one.
       2) determine whether this guy is the winner of the call.

   the minirdr must get the strucsupspinlock in order to call this routine; this routine
   must NOT be called if the minirdr's call was successfully canceled.


Arguments:

   SCCBC -- Call back structure

--*/
{
    KIRQL SavedIrql;
    PMRX_SRVCALLDOWN_STRUCTURE pSrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);
    PSRV_CALL pSrvCall = (PSRV_CALL)pSrvCalldownStructure->SrvCall;

    ULONG   MiniRedirectorsRemaining;
    BOOLEAN Cancelled;

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    RxDbgTrace(0, Dbg, ("  RxCreateSrvCallCallBack SrvCall = %08lx\n",
                        pSrvCall));

    if (SCCBC->Status == (STATUS_SUCCESS)) {
        pSrvCalldownStructure->BestFinisher = SCCBC->RxDeviceObject;
        pSrvCalldownStructure->BestFinisherOrdinal = SCCBC->CallbackContextOrdinal;
    }

    pSrvCalldownStructure->NumberRemaining -= 1;
    MiniRedirectorsRemaining = pSrvCalldownStructure->NumberRemaining;
    pSrvCall->Status = SCCBC->Status;

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (MiniRedirectorsRemaining == 0) {
        if (!FlagOn(
                pSrvCalldownStructure->RxContext->Flags,
                RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            KeSetEvent(
                &pSrvCalldownStructure->FinishEvent,
                IO_NETWORK_INCREMENT,
                FALSE );
        } else if (FlagOn(
                       pSrvCalldownStructure->RxContext->Flags,
                       RX_CONTEXT_FLAG_CREATE_MAILSLOT)) {
            RxFinishSrvCallConstruction(pSrvCalldownStructure);
        } else {
            KIRQL   SavedIrql;
            BOOLEAN DispatchRequest;

            KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

            InsertTailList(
                &RxSrvCalldownList,
                &pSrvCalldownStructure->SrvCalldownList);

            DispatchRequest = !RxSrvCallConstructionDispatcherActive;

            if (!RxSrvCallConstructionDispatcherActive) {
                RxSrvCallConstructionDispatcherActive = TRUE;
            }

            KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

            if (DispatchRequest) {
                NTSTATUS DispatchStatus;
                DispatchStatus = RxDispatchToWorkerThread(
                                     RxFileSystemDeviceObject,
                                     CriticalWorkQueue,
                                     RxFinishSrvCallConstructionDispatcher,
                                     &RxSrvCalldownList);

                if (DispatchStatus != STATUS_SUCCESS) {
                    RxFinishSrvCallConstructionDispatcher(NULL);
                }
            }
        }
    }
}


NTSTATUS
RxConstructSrvCall(
    PRX_CONTEXT        RxContext,
    PSRV_CALL          pSrvCall,
    LOCK_HOLDING_STATE *pLockHoldingState)
/*++

Routine Description:

    This routine constructs a srv call by invoking the registered mini redirectors

Arguments:

    pSrvCall -- the server call whose construction is to be completed

    pLockHoldingState -- the prefix table lock holding status

Return Value:

    the appropriate status value

--*/
{
    RxCaptureRequestPacket;

    NTSTATUS             Status,WaitStatus;

    PMRX_SRVCALLDOWN_STRUCTURE pSrvCalldownStructure;
    RX_BLOCK_CONDITION         SrvCallCondition;
    BOOLEAN                    SynchronousOperation;

    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;
    PRX_PREFIX_TABLE  pRxNetNameTable = RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    ASSERT(*pLockHoldingState == LHS_ExclusiveLockHeld);

    SynchronousOperation = (!FlagOn(
                                RxContext->Flags,
                                RX_CONTEXT_FLAG_ASYNC_OPERATION));

    pSrvCalldownStructure = RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(MRX_SRVCALLDOWN_STRUCTURE) +
                                (sizeof(MRX_SRVCALL_CALLBACK_CONTEXT) * 1), //one minirdr in this call
                                'CSxR' );

    if (pSrvCalldownStructure == NULL) {
        pSrvCall->Condition = Condition_Bad;
        pSrvCall->Context = NULL;
        RxReleasePrefixTableLock( pRxNetNameTable );
        *pLockHoldingState = LHS_LockNotHeld;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pSrvCalldownStructure,
                  sizeof(MRX_SRVCALLDOWN_STRUCTURE) +
                  sizeof(MRX_SRVCALL_CALLBACK_CONTEXT) * 1);

    pSrvCall->Condition = Condition_InTransition;
    pSrvCall->Context = NULL;

    // Drop the prefix table lock before calling the mini redirectors.
    RxReleasePrefixTableLock( pRxNetNameTable );
    *pLockHoldingState = LHS_LockNotHeld;

    SCCBC = &(pSrvCalldownStructure->CallbackContexts[0]); //use the first and only context
    RxLog(("Calldwn %lx %wZ",SCCBC,&RxDeviceObject->DeviceName));
    RxWmiLog(LOG,
             RxConstructSrvCall,
             LOGPTR(SCCBC)
             LOGUSTR(RxDeviceObject->DeviceName));

    SCCBC->SrvCalldownStructure = pSrvCalldownStructure;
    SCCBC->CallbackContextOrdinal = 0;
    SCCBC->RxDeviceObject = RxDeviceObject;

   // This reference is taken away by the RxFinishSrvCallConstruction routine.
   // This reference enables us to deal with synchronous/asynchronous processing
   // of srv call construction requests in an identical manner.

   RxReferenceSrvCall(pSrvCall);

   if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
       RxPrePostIrp(RxContext,capReqPacket);
   } else {
       KeInitializeEvent(
            &pSrvCalldownStructure->FinishEvent,
            SynchronizationEvent,
            FALSE );
   }

   pSrvCalldownStructure->NumberToWait = 1;
   pSrvCalldownStructure->NumberRemaining = pSrvCalldownStructure->NumberToWait;
   pSrvCalldownStructure->SrvCall      = (PMRX_SRV_CALL)pSrvCall;
   pSrvCalldownStructure->CallBack     = RxCreateSrvCallCallBack;
   pSrvCalldownStructure->BestFinisher = NULL;
   pSrvCalldownStructure->RxContext    = RxContext;
   SCCBC->Status      = STATUS_BAD_NETWORK_PATH;

   InitializeListHead(&pSrvCalldownStructure->SrvCalldownList);

   MINIRDR_CALL_THROUGH(
                  Status,
                  RxDeviceObject->Dispatch,
                  MRxCreateSrvCall,
                  ((PMRX_SRV_CALL)pSrvCall,SCCBC),
                  );
   ASSERT(Status == STATUS_PENDING);

   if (SynchronousOperation) {
        WaitStatus = KeWaitForSingleObject(
                         &pSrvCalldownStructure->FinishEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

        Status = RxFinishSrvCallConstruction(pSrvCalldownStructure);

        if (Status != STATUS_SUCCESS) {
            RxReleasePrefixTableLock( pRxNetNameTable );
            *pLockHoldingState = LHS_LockNotHeld;
        } else {
            ASSERT(RxIsPrefixTableLockAcquired(pRxNetNameTable));
            *pLockHoldingState = LHS_ExclusiveLockHeld;
        }
   } else {
       Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
RxConstructNetRoot(
    PRX_CONTEXT          RxContext,
    PSRV_CALL            pSrvCall,
    PNET_ROOT            pNetRoot,
    PV_NET_ROOT          pVNetRoot,
    LOCK_HOLDING_STATE   *pLockHoldingState
    )
/*++

Routine Description:

    This routine constructs a net root by invoking the registered mini redirectors

Arguments:

    RxContext         -- the RDBSS context

    pSrvCall          -- the server call associated with the net root

    pNetRoot          -- the net root instance to be constructed

    pVirtualNetRoot   -- the virtual net root instance to be constructed

    pLockHoldingState -- the prefix table lock holding status

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS Status;

    PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext;

    RX_BLOCK_CONDITION NetRootCondition = Condition_Bad;
    RX_BLOCK_CONDITION VNetRootCondition = Condition_Bad;

    PRX_PREFIX_TABLE  pRxNetNameTable
                      = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    ASSERT(*pLockHoldingState == LHS_ExclusiveLockHeld);

    pCreateNetRootContext = (PMRX_CREATENETROOT_CONTEXT)
                            RxAllocatePoolWithTag( NonPagedPool,
                                  sizeof(MRX_CREATENETROOT_CONTEXT),
                                  'CSxR' );
    if (pCreateNetRootContext == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RxReleasePrefixTableLock( pRxNetNameTable );
    *pLockHoldingState = LHS_LockNotHeld;

    RtlZeroMemory(pCreateNetRootContext,sizeof(MRX_CREATENETROOT_CONTEXT));

    KeInitializeEvent( &pCreateNetRootContext->FinishEvent, SynchronizationEvent, FALSE );
    pCreateNetRootContext->Callback  = RxCreateNetRootCallBack;
    pCreateNetRootContext->RxContext = RxContext;
    pCreateNetRootContext->pVNetRoot = pVNetRoot;

    MINIRDR_CALL_THROUGH(
                Status,
                pSrvCall->RxDeviceObject->Dispatch,
                MRxCreateVNetRoot,(pCreateNetRootContext)
               );

    ASSERT (Status == STATUS_PENDING);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&pCreateNetRootContext->FinishEvent, Executive, KernelMode, FALSE, NULL);

        if ((pCreateNetRootContext->NetRootStatus == (STATUS_SUCCESS)) &&
            (pCreateNetRootContext->VirtualNetRootStatus == (STATUS_SUCCESS))) {
            RxDbgTrace(0, Dbg, ("Return to open, good netroot...%wZ\n",
                             &pNetRoot->PrefixEntry.Prefix));
            NetRootCondition = Condition_Good;
            VNetRootCondition = Condition_Good;
            Status = (STATUS_SUCCESS);
        } else {
            if (pCreateNetRootContext->NetRootStatus == (STATUS_SUCCESS)) {
               NetRootCondition = Condition_Good;
            }
            RxDbgTrace(0, Dbg, ("Return to open, bad netroot...%wZ\n",
                             &pNetRoot->PrefixEntry.Prefix));
            if (pCreateNetRootContext->VirtualNetRootStatus != (STATUS_SUCCESS)) {
               Status = pCreateNetRootContext->VirtualNetRootStatus;
            } else {
             Status = pCreateNetRootContext->NetRootStatus;
            }
        }
    }

    RxAcquirePrefixTableLockExclusive(pRxNetNameTable, TRUE);

    RxTransitionNetRoot(pNetRoot, NetRootCondition);
    RxTransitionVNetRoot(pVNetRoot,VNetRootCondition);

    *pLockHoldingState = LHS_ExclusiveLockHeld;

    if (pCreateNetRootContext->WorkQueueItem.List.Flink != NULL) {
        //DbgBreakPoint();
    }

    RxFreePool(pCreateNetRootContext);

    return Status;
}


NTSTATUS
RxConstructVirtualNetRoot(
   PRX_CONTEXT        RxContext,
   PUNICODE_STRING    CanonicalName,
   NET_ROOT_TYPE      NetRootType,
   PV_NET_ROOT        *pVirtualNetRootPointer,
   LOCK_HOLDING_STATE *pLockHoldingState,
   PRX_CONNECTION_ID  RxConnectionId)
/*++

Routine Description:

    This routine constructs a VNetRoot (View of a net root) by invoking the registered mini
    redirectors

Arguments:

    RxContext         -- the RDBSS context

    CanonicalName     -- the canonical name associated with the VNetRoot

    NetRootType       -- the type of the virtual net root

    pVirtualNetRoot   -- placeholder for the virtual net root instance to be constructed

    pLockHoldingState -- the prefix table lock holding status
    
    RxConnectionId    -- The ID used for multiplex control

Return Value:

    the appropriate status value

--*/
{
   NTSTATUS           Status;

   RX_BLOCK_CONDITION VNetRootCondition = Condition_Bad;

   UNICODE_STRING     FilePath;
   UNICODE_STRING     LocalNetRootName;

   PV_NET_ROOT        pVirtualNetRoot = NULL;

   PAGED_CODE();

   RxDbgTrace(0, Dbg, ("RxConstructVirtualNetRoot -- Entry\n"));

   ASSERT(*pLockHoldingState != LHS_LockNotHeld);

   Status = RxFindOrCreateConnections(
                  RxContext,
                  CanonicalName,
                  NetRootType,
                  &LocalNetRootName,
                  &FilePath,
                  pLockHoldingState,
                  RxConnectionId);

   if (Status == (STATUS_CONNECTION_ACTIVE)) {
      PV_NET_ROOT pActiveVNetRoot = (PV_NET_ROOT)(RxContext->Create.pVNetRoot);

      PNET_ROOT   pNetRoot  = (PNET_ROOT)pActiveVNetRoot->NetRoot;

      RxDbgTrace(0, Dbg, ("  RxConstructVirtualNetRoot -- Creating new VNetRoot\n"));
      RxDbgTrace(0, Dbg, ("RxCreateTreeConnect netroot=%wZ\n", &pNetRoot->PrefixEntry.Prefix));

      // The NetRoot has been previously constructed. A subsequent VNetRoot
      // construction is required since the existing VNetRoot's do not satisfy
      // the given criterion ( currently smae Logon Id's).

      pVirtualNetRoot = RxCreateVNetRoot(
                                        RxContext,
                                        pNetRoot,
                                        CanonicalName,
                                        &LocalNetRootName,
                                        &FilePath,
                                        RxConnectionId);

      // The skeleton VNetRoot has been constructed. ( As part of this construction
      // the underlying NetRoot and SrvCall has been referenced).
      if (pVirtualNetRoot != NULL) {
         RxReferenceVNetRoot(pVirtualNetRoot);
      }

      // Dereference the VNetRoot returned as part of the lookup.
      RxDereferenceVNetRoot(pActiveVNetRoot,LHS_LockNotHeld);

      RxContext->Create.pVNetRoot = NULL;
      RxContext->Create.pNetRoot  = NULL;
      RxContext->Create.pSrvCall  = NULL;

      if (pVirtualNetRoot != NULL) {
         Status = RxConstructNetRoot(
                        RxContext,
                        (PSRV_CALL)pVirtualNetRoot->NetRoot->SrvCall,
                        (PNET_ROOT)pVirtualNetRoot->NetRoot,
                        pVirtualNetRoot,
                        pLockHoldingState);

         VNetRootCondition = (Status == (STATUS_SUCCESS))
                              ? Condition_Good
                              : Condition_Bad;
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   } else if (Status == (STATUS_SUCCESS)) {
      *pLockHoldingState = LHS_ExclusiveLockHeld;
      VNetRootCondition = Condition_Good;
      pVirtualNetRoot = (PV_NET_ROOT)(RxContext->Create.pVNetRoot);
   } else {
      RxDbgTrace(0, Dbg, ("RxConstructVirtualNetRoot -- RxFindOrCreateConnections Status %lx\n",Status));
   }

   if ((pVirtualNetRoot != NULL) &&
       !StableCondition(pVirtualNetRoot->Condition)) {
      RxTransitionVNetRoot(pVirtualNetRoot,VNetRootCondition);
   }

   if (Status != (STATUS_SUCCESS)) {
      if (pVirtualNetRoot != NULL) {
         ASSERT(*pLockHoldingState  != LHS_LockNotHeld);
         RxDereferenceVNetRoot(pVirtualNetRoot,*pLockHoldingState);
         pVirtualNetRoot = NULL;
      }

      if (*pLockHoldingState != LHS_LockNotHeld) {
         RxReleasePrefixTableLock(
                  RxContext->RxDeviceObject->pRxNetNameTable);
         *pLockHoldingState = LHS_LockNotHeld;
      }
   }

   *pVirtualNetRootPointer = pVirtualNetRoot;

   RxDbgTrace(0, Dbg, ("RxConstructVirtualNetRoot -- Exit Status %lx\n",Status));

   return Status;
}

NTSTATUS
RxCheckVNetRootCredentials(
    PRX_CONTEXT     RxContext,
    PV_NET_ROOT     pVNetRoot,
    LUID            *pLogonId,
    PUNICODE_STRING pUserName,
    PUNICODE_STRING pUserDomainName,
    PUNICODE_STRING pPassword,
    ULONG           Flags
    )
{
    NTSTATUS Status;
    BOOLEAN  UNCName;
    BOOLEAN  TreeConnectFlagSpecified;
    PSecurityUserData pSecurityData = NULL;

    RxCaptureParamBlock;

    PAGED_CODE();

    Status = (STATUS_MORE_PROCESSING_REQUIRED);

    UNCName = BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME);

    TreeConnectFlagSpecified =
        BooleanFlagOn(capPARAMS->Parameters.Create.Options,FILE_CREATE_TREE_CONNECTION);

    // only for UNC names do we do the logic below
    if(RxContext->Create.Flags & RX_CONTEXT_CREATE_FLAG_UNC_NAME)
    {
        if ((pVNetRoot->Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE) !=
            (Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE))
        {
            // mismatched csc agent flags, not collapsing
            //DbgPrint("RxCheckVNetRootCredentials Not collapsing VNR %x \n", pVNetRoot);
            return Status;
        }
    }

    // The for loop is a scoping construct to join together the
    // multitiude of failure cases in comparing the EA parameters
    // with the original parameters supplied in the create request.
    for (;;) {
        if (RtlCompareMemory(&pVNetRoot->LogonId,pLogonId,sizeof(LUID)) == sizeof(LUID)) {
            PUNICODE_STRING TempUserName,TempUserDomainName;

            // If no EA parameters are specified by the user, the existing
            // V_NET_ROOT instance as used. This is the common case when
            // the user specifies the credentials for establishing a
            // persistent connection across processes and reuses them.

            if ((pUserName == NULL) &&
                (pUserDomainName == NULL) &&
                (pPassword == NULL)) {
                Status = STATUS_SUCCESS;
                break;
            }

            TempUserName = pVNetRoot->pUserName;
            TempUserDomainName = pVNetRoot->pUserDomainName;

            if (TempUserName == NULL ||
                TempUserDomainName == NULL) {
                Status = GetSecurityUserInfo(
                             pLogonId,
                             UNDERSTANDS_LONG_NAMES,
                             &pSecurityData);

                if (NT_SUCCESS(Status)) {
                    if (TempUserName == NULL) {
                        TempUserName = &(pSecurityData->UserName);
                    }

                    if (TempUserDomainName == NULL) {
                        TempUserDomainName = &(pSecurityData->LogonDomainName);
                    }
                } else {
                    break;
                }
            }

            // The logon ids match. The user has supplied EA parameters
            // which can either match with the existing credentials or
            // result in a conflict with the existing credentials. In all
            // such cases the outcome will either be a reuse of the
            // existing V_NET_ROOT instance or a refusal of the new connection
            // attempt.
            // The only exception to the above rule is in the case of
            // regular opens (FILE_CREATE_TREE_CONNECTION is not
            // specified for UNC names. In such cases the construction of a
            // new V_NET_ROOT is initiated which will be torn down
            // when the associated file is closed

            if (UNCName && !TreeConnectFlagSpecified) {
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
            }

            if (pUserName != NULL &&
                TempUserName != NULL &&
                !RtlEqualUnicodeString(TempUserName,pUserName,TRUE)) {
                break;
            }

            if (pUserDomainName != NULL &&
                !RtlEqualUnicodeString(TempUserDomainName,pUserDomainName,TRUE)) {
                break;
            }

            if ((pVNetRoot->pPassword != NULL) &&
                (pPassword != NULL)) {
                if (!RtlEqualUnicodeString(
                        pVNetRoot->pPassword,
                        pPassword,
                        FALSE)) {
                    break;
                }
            }

            // We use existing session if either the stored or new password is NULL.
            // Later, a new security API will be created for verify the password based
            // on the logon ID.

            Status = STATUS_SUCCESS;
            break;
        } else {
            break;
        }
    }

    //ASSERT(Status != STATUS_NETWORK_CREDENTIAL_CONFLICT);

    if (pSecurityData != NULL) {
        LsaFreeReturnBuffer(pSecurityData);
    }

    return Status;
}

NTSTATUS
RxFindOrConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PUNICODE_STRING    RemainingName)
/*++

Routine Description:

    This routine finds or constructs a VNetRoot (View of a net root)

Arguments:

    RxContext         -- the RDBSS context

    CanonicalName     -- the canonical name associated with the VNetRoot

    NetRootType       -- the type of the virtual net root

    RemainingName     -- the portion of the name that was not found in the prefix table

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS           Status;
    LOCK_HOLDING_STATE LockHoldingState;

    BOOLEAN Wait  = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    BOOLEAN UNCName;
    BOOLEAN TreeConnectFlagSpecified;

    PVOID         Container;

    PV_NET_ROOT   pVNetRoot;
    PNET_ROOT     pNetRoot;
    PSRV_CALL     pSrvCall;
    PRX_PREFIX_TABLE  pRxNetNameTable
                      = RxContext->RxDeviceObject->pRxNetNameTable;
    ULONG         Flags = 0;
    RX_CONNECTION_ID sRxConnectionId;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    RxCaptureParamBlock;

    PAGED_CODE();

    MINIRDR_CALL_THROUGH(
                   Status,
                   RxDeviceObject->Dispatch,
                   MRxGetConnectionId,
                   (RxContext,&sRxConnectionId)
                   );
    if( Status == STATUS_NOT_IMPLEMENTED )
    {
        RtlZeroMemory( &sRxConnectionId, sizeof(RX_CONNECTION_ID) );
    }
    else if( !NT_SUCCESS(Status) )
    {
        DbgPrint( "MRXSMB: Failed to initialize Connection ID\n" );
        ASSERT(FALSE);
        RtlZeroMemory( &sRxConnectionId, sizeof(RX_CONNECTION_ID) );
    }

    Status = (STATUS_MORE_PROCESSING_REQUIRED);

    UNCName = BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME);

    TreeConnectFlagSpecified =
        BooleanFlagOn(capPARAMS->Parameters.Create.Options,FILE_CREATE_TREE_CONNECTION);

    //deleterxcontext stuff will deref wherever this points.......
    RxContext->Create.NetNamePrefixEntry = NULL;

    RxAcquirePrefixTableLockShared(pRxNetNameTable, TRUE);
    LockHoldingState = LHS_SharedLockHeld;

    for(;;) {
        // This for loop actually serves as a simple scoping construct for executing
        // the same piece of code twice, once with a shared lock and once with an
        // exclusive lock. In the interests of maximal concurrency a shared lock is
        // accquired for the first pass and subsequently upgraded. If the search
        // succeeds with a shared lock the second pass is skipped.

        Container = RxPrefixTableLookupName( pRxNetNameTable, CanonicalName, RemainingName, &sRxConnectionId );

        if (Container != NULL ) {
            if (NodeType(Container) == RDBSS_NTC_V_NETROOT) {
                PV_NET_ROOT      pTempVNetRoot;
                ULONG            SessionId;

                pVNetRoot = (PV_NET_ROOT)Container;
                pNetRoot        = (PNET_ROOT)pVNetRoot->NetRoot;

                // Determine if a virtual net root with the same logon id. already exists.
                // If not a new virtual net root has to be constructed.
                // traverse the list of virtual net roots associated with a net root.
                // Note that the list of virtual net roots associated with a net root cannot be empty
                // since the construction of the default virtual net root coincides with the creation
                // of the net root.

                if (((pNetRoot->Condition == Condition_Good) ||
                    (pNetRoot->Condition == Condition_InTransition)) &&
                    (pNetRoot->pSrvCall->RxDeviceObject == RxContext->RxDeviceObject)) {
                    LUID             LogonId;
                    PUNICODE_STRING  pUserName,pUserDomainName,pPassword;

                    // Extract the VNetRoot parameters from the IRP to map one of
                    // the existing VNetRoots if possible. The algorithm for
                    // determining this mapping is very simplistic. If no Ea
                    // parameters are specified a VNetRoot with a matching Logon
                    // id. is choosen. if Ea parameters are specified then a
                    // VNetRoot with identical parameters is choosen. The idea
                    // behind this simplistic algorithm is to let the mini redirectors
                    // determine the mapping policy and not prefer one mini
                    // redirectors policy over another.

                    Status = RxInitializeVNetRootParameters(
                                 RxContext,
                                 &LogonId,
                                 &SessionId,
                                 &pUserName,
                                 &pUserDomainName,
                                 &pPassword,
                                 &Flags
                                 );

#if 0
                    if (Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE)
                    {
                        DbgPrint("RxFindOrConstructVirtualNetRoot AgentOpen %wZ\n", CanonicalName);
                    }
#endif
                    if (Status == STATUS_SUCCESS) {
                        pTempVNetRoot = pVNetRoot;

                        Status = RxCheckVNetRootCredentials(
                                     RxContext,
                                     pTempVNetRoot,
                                     &LogonId,
                                     pUserName,
                                     pUserDomainName,
                                     pPassword,
                                     Flags
                                     );

                        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                            // The for loop iterates over the existing VNetRoots to locate
                            // an instance whose parameters match the supplied parameters.
                            // On exit from this loop pTempVNetRoot will either point to a
                            // valid instance or have a NULL value.

                            pTempVNetRoot = (PV_NET_ROOT)CONTAINING_RECORD(
                                                pNetRoot->VirtualNetRoots.Flink,
                                                V_NET_ROOT,
                                                NetRootListEntry);

                            for (;;) {
                                Status = RxCheckVNetRootCredentials(
                                             RxContext,
                                             pTempVNetRoot,
                                             &LogonId,
                                             pUserName,
                                             pUserDomainName,
                                             pPassword,
                                             Flags
                                             );

                                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                                    if (pTempVNetRoot->NetRootListEntry.Flink == &pNetRoot->VirtualNetRoots) {
                                        pTempVNetRoot = NULL;
                                        break;
                                    } else {
                                        pTempVNetRoot = (PV_NET_ROOT)CONTAINING_RECORD(
                                                            pTempVNetRoot->NetRootListEntry.Flink,
                                                            V_NET_ROOT,
                                                            NetRootListEntry);
                                    }
                                } else {
                                    break;
                                }
                            }
                        }

                        if (Status != STATUS_SUCCESS) {
                            pTempVNetRoot = NULL;
                        }

                        RxUninitializeVNetRootParameters(pUserName,pUserDomainName,pPassword,&Flags);
                    }
                } else {
                    Status = (STATUS_BAD_NETWORK_PATH);
                    pTempVNetRoot = NULL;
                }

                if ((Status == STATUS_MORE_PROCESSING_REQUIRED) ||
                    (Status == STATUS_SUCCESS)) {
                    if (pTempVNetRoot != pVNetRoot) {
                        RxDereferenceVNetRoot(pVNetRoot,LockHoldingState);
                        pVNetRoot = pTempVNetRoot;

                        if (pVNetRoot != NULL) {
                            RxReferenceVNetRoot(pVNetRoot);
                        }
                    }
                } else {
                    if (pTempVNetRoot == NULL) {
                        RxDereferenceVNetRoot(pVNetRoot,LockHoldingState);
                    }
                }
            } else {
                ASSERT(NodeType(Container) == RDBSS_NTC_SRVCALL);
                RxDereferenceSrvCall((PSRV_CALL)Container,LockHoldingState);
            }
        }

        if ((Status == (STATUS_MORE_PROCESSING_REQUIRED)) &&
            (LockHoldingState == LHS_SharedLockHeld)) {
            // Release the shared lock and acquire it in an exclusive mode.
            // Upgrade the lock to an exclusive lock
            if (!RxAcquirePrefixTableLockExclusive(pRxNetNameTable, FALSE) ) {
                RxReleasePrefixTableLock(pRxNetNameTable);
                RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);
                LockHoldingState = LHS_ExclusiveLockHeld;
            } else {
                // The lock was upgraded from a shared mode to an exclusive mode without
                // losing it. Therefore there is no need to search the table again. The
                // construction of the new V_NET_ROOT can proceed.
                LockHoldingState = LHS_ExclusiveLockHeld;
                break;
            }
        } else {
            break;
        }
    }

    // At this point either the lookup was successful ( with a shared/exclusive lock )
    // or exclusive lock has been obtained.
    // No virtual net root was found in the prefix table or the net root that was found is bad.
    // The construction of a new virtual netroot needs to be undertaken.

    if (Status == (STATUS_MORE_PROCESSING_REQUIRED)) {
        ASSERT(LockHoldingState == LHS_ExclusiveLockHeld);
        Status = RxConstructVirtualNetRoot(
                     RxContext,
                     CanonicalName,
                     NetRootType,
                     &pVNetRoot,
                     &LockHoldingState,
                     &sRxConnectionId);

        ASSERT((Status != (STATUS_SUCCESS)) || (LockHoldingState != LHS_LockNotHeld));

        if (Status == (STATUS_SUCCESS)) {
            ASSERT(CanonicalName->Length >= pVNetRoot->PrefixEntry.Prefix.Length);
            RemainingName->Buffer = (PWCH)((PCHAR)CanonicalName->Buffer +
                                         pVNetRoot->PrefixEntry.Prefix.Length);
            RemainingName->Length = CanonicalName->Length -
                                 pVNetRoot->PrefixEntry.Prefix.Length;
            RemainingName->MaximumLength = RemainingName->Length;

            if (FlagOn(Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE))
            {
                RxLog(("FOrCVNR CSC instance %x\n", pVNetRoot));
                RxWmiLog(LOG,
                         RxFindOrConstructVirtualNetRoot,
                         LOGPTR(pVNetRoot));
//                DbgPrint("FOrCVNR CSC instance %wZ\n", CanonicalName);
            }
            pVNetRoot->Flags |= Flags;
        }
    }

    if (LockHoldingState != LHS_LockNotHeld) {
        RxReleasePrefixTableLock(pRxNetNameTable);
    }

    if (Status == (STATUS_SUCCESS)) {
        RxWaitForStableVNetRoot(pVNetRoot,RxContext);

        if (pVNetRoot->Condition == Condition_Good) {
            pNetRoot = (PNET_ROOT)pVNetRoot->NetRoot;
            pSrvCall = (PSRV_CALL)pNetRoot->SrvCall;
            RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)pVNetRoot;
            RxContext->Create.pNetRoot  = (PMRX_NET_ROOT)pNetRoot;
            RxContext->Create.pSrvCall  = (PMRX_SRV_CALL)pSrvCall;
        } else {
            RxDereferenceVNetRoot(pVNetRoot,LHS_LockNotHeld);
            RxContext->Create.pVNetRoot = NULL;
            Status = (STATUS_BAD_NETWORK_PATH);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxdebug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.c

Abstract:

    This module implements functions supporting read/write tracking for help in
    tracking down data corruption problems.

    Currently it is only implemented for files that are created of drive
    letter X:. For each file that is created there are three additional bitmaps
    are created. The first one marks the ranges of fileoffset, length for which
    write were submitted to rdbss. The second  bitmap marks the ranges of the
    file for which write requests were passed onto the mini redirector
    (initiation of Lowio). The third bitmap marks the ranges for which the I/O
    was successfully completed.

    Each bit map kas 8k bits long enough to accomodate files upto ( 8K * PAGE_SIZE)
    bytes. The FCB contains a pointer to this data structure. The data structure
    is independent of FCB's and a new one is created everytime a new FCB instance
    is created.

Author:

    Balan Sethu Raman --

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#ifdef RDBSSLOG
#include <stdio.h>
#endif

VOID
RxInitializeDebugSupport()
{
#ifdef RX_WJ_DBG_SUPPORT
    RxdInitializeWriteJournalSupport();
#endif
}

VOID
RxTearDownDebugSupport()
{
#ifdef RX_WJ_DBG_SUPPORT
    RxdTearDownWriteJournalSupport();
#endif
}

#ifdef RX_WJ_DBG_SUPPORT

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxdInitializeWriteJournalSupport)
#pragma alloc_text(PAGE, RxdTearDownWriteJournalSupport)
#pragma alloc_text(PAGE, RxdInitializeFcbWriteJournalDebugSupport)
#pragma alloc_text(PAGE, RxdTearDownFcbWriteJournalDebugSupport)
#pragma alloc_text(PAGE, RxdUpdateJournalOnWriteInitiation)
#pragma alloc_text(PAGE, RxdUpdateJournalOnLowIoWriteInitiation)
#pragma alloc_text(PAGE, RxdUpdateJournalOnLowIoWriteCompletion)
#pragma alloc_text(PAGE, RxdFindWriteJournal)
#pragma alloc_text(PAGE, UpdateBitmap)
#endif

LIST_ENTRY OldWriteJournals;
LIST_ENTRY ActiveWriteJournals;
ERESOURCE  WriteJournalsResource;

extern VOID
UpdateBitmap(
    PBYTE           pBitmap,
    LARGE_INTEGER   Offset,
    ULONG           Length);

extern PFCB_WRITE_JOURNAL
RxdFindWriteJournal(
    PFCB pFcb);

VOID
RxdInitializeWriteJournalSupport()
{
    PAGED_CODE();

    InitializeListHead(&ActiveWriteJournals);
    InitializeListHead(&OldWriteJournals);

    ExInitializeResource(&WriteJournalsResource);
}

VOID
RxdTearDownWriteJournalSupport()
{
    PLIST_ENTRY pJournalEntry;

    PFCB_WRITE_JOURNAL pJournal;

    PAGED_CODE();

    ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

    while (ActiveWriteJournals.Flink != &ActiveWriteJournals) {
        pJournalEntry = RemoveHeadList(&ActiveWriteJournals);

        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        RxFreePool(pJournal);
    }

    while (OldWriteJournals.Flink != &OldWriteJournals) {
        pJournalEntry = RemoveHeadList(&OldWriteJournals);

        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        RxFreePool(pJournal);
    }

    ExReleaseResource(&WriteJournalsResource);

    ExDeleteResource(&WriteJournalsResource);
}

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb)
{
    PFCB_WRITE_JOURNAL pJournal;

    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        pJournal = RxAllocatePoolWithTag(
                       PagedPool | POOL_COLD_ALLOCATION,
                       sizeof(FCB_WRITE_JOURNAL),
                       RX_MISC_POOLTAG);

        if (pJournal != NULL) {
            ULONG PathLength;

            RtlZeroMemory(
                pJournal,
                sizeof(FCB_WRITE_JOURNAL));

            pJournal->pName = &pJournal->Path[0];

            if (pFcb->AlreadyPrefixedName.Length > (MAX_PATH * sizeof(WCHAR))) {
                PathLength = MAX_PATH * sizeof(WCHAR);
            } else {
                PathLength = pFcb->AlreadyPrefixedName.Length;
            }

            RtlCopyMemory(
                pJournal->pName,
                pFcb->AlreadyPrefixedName.Buffer,
                PathLength);

            pJournal->pFcb = pFcb;

            pJournal->pWriteInitiationBitmap = pJournal->WriteInitiationBitmap;
            pJournal->pLowIoWriteInitiationBitmap = pJournal->LowIoWriteInitiationBitmap;
            pJournal->pLowIoWriteCompletionBitmap = pJournal->LowIoWriteCompletionBitmap;

            ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

            InsertHeadList(
                &ActiveWriteJournals,
                &pJournal->JournalsList);

            ExReleaseResource(&WriteJournalsResource);
        }
    }
}

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            RemoveEntryList(&pJournal->JournalsList);

//            InsertHeadList(
//                &OldWriteJournals,
//                &pJournal->JournalsList);

            RxFreePool(pJournal);
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->WriteInitiationBitmap,
                Offset,
                Length);

            pJournal->WritesInitiated++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {

        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->LowIoWriteInitiationBitmap,
                Offset,
                Length);

            pJournal->LowIoWritesInitiated++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->LowIoWriteCompletionBitmap,
                Offset,
                Length);

            pJournal->LowIoWritesCompleted++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

PFCB_WRITE_JOURNAL
RxdFindWriteJournal(
    PFCB pFcb)
{
    PFCB_WRITE_JOURNAL pJournal;
    PLIST_ENTRY pJournalEntry;

    PAGED_CODE();

    pJournalEntry = ActiveWriteJournals.Flink;
    while (pJournalEntry != &ActiveWriteJournals) {
        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        if (pJournal->pFcb == pFcb) {
            break;
        } else {
            pJournalEntry = pJournalEntry->Flink;
        }
    }

    if (pJournalEntry == &ActiveWriteJournals) {
        pJournal = NULL;
    }

    return pJournal;
}

CHAR PageMask[8] = { 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};

VOID
UpdateBitmap(
    PBYTE           pBitmap,
    LARGE_INTEGER   Offset,
    ULONG           Length)
{
    LONG    OffsetIn4kChunks;
    LONG    OffsetIn32kChunks;
    LONG    NumberOf4kChunks,Starting4kChunk;

    PAGED_CODE();

    // Each byte in the bit map represents a 32k region since each bit represents
    // a 4k region in the file.
    // we ignore the offset's high part for now because the bitmap's max size is
    // far less than what can be accomodated in the low part.

    OffsetIn4kChunks  = Offset.LowPart / (0x1000);
    OffsetIn32kChunks = Offset.LowPart / (0x8000);

    Starting4kChunk = ((Offset.LowPart & ~0xfff) - (Offset.LowPart & ~0x7fff)) / 0x1000;
    NumberOf4kChunks = Length / 0x1000;

    if (NumberOf4kChunks > (8 - Starting4kChunk)) {
        pBitmap[OffsetIn32kChunks++] |= (PageMask[7] & ~PageMask[Starting4kChunk]);
        Length -= (8 - Starting4kChunk) * 0x1000;
    }

    if (Length > 0x8000) {
        while (Length > (0x8000)) {
            pBitmap[OffsetIn32kChunks++] = PageMask[7];
            Length -= (0x8000);
        }

        Starting4kChunk = 0;
    }

    // The final chunk is less then 32k. The byte in the bitmao needs to be
    // updated accordingly.

    if (Length > 0) {
        NumberOf4kChunks = Length / (0x1000);
        pBitmap[OffsetIn32kChunks] |= PageMask[NumberOf4kChunks + Starting4kChunk];
    }
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxlog.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.c

Abstract:

    This module implements the logging system used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

    Balan Sethu Raman [SethuR] 24-April-95
         Revised to conform to new log record layout.

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "prefix.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxUninitializeLog)
#pragma alloc_text(PAGE, RxInitializeLog)
#pragma alloc_text(PAGE, RxPrintLog)
#pragma alloc_text(PAGE, RxpTrackDereference)
#endif

#if !DBG
#undef RDBSSTRACE
#endif

//
//  The debug trace level
//

#define Dbg                              (0)

#define RDBSSHUGELOG

#if DBG
#define RX_LOG_BUFFER_SIZE 5000
#else
#if RDBSSLOG
#define RX_LOG_BUFFER_SIZE 500
#else
#define RX_LOG_BUFFER_SIZE 0
#endif
#endif

#define MAX_RX_LOG_BUFFER_ALLOC   (256*1024)
#define RX_LOG_MAX_MDLLIST_LENGTH 100

RX_LOG s_RxLog = {0,RX_LOG_UNINITIALIZED,NULL,NULL,NULL,0,0,0,0};

PUCHAR RxContxOperationNames[] = {
      RDBSSLOG_ASYNC_NAME_PREFIX "CREATE",    //#define IRP_MJ_CREATE                   0x00
      RDBSSLOG_ASYNC_NAME_PREFIX "CR_NMPIPE", //#define IRP_MJ_CREATE_NAMED_PIPE        0x01
      RDBSSLOG_ASYNC_NAME_PREFIX "CLOSE",     //#define IRP_MJ_CLOSE                    0x02
      RDBSSLOG_ASYNC_NAME_PREFIX "READ",      //#define IRP_MJ_READ                     0x03
      RDBSSLOG_ASYNC_NAME_PREFIX "WRITE",     //#define IRP_MJ_WRITE                    0x04
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYINFO", //#define IRP_MJ_QUERY_INFORMATION        0x05
      RDBSSLOG_ASYNC_NAME_PREFIX "SETINFO",   //#define IRP_MJ_SET_INFORMATION          0x06
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYEA",   //#define IRP_MJ_QUERY_EA                 0x07
      RDBSSLOG_ASYNC_NAME_PREFIX "SETEA",     //#define IRP_MJ_SET_EA                   0x08
      RDBSSLOG_ASYNC_NAME_PREFIX "FLUSH",     //#define IRP_MJ_FLUSH_BUFFERS            0x09
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYVOL",  //#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
      RDBSSLOG_ASYNC_NAME_PREFIX "SETVOL",    //#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
      RDBSSLOG_ASYNC_NAME_PREFIX "DIRCTRL",   //#define IRP_MJ_DIRECTORY_CONTROL        0x0c
      RDBSSLOG_ASYNC_NAME_PREFIX "FSCTL",     //#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
      RDBSSLOG_ASYNC_NAME_PREFIX "IOCTL",     //#define IRP_MJ_DEVICE_CONTROL           0x0e
      RDBSSLOG_ASYNC_NAME_PREFIX "xIOCTL",    //#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
      RDBSSLOG_ASYNC_NAME_PREFIX "SHUTDWN",   //#define IRP_MJ_SHUTDOWN                 0x10
      RDBSSLOG_ASYNC_NAME_PREFIX "LOCKCTRL",  //#define IRP_MJ_LOCK_CONTROL             0x11
      RDBSSLOG_ASYNC_NAME_PREFIX "CLEANUP",   //#define IRP_MJ_CLEANUP                  0x12
      RDBSSLOG_ASYNC_NAME_PREFIX "CR_MLSLOT", //#define IRP_MJ_CREATE_MAILSLOT          0x13
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYSCRTY",//#define IRP_MJ_QUERY_SECURITY           0x14
      RDBSSLOG_ASYNC_NAME_PREFIX "SETSCRTY",  //#define IRP_MJ_SET_SECURITY             0x15
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYPWR",  //#define IRP_MJ_QUERY_POWER              0x16
      RDBSSLOG_ASYNC_NAME_PREFIX "NOTDEFND",  //#define IRP_MJ_NOT_DEFINED              0x17
      RDBSSLOG_ASYNC_NAME_PREFIX "DVCHANGE",  //#define IRP_MJ_DEVICE_CHANGE            0x18
      RDBSSLOG_ASYNC_NAME_PREFIX "QRYQUOTA",  //#define IRP_MJ_QUERY_QUOTA              0x19
      RDBSSLOG_ASYNC_NAME_PREFIX "SETQUOTA",  //#define IRP_MJ_SET_QUOTA                0x1a
      RDBSSLOG_ASYNC_NAME_PREFIX "PNPPOWER",  //#define IRP_MJ_PNP_POWER                0x1b
      RDBSSLOG_ASYNC_NAME_PREFIX "********",  //internal init            0x1c
        "XX"
         //#define IRP_MJ_MAXIMUM_FUNCTION         0x1b
         };

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry(void)
{
    PRX_LOG_ENTRY_HEADER pEntry;
    // you have to hold the spinlock for this....

    pEntry = s_RxLog.CurrentEntry + 1;
    if (pEntry == s_RxLog.EntryLimit){
        s_RxLog.NumberOfLogWraps++;
        pEntry = s_RxLog.BaseEntry;
    }

    s_RxLog.CurrentEntry = pEntry;
    return pEntry;
}

VOID
RxUninitializeLog ()
{
    PRX_LOG_ENTRY_HEADER EntryLimit = s_RxLog.EntryLimit;
    PMDL *MdlList = (PMDL *)(EntryLimit+1);

    PAGED_CODE();

    //NOTE: none of this is happening under spinlock!
    //DbgPrint("UninitLog: mdllist=%08lx,*mdllist=%08lx\n",MdlList,*MdlList);
    //DbgBreakPoint();

    if ((s_RxLog.State == RX_LOG_UNINITIALIZED) ||
        (s_RxLog.State == RX_LOG_ERROR)) {
        return;
    }

    s_RxLog.State = RX_LOG_UNINITIALIZED;

    for (;;) {
        PMDL Mdl = *MdlList;
        PUCHAR Buffer;
        if (Mdl == NULL) break;
        Buffer = MmGetMdlVirtualAddress(Mdl);
        //DbgPrint("UninitLog: buffer=%08lx,mdl=%08lx\n",Buffer,Mdl);
        MmUnlockPages(Mdl);
        IoFreeMdl(Mdl);
        RxFreePool(Buffer);
        MdlList++;
    }

    RxFreePool(s_RxLog.BaseEntry);
    return;
};



NTSTATUS
RxInitializeLog ()
{
    ULONG NumEntries = RX_LOG_BUFFER_SIZE;
    ULONG NumEntriesLeft;
    ULONG LogSize = (NumEntries+1)*sizeof(RX_LOG_ENTRY_HEADER);
    PRX_LOG_ENTRY_HEADER BaseEntry=NULL,EntryLimit=NULL;
    PRX_LOG_ENTRY_HEADER p;
    PUCHAR NextBuffer;
    PMDL *MdlList;
    ULONG MdlListLength = RX_LOG_MAX_MDLLIST_LENGTH*sizeof(PMDL);
    ULONG MdlsLeft = RX_LOG_MAX_MDLLIST_LENGTH;
    ULONG SpaceLeft;

    PAGED_CODE();

    if (s_RxLog.State != RX_LOG_UNINITIALIZED) {
        return (STATUS_SUCCESS);
    }
    //only do this stuff once
    KeInitializeSpinLock( &s_RxLog.SpinLock );
    s_RxLog.LogBufferSizeInEntries = NumEntries;

    //first allocate the marginal index array
    BaseEntry = RxAllocatePoolWithTag(NonPagedPool,LogSize+MdlListLength,'xr');
    if (BaseEntry==NULL) {
        s_RxLog.State = RX_LOG_ERROR;
        DbgPrint("Couldn't initialize log1");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    s_RxLog.BaseEntry = BaseEntry;
    EntryLimit = s_RxLog.EntryLimit = BaseEntry+NumEntries;
    MdlList = (PMDL *)(EntryLimit+1);
    *MdlList = 0;
    //DbgPrint("InitLog: mdllist=%08lx,*mdllist=%08lx\n",MdlList,*MdlList);

    //now allocate wspace for the actual buffers...since we may be asking for a lot
    // we allocate from pages pool and lock down.

    SpaceLeft = 0;
    for (   p=BaseEntry,NumEntriesLeft=NumEntries;
            NumEntriesLeft>0;
            p++,NumEntriesLeft--  ) {

        if (SpaceLeft<sizeof(RX_LOG_ENTRY_HEADER)) {
            PMDL Mdl = NULL;
            PUCHAR Buffer=NULL;
            NTSTATUS Status;
            ULONG AllocLength = min(MAX_RX_LOG_BUFFER_ALLOC,
                                    NumEntriesLeft*MAX_RX_LOG_ENTRY_SIZE);
            for (;;) {
                Buffer = RxAllocatePoolWithTag(PagedPool,AllocLength,'xr');
                if (Buffer) break;
                DbgPrint("InitLog: failed alloc at %08lx",AllocLength);
                if (AllocLength<PAGE_SIZE) break;
                AllocLength >>= 3;
                NumEntriesLeft = AllocLength / MAX_RX_LOG_ENTRY_SIZE;
            }
            if (Buffer==NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log2");
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            if (MdlsLeft==0) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log3");
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            Mdl = RxAllocateMdl(Buffer,AllocLength);
            if (Mdl==NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log4");
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            RxProbeAndLockPages(Mdl,KernelMode,IoModifyAccess,Status);
            if (Status!=(STATUS_SUCCESS)) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log5");
                RxFreePool(Mdl);
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return Status;
            }
            //DbgPrint("InitLog: newbuf=%08lx,mdl=%08lx,alloc=%08lx\n",Buffer,Mdl,AllocLength);
            MdlsLeft--;
            *MdlList = Mdl;
            MdlList++;
            *MdlList = NULL;

            NextBuffer = MmGetSystemAddressForMdlSafe(Mdl, LowPagePriority);

            if (NextBuffer == NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log5");
                MmUnlockPages(Mdl);
                RxFreePool(Mdl);
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            SpaceLeft = AllocLength;
        }

        p->Buffer = NextBuffer;
        *((PULONG)NextBuffer) = '###';
        NextBuffer += MAX_RX_LOG_ENTRY_SIZE;
        SpaceLeft -= MAX_RX_LOG_ENTRY_SIZE;
    }

    //DbgPrint("Init Log: numeleft,nummleft=%d,%d\n",NumEntriesLeft,MdlsLeft);
    p->Buffer = (PUCHAR)IntToPtr(0xf00df00d);
    s_RxLog.State = RX_LOG_ENABLED;
    s_RxLog.CurrentEntry = EntryLimit-1;

    //DbgPrint("Init Log: exit\n");
    return((STATUS_SUCCESS));

}

VOID
_RxPauseLog ()
{
    KIRQL oldIrql;

    KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

    if (s_RxLog.State == RX_LOG_ENABLED) {
       s_RxLog.State = RX_LOG_DISABLED;
    }

    KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );
}

VOID
_RxResumeLog()
{
    KIRQL oldIrql;

    KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

    if (s_RxLog.State == RX_LOG_DISABLED) {
       s_RxLog.State = RX_LOG_ENABLED;
    }

    KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );
}

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    )
{
    //KIRQL oldIrql;
    PRX_LOG_ENTRY_HEADER LogEntry,EntryLimit;
    ULONG i=0;

    PAGED_CODE();

    RxPauseLog();

    if (EntriesToPrint==0) {
        EntriesToPrint =  RX_LOG_BUFFER_SIZE;
    }
    DbgPrint("\n\n\nLog Print: Entries = %lu \n", EntriesToPrint);

    LogEntry = s_RxLog.CurrentEntry-1;
    EntryLimit = s_RxLog.EntryLimit;
    for (;EntriesToPrint>0;EntriesToPrint--) {
        LogEntry++;
        if (LogEntry>=EntryLimit) {
            LogEntry = s_RxLog.BaseEntry;
        }
        DbgPrint("%0ld: %s\n",i++,LogEntry->Buffer);
    }

    RxResumeLog();
}


VOID
_RxLog(char *Format, ...)
{
   va_list arglist;
   KIRQL   oldIrql;
   CLONG   LogEntryLength = 0;
   BOOLEAN fLogNewEntry = TRUE;
   PRX_LOG_ENTRY_HEADER LogEntry;
   CHAR    EntryString[MAX_RX_LOG_ENTRY_SIZE];
   PCHAR   pEntryString;
   CHAR    FormatChar;
   CHAR    FieldString[MAX_RX_LOG_ENTRY_SIZE];
   ULONG   FieldLength;
   char *OriginalFormat = Format;
   ULONG BinaryArgs = 0;
   ULONG BinaryStringMask = 1;  //the first arg is always a string!!!!

   //DbgPrint("RxLog: entry\n");
   if (s_RxLog.State != RX_LOG_ENABLED) {
      return;
   }

   pEntryString = EntryString;

   va_start(arglist, Format);
   //DbgBreakPoint();

   for (;;) {
      // Copy the format string
      while ((LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) &&
             ((FormatChar = *Format++) != '\0') &&
             (FormatChar != '%')) {
         if (FormatChar != '\n'){
             pEntryString[LogEntryLength++] = FormatChar;
         }
      }

      if ((LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) &&
          (FormatChar == '%')) {
         if ( (*Format == 'l') || (*Format == 'w') ) {
            Format++;
         }
         switch (*Format++) {
         case 'N': //binary placement -- don't try to make it foolproof
            {
                BinaryArgs++;
                *((PULONG)(&EntryString[sizeof(ULONG)])+BinaryArgs) = (ULONG)va_arg(arglist,ULONG);
            }
            break;
         case 'S': //binary placement -- don't try to make it foolproof
            {
                BinaryArgs++;
                BinaryStringMask |= 1<<(BinaryArgs-1);
                //DbgPrint("BSM %08lx\n",BinaryStringMask);
                *((PULONG)(&EntryString[sizeof(ULONG)])+BinaryArgs) = (ULONG)va_arg(arglist,ULONG);
            }
            break;
         case 'd':
            {
              // _itoa((LONG)va_arg(arglist,LONG),FieldString,10);
              // FieldLength = strlen(FieldString);// + 1;
              // if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
              //    strcpy(&pEntryString[LogEntryLength],FieldString);
              //    LogEntryLength += FieldLength;
              //    //pEntryString[LogEntryLength - 1] = ' ';
              // }
                LONG l = (LONG)va_arg(arglist,LONG);
                if ((LogEntryLength + 5) < MAX_RX_LOG_ENTRY_SIZE) {
                    pEntryString[LogEntryLength++] = 0x5;
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>0));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>8));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>16));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>24));
                }
            }
            break;
         case 'c':
            pEntryString[LogEntryLength++] = (CHAR)va_arg(arglist,char);
            break;
         case 'x':
            {
              // _itoa((LONG)va_arg(arglist,LONG),FieldString,16);
              // FieldLength = strlen(FieldString);// + 1;
              // if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
              //    strcpy(&pEntryString[LogEntryLength],FieldString);
              //    LogEntryLength += FieldLength;
              //    //pEntryString[LogEntryLength - 1] = ' ';
              // }
                LONG l = (LONG)va_arg(arglist,LONG);
                if ((LogEntryLength + 5) < MAX_RX_LOG_ENTRY_SIZE) {
                    pEntryString[LogEntryLength++] = 0x4;
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>0));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>8));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>16));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>24));
                }
            }
            break;
         case 's':
            {
               PCHAR pString = &pEntryString[LogEntryLength];
               PCHAR pArg    = (PCHAR)va_arg(arglist, PCHAR);

               ASSERT(pArg!=NULL);
               FieldLength = strlen(pArg);// + 1;
               if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
                  strcpy(pString,pArg);
                  LogEntryLength += FieldLength;
                  //pEntryString[LogEntryLength - 1] = ' ';
               }
            }
            break;
         case 'Z':
            {
               PCHAR pString = &pEntryString[LogEntryLength];
               PUNICODE_STRING pArg    = (PUNICODE_STRING)va_arg(arglist, PUNICODE_STRING);
               PWCHAR Buffer;
               ULONG Length;

               //this really only works for ascii strings in unicode......
               ASSERT(pArg!=NULL);
               Buffer = pArg->Buffer;
               Length = pArg->Length;
               //DbgPrint("yaya=%08lx,%08lx,%08lx\n",pArg,Buffer,Length);
               for (;Length>0;Length-=sizeof(WCHAR)) {
                   if (LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) {
                       pEntryString[LogEntryLength++] = (UCHAR)(*Buffer++);
                   } else {
                       break;
                   }
               }
               //DbgBreakPoint();
            }
            break;
         default:
            fLogNewEntry = FALSE;
            break;
         }
      } else {
         break;
      }
   }

   va_end(arglist);

   if (BinaryArgs) {
       EntryString[0] = '#';
       EntryString[1] = '>';
       EntryString[2] = '0'+(UCHAR)BinaryArgs;
       EntryString[3] = 0;
       *((PULONG)(&EntryString[sizeof(ULONG)])) = BinaryStringMask;
       LogEntryLength = MAX_RX_LOG_ENTRY_SIZE;
   }

   KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

   if (fLogNewEntry) {
      s_RxLog.NumberOfLogWriteAttempts++;
      LogEntry = RxGetNextLogEntry();
   } else {
      s_RxLog.NumberOfEntriesIgnored++;
      DbgPrint("RxLog: Entry exceeds max size, not recorded <%s>\n",OriginalFormat);
      if (s_RxLog.NumberOfEntriesIgnored==1) {
          //DbgBreakPoint();
      }
   }

   KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );

   if (fLogNewEntry) {
        BOOLEAN OutOfBounds = ((LogEntry<s_RxLog.BaseEntry) || (LogEntry>=s_RxLog.EntryLimit));
        if (OutOfBounds) {
          DbgPrint("RxLog: wrap logic has fail.....log disabled\n");
          s_RxLog.State = RX_LOG_DISABLED;
        } else {
            if (LogEntryLength >= MAX_RX_LOG_ENTRY_SIZE) {
                LogEntryLength = MAX_RX_LOG_ENTRY_SIZE;
                if (BinaryArgs == 0) {
                    pEntryString[MAX_RX_LOG_ENTRY_SIZE-1] = 0;
                }
            } else {
                pEntryString[LogEntryLength++] = 0;
            }
            RtlCopyMemory(LogEntry->Buffer,pEntryString,LogEntryLength);
        }
   }
}

#define RxToUpper(CH) ((CH)&~('A'^'a'))
#define RxIsLetter(CH) ((RxToUpper(CH)>='A') && (RxToUpper(CH)<='Z'))
#define RxIsDigit(CH) (((CH)>='0')&&((CH)<='9'))

VOID
RxDebugControlCommand (
    IN char *ControlString
    )
/*
    This routine manipulates the print and log levels and the breakpoint masks. the format is

          AAAAA+AAAAA+AAAAA+AAAAA.....

     where each AAAAA == <+-!>*<Letter>*<digit>*.

     <letter>* designates a control name.....only enuff to disambiguate is needed.

     any + turns on  tracing globally
     any % turns on  tracing globally RIGHT NOW!
     any - turns off tracing globally

     for 0 !s, it means:  for the control <letter>*, set the printlevel to <digit>*
     for 1 !s, it means:  for the control <letter>* set breakmask bit <digit>*. 0 means all bits
     for 2 !s, it means:  for the control <letter>* clear breakmask bit <digit>*. 0 means all bits
         THIS STUFF (I.E. THE ! STUFF)  IS ACTUALLY IMPLEMENTED IN RXTRACE.C

     @ means  printlog
     @@ means   pauselog
     @@@ means resumelog
     @@@@ means initialize
     @@@@@ means setup to debug by turning off printing
     more than @@@@@ means  banner


     E.G. cle0+clo0+cre1000+!devf3 sets disables printing for cleanup and close, sets the printlevel
          for create to 1000, and enables the third bit of the breakmask for devfcb.

     the letter string is upcased automatically.

     There is usually one control for each file but some controls control stuff from multiple
     files (like dispatch)
*/
{
    char namebuf[16], numbuf[16], *p, *q, *c;
    //long i;
    long level,pointcount,atsigncount;
    //DEBUG_TRACE_CONTROLS control;

    //ASSERTMSG("Here in debug command parser!\n",FALSE);
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxDebugTraceControl %s!!\n", ControlString));

    if (!ControlString)
    {
        return;
    }

    for (c = ControlString;;) {
        if (*c == 0) break;
        p=namebuf;q=numbuf; atsigncount=pointcount = 0;
        for (;(*c!=0)&&!RxIsLetter(*c)&&!RxIsDigit(*c); c++){     //skip to a letter or digit
            if (*c == '!') {
                pointcount++;
            }
            if (*c == '@') {
                atsigncount++;
            }
#if RDBSSTRACE
            if (*c == '+') {
                RxNextGlobalTraceSuppress = FALSE;
            }
            if (*c == '%') {
                RxGlobalTraceSuppress = FALSE;
            }
            if (*c == '-') {
                RxNextGlobalTraceSuppress = TRUE;
            }
#endif //RDBSSTRACE
        }
        for (p=namebuf;(*c!=0)&&RxIsLetter(*c); *p++=RxToUpper(*c++) ) ;    //copy letters
        for (level=0,q=numbuf;(*c!=0)&&RxIsDigit(*c); *q++=*c++){           //copy digits
            level = 10*level+((*c)-'0');
        }
        *p = *q = (char)0;
        {if (atsigncount>0) {
            if (atsigncount==1) {
                RxPrintLog(level);
            } else if (atsigncount == 2) {
                RxPauseLog();
            } else if (atsigncount == 3) {
                RxResumeLog();
            } else if (atsigncount == 4) {
                RxInitializeLog();
            } else if (atsigncount == 5){
#if RDBSSTRACE
                RxDebugTraceZeroAllPrintLevels();
                RxDbgTraceFindControlPoint((DEBUG_TRACE_UNWIND))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_READ))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_RXCONTX))->PrintLevel = 1000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_DISPATCH))->PrintLevel = 1000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CREATE))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CLEANUP))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CLOSE))->PrintLevel = 10000;
#endif
            } else {
#if RDBSSTRACE
                RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("\n\n\n\n\n %s %s\n\n\n\n\n", namebuf, numbuf));
#endif
            }
            continue;
        }}
#if RDBSSTRACE
        if (((*namebuf)==0||(*numbuf)==0)) {
            continue;
        }
        RxDebugTraceDebugCommand(namebuf,level,pointcount);
#endif
    }
    return;
}

#ifdef DBG
VOID
RxpTrackReference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance)
{
   if (REF_TRACING_ON(TraceType)) {
      ULONG RefCount;
      PCHAR pTypeName,pLogTypeName;

      switch (TraceType) {
      case RDBSS_REF_TRACK_SRVCALL :
         pTypeName    = "SrvCall";
         pLogTypeName = "SC";
         RefCount     = ((PSRV_CALL)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVCALL,RxRefSrvcall,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETROOT :
         pTypeName = "NetRoot";
         pLogTypeName = "NR";
         RefCount     = ((PNET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(NETROOT,RxRefNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_VNETROOT:
         pTypeName = "VNetRoot";
         pLogTypeName = "VN";
         RefCount     = ((PV_NET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(VNETROOT,RxRefVNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFOBX :
         pTypeName = "NetFobx";
         pLogTypeName = "FO";
         RefCount     = ((PFOBX)pInstance)->NodeReferenceCount;
         RxWmiLog(FOBX,RxRefFobx,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFCB  :
         pTypeName = "NetFcb";
         pLogTypeName = "FC";
         RefCount     = ((PFCB)pInstance)->NodeReferenceCount;
         RxWmiLog(FCB,RxRefFcb,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_SRVOPEN :
         pTypeName = "SrvOpen";
         pLogTypeName = "SO";
         RefCount     = ((PSRV_OPEN)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVOPEN,RxRefSrvOpen,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      default:
         DbgPrint("Invalid Node Type for referencing\n");
         //DbgBreakPoint();
         return;
      }

      if (RdbssReferenceTracingValue & RX_LOG_REF_TRACKING) {
         RxLog(("Ref.%s %lx %ld %lx %ld->%ld",pLogTypeName,pInstance,Line,FileName,RefCount,RefCount+1));
      }

      if (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING) {
         DbgPrint("Reference %s  %lx %ld %s\n",pTypeName,pInstance,Line,FileName);
      }
   }
}

BOOLEAN
RxpTrackDereference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance)
{
   PAGED_CODE();

   if (REF_TRACING_ON(TraceType)) {
      PCHAR pTypeName,pLogTypeName;
      ULONG RefCount;

      switch (TraceType) {
      case RDBSS_REF_TRACK_SRVCALL :
         pTypeName    = "SrvCall";
         pLogTypeName = "SC";
         RefCount     = ((PSRV_CALL)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVCALL,RxDerefSrvcall,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETROOT :
         pTypeName = "NetRoot";
         pLogTypeName = "NR";
         RefCount     = ((PNET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(NETROOT,RxDerefNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_VNETROOT:
         pTypeName = "VNetRoot";
         pLogTypeName = "VN";
         RefCount     = ((PV_NET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(VNETROOT,RxDerefVNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFOBX :
         pTypeName = "NetFobx";
         pLogTypeName = "FO";
         RefCount     = ((PFOBX)pInstance)->NodeReferenceCount;
         RxWmiLog(FOBX,RxDerefFobx,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFCB  :
         pTypeName = "NetFcb";
         pLogTypeName = "FC";
         RefCount     = ((PFCB)pInstance)->NodeReferenceCount;
         RxWmiLog(FCB,RxDerefFcb,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_SRVOPEN :
         pTypeName = "SrvOpen";
         pLogTypeName = "SO";
         RefCount     = ((PSRV_OPEN)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVOPEN,RxDerefSrvOpen,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      default:
         DbgPrint("Invalid Node Type for referencing\n");
         //DbgBreakPoint();
         return TRUE;
      }

      if (RdbssReferenceTracingValue & RX_LOG_REF_TRACKING) {
         RxLog(("Deref.%s %lx %ld %lx %ld->%ld",pLogTypeName,pInstance,Line,FileName,RefCount,RefCount-1));
      }

      if (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING) {
         DbgPrint("Dereference %s %lx %ld %s\n",pTypeName,pInstance,Line,FileName);
      }
   }
   return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxtdi.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxtdi.h

Abstract:

    This is the include file that defines all the Transport driver related
    functions that the rest of the connection engine relies on. these have to
    be implemented across all OS platforms.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

--*/

#ifndef _RXTDI_H_
#define _RXTDI_H_

#include "nb30.h" // NETBIOS specific data structures

//
// Some of these routines should be made inlines. The number of them that need to be made
// inline is a space/time tradeoff that could very well be different across OS platforms.
// As a first cut in order to facilitate debugging all of these routines have not been inlined.
//

extern ULONG
ComputeTransportAddressLength(
    PTRANSPORT_ADDRESS pTransportAddress);

extern NTSTATUS
RxTdiBindToTransport(
    IN OUT PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxTdiUnbindFromTransport(
    IN OUT PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxTdiOpenAddress(
    IN     PRXCE_TRANSPORT    pTransport,
    IN     PTRANSPORT_ADDRESS pTransportAddress,
    IN OUT PRXCE_ADDRESS      pAddress);

extern NTSTATUS
RxTdiCloseAddress(
    IN OUT PRXCE_ADDRESS   pAddress);

extern NTSTATUS
RxTdiSetEventHandlers(
    IN PRXCE_TRANSPORT pTransport,
    IN PRXCE_ADDRESS   pAddress);


#define RXCE_QUERY_BROADCAST_ADDRESS        TDI_QUERY_BROADCAST_ADDRESS
#define RXCE_QUERY_PROVIDER_INFORMATION     TDI_QUERY_PROVIDER_INFORMATION
#define RXCE_QUERY_PROVIDER_INFO            TDI_QUERY_PROVIDER_INFO
#define RXCE_QUERY_ADDRESS_INFO             TDI_QUERY_ADDRESS_INFO
#define RXCE_QUERY_CONNECTION_INFO          TDI_QUERY_CONNECTION_INFO
#define RXCE_QUERY_PROVIDER_STATISTICS      TDI_QUERY_PROVIDER_STATISTICS
#define RXCE_QUERY_DATAGRAM_INFO            TDI_QUERY_DATAGRAM_INFO
#define RXCE_QUERY_DATA_LINK_ADDRESS        TDI_QUERY_DATA_LINK_ADDRESS
#define RXCE_QUERY_NETWORK_ADDRESS          TDI_QUERY_NETWORK_ADDRESS
#define RXCE_QUERY_MAX_DATAGRAM_INFO        TDI_QUERY_MAX_DATAGRAM_INFO

extern NTSTATUS
RxTdiQueryInformation(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            QueryType,
    IN PVOID            QueryBuffer,
    IN ULONG            QueryBufferLength);

extern NTSTATUS
RxTdiQueryAdapterStatus(
    IN     PRXCE_TRANSPORT pTransport,
    IN OUT PADAPTER_STATUS pAdapterStatus);

extern NTSTATUS
RxTdiConnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN     PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc);

extern NTSTATUS
RxTdiInitiateAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiCancelAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiCleanupAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiReconnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN     PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc);

//
// Disconnect options
//

#define RXCE_DISCONNECT_ABORT   TDI_DISCONNECT_ABORT
#define RXCE_DISCONNECT_RELEASE TDI_DISCONNECT_RELEASE
#define RXCE_DISCONNECT_WAIT    TDI_DISCONNECT_WAIT
#define RXCE_DISCONNECT_ASYNC   TDI_DISCONNECT_ASYNC

extern NTSTATUS
RxTdiDisconnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            DisconnectFlags);

extern NTSTATUS
RxTdiCancelConnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection);

extern NTSTATUS
RxTdiSend(
    IN PRXCE_TRANSPORT   pTransport,
    IN PRXCE_ADDRESS     pAddress,
    IN PRXCE_CONNECTION  pConnection,
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
RxTdiSendDatagram(
    IN PRXCE_TRANSPORT              pTransport,
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

#endif // _RXTDI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxtrace.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.c

Abstract:

    This module declares the global data used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

#if DBG

LONG RxDebugTraceIndent = 0;

#endif

#if RDBSSTRACE

BOOLEAN RxGlobalTraceSuppress = FALSE;
BOOLEAN RxNextGlobalTraceSuppress = FALSE;

#define MAXIMUM_DEBUGTRACE_CONTROLS 200
ULONG RxMaximumTraceControl;
RX_DEBUG_TRACE_CONTROL RxDebugTraceControl[MAXIMUM_DEBUGTRACE_CONTROLS];

#define DEBUGTRACE_NAMEBUFFERSIZE 800
CHAR RxDebugTraceNameBuffer[DEBUGTRACE_NAMEBUFFERSIZE];
ULONG RxDTNMptr = 0;
BOOLEAN RxDTNMCopy = FALSE;


PCHAR RxStorageTypeNames[256];
PCHAR RxIrpCodeToName[IRP_MJ_MAXIMUM_FUNCTION+1];
ULONG RxIrpCodeCount[IRP_MJ_MAXIMUM_FUNCTION+1];

#endif // RDBSSTRACE


#if RDBSSTRACE

//we declare controlpoints differently in the rdbss than in a minirdr. at some point,
//         minirdrs may come and go. for this reason we have to save the name text in
//         a nontransient rdbss storage. for rdbss controlpoints, we just use the name
//         pointer we're given since it is just as persistent as the copy. whether we copy
//         or just point is controlled

#define RXDT_Declare(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
RXDT_Declare(ERROR);
RXDT_Declare(HOOKS);
RXDT_Declare(CATCH_EXCEPTIONS);
RXDT_Declare(UNWIND);
RXDT_Declare(CLEANUP);
RXDT_Declare(CLOSE);
RXDT_Declare(CREATE);
RXDT_Declare(DIRCTRL);
RXDT_Declare(EA);
RXDT_Declare(FILEINFO);
RXDT_Declare(FSCTRL);
RXDT_Declare(LOCKCTRL);
RXDT_Declare(READ);
RXDT_Declare(VOLINFO);
RXDT_Declare(WRITE);
RXDT_Declare(FLUSH);
RXDT_Declare(DEVCTRL);
RXDT_Declare(SHUTDOWN);
RXDT_Declare(PREFIX);
RXDT_Declare(DEVFCB);
RXDT_Declare(ACCHKSUP);
RXDT_Declare(ALLOCSUP);
RXDT_Declare(DIRSUP);
RXDT_Declare(FILOBSUP);
RXDT_Declare(NAMESUP);
RXDT_Declare(VERFYSUP);
RXDT_Declare(CACHESUP);
RXDT_Declare(SPLAYSUP);
RXDT_Declare(DEVIOSUP);
RXDT_Declare(FCBSTRUCTS);
RXDT_Declare(STRUCSUP);
RXDT_Declare(FSP_DISPATCHER);
RXDT_Declare(FSP_DUMP);
RXDT_Declare(RXCONTX);
RXDT_Declare(DISPATCH);
RXDT_Declare(NTFASTIO);
RXDT_Declare(LOWIO);
RXDT_Declare(MINIRDR);
RXDT_Declare(DISCCODE);  //for the browser interface stuff
RXDT_Declare(BROWSER);
RXDT_Declare(CONNECT);
RXDT_Declare(NTTIMER);
RXDT_Declare(SCAVTHRD);
RXDT_Declare(SCAVENGER);
RXDT_Declare(SHAREACCESS);
RXDT_Declare(NAMECACHE);

// connection engine stuff
RXDT_Declare(RXCEBINDING);
RXDT_Declare(RXCEDBIMPLEMENTATION);
RXDT_Declare(RXCEMANAGEMENT);
RXDT_Declare(RXCEXMIT);
RXDT_Declare(RXCEPOOL);
RXDT_Declare(RXCETDI);


VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
    ULONG i;

    RxMaximumTraceControl++;
    i = RxMaximumTraceControl;
    ASSERT(i<MAXIMUM_DEBUGTRACE_CONTROLS);
    RxDebugTraceControl[i].PrintLevel = 1000;
    RxDebugTraceControl[i].BreakMask = 0xf0000000;
    if (RxDTNMCopy) {
        ULONG len = strlen(Name)+1;
        ASSERT (RxDTNMptr+len<DEBUGTRACE_NAMEBUFFERSIZE);
        RxDebugTraceControl[i].Name= &RxDebugTraceNameBuffer[RxDTNMptr];
        RtlCopyMemory(RxDebugTraceControl[i].Name,Name,len);
        RxDTNMptr += len;
    } else {
        RxDebugTraceControl[i].Name=Name;
    }
    RxDebugTraceControl[i+1].Name=NULL;
    ControlPoint->Name=RxDebugTraceControl[i].Name;
    ControlPoint->ControlPointNumber = i;
}


#ifdef RxInitializeDebugTrace
#undef RxInitializeDebugTrace
#endif
VOID RxInitializeDebugTrace(void){
    int i;

    RxDebugTraceIndent = 0;
    RxGlobalTraceSuppress = TRUE;
    RxNextGlobalTraceSuppress = TRUE;
    RxExports.pRxDebugTraceIndent = &RxDebugTraceIndent;


    for (i=0;i<=IRP_MJ_MAXIMUM_FUNCTION;i++) {
        RxIrpCodeCount[i] = 0;
    }

#if RDBSSTRACE
#define OneName(x) { RxInitializeDebugTraceControlPoint(#x, &RX_DEBUG_TRACE_##x); }
    RxMaximumTraceControl=0;
    OneName(ACCHKSUP);
    OneName(ALLOCSUP);
    OneName(BROWSER);
    OneName(CACHESUP);
    OneName(CATCH_EXCEPTIONS);
    OneName(CLEANUP);
    OneName(CLOSE);
    OneName(CONNECT);
    OneName(CREATE);
    OneName(HOOKS);
    OneName(DEVCTRL);
    OneName(DEVFCB);
    OneName(DEVIOSUP);
    OneName(DIRCTRL);
    OneName(DIRSUP);
    OneName(DISCCODE);
    OneName(DISPATCH);
    OneName(EA);
    OneName(ERROR);
    OneName(FCBSTRUCTS);
    OneName(FILEINFO);
    OneName(FILOBSUP);
    OneName(FLUSH);
    OneName(FSCTRL);
    OneName(FSP_DISPATCHER);
    OneName(FSP_DUMP);
    OneName(RXCONTX);
    OneName(LOCKCTRL);
    OneName(LOWIO);
    OneName(MINIRDR);
    OneName(NAMESUP);
    OneName(NTFASTIO);
    OneName(NTTIMER);
    OneName(PREFIX);
    OneName(READ);
    OneName(SCAVTHRD);
    OneName(SHUTDOWN);
    OneName(SPLAYSUP);
    OneName(STRUCSUP);
    OneName(UNWIND);
    OneName(VERFYSUP);
    OneName(VOLINFO);
    OneName(WRITE);
    OneName(SCAVENGER);
    OneName(SHAREACCESS);
    OneName(NAMECACHE);
    OneName(RXCEBINDING);       //connection engine
    OneName(RXCEDBIMPLEMENTATION);
    OneName(RXCEMANAGEMENT);
    OneName(RXCEXMIT);
    OneName(RXCEPOOL);
    OneName(RXCETDI);

    RxDTNMCopy = FALSE;  // from now on, copy the name

    RxDebugTraceControl[RX_DEBUG_TRACE_ALLOCSUP.ControlPointNumber].PrintLevel = 0;   //get rid of annoying logof msg
    RxDebugTraceControl[RX_DEBUG_TRACE_DISCCODE.ControlPointNumber].PrintLevel = 0;   //it's just too much
    RxDebugTraceControl[RX_DEBUG_TRACE_BROWSER.ControlPointNumber].PrintLevel = 0;   //it's just too much
    //RxDebugTraceControl[RX_DEBUG_TRACE_CREATE.ControlPointNumber].PrintLevel = 0;
#endif //rdbsstrace


    RxIrpCodeToName[IRP_MJ_CREATE] = "CREATE";
    RxIrpCodeToName[IRP_MJ_CREATE_NAMED_PIPE] = "CREATE_NAMED_PIPE";
    RxIrpCodeToName[IRP_MJ_CLOSE] = "CLOSE";
    RxIrpCodeToName[IRP_MJ_READ] = "READ";
    RxIrpCodeToName[IRP_MJ_WRITE] = "WRITE";
    RxIrpCodeToName[IRP_MJ_QUERY_INFORMATION] = "QUERY_INFORMATION";
    RxIrpCodeToName[IRP_MJ_SET_INFORMATION] = "SET_INFORMATION";
    RxIrpCodeToName[IRP_MJ_QUERY_EA] = "QUERY_EA";
    RxIrpCodeToName[IRP_MJ_SET_EA] = "SET_EA";
    RxIrpCodeToName[IRP_MJ_FLUSH_BUFFERS] = "FLUSH_BUFFERS";
    RxIrpCodeToName[IRP_MJ_QUERY_VOLUME_INFORMATION] = "QUERY_VOLUME_INFORMATION";
    RxIrpCodeToName[IRP_MJ_SET_VOLUME_INFORMATION] = "SET_VOLUME_INFORMATION";
    RxIrpCodeToName[IRP_MJ_DIRECTORY_CONTROL] = "DIRECTORY_CONTROL";
    RxIrpCodeToName[IRP_MJ_FILE_SYSTEM_CONTROL] = "FILE_SYSTEM_CONTROL";
    RxIrpCodeToName[IRP_MJ_DEVICE_CONTROL] = "DEVICE_CONTROL";
    RxIrpCodeToName[IRP_MJ_INTERNAL_DEVICE_CONTROL] = "INTERNAL_DEVICE_CONTROL";
    RxIrpCodeToName[IRP_MJ_SHUTDOWN] = "SHUTDOWN";
    RxIrpCodeToName[IRP_MJ_LOCK_CONTROL] = "LOCK_CONTROL";
    RxIrpCodeToName[IRP_MJ_CLEANUP] = "CLEANUP";
    RxIrpCodeToName[IRP_MJ_CREATE_MAILSLOT] = "CREATE_MAILSLOT";
    RxIrpCodeToName[IRP_MJ_QUERY_SECURITY] = "QUERY_SECURITY";
    RxIrpCodeToName[IRP_MJ_SET_SECURITY] = "SET_SECURITY";
    RxIrpCodeToName[IRP_MJ_POWER] = "POWER";
    RxIrpCodeToName[IRP_MJ_SYSTEM_CONTROL] = "SYSTEM_CONTROL";
    RxIrpCodeToName[IRP_MJ_DEVICE_CHANGE] = "DEVICE_CHANGE";
    RxIrpCodeToName[IRP_MJ_QUERY_QUOTA] = "QUERY_QUOTA";
    RxIrpCodeToName[IRP_MJ_SET_QUOTA] = "SET_QUOTA";
    RxIrpCodeToName[IRP_MJ_PNP_POWER] = "PNP";

}

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    )
{
    ULONG i,mask;


    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("name/num/!c %s/%lu/%lu!!\n", name, level, pointcount));

    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        ULONG l = strlen(name);
        //RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("----->checking %s\n",control->Name));
        if (strncmp(name,control->Name,l)) continue;
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---> got it %s/%lu/%lu !!\n", control->Name, level, pointcount));
        if (pointcount==0) {
            control->PrintLevel = level;
        } else if (pointcount <= 2) {
            if (level==0) {
                mask = 0xffffffff;
            } else {
                mask = 1 << (level-1);
            }
            if (pointcount==1) {
                control->BreakMask |= mask;
            } else {
                control->BreakMask &= ~mask;
            }
        }
    }
}

#ifdef RxDbgTraceDisableGlobally
#undef RxDbgTraceDisableGlobally
#endif
BOOLEAN
RxDbgTraceDisableGlobally(void)
{
    BOOLEAN flag = RxGlobalTraceSuppress;
    RxGlobalTraceSuppress = TRUE;
    return  flag;
}

#ifdef RxDbgTraceEnableGlobally
#undef RxDbgTraceEnableGlobally
#endif
VOID
RxDbgTraceEnableGlobally(BOOLEAN flag)
{
    RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  flag;
}


VOID
RxDebugTraceZeroAllPrintLevels(
    void
    )
{
    ULONG i;

    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        control->PrintLevel = 0;    // disable output
    }
}


BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
/*
This routine has the responsibility to determine if a particular dbgprint is going to be printed and ifso to
fiddle with the indent. so the return value is whether to print; it is also used for just fiddling with the indent
by setting the highoredr bit of the mask.

The Mask is now very complicated owing to the large number of dbgprints i'm trying to control...sigh.
The low order byte is the controlpoint....usually the file. each controlpoint has a current level associated
with it. if the level of a a debugtrace is less that then current control level then the debug is printed.
The next byte is the level of this particular call; again if the level is <= the current level for the control
you get printed. The next byte is the indent. indents are only processed if printing is done.
*/
    LONG Indent = ((NewMask>>RxDT_INDENT_SHIFT)&RxDT_INDENT_MASK) - RxDT_INDENT_EXCESS;
    LONG LevelOfThisWrite = (NewMask) & RxDT_LEVEL_MASK;
    BOOLEAN PrintIt = (NewMask&RxDT_SUPPRESS_PRINT)==0;
    BOOLEAN OverrideReturn = (NewMask&RxDT_OVERRIDE_RETURN)!=0;
    LONG _i;

    ASSERT (Indent==1 || Indent==0 || (Indent==-1));

    if (RxGlobalTraceSuppress) return FALSE;

#if 0
    if (ControlPoint!=NULL){
        ULONG ControlPointNumber = ControlPoint->ControlPointNumber;
        if (ControlPointNumber==0) {
            if (!RxDbgTraceFindControlPointActual(ControlPoint)){
                //couldnt find or initialize the control point text.....hmmmmmmmmmmm
                ASSERT(!"bad return from findcontrolpoint");
                return(FALSE);
            }
            ControlPointNumber = ControlPoint->ControlPointNumber;
        }

        ASSERT(ControlPointNumber && ControlPointNumber<=RxMaximumTraceControl);

        if (LevelOfThisWrite > RxDebugTraceControl[ControlPointNumber].PrintLevel  ) return FALSE;
    }
#else
    PrintIt = TRUE;
#endif


    if ((Indent) > 0) {
        RxDebugTraceIndent += (Indent);
    }

    if (PrintIt) {
        _i = (ULONG)((ULONG_PTR)PsGetCurrentThread());

        if (RxDebugTraceIndent < 0) {
            RxDebugTraceIndent = 0;
        }
        DbgPrint("%08lx:%-*s",_i,(int)(RxDebugTraceIndent),"");
    }

    if (Indent < 0) {
        RxDebugTraceIndent += (Indent);
    }

    ASSERT (RxDebugTraceIndent <= 0x40);

    return PrintIt||OverrideReturn;
}

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
    ULONG i,ControlPointNumber;
    PUCHAR name;

    ASSERT (ControlPoint);
    ControlPointNumber = ControlPoint->ControlPointNumber;

    if (ControlPointNumber) return (&RxDebugTraceControl[ControlPointNumber]);

    //otherwise, we have to look it up..........
    name = ControlPoint->Name;
    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        ULONG l = strlen(name);
        //RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("----->checking %s\n",control->Name));
        if (strncmp(name,control->Name,l)) continue;
        DbgPrint("Controlpointlookup=%08lx<%s> to %08lx\n",
                         ControlPoint,ControlPoint->Name,i);
        ControlPoint->ControlPointNumber = i;
        return(control);
    }
    DbgPrint("Couldn't find ControlPointName=%s...inserting\n",name);
    RxInitializeDebugTraceControlPoint(name,ControlPoint); //actually copies the name
    return (&RxDebugTraceControl[ControlPoint->ControlPointNumber]);
}

#endif // RDBSSTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxtimer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtTimer.c

Abstract:

    This module implements the nt version of the timer and worker thread management routines.
    These services are provided to all mini redirector writers. The timer service comes in two
    flavours - a periodic trigger and a one shot notification.

Author:

    Joe Linn     [JoeLinn]   2-mar-95

Revision History:

    Balan Sethu Raman [SethuR] 7-Mar-95
         Included one shot, periodic notification for work queue items.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeRxTimer)
#pragma alloc_text(PAGE, RxTearDownRxTimer)
#pragma alloc_text(PAGE, RxPostRecurrentTimerRequest)
#pragma alloc_text(PAGE, RxRecurrentTimerWorkItemDispatcher)
#endif

typedef struct _RX_RECURRENT_WORK_ITEM_ {
   RX_WORK_ITEM               WorkItem;
   LIST_ENTRY                 RecurrentWorkItemsList;
   LARGE_INTEGER              TimeInterval;
   PRX_WORKERTHREAD_ROUTINE   Routine;
   PVOID                      pContext;
} RX_RECURRENT_WORK_ITEM, *PRX_RECURRENT_WORK_ITEM;

//
// Forward declarations of routines
//

extern VOID
RxTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

extern VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );


//  The Bug check file id for this module
#define BugCheckFileId  (RDBSS_BUG_CHECK_NTTIMER)


//  The local trace mask for this part of the module
#define Dbg                              (DEBUG_TRACE_NTTIMER)

LARGE_INTEGER s_RxTimerInterval;
KSPIN_LOCK    s_RxTimerLock;
KDPC          s_RxTimerDpc;
LIST_ENTRY    s_RxTimerQueueHead;  // queue of the list of timer calls
LIST_ENTRY    s_RxRecurrentWorkItemsList;
KTIMER        s_RxTimer;
ULONG         s_RxTimerTickCount;

#define NoOf100nsTicksIn1ms  (10 * 1000)
#define NoOf100nsTicksIn55ms (10 * 1000 * 55)

NTSTATUS
RxInitializeRxTimer()
/*++

Routine Description:

    The routine initializes everything having to do with the timer stuff.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    s_RxTimerInterval.LowPart = (ULONG)(-((LONG)NoOf100nsTicksIn55ms));
    s_RxTimerInterval.HighPart = -1;

    KeInitializeSpinLock( &s_RxTimerLock );

    InitializeListHead( &s_RxTimerQueueHead );
    InitializeListHead( &s_RxRecurrentWorkItemsList );

    KeInitializeDpc( &s_RxTimerDpc, RxTimerDispatch, NULL );
    KeInitializeTimer( &s_RxTimer );

    s_RxTimerTickCount = 0;

    return Status;
}


VOID
RxTearDownRxTimer(
    void)
/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    TimerEntry - Pointer to a timer entry to be used.

    TimerRoutine - Driver routine to be executed when timer expires.

    Context - Context parameter that is passed to the driver routine.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    PRX_RECURRENT_WORK_ITEM pWorkItem;
    PLIST_ENTRY             pListEntry;

    PAGED_CODE();

    KeCancelTimer( &s_RxTimer );

    // Walk down the list freeing up the recurrent requests since the memory was
    // allocated by us.
    while (!IsListEmpty(&s_RxRecurrentWorkItemsList)) {
        pListEntry = RemoveHeadList(&s_RxRecurrentWorkItemsList);
        pWorkItem  = (PRX_RECURRENT_WORK_ITEM)
                     CONTAINING_RECORD(
                         pListEntry,
                         RX_RECURRENT_WORK_ITEM,
                         RecurrentWorkItemsList);
        RxFreePool(pWorkItem);
    }
}

VOID
RxTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine scans the  timer database and posts a work item for all those requests
    whose temporal constraints have been satisfied.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

--*/
{
    PLIST_ENTRY      pListEntry;
    LIST_ENTRY       ExpiredList;

    //KIRQL            Irql;
    BOOLEAN          ContinueTimer = FALSE;

    PRX_WORK_QUEUE_ITEM pWorkQueueItem;
    PRX_WORK_ITEM       pWorkItem;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    InitializeListHead(&ExpiredList);

    KeAcquireSpinLockAtDpcLevel( &s_RxTimerLock );

    s_RxTimerTickCount++;

    pListEntry = s_RxTimerQueueHead.Flink;

    while (pListEntry != &s_RxTimerQueueHead) {
        pWorkQueueItem = CONTAINING_RECORD(
                             pListEntry,
                             RX_WORK_QUEUE_ITEM,
                             List );
        pWorkItem      = CONTAINING_RECORD(
                             pWorkQueueItem,
                             RX_WORK_ITEM,
                             WorkQueueItem);

        if (pWorkItem->LastTick == s_RxTimerTickCount) {
           PLIST_ENTRY pExpiredEntry = pListEntry;
           pListEntry = pListEntry->Flink;

           RemoveEntryList(pExpiredEntry);
           InsertTailList(&ExpiredList,pExpiredEntry);
        } else {
           pListEntry = pListEntry->Flink;
        }
    }

    ContinueTimer = !(IsListEmpty(&s_RxTimerQueueHead));
    KeReleaseSpinLockFromDpcLevel( &s_RxTimerLock );

    // Resubmit the timer queue dispatch routine so that it will be reinvoked.
    if (ContinueTimer)
        KeSetTimer( &s_RxTimer, s_RxTimerInterval, &s_RxTimerDpc );

    // Queue all the expired entries on the worker threads.
    while (!IsListEmpty(&ExpiredList)) {
        pListEntry = RemoveHeadList(&ExpiredList);
        pListEntry->Flink = pListEntry->Blink = NULL;

        pWorkQueueItem = CONTAINING_RECORD(
                             pListEntry,
                             RX_WORK_QUEUE_ITEM,
                             List );

        // Post the work item to a worker thread
        RxPostToWorkerThread(
            pWorkQueueItem->pDeviceObject,
            CriticalWorkQueue,
            pWorkQueueItem,
            pWorkQueueItem->WorkerRoutine,
            pWorkQueueItem->Parameter);
    }
}

NTSTATUS
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval)
/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    pDeviceObject - the device object

    pWorkItem - the work item

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

    TimeInterval   - the time interval in 100 ns ticks.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    BOOLEAN       StartTimer;
    //NTSTATUS      Status;
    ULONG         NumberOf55msIntervals;
    KIRQL         Irql;
    LARGE_INTEGER StrobeInterval;

    ASSERT(pWorkItem != NULL);

    // Initialize the work queue item.
    ExInitializeWorkItem(
        (PWORK_QUEUE_ITEM)&pWorkItem->WorkQueueItem,
        Routine,
        pContext );

    pWorkItem->WorkQueueItem.pDeviceObject = pDeviceObject;

    // Compute the time interval in number of ticks.
    StrobeInterval.QuadPart= NoOf100nsTicksIn55ms;
    NumberOf55msIntervals = (ULONG)(TimeInterval.QuadPart / StrobeInterval.QuadPart);
    NumberOf55msIntervals += 1; // Take the ceiling to be conservative
    RxDbgTraceLV( 0, Dbg, 1500, ("Timer will expire after %ld 55ms intervals\n",NumberOf55msIntervals));

    // Insert the entry in the timer queue.
    KeAcquireSpinLock( &s_RxTimerLock, &Irql );

    // Update the tick relative to the current tick.
    pWorkItem->LastTick = s_RxTimerTickCount + NumberOf55msIntervals;

    StartTimer = IsListEmpty(&s_RxTimerQueueHead);
    InsertTailList( &s_RxTimerQueueHead,&pWorkItem->WorkQueueItem.List);

    KeReleaseSpinLock( &s_RxTimerLock, Irql );

    if (StartTimer) {
        KeSetTimer( &s_RxTimer, s_RxTimerInterval, &s_RxTimerDpc );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval)
/*++

Routine Description:

    This routine is used to post a recurrent timer request. The passed in routine once every
    (TimeInterval) milli seconds.

Arguments:

    pDeviceObject  - the device object

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

    TimeInterval   - the time interval in 100ns ticks.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/
{
    PRX_RECURRENT_WORK_ITEM pRecurrentWorkItem;
    NTSTATUS      Status;

    PAGED_CODE();

    // Allocate a work item.
    pRecurrentWorkItem = (PRX_RECURRENT_WORK_ITEM)
                        RxAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(RX_RECURRENT_WORK_ITEM),
                            RX_TIMER_POOLTAG);

    if (pRecurrentWorkItem != NULL) {
        InsertTailList(
            &s_RxRecurrentWorkItemsList,
            &pRecurrentWorkItem->RecurrentWorkItemsList);

        pRecurrentWorkItem->Routine = Routine;
        pRecurrentWorkItem->pContext = pContext;
        pRecurrentWorkItem->TimeInterval = TimeInterval;
        pRecurrentWorkItem->WorkItem.WorkQueueItem.pDeviceObject = pDeviceObject;

        Status = RxPostOneShotTimerRequest(
                     pRecurrentWorkItem->WorkItem.WorkQueueItem.pDeviceObject,
                     &pRecurrentWorkItem->WorkItem,
                     RxRecurrentTimerWorkItemDispatcher,
                     pRecurrentWorkItem,
                     TimeInterval);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT       pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE   Routine,
    IN PVOID                      pContext)
/*++

Routine Description:

    This routine cancels a  timer request. The request to be cancelled is identified
    by the routine and context.

Arguments:

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

--*/
{
    NTSTATUS                Status = STATUS_NOT_FOUND;
    PLIST_ENTRY             pListEntry;
    PWORK_QUEUE_ITEM     pWorkQueueItem;
    PRX_WORK_ITEM           pWorkItem;
    PRX_RECURRENT_WORK_ITEM pRecurrentWorkItem = NULL;
    KIRQL Irql;

    KeAcquireSpinLock( &s_RxTimerLock, &Irql );

    // Walk through the list of entries
    for (pListEntry = s_RxTimerQueueHead.Flink;
         (pListEntry != &s_RxTimerQueueHead);
         pListEntry = pListEntry->Flink ) {
        pWorkQueueItem = CONTAINING_RECORD( pListEntry, WORK_QUEUE_ITEM, List );
        pWorkItem      = CONTAINING_RECORD( pWorkQueueItem, RX_WORK_ITEM, WorkQueueItem);

        if ((pWorkItem->WorkQueueItem.pDeviceObject == pDeviceObject) &&
            (pWorkItem->WorkQueueItem.WorkerRoutine == Routine) &&
            (pWorkItem->WorkQueueItem.Parameter == pContext)) {
            RemoveEntryList(pListEntry);
            Status = STATUS_SUCCESS;
            pRecurrentWorkItem = NULL;
            break;
        } else if (pWorkItem->WorkQueueItem.WorkerRoutine == RxRecurrentTimerWorkItemDispatcher) {
            pRecurrentWorkItem = (PRX_RECURRENT_WORK_ITEM)pWorkItem->WorkQueueItem.Parameter;

            if ((pRecurrentWorkItem->Routine == Routine) &&
                (pRecurrentWorkItem->pContext == pContext)) {
                RemoveEntryList(pListEntry);
                RemoveEntryList(&pRecurrentWorkItem->RecurrentWorkItemsList);
                Status = STATUS_SUCCESS;
            } else {
                pRecurrentWorkItem = NULL;
            }
        }
    }

    KeReleaseSpinLock( &s_RxTimerLock, Irql );

    if (pRecurrentWorkItem != NULL) {
        RxFreePool(pRecurrentWorkItem);
    }

    return Status;
}

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    )
/*++

Routine Description:

    This routine dispatches a recurrent timer request. On completion of the invocation of the
    associated routine the request s requeued.

Arguments:

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

--*/
{
    PRX_RECURRENT_WORK_ITEM  pPeriodicWorkItem = (PRX_RECURRENT_WORK_ITEM)Context;
    PRX_WORKERTHREAD_ROUTINE Routine  = pPeriodicWorkItem->Routine;
    PVOID                    pContext = pPeriodicWorkItem->pContext;

    PAGED_CODE();

    //KIRQL  Irql;

    // Invoke the routine.
    Routine(pContext);

    // enqueue the item if necessary.
    RxPostOneShotTimerRequest(
        pPeriodicWorkItem->WorkItem.WorkQueueItem.pDeviceObject,
        &pPeriodicWorkItem->WorkItem,
        RxRecurrentTimerWorkItemDispatcher,
        pPeriodicWorkItem,
        pPeriodicWorkItem->TimeInterval);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.c

Abstract:

    This module declares the global data used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

//
//  The global fsd data record, and zero large integer
//

RX_DISPATCHER RxDispatcher;
RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

LIST_ENTRY    RxSrvCalldownList;
LIST_ENTRY    RxActiveContexts;
PRX_CONTEXT   RxStopContext = NULL;

//
// the debugger extension needs to know the target architecture. sacrifice one ulong....
// the highorder 0xabc is just for consistency..........

ULONG           RxProcessorArchitecture = 0xabc0000 |
#if defined(_X86_)
                                                RX_PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_MIPS_)
                                                RX_PROCESSOR_ARCHITECTURE_MIPS;
#elif defined(_ALPHA_)
                                                RX_PROCESSOR_ARCHITECTURE_ALPHA;
#elif defined(_PPC_)
                                                RX_PROCESSOR_ARCHITECTURE_PPC;
#else
                                                RX_PROCESSOR_ARCHITECTURE_UNKNOWN;
#endif

#ifdef EXPLODE_POOLTAGS
ULONG RxExplodePoolTags = 1;
#else
ULONG RxExplodePoolTags = 0;
#endif

KMUTEX       RxSerializationMutex;

RDBSS_DATA      RxData;
RDBSS_EXPORTS   RxExports;
ULONG           RxElapsedSecondsSinceStart;

KSPIN_LOCK      RxStrucSupSpinLock = {0};      //  used to synchronize access to zones/structures

PRDBSS_DEVICE_OBJECT  RxFileSystemDeviceObject;
NTSTATUS        RxStubStatus = (STATUS_NOT_IMPLEMENTED);
FCB             RxDeviceFCB;

LARGE_INTEGER RxLargeZero = {0,0};
LARGE_INTEGER RxMaxLarge = {MAXULONG,MAXLONG};
LARGE_INTEGER Rx30Milliseconds = {(ULONG)(-30 * 1000 * 10), -1};
LARGE_INTEGER RxOneSecond = {10000000,0};
LARGE_INTEGER RxOneDay = {0x2a69c000, 0xc9};
LARGE_INTEGER RxJanOne1980 = {0xe1d58000,0x01a8e79f};
LARGE_INTEGER RxDecThirtyOne1979 = {0xb76bc000,0x01a8e6d6};


ULONG RxFsdEntryCount = 0;
ULONG RxFspEntryCount = 0;
ULONG RxIoCallDriverCount = 0;

LONG RxPerformanceTimerLevel = 0x00000000;

ULONG RxTotalTicks[32] = { 0 };

//
//  I need this because C can't support conditional compilation within
//  a macro.
//

PVOID RxNull = NULL;


extern LONG           RxNumberOfActiveFcbs = 0;

// Reference Tracing mask value .. Turn it on by default for DBG builds

#ifdef DBG
ULONG RdbssReferenceTracingValue = 0x8000003f;
#else
ULONG RdbssReferenceTracingValue = 0;
#endif


UNICODE_STRING s_PipeShareName = { 10, 10, L"\\PIPE" };
UNICODE_STRING s_MailSlotShareName = { 18, 18, L"\\MAILSLOT" };
UNICODE_STRING s_MailSlotServerPrefix = {8,8,L";$:\\"};
UNICODE_STRING s_IpcShareName  = { 10, 10, L"\\IPC$" };

UNICODE_STRING s_PrimaryDomainName = {0,0,NULL};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\precomp.h ===
#include "rx.h"         // RX memory allocation macros
#include "ntddnfs2.h"   // NT network file system driver include file
#include "rxdebug.h"    // debug support

// the rest of the real connection engine stuff.........
#include "rxcep.h"      // RxCe implementation details
#include "rxtdi.h"      // RxCe transport driver interface
#include "rxwmi.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxworkq.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxworkq.c

Abstract:

    This module implements the Work queue routines for the Rx File system.

Author:

    JoeLinn           [JoeLinn]    8-8-94   Initial Implementation

    Balan Sethu Raman [SethuR]     22-11-95 Implemented dispatch support for mini rdrs

    Balan Sethu Raman [SethuR]     20-03-96 Delinked from executive worker threads

Notes:

    There are two kinds of support for asynchronous resumption provided in the RDBSS.
    The I/O requests that cannot be completed in the context of the thread in which
    the request was made are posted to a file system process for completion.

    The mini redirectors also require support for asynchronously completing requests as
    well as post requests that cannot be completed at DPC level.

    The requests for posting from the mini redirectors are classified into Critical(blocking and
    non blocking requests. In order to ensure progress these requests are handled through
    separate resources. There is no well known mechanism to ensure that the hyper critical
    requests will not block.

    The two functions that are available to all mini redirector writers are

         RxDispatchToWorkerThread
         RxPostToWorkerThread.

    These two routines enable the mini redirector writer to make the appropriate space
    time tradeoffs. The RxDispatchToWorkerThread trades time for reduction in space by
    dynamically allocating the work item as and when required, while RxPostToWorkerThread
    trades space for time by pre allocating a work item.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeDispatcher)
#pragma alloc_text(PAGE, RxInitializeMRxDispatcher)
#pragma alloc_text(PAGE, RxSpinDownMRxDispatcher)
#pragma alloc_text(PAGE, RxInitializeWorkQueueDispatcher)
#pragma alloc_text(PAGE, RxInitializeWorkQueue)
#pragma alloc_text(PAGE, RxTearDownDispatcher)
#pragma alloc_text(PAGE, RxTearDownWorkQueueDispatcher)
#pragma alloc_text(PAGE, RxpSpinUpWorkerThreads)
#pragma alloc_text(PAGE, RxBootstrapWorkerThreadDispatcher)
#pragma alloc_text(PAGE, RxWorkerThreadDispatcher)
#endif

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_FSP_DISPATCHER)

//
// had to steal this from ntifs.h in order to use ntsrv.h

extern POBJECT_TYPE *PsThreadType;

//
// Prototype forward declarations.
//

extern NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

extern
VOID
RxInitializeWorkQueue(
   PRX_WORK_QUEUE  pWorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG           MaximumNumberOfWorkerThreads,
   ULONG           MinimumNumberOfWorkerThreads);

extern VOID
RxTearDownWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

extern VOID
RxTearDownWorkQueue(
   PRX_WORK_QUEUE pWorkQueue);

extern NTSTATUS
RxSpinUpWorkerThread(
   PRX_WORK_QUEUE           pWorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID                    Parameter);

extern VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue);

extern VOID
RxSpinDownWorkerThreads(
   PRX_WORK_QUEUE    pWorkQueue);

extern VOID
RxpWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue,
   IN PLARGE_INTEGER pWaitInterval);

VOID
RxBootstrapWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

extern VOID
RxWorkItemDispatcher(
   PVOID    pContext);

extern VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher);

// The spin up requests thread

PETHREAD RxSpinUpRequestsThread = NULL;

//
// The delay parameter for KQUEUE wait requests in the RX_WORK_QUEUE implemenation
//

LARGE_INTEGER RxWorkQueueWaitInterval[MaximumWorkQueue];
LARGE_INTEGER RxSpinUpDispatcherWaitInterval;

//
// Currently the levels correspond to the three levels defined in ex.h
// Delayed,Critical and HyperCritical. As regards mini redirectors if any work
// is not dependent on any mini redirector/RDBSS resource, i.e., it will not wait
// it can be classified as a hypercritical1 work item. There is no good way to
// enforce this, therefore one should exercise great caution before classifying
// something as hypercritical.
//

NTSTATUS
RxInitializeDispatcher()
/*++

Routine Description:

    This routine initializes the work queues dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

    The dispatching mechanism is implemented as a two tiered approach. Each
    processor in the system is associated with a set of work queues. A best
    effort is made to schedule all work emanating from a processor onto the
    same processor. This prevents excessive sloshing of state information from
    one processor cache to another.

    For a given processor there are three work queues corresponding to three
    levels of classification -- Delayed Work items, Critical Work items and
    Hyper Critical work items. Each of these levels is associated with a
    Kernel Queue (KQUEUE). The number of threads associated with each of these
    queues can be independently controlled.

    Currently the tuning parameters for the dispatcher are all hard coded. A
    mechanism to intialize them from the registry needs to be implemented.

    The following parameters associated with the dispatcher can be tuned ...

    1) the wait time intervals associated with the kernel queue for each level.

    2) the minimum and amximum number of worker threads associated with each
    level.

--*/
{
    ULONG    ProcessorIndex,NumberOfProcessors;
    NTSTATUS Status;

    PAGED_CODE();

    // Currently we set the number of processors to 1. In future the
    // dispatcher can be tailored to multi processor implementation
    // by appropriately initializing it as follows
    // NumberOfProcessors = KeNumberProcessors;

    NumberOfProcessors = 1;

    RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads = 0;
    RxFileSystemDeviceObject->DispatcherContext.pTearDownEvent = NULL;

    // Currently the default values for the wait intervals are set as
    // 10 seconds ( expressed in system time units of 100 ns ticks ).
    RxWorkQueueWaitInterval[DelayedWorkQueue].QuadPart       = -10 * TICKS_PER_SECOND;
    RxWorkQueueWaitInterval[CriticalWorkQueue].QuadPart      = -10 * TICKS_PER_SECOND;
    RxWorkQueueWaitInterval[HyperCriticalWorkQueue].QuadPart = -10 * TICKS_PER_SECOND;

    RxSpinUpDispatcherWaitInterval.QuadPart = -60 * TICKS_PER_SECOND;

    RxDispatcher.NumberOfProcessors = NumberOfProcessors;
    RxDispatcher.OwnerProcess       = IoGetCurrentProcess();
    RxDispatcher.pWorkQueueDispatcher = &RxDispatcherWorkQueues;

    if (RxDispatcher.pWorkQueueDispatcher != NULL) {
        for (
             ProcessorIndex = 0;
             ProcessorIndex < NumberOfProcessors;
             ProcessorIndex++
            ) {
            Status = RxInitializeWorkQueueDispatcher(
                         &RxDispatcher.pWorkQueueDispatcher[ProcessorIndex]);

            if (Status != STATUS_SUCCESS) {
                break;
            }
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxInitializeMRxDispatcher(RxFileSystemDeviceObject);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        HANDLE   ThreadHandle;

        KeInitializeEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            NotificationEvent,
            FALSE);

        KeInitializeEvent(
            &RxDispatcher.SpinUpRequestsTearDownEvent,
            NotificationEvent,
            FALSE);

        InitializeListHead(
            &RxDispatcher.SpinUpRequests);

        RxDispatcher.State = RxDispatcherActive;

        KeInitializeSpinLock(&RxDispatcher.SpinUpRequestsLock);

        Status = PsCreateSystemThread(
                     &ThreadHandle,
                     PROCESS_ALL_ACCESS,
                     NULL,
                     NULL,
                     NULL,
                     RxSpinUpRequestsDispatcher,
                     &RxDispatcher);

        if (NT_SUCCESS(Status)) {
            // Close the handle so the thread can die when needed
            ZwClose(ThreadHandle);
        }
    }

    return Status;
}


NTSTATUS
RxInitializeMRxDispatcher(PRDBSS_DEVICE_OBJECT pMRxDeviceObject)
/*++

Routine Description:

    This routine initializes the dispatcher context for a mini rdr

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

--*/
{
    PAGED_CODE();

    pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads = 0;
    pMRxDeviceObject->DispatcherContext.pTearDownEvent = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RxSpinDownMRxDispatcher(PRDBSS_DEVICE_OBJECT pMRxDeviceObject)
/*++

Routine Description:

    This routine tears down the dispatcher context for a mini rdr

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

--*/
{
    LONG     FinalRefCount;
    KEVENT   TearDownEvent;
    KIRQL    SavedIrql;

    PAGED_CODE();

    KeInitializeEvent(
        &TearDownEvent,
        NotificationEvent,
        FALSE);


    InterlockedIncrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    pMRxDeviceObject->DispatcherContext.pTearDownEvent = &TearDownEvent;

    FinalRefCount = InterlockedDecrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    if (FinalRefCount > 0) {
        KeWaitForSingleObject(
            &TearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    } else {
        InterlockedExchangePointer(
            &pMRxDeviceObject->DispatcherContext.pTearDownEvent,
            NULL);
    }

    ASSERT(pMRxDeviceObject->DispatcherContext.pTearDownEvent == NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine initializes the work queue dispatcher for a particular processor

Arguments:

    pDispatcher - Work Queue Dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

   For each of the work queues associated with a processor the minimum number of
   worker threads and maximum number of worker threads can be independently
   specified and tuned.

   The two factors that influence these decision are (1) the cost of spinnning up/
   spinning down worker threads and (2) the amount of resources consumed by an
   idle worker thread.

   Currently these numbers are hard coded, a desirable extension would be a mechanism
   to initialize them from a registry setting. This will enable us to tune the
   parameters easily. This has to be implemented.

--*/
{
    NTSTATUS        Status;
    MM_SYSTEMSIZE  SystemSize;
    ULONG           NumberOfCriticalWorkerThreads;

    PAGED_CODE();

    SystemSize = MmQuerySystemSize();

    RxInitializeWorkQueue(
        &pDispatcher->WorkQueue[DelayedWorkQueue],DelayedWorkQueue,2,1);

    if (SystemSize == MmLargeSystem) {
        NumberOfCriticalWorkerThreads = 10;
    } else {
        NumberOfCriticalWorkerThreads = 5;
    }

    RxInitializeWorkQueue(
        &pDispatcher->WorkQueue[CriticalWorkQueue],
        CriticalWorkQueue,
        NumberOfCriticalWorkerThreads,
        1);

    RxInitializeWorkQueue(
        &pDispatcher->WorkQueue[HyperCriticalWorkQueue],
        HyperCriticalWorkQueue,
        5,
        1);

    Status = RxSpinUpWorkerThread(
                 &pDispatcher->WorkQueue[HyperCriticalWorkQueue],
                 RxBootstrapWorkerThreadDispatcher,
                 &pDispatcher->WorkQueue[HyperCriticalWorkQueue]);

    if (Status == STATUS_SUCCESS) {
        Status = RxSpinUpWorkerThread(
                     &pDispatcher->WorkQueue[CriticalWorkQueue],
                     RxBootstrapWorkerThreadDispatcher,
                     &pDispatcher->WorkQueue[CriticalWorkQueue]);
    }

    if (Status == STATUS_SUCCESS) {
        Status = RxSpinUpWorkerThread(
                     &pDispatcher->WorkQueue[DelayedWorkQueue],
                     RxBootstrapWorkerThreadDispatcher,
                     &pDispatcher->WorkQueue[DelayedWorkQueue]);
    }

    return Status;
}

VOID
RxInitializeWorkQueue(
    PRX_WORK_QUEUE   pWorkQueue,
    WORK_QUEUE_TYPE  WorkQueueType,
    ULONG            MaximumNumberOfWorkerThreads,
    ULONG            MinimumNumberOfWorkerThreads)
/*++

Routine Description:

    This routine initializes a work queue

Arguments:

    pWorkQueue - Work Queue Dispatcher

    MaximumNumberOfWorkerThreads - the upper bound on worker threads

    MinimumNumberOfWorkerThreads - the lower bound on the threads.

--*/
{
    PAGED_CODE();

    pWorkQueue->Type                  = (UCHAR)WorkQueueType;
    pWorkQueue->State                 = RxWorkQueueActive;
    pWorkQueue->SpinUpRequestPending  = FALSE;
    pWorkQueue->pRundownContext       = NULL;

    pWorkQueue->NumberOfWorkItemsDispatched     = 0;
    pWorkQueue->NumberOfWorkItemsToBeDispatched = 0;
    pWorkQueue->CumulativeQueueLength           = 0;

    pWorkQueue->NumberOfSpinUpRequests       = 0;
    pWorkQueue->MaximumNumberOfWorkerThreads = MaximumNumberOfWorkerThreads;
    pWorkQueue->MinimumNumberOfWorkerThreads = MinimumNumberOfWorkerThreads;
    pWorkQueue->NumberOfActiveWorkerThreads  = 0;
    pWorkQueue->NumberOfIdleWorkerThreads    = 0;
    pWorkQueue->NumberOfFailedSpinUpRequests = 0;
    pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse = 0;

    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForTearDownWorkQueue,NULL,NULL);
    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,NULL,NULL);
    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinDownWorkerThread,NULL,NULL);
    pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject = NULL;
    pWorkQueue->WorkQueueItemForSpinUpWorkerThread.pDeviceObject = NULL;
    pWorkQueue->WorkQueueItemForTearDownWorkQueue.pDeviceObject = NULL;

    KeInitializeQueue(&pWorkQueue->Queue,MaximumNumberOfWorkerThreads);
    KeInitializeSpinLock(&pWorkQueue->SpinLock);
}

NTSTATUS
RxTearDownDispatcher()
/*++

Routine Description:

    This routine tears down the dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

--*/
{
    LONG    ProcessorIndex;
    NTSTATUS Status;

    PAGED_CODE();

    if (RxDispatcher.pWorkQueueDispatcher != NULL) {
        RxDispatcher.State = RxDispatcherInactive;

        KeSetEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            IO_NO_INCREMENT,
            FALSE);

        KeWaitForSingleObject(
            &RxDispatcher.SpinUpRequestsTearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        if (RxSpinUpRequestsThread != NULL) {
            if (!PsIsThreadTerminating(RxSpinUpRequestsThread)) {
                // Wait for the thread to terminate.
                KeWaitForSingleObject(
                    RxSpinUpRequestsThread,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                ASSERT(PsIsThreadTerminating(RxSpinUpRequestsThread));
            }

            ObDereferenceObject(RxSpinUpRequestsThread);
        }

        for (
             ProcessorIndex = 0;
             ProcessorIndex < RxDispatcher.NumberOfProcessors;
             ProcessorIndex++
            ) {
            RxTearDownWorkQueueDispatcher(&RxDispatcher.pWorkQueueDispatcher[ProcessorIndex]);
        }

        //RxFreePool(RxDispatcher.pWorkQueueDispatcher);
    }

    return STATUS_SUCCESS;
}

VOID
RxTearDownWorkQueueDispatcher(
    PRX_WORK_QUEUE_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine tears dwon the work queue dispatcher for a particular processor

Arguments:

    pDispatcher - Work Queue Dispatcher

--*/
{
    PAGED_CODE();

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[DelayedWorkQueue]);

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[CriticalWorkQueue]);

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[HyperCriticalWorkQueue]);
}

VOID
RxTearDownWorkQueue(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine tears down a work queue

Arguments:

    pWorkQueue - Work Queue

Notes:

   Tearing down a work queue is a more complex process when compared to initializing
   a work queue. This is because of the threads associated with the queue. In order
   to ensure that the work queue can be torn down correctly each of the threads
   associated with the queue must be spun down correctly.

   This is accomplished by changing the state of the work queue from
   RxWorkQueueActive to RxWorkQueueRundownInProgress. This prevents further requests
   from being inserted into the queue. Having done that the currently active threads
   must be spundown.

   The spinning down process is accelerated by posting a dummy work item onto the
   work queue so that the waits are immediately satisfied.

--*/
{
    KIRQL       SavedIrql;
    ULONG       NumberOfActiveThreads;
    PLIST_ENTRY pFirstListEntry,pNextListEntry;

    PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

    pRundownContext = (PRX_WORK_QUEUE_RUNDOWN_CONTEXT)
                     RxAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(RX_WORK_QUEUE_RUNDOWN_CONTEXT) +
                        pWorkQueue->MaximumNumberOfWorkerThreads * sizeof(PETHREAD),
                        RX_WORKQ_POOLTAG);

    if (pRundownContext != NULL) {
        KeInitializeEvent(
            &pRundownContext->RundownCompletionEvent,
            NotificationEvent,
            FALSE);

        pRundownContext->NumberOfThreadsSpunDown = 0;
        pRundownContext->ThreadPointers = (PETHREAD *)(pRundownContext + 1);

        KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

        ASSERT((pWorkQueue->pRundownContext == NULL) &&
               (pWorkQueue->State == RxWorkQueueActive));

        pWorkQueue->pRundownContext = pRundownContext;
        pWorkQueue->State = RxWorkQueueRundownInProgress;

        NumberOfActiveThreads = pWorkQueue->NumberOfActiveWorkerThreads;

        KeReleaseSpinLock(&pWorkQueue->SpinLock,SavedIrql);

        if (NumberOfActiveThreads > 0) {
            pWorkQueue->WorkQueueItemForTearDownWorkQueue.pDeviceObject = RxFileSystemDeviceObject;
            InterlockedIncrement(&RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);
            ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForTearDownWorkQueue,RxSpinDownWorkerThreads,pWorkQueue);
            KeInsertQueue(&pWorkQueue->Queue,&pWorkQueue->WorkQueueItemForTearDownWorkQueue.List);

            KeWaitForSingleObject(
                &pWorkQueue->pRundownContext->RundownCompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        if (pRundownContext->NumberOfThreadsSpunDown > 0) {
            LONG Index = 0;

            for (
                 Index = pRundownContext->NumberOfThreadsSpunDown - 1;
                 Index >= 0;
                 Index--
                ) {
                PETHREAD pThread;

                pThread = pRundownContext->ThreadPointers[Index];

                ASSERT(pThread != NULL);

                if (!PsIsThreadTerminating(pThread)) {
                    // Wait for the thread to terminate.
                    KeWaitForSingleObject(
                        pThread,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);

                    ASSERT(PsIsThreadTerminating(pThread));
                }

                ObDereferenceObject(pThread);
            }
        }

        RxFreePool(pRundownContext);
    }

    ASSERT(pWorkQueue->NumberOfActiveWorkerThreads == 0);

    pFirstListEntry = KeRundownQueue(&pWorkQueue->Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;

        do {
            PWORK_QUEUE_ITEM pWorkQueueItem;

            pWorkQueueItem = (PWORK_QUEUE_ITEM)
                             CONTAINING_RECORD(
                                 pNextListEntry,
                                 WORK_QUEUE_ITEM,
                                 List);

            pNextListEntry = pNextListEntry->Flink;

            if (pWorkQueueItem->WorkerRoutine == RxWorkItemDispatcher) {
                RxFreePool(pWorkQueueItem);
            }
        } while (pNextListEntry != pFirstListEntry);
    }
}

NTSTATUS
RxSpinUpWorkerThread(
    PRX_WORK_QUEUE             pWorkQueue,
    PRX_WORKERTHREAD_ROUTINE   Routine,
    PVOID                      Parameter)
/*++

Routine Description:

    This routine spins up a worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

    Routine    - the thread routine

    Parameter  - the thread routine parameter

Return Value:

    STATUS_SUCCESS if successful,

    otherwise appropriate error code

--*/
{
    NTSTATUS Status;
    HANDLE   ThreadHandle;
    KIRQL    SavedIrql;

    PAGED_CODE();

    KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

    if( pWorkQueue->State == RxWorkQueueActive )
    {
        pWorkQueue->NumberOfActiveWorkerThreads++;
        Status = STATUS_SUCCESS;
        //RxLogRetail(("SpinUpWT %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
        RxLogRetail(("SpinUpWT Fail %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));
        //DbgPrint("[dkruse] RDBSS would have crashed here without this fix!\n");
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql );

    if( NT_SUCCESS(Status) )
    {
        Status = PsCreateSystemThread(
                     &ThreadHandle,
                     PROCESS_ALL_ACCESS,
                     NULL,
                     NULL,
                     NULL,
                     Routine,
                     Parameter);

        if (NT_SUCCESS(Status)) {
            // Close the handle so the thread can die when needed
            ZwClose(ThreadHandle);
        } else {

            // Log the inability to create a worker thread.
            RxLog(("WorkQ: %lx SpinUpStat %lx\n",pWorkQueue,Status));
            RxWmiLogError(Status,
                          LOG,
                          RxSpinUpWorkerThread,
                          LOGPTR(pWorkQueue)
                          LOGULONG(Status));


            // Change the thread count back, and set the rundown completion event if necessary
            KeAcquireSpinLock( &pWorkQueue->SpinLock, &SavedIrql );

            pWorkQueue->NumberOfActiveWorkerThreads--;
            pWorkQueue->NumberOfFailedSpinUpRequests++;

            if( (pWorkQueue->NumberOfActiveWorkerThreads == 0) &&
                (pWorkQueue->State == RxWorkQueueRundownInProgress) )
            {
                KeSetEvent(
                    &pWorkQueue->pRundownContext->RundownCompletionEvent,
                    IO_NO_INCREMENT,
                    FALSE);
            }

            RxLogRetail(("SpinUpWT Fail2 %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));

            KeReleaseSpinLock( &pWorkQueue->SpinLock, SavedIrql );

        }
    }


    return Status;
}

VOID
RxpSpinUpWorkerThreads(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine ensures that the dispatcher is not torn down while requests
    are pending in the kernel worker threads for spin ups

Arguments:

    pWorkQueue - the WorkQueue instance.

Notes:

    There is implicit reliance on the fact that the RxDispatcher owner process
    is the same as the system process. If this is not TRUE then an alternate
    way needs to be implemented for ensuring that spinup requests are not stuck
    behind other requests.

--*/
{
    LONG NumberOfWorkerThreads;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxDispatcher.OwnerProcess);

    RxSpinUpWorkerThreads(pWorkQueue);

    NumberOfWorkerThreads = InterlockedDecrement(
                                &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    if (NumberOfWorkerThreads == 0) {
        PKEVENT pTearDownEvent;

        pTearDownEvent = (PKEVENT)
                         InterlockedExchangePointer(
                             &RxFileSystemDeviceObject->DispatcherContext.pTearDownEvent,
                             NULL);

        if (pTearDownEvent != NULL) {
            KeSetEvent(
                pTearDownEvent,
                IO_NO_INCREMENT,
                FALSE);
        }
    }
}

VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine ensures that there is an independent thread to handle spinup
    requests for all types of threads. This routine will be active as long as
    the dispatcher is active

Arguments:

    pDispatcher - the dispatcher instance.

Notes:

    There is implicit reliance on the fact that the RxDispatcher owner process
    is the same as the system process. If this is not TRUE then an alternate
    way needs to be implemented for ensuring that spinup requests are not stuck
    behind other requests.

--*/
{
    PETHREAD ThisThread;
    NTSTATUS Status;

    RxDbgTrace(0,Dbg,("+++++ Worker SpinUp Requests Thread Startup %lx\n",PsGetCurrentThread()));

    ThisThread = PsGetCurrentThread();
    Status     = ObReferenceObjectByPointer(
                     ThisThread,
                     THREAD_ALL_ACCESS,
                     *PsThreadType,
                     KernelMode);

    if (Status == STATUS_SUCCESS) {
        RxSpinUpRequestsThread = ThisThread;

        for (;;) {
            NTSTATUS            Status;
            RX_DISPATCHER_STATE State;
            KIRQL               SavedIrql;
            LIST_ENTRY          SpinUpRequests;
            PLIST_ENTRY         pListEntry;

            InitializeListHead(&SpinUpRequests);

            Status = KeWaitForSingleObject(
                         &pDispatcher->SpinUpRequestsEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         &RxSpinUpDispatcherWaitInterval);

            ASSERT((Status == STATUS_SUCCESS) || (Status == STATUS_TIMEOUT));

            KeAcquireSpinLock(
                &pDispatcher->SpinUpRequestsLock,
                &SavedIrql);

            RxTransferList(
                &SpinUpRequests,
                &pDispatcher->SpinUpRequests);

            State = pDispatcher->State;

            KeResetEvent(
                &pDispatcher->SpinUpRequestsEvent);

            KeReleaseSpinLock(
                &pDispatcher->SpinUpRequestsLock,
                SavedIrql);

            // Process the spin up requests

            while (!IsListEmpty(&SpinUpRequests)) {
                PRX_WORKERTHREAD_ROUTINE Routine;
                PVOID                    pParameter;
                PWORK_QUEUE_ITEM         pWorkQueueItem;
                PRX_WORK_QUEUE           pWorkQueue;
                LONG ItemInUse;

                pListEntry = RemoveHeadList(&SpinUpRequests);

                pWorkQueueItem = (PWORK_QUEUE_ITEM)
                                 CONTAINING_RECORD(
                                     pListEntry,
                                     WORK_QUEUE_ITEM,
                                     List);

                Routine       = pWorkQueueItem->WorkerRoutine;
                pParameter    = pWorkQueueItem->Parameter;
                pWorkQueue    = (PRX_WORK_QUEUE)pParameter;

                ItemInUse = InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

                RxLog(("WORKQ:SR %lx %lx\n", Routine, pParameter ));
                RxWmiLog(LOG,
                         RxSpinUpRequestsDispatcher,
                         LOGPTR(Routine)
                         LOGPTR(pParameter));

                Routine(pParameter);
            }

            if (State != RxDispatcherActive) {
                KeSetEvent(
                    &pDispatcher->SpinUpRequestsTearDownEvent,
                    IO_NO_INCREMENT,
                    FALSE);

                break;
            }
        }
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine spins up one or more worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

Return Value:

    STATUS_SUCCESS if successful,

    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    HANDLE   ThreadHandle;

    LONG     NumberOfThreads;
    KIRQL    SavedIrql;
    LONG     ItemInUse;

    if ((IoGetCurrentProcess() != RxDispatcher.OwnerProcess) ||
        (KeGetCurrentIrql() != PASSIVE_LEVEL)) {

        ItemInUse = InterlockedIncrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

        if (ItemInUse > 1) {
            // A work queue item is already on the SpinUpRequests waiting to be processed.
            // No need to post another one.
            InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);
            return;
        }

        InterlockedIncrement(
            &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

        ExInitializeWorkItem(
            (PWORK_QUEUE_ITEM)&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,
            RxpSpinUpWorkerThreads,
            pWorkQueue);

        KeAcquireSpinLock(&RxDispatcher.SpinUpRequestsLock, &SavedIrql);

        InsertTailList(
            &RxDispatcher.SpinUpRequests,
            &pWorkQueue->WorkQueueItemForSpinUpWorkerThread.List);

        KeSetEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            IO_NO_INCREMENT,
            FALSE);

        KeReleaseSpinLock(&RxDispatcher.SpinUpRequestsLock,SavedIrql);
    } else {
        // Decide on the number of worker threads that need to be spun up.
        KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

        if( pWorkQueue->State != RxWorkQueueRundownInProgress )
        {
            NumberOfThreads = pWorkQueue->MaximumNumberOfWorkerThreads -
                              pWorkQueue->NumberOfActiveWorkerThreads;

            if (NumberOfThreads > pWorkQueue->NumberOfWorkItemsToBeDispatched) {
                NumberOfThreads = pWorkQueue->NumberOfWorkItemsToBeDispatched;
            }
        }
        else
        {
            // We're running down, so don't increment
            NumberOfThreads = 0;
            //DbgPrint( "[dkruse] Preventing rundown!\n" );
        }

        pWorkQueue->SpinUpRequestPending  = FALSE;

        KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

        while (NumberOfThreads-- > 0) {
            Status = RxSpinUpWorkerThread(
                         pWorkQueue,
                         RxWorkerThreadDispatcher,
                         pWorkQueue);

            if (Status != STATUS_SUCCESS) {
                break;
            }
        }

        if (Status != STATUS_SUCCESS) {
            ItemInUse = InterlockedIncrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

            if (ItemInUse > 1) {
                // A work queue item is already on the SpinUpRequests waiting to be processed.
                // No need to post another one.
                InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);
                return;
            }

            ExInitializeWorkItem(
                (PWORK_QUEUE_ITEM)&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,
                RxpSpinUpWorkerThreads,
                pWorkQueue);

            KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

            pWorkQueue->SpinUpRequestPending  = TRUE;

            KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

            KeAcquireSpinLock(&RxDispatcher.SpinUpRequestsLock, &SavedIrql);

            // An attempt to spin up a worker thread failed. Reschedule the
            // requests to attempt this operation later.

            InterlockedIncrement(
                &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

            InsertTailList(
                &RxDispatcher.SpinUpRequests,
                &pWorkQueue->WorkQueueItemForSpinUpWorkerThread.List);

            KeReleaseSpinLock(&RxDispatcher.SpinUpRequestsLock,SavedIrql);
        }
    }
}

VOID
RxSpinDownWorkerThreads(
    PRX_WORK_QUEUE    pWorkQueue)
/*++

Routine Description:

    This routine spins down one or more worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

--*/
{
    KIRQL    SavedIrql;
    BOOLEAN  RepostSpinDownRequest = FALSE;

    // Decide on the number of worker threads that need to be spun up.
    KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

    if (pWorkQueue->NumberOfActiveWorkerThreads > 1) {
        RepostSpinDownRequest = TRUE;
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

    if (RepostSpinDownRequest) {
        if (pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject == NULL) {
            pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject = RxFileSystemDeviceObject;
        }

        ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinDownWorkerThread,RxSpinDownWorkerThreads,pWorkQueue);
        KeInsertQueue(&pWorkQueue->Queue,&pWorkQueue->WorkQueueItemForSpinDownWorkerThread.List);
    }
}

BOOLEAN DumpDispatchRoutine = FALSE;

VOID
RxpWorkerThreadDispatcher(
    IN PRX_WORK_QUEUE pWorkQueue,
    IN PLARGE_INTEGER pWaitInterval)
/*++

Routine Description:

    This routine dispatches a work item and frees the associated work item

Arguments:

     pWorkQueue - the WorkQueue instance.

     pWaitInterval - the interval for waiting on the KQUEUE.

--*/
{
    NTSTATUS                 Status;
    PLIST_ENTRY              pListEntry;
    PRX_WORK_QUEUE_ITEM      pWorkQueueItem;
    PRX_WORKERTHREAD_ROUTINE Routine;
    PVOID                    pParameter;
    BOOLEAN                  SpindownThread,DereferenceThread;
    KIRQL                    SavedIrql;
    PETHREAD                 ThisThread;

    RxDbgTrace(0,Dbg,("+++++ Worker Thread Startup %lx\n",PsGetCurrentThread()));

    InterlockedIncrement(&pWorkQueue->NumberOfIdleWorkerThreads);

    ThisThread = PsGetCurrentThread();
    Status     = ObReferenceObjectByPointer(
                     ThisThread,
                     THREAD_ALL_ACCESS,
                     *PsThreadType,
                     KernelMode);

    ASSERT(Status == STATUS_SUCCESS);

    SpindownThread    = FALSE;
    DereferenceThread = FALSE;

    for (;;) {
        pListEntry = KeRemoveQueue(
                         &pWorkQueue->Queue,
                         KernelMode,
                         pWaitInterval);

        if ((NTSTATUS)(ULONG_PTR)pListEntry != STATUS_TIMEOUT) {
            LONG                 FinalRefCount;
            PRDBSS_DEVICE_OBJECT pMRxDeviceObject;

            InterlockedIncrement(&pWorkQueue->NumberOfWorkItemsDispatched);
            InterlockedDecrement(&pWorkQueue->NumberOfWorkItemsToBeDispatched);
            InterlockedDecrement(&pWorkQueue->NumberOfIdleWorkerThreads);

            InitializeListHead(pListEntry);

            pWorkQueueItem = (PRX_WORK_QUEUE_ITEM)
                              CONTAINING_RECORD(
                                  pListEntry,
                                  RX_WORK_QUEUE_ITEM,
                                  List);

            pMRxDeviceObject = pWorkQueueItem->pDeviceObject;

            // This is a regular work item. Invoke the routine in the context of
            // a try catch block.

            Routine       = pWorkQueueItem->WorkerRoutine;
            pParameter    = pWorkQueueItem->Parameter;

            // Reset the fields in the Work item.

            ExInitializeWorkItem(pWorkQueueItem,NULL,NULL);
            pWorkQueueItem->pDeviceObject = NULL;

            RxDbgTrace(0, Dbg, ("RxWorkerThreadDispatcher Routine(%lx) Parameter(%lx)\n",Routine,pParameter));
            //RxLog(("WORKQ:Ex Dev(%lx) %lx %lx\n", pMRxDeviceObject,Routine, pParameter ));
            //RxWmiLog(LOG,
            //         RxpWorkerThreadDispatcher,
            //         LOGPTR(pMRxDeviceObject)
            //         LOGPTR(Routine)
            //         LOGPTR(pParameter));

            Routine(pParameter);

            FinalRefCount = InterlockedDecrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

            if (FinalRefCount == 0) {
                PKEVENT pTearDownEvent;

                pTearDownEvent = (PKEVENT)
                                 InterlockedExchangePointer(
                                     &pMRxDeviceObject->DispatcherContext.pTearDownEvent,
                                     NULL);

                if (pTearDownEvent != NULL) {
                    KeSetEvent(
                        pTearDownEvent,
                        IO_NO_INCREMENT,
                        FALSE);
                }
            }

            InterlockedIncrement(&pWorkQueue->NumberOfIdleWorkerThreads);
        }

        KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

        switch (pWorkQueue->State) {
        case RxWorkQueueActive:
            {
                if (pWorkQueue->NumberOfWorkItemsToBeDispatched > 0) {
                    // Delay spinning down a worker thread till the existing work
                    // items have been dispatched.
                    break;
                }
            }
            // lack of break intentional.
            // Ensure that the number of idle threads is not more than the
            // minimum number of worker threads permitted for the work queue
        case RxWorkQueueInactive:
            {
                ASSERT(pWorkQueue->NumberOfActiveWorkerThreads > 0);

                if (pWorkQueue->NumberOfActiveWorkerThreads >
                    pWorkQueue->MinimumNumberOfWorkerThreads) {
                    SpindownThread = TRUE;
                    DereferenceThread = TRUE;
                    InterlockedDecrement(&pWorkQueue->NumberOfActiveWorkerThreads);
                }
            }
            break;

        case RxWorkQueueRundownInProgress:
            {
                PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

                pRundownContext = pWorkQueue->pRundownContext;

                // The work queue is no longer active. Spin down all the worker
                // threads associated with the work queue.

                ASSERT(pRundownContext != NULL);

                pRundownContext->ThreadPointers[pRundownContext->NumberOfThreadsSpunDown++] = ThisThread;

                InterlockedDecrement(&pWorkQueue->NumberOfActiveWorkerThreads);

                SpindownThread    = TRUE;
                DereferenceThread = FALSE;

                if (pWorkQueue->NumberOfActiveWorkerThreads == 0) {
                    KeSetEvent(
                        &pWorkQueue->pRundownContext->RundownCompletionEvent,
                        IO_NO_INCREMENT,
                        FALSE);
                }
            }
            break;

        default:
            ASSERT(!"Valid State For Work Queue");
        }

        if (SpindownThread) {
            InterlockedDecrement(&pWorkQueue->NumberOfIdleWorkerThreads);
        }

        KeReleaseSpinLock(&pWorkQueue->SpinLock,SavedIrql);

        if (SpindownThread) {
            RxDbgTrace(0,Dbg,("----- Worker Thread Exit %lx\n",PsGetCurrentThread()));
            break;
        }
    }

    if (DereferenceThread) {
        ObDereferenceObject(ThisThread);
    }

    if (DumpDispatchRoutine) {
        // just to keep them around on free build for debug purpose
        DbgPrint("Dispatch routine %lx %lx %lx\n",Routine,pParameter,pWorkQueueItem);
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID
RxBootstrapWorkerThreadDispatcher(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine is for worker threads that use a infinite time interval
    for waiting on the KQUEUE data structure. These threads cannot be throtled
    back and are used for ensuring that the bare minimum number of threads
    are always active ( primarily startup purposes )

Arguments:

     pWorkQueue - the WorkQueue instance.

--*/
{
    PAGED_CODE();

    RxpWorkerThreadDispatcher(pWorkQueue,NULL);
}

VOID
RxWorkerThreadDispatcher(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine is for worker threads that use a finite time interval to wait
    on the KQUEUE data structure. Such threads have a self regulatory mechanism
    built in which causes them to spin down if the work load eases off. The
    time interval is based on the type of the work queue

Arguments:

     pWorkQueue - the WorkQueue instance.

--*/
{
    PAGED_CODE();

    RxpWorkerThreadDispatcher(
        pWorkQueue,
        &RxWorkQueueWaitInterval[pWorkQueue->Type]);
}

NTSTATUS
RxInsertWorkQueueItem(
    PRDBSS_DEVICE_OBJECT pDeviceObject,
    WORK_QUEUE_TYPE      WorkQueueType,
    PRX_WORK_QUEUE_ITEM  pWorkQueueItem)
/*++

Routine Description:

    This routine inserts a work item into the appropriate queue.

Arguments:

     pDeviceObject  - the device object

     WorkQueueType  - the type of work item

     pWorkQueueItem - the work queue item

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate error conditions

         STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    This routine inserts the work item into the appropriate queue and spins
    up a worker thread if required.

    There are some extensions to this routine that needs to be implemented. These
    have been delayed in order to get an idea of the costs and the benefits of
    the various tradeoffs involved.

    The current implementation follows a very simple logic in queueing work
    from the various sources onto the same processor from which it originated.
    The benefits associated with this approach are the prevention of cache/state
    sloshing as the work is moved around from one processor to another. The
    undesirable charecterstic is the skewing of work load on the various processors.

    The important question that needs to be answered is when is it beneficial to
    sacrifice the affinity to a processor. This depends upon the workload associated
    with the current processor and the amount of information associated with the
    given processor. The later is more difficult to determine.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    KIRQL    SavedIrql;

    BOOLEAN  SpinUpWorkerThread = FALSE;
    ULONG    ProcessorNumber;

    // If the dispatcher were on a per processor basis the ProcessorNumber
    // would be indx for accessing the dispatcher data structure
    // ProcessorNumber = KeGetCurrentProcessorNumber();

    PRX_WORK_QUEUE_DISPATCHER pWorkQueueDispatcher;
    PRX_WORK_QUEUE            pWorkQueue;

    ProcessorNumber = 0;

    pWorkQueueDispatcher = &RxDispatcher.pWorkQueueDispatcher[ProcessorNumber];
    pWorkQueue           = &pWorkQueueDispatcher->WorkQueue[WorkQueueType];

    if (RxDispatcher.State != RxDispatcherActive)
    {
        return STATUS_UNSUCCESSFUL;
    }

    KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

    if ((pWorkQueue->State == RxWorkQueueActive) &&
        (pDeviceObject->DispatcherContext.pTearDownEvent == NULL)) {
        pWorkQueueItem->pDeviceObject = pDeviceObject;
        InterlockedIncrement(&pDeviceObject->DispatcherContext.NumberOfWorkerThreads);

        pWorkQueue->CumulativeQueueLength += pWorkQueue->NumberOfWorkItemsToBeDispatched;
        InterlockedIncrement(&pWorkQueue->NumberOfWorkItemsToBeDispatched);

        if ((pWorkQueue->NumberOfIdleWorkerThreads < pWorkQueue->NumberOfWorkItemsToBeDispatched) &&
            (pWorkQueue->NumberOfActiveWorkerThreads < pWorkQueue->MaximumNumberOfWorkerThreads) &&
            (!pWorkQueue->SpinUpRequestPending)) {
            pWorkQueue->SpinUpRequestPending = TRUE;
            SpinUpWorkerThread = TRUE;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

    if (Status == STATUS_SUCCESS) {
        KeInsertQueue(&pWorkQueue->Queue,&pWorkQueueItem->List);

        if (SpinUpWorkerThread) {
            RxSpinUpWorkerThreads(
                pWorkQueue);
        }
    } else {
        RxWmiLogError(Status,
                      LOG,
                      RxInsertWorkQueueItem,
                      LOGPTR(pDeviceObject)
                      LOGULONG(WorkQueueType)
                      LOGPTR(pWorkQueueItem)
                      LOGUSTR(pDeviceObject->DeviceName));
    }

    return Status;
}

VOID
RxWorkItemDispatcher(
    PVOID    pContext)
/*++

Routine Description:

    This routine serves as a wrapper for dispatching a work item and for
    performing the related cleanup actions

Arguments:

     pContext   - the Context parameter that is passed to the driver routine.

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

    This routine implements a wrapper for those instances in which time was traded
    off for space. It invokes the desired routine and frees the memory.

--*/
{
    PRX_WORK_DISPATCH_ITEM   pDispatchItem;
    PRX_WORKERTHREAD_ROUTINE Routine;
    PVOID                    Parameter;

    pDispatchItem = (PRX_WORK_DISPATCH_ITEM)pContext;

    Routine   = pDispatchItem->DispatchRoutine;
    Parameter = pDispatchItem->DispatchRoutineParameter;

    //RxLog(("WORKQ:Ds %lx %lx\n", Routine, Parameter ));
    //RxWmiLog(LOG,
    //         RxWorkItemDispatcher,
    //         LOGPTR(Routine)
    //         LOGPTR(Parameter));

    Routine(Parameter);

    RxFreePool(pDispatchItem);
}

NTSTATUS
RxDispatchToWorkerThread(
    IN OUT PRDBSS_DEVICE_OBJECT       pMRxDeviceObject,
    IN     WORK_QUEUE_TYPE            WorkQueueType,
    IN     PRX_WORKERTHREAD_ROUTINE   Routine,
    IN     PVOID                      pContext)
/*++

Routine Description:

    This routine invokes the routine in the context of a worker thread.

Arguments:

     pMRxDeviceObject - the device object of the corresponding mini redirector

     WorkQueueType    - the type of the work queue

     Routine          - routine to be invoked

     pContext         - the Context parameter that is passed to the driver routine.

Return Value:

     STATUS_SUCCESS                -- successful

     STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

--*/
{
    NTSTATUS               Status;
    PRX_WORK_DISPATCH_ITEM pDispatchItem;
    KIRQL                  SavedIrql;

    pDispatchItem = RxAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(RX_WORK_DISPATCH_ITEM),
                        RX_WORKQ_POOLTAG);

    if (pDispatchItem != NULL) {
        pDispatchItem->DispatchRoutine          = Routine;
        pDispatchItem->DispatchRoutineParameter = pContext;

        ExInitializeWorkItem(
            &pDispatchItem->WorkQueueItem,
            RxWorkItemDispatcher,
            pDispatchItem);

        Status = RxInsertWorkQueueItem(pMRxDeviceObject,WorkQueueType,&pDispatchItem->WorkQueueItem);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status != STATUS_SUCCESS) {
        if (pDispatchItem != NULL) {
            RxFreePool(pDispatchItem);
        }

        RxLog(("WORKQ:Queue(D) %ld %lx %lx %lx\n", WorkQueueType,Routine,pContext,Status));
        RxWmiLogError(Status,
                      LOG,
                      RxDispatchToWorkerThread,
                      LOGULONG(WorkQueueType)
                      LOGPTR(Routine)
                      LOGPTR(pContext)
                      LOGULONG(Status));
    }

    return Status;
}

NTSTATUS
RxPostToWorkerThread(
    IN OUT PRDBSS_DEVICE_OBJECT       pMRxDeviceObject,
    IN     WORK_QUEUE_TYPE            WorkQueueType,
    IN OUT PRX_WORK_QUEUE_ITEM        pWorkQueueItem,
    IN     PRX_WORKERTHREAD_ROUTINE   Routine,
    IN     PVOID                      pContext)
/*++

Routine Description:

    This routine invokes the routine in the context of a worker thread.

Arguments:

     WorkQueueType - the priority of the task at hand.

     WorkQueueItem - the work queue item

     Routine       - routine to be invoked

     pContext      - the Context parameter that is passed to the driver routine.

Return Value:

     STATUS_SUCCESS                -- successful

     STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

--*/
{
    NTSTATUS Status;

    ExInitializeWorkItem( pWorkQueueItem,Routine,pContext );
    Status = RxInsertWorkQueueItem(pMRxDeviceObject,WorkQueueType,pWorkQueueItem);

    if (Status != STATUS_SUCCESS) {
        RxLog(("WORKQ:Queue(P) %ld %lx %lx %lx\n", WorkQueueType,Routine,pContext,Status));
        RxWmiLogError(Status,
                      LOG,
                      RxPostToWorkerThread,
                      LOGULONG(WorkQueueType)
                      LOGPTR(Routine)
                      LOGPTR(pContext)
                      LOGULONG(Status));
    }

    return Status;
}


PEPROCESS
RxGetRDBSSProcess()
{
   return RxData.OurProcess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\rxcep.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT specific notification routines in the connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    The notification of a transport binding/unbinding to the mini redirectors is done
    in a worker thread. In order to simplify the task of writing a routine the connection
    engine guarantees that not more than one  invocation of MRxTranspotrtUpdateHandler
    will be active at any instant of time for a given mini redirector.

    There is no thread dedicated to processing these notifications. A worker thread is
    used to process the notifications. In order to ensure condition (1) all the notifications
    are queued ( interlocked queue ).

--*/

#include "precomp.h"
#pragma  hdrstop

#include "mrx.h"

typedef struct _RXCE_MINIRDR_NOTIFICATION_CONTEXT_ {
    LIST_ENTRY           NotificationListEntry;
    PRXCE_TRANSPORT      pTransport;
    RXCE_TRANSPORT_EVENT TransportEvent;
} RXCE_MINIRDR_NOTIFICATION_CONTEXT,
  *PRXCE_MINIRDR_NOTIFICATION_CONTEXT;

typedef struct _RXCE_MINIRDR_NOTIFICATION_HANDLER_ {
    WORK_QUEUE_ITEM WorkQueueEntry;
    KSPIN_LOCK         Lock;
    LIST_ENTRY         ListHead;
    BOOLEAN            NotifierActive;
} RXCE_MINIRDR_NOTIFICATION_HANDLER,
 *PRXCE_MINIRDR_NOTIFICATION_HANDLER;

RXCE_MINIRDR_NOTIFICATION_HANDLER s_RxCeMinirdrNotificationHandler;

extern VOID
MiniRedirectorsNotifier(
   PVOID NotificationContext);

NTSTATUS
InitializeMiniRedirectorNotifier()
{
    s_RxCeMinirdrNotificationHandler.NotifierActive = FALSE;
    KeInitializeSpinLock(&s_RxCeMinirdrNotificationHandler.Lock);
    InitializeListHead(&s_RxCeMinirdrNotificationHandler.ListHead);
    return STATUS_SUCCESS;
}

NTSTATUS
NotifyMiniRedirectors(
    RXCE_TRANSPORT_HANDLE  hTransport,
    RXCE_TRANSPORT_EVENT   TransportEvent,
    RXCE_NOTIFICATION_MODE Mode)
{
    NTSTATUS Status;
    KIRQL    SavedIrql;

    PRXCE_MINIRDR_NOTIFICATION_CONTEXT pContext;

    pContext = RxAllocatePoolWithTag(
                   PagedPool | POOL_COLD_ALLOCATION,
                   sizeof(RXCE_MINIRDR_NOTIFICATION_CONTEXT),
                   RX_MISC_POOLTAG);

    if (pContext != NULL) {
        pContext->TransportEvent = TransportEvent;

        // Reference the transport entry
        pContext->pTransport = RxCeReferenceTransport(hTransport);

        if (Mode == RXCE_ASYNCHRONOUS_NOTIFICATION) {
            BOOLEAN DispatchNotifier;

            // Acquire the spin lock ...
            KeAcquireSpinLock(
                &s_RxCeMinirdrNotificationHandler.Lock,
                &SavedIrql);

            DispatchNotifier = (IsListEmpty(&s_RxCeMinirdrNotificationHandler.ListHead) &&
                                !s_RxCeMinirdrNotificationHandler.NotifierActive);

            InsertTailList(&s_RxCeMinirdrNotificationHandler.ListHead,&pContext->NotificationListEntry);

            if (DispatchNotifier) {
                s_RxCeMinirdrNotificationHandler.NotifierActive = TRUE;
            }

            // Release the spin lock
            KeReleaseSpinLock(
                &s_RxCeMinirdrNotificationHandler.Lock,
                SavedIrql);

            // If the notification list is empty a worker thread needs to be fired up.
            if (DispatchNotifier) {
                RxPostToWorkerThread(
                    CriticalWorkQueue,
                    &s_RxCeMinirdrNotificationHandler.WorkQueueEntry,
                    MiniRedirectorsNotifier,
                    &s_RxCeMinirdrNotificationHandler);
            }

            Status = STATUS_SUCCESS;
        } else {
            ULONG                         i;
            PMRX_TRANSPORT_UPDATE_HANDLER MRxTransportUpdateHandler;
            PLIST_ENTRY ListEntry;

            // Notify all the mini redirectors ....
            for (ListEntry = RxRegisteredMiniRdrs.Flink;
                 ListEntry!= &RxRegisteredMiniRdrs;
                 ListEntry = ListEntry->Flink) {

                PRDBSS_DEVICE_OBJECT RxDeviceObject = CONTAINING_RECORD( ListEntry, RDBSS_DEVICE_OBJECT, MiniRdrListLinks );
                MRxTransportUpdateHandler = RxDeviceObject->Dispatch->MRxTransportUpdateHandler;

                if ( MRxTransportUpdateHandler != NULL) {
                    Status = MRxTransportUpdateHandler(
                                 pContext->pTransport,
                                 pContext->TransportEvent,
                                 pContext->pTransport->pProviderInfo);
                }
            }

            // Derefrence the transport entry
            RxCeDereferenceTransport(pContext->pTransport);

            // free the notification context.
            RxFreePool(pContext);

            Status = STATUS_SUCCESS;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
MiniRedirectorsNotifier(
    PVOID NotificationContext)
{
    NTSTATUS    Status;
    KIRQL    SavedIrql;

    PLIST_ENTRY pEntry;

    PRXCE_MINIRDR_NOTIFICATION_CONTEXT pContext;
    PMRX_TRANSPORT_UPDATE_HANDLER      MRxTransportUpdateHandler;

    for (;;) {
        PLIST_ENTRY ListEntry;

        // Acquire the spin lock ...
        KeAcquireSpinLock(
            &s_RxCeMinirdrNotificationHandler.Lock,
            &SavedIrql);

        // Remove an item from the notification list.
        if (!IsListEmpty(&s_RxCeMinirdrNotificationHandler.ListHead)) {
            pEntry = RemoveHeadList(
                         &s_RxCeMinirdrNotificationHandler.ListHead);
        } else {
            pEntry = NULL;
            s_RxCeMinirdrNotificationHandler.NotifierActive = FALSE;
        }

        // Release the spin lock
        KeReleaseSpinLock(&s_RxCeMinirdrNotificationHandler.Lock,SavedIrql);

        if (pEntry == NULL) {
            break;
        }

        pContext = (PRXCE_MINIRDR_NOTIFICATION_CONTEXT)
                   CONTAINING_RECORD(
                       pEntry,
                       RXCE_MINIRDR_NOTIFICATION_CONTEXT,
                       NotificationListEntry);

        // Notify all the mini redirectors ....
        for (ListEntry = RxRegisteredMiniRdrs.Flink;
             ListEntry!= &RxRegisteredMiniRdrs;
             ListEntry = ListEntry->Flink) {

            PRDBSS_DEVICE_OBJECT RxDeviceObject = CONTAINING_RECORD( ListEntry, RDBSS_DEVICE_OBJECT, MiniRdrListLinks );
            MRxTransportUpdateHandler = RxDeviceObject->Dispatch->MRxTransportUpdateHandler;

            if ( MRxTransportUpdateHandler != NULL) {
                Status = MRxTransportUpdateHandler(
                             pContext->pTransport,
                             pContext->TransportEvent,
                             pContext->pTransport->pProviderInfo);

                if (!NT_SUCCESS(Status)) {
                }
            }
        }

        // Derefrence the transport entry
        RxCeDereferenceTransport(pContext->pTransport);

        // free the notification context.
        RxFreePool(pContext);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\rxpnp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpnp.c

Abstract:

    This module implements the PNP notification handling routines for RDBSS

Revision History:

    Balan Sethu Raman     [SethuR]    10-Apr-1996

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#include "tdikrnl.h"

HANDLE RxTdiNotificationHandle;

VOID
RxTdiBindTransportCallback(
    IN PUNICODE_STRING DeviceName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    DeviceName - the name of the newly created device object

--*/
{
   RX_BINDING_CONTEXT   BindingContext;

   BindingContext.pTransportName   = DeviceName;
   BindingContext.QualityOfService = 65534;

   //DbgPrint("$$$$$ Bind for transport %ws\n",DeviceName->Buffer);
   RxCeBindToTransport(&BindingContext);
}

VOID
RxTdiUnbindTransportCallback(
    IN PUNICODE_STRING DeviceName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport deletes a device object

Arguments:

    DeviceName = the name of the deleted device object

--*/
{
   RX_BINDING_CONTEXT   BindingContext;

   BindingContext.pTransportName   = DeviceName;

   RxCeUnbindFromTransport(&BindingContext);
}

NTSTATUS
RxRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if( RxTdiNotificationHandle == NULL ) {

        status = TdiRegisterNotificationHandler (
                                        RxTdiBindTransportCallback,
                                        RxTdiUnbindTransportCallback,
                                        &RxTdiNotificationHandle );
    }

    return status;
}

NTSTATUS
RxDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if( RxTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterNotificationHandler( RxTdiNotificationHandle );
        if( NT_SUCCESS( Status ) ) {
            RxTdiNotificationHandle = NULL;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\rxtdip.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrxce.h

Abstract:

    This module contains the NT implementation related includes for the RxCe.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:


--*/

#ifndef _RXTDIP_H_
#define _RXTDIP_H_

typedef struct _RXTDI_REQUEST_COMPLETION_CONTEXT_ {
   PVOID                   pEventContext;
   PRXCE_VC                pVc;                    // VC Handle for connections
   PMDL                    pPartialMdl;            // the partial Mdl that was built for Xmit
   PVOID                   pCompletionContext;     // the callback context
   union {
      PRXCE_IND_SEND_COMPLETE            SendCompletionHandler;         // for datagrams
      PRXCE_IND_CONNECTION_SEND_COMPLETE ConnectionSendCompletionHandler; // for VC sends
   };
} RXTDI_REQUEST_COMPLETION_CONTEXT, *PRXTDI_REQUEST_COMPLETION_CONTEXT;

PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

#define RxCeAllocateIrp(StackSize,ChargeQuota) \
        RxCeAllocateIrpWithMDL(StackSize,ChargeQuota,NULL)

extern
VOID RxCeFreeIrp(PIRP pIrp);

extern
NTSTATUS RxTdiRequestCompletion(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context);

extern
NTSTATUS RxTdiAsynchronousRequestCompletion(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP           Irp,
               IN PVOID          Context);

extern NTSTATUS
RxTdiSendPossibleEventHandler (
    IN PVOID EventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

extern NTSTATUS
BuildEaBuffer (
    IN  ULONG                     EaNameLength,
    IN  PVOID                     pEaName,
    IN  ULONG                     EaValueLength,
    IN  PVOID                     pEaValue,
    OUT PFILE_FULL_EA_INFORMATION *pEaBuffer,
    OUT PULONG                    pEaBufferLength
    );


extern NTSTATUS
RxCeSubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

extern NTSTATUS
RxCeSubmitAsynchronousTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext
    );

//
// TDI event handler extern definitions
//

extern
NTSTATUS
RxTdiConnectEventHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

extern NTSTATUS
RxTdiDisconnectEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              DisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              DisconnectInformation,
    IN ULONG              DisconnectFlags
    );

extern NTSTATUS
RxTdiErrorEventHandler(
    IN PVOID    TdiEventContext,
    IN NTSTATUS Status                // status code indicating error type.
    );


extern NTSTATUS
RxTdiReceiveEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *BytesTaken,
    IN PVOID              Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP              *IoRequestPacket   // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
RxTdiReceiveDatagramEventHandler(
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *pIrp                  // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
RxTdiReceiveExpeditedEventHandler(
    IN PVOID               EventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG               ReceiveFlags,          //
    IN ULONG               BytesIndicated,        // number of bytes in this indication
    IN ULONG               BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG              *BytesTaken,          // number of bytes used by indication routine
    IN PVOID               Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

// Initialization routines

extern NTSTATUS
InitializeMiniRedirectorNotifier();

#endif // _RXTDIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\rxtdi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT TDI related routines used by RXCE. The wrappers are necessary to
    ensure that all the OS dependencies can be localized to select modules like this for
    customization.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:


--*/

#include "precomp.h"
#pragma  hdrstop
#include "tdikrnl.h"
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCETDI)

LARGE_INTEGER ConnectionTimeOut = {0,0};

#define CANCELLED_CONNECT_IRP IntToPtr(0xffffffff)

#if DBG
void
DbgDumpTransportAddress(
    PWSTR RoutineName,
    PRXCE_TRANSPORT  pTransport,
    PTRANSPORT_ADDRESS pTA
    );
#else
#define DbgDumpTransportAddress( r, t, a )
#endif

// Once a valid handle to a transport device object has been obtained subsequent
// opens to the same device object can be opened with a NULL relative name to
// this handle. This has two beneficial side effects --- one it is fast since
// we do not have to go through the object manager's logic for parsing names and
// in remote boot scenarios it minimizes the footprint that needs to be locked
// down.

UNICODE_STRING RelativeName = { 0,0,NULL};

NTSTATUS
RxTdiBindToTransport(
    IN OUT PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine binds to the transport specified.

Arguments:

    pTransport       - the transport structure to be initialized

    pRxBindingContext - the binding context containing a pointer to the
                        transport name and the quality of service for NT.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ChannelAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    RxProfile(RxTdi,RxTdiBindToTransport);

    InitializeObjectAttributes(
        &ChannelAttributes,       // Tdi Control Channel attributes
        &pTransport->Name,        // Name
        OBJ_CASE_INSENSITIVE,     // Attributes
        NULL,                     // RootDirectory
        NULL);                    // SecurityDescriptor

    Status = ZwCreateFile(
                 &pTransport->ControlChannel,                 // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &ChannelAttributes,                         // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 NULL,                                       // EA Buffer
                 0);                                         // EA length

    if (NT_SUCCESS(Status)) {
        //  Obtain a referenced pointer to the file object.
        Status = ObReferenceObjectByHandle(
                     pTransport->ControlChannel,                     // Object Handle
                     FILE_ANY_ACCESS,                                // Desired Access
                     NULL,                                           // Object Type
                     KernelMode,                                     // Processor mode
                     (PVOID *)&pTransport->pControlChannelFileObject,// Object pointer
                     NULL);                                          // Object Handle information

        if (NT_SUCCESS(Status)) {
            PIRP pIrp = NULL;

            // Obtain the related device object.
            pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

            pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

            if (pIrp != NULL) {
                PMDL pMdl;

                // Obtain the provider information from the specified transport.
                ASSERT(pTransport->pProviderInfo != NULL);
                pMdl = RxAllocateMdl(
                           pTransport->pProviderInfo,           // Virtual address for MDL construction
                           sizeof( RXCE_TRANSPORT_PROVIDER_INFO));        // size of the buffer

                if ( pMdl != NULL ) {
                    try {
                        MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        IoFreeMdl( pMdl );
                        Status = GetExceptionCode();
                    }

                    if (Status == STATUS_SUCCESS) {
                        TdiBuildQueryInformation(
                            pIrp,
                            pTransport->pDeviceObject,
                            pTransport->pControlChannelFileObject,
                            RxTdiRequestCompletion,                // Completion routine
                            NULL,                                  // Completion context
                            TDI_QUERY_PROVIDER_INFO,
                            pMdl);

                        Status = RxCeSubmitTdiRequest(
                                     pTransport->pDeviceObject,
                                     pIrp);

                        MmUnlockPages(pMdl);
                        IoFreeMdl(pMdl);
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                RxCeFreeIrp(pIrp);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return Status;
}

NTSTATUS
RxTdiUnbindFromTransport(
    IN OUT PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine unbinds to the transport specified.

Arguments:

    pTransport - the transport structure


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;

    RxProfile(RxTdi,RxTdiUnbindFromTransport);

    // Dereference the control channel file object.
    if (pTransport->pControlChannelFileObject != NULL) {
        ObDereferenceObject(pTransport->pControlChannelFileObject);
    }

    // Close the control channel
    if (pTransport->ControlChannel != INVALID_HANDLE_VALUE) {
        Status = ZwClose(pTransport->ControlChannel);
    }

    pTransport->pControlChannelFileObject = NULL;
    pTransport->ControlChannel = INVALID_HANDLE_VALUE;

    return Status;
}


NTSTATUS
RxTdiOpenAddress(
    IN     PRXCE_TRANSPORT    pTransport,
    IN     PTRANSPORT_ADDRESS pTransportAddress,
    IN OUT PRXCE_ADDRESS      pAddress)
/*++

Routine Description:

    This routine opens an address object.

Arguments:


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    ULONG TransportAddressLength;
    ULONG TransportEaBufferLength;

    PFILE_FULL_EA_INFORMATION pTransportAddressEa;

    RxProfile(RxTdi,RxTdiOpenAddress);

    TransportAddressLength = ComputeTransportAddressLength(pTransportAddress);

    // Build an EA buffer for the specified transport address
    Status = BuildEaBuffer(
                 TDI_TRANSPORT_ADDRESS_LENGTH,
                 TdiTransportAddress,
                 TransportAddressLength,
                 pTransportAddress,
                 &pTransportAddressEa,
                 &TransportEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeObjectAttributes(
        &AddressAttributes,         // OBJECT_ATTRIBUTES instance
        &RelativeName,                       // Name
        0,                          // Attributes
        pTransport->ControlChannel, // RootDirectory
        NULL);                      // SecurityDescriptor

    Status = ZwCreateFile(
                 &pAddress->hAddress,                         // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &AddressAttributes,                         // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pTransportAddressEa,                        // EA Buffer
                 TransportEaBufferLength);                   // EA length

    if (NT_SUCCESS(Status)) {
        //  Obtain a referenced pointer to the file object.
        Status = ObReferenceObjectByHandle (
                     pAddress->hAddress,              // Object Handle
                     FILE_ANY_ACCESS,                 // Desired Access
                     NULL,                            // Object Type
                     KernelMode,                      // Processor mode
                     (PVOID *)&pAddress->pFileObject, // Object pointer
                     NULL);                           // Object Handle information

        Status = RxTdiSetEventHandlers(pTransport,pAddress);

        //DbgPrint("RDR opened address %lx\n", pAddress->hAddress);
    }

    // Free up the EA buffer allocated.
    RxFreePool(pTransportAddressEa);

    RxDbgTrace(0, Dbg,("RxTdiOpenAddress returns %lx\n",Status));
    return Status;
}

NTSTATUS
RxTdiSetEventHandlers(
    PRXCE_TRANSPORT pTransport,
    PRXCE_ADDRESS   pRxCeAddress)
/*++

Routine Description:

    This routine establishes the event handlers for a given address.

Arguments:

    pRxCeAddress - the address object


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS        Status;
    PIRP pIrp;

    RxProfile(RxTdi,RxTdiSetEventHandlers);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // The event handlers need to be set one at a time.
    do {
        // Connect Event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_CONNECT,
            RxTdiConnectEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Disconnect event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_DISCONNECT,
            RxTdiDisconnectEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Error event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_ERROR,
            RxTdiErrorEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Receive Event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE,
            RxTdiReceiveEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

#if 0
        // Receive datagram event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE_DATAGRAM,
            RxTdiReceiveDatagramEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }
#endif

        // Receieve expedited event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE_EXPEDITED,
            RxTdiReceiveExpeditedEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }
#if 0
        // Send possible event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_SEND_POSSIBLE,
            RxTdiSendPossibleEventHandler,
            RxCeGetAddressHandle(pRxCeAddress));

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);
#endif
        if (NT_SUCCESS(Status)) {
            // All the event handlers have been successfully set.
            break;
        }
    } while (NT_SUCCESS(Status));

    // Free the Irp
    RxCeFreeIrp(pIrp);

    return Status;
}

NTSTATUS
RxTdiConnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN OUT PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the RxCe virtual circuit instance.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS                     Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES            VcAttributes;
    IO_STATUS_BLOCK              IoStatusBlock;
    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;

    ULONG ConnectionContextEaBufferLength;

    PFILE_FULL_EA_INFORMATION pConnectionContextEa;

    RxProfile(RxTdi,RxTdiConnect);

#if DBG
    {
        PTRANSPORT_ADDRESS pTA =
            (PTRANSPORT_ADDRESS)(pConnection->pConnectionInformation->RemoteAddress);
        RxDbgTrace(0, Dbg,("RxTdiConnect to %wZ address length %d type %d\n",
                           &(pTransport->Name),
                           pTA->Address[0].AddressLength,
                           pTA->Address[0].AddressType ));
    }
#endif

    // Build an EA buffer for the specified connection context
    Status = BuildEaBuffer(
                 TDI_CONNECTION_CONTEXT_LENGTH,
                 TdiConnectionContext,
                 sizeof(PRXCE_VC),
                 &pVc,
                 &pConnectionContextEa,
                 &ConnectionContextEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    // Open the local connection endpoint.
    InitializeObjectAttributes(
        &VcAttributes,              // OBJECT_ATTRIBUTES instance
        &RelativeName,                       // Name
        0,                          // Attributes
        pTransport->ControlChannel, // RootDirectory
        NULL);                      // SecurityDescriptor

    Status = ZwCreateFile(
                 &pVc->hEndpoint,                             // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &VcAttributes,                              // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pConnectionContextEa,                       // EA Buffer
                 ConnectionContextEaBufferLength);           // EA length

    if (NT_SUCCESS(Status)) {
        PIRP pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            //  Obtain a referenced pointer to the file object.
            Status = ObReferenceObjectByHandle (
                         pVc->hEndpoint,                  // Object Handle
                         FILE_ANY_ACCESS,                 // Desired Access
                         NULL,                            // Object Type
                         KernelMode,                      // Processor mode
                         (PVOID *)&pVc->pEndpointFileObject,  // Object pointer
                         NULL);                           // Object Handle information

            if (NT_SUCCESS(Status)) {
                // Associate the local endpoint with the address object.
                TdiBuildAssociateAddress(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    NULL,
                    NULL,
                    pAddress->hAddress);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if (NT_SUCCESS(Status)) {
                    // issue the connect request to the underlying transport provider.
                    TdiBuildConnect(
                        pIrp,
                        pTransport->pDeviceObject,
                        pVc->pEndpointFileObject,
                        NULL,
                        NULL,
                        &ConnectionTimeOut,
                        pConnection->pConnectionInformation,
                        pReturnConnectionInformation);

                    Status = RxCeSubmitTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    if (!NT_SUCCESS(Status)) {
                        // Disassociate address from the connection since the connect request was
                        // not successful.
                        NTSTATUS LocalStatus;

                        TdiBuildDisassociateAddress(
                            pIrp,
                            pTransport->pDeviceObject,
                            pVc->pEndpointFileObject,
                            NULL,
                            NULL);

                        LocalStatus = RxCeSubmitTdiRequest(
                                          pTransport->pDeviceObject,
                                          pIrp);
                    } else {
                        // The associate address was not successful.
                        RxDbgTrace(0, Dbg,("TDI connect returned %lx\n",Status));
                    }
                } else {
                    // The associate address was not successful.
                    RxDbgTrace(0, Dbg,("TDI associate address returned %lx\n",Status));
                }

                if (!NT_SUCCESS(Status)) {
                    // Dereference the endpoint file object.
                    ObDereferenceObject(pVc->pEndpointFileObject);
                }
            } else {
                // error obtaining the file object for the connection.
                RxDbgTrace(0, Dbg,("error referencing endpoint file object %lx\n",Status));
            }

            RxCeFreeIrp(pIrp);

            if (!NT_SUCCESS(Status)) {
                // Close the endpoint file object handle
                ZwClose(pVc->hEndpoint);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        // error creating the connection object
        RxDbgTrace(0, Dbg,("Connection object(ZwCreate) returned %lx\n",Status));
    }

    if (!NT_SUCCESS(Status)) {
        pVc->hEndpoint = INVALID_HANDLE_VALUE;
        pVc->pEndpointFileObject = NULL;
    }

    RxFreePool(pConnectionContextEa);

    return Status;
}

NTSTATUS
RxTdiDereferenceAndFreeIrp(
     IN PULONG IrpRefCount,
     IN PIRP pIrp)
/*++

Routine Description:

    This routine dereference the connect Irp and free it if ref count reaches 0

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(IrpRefCount);

    if (RefCount == 0) {
        RxCeFreeIrp(pIrp);
        RxFreePool(IrpRefCount);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxTdiAsynchronousConnectCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context)
/*++

Routine Description:

    This routine completes an asynchronous connect request.

Arguments:

    pDeviceObject - the device object

    pIrp          - the IRp

    Context       - the completion context

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    PULONG IrpRefCount = NULL;
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters;

    RxDbgTrace(0, Dbg,("RxTdiAsynchronousConnectCompletion, irp 0x%x, status 0x%x\n",
                       pIrp, pIrp->IoStatus.Status));

    pParameters = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)Context;

    pParameters->CallOutStatus = pIrp->IoStatus.Status;
    IrpRefCount = pParameters->IrpRefCount;

    RxWmiLogError(pParameters->CallOutStatus,
                  LOG,
                  RxTdiAsynchronousConnectCompletion,
                  LOGULONG(pParameters->CallOutStatus)
                  LOGUSTR(pParameters->Connection.pAddress->pTransport->Name));

    if (pParameters->pCallOutContext != NULL) {
        pParameters->pCallOutContext->pRxCallOutCompletion(
            (PRX_CALLOUT_PARAMETERS_BLOCK)pParameters);
    }

    // Free the IRP.
    RxTdiDereferenceAndFreeIrp(IrpRefCount,pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
RxTdiCancelAsynchronousConnect(
     IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine cancels a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_CANCELLED - if the call was successfull.

--*/
{
    KIRQL OldIrql;
    PIRP pIrp = NULL;
    PULONG IrpRefCount = NULL;
    BOOLEAN ShouldCancel = FALSE;
    NTSTATUS Status = STATUS_PENDING;

    KeAcquireSpinLock(&pParameters->pCallOutContext->SpinLock,&OldIrql);

    pIrp = InterlockedExchangePointer(
           &pParameters->pConnectIrp,
           CANCELLED_CONNECT_IRP);

    if ((pIrp != NULL) && (pIrp != CANCELLED_CONNECT_IRP)) {
        IrpRefCount = pParameters->IrpRefCount;
        (*IrpRefCount) ++;
        ShouldCancel = TRUE;
    }

    KeReleaseSpinLock(&pParameters->pCallOutContext->SpinLock,OldIrql);

    if (ShouldCancel) {
        if (IoCancelIrp(pIrp)) {
            Status = STATUS_CANCELLED;
        }

        RxTdiDereferenceAndFreeIrp(IrpRefCount,pIrp);
    }

    return Status;
}

NTSTATUS
RxTdiCleanupAsynchronousConnect(
    IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine disconnects all failed requests when asynchronous connection attempts
    are made.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP     pIrp;

    PRXCE_CONNECTION pConnection;
    PRXCE_VC         pVc;

    RxProfile(RxTdi,RxTdiConnect);

    pConnection = &pParameters->Connection;
    pVc         = &pParameters->Vc;

    RxProfile(RxTdi,RxTdiDisconnect);

    if (pVc->pEndpointFileObject != NULL) {
        PDEVICE_OBJECT pDeviceObject;

        pDeviceObject = IoGetRelatedDeviceObject(pVc->pEndpointFileObject);

        pIrp = RxCeAllocateIrp(pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            TdiBuildDisassociateAddress(
                pIrp,
                pDeviceObject,
                pVc->pEndpointFileObject,
                NULL,
                NULL);

            Status = RxCeSubmitTdiRequest(
                         pDeviceObject,
                         pIrp);

            if (Status != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disassociate returned %lx\n",Status));
            }

            if (pParameters->CallOutStatus == STATUS_SUCCESS) {
                // Build the disconnect request to the underlying transport driver
                TdiBuildDisconnect(
                    pIrp,                                // the IRP
                    pDeviceObject,                       // the device object
                    pVc->pEndpointFileObject,            // the connection (VC) file object
                    NULL,                                // Completion routine
                    NULL,                                // completion context
                    NULL,                                // time
                    RXCE_DISCONNECT_ABORT,                     // disconnect options
                    pConnection->pConnectionInformation, // disconnect request connection information
                    NULL);                               // disconnect return connection information

                Status = RxCeSubmitTdiRequest(
                             pDeviceObject,
                             pIrp);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disconnect returned %lx\n",Status));
                }
            }

            RxCeFreeIrp(pIrp);
        }

        // Dereference the endpoint file object.
        ObDereferenceObject(pVc->pEndpointFileObject);

        // Close the endpoint file object handle
        ZwClose(pVc->hEndpoint);

        pVc->pEndpointFileObject = NULL;
        pVc->hEndpoint = INVALID_HANDLE_VALUE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RxTdiInitiateAsynchronousConnect(
     IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT     pTransport;
    PRXCE_ADDRESS       pAddress;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;

    OBJECT_ATTRIBUTES   VcAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                pIrp = NULL;

    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;

    PFILE_FULL_EA_INFORMATION pConnectionContextEa;
    ULONG ConnectionContextEaBufferLength;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT pContext;

    RxProfile(RxTdi,RxTdiConnect);

    pConnection = &pParameters->Connection;
    pVc         = &pParameters->Vc;

    pVc->hEndpoint = INVALID_HANDLE_VALUE;
    pVc->pEndpointFileObject = NULL;

    if (pParameters->pConnectIrp ==  CANCELLED_CONNECT_IRP) {
        return STATUS_CANCELLED;
    }

    pParameters->IrpRefCount = (PULONG)RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            sizeof(ULONG),
                                            RXCE_CONNECTION_POOLTAG);

    if (pParameters->IrpRefCount == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *(pParameters->IrpRefCount) = 1;

    pContext = (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)pParameters->pCallOutContext;

    pAddress    = pConnection->pAddress;
    pTransport  = pAddress->pTransport;

    DbgDumpTransportAddress(
        L"RxInitiateAsynchronousConnect",
        pTransport,
        (PTRANSPORT_ADDRESS)(pConnection->pConnectionInformation->RemoteAddress)
        );

    // Build an EA buffer for the specified connection context
    Status = BuildEaBuffer(
                 TDI_CONNECTION_CONTEXT_LENGTH,
                 TdiConnectionContext,
                 sizeof(PRXCE_VC),
                 &pContext->pConnectionContext,
                 &pConnectionContextEa,
                 &ConnectionContextEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        if (pParameters->IrpRefCount != NULL) {
            RxFreePool(pParameters->IrpRefCount);
            pParameters->IrpRefCount = NULL;
        }

        return Status;
    }

    // Open the local connection endpoint.
    InitializeObjectAttributes(
        &VcAttributes,                  // OBJECT_ATTRIBUTES instance
        &RelativeName,                           // Name
        0,                              // Attributes
        pTransport->ControlChannel,     // RootDirectory
        NULL);                          // SecurityDescriptor

    Status = ZwCreateFile(
                 &pVc->hEndpoint,                             // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &VcAttributes,                              // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pConnectionContextEa,                       // EA Buffer
                 ConnectionContextEaBufferLength);           // EA length

    // Free the connection context ea buffer.
    RxFreePool(pConnectionContextEa);

    if (NT_SUCCESS(Status)) {
        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            //  Obtain a referenced pointer to the file object.
            Status = ObReferenceObjectByHandle (
                         pVc->hEndpoint,                  // Object Handle
                         FILE_ANY_ACCESS,                 // Desired Access
                         NULL,                            // Object Type
                         KernelMode,                      // Processor mode
                         (PVOID *)&pVc->pEndpointFileObject,  // Object pointer
                         NULL);                           // Object Handle information

            if (NT_SUCCESS(Status)) {
                // Associate the local endpoint with the address object.
                TdiBuildAssociateAddress(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    NULL,
                    NULL,
                    pAddress->hAddress);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if (NT_SUCCESS(Status)) {
                    // issue the connect request to the underlying transport provider.
                    TdiBuildConnect(
                        pIrp,
                        pTransport->pDeviceObject,
                        pVc->pEndpointFileObject,
                        NULL,
                        NULL,
                        &ConnectionTimeOut,
                        pConnection->pConnectionInformation,
                        pReturnConnectionInformation);

                    IoSetCompletionRoutine(
                        pIrp,                                // The IRP
                        RxTdiAsynchronousConnectCompletion,  // The completion routine
                        pParameters,                     // The completion context
                        TRUE,                                // Invoke On Success
                        TRUE,                                // Invoke On Error
                        TRUE);                               // Invoke On Cancel

                    InterlockedExchangePointer(
                        &pParameters->pConnectIrp,
                        pIrp);

                    //  Submit the request
                    Status = IoCallDriver(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0,Dbg,("RxTdiAsynchronousConnect: Connect IRP initiation failed, irp %lx, status 0x%x\n",pIrp, Status));
                    }
                    Status = STATUS_PENDING;
                } else {
                    // The associate address was not successful.
                    RxDbgTrace(0, Dbg,("TDI associate address returned %lx\n",Status));
                }
            } else {
                // error obtaining the file object for the connection.
                RxDbgTrace(0, Dbg,("error referencing endpoint file object %lx\n",Status));
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_PENDING) {
            if (pIrp != NULL) {
                RxCeFreeIrp(pIrp);
            }

            if (pParameters->IrpRefCount != NULL) {
                RxFreePool(pParameters->IrpRefCount);
            }

            if (pVc->pEndpointFileObject != NULL) {
                ObDereferenceObject(pVc->pEndpointFileObject);
                pVc->pEndpointFileObject = NULL;
            }

            if (pVc->hEndpoint != INVALID_HANDLE_VALUE) {
                // Close the endpoint file object handle
                ZwClose(pVc->hEndpoint);
                pVc->hEndpoint = INVALID_HANDLE_VALUE;
            }
        }
    } else {
        // error creating the connection object
        RxDbgTrace(0, Dbg,("Connection object(ZwCreate) returned %lx\n",Status));

        if (pParameters->IrpRefCount != NULL) {
            RxFreePool(pParameters->IrpRefCount);
            pParameters->IrpRefCount = NULL;
        }
    }

    return Status;
}

NTSTATUS
RxTdiReconnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN OUT PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the RxCe virtual circuit instance.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status;

    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;
    PIRP     pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    RxProfile(RxTdi,RxTdiReconnect);

    ASSERT(pVc->State == RXCE_VC_DISCONNECTED);

    if (pIrp != NULL) {
        // issue the connect request to the underlying transport provider.
        TdiBuildConnect(
            pIrp,
            pTransport->pDeviceObject,
            pVc->pEndpointFileObject,
            NULL,
            NULL,
            &ConnectionTimeOut,
            pConnection->pConnectionInformation,
            pReturnConnectionInformation);

        Status = RxCeSubmitTdiRequest(
                     pTransport->pDeviceObject,
                     pIrp);

        if (NT_SUCCESS(Status)) {
            InterlockedExchange(
                &pVc->State,
                RXCE_VC_ACTIVE);
        } else {
            // The reconnect request was not successful
            RxDbgTrace(0, Dbg,("RxTdiReconnect: TDI connect returned %lx\n",Status));
        }

        RxCeFreeIrp(pIrp);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxTdiDisconnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            DisconnectFlags)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnection - the connection

    pVc    - the virtual circuit to be disconnected.

    DisconnectFlags - DisconnectOptions

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS        Status;
    PIRP pIrp;

    RxProfile(RxTdi,RxTdiDisconnect);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TdiBuildDisassociateAddress(
        pIrp,
        pTransport->pDeviceObject,
        pVc->pEndpointFileObject,
        NULL,
        NULL);

    Status = RxCeSubmitTdiRequest(
                 pTransport->pDeviceObject,
                 pIrp);

    if (NT_SUCCESS(Status)) {
        // Build the disconnect request to the underlying transport driver
        TdiBuildDisconnect(
            pIrp,                                // the IRP
            pTransport->pDeviceObject,           // the device object
            pVc->pEndpointFileObject,            // the connection (VC) file object
            NULL,                                // Completion routine
            NULL,                                // completion context
            NULL,                                // time
            DisconnectFlags,                     // disconnect options
            pConnection->pConnectionInformation, // disconnect request connection information
            NULL);                               // disconnect return connection information

        Status = RxCeSubmitTdiRequest(
                     pTransport->pDeviceObject,
                     pIrp);

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disconnect returned %lx\n",Status));
        }
    } else {
        RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disassociate returned %lx\n",Status));
    }

    RxCeFreeIrp(pIrp);

    return STATUS_SUCCESS;
}

NTSTATUS
RxTdiCloseAddress(
    IN OUT PRXCE_ADDRESS   pAddress)
/*++

Routine Description:

    This routine closes the address object.

Arguments:

    pRxCeAddress - the address object to be closed


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Dereference the file object.
    if (pAddress->pFileObject != NULL) {
        ObDereferenceObject(pAddress->pFileObject);
    }

    // Close the address file object handle
    ZwClose(pAddress->hAddress);
    //DbgPrint("RDR closed address %lx\n", pAddress->hAddress);

    return Status;
}


NTSTATUS
RxTdiQueryInformation(
    IN  PRXCE_TRANSPORT  pTransport,
    IN  PRXCE_ADDRESS    pAddress,
    IN  PRXCE_CONNECTION pConnection,
    IN  PRXCE_VC         pVc,
    IN  ULONG            QueryType,
    IN  PVOID            pQueryBuffer,
    IN  ULONG            QueryBufferLength)
/*++

Routine Description:

    This routine queries the information w.r.t a connection

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the VC instance

    QueryType          - the class of information desired

    pQueryBuffer       - the buffer in whihc the data is to be returned

    QueryBufferLength  - the query buffer length.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PIRP      pIrp = NULL;

    // Obtain the related device object.
    pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp != NULL) {
        PMDL pMdl;
        pMdl = RxAllocateMdl(
                   pQueryBuffer,                        // Virtual address for MDL construction
                   QueryBufferLength);                  // size of the buffer

        if ( pMdl != NULL ) {
            try {
                MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                IoFreeMdl( pMdl );
                Status = GetExceptionCode();
            }

            if (Status == STATUS_SUCCESS) {
                // Get the file object associated with trhe connection.

                TdiBuildQueryInformation(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    RxTdiRequestCompletion,           // Completion routine
                    NULL,                                  // Completion context
                    QueryType,
                    pMdl);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        RxCeFreeIrp(pIrp);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxTdiQueryAdapterStatus(
    IN  PRXCE_TRANSPORT  pTransport,
    IN  PADAPTER_STATUS  pAdapterStatus)
/*++

Routine Description:

    This routine queries the information w.r.t a connection

Arguments:

    pTransport         - the associated transport

    pAdapterStatus     - ADAPTER STATUS structure

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PIRP      pIrp = NULL;

    if (pTransport->pControlChannelFileObject != NULL) {
        // Obtain the related device object.
        pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            PMDL pMdl;
            pMdl = RxAllocateMdl(
                       pAdapterStatus,                        // Virtual address for MDL construction
                       sizeof(ADAPTER_STATUS));               // size of the buffer

            if ( pMdl != NULL ) {
                try {
                    MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    IoFreeMdl( pMdl );
                    Status = GetExceptionCode();
                }

                if (NT_SUCCESS(Status)) {
                    // Get the file object associated with the connection.
                    TdiBuildQueryInformation(
                        pIrp,
                        pTransport->pDeviceObject,
                        pTransport->pControlChannelFileObject,
                        NULL,                             // Completion routine
                        NULL,                             // Completion context
                        TDI_QUERY_ADAPTER_STATUS,
                        pMdl);

                    Status = RxCeSubmitTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    MmUnlockPages(pMdl);
                    IoFreeMdl(pMdl);
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            RxCeFreeIrp(pIrp);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_ADDRESS_NOT_ASSOCIATED;
    }

    return Status;
}

NTSTATUS
RxTdiSend(
    IN PRXCE_TRANSPORT   pTransport,
    IN PRXCE_ADDRESS     pAddress,
    IN PRXCE_CONNECTION  pConnection,
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnection - the connection

    pVc    - the virtual circuit to be disconnected.

    SendOptions - the options for transmitting the data

    pMdl        - the buffer to be transmitted.

    SendLength  - length of data to be transmitted

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMDL     pPartialMdl  = NULL;
    ULONG    MdlByteCount = MmGetMdlByteCount(pMdl);
    PVOID    pMdlAddress  = MmGetMdlVirtualAddress(pMdl);

    ULONG    TdiOptions      = (~RXCE_FLAGS_MASK & SendOptions);
    BOOLEAN  SynchronousSend = ((SendOptions & RXCE_SEND_SYNCHRONOUS) != 0);

    RxProfile(RxTdi,RxTdiSend);

    ASSERT(pMdl->MdlFlags & (MDL_PAGES_LOCKED|MDL_SOURCE_IS_NONPAGED_POOL|MDL_PARTIAL));

    if (SendOptions & RXCE_SEND_PARTIAL) {
        if (MdlByteCount > SendLength) {
            pPartialMdl = IoAllocateMdl(pMdlAddress,SendLength,FALSE,FALSE,NULL);

            if (pPartialMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxBuildPartialHeaderMdl(pMdl,pPartialMdl,pMdlAddress,SendLength);
            }
        } else if (MdlByteCount == SendLength) {
            // No need to build a partial MDL, reuse the MDl
            pPartialMdl = pMdl;
        } else {
            ASSERT(!"MdlByteCount > SendLength");
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        pPartialMdl = pMdl;
    }

    if (NT_SUCCESS(Status)) {
        PIRP                              pIrp = NULL;
        PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext = NULL;

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            // Build the Send request to the underlying transport driver
            TdiBuildSend(
                pIrp,                                // the IRP
                pTransport->pDeviceObject,           // the device object
                pVc->pEndpointFileObject,            // the connection (VC) file object
                NULL,                                // Completion routine
                NULL,                                // completion context
                pPartialMdl,                         // the data buffer
                TdiOptions,                          // send flags
                SendLength);                         // send buffer length

            if (SynchronousSend) {
                // Synchronous Send Request
                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if ((pConnection->pHandler != NULL) &&
                    (pConnection->pHandler->RxCeSendCompleteEventHandler != NULL)) {

                    (pConnection->pHandler->RxCeSendCompleteEventHandler)(
                        pConnection->pContext,
                        pVc,
                        pCompletionContext,
                        pIrp->IoStatus.Status);
                }
            } else {
                // Aysnchronous Send Request
                // CODE.IMPROVEMENT The assertion needs to be strengthened after
                // max command enfocement is in place.
                // (pCompletionContext != NULL) &&    // the caller provided a valid context
                ASSERT((pConnection->pHandler != NULL) && // the connection has a handler
                       (pConnection->pHandler->RxCeSendCompleteEventHandler != NULL));

                pRequestContext = (PRXTDI_REQUEST_COMPLETION_CONTEXT)
                                  RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXTDI_REQUEST_COMPLETION_CONTEXT),
                                     RXCE_TDI_POOLTAG);

                if (pRequestContext != NULL) {
                    if (pPartialMdl != pMdl) {
                        pRequestContext->pPartialMdl = pPartialMdl;
                    } else {
                        pRequestContext->pPartialMdl = NULL;
                    }

                    pRequestContext->pVc                = pVc;
                    pRequestContext->pCompletionContext = pCompletionContext;

                    pRequestContext->ConnectionSendCompletionHandler = pConnection->pHandler->RxCeSendCompleteEventHandler;
                    pRequestContext->pEventContext                   = pConnection->pContext;

                    Status = RxCeSubmitAsynchronousTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp,
                                 pRequestContext);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {
            // Could not allocate the IRP.
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (SynchronousSend) {
            if (pPartialMdl != pMdl) {
                IoFreeMdl( pPartialMdl );
            }

            if (pRequestContext != NULL) {
                RxFreePool(pRequestContext);
            }

            if (pIrp != NULL) {
                RxCeFreeIrp(pIrp);
            }
        } else {
            if (pIrp != NULL && Status != STATUS_PENDING) {
                DbgPrint("RDBSS AsyncSendReq returned %x %x\n", pIrp,Status);
                //DbgBreakPoint();
            }
        }
    }

    return Status;
}

NTSTATUS
RxTdiSendDatagram(
    IN PRXCE_TRANSPORT              pTransport,
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        Options,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnectionInformation - the remote address

    Options   - the send options.

    pMdl      - the send buffer

    SendLength  - length of data to be sent

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    In the current implementation the SYNCHRONOUS flag is disregarded for sending
    datagrams because the underlying transports do not block on datagram sends.
    Submission of request and completion of request happen simultaneously.

    If a different behaviour is noted for some transports then the code for
    SendDatagrams need to be implemented along the lines of a send.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMDL     pPartialMdl = NULL;
    ULONG    MdlByteCount = MmGetMdlByteCount(pMdl);
    PVOID    pMdlAddress  = MmGetMdlVirtualAddress(pMdl);

    ULONG    TdiOptions      = (~RXCE_FLAGS_MASK & Options);

    RxProfile(RxTdi,RxTdiSendDatagram);

    ASSERT(pMdl->MdlFlags & (MDL_PAGES_LOCKED|MDL_SOURCE_IS_NONPAGED_POOL|MDL_PARTIAL));

    DbgDumpTransportAddress(
        L"RxTdiSendDatagram",
        pTransport,
        (PTRANSPORT_ADDRESS)(pConnectionInformation->RemoteAddress)
        );

    if (Options & RXCE_SEND_PARTIAL) {
        if (MdlByteCount > SendLength) {
            pPartialMdl = IoAllocateMdl(pMdlAddress,SendLength,FALSE,FALSE,NULL);

            if (pPartialMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxBuildPartialHeaderMdl(pMdl,pPartialMdl,pMdlAddress,SendLength);
            }
        } else if (MdlByteCount == SendLength) {
            // No need to build a partial MDL, reuse the MDl
            pPartialMdl = pMdl;
        } else {
            RxDbgTrace(0, Dbg,("Mdl Length - %lx Send Length %lx\n",MdlByteCount,SendLength));
            ASSERT(!"MdlByteCount > SendLength");
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {
        pPartialMdl = pMdl;
    }

    if (NT_SUCCESS(Status)) {
        PIRP pIrp;

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            // Build the disconnect request to the underlying transport driver
            TdiBuildSendDatagram(
                pIrp,                                // the IRP
                pTransport->pDeviceObject,           // the device object
                pAddress->pFileObject,               // the connection (VC) file object
                NULL,                                // Completion routine
                NULL,                                // completion context
                pPartialMdl,                         // the send data buffer
                SendLength,                          // the send data buffer length
                pConnectionInformation);             // remote address information

            Status = RxCeSubmitTdiRequest(
                         pTransport->pDeviceObject,
                         pIrp);

        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ((pAddress->pHandler != NULL) &&
            (pAddress->pHandler->RxCeSendCompleteEventHandler != NULL)) {
            (pAddress->pHandler->RxCeSendCompleteEventHandler)(
                pAddress->pContext,
                pCompletionContext,
                Status);
        }

        if (pIrp != NULL) {
            RxCeFreeIrp(pIrp);
        }

        if ((pPartialMdl != pMdl) && (pPartialMdl != NULL)) {
            IoFreeMdl( pPartialMdl );
        }
    }

    return Status;
}

NTSTATUS
RxTdiRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    RxDbgTrace(0, Dbg, ("CompletionEvent\n"));

    if (Context != NULL)
       KeSetEvent((PKEVENT )Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
RxCeSubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PDevice_OBJECT DeviceObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    NTSTATUS Status;
    KEVENT Event;

    KeInitializeEvent (
        &Event,
        NotificationEvent,
        FALSE);

    IoSetCompletionRoutine(
        pIrp,                         // The IRP
        RxTdiRequestCompletion,  // The completion routine
        &Event,                       // The completion context
        TRUE,                         // Invoke On Success
        TRUE,                         // Invoke On Error
        TRUE);                        // Invoke On Cancel

    //
    //  Submit the request
    //

    RxDbgTrace(0, Dbg,("IoCallDriver(pDeviceObject = %lx)\n",pDeviceObject));
    Status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx) returned %lx\n",pDeviceObject,Status));
    }

    if ((Status == STATUS_PENDING) || (Status == STATUS_SUCCESS)) {

        RxDbgTrace(0, Dbg,("Waiting for Tdi Request Completion ....\n"));

        Status = KeWaitForSingleObject(
                     &Event,     // Object to wait on.
                     Executive,  // Reason for waiting
                     KernelMode, // Processor mode
                     FALSE,      // Alertable
                     NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg,("RxTdiSubmitRequest could not wait Wait returned %lx\n",Status));
            return Status;
        }

        Status = pIrp->IoStatus.Status;
    } else {
        if (!KeReadStateEvent(&Event)) {
            DbgBreakPoint();
        }
    }

    RxDbgTrace(0, Dbg, ("RxCeSubmitTdiRequest returned %lx\n",Status));

    return Status;
}

NTSTATUS
RxTdiAsynchronousRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

   This routine completes an asynchronous send request.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext;

    RxDbgTrace(0, Dbg,("RxTdiAsynchronousRequestCompletion\n"));

    pRequestContext = (PRXTDI_REQUEST_COMPLETION_CONTEXT)Context;

    if (pRequestContext->pPartialMdl != NULL) {
       // Free the partial MDL.
       IoFreeMdl(pRequestContext->pPartialMdl);
    }

    // Invoke the Completion event handler if any.
    if (pRequestContext->pVc == NULL) {
       if (pRequestContext->SendCompletionHandler != NULL) {
          (pRequestContext->SendCompletionHandler)(
                              pRequestContext->pEventContext,
                              pRequestContext->pCompletionContext,
                              pIrp->IoStatus.Status);
       }
    } else {
       if (pRequestContext->ConnectionSendCompletionHandler != NULL) {
          (pRequestContext->ConnectionSendCompletionHandler)(
                              pRequestContext->pEventContext,
                              pRequestContext->pVc,
                              pRequestContext->pCompletionContext,
                              pIrp->IoStatus.Status);
       }
    }

    // Free the IRP.
    RxCeFreeIrp(pIrp);

    // Free the request context
    RxFreePool(pRequestContext);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
RxCeSubmitAsynchronousTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext
    )
/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PDevice_OBJECT DeviceObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    NTSTATUS Status;

    ASSERT(pRequestContext != NULL);

    IoSetCompletionRoutine(
        pIrp,                                // The IRP
        RxTdiAsynchronousRequestCompletion,  // The completion routine
        pRequestContext,                     // The completion context
        TRUE,                                // Invoke On Success
        TRUE,                                // Invoke On Error
        TRUE);                               // Invoke On Cancel

    //
    //  Submit the request
    //

    RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx)\n",pDeviceObject));

    Status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx) returned %lx\n",pDeviceObject,Status));
    }

    RxDbgTrace(0, Dbg, ("RxCeSubmitAsynchronousTdiRequest returned %lx\n",Status));
    return Status;
}

NTSTATUS
BuildEaBuffer (
    IN  ULONG                     EaNameLength,
    IN  PVOID                     pEaName,
    IN  ULONG                     EaValueLength,
    IN  PVOID                     pEaValue,
    OUT PFILE_FULL_EA_INFORMATION *pEaBufferPointer,
    OUT PULONG                    pEaBufferLength
    )
/*++

Routine Description:

   Builds an EA buffer.

Arguments:

    EaNameLength     - Length of the Extended attribute name

    pEaName          - the extended attriute name

    EaValueLength    - Length of the Extended attribute value

    pEaValue         - the extended attribute value

    pBuffer          - the buffer for constructing the EA

--*/

{
   PFILE_FULL_EA_INFORMATION pEaBuffer;
   ULONG Length;

   RxDbgTrace(0, Dbg, ("BuildEaBuffer\n"));

   // Allocate an EA buffer for passing down the transport address
   *pEaBufferLength = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                      EaNameLength + 1 +
                      EaValueLength;

   pEaBuffer = (PFILE_FULL_EA_INFORMATION)
               RxAllocatePoolWithTag(
                    PagedPool,
                    *pEaBufferLength,
                    RXCE_TDI_POOLTAG);

   if (pEaBuffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   *pEaBufferPointer = pEaBuffer;

   pEaBuffer->NextEntryOffset = 0;
   pEaBuffer->Flags           = 0;
   pEaBuffer->EaNameLength    = (UCHAR)EaNameLength;
   pEaBuffer->EaValueLength   = (USHORT)EaValueLength;

   RtlCopyMemory (
        pEaBuffer->EaName,
        pEaName,
        pEaBuffer->EaNameLength + 1);

   RtlCopyMemory(
        &pEaBuffer->EaName[EaNameLength + 1],
        pEaValue,
        EaValueLength);

   return STATUS_SUCCESS;
}

NTSTATUS
RxTdiCancelConnect(
         IN PRXCE_TRANSPORT  pTransport,
         IN PRXCE_ADDRESS    pAddress,
         IN PRXCE_CONNECTION pConnection)
{
   return STATUS_NOT_IMPLEMENTED;
}

#if DBG

void
DbgDumpTransportAddress(
    PWSTR RoutineName,
    PRXCE_TRANSPORT  pTransport,
    PTRANSPORT_ADDRESS pTA
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG i;
    PTA_ADDRESS taa;
    RxDbgTrace(0, Dbg,("%ws on %wZ, address count = %d\n",
                       RoutineName, &(pTransport->Name), pTA->TAAddressCount) );
    taa = pTA->Address;
    for( i = 0; i < (ULONG) pTA->TAAddressCount; i++ ){
        RxDbgTrace(0, Dbg, ("\t%d:Address length %d type %d: ",
                            i, taa->AddressLength, taa->AddressType ));
        switch (taa->AddressType) {
        case TDI_ADDRESS_TYPE_NETBIOS_EX: {
            PTDI_ADDRESS_NETBIOS_EX address = (PTDI_ADDRESS_NETBIOS_EX) taa->Address;
            RxDbgTrace( 0, Dbg, ("Endpoint: \"%16.16s\" type %d name \"%16.16s\"\n",
                                 address->EndpointName,
                                 address->NetbiosAddress.NetbiosNameType,
                                 address->NetbiosAddress.NetbiosName) );
            break;
        }
        case TDI_ADDRESS_TYPE_NETBIOS: {
            PTDI_ADDRESS_NETBIOS address = (PTDI_ADDRESS_NETBIOS) taa->Address;
            RxDbgTrace( 0, Dbg, ("NBType %d name \"%16.16s\"\n",
                                 address->NetbiosNameType,
                                 address->NetbiosName) );
            break;
        }
        case TDI_ADDRESS_TYPE_IP: {
            PTDI_ADDRESS_IP address = (PTDI_ADDRESS_IP) taa->Address;
            RxDbgTrace( 0, Dbg, ("IP port %d addr 0x%x\n", address->sin_port, address->in_addr ) );
            break;
        }
        default: {
            RxDbgTrace( 0, Dbg, ("Unknown!\n") );
        }
        }
        taa = (PTA_ADDRESS) (taa->Address + taa->AddressLength);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\scavengr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This module implements the scavenging routines in RDBSS.


Author:

    Balan Sethu Raman     [SethuR]    9-sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

KMUTEX       RxScavengerMutex;  //only one of these!

VOID
RxScavengerFinalizeEntries(
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

PRDBSS_DEVICE_OBJECT
RxGetDeviceObjectOfInstance (
    PVOID pInstance
    );

VOID
RxScavengerTimerRoutine(
    PVOID pContext); //actually a rxdeviceobject


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxPurgeFobxFromCache)
#pragma alloc_text(PAGE, RxMarkFobxOnCleanup)
#pragma alloc_text(PAGE, RxMarkFobxOnClose)
#pragma alloc_text(PAGE, RxPurgeFobx)
#pragma alloc_text(PAGE, RxInitializePurgeSyncronizationContext)
#pragma alloc_text(PAGE, RxPurgeRelatedFobxs)
#pragma alloc_text(PAGE, RxPurgeAllFobxs)
#pragma alloc_text(PAGE, RxGetDeviceObjectOfInstance)
#pragma alloc_text(PAGE, RxpMarkInstanceForScavengedFinalization)
#pragma alloc_text(PAGE, RxpUndoScavengerFinalizationMarking)
#pragma alloc_text(PAGE, RxScavengeVNetRoots)
#pragma alloc_text(PAGE, RxScavengeRelatedFobxs)
#pragma alloc_text(PAGE, RxScavengeAllFobxs)
#pragma alloc_text(PAGE, RxScavengerFinalizeEntries)
#pragma alloc_text(PAGE, RxScavengerTimerRoutine)
#pragma alloc_text(PAGE, RxTerminateScavenging)
#endif

//
//  Local debug trace level
//

#define Dbg  (DEBUG_TRACE_SCAVENGER)

#ifndef WIN9X
#define RxAcquireFcbScavengerMutex(pFcbScavenger)               \
        RxAcquireScavengerMutex();                              \
        (pFcbScavenger)->State |= RX_SCAVENGER_MUTEX_ACQUIRED

#define RxReleaseFcbScavengerMutex(pFcbScavenger)                  \
        (pFcbScavenger)->State &= ~RX_SCAVENGER_MUTEX_ACQUIRED; \
        RxReleaseScavengerMutex()
#else
#define RxAcquireFcbScavengerMutex(pFcbScavenger)               \
        (pFcbScavenger)->State |= RX_SCAVENGER_MUTEX_ACQUIRED

#define RxReleaseFcbScavengerMutex(pFcbScavenger)                  \
        (pFcbScavenger)->State &= ~RX_SCAVENGER_MUTEX_ACQUIRED

#endif

#define RX_SCAVENGER_FINALIZATION_TIME_INTERVAL (10 * 1000 * 1000 * 10)

extern VOID
RxScavengerTimerRoutine(
    PVOID pContext);

NTSTATUS
RxPurgeFobxFromCache(
    PFOBX   pFobxToBePurged)
/*++

Routine Description:

    This routine purges an FOBX for which a close is pending

Arguments:

    pFobxToBePurged -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    This routine unlike the one that follows does not attempt to force the
    operations from the memory manager. It merely purges the underlying FCB
    from the cache

    The FOBX must have been referenced on entry to this routine and it will
    lose that reference on exit.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFCB pFcbToBePurged = pFobxToBePurged->SrvOpen->Fcb;

    PAGED_CODE();

    ASSERT(pFcbToBePurged != NULL);
    Status = RxAcquireExclusiveFcb(NULL,pFcbToBePurged);

    if (Status == STATUS_SUCCESS) {
        BOOLEAN fResult;

        RxReferenceNetFcb(pFcbToBePurged);

        if (!FlagOn(pFobxToBePurged->Flags,FOBX_FLAG_SRVOPEN_CLOSED) &&
            (pFobxToBePurged->SrvOpen->UncleanFobxCount == 0))  {

            Status = RxPurgeFcbInSystemCache(
                         pFcbToBePurged,
                         NULL,
                         0,
                         FALSE,
                         TRUE);

        } else {
            RxLog(("Skipping Purging %lx\n",pFobxToBePurged));
            RxWmiLog(LOG,
                     RxPurgeFobxFromCache,
                     LOGPTR(pFobxToBePurged));
        }

        RxDereferenceNetFobx(pFobxToBePurged,LHS_ExclusiveLockHeld);

        if ( !RxDereferenceAndFinalizeNetFcb(pFcbToBePurged,NULL,FALSE,FALSE) ) {
            RxReleaseFcb( NULL, pFcbToBePurged );
        }
    } else {
        RxDereferenceNetFobx(pFobxToBePurged,LHS_LockNotHeld);
    }

    return Status;
}

VOID
RxMarkFobxOnCleanup(
    PFOBX    pFobx,
    BOOLEAN  *pNeedPurge)
/*++

Routine Description:

    Thie routine marks a FOBX for special processing on cleanup

Arguments:

    pFobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.

    Only diskfile type fobxs are placed on the delayed-close list.

--*/
{
    PAGED_CODE();

    if (pFobx != NULL) {
        PFCB        pFcb     = pFobx->SrvOpen->Fcb;
        PLIST_ENTRY pListEntry;
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        PRDBSS_SCAVENGER pRdbssScavenger;

        PFOBX       pFobxToBePurged = NULL;

        ASSERT(NodeTypeIsFcb(pFcb));
        RxDeviceObject = pFcb->RxDeviceObject;
        pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

        RxAcquireScavengerMutex();

        if ((NodeType(pFcb) != RDBSS_NTC_STORAGE_TYPE_FILE)
               || (pFcb->VNetRoot->NetRoot->DeviceType != RxDeviceType(DISK)) ) {

            //
            // the markfobxatclose will want to remove this from a list. just fix up
            // the list pointers and get out

            SetFlag(pFobx->Flags,FOBX_FLAG_MARKED_AS_DORMANT);
            InitializeListHead(&pFobx->ClosePendingList);
            pRdbssScavenger->NumberOfDormantFiles++ ;
        } else {
            // Ensure that the limit of dormant files specified for the given server is
            // not exceeded. If the limit will be exceeded pick an entry from the
            // list of files that are currently dormant and purge it.


            ASSERT(pRdbssScavenger->NumberOfDormantFiles >= 0);
            if (pRdbssScavenger->NumberOfDormantFiles >=
                pRdbssScavenger->MaximumNumberOfDormantFiles) {

                // If the number of dormant files exceeds the limit specified for the
                // given server a currently dormant file needs to be picked up for
                // purging.

                pListEntry = pRdbssScavenger->ClosePendingFobxsList.Flink;
                if (pListEntry != &pRdbssScavenger->ClosePendingFobxsList) {
                    pFobxToBePurged = (PFOBX)(CONTAINING_RECORD(
                                          pListEntry,
                                          FOBX,
                                          ClosePendingList));

                    if ((pFobxToBePurged->SrvOpen != NULL) &&
                        (pFobxToBePurged->SrvOpen->Fcb == pFcb)) {

                        // The first FOBX in the close pending list and the one about to be
                        // inserted share the same FCB. Instaed of removing the first one
                        // a purge is forced on the current FOBX. This avoids the resource
                        // release/acquire that would have been required otherwise
                        *pNeedPurge = TRUE;
                        pFobxToBePurged = NULL;
                    } else {
                        RxReferenceNetFobx(pFobxToBePurged);
                    }
                }
            }

            SetFlag(pFobx->Flags,FOBX_FLAG_MARKED_AS_DORMANT);

            InsertTailList(
                &pRdbssScavenger->ClosePendingFobxsList,
                &pFobx->ClosePendingList);

            if (pRdbssScavenger->NumberOfDormantFiles++ == 0) {
                BOOLEAN PostTimerRequest;

                if (pRdbssScavenger->State == RDBSS_SCAVENGER_INACTIVE) {
                    pRdbssScavenger->State = RDBSS_SCAVENGER_DORMANT;
                    PostTimerRequest  = TRUE;
                } else {
                    PostTimerRequest = FALSE;
                }

                if (PostTimerRequest) {
                    LARGE_INTEGER TimeInterval;

                    // Post a one shot timer request for scheduling the scavenger after a
                    // predetermined amount of time.

                    TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

                    RxPostOneShotTimerRequest(
                        RxFileSystemDeviceObject,
                        &pRdbssScavenger->WorkItem,
                        RxScavengerTimerRoutine,
                        RxDeviceObject,
                        TimeInterval);
                }
            }
        }

        RxReleaseScavengerMutex();

        if (pFobxToBePurged != NULL) {
            NTSTATUS Status;

            Status = RxPurgeFobxFromCache(pFobxToBePurged);

            if (Status != STATUS_SUCCESS) {
                *pNeedPurge = TRUE;
            }
        }
    }
}

VOID
RxMarkFobxOnClose(PFOBX pFobx)
/*++

Routine Description:

    This routine undoes the marking done on cleanup

Arguments:

    pFobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.


--*/
{
    PAGED_CODE();

    if (pFobx != NULL) {
        PFCB        pFcb     = pFobx->SrvOpen->Fcb;
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        PRDBSS_SCAVENGER pRdbssScavenger;

        ASSERT(NodeTypeIsFcb(pFcb));
        RxDeviceObject = pFcb->RxDeviceObject;
        pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

        RxAcquireScavengerMutex();

        if (BooleanFlagOn(pFobx->Flags,FOBX_FLAG_MARKED_AS_DORMANT)) {
            if (!pFobx->fOpenCountDecremented) {
                PFCB      pFcb     = pFobx->SrvOpen->Fcb;

                ASSERT(NodeTypeIsFcb(pFcb));
                InterlockedDecrement(&pFcb->OpenCount);
                pFobx->fOpenCountDecremented = TRUE;
            }

            InterlockedDecrement(&pRdbssScavenger->NumberOfDormantFiles);
            ClearFlag(pFobx->Flags,FOBX_FLAG_MARKED_AS_DORMANT);
        }

        if (!IsListEmpty(&pFobx->ClosePendingList)) {
            RemoveEntryList(&pFobx->ClosePendingList);
            InitializeListHead(&pFobx->ClosePendingList);
        }

        RxReleaseScavengerMutex();
    }
}

BOOLEAN
RxPurgeFobx(
   PFOBX pFobx)
/*++

Routine Description:

    This routine purges an FOBX for which a close is pending

Arguments:

    pFobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.


--*/
{
    NTSTATUS  Status;
    BOOLEAN   fResult = TRUE;
    PFCB      pFcb    = pFobx->SrvOpen->Fcb;

    PAGED_CODE();

    Status = RxAcquireExclusiveFcb(NULL,pFcb);

    ASSERT(Status == STATUS_SUCCESS);

    // Carry out the purge operation
    Status = RxPurgeFcbInSystemCache(
                 pFcb,
                 NULL,
                 0,
                 FALSE,
                 TRUE);

    RxReleaseFcb( NULL, pFcb );

    fResult = (Status == STATUS_SUCCESS);

    if (!fResult) {
        RxLog(("PurgeFobxCCFail %lx %lx %lx",pFobx,pFcb,fResult));
        RxWmiLog(LOG,
                 RxPurgeFobx_1,
                 LOGPTR(pFobx)
                 LOGPTR(pFcb));
        return(fResult);
    }

    //try to flush the image section....it may fail
    if (!MmFlushImageSection( &pFcb->NonPaged->SectionObjectPointers, MmFlushForWrite )) {
        RxLog(("PurgeFobxImFail %lx %lx %lx",pFobx,pFcb,FALSE));
        RxWmiLog(LOG,
                 RxPurgeFobx_2,
                 LOGPTR(pFobx)
                 LOGPTR(pFcb));
        return(FALSE);
    }

    //try to flush the user data sections section....it may fail
    if (!MmForceSectionClosed(&pFcb->NonPaged->SectionObjectPointers, TRUE)) {
        RxLog(("PurgeFobxUsFail %lx %lx %lx",pFobx,pFcb,FALSE));
        RxWmiLog(LOG,
                 RxPurgeFobx_3,
                 LOGPTR(pFobx)
                 LOGPTR(pFcb));
        return(FALSE);
    }

    RxLog(("PurgeFobx %lx %lx %lx",pFobx,pFcb,TRUE));
    RxWmiLog(LOG,
             RxPurgeFobx_4,
             LOGPTR(pFobx)
             LOGPTR(pFcb));
    return TRUE;
}

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    )
{
    PAGED_CODE();

    InitializeListHead(&PurgeSyncronizationContext->ContextsAwaitingPurgeCompletion);
    PurgeSyncronizationContext->PurgeInProgress = FALSE;
}

VOID
RxSynchronizeWithScavenger(
    PRX_CONTEXT RxContext)
{
    NTSTATUS Status;
    RxCaptureFcb;
    BOOLEAN ReacquireFcbLock = FALSE;

    PRDBSS_SCAVENGER pRdbssScavenger = capFcb->RxDeviceObject->pRdbssScavenger;

    RxAcquireScavengerMutex();

    if ((pRdbssScavenger->CurrentScavengerThread != PsGetCurrentThread()) &&
        (pRdbssScavenger->CurrentFcbForClosePendingProcessing == capFcb)) {

        ReacquireFcbLock = TRUE;
        RxReleaseFcb(RxContext,capFcb);

        while (pRdbssScavenger->CurrentFcbForClosePendingProcessing == capFcb) {
            RxReleaseScavengerMutex();

            KeWaitForSingleObject(
                &(pRdbssScavenger->ClosePendingProcessingSyncEvent),
                Executive,
                KernelMode,
                TRUE,
                NULL);

            RxAcquireScavengerMutex();
        }
    }

    RxReleaseScavengerMutex();

    if (ReacquireFcbLock) {
        Status = RxAcquireExclusiveFcb( RxContext, capFcb );
        ASSERT(Status == STATUS_SUCCESS);
    }
}

NTSTATUS
RxPurgeRelatedFobxs(
    PNET_ROOT   pNetRoot,
    PRX_CONTEXT pRxContext,
    BOOLEAN     AttemptFinalize,
    PFCB        PurgingFcb
    )
/*++

Routine Description:

    This routine purges all the FOBX's associated with a NET_ROOT

Arguments:

    pNetRoot -- the NET_ROOT for which the FOBX's need to be purged

    pRxContext -- the RX_CONTEXT instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.

    This is a synchronous operation.

--*/
{
    BOOLEAN  ScavengerMutexAcquired = FALSE;
    NTSTATUS Status;
    ULONG    FobxsSuccessfullyPurged = 0;
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;
    LIST_ENTRY FailedToPurgeFobxList;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pRxContext->RxDeviceObject;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    PurgeSyncronizationContext = &pNetRoot->PurgeSyncronizationContext;
    InitializeListHead(&FailedToPurgeFobxList);

    RxAcquireScavengerMutex();

    // If the purge operation for this net root is currently under way hold
    // this request till it completes else initiate the operation after
    // updating the state of the net root.

    if (PurgeSyncronizationContext->PurgeInProgress) {
        InsertTailList(
            &PurgeSyncronizationContext->ContextsAwaitingPurgeCompletion,
            &pRxContext->RxContextSerializationQLinks);

        RxReleaseScavengerMutex();

        RxWaitSync(pRxContext);

        RxAcquireScavengerMutex();
    }

    PurgeSyncronizationContext->PurgeInProgress = TRUE;
    RxWmiLog(LOG,
             RxPurgeRelatedFobxs_3,
             LOGPTR(pRxContext)
             LOGPTR(pNetRoot));

    while (pRdbssScavenger->CurrentNetRootForClosePendingProcessing == pNetRoot) {
        RxReleaseScavengerMutex();

        KeWaitForSingleObject(
            &(pRdbssScavenger->ClosePendingProcessingSyncEvent),
            Executive,
            KernelMode,
            TRUE,
            NULL);

        RxAcquireScavengerMutex();
    }

    ScavengerMutexAcquired = TRUE;

    // An attempt should be made to purge all the FOBX's that had a close
    // pending before the purge request was received.

    for (;;) {
        PLIST_ENTRY pListEntry = NULL;
        PFOBX       pFobx;
        PFCB pFcb;
        BOOLEAN PurgeResult;

        pFobx = NULL;
        pListEntry = pRdbssScavenger->ClosePendingFobxsList.Flink;

        while (pListEntry != &pRdbssScavenger->ClosePendingFobxsList) {
            PFOBX pTempFobx;

            pTempFobx = (PFOBX)(CONTAINING_RECORD(
                            pListEntry,
                            FOBX,
                            ClosePendingList));

            RxLog(("TempFobx=%lx",pTempFobx));
            RxWmiLog(LOG,
                     RxPurgeRelatedFobxs_1,
                     LOGPTR(pTempFobx));

            if ((pTempFobx->SrvOpen != NULL) &&
                (pTempFobx->SrvOpen->Fcb != NULL) &&
                (pTempFobx->SrvOpen->Fcb->VNetRoot != NULL) &&
                ((PNET_ROOT)pTempFobx->SrvOpen->Fcb->VNetRoot->NetRoot == pNetRoot)) {
                NTSTATUS PurgeStatus = STATUS_MORE_PROCESSING_REQUIRED;

                if ((PurgingFcb != NULL) &&
                    (pTempFobx->SrvOpen->Fcb != PurgingFcb)) {
                    MINIRDR_CALL_THROUGH(
                        PurgeStatus,
                        RxDeviceObject->Dispatch,
                        MRxAreFilesAliased,(pTempFobx->SrvOpen->Fcb,PurgingFcb)
                    );
                }

                if (PurgeStatus != STATUS_SUCCESS) {
                    RemoveEntryList(pListEntry);
                    InitializeListHead(pListEntry);

                    pFobx = pTempFobx;
                    break;
                } else {
                    pListEntry = pListEntry->Flink;
                }
            } else {
                pListEntry = pListEntry->Flink;
            }
        }

        if (pFobx != NULL) {
            RxReferenceNetFobx(pFobx);
        } else {
            // Try to wake up the next waiter if any.
            if (!IsListEmpty(&PurgeSyncronizationContext->ContextsAwaitingPurgeCompletion)) {
                PLIST_ENTRY pContextListEntry;
                PRX_CONTEXT pNextContext;

                pContextListEntry = PurgeSyncronizationContext->ContextsAwaitingPurgeCompletion.Flink;
                RemoveEntryList(pContextListEntry);

                pNextContext = (PRX_CONTEXT)(CONTAINING_RECORD(
                                   pContextListEntry,
                                   RX_CONTEXT,
                                   RxContextSerializationQLinks));

                RxSignalSynchronousWaiter(pNextContext);
            } else {
                PurgeSyncronizationContext->PurgeInProgress = FALSE;
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        if (pFobx == NULL) {
            break;
        }

        // Purge the FOBX.
        if (PurgeResult=RxPurgeFobx(pFobx)) {
            FobxsSuccessfullyPurged++;
        }

        pFcb = pFobx->SrvOpen->Fcb;

        if (AttemptFinalize
            && (RxAcquireExclusiveFcb(NULL,pFcb) == STATUS_SUCCESS)) {
            RxReferenceNetFcb(pFcb);
            RxDereferenceNetFobx(pFobx,LHS_ExclusiveLockHeld);
            if ( !RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE) ) {
                RxReleaseFcb( NULL, pFcb );
            }
        } else {
            RxDereferenceNetFobx(pFobx,LHS_LockNotHeld);
        }

        if (!PurgeResult) {
            RxLog(("SCVNGR:FailedToPurge %lx\n", pFcb));
            RxWmiLog(LOG,
                     RxPurgeRelatedFobxs_2,
                     LOGPTR(pFcb));
        }

        RxAcquireScavengerMutex();
        ScavengerMutexAcquired = TRUE;
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    Status = (FobxsSuccessfullyPurged > 0) ? (STATUS_SUCCESS) : (STATUS_UNSUCCESSFUL);

    return Status;
}

VOID
RxPurgeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    This routine purges all the FOBX's while stopping the scavenger

Arguments:

    RxDeviceObject -- the mini redirector device for which the purge should be done

--*/
{
    PLIST_ENTRY pListEntry = NULL;
    PFOBX       pFobx;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    for (;;) {
        PFCB pFcb;

        RxAcquireScavengerMutex();

        pListEntry = pRdbssScavenger->ClosePendingFobxsList.Flink;
        ASSERT(pListEntry!=NULL);

        if (pListEntry != &pRdbssScavenger->ClosePendingFobxsList) {
            pFobx = (PFOBX)(CONTAINING_RECORD(
                        pListEntry,
                        FOBX,
                        ClosePendingList));

            ASSERT ((pFobx->NodeTypeCode&(~RX_SCAVENGER_MASK))==RDBSS_NTC_FOBX);
            ASSERT(pListEntry->Flink!=NULL);
            ASSERT(pListEntry->Blink!=NULL);
            RemoveEntryList(pListEntry);
            InitializeListHead(pListEntry);

            RxReferenceNetFobx(pFobx);
        } else {
            pFobx = NULL;
        }

        RxReleaseScavengerMutex();

        if (pFobx == NULL) {
            break;
        }

        pFcb = pFobx->SrvOpen->Fcb;
        RxPurgeFobx(pFobx);

        if (RxAcquireExclusiveFcb(NULL,pFcb) == STATUS_SUCCESS) {
            RxReferenceNetFcb(pFcb);
            RxDereferenceNetFobx(pFobx,LHS_ExclusiveLockHeld);
            if ( !RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE) ) {
                RxReleaseFcb( NULL, pFcb );
            }
        } else {
            RxLog(("RxPurgeAllFobxs: FCB %lx not accqd.\n",pFcb));
            RxWmiLog(LOG,
                     RxPurgeAllFobxs,
                     LOGPTR(pFcb));
            RxDereferenceNetFobx(pFobx,LHS_LockNotHeld);
        }
    }
}


PRDBSS_DEVICE_OBJECT
RxGetDeviceObjectOfInstance (
    PVOID pInstance
    )
/*++

Routine Description:

    The routine finds out the device object of an upper structure.

Arguments:

    pInstance        - the instance

Return Value:

    none.

--*/
{
    ULONG NodeTypeCode = NodeType(pInstance) & ~RX_SCAVENGER_MASK;
    PAGED_CODE();


    ASSERT(   (NodeTypeCode == RDBSS_NTC_SRVCALL ) ||
              (NodeTypeCode == RDBSS_NTC_NETROOT ) ||
              (NodeTypeCode == RDBSS_NTC_V_NETROOT ) ||
              (NodeTypeCode == RDBSS_NTC_SRVOPEN ) ||
              (NodeTypeCode == RDBSS_NTC_FOBX )
           );

    switch (NodeTypeCode) {

    case RDBSS_NTC_SRVCALL:
        return((PSRV_CALL)pInstance)->RxDeviceObject;
        //no break;

    case RDBSS_NTC_NETROOT:
        return((PNET_ROOT)pInstance)->SrvCall->RxDeviceObject;
        //no break;

    case RDBSS_NTC_V_NETROOT:
        return((PV_NET_ROOT)pInstance)->NetRoot->SrvCall->RxDeviceObject;
        //no break;

    case RDBSS_NTC_SRVOPEN:
        return((PSRV_OPEN)pInstance)->Fcb->RxDeviceObject;
        //no break;

    case RDBSS_NTC_FOBX:
        return((PFOBX)pInstance)->SrvOpen->Fcb->RxDeviceObject;
        //no break;

    default:
        return(NULL);
    }
}


VOID
RxpMarkInstanceForScavengedFinalization(
    PVOID pInstance)
/*++

Routine Description:

    Thie routine marks a reference counted instance for scavenging

Arguments:

    pInstance -- the instance to be marked for finalization by the scavenger

Notes:

    Currently scavenging has been implemented for SRV_CALL,NET_ROOT and V_NET_ROOT.
    The FCB scavenging is handled separately. The FOBX can and should always be
    synchronously finalized. The only data structure that will have to be potentially
    enabled for scavenged finalization are SRV_OPEN's.

    The Scavenger as it is implemented currently will not consume any system resources
    till there is a need for scavenged finalization. The first entry to be marked for
    scavenged finalization results in a timer request being posted for the scavenger.

    In the current implementation the timer requests are posted as one shot timer requests.
    This implies that there are no guarantess as regards the time interval within which
    the entries will be finalized. The scavenger activation mechanism is a potential
    candidate for fine tuning at a later stage.

    On Entry -- Scavenger Mutex must have been accquired

    On Exit  -- no change in resource ownership.

--*/
{
    BOOLEAN PostTimerRequest = FALSE;

    PLIST_ENTRY pListHead  = NULL;
    PLIST_ENTRY pListEntry = NULL;

    NODE_TYPE_CODE_AND_SIZE *pNode = (PNODE_TYPE_CODE_AND_SIZE)pInstance;

    USHORT InstanceType;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxGetDeviceObjectOfInstance(pInstance);
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxDbgTrace(0,Dbg,("Marking %lx of type %lx for scavenged finalization\n",pInstance,NodeType(pInstance)));

    InstanceType = pNode->NodeTypeCode;

    if (pNode->NodeReferenceCount <= 1) {
        // Mark the entry for scavenging.
        pNode->NodeTypeCode |= RX_SCAVENGER_MASK;
        RxLog(("Marked for scavenging %lx",pNode));
        RxWmiLog(LOG,
                 RxpMarkInstanceForScavengedFinalization,
                 LOGPTR(pNode));

        switch (InstanceType) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL pSrvCall = (PSRV_CALL)pInstance;

                pRdbssScavenger->SrvCallsToBeFinalized++;
                pListHead  = &pRdbssScavenger->SrvCallFinalizationList;
                pListEntry = &pSrvCall->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)pInstance;

                pRdbssScavenger->NetRootsToBeFinalized++;
                pListHead  = &pRdbssScavenger->NetRootFinalizationList;
                pListEntry = &pNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT pVNetRoot = (PV_NET_ROOT)pInstance;

                pRdbssScavenger->VNetRootsToBeFinalized++;
                pListHead  = &pRdbssScavenger->VNetRootFinalizationList;
                pListEntry = &pVNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN pSrvOpen = (PSRV_OPEN)pInstance;

                pRdbssScavenger->SrvOpensToBeFinalized++;
                pListHead  = &pRdbssScavenger->SrvOpenFinalizationList;
                pListEntry = &pSrvOpen->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX pFobx = (PFOBX)pInstance;

                pRdbssScavenger->FobxsToBeFinalized++;
                pListHead  = &pRdbssScavenger->FobxFinalizationList;
                pListEntry = &pFobx->ScavengerFinalizationList;
            }
            break;

        default:
            break;
        }

        InterlockedIncrement(&pNode->NodeReferenceCount);
    }

    if (pListHead != NULL) {
        InsertTailList(pListHead,pListEntry);

        if (pRdbssScavenger->State == RDBSS_SCAVENGER_INACTIVE) {
            pRdbssScavenger->State = RDBSS_SCAVENGER_DORMANT;
            PostTimerRequest  = TRUE;
        } else {
            PostTimerRequest = FALSE;
        }
    }

    if (PostTimerRequest) {
        LARGE_INTEGER TimeInterval;

        // Post a one shot timer request for scheduling the scavenger after a
        // predetermined amount of time.

        TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

        RxPostOneShotTimerRequest(
            RxFileSystemDeviceObject,
            &pRdbssScavenger->WorkItem,
            RxScavengerTimerRoutine,
            RxDeviceObject,
            TimeInterval);
    }
}

VOID
RxpUndoScavengerFinalizationMarking(
    PVOID pInstance)
/*++

Routine Description:

    This routine undoes the marking for scavenged finalization

Arguments:

    pInstance -- the instance to be unmarked

Notes:

    This routine is typically invoked when a reference is made to an entry that has
    been marked for scavenging. Since the scavenger routine that does the finalization
    needs to acquire the exclusive lock this routine should be called with the
    appropriate lock held in a shared mode atleast. This routine removes it from the list
    of entries marked for scavenging and rips off the scavenger mask from the node type.

--*/
{
    PLIST_ENTRY pListEntry;

    PNODE_TYPE_CODE_AND_SIZE pNode = (PNODE_TYPE_CODE_AND_SIZE)pInstance;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxGetDeviceObjectOfInstance(pInstance);
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxDbgTrace(0,Dbg,("SCAVENGER -- undoing the marking for %lx of type %lx\n",pNode,pNode->NodeTypeCode));

    if (pNode->NodeTypeCode & RX_SCAVENGER_MASK) {
        pNode->NodeTypeCode &= ~RX_SCAVENGER_MASK;

        switch (pNode->NodeTypeCode) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL pSrvCall = (PSRV_CALL)pInstance;

                pRdbssScavenger->SrvCallsToBeFinalized--;
                pListEntry = &pSrvCall->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)pInstance;

                pRdbssScavenger->NetRootsToBeFinalized--;
                pListEntry = &pNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT pVNetRoot = (PV_NET_ROOT)pInstance;

                pRdbssScavenger->VNetRootsToBeFinalized--;
                pListEntry = &pVNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN pSrvOpen = (PSRV_OPEN)pInstance;

                pRdbssScavenger->SrvOpensToBeFinalized--;
                pListEntry = &pSrvOpen->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX pFobx = (PFOBX)pInstance;

                pRdbssScavenger->FobxsToBeFinalized--;
                pListEntry = &pFobx->ScavengerFinalizationList;
            }
            break;

        default:
            return;
        }

        RemoveEntryList(pListEntry);
        InitializeListHead(pListEntry);

        InterlockedDecrement(&pNode->NodeReferenceCount);
    }
}

VOID
RxUndoScavengerFinalizationMarking(
    PVOID pInstance)
/*++

Routine Description:

    This routine undoes the marking for scavenged finalization

Arguments:

    pInstance -- the instance to be unmarked

--*/
{
    RxAcquireScavengerMutex();

    RxpUndoScavengerFinalizationMarking(pInstance);

    RxReleaseScavengerMutex();
}

BOOLEAN
RxScavengeRelatedFobxs(PFCB pFcb)
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given FCB.

Notes:

    On Entry -- FCB must have been accquired exclusive.

    On Exit  -- no change in resource acquistion.

--*/
{
    BOOLEAN ScavengerMutexAcquired  = FALSE;
    BOOLEAN AtleastOneFobxScavenged = FALSE;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pFcb->RxDeviceObject;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxAcquireScavengerMutex();
    ScavengerMutexAcquired = TRUE;

    if (pRdbssScavenger->FobxsToBeFinalized > 0) {
        PLIST_ENTRY   pEntry;
        PFOBX         pFobx;
        LIST_ENTRY    FobxList;

        InitializeListHead(&FobxList);


        pEntry = pRdbssScavenger->FobxFinalizationList.Flink;
        while (pEntry != &pRdbssScavenger->FobxFinalizationList) {
            pFobx  = (PFOBX)CONTAINING_RECORD(
                                pEntry,
                                FOBX,
                                ScavengerFinalizationList);

            pEntry = pEntry->Flink;

            if (pFobx->SrvOpen != NULL &&
                pFobx->SrvOpen->Fcb == pFcb) {
                RxpUndoScavengerFinalizationMarking(pFobx);
                ASSERT(NodeType(pFobx) == RDBSS_NTC_FOBX);

                InsertTailList(&FobxList,&pFobx->ScavengerFinalizationList);
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        AtleastOneFobxScavenged = !IsListEmpty(&FobxList);

        pEntry = FobxList.Flink;
        while (!IsListEmpty(&FobxList)) {
            pEntry = FobxList.Flink;
            RemoveEntryList(pEntry);
            pFobx  = (PFOBX)CONTAINING_RECORD(
                         pEntry,
                         FOBX,
                         ScavengerFinalizationList);

            RxFinalizeNetFobx(pFobx,TRUE,TRUE);
        }
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    return AtleastOneFobxScavenged;
}


VOID
RxpScavengeFobxs(
    PRDBSS_SCAVENGER pRdbssScavenger,
    PLIST_ENTRY      pFobxList)
/*++

Routine Description:

    Thie routine scavenges all the file objects in the given list. This routine
    does the actual work of scavenging while RxScavengeFobxsForNetRoot and
    RxScavengeAllFobxs gather the file object extensions and call this routine

Notes:

--*/
{
    while (!IsListEmpty(pFobxList)) {
        PFCB        pFcb;
        PFOBX       pFobx;
        NTSTATUS    Status;

        PLIST_ENTRY pEntry;

        pEntry = pFobxList->Flink;

        RemoveEntryList(pEntry);

        pFobx  = (PFOBX)CONTAINING_RECORD(
                     pEntry,
                     FOBX,
                     ScavengerFinalizationList);

        pFcb = (PFCB)pFobx->pSrvOpen->pFcb;

        Status = RxAcquireExclusiveFcb( NULL, pFcb );

        if (Status == (STATUS_SUCCESS)) {
            BOOLEAN ReleaseFcb;

            RxReferenceNetFcb(pFcb);

            RxDereferenceNetFobx(pFobx,LHS_ExclusiveLockHeld);

            ReleaseFcb = !RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE);

            if (ReleaseFcb) {
                RxReleaseFcb( NULL, pFcb );
            }
        } else {
            RxDereferenceNetFobx(pFobx,LHS_LockNotHeld);
        }
    }
}

VOID
RxScavengeFobxsForNetRoot(
    PNET_ROOT pNetRoot,
    PFCB      PurgingFcb)
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given net root
    instance

Notes:

--*/
{
    BOOLEAN ScavengerMutexAcquired = FALSE;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pNetRoot->pSrvCall->RxDeviceObject;
    PRDBSS_SCAVENGER pRdbssScavenger    = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxAcquireScavengerMutex();
    ScavengerMutexAcquired = TRUE;

    if (pRdbssScavenger->FobxsToBeFinalized > 0) {
        PLIST_ENTRY   pEntry;
        PFOBX         pFobx;
        LIST_ENTRY    FobxList;

        InitializeListHead(&FobxList);

        pEntry = pRdbssScavenger->FobxFinalizationList.Flink;
        while (pEntry != &pRdbssScavenger->FobxFinalizationList) {
            pFobx  = (PFOBX)CONTAINING_RECORD(
                                pEntry,
                                FOBX,
                                ScavengerFinalizationList);

            pEntry = pEntry->Flink;

            if (pFobx->SrvOpen != NULL &&
                pFobx->SrvOpen->Fcb->pNetRoot == (PMRX_NET_ROOT)pNetRoot) {
                NTSTATUS PurgeStatus = STATUS_MORE_PROCESSING_REQUIRED;

                if ((PurgingFcb != NULL) &&
                    (pFobx->SrvOpen->Fcb != PurgingFcb)) {
                    MINIRDR_CALL_THROUGH(
                        PurgeStatus,
                        RxDeviceObject->Dispatch,
                        MRxAreFilesAliased,(pFobx->SrvOpen->Fcb,PurgingFcb)
                    );
                }

                if (PurgeStatus != STATUS_SUCCESS) {
                    RxReferenceNetFobx(pFobx);

                    ASSERT(NodeType(pFobx) == RDBSS_NTC_FOBX);

                    InsertTailList(&FobxList,&pFobx->ScavengerFinalizationList);
                }
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        RxpScavengeFobxs(pRdbssScavenger,&FobxList);
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    return;
}

VOID
RxScavengeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given mini
    redirector device object

Notes:


--*/
{
    PRDBSS_SCAVENGER pRdbssScavenger    = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    if (pRdbssScavenger->FobxsToBeFinalized > 0) {
        PLIST_ENTRY   pEntry;
        PFOBX         pFobx;
        LIST_ENTRY    FobxList;

        InitializeListHead(&FobxList);

        RxAcquireScavengerMutex();

        pEntry = pRdbssScavenger->FobxFinalizationList.Flink;
        while (pEntry != &pRdbssScavenger->FobxFinalizationList) {
            pFobx  = (PFOBX)CONTAINING_RECORD(
                                pEntry,
                                FOBX,
                                ScavengerFinalizationList);

            pEntry = pEntry->Flink;

            RxReferenceNetFobx(pFobx);

            ASSERT(NodeType(pFobx) == RDBSS_NTC_FOBX);

            InsertTailList(&FobxList,&pFobx->ScavengerFinalizationList);
        }

        RxReleaseScavengerMutex();

        RxpScavengeFobxs(pRdbssScavenger,&FobxList);
    }
}

BOOLEAN
RxScavengeVNetRoots(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
{
    BOOLEAN AtleastOneEntryScavenged = FALSE;
    PRX_PREFIX_TABLE  pRxNetNameTable = RxDeviceObject->pRxNetNameTable;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;
    PV_NET_ROOT pVNetRoot;

    PAGED_CODE();

    do {
        PVOID       pEntry;

        RxDbgTrace(0,Dbg,("RDBSS SCAVENGER -- Scavenging VNetRoots\n"));

        RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);

        RxAcquireScavengerMutex();

        if (pRdbssScavenger->VNetRootsToBeFinalized > 0) {
            pEntry = RemoveHeadList(&pRdbssScavenger->VNetRootFinalizationList);

            pVNetRoot = (PV_NET_ROOT)
                        CONTAINING_RECORD(
                            pEntry,
                            V_NET_ROOT,
                            ScavengerFinalizationList);

            RxpUndoScavengerFinalizationMarking(pVNetRoot);
            ASSERT(NodeType(pVNetRoot) == RDBSS_NTC_V_NETROOT);
        } else {
            pVNetRoot = NULL;
        }

        RxReleaseScavengerMutex();

        if (pVNetRoot != NULL) {
            RxFinalizeVNetRoot(pVNetRoot,TRUE,TRUE);
            AtleastOneEntryScavenged = TRUE;
        }

        RxReleasePrefixTableLock(pRxNetNameTable);
    } while (pVNetRoot != NULL);

    return AtleastOneEntryScavenged;
}

VOID
RxScavengerFinalizeEntries (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    Thie routine initiates the delayed finalization of entries

Notes:

    This routine must always be called only after acquiring the Scavenger Mutex.
    On return from this routine it needs to be reacquired. This is required
    to avoid redundant copying of data structures.

    The performance metric for the scavenger is different from the other routines. In
    the other routines the goal is to do as much work as possible once the lock is
    acquired without having to release it. On the other hand for the scavenger the
    goal is to hold the lock for as short a duration as possible because this
    interferes with the regular activity. This is preferred even if it entails
    frequent relaesing/acquisition of locks since it enables higher degrees of
    concurrency.

--*/
{
    BOOLEAN AtleastOneEntryScavenged;
    PRX_PREFIX_TABLE  pRxNetNameTable = RxDeviceObject->pRxNetNameTable;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    do {
        AtleastOneEntryScavenged = FALSE;

        RxAcquireScavengerMutex();

        if (pRdbssScavenger->NumberOfDormantFiles > 0) {
            PLIST_ENTRY pListEntry;
            PFOBX       pFobxToBePurged;

            // If the number of dormant files exceeds the limit specified for the
            // given server a currently dormant file needs to be picked up for
            // purging.

            pListEntry = pRdbssScavenger->ClosePendingFobxsList.Flink;
            if (pListEntry != &pRdbssScavenger->ClosePendingFobxsList) {
                pFobxToBePurged = (PFOBX)(CONTAINING_RECORD(
                                      pListEntry,
                                      FOBX,
                                      ClosePendingList));

                RemoveEntryList(&pFobxToBePurged->ClosePendingList);
                InitializeListHead(&pFobxToBePurged->ClosePendingList);

                RxReferenceNetFobx(pFobxToBePurged);

                pRdbssScavenger->CurrentScavengerThread = PsGetCurrentThread();

                pRdbssScavenger->CurrentFcbForClosePendingProcessing =
                    (PFCB)(pFobxToBePurged->SrvOpen->Fcb);

                pRdbssScavenger->CurrentNetRootForClosePendingProcessing =
                    (PNET_ROOT)(pFobxToBePurged->SrvOpen->Fcb->pNetRoot);

                KeResetEvent(
                    &(pRdbssScavenger->ClosePendingProcessingSyncEvent));
            } else {
                pFobxToBePurged = NULL;
            }

            if (pFobxToBePurged != NULL) {
                NTSTATUS Status;

                RxReleaseScavengerMutex();

                Status = RxPurgeFobxFromCache(pFobxToBePurged);

                AtleastOneEntryScavenged = (Status == STATUS_SUCCESS);

                RxAcquireScavengerMutex();

                pRdbssScavenger->CurrentScavengerThread = NULL;
                pRdbssScavenger->CurrentFcbForClosePendingProcessing = NULL;
                pRdbssScavenger->CurrentNetRootForClosePendingProcessing = NULL;

                KeSetEvent(
                    &(pRdbssScavenger->ClosePendingProcessingSyncEvent),
                    0,
                    FALSE);
            }
        }

        if (pRdbssScavenger->FobxsToBeFinalized > 0) {
            PVOID pEntry;
            PFOBX pFobx = NULL;
            PFCB  pFcb  = NULL;

            RxDbgTrace(0,Dbg,("RDBSS SCAVENGER -- Scavenging Fobxs\n"));

            if (pRdbssScavenger->FobxsToBeFinalized > 0) {
                pEntry = pRdbssScavenger->FobxFinalizationList.Flink;

                pFobx  = (PFOBX)
                         CONTAINING_RECORD(
                             pEntry,
                             FOBX,
                             ScavengerFinalizationList);

                pFcb = pFobx->SrvOpen->Fcb;
                RxReferenceNetFcb(pFcb);

                pRdbssScavenger->CurrentScavengerThread = PsGetCurrentThread();

                pRdbssScavenger->CurrentFcbForClosePendingProcessing =
                    (PFCB)(pFobx->SrvOpen->Fcb);

                pRdbssScavenger->CurrentNetRootForClosePendingProcessing =
                    (PNET_ROOT)(pFobx->SrvOpen->Fcb->pNetRoot);

                KeResetEvent(
                    &(pRdbssScavenger->ClosePendingProcessingSyncEvent));
            } else {
                pFobx = NULL;
            }

            if (pFobx != NULL) {
                NTSTATUS Status;

                RxReleaseScavengerMutex();

                Status = RxAcquireExclusiveFcb( NULL, pFcb );
                if (Status == (STATUS_SUCCESS)) {
                    BOOLEAN ReleaseFcb;

                    AtleastOneEntryScavenged = RxScavengeRelatedFobxs(pFcb);

                    ReleaseFcb = !RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE);

                    if (ReleaseFcb) {
                        RxReleaseFcb( NULL, pFcb );
                    }
                } else {
                    RxLog(("Delayed Close Failure FOBX(%lx) FCB(%lx)\n",pFobx,pFcb));
                    RxWmiLog(LOG,
                             RxScavengerFinalizeEntries,
                             LOGPTR(pFobx)
                             LOGPTR(pFcb));
                }

                RxAcquireScavengerMutex();

                pRdbssScavenger->CurrentScavengerThread = NULL;
                pRdbssScavenger->CurrentFcbForClosePendingProcessing = NULL;
                pRdbssScavenger->CurrentNetRootForClosePendingProcessing = NULL;

                KeSetEvent(
                    &(pRdbssScavenger->ClosePendingProcessingSyncEvent),
                    0,
                    FALSE);
            }
        }

        RxReleaseScavengerMutex();

        if (pRdbssScavenger->SrvOpensToBeFinalized > 0) {
            //SRV_OPEN List should not be empty, potential memory leak
            ASSERT(pRdbssScavenger->SrvOpensToBeFinalized == 0);
        }

        if (pRdbssScavenger->FcbsToBeFinalized > 0) {
            //FCB list should be empty , potential memory leak
            ASSERT(pRdbssScavenger->FcbsToBeFinalized == 0);
        }

        if (pRdbssScavenger->VNetRootsToBeFinalized > 0) {
            PVOID       pEntry;
            PV_NET_ROOT pVNetRoot;

            RxDbgTrace(0,Dbg,("RDBSS SCAVENGER -- Scavenging VNetRoots\n"));

            RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);

            RxAcquireScavengerMutex();

            if (pRdbssScavenger->VNetRootsToBeFinalized > 0) {
                pEntry = RemoveHeadList(&pRdbssScavenger->VNetRootFinalizationList);

                pVNetRoot = (PV_NET_ROOT)
                            CONTAINING_RECORD(
                                pEntry,
                                V_NET_ROOT,
                                ScavengerFinalizationList);

                RxpUndoScavengerFinalizationMarking(pVNetRoot);
                ASSERT(NodeType(pVNetRoot) == RDBSS_NTC_V_NETROOT);
            } else {
                pVNetRoot = NULL;
            }

            RxReleaseScavengerMutex();

            if (pVNetRoot != NULL) {
                RxFinalizeVNetRoot(pVNetRoot,TRUE,TRUE);
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock(pRxNetNameTable);
        }

        if (pRdbssScavenger->NetRootsToBeFinalized > 0) {
            PVOID     pEntry;
            PNET_ROOT pNetRoot;

            RxDbgTrace(0,Dbg,("RDBSS SCAVENGER -- Scavenging NetRoots\n"));

            RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);

            RxAcquireScavengerMutex();

            if (pRdbssScavenger->NetRootsToBeFinalized > 0) {
                pEntry = RemoveHeadList(&pRdbssScavenger->NetRootFinalizationList);

                pNetRoot = (PNET_ROOT)
                            CONTAINING_RECORD(
                                pEntry,
                                NET_ROOT,
                                ScavengerFinalizationList);

                RxpUndoScavengerFinalizationMarking(pNetRoot);
                ASSERT(NodeType(pNetRoot) == RDBSS_NTC_NETROOT);
            } else {
                pNetRoot = NULL;
            }

            RxReleaseScavengerMutex();

            if (pNetRoot != NULL) {
                RxFinalizeNetRoot(pNetRoot,TRUE,TRUE);
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock(pRxNetNameTable);
        }

        if (pRdbssScavenger->SrvCallsToBeFinalized > 0) {
            PVOID     pEntry;
            PSRV_CALL pSrvCall;

            RxDbgTrace(0,Dbg,("RDBSS SCAVENGER -- Scavenging SrvCalls\n"));

            RxAcquirePrefixTableLockExclusive(pRxNetNameTable,TRUE);

            RxAcquireScavengerMutex();

            if (pRdbssScavenger->SrvCallsToBeFinalized > 0) {
                pEntry = RemoveHeadList(&pRdbssScavenger->SrvCallFinalizationList);

                pSrvCall = (PSRV_CALL)
                            CONTAINING_RECORD(
                                pEntry,
                                SRV_CALL,
                                ScavengerFinalizationList);

                RxpUndoScavengerFinalizationMarking(pSrvCall);
                ASSERT(NodeType(pSrvCall) == RDBSS_NTC_SRVCALL);
            } else {
                pSrvCall = NULL;
            }

            RxReleaseScavengerMutex();

            if (pSrvCall != NULL) {
                RxFinalizeSrvCall(pSrvCall,TRUE,TRUE);
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock(pRxNetNameTable);
        }
    } while (AtleastOneEntryScavenged);
}

VOID
RxScavengerTimerRoutine(
    PVOID pContext)
/*++

Routine Description:

    This routine is the timer routine that periodically initiates the finalization of
    entries.

Arguments:

    pContext -- the context (actually the RxDeviceObject)

Notes:

--*/
{
    PRDBSS_DEVICE_OBJECT RxDeviceObject = (PRDBSS_DEVICE_OBJECT)pContext;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;
    BOOLEAN PostTimerRequest = FALSE;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    KeResetEvent(&pRdbssScavenger->SyncEvent);

    if (pRdbssScavenger->State == RDBSS_SCAVENGER_DORMANT) {
        pRdbssScavenger->State = RDBSS_SCAVENGER_ACTIVE;

        RxReleaseScavengerMutex();

        RxScavengerFinalizeEntries(RxDeviceObject);

        RxAcquireScavengerMutex();

        if (pRdbssScavenger->State == RDBSS_SCAVENGER_ACTIVE) {
            ULONG EntriesToBeFinalized;

            // Check if the scavenger needs to be activated again.
            EntriesToBeFinalized = pRdbssScavenger->SrvCallsToBeFinalized +
                                   pRdbssScavenger->NetRootsToBeFinalized +
                                   pRdbssScavenger->VNetRootsToBeFinalized +
                                   pRdbssScavenger->FcbsToBeFinalized +
                                   pRdbssScavenger->SrvOpensToBeFinalized +
                                   pRdbssScavenger->FobxsToBeFinalized +
                                   pRdbssScavenger->NumberOfDormantFiles;

            if (EntriesToBeFinalized > 0) {
                PostTimerRequest = TRUE;
                pRdbssScavenger->State = RDBSS_SCAVENGER_DORMANT;
            } else {
                pRdbssScavenger->State = RDBSS_SCAVENGER_INACTIVE;
            }
        }

        RxReleaseScavengerMutex();

        if (PostTimerRequest) {
            LARGE_INTEGER TimeInterval;

            TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

            RxPostOneShotTimerRequest(
                RxFileSystemDeviceObject,
                &pRdbssScavenger->WorkItem,
                RxScavengerTimerRoutine,
                RxDeviceObject,
                TimeInterval);
        }
    } else {
        RxReleaseScavengerMutex();
    }

    // Trigger the event.
    KeSetEvent(&pRdbssScavenger->SyncEvent,0,FALSE);
}

VOID
RxTerminateScavenging(
    PRX_CONTEXT pRxContext)
/*++

Routine Description:

    This routine terminates all scavenging activities in the RDBSS. The termination is
    effected in an orderly fashion after all the entries currently marked for scavenging
    are finalized.

Arguments:

    pRxContext -- the context

Notes:

    In implementing the scavenger there are two options. The scavenger can latch onto a
    thread and hold onto it from the moment RDBSS comes into existence till it is unloaded.
    Such an implementation renders a thread useless throughout the lifetime of RDBSS.

    If this is to be avoided the alternative is to trigger the scavenger as and when
    required. While this technique addresses the conservation of system resources it
    poses some tricky synchronization problems having to do with start/stop of the RDR.

    Since the RDR can be started/stopped at any time the Scavenger can be in one of three
    states when the RDR is stopped.

      1) Scavenger is active.

      2) Scavenger request is in the timer queue.

      3) Scavenger is inactive.

    Of these case (3) is the easiest since no special action is required.

    If the scavenger is active then this routine has to synchronize with the timer routine
    that is finzalizing the entries. This is achieved by allowing the termination routine to
    modify the Scavenger state under a mutex and waiting for it to signal the event on
    completion.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pRxContext->RxDeviceObject;
    PRDBSS_SCAVENGER pRdbssScavenger = RxDeviceObject->pRdbssScavenger;

    RDBSS_SCAVENGER_STATE PreviousState;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    PreviousState        = pRdbssScavenger->State;
    pRdbssScavenger->State = RDBSS_SCAVENGER_SUSPENDED;

    RxReleaseScavengerMutex();

    if (PreviousState == RDBSS_SCAVENGER_DORMANT) {
        // There is a timer request currently active. cancel it
        Status = RxCancelTimerRequest(
                     RxFileSystemDeviceObject,
                     RxScavengerTimerRoutine,
                     RxDeviceObject);
    }

    if ((PreviousState == RDBSS_SCAVENGER_ACTIVE) ||
        (Status == STATUS_NOT_FOUND)) {
        // Either the timer routine was previously active or it could not be cancelled
        // Wait for it to complete
        KeWaitForSingleObject(&pRdbssScavenger->SyncEvent,Executive,KernelMode,FALSE,NULL);
    }

    RxPurgeAllFobxs(pRxContext->RxDeviceObject);

    RxScavengerFinalizeEntries(pRxContext->RxDeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\rxcemm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcemm.c

Abstract:

    This module contains the NT implementation of memory management for RxCe.

Notes:


--*/

#include "precomp.h"
#pragma  hdrstop
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEPOOL)

#define RXCE_ZONE_ALLOCATION 0x80

//
// Pool debugging data structures.
//
LIST_ENTRY s_RxMdlList;

// MDL debugging structures.

typedef struct _WRAPPED_RX_MDL {
    LIST_ENTRY  Next;
    PUCHAR      File;
    int         Line;
    PMDL        pMdl;
} WRAPPED_RX_MDL, *PWRAPPED_RX_MDL;

//
// Pool header data structure.  Ensure it is 8 byte aligned, no
// matter what members are added to the pool header
//
typedef struct _RX_POOL_HEADER {
    union {
        struct _RXH {
            BYTE  Signature[ 16 ];
            ULONG Size;
            ULONG Type;
            PSZ   AFileName;
            ULONG ALineNumber;
            PSZ   FFileName;
            ULONG FLineNumber;
        };
        UCHAR _pad[ (sizeof( struct _RXH ) + 7) & (~7) ];
    };
} RX_POOL_HEADER, *PRX_POOL_HEADER;

//
// Number of trailer bytes after a pool allocation with a known signature
//
#define TRAIL_BYTES  16

#ifdef RX_POOL_WRAPPER

PVOID
_RxAllocatePoolWithTag(
    ULONG Type,
    ULONG Size,
    ULONG Tag,
    PSZ   FileName,
    ULONG LineNumber
    )
/*++

Routine Description:

    This routine allocates the desired pool and sets up the debugging header and trailer
    to catch most instances of memory trashing

Arguments:

    Type    - type of pool to be allocated

    Size    - size of the allocation

Return Value:

    a valid pointer if successful, otherwise FALSE.

--*/
{
#if 0
    PCHAR pBuffer;
    PRX_POOL_HEADER pPoolHeader;

    ASSERT( Size != 0 );
    ASSERT(
        Type == PagedPool ||
        Type == (PagedPool | POOL_COLD_ALLOCATION) ||
        Type == NonPagedPool);

    ASSERT( (sizeof(RX_POOL_HEADER)&7) == 0  );

    pPoolHeader = ExAllocatePoolWithTagPriority(
                      Type,
                      sizeof( *pPoolHeader ) + Size + TRAIL_BYTES,
                      Tag,
                      LowPoolPriority);

    if ( pPoolHeader == NULL ) {
        RxLog(("RA:NULL %d %d %s\n", Type, LineNumber, &FileName[24]));
        return( NULL );
    }

    //
    // Fill the head so we can verify valid free's
    //
    RtlFillMemory( pPoolHeader->Signature, sizeof( pPoolHeader->Signature ), 'H' );
    pPoolHeader->Size = Size;
    pPoolHeader->Type = Type;
    pPoolHeader->AFileName = FileName;
    pPoolHeader->ALineNumber = LineNumber;
    pPoolHeader->FFileName = NULL;
    pPoolHeader->FLineNumber = 0;

    pBuffer = (PCHAR)(pPoolHeader + 1);

    //
    // Fill the memory to catch uninitialized structures, etc
    //
    RtlFillMemory( pBuffer, Size, '*' );

    //
    // Fill the tail to catch overruns
    //
    RtlFillMemory( pBuffer + Size, TRAIL_BYTES, 'T' );

    //
    // Make sure we're starting out valid
    //
    RxCheckMemoryBlock( pBuffer );

    return( pBuffer );
#endif

    return ExAllocatePoolWithTagPriority(
               Type,Size,Tag,LowPoolPriority);
}

VOID
_RxFreePool( PVOID pBuffer, PSZ FileName, ULONG LineNumber )
{
#if 0
    if( _RxCheckMemoryBlock( pBuffer, FileName, LineNumber ) ) {

        PRX_POOL_HEADER pPoolHeader = ((PRX_POOL_HEADER)pBuffer) - 1;

        //
        // Zap the block, to catch cases where we are using freed blocks
        //
        RtlFillMemory( pPoolHeader->Signature,
                      sizeof( pPoolHeader->Signature ),
                     'F' );

        pPoolHeader->FFileName = FileName;
        pPoolHeader->FLineNumber = LineNumber;
        RtlFillMemory( pPoolHeader+1,
                      pPoolHeader->Size + TRAIL_BYTES,
                     'F' );

        ExFreePool( pPoolHeader );
    }
#endif

    ExFreePool(pBuffer);
}

BOOLEAN
_RxCheckMemoryBlock(
    PVOID pBuffer,
    PSZ   FileName,
    ULONG LineNumber
    )
/*++

Routine Description:

    This routine frees up the pool allocated through RxAllocate

Arguments:

    pv       - the block to be freed

--*/
{
    PRX_POOL_HEADER pPoolHeader = ((PRX_POOL_HEADER)pBuffer) - 1;
    PCHAR pTail;
    ULONG i;

    if( pBuffer == NULL ) {
        DbgPrint( "RxCheckMemoryBlock( NULL ) at %s %d\n",
                   FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    //
    // Make sure we have a valid block
    //
    for( i=0; i < sizeof( pPoolHeader->Signature ); i++ ) {
        if( pPoolHeader->Signature[i] != 'H' ) {
            if( pPoolHeader->Signature[i] == 'F' && i == 0 ) {
                DbgPrint( "RxFreePool: Likely double free on block at %X\n", pPoolHeader );
            }

            DbgPrint( "RxCheckMemoryBlock: Invalid header signature for block %X\n", pPoolHeader );
            DbgPrint( "            Called from %s %d\n", FileName, LineNumber );
            DbgPrint( "            Originally Freed at %s %d\n",pPoolHeader->FFileName,pPoolHeader->FLineNumber);
            DbgPrint( "            Size is x%X, user part at %X\n", pPoolHeader->Size, pPoolHeader + 1 );
            DbgBreakPoint();
            return FALSE;
        }
    }

    if( pPoolHeader->Type != PagedPool && 
        pPoolHeader->Type != (PagedPool | POOL_COLD_ALLOCATION) &&
        pPoolHeader->Type != NonPagedPool) {
        DbgPrint( "RxCheckMemoryBlock:\n" );
        DbgPrint( "    Invalid PoolHeader->Type for block %X\n", pPoolHeader );
        DbgPrint( "    Called from %s %d\n", FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    if( pPoolHeader->Size == 0 ) {
        DbgPrint( "RxCheckMemoryBlock:\n" );
        DbgPrint( "     Size is 0 for block %X\n", pPoolHeader );
        DbgPrint( "    Called from %s %d\n", FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    //
    // Look to see if the buffer has been overrun
    //
    pTail = (PCHAR)pBuffer + pPoolHeader->Size;
    for( i=0; i < TRAIL_BYTES; i++ ) {
        if( *pTail++ != 'T' ) {
            DbgPrint( "RxCheckMemoryBlock: Overrun memory block at %X\n", pPoolHeader );
            DbgPrint( "            RxCheckMemoryBlock called from %s line %d\n", FileName, LineNumber );
            DbgPrint( "            Allocated at %s line %d\n", pPoolHeader->AFileName, pPoolHeader->ALineNumber );
            DbgPrint( "            Size is x%X, user part at %X\n", pPoolHeader->Size, pPoolHeader + 1 );
            DbgPrint( "            Overrun begins at %X\n", pTail-1 );
            DbgBreakPoint();
            return FALSE;
        }
    }

    return TRUE;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\setup\makefile.inc ===
#
# This file is designed to be included from 1 level below
#

.SUFFIXES: .ba0 .bat .in0 .ini

{}.in0{$O)\}.ini:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)

{..\}.in0{$(O)\}.ini:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)

{}.ba0{$(O)\}.bat:

{..\}.ba0{$(O)\}.bat:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\tdihdlr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tdihdlr.c

Abstract:

    This module implements the NT TDI event handler routines.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop
#include "tdikrnl.h"
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCETDI)


extern
NTSTATUS
ReceiveEventHandler(
    IN BOOLEAN             fExpedited,
    IN PRXCE_ADDRESS       pAddress,
    IN PRXCE_VC            pVc,
    IN ULONG               ReceiveFlags,
    IN ULONG               BytesIndicated,
    IN ULONG               BytesAvailable,
    OUT ULONG              *BytesTaken,
    IN PVOID               Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *pIrp              // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
ReceiveEventPostProcessing(
    PRXCE_VC          pVc,
    PRXCE_CONNECTION  pConnection,
    PMDL              pDataBuffer,
    ULONG             DataBufferSize,
    PIRP              *pIrpPointer);

extern VOID
ReceiveDatagramEventPostProcessing(
    PRXCE_ADDRESS     pAddress,
    PMDL              pDataBuffer,
    ULONG             DataBufferSize,
    PIRP              *pIrpPointer);

NTSTATUS
RxTdiConnectEventHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )
/*++

Routine Description:

    This routine is called when a connect request has completed. The connection
    is fully functional when the indication occurs.

Arguments:

    TdiEventContext - the context value passed in by the user in the Set Event Handler call

    RemoteAddressLength,

    RemoteAddress,

    UserDataLength,

    UserData,

    OptionsLength,

    Options,

    ConnectionId

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (RemoteAddressLength);
    UNREFERENCED_PARAMETER (RemoteAddress);
    UNREFERENCED_PARAMETER (UserDataLength);
    UNREFERENCED_PARAMETER (UserData);
    UNREFERENCED_PARAMETER (OptionsLength);
    UNREFERENCED_PARAMETER (Options);
    UNREFERENCED_PARAMETER (ConnectionContext);

    return STATUS_INSUFFICIENT_RESOURCES;       // do nothing
}


NTSTATUS
RxTdiDisconnectEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              DisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              DisconnectInformation,
    IN ULONG              DisconnectFlags
    )
/*++

Routine Description:

    This routine is used as the demultiplexing point for handling any
    connection disconnects for any address registered with the RxCe.

Arguments:

    EventContext         - the hAddress of the associated endpoint.

    ConnectionContext    - the hVc associated with the connection.

    DisconnectIndicators - Value indicating reason for disconnection indication.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_VC               pVc = (PRXCE_VC)ConnectionContext;
    PRXCE_ADDRESS          pAddress = (PRXCE_ADDRESS)EventContext;

    PRXCE_TRANSPORT   pTransport;
    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,RxTdiDisconnectEventHandler);

    try {
        if (RxCeIsVcValid(pVc) &&
            (pVc->pConnection->pAddress == pAddress)) {
            pConnection = pVc->pConnection;

            ASSERT(RxCeIsConnectionValid(pConnection));

            if (
                // There is a event handler associated with this connection
                (pConnection->pHandler != NULL) &&
                // and the disconnect event handler has been specified
                (pConnection->pHandler->RxCeDisconnectEventHandler != NULL)) {

                Status = pConnection->pHandler->RxCeDisconnectEventHandler(
                             pConnection->pContext,
                             pVc,
                             DisconnectDataLength,
                             DisconnectData,
                             DisconnectInformationLength,
                             DisconnectInformation,
                             DisconnectFlags);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg, ("Disconnect event handler notification returned %lx\n",Status));
                }
            }

            // The final action irrespective of the action taken by the handlers specified.
            if (DisconnectFlags & TDI_DISCONNECT_RELEASE) {
                // The disconnect has to be confirmed.
                //      Status = RxTdiDisconnect(
                //                        pTransport,
                //                        pAddress,
                //                        pConnection,
                //                        pVc,
                //                        RXCE_DISCONNECT_RELEASE);
            }

            // Mark the status of the local connection to prevent any subsequent sends
            // on this connection.
            InterlockedCompareExchange(
                &pVc->State,
                RXCE_VC_DISCONNECTED,
                RXCE_VC_ACTIVE);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
RxTdiErrorEventHandler(
    IN PVOID    TdiEventContext,
    IN NTSTATUS Status                // status code indicating error type.
    )
/*++

Routine Description:

    This routine is used as the default error event handler for
    the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TransportEndpoint - Pointer to open file object.

    Status - Status code indicated by this event.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (Status);

    return STATUS_SUCCESS;
}


NTSTATUS
RxTdiReceiveEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *BytesTaken,
    IN PVOID              Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP              *IoRequestPacket   // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the receive event handler for
    the transport endpoint.

Arguments:

    EventContext      - hAddresst.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveIndicators - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/

{
   return ReceiveEventHandler(
              FALSE,                               // regular receive
              (PRXCE_ADDRESS)EventContext,
              (PRXCE_VC)ConnectionContext,
              ReceiveFlags,
              BytesIndicated,
              BytesAvailable,
              BytesTaken,
              Tsdu,
              IoRequestPacket);
}

NTSTATUS
RxTdiReceiveDatagramEventHandler(
    IN PVOID EventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *pIrp                  // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the default receive datagram event
    handler for the transport endpoint.  It is pointed to by a
    field in the TP_ENDPOINT structure for an endpoint when the
    endpoint is created, and also whenever the TdiSetEventHandler
    request is submitted with a NULL EventHandler field.

Arguments:

    EventContext - event context ( hAddress )

    SourceAddress - Pointer to the network name of the source from which
        the datagram originated.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_ADDRESS     pAddress =  (PRXCE_ADDRESS)EventContext;
    PRXCE_TRANSPORT   pTransport;

    PMDL pDataBuffer;
    ULONG             DataBufferSize;

    RxProfile(RxTdi,RxCeReceiveDatagramEventHandler);

    ASSERT(RxCeIsAddressValid(pAddress));

    // Check if we have an event handler associated with this address
    if (
        // There is a event handler associated with this address
        (pAddress->pHandler != NULL)

        &&

        // and the expedited receive datagram handler has been specified
        (pAddress->pHandler->RxCeReceiveDatagramEventHandler != NULL)
        ) {

        Status = pAddress->pHandler->RxCeReceiveDatagramEventHandler(
                     pAddress->pContext,
                     SourceAddressLength,
                     SourceAddress,
                     OptionsLength,
                     Options,
                     ReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     &pDataBuffer,
                     &DataBufferSize);

        switch (Status) {
        case STATUS_SUCCESS:
        case STATUS_DATA_NOT_ACCEPTED:
            break;

        case STATUS_MORE_PROCESSING_REQUIRED:
            ReceiveDatagramEventPostProcessing(
                pAddress,
                pDataBuffer,
                DataBufferSize,
                pIrp);
            break;

        default:
         // log the error.
         break;
        }
    } else {
        // No handler is associated. Take the default action.
        Status = STATUS_DATA_NOT_ACCEPTED;
    }

    return Status;
}


NTSTATUS
RxTdiReceiveExpeditedEventHandler(
    IN PVOID               EventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG               ReceiveFlags,          //
    IN ULONG               BytesIndicated,        // number of bytes in this indication
    IN ULONG               BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG              *BytesTaken,          // number of bytes used by indication routine
    IN PVOID               Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

Arguments:

    EventContext - the context value passed in by the user in the Set Event Handler call

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
   return ReceiveEventHandler(
              TRUE,                               // expedited receive
              (PRXCE_ADDRESS)EventContext,
              (PRXCE_VC)ConnectionContext,
              ReceiveFlags,
              BytesIndicated,
              BytesAvailable,
              BytesTaken,
              Tsdu,
              IoRequestPacket);
}

NTSTATUS
RxTdiSendPossibleEventHandler (
    IN PVOID EventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable)
/*++

Routine Description:

Arguments:

    EventContext - the context value passed in by the user in the Set Event Handler call

    ConnectionContext - connection context of connection which can be sent on

    BytesAvailable - number of bytes which can now be sent

Return Value:

    ignored by the transport

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT   pTransport;
    PRXCE_ADDRESS     pAddress;
    PRXCE_VC          pVc;
    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,RxCeSendPossibleEventHandler);

    pVc = (PRXCE_VC)ConnectionContext;
    pConnection = pVc->pConnection;
    pAddress = pConnection->pAddress;
    pTransport = pAddress->pTransport;

    if (NT_SUCCESS(Status)) {
        // Check if we have an event handler associated with this connection.
        if (
            // There is a event handler associated with this connection
            (pConnection->pHandler != NULL)

            &&

            // and the expedited send possible event handler has been specified
            (pConnection->pHandler->RxCeSendPossibleEventHandler != NULL)
            ) {

            Status = pConnection->pHandler->RxCeSendPossibleEventHandler(
                         pConnection->pContext,
                         pVc,
                         BytesAvailable);
        } else {
            // No handler is associated. Take the default action.
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

NTSTATUS
ReceiveEventHandler(
    IN BOOLEAN             fExpedited,
    IN PRXCE_ADDRESS       pAddress,
    IN PRXCE_VC            pVc,
    IN ULONG               ReceiveFlags,
    IN ULONG               BytesIndicated,
    IN ULONG               BytesAvailable,
    OUT ULONG              *BytesTaken,
    IN PVOID               Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *pIrp              // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the receive event handler for
    the transport endpoint.

Arguments:

    fExpedited        - TRUE if it was a TDI_EXPEDITED_RECEIVE event

    EventContext      - hAddress.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveIndicators - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS          Status = STATUS_UNSUCCESSFUL;

    PMDL              pDataBuffer = NULL;
    ULONG             DataBufferSize;

    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,ReceiveEventHandler);

    ASSERT(RxCeIsVcValid(pVc));

    if (ReceiveFlags & TDI_RECEIVE_PARTIAL) {
        // Stream mode transports always set this flag. They need to be handled in a
        // different way. The clients of RxCe need only be notified when we have
        // receieved a complete TSDU.
        Status = STATUS_DATA_NOT_ACCEPTED;
    } else {
        pConnection = pVc->pConnection;
        ASSERT(RxCeIsConnectionValid(pConnection));

        // Check if we have an event handler associated with this connection.
        if (
            // There is a event handler associated with this connection
            (pConnection->pHandler != NULL)
            ) {
            if (fExpedited) {    // Expedited receive
                // and the expedited receive event handler has been specified
                if (pConnection->pHandler->RxCeReceiveExpeditedEventHandler != NULL) {

                    Status = pConnection->pHandler->RxCeReceiveExpeditedEventHandler(
                                 pConnection->pContext,
                                 pVc,
                                 ReceiveFlags,
                                 BytesIndicated,
                                 BytesAvailable,
                                 BytesTaken,
                                 Tsdu,
                                 &pDataBuffer,
                                 &DataBufferSize);
                }
            } else if (pConnection->pHandler->RxCeReceiveEventHandler != NULL) {
                Status = pConnection->pHandler->RxCeReceiveEventHandler(
                             pConnection->pContext,
                             pVc,
                             ReceiveFlags,
                             BytesIndicated,
                             BytesAvailable,
                             BytesTaken,
                             Tsdu,
                             &pDataBuffer,
                             &DataBufferSize);
            }

            switch (Status) {
            case STATUS_SUCCESS:
            case STATUS_DATA_NOT_ACCEPTED:
                break;

            case STATUS_MORE_PROCESSING_REQUIRED:
                {
                    Status = ReceiveEventPostProcessing(
                                 pVc,
                                 pConnection,
                                 pDataBuffer,
                                 DataBufferSize,
                                 pIrp);
                }
            break;

            default:
                RxDbgTrace(0, Dbg, ("Receive Event Notification returned %lx\n",Status));
                break;
            }
        }
    }

    return Status;
}

NTSTATUS
RxTdiReceiveCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine is invoked upon completion of the reception of the desired amount of
    data.

Arguments:

    pDeviceObject - the device object

    pIrp          - the IRP

    pContext - the connection handle

--*/
{
    PRXCE_VC         pVc = (PRXCE_VC)pContext;

    if (pVc != NULL) {
        NTSTATUS Status;
        ULONG    BytesCopied = (ULONG)pIrp->IoStatus.Information;
        PRXCE_CONNECTION pConnection = pVc->pConnection;

        ASSERT(
            RxCeIsVcValid(pVc) &&
            RxCeIsConnectionValid(pConnection));

        if (pConnection->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pConnection->pHandler->RxCeDataReadyEventHandler(
                         pConnection->pContext,
                         pVc->pReceiveMdl,
                         BytesCopied,
                         pIrp->IoStatus.Status);
        }

        pVc->pReceiveMdl = NULL;
    } else {
        ASSERT(!"Valid connection handle for receive completion");
    }

    RxCeFreeIrp(pIrp);

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ReceiveEventPostProcessing(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection,
    PMDL             pDataMdl,
    ULONG            DataBufferSize,
    PIRP             *pIrpPointer)
/*++

Routine Description:

    This routine is invoked when a recieve event notification to a connection engine client
    results in further requests for copying the data out of the transport drivers buffers

Arguments:

    pDataBuffer   - the buffer into which the data should be copied

    DataBufferSize - the size of the data

    pIrpPointer  - the IRP to the transport driver for processing the copy request.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED -- if successful
    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PRXCE_ADDRESS    pAddress    = pConnection->pAddress;
    PRXCE_TRANSPORT  pTransport  = pAddress->pTransport;
    PIRP             pIrp;

    ASSERT(RxCeIsAddressValid(pAddress));
    ASSERT(RxCeIsTransportValid(pTransport));

    ASSERT(pConnection->pHandler->RxCeDataReadyEventHandler != NULL);

    pIrp = RxCeAllocateIrpWithMDL(pTransport->pDeviceObject->StackSize,FALSE,pDataMdl);
    *pIrpPointer = pIrp;
    if (pIrp != NULL) {
        pVc->pReceiveMdl = pDataMdl;

        TdiBuildReceive(
            pIrp,                                 // the IRP
            pTransport->pDeviceObject,            // the device object
            pVc->pEndpointFileObject,             // the connection (VC) file object
            RxTdiReceiveCompletion,               // Completion routine
            pVc,                                  // completion context
            pDataMdl,                             // the data buffer
            0,                                    // receive flags
            DataBufferSize);                      // receive buffer length

        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but for this IRP it has been bypassed.
        //

        IoSetNextIrpStackLocation(pIrp);
    } else {
        // An IRP for receiving the data was not allocated. Invoke the error handler
        // to communicate the status back.

        ASSERT(pConnection->pHandler->RxCeDataReadyEventHandler != NULL);
        
        if (pConnection->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pConnection->pHandler->RxCeDataReadyEventHandler(
                         pConnection->pContext,
                         pDataMdl,
                         0,
                         STATUS_INSUFFICIENT_RESOURCES);
        }

        Status = STATUS_DATA_NOT_ACCEPTED;
    }

    return Status;
}

NTSTATUS
RxTdiReceiveDatagramCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine is invoked upon completion of the reception of the desired amount of
    data.

Arguments:

    pDeviceObject - the device object

    pIrp   - the IRP

    pContext - the connection handle

--*/
{
    NTSTATUS Status;
    PRXCE_ADDRESS pAddress = (PRXCE_ADDRESS)pContext;

    ASSERT(RxCeIsAddressValid(pAddress));

    if (pAddress != NULL) {
        ULONG BytesCopied = (ULONG)pIrp->IoStatus.Information;

        if (pAddress->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pAddress->pHandler->RxCeDataReadyEventHandler(
                         pAddress->pContext,
                         pAddress->pReceiveMdl,
                         BytesCopied,
                         pIrp->IoStatus.Status);
        }

        pAddress->pReceiveMdl = NULL;
    } else {
        ASSERT(!"Valid Address handle for receive datagram completion");
    }

    RxCeFreeIrp(pIrp);

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
ReceiveDatagramEventPostProcessing(
    PRXCE_ADDRESS          pAddress,
    PMDL                   pDataMdl,
    ULONG                  DataBufferSize,
    PIRP                   *pIrpPointer)
/*++

Routine Description:

    This routine is invoked when a recieve event notification to a connection engine client
    results in further requests for copying the data out of the transport drivers buffers

Arguments:

    pDataBuffer   - the buffer into which the data should be copied

    DataBufferSize - the size of the data

    pIrpPointer  - the IRP to the transport driver for processing the copy request.

Return Value:

    a STATUS_SUCCESS returned from this routine only implies that an IRP for processing
    the request was setup correctly.

--*/
{
    PIRP            pIrp;
    PRXCE_TRANSPORT pTransport = pAddress->pTransport;

    ASSERT(RxCeIsTransportValid(pTransport));
    ASSERT(pAddress->pHandler->RxCeDataReadyEventHandler != NULL);

    *pIrpPointer = pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);
    if (pIrp != NULL) {
        pAddress->pReceiveMdl = pDataMdl;

        TdiBuildReceive(
            pIrp,                                 // the IRP
            pTransport->pDeviceObject,            // the device object
            pAddress->pFileObject,                // the connection (VC) file object
            RxTdiReceiveDatagramCompletion,       // Completion routine
            pAddress,                             // completion context
            pDataMdl,                             // the data buffer
            0,                                    // send flags
            DataBufferSize);                      // send buffer length

        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but for this IRP it has been bypassed.
        //

        IoSetNextIrpStackLocation(pIrp);
    } else {
        // An IRP for receiving the data was not allocated. Invoke the error handler
        // to communicate the status back.
        if (pAddress->pHandler->RxCeErrorEventHandler != NULL) {
            pAddress->pHandler->RxCeErrorEventHandler(
                pAddress->pContext,
                STATUS_INSUFFICIENT_RESOURCES);
        } else {
            // No error handler to handle an erroneous situation.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\setup\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\setup\sources.inc ===
#
# This file is designed to be included from 1 level below
#

RXOBJ = $(O)

SYNCHRONIZE_BLOCK=1

MAJORCOMP=rdr2
MINORCOMP=setup

TARGETNAME=setup
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=


NTTARGETFILE0=\
   $(RXOBJ)\rdr1.bat      \
   $(RXOBJ)\rdr2.bat      \
   $(RXOBJ)\rdr2.ini      \
   $(RXOBJ)\rdr1.ini      \
   $(RXOBJ)\mrxsmb.ini    \
   $(RXOBJ)\rdbss.ini

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
###NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\smbrdr\smbrdr.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    smbrdr.c

Abstract:

    This module implements a simple app to switch between rdr1 and rdr2

Author:

    Joe Linn (JoeLinn) 21-jul-94

Revision History:

    added in stuff to control the filesystem proxy mini AKA the reflector

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "smbrdr.h"

#include <ntddnfs2.h>    //this might should be in smbrdr.h
#include <ntddumod.h>    //this might should be in smbrdr.h

VOID SwRxUsage(void);
VOID SwRxPrintCurrentRdrMsg(void);

BOOLEAN
SwRxIsRdr2Running(
    void);

BOOLEAN SwRxNoStop = FALSE;
BOOLEAN SwRxNoStart = FALSE;
BOOLEAN SwRxProxyEnabled = FALSE;

VOID SwRxStartStop(
    IN PSWRX_REGISTRY_MUCKER Mucker
    )
{
    BOOLEAN Rdr2WasRunning = FALSE;
    BOOLEAN Rdr2IsRunning = FALSE;

    Rdr2WasRunning = SwRxIsRdr2Running();
    if (!SwRxNoStop) {
        printf("Stopping rdr.......\n");
        system("net stop rdr /y");
        if (Rdr2WasRunning) {
            SwRxStopProxyFileSystem();
            printf("Stopping rdbss.......\n");
            system("net stop rdbss /y");
        }
    }
    Mucker();
    if (!SwRxNoStart) {
        printf("Starting rdr\n");
        system("net start rdr");
        printf("Starting messenger\n");
        system("net start messenger");
        printf("Starting netlogon\n");
        system("net start netlogon");
        if (SwRxProxyEnabled) {
            SwRxStartProxyFileSystem();
        }
    }

    Rdr2IsRunning = SwRxIsRdr2Running();

    DbgPrint("SMBRDR: %s was running, %s is running now\n",
              Rdr2WasRunning?"Rdr2":"Rdr1",
              Rdr2IsRunning?"Rdr2":"Rdr1"
              );

}

VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    //NTSTATUS status;
    char *thisarg;
    ULONG i;


    if (argc<2) { SwRxPrintCurrentRdrMsg(); exit(0); }
    for (i=1;i<(ULONG)argc;i++) {
        thisarg=argv[i];

        printf("thisarg=%s,argc=%d\n",thisarg,argc);

        if (!strncmp(thisarg,"/?",2) || !strncmp(thisarg,"-?",2)){
             SwRxUsage();
             }
        if (!strncmp(thisarg,"/1",2) || !strncmp(thisarg,"-1",2)){
            printf("-1 no longer supported\n");
            //SwRxStartStop(SwRxRdr1Muck);
            exit(0);
            }
        if (!strncmp(thisarg,"/2",2) || !strncmp(thisarg,"-2",2)){
            SwRxStartStop(SwRxRdr2Muck);
            exit(0);
            }
        if (!strncmp(thisarg,"-!",2)){
            SwRxNoStop = TRUE;
            SwRxNoStart = TRUE;
            continue;
        }
        if (!strncmp(thisarg,"-proxy",6)){
            SwRxProxyEnabled = TRUE;
            continue;
        }
        if (!strncmp(thisarg,"-startproxy",11)){
            SwRxStartProxyFileSystem();
            exit(0);
        }

        break;

    }
    SwRxUsage();

}

VOID SwRxUsage(void){
    printf("    Usage: smbrdr [-!] [-1|-2]   ");
    SwRxPrintCurrentRdrMsg();
    exit(0);
}


VOID SwRxPrintCurrentRdrMsg(void){
    PSZ notstring = "not ";

    if (SwRxIsRdr2Running()) {
        notstring = "";
    }
    printf("  (Currently, rdr2 is %srunning.)\n",notstring);
}


BOOLEAN
SwRxIsRdr2Running(
    void)

/*++

Routine Description:

    This routine looks to see if the rdr is rdr2 by
    opening a handle and pushing down a FSCTL that rdr1 handles
    and rdr2 does not.

Arguments:

    HANDLE pRdrHandle - a handle to be returned

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    HANDLE              h;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    //
    // Open the RDBSS device.
    //
    RtlInitUnicodeString(&DeviceName,DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &h,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    //return(ntstatus);
    if (!NT_SUCCESS(ntstatus)) {
        printf("open didn't work\n");
        return(FALSE);
    }

    //
    // Send the request to the RDBSS FSD.
    //
    ntstatus = NtFsControlFile(
                   h,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   FSCTL_LMR_GET_VERSIONS,
                   NULL,
                   0,
                   NULL,
                   0
                   );

    NtClose(h);
    return(ntstatus==STATUS_INVALID_DEVICE_REQUEST);
}

VOID
SwRxStartProxyFileSystem(void){
    NTSTATUS            ntstatus;
    HANDLE              h;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    //UNICODE_STRING      LinkTarget,VNetRootPart;
    //WCHAR               StringBuffer[512];

    //
    // Get the driver loaded.
    //

    if (SwRxProxyEnabled) {
        printf("Starting proxy driver.......\n");
        system("net start reflctor");
    }

    //
    // Open the Proxy FileSystem driver device.
    //
    RtlInitUnicodeString(&DeviceName,UMRX_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &h,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    //
    // if we couldn't open.....just punt
    //

    if (!NT_SUCCESS(ntstatus)) {
        printf("Couldn't open the ProxyFilesystem device\n");
        return;
    }

    //
    // Send the start request...this will also set up the server, netroot
    // and vnetroot
    //

    ntstatus = NtFsControlFile(
                   h,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   FSCTL_UMRX_START,
                   NULL,
                   0,
                   NULL,
                   0
                   );

    NtClose(h);

    //
    // now we have to do the bit about making the dosdevice

    if (! DefineDosDeviceW(
              DDD_RAW_TARGET_PATH |
                DDD_NO_BROADCAST_SYSTEM,
              L"X:",
              UMRX_DEVICE_NAME_U L"\\;X:"
              UMRX_CLAIMED_SERVERNAME_U
              UMRX_CLAIMED_SHARENAME_U
              )) {

        printf("Couldn't set X: as a dosdevice\n");
    }
}

VOID
SwRxStopProxyFileSystem(void){
    NTSTATUS            ntstatus;
    HANDLE              h;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    //UNICODE_STRING      LinkTarget,VNetRootPart;
    //WCHAR               StringBuffer[512];

    //
    // Open the Proxy FileSystem driver device.
    //
    RtlInitUnicodeString(&DeviceName,UMRX_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &h,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    //
    // if we couldn't open.....just punt
    //

    if (!NT_SUCCESS(ntstatus)) {
        printf("Couldn't open the ProxyFilesystem device\n");
        return;
    }

    //
    // Send the stop request...this will also set up the server, netroot
    // and vnetroot
    //

    ntstatus = NtFsControlFile(
                   h,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   FSCTL_UMRX_STOP,
                   NULL,
                   0,
                   NULL,
                   0
                   );

    NtClose(h);

    //
    // now we have to get rid of the dosdevice

    if (! DefineDosDeviceW(
              DDD_REMOVE_DEFINITION  |
                 DDD_RAW_TARGET_PATH |
                 DDD_EXACT_MATCH_ON_REMOVE |
                 DDD_NO_BROADCAST_SYSTEM,
          L"X:",
          UMRX_DEVICE_NAME_U L"\\;X:"
          UMRX_CLAIMED_SERVERNAME_U
          UMRX_CLAIMED_SHARENAME_U
              )) {

        printf("Couldn't set X: as a dosdevice\n");

    }

    if (SwRxProxyEnabled) {
        printf("Stopping proxy driver.......\n");
        system("net stop reflctor /y");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\smbrdr\regmuck.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    regmuck.c

Abstract:

    This module contains the routines for mucking with the registry for smbrdr.exe

Author:

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "smbrdr.h"


// Global Registry key definitions for the new Redirector


// the key definition is relative to HKEY_LOCAL_MACHINE
#define RDBSS_REGISTRY_KEY   L"System\\CurrentControlSet\\Services\\Rdbss"
#define MRXSMB_REGISTRY_KEY  L"System\\CurrentControlSet\\Services\\MRxSmb"
#define MRXPROXY_REGISTRY_KEY  L"System\\CurrentControlSet\\Services\\Reflctor"

//most of the keynames are not #defined even if they were it wouldn't be here
//#define MINI_REDIRECTORS     L"MiniRedirectors"
#define LAST_LOAD_STATUS     L"LastLoadStatus"

#define SwRxSetRegX(KEYHANDLE,NAME,REGTYPE,VALUEASPTR,VALUESIZE) {        \
    TempStatus = RegSetValueEx(               \
                      KEYHANDLE,              \
                      NAME,                   \
                      0,                      \
                      REGTYPE,                \
                      VALUEASPTR,             \
                      VALUESIZE);             \
    if (TempStatus != ERROR_SUCCESS) {    \
        printf("ERROR (%d) in adjusting the registry: cant store %ws\n", \
                    TempStatus,NAME);                             \
        RegCloseKey(KEYHANDLE);                                                    \
        return(TempStatus);                                                  \
    }                                     \
}

#define SwRxSetRegDword(KEYHANDLE,NAME,VALUE) {        \
    DWORD DwordValue = VALUE;                          \
    SwRxSetRegX(KEYHANDLE,NAME,REG_DWORD,((PCHAR)&DwordValue),sizeof(DWORD));         \
}

#define SwRxSetRegSz(KEYHANDLE,NAME,VALUE) {        \
    SwRxSetRegX(KEYHANDLE,NAME,REG_SZ,((PCHAR)VALUE),sizeof(VALUE));         \
}

#define SwRxSetRegExpandSz(KEYHANDLE,NAME,VALUE) {        \
    SwRxSetRegX(KEYHANDLE,NAME,REG_EXPAND_SZ,((PCHAR)VALUE),sizeof(VALUE));         \
}

#define SwRxSetRegMultiSz(KEYHANDLE,NAME,VALUE) {        \
    SwRxSetRegX(KEYHANDLE,NAME,REG_MULTI_SZ,((PCHAR)VALUE),sizeof(VALUE));         \
}



#define SwRxCreateKey(KEYHANDLE,KEYNAME) {           \
    DWORD           Disposition;               \
    TempStatus = RegCreateKeyEx (              \
                     HKEY_LOCAL_MACHINE,       \
                     KEYNAME,                  \
                     0,                        \
                     NULL,                     \
                     0,                        \
                     KEY_ALL_ACCESS,           \
                     NULL,                     \
                     &KEYHANDLE,               \
                     &Disposition              \
                                );             \
                                               \
    if (TempStatus != ERROR_SUCCESS) {    \
        printf("ERROR (%d) in adjusting the registry: cant create key %ws\n", \
                    TempStatus,KEYNAME);                                      \
        return(TempStatus);                                                   \
    }                                     \
}

extern BOOLEAN SwRxProxyEnabled;
NET_API_STATUS
SwRxRdr2Muck(
    void
    )
{
    NET_API_STATUS  TempStatus;
    HKEY            hRedirectorKey;

    printf("Adjusting the registry for Rdr2\n");

    //altho the code for the three different drivers is essentially similar, it is
    // not combined so that it can be changed more readily

    if (SwRxProxyEnabled) {
//\registry\machine\system\currentcontrolset\services\reflctor
//    Type = REG_DWORD 0x00000002
//    Start = REG_DWORD 0x00000003
//    ErrorControl = REG_DWORD 0x00000001
//    ImagePath = REG_EXPAND_SZ \SystemRoot\System32\drivers\reflctor.sys
//    DisplayName = mrxproxy
//    Group = Network
//    Linkage
//        Disabled
//    Parameters
//    Security

        SwRxCreateKey(hRedirectorKey,MRXPROXY_REGISTRY_KEY L"\\Linkage\\Disabled");
        RegCloseKey(hRedirectorKey);
        SwRxCreateKey(hRedirectorKey,MRXPROXY_REGISTRY_KEY L"\\Parameters");
        RegCloseKey(hRedirectorKey);
        SwRxCreateKey(hRedirectorKey,MRXPROXY_REGISTRY_KEY L"\\Security");
        RegCloseKey(hRedirectorKey);

        SwRxCreateKey(hRedirectorKey,MRXPROXY_REGISTRY_KEY);
        SwRxSetRegDword(hRedirectorKey,L"Type",0x00000002);
        SwRxSetRegDword(hRedirectorKey,L"Start",0x00000003);
        SwRxSetRegDword(hRedirectorKey,L"ErrorControl",0x00000001);

        SwRxSetRegSz(hRedirectorKey,L"DisplayName",L"Reflctor");
        SwRxSetRegSz(hRedirectorKey,L"Group",L"Network");

        SwRxSetRegExpandSz(hRedirectorKey,L"ImagePath",L"System32\\drivers\\reflctor.sys");

        RegCloseKey(hRedirectorKey);

    }

    printf("no longer muck with mrxsmb or rdbss\n");
#if 0
//\registry\machine\system\currentcontrolset\services\mrxsmb
//    Type = REG_DWORD 0x00000002
//    Start = REG_DWORD 0x00000003
//    ErrorControl = REG_DWORD 0x00000001
//    ImagePath = REG_EXPAND_SZ \SystemRoot\System32\drivers\mrxsmb.sys
//    DisplayName = mrxsmb
//    Group = Network
//    Linkage
//        Disabled
//    Parameters
//    Security

    SwRxCreateKey(hRedirectorKey,MRXSMB_REGISTRY_KEY L"\\Linkage\\Disabled");
    RegCloseKey(hRedirectorKey);
    SwRxCreateKey(hRedirectorKey,MRXSMB_REGISTRY_KEY L"\\Parameters");
    RegCloseKey(hRedirectorKey);
    SwRxCreateKey(hRedirectorKey,MRXSMB_REGISTRY_KEY L"\\Security");
    RegCloseKey(hRedirectorKey);

    SwRxCreateKey(hRedirectorKey,MRXSMB_REGISTRY_KEY);
    SwRxSetRegDword(hRedirectorKey,L"Type",0x00000002);
    SwRxSetRegDword(hRedirectorKey,L"Start",0x00000003);
    SwRxSetRegDword(hRedirectorKey,L"ErrorControl",0x00000001);

    SwRxSetRegSz(hRedirectorKey,L"DisplayName",L"MRxSmb");
    SwRxSetRegSz(hRedirectorKey,L"Group",L"Network");

    SwRxSetRegExpandSz(hRedirectorKey,L"ImagePath",L"\\SystemRoot\\System32\\drivers\\mrxsmb.sys");

    SwRxSetRegDword(hRedirectorKey,LAST_LOAD_STATUS,0);

    RegCloseKey(hRedirectorKey);


//\registry\machine\system\currentcontrolset\services\rdbss
//    Type = REG_DWORD 0x00000002
//    Start = REG_DWORD 0x00000003
//    ErrorControl = REG_DWORD 0x00000001
//    ImagePath = REG_EXPAND_SZ \SystemRoot\System32\drivers\rdbss.sys
//    DisplayName = Rdbss
//    Group = Network
//    LastLoadStatus = REG_DWORD 0x0
//    Linkage
//        Disabled
//    Parameters
//    Security

    SwRxCreateKey(hRedirectorKey,RDBSS_REGISTRY_KEY L"\\Linkage\\Disabled");
    RegCloseKey(hRedirectorKey);
    SwRxCreateKey(hRedirectorKey,RDBSS_REGISTRY_KEY L"\\Parameters");
    RegCloseKey(hRedirectorKey);
    SwRxCreateKey(hRedirectorKey,RDBSS_REGISTRY_KEY L"\\Security");
    RegCloseKey(hRedirectorKey);

    SwRxCreateKey(hRedirectorKey,RDBSS_REGISTRY_KEY);
    SwRxSetRegDword(hRedirectorKey,L"Type",0x00000002);
    SwRxSetRegDword(hRedirectorKey,L"Start",0x00000003);
    SwRxSetRegDword(hRedirectorKey,L"ErrorControl",0x00000001);

    SwRxSetRegSz(hRedirectorKey,L"DisplayName",L"Rdbss");
    SwRxSetRegSz(hRedirectorKey,L"Group",L"Network");

    SwRxSetRegExpandSz(hRedirectorKey,L"ImagePath",L"\\SystemRoot\\System32\\drivers\\rdbss.sys");

    RegCloseKey(hRedirectorKey);

    ////now put in the new minirdr enumeration
    ///SwRxCreateKey(hRedirectorKey,RDBSS_REGISTRY_KEY L"\\MiniRdrs");
    //SwRxSetRegDword(hRedirectorKey,L"MRxSmb",0xbaadf00d);
    //SwRxSetRegDword(hRedirectorKey,L"MRxFtp00",0xbaadf10d);
    //SwRxSetRegDword(hRedirectorKey,L"MRxNfs",0xbaadf20d);
    //SwRxSetRegDword(hRedirectorKey,L"MRxNcp6",0xbaadf30d);
    //RegCloseKey(hRedirectorKey);
#endif
    return ERROR_SUCCESS;

}

NET_API_STATUS
SwRxRdr1Muck(
    void
    )
{
    NET_API_STATUS  TempStatus;
    HKEY            hRedirectorKey;
    DWORD           FinalStatus;

    printf("Adjusting the registry for Rdr1...........\n");
    TempStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    MRXSMB_REGISTRY_KEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hRedirectorKey);

    if (TempStatus == ERROR_SUCCESS) {

        //the value 0 would mean load rdr2; the value 0x15 (ERROR_NOT_READY)
        //would mean load rdr1 BUT ONLY IS THE RDR IS NOT RUNNING. 0x1 means
        //start rdr1 on the next load

        SwRxSetRegDword(hRedirectorKey,LAST_LOAD_STATUS,0x1);

        RegCloseKey(hRedirectorKey);
    }

    return ERROR_SUCCESS;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\wmi\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\wmi\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\daytona\tdimisc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT TDI related routines used by RXCE. The wrappers are necessary to
    ensure that all the OS dependencies can be localized to select modules like this for
    customization.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

--*/

#include "precomp.h"
#pragma  hdrstop

ULONG
ComputeTransportAddressLength(
      PTRANSPORT_ADDRESS pTransportAddress)
/*++

Routine Description:

   computes the length in bytes of a TRANSPORT_ADDRESS structure

Arguments:

    pTransportAddress - TRANSPORT_ADDRESS instance

Return Value:

    the length of the instance in bytes

Notes:

    Since this structure is packed the arithmetic has to be done using unaligned pointers.

--*/
{
   ULONG Size = 0;

   if (pTransportAddress != NULL) {
      LONG Index;

      TA_ADDRESS *pTaAddress;

      Size  = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) +
              FIELD_OFFSET(TA_ADDRESS,Address) * pTransportAddress->TAAddressCount;

      pTaAddress = (TA_ADDRESS *)pTransportAddress->Address;

      for (Index = 0;Index <pTransportAddress->TAAddressCount;Index++) {
         Size += pTaAddress->AddressLength;
         pTaAddress = (TA_ADDRESS *)((PCHAR)pTaAddress +
                                               FIELD_OFFSET(TA_ADDRESS,Address) +
                                               pTaAddress->AddressLength);
      }
   }

   return Size;
}

PIRP
RxCeAllocateIrpWithMDL(
      IN CCHAR    StackSize,
      IN BOOLEAN  ChargeQuota,
      IN PMDL     Buffer)
/*++

Routine Description:

   computes the length in bytes of a TRANSPORT_ADDRESS structure

Arguments:

    pTransportAddress - TRANSPORT_ADDRESS instance

Return Value:

    the length of the instance in bytes

Notes:

    Currently the RxCeAllocateIrp and RxCeFreeIrp are implemented as wrappers around the
    IO calls. One possible optimization to consider would be to maintain a pool of IRP's
    which can be reused.

--*/
{
    PIRP pIrp = NULL;
    PRX_IRP_LIST_ITEM pListItem = NULL;

    pIrp = IoAllocateIrp(StackSize,ChargeQuota);

    if (pIrp != NULL) {
        pListItem = RxAllocatePoolWithTag(
                         NonPagedPool,
                         sizeof(RX_IRP_LIST_ITEM),
                         RX_IRPC_POOLTAG);

        if (pListItem == NULL) {
            IoFreeIrp(pIrp);
            pIrp = NULL;
        } else {
            KIRQL SavedIrql;

            pListItem->pIrp = pIrp;
            pListItem->CopyDataBuffer = Buffer;
            pListItem->Completed = 0;
            InitializeListHead(&pListItem->IrpsList);

            KeAcquireSpinLock(&RxIrpsListSpinLock,&SavedIrql);
            InsertTailList(&RxIrpsList,&pListItem->IrpsList);
            KeReleaseSpinLock(&RxIrpsListSpinLock,SavedIrql);
        }
    }

    return pIrp;
}

VOID
RxCeFreeIrp(PIRP pIrp)
/*++

Routine Description:

   frees an IRP

Arguments:

    pIrp - IRP to be freed

--*/
{
    KIRQL SavedIrql;
    PLIST_ENTRY pListEntry;
    BOOLEAN IrpFound = FALSE;
    PRX_IRP_LIST_ITEM pListItem = NULL;

    KeAcquireSpinLock(&RxIrpsListSpinLock,&SavedIrql);
    
    pListEntry = RxIrpsList.Flink;

    while (pListEntry != &RxIrpsList) {
        pListItem = CONTAINING_RECORD(
                        pListEntry,
                        RX_IRP_LIST_ITEM,
                        IrpsList);

        if (pListItem->pIrp == pIrp) {
            IrpFound = TRUE;
            //ASSERT(pListItem->Completed);
            RemoveEntryList(pListEntry);
            RxFreePool(pListItem);
            break;
        } else {
            pListEntry = pListEntry->Flink;
        }
    }

    KeReleaseSpinLock(&RxIrpsListSpinLock,SavedIrql);

    ASSERT(IrpFound);

    IoFreeIrp(pIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\smbrdr\smbrdr.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    smbrdr.h

Abstract:


Author:

Revision History:

--*/

#ifndef _SWITCHRX_INCLUDED_
#define _SWITCHRX_INCLUDED_

#include <lmcons.h>

#if DBG

#define STATIC

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if ( TRUE )

#else

#define STATIC static

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG

NET_API_STATUS
SwRxRdr2Muck(
    void
    );
NET_API_STATUS
SwRxRdr1Muck(
    void
    );

VOID
SwRxStartProxyFileSystem(void);

VOID
SwRxStopProxyFileSystem(void);

typedef
NET_API_STATUS
(*PSWRX_REGISTRY_MUCKER)(
    void
    );
#endif   // ifndef _SWITCHRX_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\wmi\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "stdio.h"

#include <wmistr.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    //DbgPrint("WMI disable\n");
                    Ctx->EnableLevel = 0;
                    Ctx->EnableFlags = 0;
                    Ctx->LoggerHandle = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmiGetLoggerEnableLevel(Ctx->LoggerHandle); // UCHAR
                    Ctx->EnableFlags = WmiGetLoggerEnableFlags(Ctx->LoggerHandle); // ULONG
                    //DbgPrint("WMI enable: %lx %lx\n",Ctx->EnableLevel,Ctx->EnableFlags);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

#define MAX_SCRATCH_LOG 256

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    union {
        MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
        UCHAR     ScratchPad[MAX_SCRATCH_LOG];
    };

} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    TRACE_BUFFER TraceBuffer;
    va_list ArgList;
    ULONG Length;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    va_start(ArgList, FormatString);
    Length = _vsnprintf(TraceBuffer.ScratchPad, MAX_SCRATCH_LOG, FormatString, ArgList);
    TraceBuffer.ScratchPad[Length] = 0;
    va_end(ArgList);


    TraceBuffer.Wnode.BufferSize = 
        (ULONG) ((ULONG_PTR)(TraceBuffer.ScratchPad + Length) - (ULONG_PTR)&TraceBuffer);
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsinit\dfsinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Code to force dfs volume initialization and validation
//
//  Classes:
//
//  Functions:  main
//
//  History:    March 24, 1994          Milans Created
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <dfsfsctl.h>


//
// Get rid of this file, after we remove it from the placefil.txt
//
//

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

void _cdecl main(
    int argc,
    char *argv[])
{
    NTSTATUS Status;

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\sources.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sources.inc

!ENDIF


INCLUDES=.; \
         ..; \
         $(PROJECT_ROOT)\fs\remotefs\dfs\inc; \
         $(PROJECT_ROOT)\ntos\inc; \
	 $(DS_INC_PATH)\dfs


MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /W3 /WX

RUN_WPP=$(SOURCES) -ini:$(PROJECT_ROOT)\fs\remotefs\dfs\inc\tracewpp.ini

LINKER_STACKCOMMITSIZE=32768
COMPILER_WARNINGS=/FI$(PROJECT_ROOT)\fs\remotefs\dfs\inc\dfswarnings.h


PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\wmi\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal

#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_ZERO((_value)[0],CHAR), _value )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value)[0],WCHAR), _value)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)

#define LOGVAL(_val)        (sizeof(_val)), (&(_val)),

#define WML_FLAGS(_Val)  ( (ULONG)(_Val) )
#define WML_STREAM(_Val) ( (ULONG)(_Val) )

#define WML_CONTROL(_prefix, _stream) \
            ( _prefix ## ControlGuids[ WML_STREAM(_stream) ] )
            
#define WML_ENABLED(_prefix, _stream, _level, _flags) \
            (( WML_CONTROL(_prefix, _stream).EnableLevel >= (_level) ) &&   \
             ( WML_CONTROL(_prefix, _stream).EnableFlags & WML_FLAGS(_flags) ))
            
#define WML_TRACEGUID(_prefix, _stream, _id) \
            ( WML_CONTROL(_prefix, _stream).TraceGuids[ WML_GUID(_id) ] )
            
#define WML_LOG(_prefix, _stream, _level, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, _arg); \
        } \
    } while (0)            

#define WML_PRINTF(_prefix, _stream, _level, _flags, _id, _fmtstr, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlPrintf( WML_ID(_id), \
                      &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, \
                      _fmtstr, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\referralserver\apisupport.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <lm.h>
#include <lmdfs.h>
#include <netdfs.h>
#include <DfsServerLibrary.hxx>
#include <validc.h>
#include "ReferralServerLog.hxx"
//
// logging specific includes
//

#include "apisupport.tmh"


extern ULONG Flags;
CRITICAL_SECTION DfsApiLock;
BOOL DfsLockInitialized = FALSE;
BOOL ServerListen = FALSE;

//
// Checks if the token contains all valid characters
//
#define SPACE_STR           L" "

#define STANDARD_ILLEGAL_CHARS  ILLEGAL_NAME_CHARS_STR L"*"
#define SERVER_ILLEGAL_CHARS    STANDARD_ILLEGAL_CHARS SPACE_STR

#define IS_VALID_TOKEN(_Str, _StrLen) \
    ((BOOLEAN) (wcscspn((_Str), STANDARD_ILLEGAL_CHARS) == (_StrLen)))

//
// Checks if the server name contains all valid characters for the server name
//
#define IS_VALID_SERVER_TOKEN(_Str, _StrLen) \
    ((BOOLEAN) (wcscspn((_Str), SERVER_ILLEGAL_CHARS) == (_StrLen)))
    


#define DFS_API_START( Status )                        \
         Status = DfsSetupRpcImpersonation();           \
         if (Status != ERROR_SUCCESS)                  \
         {                                             \
             Status = ERROR_ACCESS_DENIED;             \
         }                                             \
         if (Status == ERROR_SUCCESS)                  \
         {                                             \
             __try                                     \
             {                                         \
                 EnterCriticalSection( &DfsApiLock );  \
                 Status = ERROR_SUCCESS;               \
             }                                         \
             __except( EXCEPTION_EXECUTE_HANDLER)      \
             {                                         \
                 Status = GetExceptionCode();          \
             }                                         \
             if (Status == ERROR_SUCCESS)              \
             {                                         \
                 __try                                 \
                 {                                     


#define DFS_API_END( Status )                          \
                 }                                     \
                 __except( EXCEPTION_EXECUTE_HANDLER)  \
                 {                                     \
                     Status = GetExceptionCode();      \
                 }                                     \
                 LeaveCriticalSection( &DfsApiLock);   \
             }                                         \
             DfsTeardownRpcImpersonation();            \
         }

NET_API_STATUS
DfsEnum200(
    IN LPWSTR DfsName,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle);


NET_API_STATUS
DfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle);

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetVersion
//
//  Synopsis:   Returns the version of this server side implementation.
//
//  Arguments:  None.
//
//  Returns:    The version number.
//
//-----------------------------------------------------------------------------

DWORD
NetrDfsManagerGetVersion()
{
    DWORD Version = 3;

    return( Version );
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd 
//  Synopsis:   
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume/link to be created, or
//                      to which a replica should be added.
//              [ServerName] -- Name of server backing the volume.
//              [ShareName] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this volume, only used
//                      when DFS_ADD_VOLUME is specified.
//              [Flags] -- If DFS_ADD_VOLUME, a new volume will be created.
//                      If DFS_ADD_LINK, a new link to another Dfs will be
//                      create. If 0, a replica will be added.
//
//  Returns:    [NERR_Success] -- Operation succeeded.
// 
//              Error other wise.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs Add %ws %ws %ws\n", DfsEntryPath, ServerName, ShareName);

    DFS_API_START( Status );

    Status = DfsAdd( DfsEntryPath,
                     ServerName,
                     ShareName,
                     Comment,
                     Flags );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add %ws, Status 0x%x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd2
//
//  Synopsis:   Adds a volume/replica/link to this Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume/link to be created, or
//                      to which a replica should be added.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- Name of server backing the volume.
//              [ShareName] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this volume, only used
//                      when DFS_ADD_VOLUME is specified.
//              [Flags] -- If DFS_ADD_VOLUME, a new volume will be created.
//                      If DFS_ADD_LINK, a new link to another Dfs will be
//                      create. If 0, a replica will be added.
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              Erroroce otherwise.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs Add2 %ws DC:%ws Server:%ws Share:%ws\n", DfsEntryPath, DcName, ServerName, ShareName);

    DFS_API_START( Status );

    //
    // For now, we dont use DC name or pprootlist. We will use
    // this once we implement domain dfs.
    //
    UNREFERENCED_PARAMETER( DcName );
    UNREFERENCED_PARAMETER( ppRootList );

    Status = DfsAdd( DfsEntryPath,
                     ServerName,
                     ShareName,
                     Comment,
                     Flags );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add2 %ws, Status 0x%x\n", DfsEntryPath, Status);
    return Status;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetDcAddress
//
//  Synopsis:   Gets the DC to go to so that we can create an FtDfs object for
//              this server.
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [IsRoot] -- TRUE if this server is a Dfs root, FALSE otherwise
//              [Timeout] -- Timeout, in sec, that the server will stay with this DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetDcAddress(
    IN LPWSTR ServerName,
    IN OUT LPWSTR *DcName,
    IN OUT BOOLEAN *IsRoot,
    IN OUT ULONG *Timeout)
{
    UNREFERENCED_PARAMETER(ServerName);
    //
    // Currently, not supported
    //
    *DcName = (LPWSTR)MIDL_user_allocate(4);
    (*DcName)[0] = L' ';
    (*DcName)[1] = 0;

    *IsRoot = FALSE;
    *Timeout = 1000;

    return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetDcAddress
//
//  Synopsis:   Sets the DC to go to for the dfs blob
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [Timeout] -- Time, in sec, to stay with that DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetDcAddress(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN ULONG Timeout,
    IN DWORD Flags)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(Timeout);
    UNREFERENCED_PARAMETER(Flags);

    //
    // Currently, not supported
    //

    return ERROR_SUCCESS;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsFlushFtTable
//
//  Synopsis:   Flushes an FtDfs entry from the FtDfs cache
//
//  Arguments:  [DcName] -- Dc to use
//              [FtDfsName] -- Name of FtDfs
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsFlushFtTable(
    IN LPWSTR DcName,
    IN LPWSTR FtDfsName)
{
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(FtDfsName);

    //
    // This will NEVER be supported.
    //

    return ERROR_NOT_SUPPORTED;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRoot
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN DWORD  ApiFlags)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs Add Std Root Server:%ws, Share:%ws\n", ServerName, RootShare);
    DFS_API_START( Status );

    if (Flags & DFS_LOCAL_NAMESPACE)
    {
        ServerName = NULL;
    }
    //
    // Add a standalone root.
    //
    Status = DfsAddStandaloneRoot( ServerName,
                                   RootShare,
                                   Comment,
                                   ApiFlags );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add Std Root %ws\n", RootShare);
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRootForced
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Share] -- drive:\dir behind the share
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRootForced(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN LPWSTR Share)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(RootShare);
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Share);
    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove (Obsolete)
//
//  Synopsis:   Deletes a volume/replica/link from the Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry path of the volume to operate on.
//              [ServerName] -- If specified, indicates the replica of the
//                      volume to operate on.
//              [ShareName] -- If specified, indicates the share on the
//                      server to operate on.
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------


extern "C" NET_API_STATUS
NetrDfsRemove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs remove %ws\n", DfsEntryPath);
    //
    // call DfsRemove to do this operation.
    //

    DFS_API_START( Status );
    Status = DfsRemove( DfsEntryPath,
                        ServerName,
                        ShareName );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove2
//
//  Synopsis:   Deletes a volume/replica/link from the Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry path of the volume to operate on.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- If specified, indicates the replica of the
//                      volume to operate on.
//              [ShareName] -- If specified, indicates the share on the
//                      server to operate on.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemove2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(ppRootList);
    
    NET_API_STATUS Status;

    //
    // For now we ignore the DcName and rootlist, these are needed
    // when we implement dom dfs.
    //

    DFS_TRACE_HIGH( API, "Net Dfs remove2 %ws\n", DfsEntryPath);

    DFS_API_START( Status );

    Status = DfsRemove( DfsEntryPath,
                        ServerName,
                        ShareName );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove2 %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}





//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveStdRoot
//
//  Synopsis:   Deletes a Dfs root
//
//  Arguments:  [ServerName] -- The server to remove.
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN DWORD  Flags)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(Flags);
    
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs remove std root %ws\n", RootShare);
    
    DFS_API_START( Status );

    Status = DfsDeleteStandaloneRoot( RootShare );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove std root %ws, Status %x\n", RootShare, Status);

    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo (Obsolete)
//
//  Synopsis:   Sets the comment, volume state, or replica state.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of the volume for which info is
//                      to be set.
//              [ServerName] -- If specified, the name of the server whose
//                      state is to be set.
//              [ShareName] -- If specified, the name of the share on
//                      ServerName whose state is to be set.
//              [Level] -- Level of DfsInfo
//              [DfsInfo] -- The actual Dfs info.
//
//  Returns:    [NERR_Success] -- Operation completed successfully.
//
//-----------------------------------------------------------------------------


extern "C" NET_API_STATUS
NetrDfsSetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT pDfsInfo)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs set info %ws\n", DfsEntryPath);
    DFS_API_START( Status );

    Status = DfsSetInfo( DfsEntryPath,
                         ServerName,
                         ShareName,
                         Level,
                         (LPBYTE)pDfsInfo );

    DFS_API_END( Status );
    
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs set info %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo2
//
//  Synopsis:   Sets the comment, volume state, or replica state.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of the volume for which info is
//                      to be set.
//              [ServerName] -- If specified, the name of the server whose
//                      state is to be set.
//              [ShareName] -- If specified, the name of the share on
//                      ServerName whose state is to be set.
//              [Level] -- Level of DfsInfo
//              [DfsInfo] -- The actual Dfs info.
//
//  Returns:    [NERR_Success] -- Operation completed successfully.
//
//              [ERROR_INVALID_LEVEL] -- Level != 100 , 101, or 102
//
//              [ERROR_INVALID_PARAMETER] -- DfsEntryPath invalid, or
//                      ShareName specified without ServerName.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to
//                      a valid Dfs volume.
//
//              [NERR_DfsNoSuchShare] -- The indicated ServerName/ShareName do
//                      not support this Dfs volume.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetInfo2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT pDfsInfo,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status;

    UNREFERENCED_PARAMETER(ppRootList);
    UNREFERENCED_PARAMETER(DcName);

    DFS_TRACE_HIGH( API, "Net Dfs set info2 %ws\n", DfsEntryPath);
    //
    // DcName and rootlist not supported, for now.
    //
    DFS_API_START( Status );

    Status = DfsSetInfo( DfsEntryPath,
                         ServerName,
                         ShareName,
                         Level,
                         (LPBYTE)pDfsInfo );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs set info %ws, Status %x\n", DfsEntryPath, Status);

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetInfo
//
//  Synopsis:   Server side implementation of the NetDfsGetInfo.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume for which info is
//                      requested.
//
//              [ServerName] -- Name of server which supports this volume
//                      and for which info is requested.
//
//              [ShareName] -- Name of share on ServerName which supports this
//                      volume.
//
//              [Level] -- Level of Info requested.
//
//              [DfsInfo] -- On successful return, contains a pointer to the
//                      requested DFS_INFO_x struct.
//
//  Returns:    [NERR_Success] -- If successfully returned requested info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    OUT LPDFS_INFO_STRUCT pDfsInfo)
{
    LONG BufferSize, SizeRequired;
    ULONG MaxRetry;
    NET_API_STATUS Status;
    PDFS_INFO_1 pInfo1;

    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(ShareName);

    DFS_TRACE_HIGH( API, "Net Dfs get info %ws\n", DfsEntryPath);

    MaxRetry = 5;
    BufferSize = sizeof(DFS_INFO_STRUCT);

    DFS_API_START( Status );

    do
    {
        pInfo1 = (PDFS_INFO_1)MIDL_user_allocate(BufferSize);
        if (pInfo1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else 
        {
            Status = DfsGetInfo( DfsEntryPath,
                                 Level,
                                 (LPBYTE)pInfo1,
                                 BufferSize,
                                 &SizeRequired );
            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                MIDL_user_free(pInfo1);
                BufferSize = SizeRequired;
            }
        }
    } while ( (Status == ERROR_BUFFER_OVERFLOW) && (MaxRetry--) );

    if (Status == ERROR_SUCCESS)
    {
        pDfsInfo->DfsInfo1 = pInfo1;
    }

    DFS_API_END( Status );
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs get info %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnum
//
//  Synopsis:   The server side implementation of the NetDfsEnum public API
//
//  Arguments:  [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnum(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs enum %d\n", Level);
    DFS_API_START( Status );
    //
    // We just call NetRDfsEnumEx with a null pathname.
    //
    Status = DfsEnumEx( NULL,
                        Level,
                        PrefMaxLen,
                        pDfsEnum,
                        pResumeHandle );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs enum %d, Status %x\n", Level, Status);
    return Status;
}

#if 0
//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnum200
//
//  Synopsis:   Handles level 200 for NetrDfsEnum, server-side implementation
//
//  Arguments:  [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NetrDfsEnum200(
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    ULONG BufferSize, SizeRequired;
    ULONG MaxRetry, EntriesRead;
    NET_API_STATUS Status;
    LPDFS_INFO_1 pInfo1;

    DFS_TRACE_HIGH( API, "Net Dfs enum 200\n");

    DFS_API_START( Status );

    Status = DfsEnum200( PrefMaxLen,
                         pDfsEnum,
                         pResumeHandle );

    DFS_API_END( Status );
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs enum 200, Status %x\n", Status);

    return Status;
}
#endif

NET_API_STATUS
DfsEnum200(
    IN LPWSTR DfsName,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    UNREFERENCED_PARAMETER(PrefMaxLen);

    ULONG BufferSize, SizeRequired;
    ULONG MaxRetry, EntriesRead;
    NET_API_STATUS Status;
    LPDFS_INFO_1 pInfo1;

    MaxRetry = 5;
    BufferSize = sizeof(DFS_INFO_1);
    do
    {
        pInfo1 = (LPDFS_INFO_1)MIDL_user_allocate( BufferSize );
        if (pInfo1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else 
        {
            Status = DfsEnumerateRoots ( DfsName,
                                         (LPBYTE)pInfo1,
                                         BufferSize,
                                         &EntriesRead,
                                         pResumeHandle,
                                         &SizeRequired );
            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                MIDL_user_free( pInfo1 );
                BufferSize = SizeRequired;
            }
        }
    } while ( (Status == ERROR_BUFFER_OVERFLOW) && (MaxRetry--) );
    if (Status == ERROR_SUCCESS)
    {
        pDfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = pInfo1;
        pDfsEnum->Level = 200;
        pDfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = EntriesRead;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnumEx
//
//  Synopsis:   The DC implementation of the NetDfsEnum public API
//
//  Arguments:  [DfsName] -- The Dfs to enumerate (\\domainname\ftdfsname)
//              [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{

    NET_API_STATUS Status;

    DFS_TRACE_HIGH( API, "Net Dfs enum ex %ws\n", DfsName);
    DFS_API_START( Status );

    Status = DfsEnumEx( DfsName,
                        Level,
                        PrefMaxLen,
                        pDfsEnum,
                        pResumeHandle);

    DFS_API_END( Status );
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs enum ex %ws, Status %x\n", DfsName, Status);

    return Status;

}

NET_API_STATUS
DfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    LONG BufferSize, SizeRequired;
    ULONG MaxRetry, EntriesRead;
    NET_API_STATUS Status;
    LPDFS_INFO_1 pInfo1;

    if (Level == 200)
    {
        Status = DfsEnum200( DfsName,
                             PrefMaxLen,
                             pDfsEnum,
                             pResumeHandle );
    }
    else {
        MaxRetry = 5;
        BufferSize = sizeof(DFS_INFO_1);
        do
        {
            pInfo1 = (LPDFS_INFO_1) MIDL_user_allocate( BufferSize );
            if (pInfo1 == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                Status = DfsEnumerate( DfsName,
                                       Level,
                                       PrefMaxLen,
                                       (LPBYTE)pInfo1,
                                       BufferSize,
                                       &EntriesRead,
                                       pResumeHandle,
                                       &SizeRequired );

                if (Status == ERROR_BUFFER_OVERFLOW)
                {
                    MIDL_user_free( pInfo1 );
                    BufferSize = SizeRequired;
                }
            }
        } while ( (Status == ERROR_BUFFER_OVERFLOW) && (MaxRetry--) );

        if (Status == ERROR_SUCCESS)
        {
            pDfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = pInfo1;
            pDfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = EntriesRead,
                pDfsEnum->Level = Level;
        }
    }

    return Status;
}




//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetConfigInfo
//
//  Synopsis:   RPC Interface method that returns the config info for a
//              Dfs volume for a given server
//
//  Arguments:  [wszServer] -- Name of server requesting the info. This
//                      server is assumed to be requesting the info for
//                      verification of its local volume knowledge.
//              [wszLocalVolumeEntryPath] -- Entry path of local volume.
//              [idLocalVolume] -- The guid of the local volume.
//              [ppRelationInfo] -- The relation info is allocated and
//                      returned here.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerGetConfigInfo(
    IN LPWSTR wszServer,
    IN LPWSTR wszLocalVolumeEntryPath,
    IN GUID idLocalVolume,
    OUT LPDFSM_RELATION_INFO *ppRelationInfo)
{
    UNREFERENCED_PARAMETER( wszServer);
    UNREFERENCED_PARAMETER( wszLocalVolumeEntryPath);
    UNREFERENCED_PARAMETER( idLocalVolume);
    UNREFERENCED_PARAMETER( ppRelationInfo);

    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
    
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerSendSiteInfo
//
//  Synopsis:   RPC Interface method that reports the site information for a
//              Dfs storage server.
//
//  Arguments:  [wszServer] -- Name of server sending the info.
//              [pSiteInfo] -- The site info is here.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerSendSiteInfo(
    IN LPWSTR wszServer,
    IN LPDFS_SITELIST_INFO pSiteInfo)
{
    UNREFERENCED_PARAMETER( wszServer);
    UNREFERENCED_PARAMETER( pSiteInfo);

    //
    // This will probably be never supported.
    //

    return ERROR_NOT_SUPPORTED;
    
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerInitialize
//
//  Synopsis:   Reinitializes the service
//
//  Arguments:  [ServerName] -- Name of server
//              [Flags] -- Flags for the operation
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsManagerInitialize(
    IN LPWSTR ServerName,
    IN DWORD  Flags)
{
    UNREFERENCED_PARAMETER( ServerName);
    UNREFERENCED_PARAMETER( Flags);
    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsMove
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [DfsEntryPath] -- Current entry path of Dfs volume.
//
//              [NewEntryPath] -- New entry path of Dfs volume.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsMove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR NewDfsEntryPath)
{
    UNREFERENCED_PARAMETER( DfsEntryPath);
    UNREFERENCED_PARAMETER( NewDfsEntryPath);
    //
    // This will definitely be never supported.
    //

    return ERROR_NOT_SUPPORTED;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRename
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [Path] -- Current path along the entry path of a Dfs volume.
//
//              [NewPath] -- New path for current path.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRename(
    IN LPWSTR Path,
    IN LPWSTR NewPath)
{
    UNREFERENCED_PARAMETER( Path);
    UNREFERENCED_PARAMETER( NewPath);
    //
    // This will definitely be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}



// ====================================================================
//                MIDL allocate and free
//
//  These routines are used by the RPC layer to call back into our
// code to allocate or free memory. 
//
// ====================================================================

PVOID
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

VOID
MIDL_user_free(void * ptr)
{
    free(ptr);
}


//+-------------------------------------------------------------------------
//
//  Function:   RpcInit - Initialize the RPC for this server.
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS if we initialized without errors
//
//  Description: This routine sets up the RPC server to listen to the
//               api requests originating from the clients.
//
//--------------------------------------------------------------------------


DWORD
DfsApiInit()
{
    RPC_STATUS Status;
    LPWSTR ProtocolSequence = L"ncacn_np";
    unsigned char * Security     = NULL; /*Security not implemented */
    LPWSTR Endpoint    = L"\\pipe\\netdfs";
    unsigned int    cMinCalls      = 1;
    unsigned int    cMaxCalls      = RPC_C_LISTEN_MAX_CALLS_DEFAULT;
    unsigned int    fDontWait      = TRUE;
 
    InitializeCriticalSection( &DfsApiLock );

    DfsLockInitialized = TRUE;

    //
    // We register our protocol, and startup a server to listen to RPC
    // requests. A new server thread is started, so that our thread 
    // can return back to the caller.
    //
    Status = RpcServerUseProtseqEpW((USHORT *)ProtocolSequence,
                                   cMaxCalls,
                                   (USHORT *)Endpoint,
                                   Security); 
 
    if (Status == ERROR_SUCCESS) 
    {
        Status = RpcServerRegisterIf(netdfs_ServerIfHandle,  
                                     NULL,   
                                     NULL); 

        if (Status == ERROR_SUCCESS) 
        {
            Status = RpcServerListen(cMinCalls,
                                     cMaxCalls,
                                     fDontWait);
            if (Status == RPC_S_OK ) 
            {
                ServerListen = TRUE;
            }
        }
    }
 
    return Status;
}


void
DfsApiShutDown(void)
{
    RPC_STATUS Status = RPC_S_OK;

    //
    // stop server listen.
    //

    if(ServerListen)
    {

        Status = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( Status == RPC_S_OK) 
         {
           Status = RpcMgmtWaitServerListen();
         }

        ServerListen = FALSE;
    }

    Status = RpcServerUnregisterIf(netdfs_ServerIfHandle,
                                   NULL,      
                                   TRUE);  // wait for calls to complete

    if(DfsLockInitialized)
    {
        DeleteCriticalSection(&DfsApiLock);
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddFtRoot
//
//  Synopsis:   Creates a new FtDfs, or joins a Server into an FtDfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- DC to use
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [FtDfsName] -- The Name of the FtDfs to create/join
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN LPWSTR Comment,
    IN LPWSTR ConfigDN,
    IN BOOLEAN NewFtDfs,
    IN DWORD  ApiFlags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status;
    UNREFERENCED_PARAMETER( ConfigDN);

    if ( (DcName == NULL) || (DcName[0] == UNICODE_NULL) ||
         (RootShare == NULL) || (RootShare[0] == UNICODE_NULL) ||
         (FtDfsName == NULL) || (FtDfsName[0] == UNICODE_NULL) ||
         (ServerName == NULL) || (ServerName[0] == UNICODE_NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }
#if 0
    if ( (IS_VALID_TOKEN(FtDfsName, wcslen(FtDfsName)) == FALSE) ||
         (IS_VALID_SERVER_TOKEN(ServerName, wcslen(ServerName)) == FALSE) )
    {
        return ERROR_INVALID_NAME;
    }
#endif
    DFS_TRACE_HIGH( API, "Net Dfs Add FT Root %ws\n", RootShare);
    DFS_API_START( Status );


    Status = DfsAddADBlobRoot( ServerName,
                               DcName,
                               RootShare,
                               FtDfsName,
                               Comment,
                               NewFtDfs,
                               ApiFlags,
                               (PVOID)ppRootList );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add AD blob Root %ws\n", RootShare);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveFtRoot
//
//  Synopsis:   Deletes a root from an FtDfs.
//
//  Arguments:  [ServerName] -- The server to remove.
//              [DcName] -- DC to use
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [FtDfsName] -- The FtDfs to remove the root from.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN DWORD  ApiFlags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status;

    if ( (DcName == NULL) || (DcName[0] == UNICODE_NULL) ||
         (RootShare == NULL) || (RootShare[0] == UNICODE_NULL) ||
         (FtDfsName == NULL) || (FtDfsName[0] == UNICODE_NULL) ||
         (ServerName == NULL) || (ServerName[0] == UNICODE_NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (IS_VALID_TOKEN(FtDfsName, wcslen(FtDfsName)) == FALSE) ||
         (IS_VALID_SERVER_TOKEN(ServerName, wcslen(ServerName)) == FALSE) )
    {
        return ERROR_INVALID_NAME;
    }

    DFS_TRACE_HIGH( API, "Net Dfs Remove FT Root %ws\n", RootShare);
    DFS_API_START( Status );

    Status = DfsDeleteADBlobRoot( ServerName,
                                  DcName,
                                  RootShare,
                                  FtDfsName,
                                  ApiFlags,
                                  (PVOID)ppRootList );

    DFS_API_END( Status );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Remove AD blob Root %ws\n", RootShare);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\referralserver\netdfs_s_stub.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       netdfs_s_stub.c
//
//  Contents:   This is a stub file that includes the actual RPC server
//              file generated by the idl compiler. This server file
//              generated exists in a different depot, and we unfortunately
//              have to go through this hoop to compile the RPC server.
//
//  History:    Feb. 8 2001,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "netdfs_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\klogmacros.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       kLogMacros.c
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    March 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------
       
#include "ntifs.h"
#include <windef.h>
              
#define _NTDDK_
#include "stdarg.h"
#include "wmikm.h"
#include <wmistr.h>
#include <evntrace.h>

#include <wmiumkm.h>
#include "dfswmi.h"  
   
#include "kLogMacros.h"
#include "kLogMacros.tmh"

PVOID pkUmrControl = NULL;

void SetUmrControl(WPP_CB_TYPE * Control)
{
    pkUmrControl = (PVOID)Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\dfsumrctrl.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       dfsumr.c
//
//  Contents:   
//
//
//  Functions:  
//
//  Author - Rohan Phillips     (Rohanp)
//-----------------------------------------------------------------------------


 
#include "ntifs.h"
#include <windef.h>
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>
#include <dfsumr.h>
#include <umrx.h>
#include <dfsumrctrl.h>
               
#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, DfsInitializeUmrResources)
#pragma alloc_text(PAGE, DfsDeInitializeUmrResources)
#pragma alloc_text(PAGE, DfsWaitForPendingClients)
#pragma alloc_text(PAGE, DfsStartupUMRx)
#pragma alloc_text(PAGE, DfsTeardownUMRx)
#pragma alloc_text(PAGE, DfsProcessUMRxPacket)
#pragma alloc_text(PAGE, AddUmrRef)
#pragma alloc_text(PAGE, ReleaseUmrRef)
#pragma alloc_text(PAGE, IsUmrEnabled)
#pragma alloc_text(PAGE, LockUmrShared)
#pragma alloc_text(PAGE, GetUMRxEngineFromRxContext)
#endif

#define DFS_INIT_REFLOCK     0x00000001
#define DFS_INIT_UMRXENG     0x00000002
#define DFS_INIT_CONTEXT     0x00000004

//
// Number of usecs that the thread disabling the reflection should wait
//   between checks.  negative value for relative time.
//   1,000,000 usecs => 1 sec
//
#define DFS_UMR_DISABLE_DELAY  -100000

BOOL ReflectionEngineInitialized = FALSE;

ULONG cUserModeReflectionsInProgress = 0;

NTSTATUS  g_CheckStatus = 0xFFFFFFFF;

DWORD InitilizationStatus = 0;

PERESOURCE gReflectionLock = NULL;

PUMRX_ENGINE g_pUMRxEngine = NULL;


PERESOURCE 
CreateResource(void )   ;


void 
ReleaseResource(PERESOURCE  pResource )   ;

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeUmrResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Initializes all resources neder for the usermode reflector
//
//--------------------------------------------------------------------------
NTSTATUS 
DfsInitializeUmrResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    gReflectionLock = CreateResource();
    if(gReflectionLock != NULL)
    {
        InitilizationStatus |=  DFS_INIT_REFLOCK;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    g_pUMRxEngine = CreateUMRxEngine();
    if(g_pUMRxEngine != NULL)
    {
        InitilizationStatus |=  DFS_INIT_UMRXENG;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    Status = DfsInitializeContextResources();
    if(Status == STATUS_SUCCESS)
    {
       InitilizationStatus |=  DFS_INIT_CONTEXT;
    }

Exit:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsDeInitializeUmrResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Releases all resources neder for the usermode reflector
//
//--------------------------------------------------------------------------
void 
DfsDeInitializeUmrResources(void)
{
    PAGED_CODE();

    if(InitilizationStatus & DFS_INIT_REFLOCK)
    {
        ReleaseResource(gReflectionLock);
        gReflectionLock = NULL;
    }

    if(InitilizationStatus & DFS_INIT_UMRXENG)
    {
        if(g_pUMRxEngine != NULL)
        {
            FinalizeUMRxEngine (g_pUMRxEngine);
            g_pUMRxEngine = NULL;
        }
    }


    if(InitilizationStatus & DFS_INIT_CONTEXT)
    {
        DfsDeInitializeContextResources();
    }

}

PERESOURCE 
CreateResource(void )   
{
    PERESOURCE  pResource = NULL;

    PAGED_CODE();

    pResource = ExAllocatePoolWithTag(  NonPagedPool,
                                        sizeof( ERESOURCE ),
                                        'DfsR');
    if( pResource ) 
    {
        if( !NT_SUCCESS( ExInitializeResourceLite( pResource ) ) ) 
        {
            ExFreePool( pResource ) ;
            pResource = NULL ;
        }
    }

    return  pResource ;
}

void 
ReleaseResource(PERESOURCE  pResource )   
{
    PAGED_CODE();

    ASSERT( pResource != 0 ) ;

    if( pResource ) 
    {
        ExDeleteResourceLite( pResource ) ;
        ExFreePool( pResource ) ;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsEnableReflectionEngine 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Changes the reflector state to stopped
//
//--------------------------------------------------------------------------
NTSTATUS
DfsEnableReflectionEngine(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ReflectionEngineInitialized = TRUE;


    if(g_pUMRxEngine)
    {
        InterlockedExchange(&g_pUMRxEngine->Q.State,
                            UMRX_ENGINE_STATE_STOPPED);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsWaitForPendingClients 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Waits for all clients to exit relector before returning
//
//--------------------------------------------------------------------------
NTSTATUS
DfsWaitForPendingClients(void)
{
    BOOLEAN fDone = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER liDelay;

    liDelay.QuadPart = DFS_UMR_DISABLE_DELAY;

    PAGED_CODE();

    while (!fDone)
    {   
        ExAcquireResourceExclusiveLite(&g_pUMRxEngine->Q.Lock,TRUE);
        
        if (ReflectionEngineInitialized)
        {
            if (0 == g_pUMRxEngine->cUserModeReflectionsInProgress)
            {
                fDone = TRUE;
            }
            else
            {
            }
        }
        else
        {
            fDone = TRUE;
        }
        
        ExReleaseResourceForThreadLite(&g_pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
        
        if (!fDone)
        {
            KeDelayExecutionThread(UserMode, FALSE, &liDelay);
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsStartupUMRx 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the reflector engine
//
//--------------------------------------------------------------------------
NTSTATUS
DfsStartupUMRx(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    ExAcquireResourceExclusiveLite(gReflectionLock,TRUE);

    Status = UMRxEngineRestart(g_pUMRxEngine);

    if(Status == STATUS_SUCCESS)
    {
        ReflectionEngineInitialized = TRUE;
    }

    ExReleaseResourceForThreadLite(gReflectionLock,ExGetCurrentResourceThread());
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsTeardownUMRx 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Stops the reflector engine
//
//--------------------------------------------------------------------------
NTSTATUS
DfsTeardownUMRx(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(g_pUMRxEngine)
    {

      Status = UMRxEngineReleaseThreads(g_pUMRxEngine);

      Status = DfsWaitForPendingClients();

    }

    ReflectionEngineInitialized = FALSE;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessUMRxPacket 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Processes a packet from usermode
//
//--------------------------------------------------------------------------
NTSTATUS
DfsProcessUMRxPacket(
        IN PVOID InputBuffer,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer,
        IN ULONG OutputBufferLength,
        IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOLEAN fReturnImmediately = FALSE;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    if ((InputBuffer == NULL) && (OutputBuffer == NULL))
    {
        UMRxEngineCompleteQueuedRequests(
                 g_pUMRxEngine,
                 STATUS_INSUFFICIENT_RESOURCES,
                 FALSE);
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    //  Recd a response packet from umode - process it
    //
    Status = UMRxCompleteUserModeRequest(
                g_pUMRxEngine,
                (PUMRX_USERMODE_WORKITEM) InputBuffer,
                InputBufferLength,
                TRUE,
                &Iosb,
                &fReturnImmediately
                );

    if( !NT_SUCCESS(Iosb.Status) ) 
    {
    }

    if (fReturnImmediately)
    {
         pIoStatusBlock->Status = STATUS_SUCCESS;
         pIoStatusBlock->Information = 0;
         goto Exit;
    }


    //
    //  Remove a request from the Engine and process it
    //
    Status = UMRxEngineProcessRequest(
                 g_pUMRxEngine,
                 (PUMRX_USERMODE_WORKITEM) OutputBuffer,
                 OutputBufferLength,
                 &OutputBufferLength
                 );

    if( !NT_SUCCESS(Status) ) 
    {
        //
        //  error processing request
        //
    }

    pIoStatusBlock->Information = OutputBufferLength;

Exit:

    pIoStatusBlock->Status = Status;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   AddUmrRef 
//
//  Arguments:  
//
//  Returns:    Number of clients using reflector
//
//
//  Description: Increments the number of clients using the reflector
//
//--------------------------------------------------------------------------
LONG
AddUmrRef(void)

{
    LONG cRefs = 0;

    PAGED_CODE();

    cRefs = InterlockedIncrement(&g_pUMRxEngine->cUserModeReflectionsInProgress);
        
    //DFS_TRACE_HIGH (KUMR_DETAIL, "AddUmrRef %d\n", cRefs);
    ASSERT(cRefs > 0);
    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseUmrRef 
//
//  Arguments:  
//
//  Returns:    Number of clients using reflector
//
//
//  Description: Deccrements the number of clients using the reflector
//
//--------------------------------------------------------------------------
LONG
ReleaseUmrRef(void)
{
    LONG cRefs = 0;

    PAGED_CODE();

    cRefs = InterlockedDecrement(&g_pUMRxEngine->cUserModeReflectionsInProgress);
        
    //DFS_TRACE_HIGH (KUMR_DETAIL, "ReleaseUmrRef %d\n", cRefs);
    //ASSERT(cRefs >= 0); //this is a harmless assert. It's removed for now.
    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetUMRxEngineFromRxContext 
//
//  Arguments:  
//
//  Returns:    A pointer to the reflector engine
//
//
//  Description: returns a pointer to the reflector engine
//
//--------------------------------------------------------------------------
PUMRX_ENGINE 
GetUMRxEngineFromRxContext(void)
{
    PAGED_CODE();
    return g_pUMRxEngine;
}
                
BOOL IsUmrEnabled(void)
{
    PAGED_CODE();
    return ReflectionEngineInitialized;
}

BOOLEAN LockUmrShared(void)
{
    BOOLEAN fAcquired = FALSE;

    PAGED_CODE();

    fAcquired = ExAcquireResourceSharedLite(&g_pUMRxEngine->Q.Lock, FALSE);

    return fAcquired;
}


void UnLockUmrShared(void)
{
    PAGED_CODE();

    ExReleaseResourceForThreadLite (&g_pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\referralserver\referralserver.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include <shellapi.h>
#include <ole2.h>
#include <activeds.h>
#include <DfsServerLibrary.hxx>
#include "ReferralServerLog.hxx"

#include "ReferralServer.tmh"

extern
void 
SetReferralControl(WPP_CB_TYPE * Control);

#define PRINTF printf



DWORD
DfsApiInit();

extern
void
DfsApiShutDown(void);

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

VOID
ReferralServerUsage();

VOID
StartDfsService(
    DWORD dwNumServiceArgs, 
    LPWSTR *lpServiceArgs);

DFSSTATUS
DfsStartupServer();

VOID DfsSvcMsgProc(
    DWORD dwControl);

static void
UpdateServiceStatus(
    SERVICE_STATUS_HANDLE hService, 
    SERVICE_STATUS *pSStatus, 
    DWORD Status);

VOID
DfsSvcMsgProc(
    DWORD dwControl);

SERVICE_STATUS          ServiceStatus;
SERVICE_STATUS_HANDLE   hDfsService;

const PWSTR             wszDfsServiceName = L"DfsService";

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;


//
// The arguments we accept at commandline.
//
MAKEARG(Name);
SWITCH(L);
SWITCH(D);
SWITCH(M);
SWITCH(NoService);
SWITCH(Trace);

ULONG Flags = DFS_LOCAL_NAMESPACE;

#if defined (DFS_RUN_SERVICE)

//+----------------------------------------------------------------------------
//
//  Function:  WinMain
//
//  Synopsis:  This guy will set up link to service manager and install
//             ServiceMain as the service's entry point. Hopefully, the service
//             control dispatcher will call ServiceMain soon thereafter.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpszCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    SERVICE_TABLE_ENTRYW        aServiceEntry[2];
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw,i;
    LPWSTR CommandLine;
    BOOL fConsole = TRUE;
    HANDLE StdOut = NULL;

    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];
    
    WPP_INIT_TRACING(L"DfsReferralServer");

    SetReferralControl(pLogger);

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            PRINTF("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    if (Status == ERROR_SUCCESS)
    {
        if (fSwitchNoService != TRUE)
        {
            aServiceEntry[0].lpServiceName = wszDfsServiceName;
            aServiceEntry[0].lpServiceProc = StartDfsService;
            aServiceEntry[1].lpServiceName = NULL;
            aServiceEntry[1].lpServiceProc = NULL;

            if (!StartServiceCtrlDispatcherW(aServiceEntry)) {
                return(GetLastError());
            }

            return(0);
        }
        else 
        {
#if 0
           int hCrt;
            FILE *hf;

            //allocate a consol
            fConsole = AllocConsole();

            //get a CRT version of the STD output handle we just opened
            hCrt = _open_osfhandle(
                            (long) GetStdHandle(STD_OUTPUT_HANDLE),
                            _O_TEXT
                            );

            //associate a new stream with the new std output handle
            hf = _fdopen( hCrt, "w" );

            //replace the global std output handle
            *stdout = *hf;

            //remove buffering
            i = setvbuf( stdout, NULL, _IONBF, 0 ); 

#endif
            Status = DfsStartupServer();
            while (Status == ERROR_SUCCESS)
            {
                Sleep(3000000);
            }
            PRINTF("DfsServer is exiting with status %x\n", Status);
            exit(0);
        }
    }
    WPP_CLEANUP();
    exit(1);
}

#if 0
VOID
__cdecl MyPrintf(
    LPSTR lpFmt,
    ...
    )
{
    va_list base;

    va_start(base,lpFmt);

    wvsprintf(vrgchLibBuff, lpFmt, base);
    OutputDebugString(vrgchLibBuff);
}
#endif
#else
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw,i;
    SERVICE_TABLE_ENTRYW        aServiceEntry[2];
    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];
    
    WPP_INIT_TRACING(L"DfsReferralServer");

    SetReferralControl(pLogger);

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            printf("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsStartupServer();

        DFS_TRACE_HIGH(REFERRAL_SERVER,"ReferralServer Initialized with error %x", Status);
        
        while (Status == ERROR_SUCCESS)
        {
            Sleep(3000000);
        }
    }

    printf("DfsServer is exiting with status %x\n", Status);
    WPP_CLEANUP();
    exit(0);

}
#endif // DFS_NO_SERVICE

DFSSTATUS
DfsStartupServer()
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HRESULT hr = S_OK;


    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);

    //
    // Initialize the server.
    //  
    if (Flags & DFS_LOCAL_NAMESPACE)
    {
        Flags |= DFS_CREATE_DIRECTORIES;
    }

    Status = DfsServerInitialize( Flags );
    if (Status == ERROR_SUCCESS) {
        //
        // initialize the DfS api.
        //

        Status = DfsApiInit();
    }

    return Status;
}

void
DfsShutdownServer(void)
{
    DfsApiShutDown();

    CoUninitialize();
}

//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NameSpace;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            }
            else {
                Status = DfsAddHandledNamespace( NameSpace, TRUE );
            }
        }
        else if (_wcsicmp(Arg, SwitchTrace) == 0)
        {
            fSwitchTrace = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchL) == 0)
        {
            fSwitchL = TRUE;
            Flags |= DFS_LOCAL_NAMESPACE;
        }
        else if (_wcsicmp(Arg, SwitchNoService) == 0)
        {
            fSwitchNoService = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchD) == 0)
        {
            Flags |= DFS_CREATE_DIRECTORIES;
        }
        else if (_wcsicmp(Arg, SwitchM) == 0)
        {
            Flags |= DFS_MIGRATE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ReferralServerUsage()
{
    printf("Usage:\n");
    printf("/D - Create directories\n");
    printf("/L - Run on the local root server\n");
    printf("/M - Migrate existing DFS to allow multiple roots\n");
    printf("/Name:<Namespace> - Handle referrals to the specified namespace\n");
    printf("/NoService - Dont start as a service\n");
    printf("/trace - enable tracing\n");

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   StartDfsService
//
//  Synopsis:   Call back for DfsService service. This is called *once* by the
//              Service controller when the DfsService service is to be inited
//              This function is responsible for registering a message
//              handler function for the DfsService service.
//
//  Arguments:  Unused
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
StartDfsService(
    DWORD dwNumServiceArgs, 
    LPWSTR *lpServiceArgs)
{
    DFSSTATUS Status;

    UNREFERENCED_PARAMETER(dwNumServiceArgs);
    UNREFERENCED_PARAMETER(lpServiceArgs);


    hDfsService = RegisterServiceCtrlHandlerW( wszDfsServiceName,
                                               DfsSvcMsgProc);
    if (!hDfsService) {
        return;
    }
    
    ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    ServiceStatus.dwWin32ExitCode = 0;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 1000 * 30;

    UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_START_PENDING);

    Status = DfsStartupServer();
    if (Status == ERROR_SUCCESS)
    {
        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_RUNNING);
    }
    else {
        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_STOPPED);
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:  DfsSvcMsgProc
//
//  Synopsis:  Service-Message handler for DFSInit.
//
//  Arguments: [dwControl] - the message
//
//  Returns:   nothing
//
//-----------------------------------------------------------------------------

VOID
DfsSvcMsgProc(DWORD dwControl)
{
    switch(dwControl) {

    case SERVICE_CONTROL_STOP:
        //
        // dfsdev: need to do something to stop the service!
        //
        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_STOPPED);


        CoUninitialize();
        break;

    case SERVICE_INTERROGATE:
        UpdateServiceStatus( hDfsService, &ServiceStatus, ServiceStatus.dwCurrentState);
        break;

    default:
        break;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:  UpdateServiceStatus
//
//  Synopsis:  Pushes a ServiceStatus to the service manager.
//
//  Arguments: [hService] - handle returned from RegisterServiceCtrlHandler
//             [pSStatus] - pointer to service-status block
//             [Status] -   The status to set.
//
//  Returns:   Nothing.
//
//-----------------------------------------------------------------------------

static void
UpdateServiceStatus(
    SERVICE_STATUS_HANDLE hService, 
    SERVICE_STATUS *pSStatus, 
    DWORD Status)
{
    pSStatus->dwCurrentState = Status;

    if (Status == SERVICE_START_PENDING) {
        pSStatus->dwCheckPoint++;
        pSStatus->dwWaitHint = 1000;
    } else {
        pSStatus->dwCheckPoint = 0;
        pSStatus->dwWaitHint = 0;
    }

    SetServiceStatus(hService, pSStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\referralserver\netdfs_s.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for netdfs.idl, dfssrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   953                               
#define PROC_FORMAT_STRING_SIZE   1255                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 24 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 26 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 30 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 32 */	NdrFcLong( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0x1 ),	/* 1 */
/* 38 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 46 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 54 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 56 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 60 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 66 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 72 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 76 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 78 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 84 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 86 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 90 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 92 */	NdrFcLong( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 106 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 114 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 116 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 118 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 120 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 124 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 154 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x3 ),	/* 3 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 162 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 164 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 166 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 174 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 186 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 188 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 190 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 194 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 198 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 206 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 214 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 216 */	NdrFcShort( 0x3 ),	/* 3 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 222 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 224 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 226 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 230 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 232 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 234 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 236 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 238 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 240 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 246 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Return value */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 268 */	NdrFcShort( 0x2c ),	/* 44 */
/* 270 */	NdrFcShort( 0x24 ),	/* 36 */
/* 272 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 274 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 276 */	NdrFcShort( 0x8 ),	/* 8 */
/* 278 */	NdrFcShort( 0x8 ),	/* 8 */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 294 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 298 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 300 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 304 */	NdrFcShort( 0x2d6 ),	/* Type Offset=726 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 312 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 328 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 336 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 338 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 340 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 342 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 344 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 346 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 348 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 350 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 354 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x7 ),	/* 7 */
/* 362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 370 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 380 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 382 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 388 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 396 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 406 */	NdrFcShort( 0x30 ),	/* 48 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 412 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 416 */	NdrFcShort( 0x1 ),	/* 1 */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 420 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 422 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 424 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 426 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 432 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 434 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 436 */	NdrFcShort( 0x108 ),	/* Type Offset=264 */

	/* Parameter ppRelationInfo */

/* 438 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 440 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 442 */	NdrFcShort( 0x2da ),	/* Type Offset=730 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 450 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* 8 */
/* 464 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 474 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 476 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 478 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 480 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 482 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 484 */	NdrFcShort( 0x34e ),	/* Type Offset=846 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 492 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0xa ),	/* 10 */
/* 500 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0xd ),	/* 13 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 508 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 510 */	NdrFcShort( 0x1 ),	/* 1 */
/* 512 */	NdrFcShort( 0x1 ),	/* 1 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 516 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 522 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 526 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 528 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 532 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 534 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 538 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 540 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 542 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 544 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 548 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 550 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 556 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 560 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 564 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 566 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 568 */	NdrFcShort( 0x36a ),	/* Type Offset=874 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 576 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0xb ),	/* 11 */
/* 584 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 592 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 594 */	NdrFcShort( 0x1 ),	/* 1 */
/* 596 */	NdrFcShort( 0x1 ),	/* 1 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 600 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 602 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 604 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 606 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 610 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 612 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 616 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 618 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 622 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 624 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 630 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 632 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 634 */	NdrFcShort( 0x36a ),	/* Type Offset=874 */

	/* Return value */

/* 636 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 638 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 642 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 644 */	NdrFcLong( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0xc ),	/* 12 */
/* 650 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 656 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 658 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 666 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 668 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 670 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 672 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 674 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 676 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 678 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 682 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 686 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 692 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 696 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xd ),	/* 13 */
/* 704 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 710 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 712 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 720 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 722 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 724 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 726 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 730 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 738 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 744 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 746 */	NdrFcLong( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0xe ),	/* 14 */
/* 752 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 754 */	NdrFcShort( 0x8 ),	/* 8 */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 760 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 768 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 770 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 772 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 780 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 786 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 788 */	NdrFcLong( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0xf ),	/* 15 */
/* 794 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 802 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 810 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 812 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 814 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 816 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 820 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 822 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 826 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 828 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 832 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 840 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x10 ),	/* 16 */
/* 848 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 850 */	NdrFcShort( 0x35 ),	/* 53 */
/* 852 */	NdrFcShort( 0x3d ),	/* 61 */
/* 854 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 856 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 864 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 866 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 868 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 870 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 872 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 874 */	NdrFcShort( 0x39e ),	/* Type Offset=926 */

	/* Parameter IsRoot */

/* 876 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 878 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 880 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 882 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 884 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 894 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0x11 ),	/* 17 */
/* 902 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 904 */	NdrFcShort( 0x10 ),	/* 16 */
/* 906 */	NdrFcShort( 0x8 ),	/* 8 */
/* 908 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 910 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 914 */	NdrFcShort( 0x0 ),	/* 0 */
/* 916 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 920 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 922 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 924 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 926 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 928 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 932 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 936 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 938 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 944 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 948 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x12 ),	/* 18 */
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x8 ),	/* 8 */
/* 962 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 964 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 972 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 974 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 976 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 978 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 980 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 982 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 986 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 990 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x13 ),	/* 19 */
/* 998 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1004 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1006 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1008 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1010 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1014 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1016 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1018 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1020 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1022 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1024 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1026 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1028 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1030 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1034 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1036 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1038 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1040 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1042 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1044 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1046 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1050 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1052 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1054 */	NdrFcShort( 0x36a ),	/* Type Offset=874 */

	/* Return value */

/* 1056 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1058 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1062 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1064 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1068 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1070 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1078 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1080 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1082 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1086 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1088 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1090 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1092 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1096 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1098 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1102 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1104 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1108 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1110 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1112 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1114 */	NdrFcShort( 0x36a ),	/* Type Offset=874 */

	/* Return value */

/* 1116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1118 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1122 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1124 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1130 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1132 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1134 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1136 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1138 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1142 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1146 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1148 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1150 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1154 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1160 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1164 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1166 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1168 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 1170 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1172 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1174 */	NdrFcShort( 0x2d6 ),	/* Type Offset=726 */

	/* Return value */

/* 1176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1178 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1182 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1190 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1192 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1194 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1196 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1198 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1200 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1202 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1206 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1208 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1210 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1212 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1214 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1216 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1222 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1226 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1228 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1230 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1232 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1236 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1238 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1240 */	NdrFcShort( 0x3ae ),	/* Type Offset=942 */

	/* Parameter ppRootList */

/* 1242 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1246 */	NdrFcShort( 0x36a ),	/* Type Offset=874 */

	/* Return value */

/* 1248 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1250 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x4 ),	/* 4 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x3a ),	/* Offset= 58 (96) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x58 ),	/* Offset= 88 (132) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0xcc ),	/* Offset= 204 (254) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0x10 ),	/* Offset= 16 (72) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0x130 ),	/* Offset= 304 (366) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0x12a ),	/* Offset= 298 (366) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x4 ),	/* 4 */
/* 80 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 82 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 90 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 92 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 94 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 96 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 98 */	NdrFcShort( 0x2 ),	/* Offset= 2 (100) */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 120 */	NdrFcShort( 0x4 ),	/* 4 */
/* 122 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 124 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 126 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 128 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 130 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 132 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 134 */	NdrFcShort( 0x4c ),	/* Offset= 76 (210) */
/* 136 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0xc ),	/* 12 */
/* 140 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 148 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 150 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 152 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 160 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 162 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 164 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 168 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 170 */	NdrFcShort( 0xc ),	/* 12 */
/* 172 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 174 */	NdrFcShort( 0xc ),	/* 12 */
/* 176 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 178 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 180 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 182 */	NdrFcShort( 0xc ),	/* 12 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x2 ),	/* 2 */
/* 188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 192 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 194 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 200 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 202 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 206 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (136) */
			0x5b,		/* FC_END */
/* 210 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x14 ),	/* 20 */
/* 214 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 216 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 222 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 224 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 226 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x4 ),	/* 4 */
/* 232 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 234 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 236 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 238 */	NdrFcShort( 0x10 ),	/* 16 */
/* 240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 242 */	0x12, 0x0,	/* FC_UP */
/* 244 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (168) */
/* 246 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 248 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 250 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 252 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 256 */	NdrFcShort( 0x3e ),	/* Offset= 62 (318) */
/* 258 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 264 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 266 */	NdrFcShort( 0x10 ),	/* 16 */
/* 268 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 270 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 272 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (258) */
			0x5b,		/* FC_END */
/* 276 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 278 */	NdrFcShort( 0xc ),	/* 12 */
/* 280 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 282 */	NdrFcShort( 0x20 ),	/* 32 */
/* 284 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 286 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 288 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 290 */	NdrFcShort( 0xc ),	/* 12 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x2 ),	/* 2 */
/* 296 */	NdrFcShort( 0x4 ),	/* 4 */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 302 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcShort( 0x8 ),	/* 8 */
/* 308 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 310 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 312 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 314 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff4d ),	/* Offset= -179 (136) */
			0x5b,		/* FC_END */
/* 318 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 320 */	NdrFcShort( 0x28 ),	/* 40 */
/* 322 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 324 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 332 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 334 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 336 */	NdrFcShort( 0x4 ),	/* 4 */
/* 338 */	NdrFcShort( 0x4 ),	/* 4 */
/* 340 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 342 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 344 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 346 */	NdrFcShort( 0x24 ),	/* 36 */
/* 348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 350 */	0x12, 0x0,	/* FC_UP */
/* 352 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (276) */
/* 354 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 356 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 358 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 360 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9f ),	/* Offset= -97 (264) */
			0x8,		/* FC_LONG */
/* 364 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (370) */
/* 370 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 372 */	NdrFcShort( 0x4 ),	/* 4 */
/* 374 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 376 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
/* 380 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 382 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 384 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 388 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (24) */
/* 390 */	
			0x12, 0x0,	/* FC_UP */
/* 392 */	NdrFcShort( 0x140 ),	/* Offset= 320 (712) */
/* 394 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 396 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcShort( 0x2 ),	/* Offset= 2 (404) */
/* 404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 406 */	NdrFcShort( 0x3005 ),	/* 12293 */
/* 408 */	NdrFcLong( 0x1 ),	/* 1 */
/* 412 */	NdrFcShort( 0x1c ),	/* Offset= 28 (440) */
/* 414 */	NdrFcLong( 0x2 ),	/* 2 */
/* 418 */	NdrFcShort( 0x50 ),	/* Offset= 80 (498) */
/* 420 */	NdrFcLong( 0x3 ),	/* 3 */
/* 424 */	NdrFcShort( 0x8c ),	/* Offset= 140 (564) */
/* 426 */	NdrFcLong( 0x4 ),	/* 4 */
/* 430 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (638) */
/* 432 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 436 */	NdrFcShort( 0x4 ),	/* Offset= 4 (440) */
/* 438 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (437) */
/* 440 */	
			0x12, 0x0,	/* FC_UP */
/* 442 */	NdrFcShort( 0x24 ),	/* Offset= 36 (478) */
/* 444 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 446 */	NdrFcShort( 0x4 ),	/* 4 */
/* 448 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 454 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 456 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 458 */	NdrFcShort( 0x4 ),	/* 4 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x1 ),	/* 1 */
/* 464 */	NdrFcShort( 0x0 ),	/* 0 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 470 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 472 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 474 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe71 ),	/* Offset= -399 (76) */
			0x5b,		/* FC_END */
/* 478 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 482 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 484 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 486 */	NdrFcShort( 0x4 ),	/* 4 */
/* 488 */	NdrFcShort( 0x4 ),	/* 4 */
/* 490 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 492 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (444) */
/* 494 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 496 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 498 */	
			0x12, 0x0,	/* FC_UP */
/* 500 */	NdrFcShort( 0x2c ),	/* Offset= 44 (544) */
/* 502 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 504 */	NdrFcShort( 0x10 ),	/* 16 */
/* 506 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
/* 510 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 512 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 514 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 516 */	NdrFcShort( 0x10 ),	/* 16 */
/* 518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 520 */	NdrFcShort( 0x2 ),	/* 2 */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 528 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 530 */	NdrFcShort( 0x4 ),	/* 4 */
/* 532 */	NdrFcShort( 0x4 ),	/* 4 */
/* 534 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 536 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 538 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 540 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe47 ),	/* Offset= -441 (100) */
			0x5b,		/* FC_END */
/* 544 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x8 ),	/* 8 */
/* 548 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 550 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 552 */	NdrFcShort( 0x4 ),	/* 4 */
/* 554 */	NdrFcShort( 0x4 ),	/* 4 */
/* 556 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 558 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (502) */
/* 560 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 562 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 564 */	
			0x12, 0x0,	/* FC_UP */
/* 566 */	NdrFcShort( 0x34 ),	/* Offset= 52 (618) */
/* 568 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 570 */	NdrFcShort( 0x14 ),	/* 20 */
/* 572 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 578 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 580 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 582 */	NdrFcShort( 0x14 ),	/* 20 */
/* 584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0x3 ),	/* 3 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 594 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 598 */	NdrFcShort( 0x4 ),	/* 4 */
/* 600 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 602 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 604 */	NdrFcShort( 0x10 ),	/* 16 */
/* 606 */	NdrFcShort( 0x10 ),	/* 16 */
/* 608 */	0x12, 0x0,	/* FC_UP */
/* 610 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (168) */
/* 612 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 614 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe6b ),	/* Offset= -405 (210) */
			0x5b,		/* FC_END */
/* 618 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 620 */	NdrFcShort( 0x8 ),	/* 8 */
/* 622 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 624 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 626 */	NdrFcShort( 0x4 ),	/* 4 */
/* 628 */	NdrFcShort( 0x4 ),	/* 4 */
/* 630 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 632 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (568) */
/* 634 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 636 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 638 */	
			0x12, 0x0,	/* FC_UP */
/* 640 */	NdrFcShort( 0x34 ),	/* Offset= 52 (692) */
/* 642 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 644 */	NdrFcShort( 0x28 ),	/* 40 */
/* 646 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 652 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 654 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 656 */	NdrFcShort( 0x28 ),	/* 40 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x3 ),	/* 3 */
/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 668 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 670 */	NdrFcShort( 0x4 ),	/* 4 */
/* 672 */	NdrFcShort( 0x4 ),	/* 4 */
/* 674 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 676 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 678 */	NdrFcShort( 0x24 ),	/* 36 */
/* 680 */	NdrFcShort( 0x24 ),	/* 36 */
/* 682 */	0x12, 0x0,	/* FC_UP */
/* 684 */	NdrFcShort( 0xfffffe68 ),	/* Offset= -408 (276) */
/* 686 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 688 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe8d ),	/* Offset= -371 (318) */
			0x5b,		/* FC_END */
/* 692 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
/* 696 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 698 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 700 */	NdrFcShort( 0x4 ),	/* 4 */
/* 702 */	NdrFcShort( 0x4 ),	/* 4 */
/* 704 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 706 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (642) */
/* 708 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 710 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 712 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0x0 ),	/* Offset= 0 (718) */
/* 720 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 722 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffeb7 ),	/* Offset= -329 (394) */
			0x5b,		/* FC_END */
/* 726 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 728 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 730 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 732 */	NdrFcShort( 0x2 ),	/* Offset= 2 (734) */
/* 734 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 736 */	NdrFcShort( 0x2a ),	/* Offset= 42 (778) */
/* 738 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 740 */	NdrFcShort( 0x14 ),	/* 20 */
/* 742 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 744 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 746 */	NdrFcShort( 0x10 ),	/* 16 */
/* 748 */	NdrFcShort( 0x10 ),	/* 16 */
/* 750 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 752 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 754 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 756 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe13 ),	/* Offset= -493 (264) */
			0x8,		/* FC_LONG */
/* 760 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 762 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 764 */	NdrFcShort( 0x14 ),	/* 20 */
/* 766 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 768 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 770 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 772 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 774 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (738) */
/* 776 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 778 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (762) */
/* 784 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 786 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 788 */	NdrFcShort( 0x14 ),	/* 20 */
/* 790 */	NdrFcShort( 0x4 ),	/* 4 */
/* 792 */	NdrFcShort( 0x1 ),	/* 1 */
/* 794 */	NdrFcShort( 0x14 ),	/* 20 */
/* 796 */	NdrFcShort( 0x14 ),	/* 20 */
/* 798 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 800 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 802 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 804 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 806 */	
			0x11, 0x0,	/* FC_RP */
/* 808 */	NdrFcShort( 0x26 ),	/* Offset= 38 (846) */
/* 810 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 814 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 816 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 818 */	NdrFcShort( 0x4 ),	/* 4 */
/* 820 */	NdrFcShort( 0x4 ),	/* 4 */
/* 822 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 824 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 826 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 828 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 830 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 832 */	NdrFcShort( 0x8 ),	/* 8 */
/* 834 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 836 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 838 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 840 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 842 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (810) */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
/* 850 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (830) */
/* 852 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 854 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	NdrFcShort( 0x4 ),	/* 4 */
/* 860 */	NdrFcShort( 0x1 ),	/* 1 */
/* 862 */	NdrFcShort( 0x8 ),	/* 8 */
/* 864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 866 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 868 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 870 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 872 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 874 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 876 */	NdrFcShort( 0x2 ),	/* Offset= 2 (878) */
/* 878 */	
			0x12, 0x0,	/* FC_UP */
/* 880 */	NdrFcShort( 0x12 ),	/* Offset= 18 (898) */
/* 882 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 884 */	NdrFcShort( 0x4 ),	/* 4 */
/* 886 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 888 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 890 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 892 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 894 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (76) */
/* 896 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 898 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 900 */	NdrFcShort( 0x4 ),	/* 4 */
/* 902 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (882) */
/* 904 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 908 */	NdrFcShort( 0x4 ),	/* 4 */
/* 910 */	NdrFcShort( 0x4 ),	/* 4 */
/* 912 */	NdrFcShort( 0x1 ),	/* 1 */
/* 914 */	NdrFcShort( 0x4 ),	/* 4 */
/* 916 */	NdrFcShort( 0x4 ),	/* 4 */
/* 918 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 920 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 922 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 924 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 926 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 928 */	NdrFcShort( 0xfffffc66 ),	/* Offset= -922 (6) */
/* 930 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 932 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 934 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 936 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 938 */	
			0x11, 0x0,	/* FC_RP */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 944 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 946 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 948 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 950 */	NdrFcShort( 0xfffffc62 ),	/* Offset= -926 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    30,
    90,
    138,
    198,
    258,
    312,
    354,
    396,
    450,
    492,
    576,
    642,
    696,
    744,
    786,
    840,
    894,
    948,
    990,
    1062,
    1122,
    1182
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for netdfs.idl, dfssrv.acf:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   799                               
#define PROC_FORMAT_STRING_SIZE   1301                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 26 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 28 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 32 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 34 */	NdrFcLong( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0x1 ),	/* 1 */
/* 40 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 48 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 58 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 60 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 62 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 64 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 66 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 68 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 70 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 72 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 74 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 76 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 78 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 80 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 94 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 96 */	NdrFcLong( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x2 ),	/* 2 */
/* 102 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 110 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 122 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 124 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 132 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 134 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 136 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 144 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 160 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x3 ),	/* 3 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 170 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 172 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 174 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 178 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 180 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 186 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 190 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 194 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 198 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 200 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 202 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 206 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 208 */	NdrFcLong( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 214 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 216 */	NdrFcShort( 0x8 ),	/* 8 */
/* 218 */	NdrFcShort( 0x8 ),	/* 8 */
/* 220 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 222 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 224 */	NdrFcShort( 0x3 ),	/* 3 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 232 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 240 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 242 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 244 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 246 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 248 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 250 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 252 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 256 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 258 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 260 */	NdrFcShort( 0x12a ),	/* Type Offset=298 */

	/* Return value */

/* 262 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 264 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x5 ),	/* 5 */
/* 276 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 278 */	NdrFcShort( 0x2c ),	/* 44 */
/* 280 */	NdrFcShort( 0x24 ),	/* 36 */
/* 282 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 284 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 302 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 306 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 308 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 310 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 312 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 314 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 316 */	NdrFcShort( 0x256 ),	/* Type Offset=598 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 324 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x6 ),	/* 6 */
/* 332 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 338 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 340 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 350 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 352 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 354 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 356 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 358 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 360 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 364 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 368 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x7 ),	/* 7 */
/* 376 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 384 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 394 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 398 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 400 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 402 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 404 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 406 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 408 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 412 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 414 */	NdrFcLong( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x8 ),	/* 8 */
/* 420 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 422 */	NdrFcShort( 0x30 ),	/* 48 */
/* 424 */	NdrFcShort( 0x8 ),	/* 8 */
/* 426 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 428 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 430 */	NdrFcShort( 0x1 ),	/* 1 */
/* 432 */	NdrFcShort( 0x1 ),	/* 1 */
/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 438 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 440 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 442 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 444 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 450 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 452 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 454 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */

	/* Parameter ppRelationInfo */

/* 456 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 458 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 460 */	NdrFcShort( 0x25a ),	/* Type Offset=602 */

	/* Return value */

/* 462 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 464 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 468 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 470 */	NdrFcLong( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x9 ),	/* 9 */
/* 476 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 482 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 484 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x1 ),	/* 1 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 494 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 496 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 498 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 502 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 504 */	NdrFcShort( 0x2c0 ),	/* Type Offset=704 */

	/* Return value */

/* 506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 508 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 512 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 518 */	NdrFcShort( 0xa ),	/* 10 */
/* 520 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 522 */	NdrFcShort( 0xd ),	/* 13 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 528 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 530 */	NdrFcShort( 0x1 ),	/* 1 */
/* 532 */	NdrFcShort( 0x1 ),	/* 1 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 538 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 540 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 542 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 544 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 546 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 548 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 550 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 554 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 556 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 558 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 560 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 562 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 564 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 566 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 568 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 570 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 572 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 574 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 576 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 578 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 582 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 586 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 588 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 590 */	NdrFcShort( 0x2cc ),	/* Type Offset=716 */

	/* Return value */

/* 592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 594 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 598 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0xb ),	/* 11 */
/* 606 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 608 */	NdrFcShort( 0x8 ),	/* 8 */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 614 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 616 */	NdrFcShort( 0x1 ),	/* 1 */
/* 618 */	NdrFcShort( 0x1 ),	/* 1 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 624 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 630 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 632 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 634 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 636 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 638 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 640 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 642 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 644 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 646 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 654 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 656 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 658 */	NdrFcShort( 0x2cc ),	/* Type Offset=716 */

	/* Return value */

/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 662 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 666 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0xc ),	/* 12 */
/* 674 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 682 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 692 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 694 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 696 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 698 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 700 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 702 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 704 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 706 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 708 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 712 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 718 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 722 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0xd ),	/* 13 */
/* 730 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 736 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 738 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 748 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 750 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 752 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 754 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 756 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 758 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 760 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 762 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 766 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 768 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 772 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 774 */	NdrFcLong( 0x0 ),	/* 0 */
/* 778 */	NdrFcShort( 0xe ),	/* 14 */
/* 780 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 782 */	NdrFcShort( 0x8 ),	/* 8 */
/* 784 */	NdrFcShort( 0x8 ),	/* 8 */
/* 786 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 788 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 800 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 802 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 806 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 812 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 816 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xf ),	/* 15 */
/* 824 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 830 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 832 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
/* 836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 842 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 844 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 846 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 848 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 850 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 852 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 856 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 858 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 860 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 862 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 864 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 868 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 872 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 880 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 882 */	NdrFcShort( 0x35 ),	/* 53 */
/* 884 */	NdrFcShort( 0x3d ),	/* 61 */
/* 886 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 888 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 896 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 898 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 900 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 902 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 904 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 906 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 908 */	NdrFcShort( 0x304 ),	/* Type Offset=772 */

	/* Parameter IsRoot */

/* 910 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 912 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 914 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 916 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 918 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 922 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 924 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 928 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 930 */	NdrFcLong( 0x0 ),	/* 0 */
/* 934 */	NdrFcShort( 0x11 ),	/* 17 */
/* 936 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 938 */	NdrFcShort( 0x10 ),	/* 16 */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 944 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 954 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 956 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 958 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 960 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 962 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 964 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 966 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 968 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 972 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 974 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 978 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 980 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 984 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0x12 ),	/* 18 */
/* 992 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x8 ),	/* 8 */
/* 998 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1000 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 1010 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1012 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1014 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 1016 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1018 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1020 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 1022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1024 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 1028 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1030 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1036 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1038 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1040 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1044 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1046 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1048 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1054 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1056 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1058 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1060 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1062 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1064 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1066 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1068 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1070 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1072 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1074 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1076 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1078 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1080 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1082 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1084 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1086 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1088 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1090 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1092 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1094 */	NdrFcShort( 0x2cc ),	/* Type Offset=716 */

	/* Return value */

/* 1096 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1098 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1102 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1110 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1116 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1118 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1120 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1122 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1128 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1130 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1136 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1138 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1140 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1142 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1144 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1146 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1148 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1150 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1152 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1154 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1156 */	NdrFcShort( 0x2cc ),	/* Type Offset=716 */

	/* Return value */

/* 1158 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1160 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1164 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1166 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1170 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1172 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1174 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1176 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1178 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1180 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1190 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1192 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1194 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1198 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1204 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1208 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1210 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1212 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 1214 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1216 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1218 */	NdrFcShort( 0x256 ),	/* Type Offset=598 */

	/* Return value */

/* 1220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1222 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1226 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1234 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1240 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1242 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1244 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1246 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1252 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1254 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1256 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1258 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1260 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1262 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1266 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1268 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1270 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1272 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1274 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1278 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1282 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1284 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1286 */	NdrFcShort( 0x314 ),	/* Type Offset=788 */

	/* Parameter ppRootList */

/* 1288 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1290 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1292 */	NdrFcShort( 0x2cc ),	/* Type Offset=716 */

	/* Return value */

/* 1294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1296 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x34 ),	/* Offset= 52 (90) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x48 ),	/* Offset= 72 (116) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x8c ),	/* Offset= 140 (190) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (266) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0xde ),	/* Offset= 222 (284) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0xd8 ),	/* Offset= 216 (284) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x8 ),	/* 8 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x4 ),	/* Offset= 4 (86) */
/* 84 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 86 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 88 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 90 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 92 */	NdrFcShort( 0x2 ),	/* Offset= 2 (94) */
/* 94 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 96 */	NdrFcShort( 0x18 ),	/* 24 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x8 ),	/* Offset= 8 (108) */
/* 102 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 104 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 108 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 110 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 118 */	NdrFcShort( 0x2e ),	/* Offset= 46 (164) */
/* 120 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x18 ),	/* 24 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x8 ),	/* Offset= 8 (134) */
/* 128 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 130 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 148 */	NdrFcShort( 0x14 ),	/* 20 */
/* 150 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 152 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 156 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 158 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 160 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (120) */
/* 162 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 164 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 166 */	NdrFcShort( 0x20 ),	/* 32 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 170 */	NdrFcShort( 0x8 ),	/* Offset= 8 (178) */
/* 172 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 174 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 176 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 178 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 180 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 182 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 184 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (142) */
/* 190 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 192 */	NdrFcShort( 0x2a ),	/* Offset= 42 (234) */
/* 194 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 200 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 206 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 208 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (194) */
			0x5b,		/* FC_END */
/* 212 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 218 */	NdrFcShort( 0x28 ),	/* 40 */
/* 220 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 222 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 226 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 228 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 230 */	NdrFcShort( 0xffffff92 ),	/* Offset= -110 (120) */
/* 232 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 234 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 236 */	NdrFcShort( 0x38 ),	/* 56 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0xe ),	/* Offset= 14 (254) */
/* 242 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 248 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (200) */
/* 250 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 252 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 256 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 258 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 260 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (212) */
/* 266 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 268 */	NdrFcShort( 0x2 ),	/* Offset= 2 (270) */
/* 270 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x4 ),	/* Offset= 4 (280) */
/* 278 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 280 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 282 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (288) */
/* 288 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x4 ),	/* 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 294 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 296 */	NdrFcShort( 0x2 ),	/* Offset= 2 (298) */
/* 298 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 300 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 302 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 304 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 306 */	NdrFcShort( 0xfffffee6 ),	/* Offset= -282 (24) */
/* 308 */	
			0x12, 0x0,	/* FC_UP */
/* 310 */	NdrFcShort( 0x110 ),	/* Offset= 272 (582) */
/* 312 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 314 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 316 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 318 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 320 */	NdrFcShort( 0x2 ),	/* Offset= 2 (322) */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	NdrFcShort( 0x3005 ),	/* 12293 */
/* 326 */	NdrFcLong( 0x1 ),	/* 1 */
/* 330 */	NdrFcShort( 0x1c ),	/* Offset= 28 (358) */
/* 332 */	NdrFcLong( 0x2 ),	/* 2 */
/* 336 */	NdrFcShort( 0x40 ),	/* Offset= 64 (400) */
/* 338 */	NdrFcLong( 0x3 ),	/* 3 */
/* 342 */	NdrFcShort( 0x64 ),	/* Offset= 100 (442) */
/* 344 */	NdrFcLong( 0x4 ),	/* 4 */
/* 348 */	NdrFcShort( 0x88 ),	/* Offset= 136 (484) */
/* 350 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 354 */	NdrFcShort( 0xac ),	/* Offset= 172 (526) */
/* 356 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (355) */
/* 358 */	
			0x12, 0x0,	/* FC_UP */
/* 360 */	NdrFcShort( 0x18 ),	/* Offset= 24 (384) */
/* 362 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 372 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 376 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 378 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 380 */	NdrFcShort( 0xfffffed0 ),	/* Offset= -304 (76) */
/* 382 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 384 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 386 */	NdrFcShort( 0x10 ),	/* 16 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x6 ),	/* Offset= 6 (396) */
/* 392 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 394 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 396 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 398 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (362) */
/* 400 */	
			0x12, 0x0,	/* FC_UP */
/* 402 */	NdrFcShort( 0x18 ),	/* Offset= 24 (426) */
/* 404 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 408 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 412 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 414 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 418 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xfffffeb8 ),	/* Offset= -328 (94) */
/* 424 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 426 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 428 */	NdrFcShort( 0x10 ),	/* 16 */
/* 430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 432 */	NdrFcShort( 0x6 ),	/* Offset= 6 (438) */
/* 434 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 436 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 438 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 440 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (404) */
/* 442 */	
			0x12, 0x0,	/* FC_UP */
/* 444 */	NdrFcShort( 0x18 ),	/* Offset= 24 (468) */
/* 446 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 456 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 460 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 462 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 464 */	NdrFcShort( 0xfffffed4 ),	/* Offset= -300 (164) */
/* 466 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 468 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 470 */	NdrFcShort( 0x10 ),	/* 16 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x6 ),	/* Offset= 6 (480) */
/* 476 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 478 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 480 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 482 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (446) */
/* 484 */	
			0x12, 0x0,	/* FC_UP */
/* 486 */	NdrFcShort( 0x18 ),	/* Offset= 24 (510) */
/* 488 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 496 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 498 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 502 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 506 */	NdrFcShort( 0xfffffef0 ),	/* Offset= -272 (234) */
/* 508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 510 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 512 */	NdrFcShort( 0x10 ),	/* 16 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */
/* 516 */	NdrFcShort( 0x6 ),	/* Offset= 6 (522) */
/* 518 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 520 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 522 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 524 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (488) */
/* 526 */	
			0x12, 0x0,	/* FC_UP */
/* 528 */	NdrFcShort( 0x26 ),	/* Offset= 38 (566) */
/* 530 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 532 */	NdrFcShort( 0x8 ),	/* 8 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x4 ),	/* Offset= 4 (540) */
/* 538 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 540 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 542 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 544 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 554 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 558 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (530) */
/* 564 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 566 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 568 */	NdrFcShort( 0x10 ),	/* 16 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x6 ),	/* Offset= 6 (578) */
/* 574 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 576 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 578 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 580 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (544) */
/* 582 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 584 */	NdrFcShort( 0x10 ),	/* 16 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* Offset= 0 (588) */
/* 590 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 592 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 594 */	NdrFcShort( 0xfffffee6 ),	/* Offset= -282 (312) */
/* 596 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 598 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 600 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 602 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 604 */	NdrFcShort( 0x2 ),	/* Offset= 2 (606) */
/* 606 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 608 */	NdrFcShort( 0x2a ),	/* Offset= 42 (650) */
/* 610 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 612 */	NdrFcShort( 0x18 ),	/* 24 */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x8 ),	/* Offset= 8 (624) */
/* 618 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 620 */	NdrFcShort( 0xfffffe5c ),	/* Offset= -420 (200) */
/* 622 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 624 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 626 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 628 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 632 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 634 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 636 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 638 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 642 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 644 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 646 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (610) */
/* 648 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 650 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (628) */
/* 656 */	NdrFcShort( 0x0 ),	/* Offset= 0 (656) */
/* 658 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 660 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 662 */	
			0x11, 0x0,	/* FC_RP */
/* 664 */	NdrFcShort( 0x28 ),	/* Offset= 40 (704) */
/* 666 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 668 */	NdrFcShort( 0x10 ),	/* 16 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0x6 ),	/* Offset= 6 (678) */
/* 674 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 676 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 678 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 680 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 682 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 688 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 690 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 692 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 696 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 698 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 700 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (666) */
/* 702 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 704 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (682) */
/* 710 */	NdrFcShort( 0x0 ),	/* Offset= 0 (710) */
/* 712 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 718 */	NdrFcShort( 0x2 ),	/* Offset= 2 (720) */
/* 720 */	
			0x12, 0x0,	/* FC_UP */
/* 722 */	NdrFcShort( 0x26 ),	/* Offset= 38 (760) */
/* 724 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 726 */	NdrFcShort( 0x8 ),	/* 8 */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x4 ),	/* Offset= 4 (734) */
/* 732 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 734 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 736 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 738 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 744 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 746 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 748 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 752 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 754 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 756 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (724) */
/* 758 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 760 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 764 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (738) */
/* 766 */	NdrFcShort( 0x0 ),	/* Offset= 0 (766) */
/* 768 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 770 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 772 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 774 */	NdrFcShort( 0xfffffd00 ),	/* Offset= -768 (6) */
/* 776 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 778 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 782 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 784 */	
			0x11, 0x0,	/* FC_RP */
/* 786 */	NdrFcShort( 0x2 ),	/* Offset= 2 (788) */
/* 788 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 790 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 792 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 794 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 796 */	NdrFcShort( 0xfffffcfc ),	/* Offset= -772 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    32,
    94,
    144,
    206,
    268,
    324,
    368,
    412,
    468,
    512,
    598,
    666,
    722,
    772,
    816,
    872,
    928,
    984,
    1028,
    1102,
    1164,
    1226
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\klogmacros.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       kLogMacros.h
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    Marc 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------

#include "dfswmi.h"

extern PVOID pkUmrControl;

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) (((WPP_CB_TYPE *)pkUmrControl)->Control.Logger),
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
  (pkUmrControl && (((WPP_CB_TYPE *)pkUmrControl)->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)) && \
  ( ((WPP_CB_TYPE *)pkUmrControl)->Control.Level >= lvl))
 
#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) (((WPP_CB_TYPE *)pkUmrControl)->Control.Logger),
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((pkUmrControl && (!NT_SUCCESS(error) || ((( WPP_CB_TYPE *)pkUmrControl)->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)))) && \
  (((WPP_CB_TYPE *)pkUmrControl)->Control.Level >= lvl))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "ntifs.h"
#include <windef.h>
#include <midatlax.h>
#include <midatlsp.h>

#define RXCE_MIDATLAS_POOLTAG (ULONG)'dfsU'                         
VOID
RxInitializeMidMapFreeList (
    struct _MID_MAP_ *pMidMap
    );

VOID
RxUninitializeMidMap (
    struct _MID_MAP_    *pMidMap,
    PCONTEXT_DESTRUCTOR pContextDestructor
    );

VOID
RxIterateMidMapAndRemove (
	PRX_MID_ATLAS     pMidAtlas,
	struct _MID_MAP_ *pMidMap,
	PCONTEXT_ITERATOR pContextIterator
	);


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMidMapFreeList)
#pragma alloc_text(PAGE, RxCreateMidAtlas)
#pragma alloc_text(PAGE, RxUninitializeMidMap)
#pragma alloc_text(PAGE, RxDestroyMidAtlas)
#pragma alloc_text(PAGE, RxIterateMidAtlasAndRemove)
#pragma alloc_text(PAGE, RxIterateMidMapAndRemove)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        (ULONG) ((ULONG_PTR)(pEntry) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)pEntry & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
RxInitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i = 0;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("RxInitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("RxInitializeMidMapFreeList .. Exit\n");
}


PRX_MID_ATLAS
RxCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PRX_MID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(RX_MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PRX_MID_ATLAS)ExAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              RXCE_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        RxInitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("RxAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}


VOID
RxIterateMidMapAndRemove(
   PRX_MID_ATLAS     pMidAtlas,
   PMID_MAP          pMidMap,
   PCONTEXT_ITERATOR pContextIterator)
{	
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //RxLog(("_IterateMidMapAndRemove .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxIterateMidMapAndRemove(pMidAtlas,pChildMidMap,pContextIterator);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
#if 0         	
         	PVOID *pEntry;

         	pMidMap->NumberOfMidsInUse--;
         	DbgPrint("RxIterateMidMapAndRemove, MidMap Mids in use: %d\n",pMidMap->NumberOfMidsInUse);
#endif // 0
            if (pContextIterator != NULL) {
               	PVOID pContext;

               	pContext = _GetEntryPointer(pMidMap->Entries[i]);

				DbgPrint("Executing ContextIterator: 0x%08x\n",pContext);

               	(pContextIterator)(pContext);
            }
#if 0            
         	if (pMidMap->pFreeMidListHead == NULL) {
				if (pMidMap->Flags & MID_MAP_FLAGS_CAN_BE_EXPANDED) {
               		_RemoveMidMap(pMidMap);
            	}

            	_AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         	}

            *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         	pMidMap->pFreeMidListHead = pEntry;
            pMidAtlas->NumberOfMidsInUse--;
         	DbgPrint("RxIterateMidMapAndRemove, MidAtlas Mids in use: %d\n",pMidAtlas->NumberOfMidsInUse);
#endif // 0         	
         }
         break;
      default:
         break;
      }
   }
}


VOID
RxIterateMidAtlasAndRemove(
		PRX_MID_ATLAS pMidAtlas,
		PCONTEXT_ITERATOR pContextIterator)
{
	PAGED_CODE();

	RxIterateMidMapAndRemove(pMidAtlas, pMidAtlas->pRootMidMap, pContextIterator);
}



VOID
RxUninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("RxUninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   //RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxUninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      ExFreePool(pMidMap);
   }

   //DbgPrint("RxUninitializeMidMap .. Exit\n");
}

VOID
RxDestroyMidAtlas(
   PRX_MID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("RxFreeMidAtlas .. Entry\n");
   RxUninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   ExFreePool(pMidAtlas);
   //DbgPrint("RxFreeMidAtlas .. Exit\n");
}

PVOID
RxMapMidToContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxMapMidToContext Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("Context %lx \n",pContext);

   return pContext;
}

NTSTATUS
RxMapAndDissociateMidFromContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("RxMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            if (pMidMap->Flags & MID_MAP_FLAGS_CAN_BE_EXPANDED) {
               _RemoveMidMap(pMidMap);
            }

            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;


         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
RxReassociateMid(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
RxAssociateContextWithMid(
      PRX_MID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;
   PMID_MAP pMidMap = NULL;
   PVOID    *pContextPointer = NULL;

   //DbgPrint("RxAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                    << pMidMap->IndexAlignmentCount) |
                                    pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        RXCE_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                 pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                 pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                 pNewMidMap->NumberOfMidsInUse   = 0;
                 pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                    i << pMidMap->IndexAlignmentCount);
                 pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                   pMidMap->IndexFieldWidth;

                 pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                 pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                 RxInitializeMidMapFreeList(pNewMidMap);

                 //
                 // After the RxInitializeMidMapFreeList call above the 
                 // pFreeMidListHead points to Entries[0]. We will be storing
                 // the value pMidMap->Entries[i] at this location so we need
                 // to make pFreeMidListHead point to Entries[1].
                 //
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));

                 //
                 // Set up the mid map appropriately.
                 //
                 pNewMidMap->NumberOfMidsInUse = 1;
                 pNewMidMap->Entries[0] = pMidMap->Entries[i];
                 pNewMidMap->Level = pMidMap->Level + 1;

                 //
                 // The new MinMap is stored at the pMidMap->Entries[i] location.
                 //
                 pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                 //
                 // Update the free list and the expansion list respectively.
                 //
                 _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                 pNewMidMap->NumberOfMidsInUse++;
                 pContextPointer = pNewMidMap->pFreeMidListHead;
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                 *pContextPointer = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                 *pNewMid = ((USHORT)
                             (pContextPointer - (PVOID *)&pNewMidMap->Entries)
                             << pNewMidMap->IndexAlignmentCount) |
                             pNewMidMap->BaseMid;

                 Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == (STATUS_SUCCESS)) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\rxcontx.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       rxcontx.c
//
//  Contents:   Contains functions for allocating contexts and Cancel Routines
//
//
//  Functions:  
//
//  Author - Rohan Phillips     (Rohanp)
//-----------------------------------------------------------------------------
#include "ntifs.h"
#include <rxcontx.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeContext)
#pragma alloc_text(PAGE, DfsInitializeContextResources)
#pragma alloc_text(PAGE, DfsDeInitializeContextResources)
#endif

#define RX_IRPC_POOLTAG         ('rsfd')

KSPIN_LOCK  RxStrucSupSpinLock = {0};
LIST_ENTRY  RxActiveContexts;
ULONG NumberOfActiveContexts = 0;
NPAGED_LOOKASIDE_LIST RxContextLookasideList;


//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeContextResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Initializes all resources needed for allocating contexts
//
//--------------------------------------------------------------------------
NTSTATUS DfsInitializeContextResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    KeInitializeSpinLock( &RxStrucSupSpinLock );

    // Initialize the look aside list for RxContext allocation
    ExInitializeNPagedLookasideList(
                                    &RxContextLookasideList,
                                    ExAllocatePoolWithTag,
                                    ExFreePool,
                                    0,
                                    sizeof(RX_CONTEXT),
                                    RX_IRPC_POOLTAG,
                                    32);
    
    InitializeListHead(&RxActiveContexts);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDeInitializeContextResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: DeInitializes all resources needed for allocating contexts
//
//--------------------------------------------------------------------------
NTSTATUS DfsDeInitializeContextResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExDeleteNPagedLookasideList(&RxContextLookasideList);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxInitializeContext 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: initializes a context
//
//--------------------------------------------------------------------------
VOID
RxInitializeContext(
    IN PIRP            Irp,
    IN OUT PRX_CONTEXT RxContext)
{
    PAGED_CODE();

    RxContext->ReferenceCount = 1;

    // Initialize the Sync Event.
    KeInitializeEvent(
        &RxContext->SyncEvent,
        SynchronizationEvent,
        FALSE);

    if(Irp)
    {
        if (!IoIsOperationSynchronous(Irp)) 
        {
            SetFlag( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION );
        } 
    }
    
    //  Set the Irp fields.
    RxContext->CurrentIrp   = Irp;
    RxContext->OriginalThread = RxContext->LastExecutionThread = PsGetCurrentThread();

}


//+-------------------------------------------------------------------------
//
//  Function:   RxCreateRxContext 
//
//  Arguments:  
//
//  Returns:    Pointer to context information
//
//
//  Description: allocates a context
//
//--------------------------------------------------------------------------
PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    )
{
    PRX_CONTEXT        RxContext = NULL;
    ULONG              RxContextFlags = 0;
    KIRQL              SavedIrql;

    RxContext = ExAllocateFromNPagedLookasideList(
                            &RxContextLookasideList);
    if(RxContext == NULL)
    {
        return(NULL);
    }

    InterlockedIncrement(&NumberOfActiveContexts);

    RtlZeroMemory( RxContext, sizeof(RX_CONTEXT) );

    RxContext->Flags = RxContextFlags;

    RxInitializeContext(Irp,RxContext);

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    InsertTailList(&RxActiveContexts,&RxContext->ContextListEntry);

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    return RxContext;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxDereferenceAndDeleteRxContext_Real 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: Deallocates a context
//
//--------------------------------------------------------------------------
VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    )
{
    PRX_CONTEXT          pStopContext = NULL;
    LONG                 FinalRefCount = 0;
    KIRQL                SavedIrql;

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
    
    FinalRefCount = InterlockedDecrement(&RxContext->ReferenceCount);

    if (FinalRefCount == 0) 
    {
       RemoveEntryList(&RxContext->ContextListEntry);

       InterlockedDecrement(&NumberOfActiveContexts);

       RtlZeroMemory( RxContext, sizeof(RX_CONTEXT) );

       ExFreeToNPagedLookasideList(
                                    &RxContextLookasideList,
                                    RxContext );
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );
}


//+-------------------------------------------------------------------------
//
//  Function:   RxSetMinirdrCancelRoutine 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: Sets up a cancel routine
//
//--------------------------------------------------------------------------
NTSTATUS
RxSetMinirdrCancelRoutine(
    IN  OUT PRX_CONTEXT   RxContext,
    IN      DFS_CALLDOWN_ROUTINE DfsCancelRoutine)
{
   NTSTATUS Status = STATUS_SUCCESS;
   KIRQL   SavedIrql;

   KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

   if (!FlagOn(RxContext->Flags, DFS_CONTEXT_FLAG_CANCELLED)) 
   {
      RxContext->CancelRoutine = DfsCancelRoutine;
      Status = STATUS_SUCCESS;
   } 
   else 
   {
      Status = STATUS_CANCELLED;
   }

   KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

   return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxCancelRoutine 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: The main cancel routine
//
//--------------------------------------------------------------------------
VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp)
{
    PRX_CONTEXT   pRxContext = NULL;
    PLIST_ENTRY   pListEntry = NULL;
    DFS_CALLDOWN_ROUTINE DfsCancelRoutine = NULL;
    KIRQL         SavedIrql;

    // Locate the context corresponding to the given Irp.
    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    pListEntry = RxActiveContexts.Flink;

    while (pListEntry != &RxActiveContexts) 
    {
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);

        if (pRxContext->CurrentIrp == pIrp) 
        {
            break;
        } 
        else 
        {
            pListEntry = pListEntry->Flink;
        }
    }

    if (pListEntry != &RxActiveContexts) 
    {
        SetFlag( pRxContext->Flags, DFS_CONTEXT_FLAG_CANCELLED );
        DfsCancelRoutine = pRxContext->CancelRoutine;
        pRxContext->CancelRoutine = NULL;
        InterlockedIncrement(&pRxContext->ReferenceCount);
    } 
    else 
    {
        pRxContext       = NULL;
        DfsCancelRoutine = NULL;
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (pRxContext != NULL) 
    {
        if (DfsCancelRoutine != NULL) 
        {
            (DfsCancelRoutine)(pRxContext);
        }

        RxDereferenceAndDeleteRxContext(pRxContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\umrx.c ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    umrx.c

Abstract:

    This is the implementation of the UMRxEngine object and
    associated functions.

Notes:

    This module has been built and tested only in UNICODE environment

Author:


--*/


#include "ntifs.h"
#include <windef.h>
#include <dfsassert.h>
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>                         
#include <dfsumr.h>
#include <umrx.h>
#include <dfsumrctrl.h>

#include <lmcons.h>     // from the Win32 SDK

//
//  The local debug trace level
//

extern NTSTATUS  g_CheckStatus;
ULONG DfsDbgVerbose = 0;

RXDT_DefineCategory(UMRX);
#define Dbg                              (DEBUG_TRACE_UMRX)

//
//  For now, Max and Init MID entries should be the same so that the MID Atlas doesn't grow.
//    There are several bugs in the mid atlas growth code.
//
#define DFS_MAX_MID_ENTRIES   1024
#define DFS_INIT_MID_ENTRIES  DFS_MAX_MID_ENTRIES


extern PUMRX_ENGINE GetUMRxEngineFromRxContext(void);

PUMRX_ENGINE
CreateUMRxEngine()
/*++

Routine Description:

    Create a UMRX_ENGINE object
   
Arguments:

Return Value:

    PUMRX_ENGINE    -   pointer to UMRX_ENGINE
    
Notes:

--*/
{
    PUMRX_ENGINE  pUMRxEngine = NULL;
    PRX_MID_ATLAS MidAtlas = NULL;

    DfsTraceEnter("CreateUMRxEngine");
    if (DfsDbgVerbose) DbgPrint("Creating an UMRX_ENGINE object\n");

    MidAtlas = RxCreateMidAtlas(DFS_MAX_MID_ENTRIES,DFS_INIT_MID_ENTRIES);
    if (MidAtlas == NULL) {
        if (DfsDbgVerbose) DbgPrint("CreateEngine could not make midatlas\n");
        DfsTraceLeave(0);
        return NULL;
    }
    
    pUMRxEngine = (PUMRX_ENGINE) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                sizeof(UMRX_ENGINE),
                                                UMRX_ENGINE_TAG
                                                );
    if( pUMRxEngine ) {
        //
        //  Initialize the UMRX_ENGINE KQUEUE
        //
        pUMRxEngine->Q.State = UMRX_ENGINE_STATE_STOPPED;
        ExInitializeResourceLite(&pUMRxEngine->Q.Lock);  
        KeInitializeQueue(&pUMRxEngine->Q.Queue,0);
        pUMRxEngine->Q.TimeOut.QuadPart  = -10 * TICKS_PER_SECOND;
        pUMRxEngine->Q.NumberOfWorkerThreads  = 0;
        pUMRxEngine->Q.NumberOfWorkItems = 0;
        pUMRxEngine->Q.ThreadAborted = 0;
        pUMRxEngine->cUserModeReflectionsInProgress = 0;

        //
        //  Initialize the UMRX_ENGINE MidAtlas
        //
        
        pUMRxEngine->MidAtlas = MidAtlas;
        ExInitializeFastMutex(&pUMRxEngine->MidManagementMutex);
        InitializeListHead(&pUMRxEngine->WaitingForMidListhead);        
        pUMRxEngine->NextSerialNumber = 0;
        
        InitializeListHead(&pUMRxEngine->ActiveLinkHead);
        
    } else {
        //
        //  out of resources - cleanup and bail
        //
        if (MidAtlas != NULL) 
        {
            RxDestroyMidAtlas(MidAtlas,NULL);
        }
    }

    DfsTraceLeave(0);
    return pUMRxEngine;
}

VOID
FinalizeUMRxEngine(
    IN PUMRX_ENGINE pUMRxEngine
    )
/*++

Routine Description:

    Close a UMRX_ENGINE object
   
Arguments:

    PUMRX_ENGINE    -   pointer to UMRX_ENGINE

Return Value:

Notes:

    Owner of object ensures that all usage of this object
    is within the Create/Finalize span.

--*/
{
    PLIST_ENTRY pFirstListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    BOOLEAN FoundPoisoner = FALSE;

    DfsTraceEnter("FinalizeUMRxEngine");

    //
    //  destroy engine mid atlas
    //
    if (pUMRxEngine->MidAtlas != NULL) 
    {
        RxDestroyMidAtlas(pUMRxEngine->MidAtlas, NULL);  //no individual callbacks needed
    }

    //
    //  rundown engine KQUEUE -
    //  Queue should only have poisoner entry
    //
    pFirstListEntry = KeRundownQueue(&pUMRxEngine->Q.Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;

        do {
            PLIST_ENTRY ThisEntry =  pNextListEntry;

            pNextListEntry = pNextListEntry->Flink;

            if (ThisEntry != &pUMRxEngine->Q.PoisonEntry) {
                if (DfsDbgVerbose) DbgPrint("Non poisoner %08lx in the queue...very odd\n",ThisEntry);
                DbgBreakPoint();
            } else {
                FoundPoisoner = TRUE;
            }
        } while (pNextListEntry != pFirstListEntry);
    }

    if (!FoundPoisoner) {
        //if (DfsDbgVerbose) DbgPrint("No poisoner in the queue...very odd\n");
    }

    ExDeleteResourceLite(&pUMRxEngine->Q.Lock);
    
    //
    //  destroy umrx engine
    //
    ExFreePool( pUMRxEngine );
    DfsTraceLeave(0);
}



NTSTATUS
UMRxEngineRestart(
                  IN PUMRX_ENGINE pUMRxEngine
                 )
/*++

Routine Description:

  This allows the engine state to be set so that it can service
  requests again.



--*/
{
    LARGE_INTEGER liTimeout = {0, 0};
    PLIST_ENTRY pListEntry = NULL;
    ULONG PreviousQueueState = 0;
    
    DfsTraceEnter("UMRxEngineRestart");
    if (DfsDbgVerbose) DbgPrint("Restarting a UMRX_ENGINE object\n");

    //
    //  First change the state so that nobody will try to get in.
    //
    PreviousQueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STARTING,
                                            UMRX_ENGINE_STATE_STOPPED);

    if (UMRX_ENGINE_STATE_STARTED == PreviousQueueState)
    {
        //
        // This is likely because the UMR server crashed.  This call is an
        //    indication that it's back up, so we should also clear the
        //    ThreadAborted value.
        //
        InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,
                            0);
                            
        //clear the number of reflections as well.
        InterlockedExchange(&pUMRxEngine->cUserModeReflectionsInProgress,
                            0);

        if (DfsDbgVerbose) DbgPrint("UMRxEngineRestart already started 0x%08x\n",
                    pUMRxEngine);
        return STATUS_SUCCESS;
    }

    if (UMRX_ENGINE_STATE_STOPPED != PreviousQueueState)
    {
        if (DfsDbgVerbose) DbgPrint("UMRxEngineRestart unexpected previous queue state: 0x%08x => %d\n",
                             pUMRxEngine, PreviousQueueState);
        CHECK_STATUS(STATUS_UNSUCCESSFUL ) ;
        return STATUS_UNSUCCESSFUL;
    }
    

    //
    //  We won't be granted exclusive until all the threads queued have vacated.
    //
    ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock,
                                    TRUE);

    //
    //  Try to remove the poison entry that MAY be in the queue.
    //  It won't be there in the case that we've never started the engine.
    //
    pListEntry = KeRemoveQueue(&pUMRxEngine->Q.Queue,
                               UserMode,
                               &liTimeout);
    
    ASSERT(((ULONG_PTR)pListEntry == STATUS_TIMEOUT) ||
           (&pUMRxEngine->Q.PoisonEntry == pListEntry));

    //
    //  Clear the thread aborted value in case it was set.
    //
    InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,
                        0);
    

    //clear the number of reflections as well.
    InterlockedExchange(&pUMRxEngine->cUserModeReflectionsInProgress,
                        0);
    //
    //  Now, that we've reinitialized things, we can change
    //    the state to STARTED;
    //
    PreviousQueueState = InterlockedExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STARTED);

    ASSERT(UMRX_ENGINE_STATE_STARTING == PreviousQueueState);

    //
    // Now, relinquish the lock
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                    ExGetCurrentResourceThread());
        
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}



void
UMRxWakeupWaitingWaiter(IN PRX_CONTEXT RxContext, IN PUMRX_CONTEXT pUMRxContext)
{

    if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
    {
        //at last, call the continuation........
        if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
        UMRxResumeEngineContext( RxContext );
    } 
    else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
    {
        PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

        if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
        {
            //
            // We won - signal and we are done !
            //
            if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            RxSignalSynchronousWaiter(RxContext);
        } 
        else 
        {
            //
            //  The reflection request has timed out in an async fashion -
            //  We need to complete the job of resuming the engine context !
            //
            if (DfsDbgVerbose) DbgPrint("SYNC Rx completing async %x\n",RxContext);
            if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            UMRxResumeEngineContext( RxContext );
        }

    } 
    else 
    {
        if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
        RxSignalSynchronousWaiter(RxContext);
    }  
}

NTSTATUS
UMRxEngineCompleteQueuedRequests(
                  IN PUMRX_ENGINE pUMRxEngine,
                  IN NTSTATUS     CompletionStatus,
                  IN BOOLEAN      fCleanup
                 )
/*++

Routine Description:

  This cleans up any reqeusts and places the engine in a state were it's ready to startup again.



--*/
{
    LARGE_INTEGER liTimeout = {0, 0};
    PLIST_ENTRY pListEntry = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    
    DfsTraceEnter("UMRxEngineCompleteQueuedRequests");
    if (DfsDbgVerbose) DbgPrint("Cleaning up a UMRX_ENGINE object\n");


    if (fCleanup)
    {
        //
        // Lock the queue.
        //
        ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock, TRUE);

        //
        //  Change the state so nothing more can be queued.
        //
        InterlockedExchange(&pUMRxEngine->Q.State,
                            UMRX_ENGINE_STATE_STOPPED);

        //
        //  Abort any requests that made it into the queue.
        //
        UMRxAbortPendingRequests(pUMRxEngine);
    }
    else
    {        
        ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock, TRUE);
    }

    //
    //  Now clear out the KQUEUE
    //
    for(;;)
    {
        pListEntry = KeRemoveQueue(&pUMRxEngine->Q.Queue,
                                   UserMode,
                                   &liTimeout);

        if (((ULONG_PTR)pListEntry == STATUS_TIMEOUT) ||
            ((ULONG_PTR)pListEntry == STATUS_USER_APC))
            break;

        //
        //  All address in the kernel should have the high bit set
        //  This won't be valid for Win64
        //
        ASSERT((ULONG_PTR)pListEntry & 0x80000000);
            
        if (&pUMRxEngine->Q.PoisonEntry == pListEntry)
            continue;

        //
        //  We have a valid queue entry
        //
        ASSERT(pListEntry);
        //
        //  Decode the UMRX_CONTEXT and RX_CONTEXT
        //
        pUMRxContext = CONTAINING_RECORD(
                                pListEntry,
                                UMRX_CONTEXT,
                                UserMode.WorkQueueLinks
                                );
                                
        RxContext =  pUMRxContext->RxContext;

        if (DfsDbgVerbose) DbgPrint("UMRxEngineCompleteQueuedRequests %08lx %08lx.\n",
                 RxContext,pUMRxContext);
        
        {
            // Complete the CALL!!!!!
            //
            pUMRxContext->Status = CompletionStatus;
            pUMRxContext->Information = 0;
            if (pUMRxContext->UserMode.CompletionRoutine != NULL)
            {
                ASSERT(pUMRxContext->UserMode.CompletionRoutine);
                if (DfsDbgVerbose) DbgPrint("  +++  Calling completion for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                pUMRxContext->UserMode.CompletionRoutine(
                            pUMRxContext,
                            RxContext,
                            NULL,
                            0
                            );
            }
        }

        //
        // Wake up the thread that's waiting for this request to complete.
        //
        UMRxWakeupWaitingWaiter(RxContext, pUMRxContext);
        
        if (fCleanup)
        {
            pUMRxEngine->Q.NumberOfWorkerThreads = 0;
            pUMRxEngine->Q.NumberOfWorkItems = 0;
        }
        else
        {
            InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkItems);
        }
    }
        
    //
    // Unlock the queue.
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                   ExGetCurrentResourceThread());

        
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}




NTSTATUS
UMRxEngineInitiateRequest (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_CONTINUE_ROUTINE Continuation
    )
/*++

Routine Description:

    Initiate a request to the UMR engine -
    This creates a UMRxContext that is used for response rendezvous.
    All IFS dispatch routines will start a user-mode reflection by
    calling this routine. Steps in routine:

    1. Allocate a UMRxContext and set RxContext
       (NOTE: need to have ASSERTs that validate this linkage)
    2. Set Continue routine ptr and call Continue routine
    3. If Continue routine is done ie not PENDING, Finalize UMRxContext
   
Arguments:

    PRX_CONTEXT RxContext               -   Initiating RxContext
    UMRX_CONTEXT_TYPE RequestType       -   Type of request
    PUMRX_CONTINUE_ROUTINE Continuation -   Request Continuation routine

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_CONTEXT pUMRxContext = NULL;
    BOOLEAN FinalizationComplete;

    DfsTraceEnter("UMRxEngineInitiateRequest");

    ASSERT(RxContext);
    ASSERT(Continuation);
    ASSERT(pUMRxEngine);

    //
    //  Creating an UMRxContext requires a finalization
    //
    pUMRxContext = UMRxCreateAndReferenceContext(
                                RxContext,
                                RequestType
                                );

    if (pUMRxContext==NULL) {
        if (DfsDbgVerbose) DbgPrint("Couldn't allocate UMRxContext!\n");
        DfsTraceLeave(STATUS_INSUFFICIENT_RESOURCES);
        return((STATUS_INSUFFICIENT_RESOURCES));
    }

    pUMRxContext->pUMRxEngine  = pUMRxEngine;
    pUMRxContext->Continuation = Continuation;
    Status = Continuation(pUMRxContext,RxContext);

    //
    //  This matches the Creation above -
    //  NOTE: The continuation should have referenced the UMRxContext if needed
    //
    FinalizationComplete = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        
    if (Status!=(STATUS_PENDING)) 
    {
        ASSERT(FinalizationComplete);
    } 
    else 
    {
        //bugbug
        //ASSERT( (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) ||
          //      (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED))  );
    }

    DfsTraceLeave(Status);
    return(Status);
}

PUMRX_CONTEXT
UMRxCreateAndReferenceContext (
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType
    )
/*++

Routine Description:

    Create an UMRX_CONTEXT - pool alloc
   
Arguments:

    PRX_CONTEXT RxContext           -   Initiating RxContex
    UMRX_CONTEXT_TYPE RequestType   -   Type of request

Return Value:

    PUMRX_CONTEXT   -   pointer to an UMRX_CONTEXT allocated

Notes:


--*/
{
    PUMRX_CONTEXT pUMRxContext = NULL;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext); //BUGBUG

    DfsTraceEnter("UMRxCreateContext");
    if (DfsDbgVerbose) DbgPrint("UMRxCreateContext  --> entering \n") ;
    
    pUMRxContext = (PUMRX_CONTEXT)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    sizeof(UMRX_CONTEXT),
                                                    UMRX_CONTEXT_TAG 
                                                    );
    if( pUMRxContext ) 
    {
        ZeroAndInitializeNodeType( 
                           pUMRxContext,
                           UMRX_NTC_CONTEXT,
                           sizeof(UMRX_CONTEXT)
                           );
        InterlockedIncrement( &pUMRxContext->NodeReferenceCount );

        //place a reference on the rxcontext until we are finished
        InterlockedIncrement( &RxContext->ReferenceCount );
        
        pUMRxContext->RxContext = RxContext;
        pUMRxContext->CTXType = RequestType;

        //bugbug
        RxMinirdrContext->pUMRxContext = pUMRxContext;
        pUMRxContext->SavedMinirdrContextPtr = RxMinirdrContext;
    }

    if (DfsDbgVerbose) DbgPrint("UMRxCreateContext  --> leaving \n");
    DfsTraceLeave(0);
    return(pUMRxContext);
}


BOOLEAN
UMRxDereferenceAndFinalizeContext (
    IN OUT PUMRX_CONTEXT pUMRxContext
    )
    
/*++

Routine Description:

    Destroy an UMRX_CONTEXT - pool free
   
Arguments:

    PUMRX_CONTEXT   -   pointer to an UMRX_CONTEXT to free

Return Value:

    BOOLEAN - TRUE if success, FALSE if failure

Notes:


--*/
{
    LONG result;
    PRX_CONTEXT RxContext;
    
    DfsTraceEnter("UMRxFinalizeContext");
    
    result =  InterlockedDecrement(&pUMRxContext->NodeReferenceCount);
    if ( result != 0 ) {
        if (DfsDbgVerbose) DbgPrint("UMRxFinalizeContext -- returning w/o finalizing (%d)\n",result);
        DfsTraceLeave(0);
        return FALSE;
    }

    //
    //  Ref count is 0 - finalize the UMRxContext
    //
    if ( (RxContext = pUMRxContext->RxContext) != NULL ) {
        PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
        ASSERT( RxMinirdrContext->pUMRxContext == pUMRxContext );

        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( pUMRxContext->RxContext );
    }

    ExFreePool(pUMRxContext);

    DfsTraceLeave(0);
    return TRUE;
}


NTSTATUS
UMRxEngineSubmitRequest(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    Submit a request to the UMR engine -
    This adds the request to the engine KQUEUE for processing by
    a user-mode thread. Steps:
  
    1. set the FORMAT and COMPLETION callbacks in the UMRxContext
    2. initialize the RxContext sync event
    3. insert the UMRxContext into the engine KQUEUE
    4. block on RxContext sync event (for SYNC operations)
    5. after unblock (ie umode response is back), call Resume routine
   
Arguments:

    PUMRX_CONTEXT pUMRxContext      -   ptr to UMRX_CONTEXT for request
    PRX_CONTEXT   RxContext         -   Initiating RxContext
    UMRX_CONTEXT_TYPE RequestType   -   Type of Request
    PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine     -   FORMAT routine
    PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine -   COMPLETION routine

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;
    PUMRX_ENGINE    pUMRxEngine = pUMRxContext->pUMRxEngine;
    ULONG           QueueState = 0;
    ULONG           ThreadAborted = 0;
    BOOLEAN         FinalizationCompleted = FALSE;
    PUMRX_RX_CONTEXT RxMinirdrContext = NULL;


    DfsTraceEnter("UMRxFinalizeContext");

    RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

    if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest\n");
    if (DfsDbgVerbose) DbgPrint("UMRxSubmitRequest entering......CTX=%08lx <%d>\n",
             pUMRxContext,RequestType);

    pUMRxContext->CTXType = RequestType;
    pUMRxContext->UserMode.FormatRoutine = FormatRoutine;
    pUMRxContext->UserMode.CompletionRoutine = CompletionRoutine;

    RxMinirdrContext->RxSyncTimeout = 1;
    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    //
    //  If we fail to submit, we should finalize right away
    //  If we succeed in submitting, we should finalize post completion
    //
    UMRxReferenceContext( pUMRxContext );

    //
    // Try to get a shared lock on the engine.
    // If this fails it means the lock is already own exclusive.
    //
    if (ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                                        FALSE))
    {
                QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                                                        UMRX_ENGINE_STATE_STARTED,
                                                                        UMRX_ENGINE_STATE_STARTED);
                if (UMRX_ENGINE_STATE_STARTED == QueueState)
                {
                        ThreadAborted = InterlockedCompareExchange(&pUMRxEngine->Q.ThreadAborted,
                                                                                                                0,
                                                                                                                0);
                        if (!ThreadAborted)
                        {
                                //
                                //  Insert request into engine KQUEUE
                                //    
                                //RxLog((" UMRSubmitReq to KQ UCTX RXC %lx %lx\n", pUMRxContext, RxContext));
                
                                KeInsertQueue(&pUMRxEngine->Q.Queue,
                                                        &pUMRxContext->UserMode.WorkQueueLinks);
                                
                                InterlockedIncrement(&pUMRxEngine->Q.NumberOfWorkItems);
                                
                                //
                                //  Did it abort while we were enqueing?
                                //
                                ThreadAborted = InterlockedCompareExchange(&pUMRxEngine->Q.ThreadAborted,
                                                                                                                        0,
                                                                                                                        0);
                                //
                                //  If it did abort, we need to clear out any pending requests.
                                //
                                if (ThreadAborted)
                                {
                                    UMRxAbortPendingRequests(pUMRxEngine);
                                }
                                
                                Status = STATUS_SUCCESS;
                        }
                        else
                        {
                                //
                                //  The engine is STARTED, but we have evidence that the
                                //     UMR server has crashed becuase the ThreadAborted value
                                //     is set.
                                //
                                Status = STATUS_DEVICE_NOT_CONNECTED;
                                if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest: Engine in aborted state.\n");
                        }
                }
                else
                {
                        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
                        //
                        //  The state isn't STARTED, so we'll bail out.
                        //
                        Status = STATUS_DEVICE_NOT_CONNECTED;
                        if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest: Engine is not started.\n");
                }

                ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                                                        ExGetCurrentResourceThread());          
    }
    else
    {
                //
                //  This means that someone owns the lock exclusively which means
                //    it's changing state which means we treat this as STOPPED.
                //
                Status = STATUS_DEVICE_NOT_CONNECTED;
                if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest failed to get shared lock\n");
    }

    //
    //  If we were able to insert the item in the queue, then let's
    //     do what we do to return the result.
    //
    if (NT_SUCCESS(Status))
    {
        //
        //  If async mode, return pending
        //  else if sync with timeout, wait with timeout
        //  else wait for response
        //

        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) {
            Status = STATUS_PENDING;
        } else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) {
            LARGE_INTEGER liTimeout;
            
            //
            //  Wait for UMR operation to complete
            //
            liTimeout.QuadPart = -10000 * 1000 * 15;    // 15 seconds
            RxWaitSyncWithTimeout( RxContext, &liTimeout );    

            //
            //  There could be a race with the response to resume the engine context -
            //  Need to synchronize using Interlocked operations !
            //
            if( Status == STATUS_TIMEOUT ) {
                if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) {
                    //
                    //  return STATUS_PENDING to caller - a sync reflection that
                    //  timed out is same as an async Rx.
                    //
                    Status = STATUS_PENDING;
                } else {
                    Status = UMRxResumeEngineContext( RxContext );
                }
            } else {
                Status = UMRxResumeEngineContext( RxContext );
            }
            
        } else {
            //
            //  Wait for UMR operation to complete
            //
            RxWaitSync( RxContext );    
            
            //at last, call the continuation........
            Status = UMRxResumeEngineContext( RxContext );
        }        
    }
    else
    {
        //
        // Remove the reference we added up above.
        //
        FinalizationCompleted = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        ASSERT( !FinalizationCompleted );
    }

    if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest returning %08lx.\n", Status);
    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return(Status);
}


NTSTATUS
UMRxResumeEngineContext(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    Resume is called after I/O thread is unblocked by umode RESPONSE.
    This routine calls any Finish callbacks and then Finalizes the 
    UMRxContext.
   
Arguments:

    RxContext - Initiating RxContext

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_EXISTS;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
    PUMRX_CONTEXT pUMRxContext = (PUMRX_CONTEXT)(RxMinirdrContext->pUMRxContext);

    DfsTraceEnter("UMRxResumeEngineContext");
    if (DfsDbgVerbose) DbgPrint("UMRxResumeEngineContext entering........CTX=%08lx\n",pUMRxContext);

    Status = pUMRxContext->Status;
    UMRxDereferenceAndFinalizeContext(pUMRxContext);

    if (DfsDbgVerbose) DbgPrint("UMRxResumeEngineContext returning %08lx.\n", Status);
    DfsTraceLeave(Status);
    return(Status);
}


void
UMRxDisassoicateMid(
    IN PUMRX_ENGINE pUMRxEngine,
    IN PUMRX_CONTEXT pUMRxContext,
    IN BOOLEAN fReleaseMidAtlasLock
    )
/*++

Routine Description:

    Disassociates a MID.  If there is someone waiting to acquire a mid,
    then this will reassociated the MID on behalf of the waiter.
    
    The MidManagementMutex is held on entry and released on exit.
    
Arguments:

    pUMRxEngine -- Engine that the MID is being disassociated from.
    mid         -- MID to be disassociated.
    fReleaseMidAtlasLock -- should the mid atlas lock be released?
    
Return Value:

    void

Notes:


--*/
{   
    USHORT mid = 0;


    mid = pUMRxContext->UserMode.CallUpMid;
    //
    //  Remove this from the active context list.
    //
    RemoveEntryList(&pUMRxContext->ActiveLink);
        
    if (IsListEmpty(&pUMRxEngine->WaitingForMidListhead)) {
        if (DfsDbgVerbose) DbgPrint("giving up mid %08lx...... mid %04lx.\n",
                    pUMRxEngine,
                    mid);
        
        RxMapAndDissociateMidFromContext(
                                         pUMRxEngine->MidAtlas,
                                         mid,
                                         &pUMRxContext);

        if (fReleaseMidAtlasLock)
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);

    } else {

        //
        //  This is the case where somebody is waiting to allocate a MID
        //    so we need to give the MID to them and associate it on their behalf.
        //
        PLIST_ENTRY ThisEntry = RemoveHeadList(&pUMRxEngine->WaitingForMidListhead);
        
        pUMRxContext = CONTAINING_RECORD(ThisEntry,
                                         UMRX_CONTEXT,
                                         UserMode.WorkQueueLinks);
        
        if (DfsDbgVerbose) DbgPrint(
                   "reassigning MID mid %08lx ...... mid %04lx %08lx.\n",
                    pUMRxEngine,
                    mid,
                    pUMRxContext);
        
        RxReassociateMid(
                         pUMRxEngine->MidAtlas,
                         mid,
                         pUMRxContext);
        //
        //  Add this context to the active link list
        //
        InsertTailList(&pUMRxEngine->ActiveLinkHead, &pUMRxContext->ActiveLink);
        
        if (fReleaseMidAtlasLock)
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);

        pUMRxContext->UserMode.CallUpMid = mid;
        KeSetEvent(
                   &pUMRxContext->UserMode.WaitForMidEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
}


NTSTATUS
UMRxVerifyHeader (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_CONTEXT *capturedContext
    )
/*++

Routine Description:

    This routine makes sure that the header passed in is valid....that is,
    that it really refers to the operation encoded. if it does, then it reasigns
    or releases the MID as appropriate.

Arguments:

Return Value:

    STATUS_SUCCESS if the header is good
    STATUS_INVALID_PARAMETER otherwise


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    UMRX_USERMODE_WORKITEM_HEADER capturedHeader;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader =
                (PUMRX_WORKITEM_HEADER_PRIVATE)(&capturedHeader);
 
    DfsTraceEnter("UMRxVerifyHeader");
    if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteUserModeRequest %08lx %08lx %08lx.\n",
             pUMRxEngine,WorkItem,
             PrivateWorkItemHeader->pUMRxContext);

    capturedHeader = WorkItem->Header;

    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
    pUMRxContext = RxMapMidToContext(pUMRxEngine->MidAtlas,
                                           PrivateWorkItemHeader->Mid);

    if (pUMRxContext)
    {
        RxContext = pUMRxContext->RxContext;
        
        ASSERT(RxContext);

        //
        //  Clear the cancel routine
        //
        Status = RxSetMinirdrCancelRoutine(RxContext,
                                           NULL);
        if (Status == STATUS_CANCELLED)
        {
            //
            //  The cancel routine is being called but hasn't removed this from the MID Atlas yet.
            //  In this case, we know that everthing is handled by the cancel routine.
            //  Setting this to NULL fakes the rest of this function and it's caller
            //  into thinking that the MID wasn't found in the Mid Atlas.  This is exactly what would
            //  have happened if the cancel routine had completed executing before we got to this point.
            //
            pUMRxContext = NULL;
        }
    }

    if ((pUMRxContext == NULL)
          || (pUMRxContext != PrivateWorkItemHeader->pUMRxContext)
          || (pUMRxContext->UserMode.CallUpMid
                                 != PrivateWorkItemHeader->Mid)
          || (pUMRxContext->UserMode.CallUpSerialNumber
                                 != PrivateWorkItemHeader->SerialNumber) ) {
        //this is a bad packet.....just release and get out!
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        if (DfsDbgVerbose) DbgPrint("UMRxVerifyHeader: %08lx %08lx\n",pUMRxContext,PrivateWorkItemHeader);
        Status = STATUS_INVALID_PARAMETER;
    } else {
        BOOLEAN Finalized;

        *capturedContext = pUMRxContext;
        if (ReassignmentCmd == DONT_REASSIGN_MID) {
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        } else {
            //now give up the MID.....if there is someone waiting then give it to him
            // otherwise, just give it back
            
            // On Entry, the MidManagementMutex is held
            //
            UMRxDisassoicateMid(pUMRxEngine,
                                pUMRxContext,
                                TRUE);
            //
            // Upon return, the MidManagementMutex is not held.
            //
            //remove the reference i put before i went off
            Finalized = UMRxDereferenceAndFinalizeContext(pUMRxContext);
            ASSERT(!Finalized);
        }
    }

    if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteUserModeRequest %08lx %08lx %08lx......%08lx.\n",
             pUMRxEngine,WorkItem,
             PrivateWorkItemHeader->pUMRxContext,Status);

    DfsTraceLeave(Status);
    return(Status);
}


NTSTATUS
UMRxAcquireMidAndFormatHeader (
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext,
    IN PUMRX_ENGINE  pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine gets a mid and formats the header.....it waits until it can
    get a MID if all the MIDs are currently passed out.

Arguments:

Return Value:

    STATUS_SUCCESS...later could be STATUS_CANCELLED


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader =
                (PUMRX_WORKITEM_HEADER_PRIVATE)(&WorkItem->Header);
    PUMRX_USERMODE_WORKITEM_HEADER PublicWorkItemHeader = 
        (PUMRX_USERMODE_WORKITEM_HEADER)(&WorkItem->Header);
    
    DfsTraceEnter("UMRxAcquireMidAndFormatHeader");
    if (DfsDbgVerbose) DbgPrint(
            "UMRxAcquireMidAndFormatHeader %08lx %08lx %08lx.\n",
             RxContext,pUMRxContext,WorkItem);

    RtlZeroMemory(&WorkItem->Header,
                  FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest));
        
    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
    UMRxReferenceContext( pUMRxContext ); //taken away as we disassociate the mid

    if (IsListEmpty(&pUMRxEngine->WaitingForMidListhead)) {
        Status = RxAssociateContextWithMid(
                                pUMRxEngine->MidAtlas,
                                pUMRxContext,
                                &pUMRxContext->UserMode.CallUpMid);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    if (Status == STATUS_SUCCESS) {
        //
        //  Add this context to the active link list
        //
        InsertTailList(&pUMRxEngine->ActiveLinkHead, &pUMRxContext->ActiveLink);
        
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
    } else {
        KeInitializeEvent(&pUMRxContext->UserMode.WaitForMidEvent,
                          NotificationEvent,
                          FALSE);
                          
        InsertTailList(&pUMRxEngine->WaitingForMidListhead,
                       &pUMRxContext->UserMode.WorkQueueLinks);
                       
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        KeWaitForSingleObject(
                    &pUMRxContext->UserMode.WaitForMidEvent,
                    Executive,
                    UserMode,
                    FALSE,
                    NULL);
                    
        Status = STATUS_SUCCESS;
    }

    PrivateWorkItemHeader->pUMRxContext = pUMRxContext;
    pUMRxContext->UserMode.CallUpSerialNumber
               = PrivateWorkItemHeader->SerialNumber
               = InterlockedIncrement(&pUMRxEngine->NextSerialNumber);
    PrivateWorkItemHeader->Mid = pUMRxContext->UserMode.CallUpMid;

    if (DfsDbgVerbose) DbgPrint(
        "UMRxAcquireMidAndFormatHeader %08lx %08lx %08lx returning %08lx.\n",
             RxContext,pUMRxContext,WorkItem,Status);
             
    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return(Status);
}


//
//  The following functions run in the context of user-mode
//  worker threads that issue WORK IOCTLs. The IOCTL calls the
//  following functions in order:
//  1. UMRxCompleteUserModeRequest() - process a response if needed
//  2. UMRxEngineProcessRequest()  - process a request if one is
//     available on the UMRxEngine KQUEUE. 
//

NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    IN BOOLEAN fReleaseUmrRef,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT BOOLEAN * pfReturnImmediately
    )
/*++

Routine Description:

    Every IOCTL pended is potentially a Response. If so, process it.
    The first IOCTL pended is usually a NULL Response or 'listen'.
    Steps:  
    1. Get MID from response buffer. Map MID to UMRxContext.
    2. Call UMRxContext COMPLETION routine.
    3. Unblock the I/O thread waiting in UMRxEngineSubmitRequest()
   
Arguments:

    PUMRX_ENGINE pUMRxEngine            -   UMRX engine context
    PUMRX_USERMODE_WORKITEM WorkItem    -   WorkItem to process
    ULONG WorkItemLength                -   WorkItem length
    BOOLEAN fReleaseUmrRef              -   Should it be released?
    PIO_STATUS_BLOCK IoStatus           -   STATUS of operation
    BOOLEAN *pfReturnImmediately        -   Parse this out of the response.

Return Value:

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    LONG lRefs = 0;
    
    DfsTraceEnter("UMRxCompleteUserModeRequest");
    if (DfsDbgVerbose) DbgPrint("UMRxCompleteUserModeRequest -> %08lx %08lx %08lx\n",
            pUMRxEngine,PsGetCurrentThread(),WorkItem);
            
    try
    {

        ASSERT(pfReturnImmediately);

        *pfReturnImmediately = FALSE;
        IoStatus->Information = 0;
        IoStatus->Status = STATUS_CANNOT_IMPERSONATE;

        if ((NULL == WorkItem) ||
            (WorkItemLength < sizeof(UMRX_USERMODE_WORKITEM_HEADER)) ||
            (WorkItem->Header.CorrelatorAsUInt[0] == 0)) {
            //  NULL/zero length WorkItem => this is a 'listen'
            IoStatus->Status = Status;
            IoStatus->Information = 0;
            return Status;
        }

        *pfReturnImmediately = !!(WorkItem->Header.ulFlags & UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE);

        Status = UMRxVerifyHeader(pUMRxEngine,
                                  WorkItem,
                                  REASSIGN_MID,
                                  &pUMRxContext);

        if (Status != STATUS_SUCCESS) {
            IoStatus->Status = Status;
            if (DfsDbgVerbose) DbgPrint(
                    "UMRxCompleteUserModeRequest [badhdr] %08lx %08lx %08lx returning %08lx.\n",
                    pUMRxEngine,PsGetCurrentThread(),WorkItem,Status);
            DfsTraceLeave(Status);
            RtlZeroMemory(&WorkItem->Header,sizeof(UMRX_USERMODE_WORKITEM_HEADER));
            return(Status);
        }

        RxContext = pUMRxContext->RxContext;

        //BUGBUG need try/except
        pUMRxContext->IoStatusBlock = WorkItem->Header.IoStatus;
        if (pUMRxContext->UserMode.CompletionRoutine != NULL) {
            pUMRxContext->UserMode.CompletionRoutine(
                            pUMRxContext,
                            RxContext,
                            WorkItem,
                            WorkItemLength
                            );
        }

        if( fReleaseUmrRef ) 
        {
           //
           //  NOTE: UmrRef needs to be released AFTER completion routine is called !
           //

            //BUGBUGBUG
           ReleaseUmrRef() ;                
        }

        RtlZeroMemory(&WorkItem->Header,sizeof(UMRX_USERMODE_WORKITEM_HEADER));

        //
        //  release the initiating RxContext !
        //
        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
        {
            //at last, call the continuation........
            Status = UMRxResumeEngineContext( RxContext );
        } 
        else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
        {
            PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

            if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
            {
                //
                // We won - signal and we are done !
                //
                RxSignalSynchronousWaiter(RxContext);
            } 
            else 
            {
                //
                //  The reflection request has timed out in an async fashion -
                //  We need to complete the job of resuming the engine context !
                //
                Status = UMRxResumeEngineContext( RxContext );
            }

        } 
        else 
        {
            RxSignalSynchronousWaiter(RxContext);
        }


        if (DfsDbgVerbose) DbgPrint("UMRxCompleteUserModeRequest -> %08lx %08lx %08lx ret %08lx\n",
                pUMRxEngine,PsGetCurrentThread(),WorkItem,Status);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    DfsTraceLeave(Status);
    return(Status);
}


NTSTATUS
UMRxCancelRoutineEx(
      IN PRX_CONTEXT RxContext,
      IN BOOLEAN fMidAtlasLockAcquired
      )
/*++

Routine Description:

    CancelIO handler routine.

Arguments:

    PRX_CONTEXT RxContext               -   Initiating RxContext
    BOOLEAN     fMidAtlasLockAcquired   -   The caller controls the locking

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/      
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_ENGINE pUMRxEngine = GetUMRxEngineFromRxContext();
    PUMRX_CONTEXT pUMRxContext = NULL;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
    BOOLEAN  Finalized = FALSE;

    ASSERT(RxMinirdrContext);
    ASSERT(RxMinirdrContext->pUMRxContext);

    if (!fMidAtlasLockAcquired)
        ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
        
    pUMRxContext = RxMapMidToContext(pUMRxEngine->MidAtlas,
                                     RxMinirdrContext->pUMRxContext->UserMode.CallUpMid);
    if (pUMRxContext &&
        (pUMRxContext == RxMinirdrContext->pUMRxContext))
    {

        ASSERT(pUMRxContext->RxContext == RxContext);

        UMRxDisassoicateMid(pUMRxEngine,
                            pUMRxContext,
                            (BOOLEAN)!fMidAtlasLockAcquired);
        //
        // Side affect of above call is the release of the MidManagementMutex
        //
        //
        // Remove the reference on the UMRxContext when the mid was associated with
        //    it.
        //
        Finalized = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        ASSERT(!Finalized);

        // Complete the CALL!!!!!
        //
        pUMRxContext->Status = STATUS_CANCELLED;
        pUMRxContext->Information = 0;
        if (pUMRxContext->UserMode.CompletionRoutine != NULL)
        {
            if (DfsDbgVerbose) DbgPrint("  ++  Calling completion for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            pUMRxContext->UserMode.CompletionRoutine(
                        pUMRxContext,
                        RxContext,
                        NULL,
                        0
                        );
        }

        //
        //  Now Release the UmrRef.
        //  NOTE: UmrRef needs to be released AFTER completion routine is called !
        //
         ReleaseUmrRef();

        //
        // Wake up the thread that's waiting for this request to complete.
        //        
        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
        {
            //at last, call the continuation........
            if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            Status = UMRxResumeEngineContext( RxContext );
        } 
        else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
        {

            if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
            {
                //
                // We won - signal and we are done !
                //
                if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                RxSignalSynchronousWaiter(RxContext);
            } 
            else 
            {
                //
                //  The reflection request has timed out in an async fashion -
                //  We need to complete the job of resuming the engine context !
                //
                if (DfsDbgVerbose) DbgPrint("SYNC Rx completing async %x\n",RxContext);
                if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                Status = UMRxResumeEngineContext( RxContext );
            }
        
        } 
        else 
        {
            if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            RxSignalSynchronousWaiter(RxContext);
        }                

    }
    else
    {
        // It didn't match.  The request must have completed normally
        //   on its own.
        // We'll release the mutex now.
        //
        if (!fMidAtlasLockAcquired)     
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);           
            
        if (DfsDbgVerbose) DbgPrint("  ++  Store Mid Context doesn't match RxContext for: 0x%08x, 0x%08x 0x%08x\n", pUMRxContext, RxContext, RxMinirdrContext->pUMRxContext);
    }       

    return Status;
}


NTSTATUS
UMRxCancelRoutine(
      IN PRX_CONTEXT RxContext
      )
{   
    return UMRxCancelRoutineEx(RxContext, FALSE);
}



void
UMRxMidAtlasIterator(IN PUMRX_CONTEXT pUMRxContext)
{
    if (DfsDbgVerbose) DbgPrint("  ++  Canceling: 0x%08x, 0x%08x\n",
             pUMRxContext, pUMRxContext->RxContext);
    UMRxCancelRoutineEx(pUMRxContext->RxContext,
                      TRUE);
}


void
UMRxAbortPendingRequests(IN PUMRX_ENGINE pUMRxEngine)
{
    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);

    RxIterateMidAtlasAndRemove(pUMRxEngine->MidAtlas, UMRxMidAtlasIterator);

    ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
}


//
//  NOTE: if no requests are available, the user-mode thread will
//  block till a request is available (It is trivial to make this
//  a more async model).
//  
NTSTATUS
UMRxEngineProcessRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    OUT PULONG FormattedWorkItemLength
    )
/*++

Routine Description:
  
    If a request is available, get the corresponding UMRxContext and
    call ProcessRequest.
    Steps:
    1. Call KeRemoveQueue() to remove a request from the UMRxEngine KQUEUE.
    2. Get a MID for this UMRxContext and fill it in the WORK_ITEM header.
    3. Call the UMRxContext FORMAT routine - this fills in the Request params.
    4. return STATUS_SUCCESS - this causes the IOCTL to complete which
       triggers the user-mode completion and processing of the REQUEST.
   
Arguments:

    PUMRX_CONTEXT pUMRxContext          -   UMRX_CONTEXT for request
    PUMRX_USERMODE_WORKITEM WorkItem    -   Request WorkItem 
    ULONG WorkItemLength                -   WorkItem length
    PULONG FormattedWorkItemLength      -   Len of formatted data in buffer

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    PETHREAD CurrentThread = PsGetCurrentThread();
    PLIST_ENTRY pListEntry = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    ULONG i = 0;
    BOOLEAN fReleaseUmrRef = FALSE;
    BOOLEAN fLockAcquired = FALSE;
    BOOLEAN fThreadCounted = TRUE;
    ULONG   QueueState;
    PUMRX_USERMODE_WORKITEM WorkItemLarge;
    ULONG                   WorkItemLengthLarge;
    ULONG                   FormattedWorkItemLengthLarge = 0;

    DfsTraceEnter("UMRxEngineProcessRequest");
    if (DfsDbgVerbose) DbgPrint("UMRxEngineProcessRequest [Start] -> %08lx %08lx %08lx\n",
            pUMRxEngine,CurrentThread,WorkItem);

    *FormattedWorkItemLength = 0;

    if (WorkItemLength < (ULONG)FIELD_OFFSET(UMRX_USERMODE_WORKITEM,Pad[0])) {
        Status = STATUS_BUFFER_TOO_SMALL;
        if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest [noacc] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
        goto Exit;
    }

    //
    //  First try to get a shared lock on the UMR Engine.
    //
    fLockAcquired = ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                FALSE); 
    if (!fLockAcquired)
    {
        //
        //  We didn't get it, so the engine is either startup up or shutting down.
        //  In either case, we'll bail out.
        //
        if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [NotStarted] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
            goto Exit;
    }

    //
    //  Now let's check the current engine state.
    //
    QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                    UMRX_ENGINE_STATE_STARTED,
                                    UMRX_ENGINE_STATE_STARTED);
    if (UMRX_ENGINE_STATE_STARTED != QueueState)
    {
        //
        //  Must be stopped, so we'll bail out.
        //
        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
        if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest [NotStarted2] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
            goto Exit;
    }
    
    //
    //  Remove a request from engine KQUEUE
    //
    InterlockedIncrement(&pUMRxEngine->Q.NumberOfWorkerThreads);
    fThreadCounted = TRUE;
    
    for (i=1;;i++) {

        fReleaseUmrRef = FALSE;

        //
        //  Temporarily enable Kernel APC delivery to this thread
        //     This is because the system will delivery an APC if the
        //     process that this thread owned by dies.
        //
        FsRtlExitFileSystem();
        
        pListEntry = KeRemoveQueue(
                         &pUMRxEngine->Q.Queue,
                         UserMode,
                         &pUMRxEngine->Q.TimeOut
                         );
        
        //
        //  Now, Disable Kernel APC Delivery again.
        //
        FsRtlEnterFileSystem();

        //if (DfsDbgVerbose) DbgPrint("Dequeued entry %x\n",pListEntry);
        //if (DfsDbgVerbose) DbgPrint("poison entry is %x\n",&pUMRxEngine->Q.PoisonEntry);
        
        if ((ULONG_PTR)pListEntry == STATUS_TIMEOUT) 
        {
#if 0
            if ((i%5)==0) 
            {
                if (DfsDbgVerbose) DbgPrint(
                    "UMRxEngineProcessRequest [repost] -> %08lx %08lx %08lx i=%d\n",
                    pUMRxEngine,CurrentThread,WorkItem,i);
            }
#endif
            continue;
        }

        //  may have to check for STATUS_ALERTED so we handle the kill case !!
        if ((ULONG_PTR)pListEntry == STATUS_USER_APC) 
         {
            Status = STATUS_USER_APC;
            if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [usrapc] -> %08lx %08lx %08lx i=%d\n",
                pUMRxEngine,CurrentThread,WorkItem,i);

            //
            //  unblock outstanding requests in MID ATLAS....
            //
            UMRxAbortPendingRequests(pUMRxEngine);
            
            Status = STATUS_REQUEST_ABORTED;
            break;
        }

        if (pListEntry == &pUMRxEngine->Q.PoisonEntry) 
        {
            if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [poison] -> %08lx %08lx %08lx\n",
                pUMRxEngine,CurrentThread,WorkItem);
            //Status = STATUS_REQUEST_ABORTED;
            KeInsertQueue(&pUMRxEngine->Q.Queue,pListEntry);
            goto Exit;
        }

        InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkItems);
        //
        //  Decode the UMRX_CONTEXT and RX_CONTEXT
        //
        pUMRxContext = CONTAINING_RECORD(
                                pListEntry,
                                UMRX_CONTEXT,
                                UserMode.WorkQueueLinks
                                );
                                
        RxContext =  pUMRxContext->RxContext; 

        if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest %08lx %08lx %08lx.\n",
                 RxContext,pUMRxContext,WorkItem);

        //
        //  Acquire MID for UMRX_CONTEXT and call FORMAT routine
        //
        Status = UMRxAcquireMidAndFormatHeader(
                            pUMRxContext,
                            RxContext,
                            pUMRxEngine,
                            WorkItem
                            );

        //
        //  Get a reference to use the Umr for this netroot.
        //
        if (STATUS_SUCCESS == Status )  
        {
           AddUmrRef();
           fReleaseUmrRef = TRUE;
        }

        WorkItem->Header.ulHeaderVersion = UMR_VERSION;
        if ((Status == STATUS_SUCCESS)
             && (pUMRxContext->UserMode.FormatRoutine != NULL)) 
        {
            Status = pUMRxContext->UserMode.FormatRoutine(
                        pUMRxContext,
                        RxContext,
                        WorkItem,
                        WorkItemLength,
                        FormattedWorkItemLength
                        );
            if (( Status != STATUS_SUCCESS ) &&
                ( Status != STATUS_BUFFER_OVERFLOW ) &&
                ( Status != STATUS_DISK_FULL ) &&
                ( Status != STATUS_NO_MEMORY ) &&
                ( Status != STATUS_INSUFFICIENT_RESOURCES ) &&
                ( Status != STATUS_INVALID_PARAMETER )) {
                ASSERT( FALSE );
            }
        }

        if (Status == STATUS_SUCCESS)
        {
            //
            // Establish the Cancel Routine.
            //
            Status = RxSetMinirdrCancelRoutine(RxContext,
                                               UMRxCancelRoutine);
            //
            // This may return STATUS_CANCELED in which case the request will
            //   be completed below.
            //
        }

        //
        //  If FORMAT fails, complete the request here !
        //
        if( Status != STATUS_SUCCESS )
        {
            IO_STATUS_BLOCK IoStatus;
            BOOLEAN fReturnImmediately;

            IoStatus.Status =
            pUMRxContext->Status =
            WorkItem->Header.IoStatus.Status = Status;
            
            IoStatus.Information =
            pUMRxContext->Information =
            WorkItem->Header.IoStatus.Information = 0;
            
            Status = UMRxCompleteUserModeRequest(
                                    pUMRxEngine,
                                    WorkItem,
                                    WorkItemLength,
                                    FALSE,
                                    &IoStatus,
                                    &fReturnImmediately
                                    );

            if (fReleaseUmrRef)
            {
                //
                //  NOTE: UmrRef needs to be released AFTER completion routine is called !
                //
                ReleaseUmrRef();
            }
                                    
            continue;
        }

        //
        //  go back to user-mode to process this request !
        //
        Status = STATUS_SUCCESS;
        break;
    }

Exit:
    //
    //  If one of the threads received a USER_APC, then we want to take
    //    note of this.  This will be another condition undewich client
    //    threads do not enqueue reuqests becuase the UMR server has likely
    //    crashed.
    //
    if (STATUS_REQUEST_ABORTED == Status) 
    {
        if( InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,1) == 0 ) 
        {
            if (DfsDbgVerbose) DbgPrint("Usermode crashed......\n");
        }
    }
    
    if (fThreadCounted)
        InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkerThreads);

    if (fLockAcquired)
        ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());

    if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest %08lx %08lx %08lx returning %08lx.\n",
             RxContext,pUMRxContext,WorkItem,Status);

    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return Status;
}


NTSTATUS
UMRxCompleteQueueRequestsWithError(
    IN PUMRX_ENGINE pUMRxEngine,
    IN NTSTATUS     CompletionStatus
    )
/*++

Routine Description:

    This is currently called whenever there isn't enough memory in usermode to
    process requests from the kernel.  We should complete any requests queued to the UMR
    with whatever error is supplied in this call.
   
Arguments:

    PUMRX_ENGINE pUMRxEngine    -   Engine to complete requests against.
    NTSTATUS     CompletionStatus  -- Error to complete requests with.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    BOOLEAN fLockAcquired = FALSE;
    ULONG   QueueState = 0;
    
    //
    //  First try to get a shared lock on the UMR Engine.
    //
    fLockAcquired = ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                FALSE); 
    if (!fLockAcquired)
    {
        //
        //  We didn't get it, so the engine is either startup up or shutting down.
        //  In either case, we'll bail out.
        //
        if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteQueueRequestsWithError [NotStarted] -> %08lx %08lx\n",
            pUMRxEngine, PsGetCurrentThread());
        goto Exit;
    }

    //
    //  Now let's check the current engine state.
    //
    QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                    UMRX_ENGINE_STATE_STARTED,
                                    UMRX_ENGINE_STATE_STARTED);
    if (UMRX_ENGINE_STATE_STARTED != QueueState)
    {
        //
        //  Must be stopped, so we'll bail out.
        //
        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
        if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteQueueRequestsWithError [NotStarted2] -> %08lx %08lx\n",
            pUMRxEngine, PsGetCurrentThread());
        goto Exit;
    }
    
    


Exit:    
    if (fLockAcquired)
        ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
        
    return STATUS_SUCCESS;
}



NTSTATUS
UMRxEngineReleaseThreads(
    IN PUMRX_ENGINE pUMRxEngine
    )
/*++

Routine Description:

    This is called in response to a WORK_CLEANUP IOCTL.
    This routine will insert a dummy item in the engine KQUEUE.
    Each such dummy item inserted will release one thread.
   
Arguments:

    PUMRX_ENGINE pUMRxEngine    -   Engine to release threads on

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    BUGBUG: This should be serialized !

--*/
{
    ULONG PreviousQueueState = 0;

    DfsTraceEnter("UMRxEngineReleaseThreads");
    if (DfsDbgVerbose) DbgPrint("UMRxEngineReleaseThreads [Start] -> %08lx\n", pUMRxEngine);

    //
    //  First change the state so that nobody will try to get in.
    //
    PreviousQueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STOPPING,
                                            UMRX_ENGINE_STATE_STARTED);

    if (UMRX_ENGINE_STATE_STARTED != PreviousQueueState)
    {
        if (DfsDbgVerbose) DbgPrint("UMRxEngineReleaseThreads unexpected previous queue state: 0x%08x => %d\n",
                             pUMRxEngine, PreviousQueueState);
        CHECK_STATUS(STATUS_UNSUCCESSFUL) ;
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Now, get any threads that are queued up to vacate.
    //
    KeInsertQueue(&pUMRxEngine->Q.Queue,
                  &pUMRxEngine->Q.PoisonEntry);

    //
    //  We won't be granted exclusive until all the threads queued have vacated.
    //
    ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock,
                                    TRUE);
    
    //
    //  Now, that we know there aren't any threads in here, we can change
    //    the state to STOPPED;
    //
    PreviousQueueState = InterlockedExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STOPPED);

    ASSERT(UMRX_ENGINE_STATE_STOPPING == PreviousQueueState);

    //
    // Now, relinquish the lock
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                    ExGetCurrentResourceThread());
    
    if (DfsDbgVerbose) DbgPrint("UMRxReleaseCapturedThreads %08lx [exit] -> %08lx\n", pUMRxEngine);
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsinit.h ===
#ifndef __DFS_INIT__
#define __DFS_INIT__


//
//  Device extension definition for our driver.  Note that the same extension
//  is used for the following types of device objects:
//      - File system device object we attach to
//      - Mounted volume device objects we attach to
//

typedef struct _DFS_FILTER_DEVICE_EXTENSION {

    //
    //  Pointer to the file system device object we are attached to
    //

    PDEVICE_OBJECT AttachedToDeviceObject;

    //
    //  Pointer to the real (disk) device object that is associated with
    //  the file system device object we are attached to
    //

    PDEVICE_OBJECT DiskDeviceObject;

    //
    //  A cached copy of the name (if enabled) of the device we are attached to.
    //  - If it is a file system device object it will be the name of that
    //    device object.
    //  - If it is a mounted volume device object it will be the name of the
    //    real device object (since mounted volume device objects don't have
    //    names).
    //

    UNICODE_STRING Name;

    //Number of times we have attached to this device

    LONG RefCount;

    //TRUE if we are attached to this device and DFS is currently using
    //the device. Since we can't detach from a device once attached, this
    //variable is set to FALSE when we are no longer interested in this
    //device

    BOOLEAN DeviceInUse;
} DFS_FILTER_DEVICE_EXTENSION, *PDFS_FILTER_DEVICE_EXTENSION;

//
// Macro to test if we are still using a device object

#define IS_DFS_ATTACHED(pDeviceObject) \
     ((((PDFS_FILTER_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->DeviceInUse))



extern PDRIVER_OBJECT gpDfsFilterDriverObject;
extern PDEVICE_OBJECT gpDfsFilterControlDeviceObject;
extern FAST_IO_DISPATCH DfsFastIoDispatch;


//#define DFS_FILTER_NAME               L"\\FileSystem\\DfsFilter"
//#define DFS_FILTER_NAME               L"\\FileSystem\\Filters\\DfsFilter"
#define DFS_FILTER_DOSDEVICE_NAME     L"\\??\\DfsFilter"

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj) != NULL) && \
     ((_devObj)->DriverObject == gpDfsFilterDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))


//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == gpDfsFilterControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == gpDfsFilterDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    ((_type) == FILE_DEVICE_DISK_FILE_SYSTEM)


//
//  Macro to validate our current IRQL level
//

#define VALIDATE_IRQL(_irp) (ASSERT(KeGetCurrentIrql() <= APC_LEVEL))



VOID
DfsCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject);

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//

#define try_return(S) { S; goto try_exit; }

#ifndef NOTHING
#define NOTHING
#endif

#endif //__DFS_INIT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsumrrequests.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrrequests.c

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/
              
#include "ntifs.h"
#include <windef.h>
#include <smbtypes.h>
#include <smbtrans.h>
#include "DfsInit.h"
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>
#include <dfsumr.h>
#include <umrx.h>
#include <DfsUmrCtrl.h>
#include <dfsfsctl.h>


NTSTATUS
UMRxFormatUserModeGetReplicasRequest (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength,
    PULONG ReturnedLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferLengthAvailable = 0;
    ULONG BufferLengthNeeded = 0;
    PUMR_GETDFSREPLICAS_REQ GetReplicaRequest = NULL;
    PBYTE Buffer = NULL;

    PAGED_CODE();

    GetReplicaRequest = &WorkItem->WorkRequest.GetDfsReplicasRequest;
    *ReturnedLength = 0;

    BufferLengthAvailable = WorkItemLength - FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.GetDfsReplicasRequest.RepInfo.LinkName[0]);
    BufferLengthNeeded = RxContext->InputBufferLength;

    *ReturnedLength = FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.GetDfsReplicasRequest.RepInfo.LinkName[0]) + BufferLengthNeeded;

    if (WorkItemLength < *ReturnedLength)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    WorkItem->Header.WorkItemType = opUmrGetDfsReplicas;

    Buffer = (PBYTE)(GetReplicaRequest);

    RtlCopyMemory(Buffer,
              RxContext->InputBuffer,
              RxContext->InputBufferLength);

    return Status;
}

VOID
UMRxCompleteUserModeGetReplicasRequest (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMR_GETDFSREPLICAS_RESP GetReplicasResponse = NULL;

    PAGED_CODE();


    GetReplicasResponse = &WorkItem->WorkResponse.GetDfsReplicasResponse;

    //this means that the request was cancelled
    if ((NULL == WorkItem) || (0 == WorkItemLength))
    {
        Status = pUMRxContext->Status;
        goto Exit;
    }

    Status = WorkItem->Header.IoStatus.Status;
    if (Status != STATUS_SUCCESS) 
    {
        goto Exit ;
    }

    if(RxContext->OutputBufferLength < GetReplicasResponse->Length)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit;
    }


   // Status = PktpCheckReferralSyntax(NULL,
                              //  (PRESP_GET_DFS_REFERRAL) GetReplicasResponse->Buffer,
                                //(DWORD) GetReplicasResponse->Length);

    RtlCopyMemory(RxContext->OutputBuffer,
                  GetReplicasResponse->Buffer,
                  GetReplicasResponse->Length);


   RxContext->ReturnedLength = GetReplicasResponse->Length;

Exit:

    RxContext->Status = Status;
    pUMRxContext->Status = Status;
}

NTSTATUS
UMRxGetReplicasContinuation(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    Status = UMRxEngineSubmitRequest(
                         pUMRxContext,
                         RxContext,
                         UMRX_CTXTYPE_GETDFSREPLICAS,
                         UMRxFormatUserModeGetReplicasRequest,
                         UMRxCompleteUserModeGetReplicasRequest
                         );

    return(Status);
}

NTSTATUS 
DfsGetReplicaInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PRX_CONTEXT pRxContext = NULL;
    PREPLICA_DATA_INFO pRep = NULL;

    PAGED_CODE();

    //make sure we are all hooked up before flying into 
    //user mode
    if(GetUMRxEngineFromRxContext() == NULL)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        return Status;
    }

    //get the input buffer
    pRep = (PREPLICA_DATA_INFO) InputBuffer;

    //check if the buffer is large enough to hold the
    //data passed in
    if(InputBufferLength < sizeof(REPLICA_DATA_INFO))
    {
        return Status;  
    }

    //make sure the referral level is good
    if((pRep->MaxReferralLevel > 3) || (pRep->MaxReferralLevel < 1))
    {
        pRep->MaxReferralLevel = 3;
    }


    //set the outputbuffersize
    pRep->ClientBufferSize = OutputBufferLength;

    //create a context structure
    pRxContext = RxCreateRxContext (Irp, 0);
    if(pRxContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    pRxContext->OutputBuffer = OutputBuffer;
    pRxContext->OutputBufferLength = OutputBufferLength;
    pRxContext->InputBuffer = InputBuffer;
    pRxContext->InputBufferLength = InputBufferLength;

    //make the request to user mode
    Status = UMRxEngineInitiateRequest(
                                       GetUMRxEngineFromRxContext(),
                                       pRxContext,
                                       UMRX_CTXTYPE_GETDFSREPLICAS,
                                       UMRxGetReplicasContinuation
                                      );

    pIoStatusBlock->Information = pRxContext->ReturnedLength;

    //delete context
    RxDereferenceAndDeleteRxContext(pRxContext);

    return Status;
}


NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD AllocSize = 0;
    PDFS_GET_REFERRALS_INPUT_ARG pArg = NULL;
    PREPLICA_DATA_INFO pRep = NULL;
    PUNICODE_STRING Prefix = NULL;
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    if (InputBufferLength < sizeof(DFS_GET_REFERRALS_INPUT_ARG))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    pArg = (PDFS_GET_REFERRALS_INPUT_ARG) InputBuffer;
    Prefix = &pArg->DfsPathName;
    
    //get the size of the allocation
    AllocSize = sizeof(REPLICA_DATA_INFO) + Prefix->MaximumLength;
    pRep = (PREPLICA_DATA_INFO) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                AllocSize,
                                                'xsfD'
                                                );
    if(pRep == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    //zero the memory
    RtlZeroMemory(pRep, AllocSize);

    //setup the structure
    pRep->MaxReferralLevel = pArg->MaxReferralLevel;
    pRep->Flags = DFS_OLDDFS_SERVER;
    pRep->CostLimit = 1000;
    pRep->NumReplicasToReturn = 1000;
    pRep->IpFamily = pArg->IpAddress.IpFamily;
    pRep->IpLength = pArg->IpAddress.IpLen;
    
    RtlCopyMemory(pRep->IpData, pArg->IpAddress.IpData, pArg->IpAddress.IpLen); 
    
    pRep->LinkNameLength = Prefix->MaximumLength;
    
    RtlCopyMemory(pRep->LinkName, Prefix->Buffer, Prefix->MaximumLength);

    //make the request to usermode
    Status = DfsGetReplicaInformation((PVOID) pRep, 
                                      AllocSize,
                                      OutputBuffer, 
                                      OutputBufferLength,
                                      Irp,
                                      pIoStatusBlock);

    ExFreePool (pRep);
    return Status;
}



NTSTATUS
UMRxFormatUserModeIsDfsLink (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength,
    PULONG ReturnedLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferLengthAvailable = 0;
    ULONG BufferLengthNeeded = 0;
    PUMR_ISDFSLINK_REQ IsDfsLinkRequest = NULL;
    PDFS_FIND_SHARE_ARG pShare = NULL;
    PBYTE Buffer = NULL;

    PAGED_CODE();

    IsDfsLinkRequest = &WorkItem->WorkRequest.IsDfsLinkRequest;
    *ReturnedLength = 0;

    BufferLengthAvailable = WorkItemLength - FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.IsDfsLinkRequest);
    BufferLengthNeeded = RxContext->InputBufferLength;

    *ReturnedLength = FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.IsDfsLinkRequest.Buffer[0]) + BufferLengthNeeded;

    if (WorkItemLength < *ReturnedLength)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    pShare = (PDFS_FIND_SHARE_ARG) RxContext->InputBuffer;

    WorkItem->Header.WorkItemType = opUmrIsDfsLink;

    IsDfsLinkRequest->Length = pShare->ShareName.Length;
    Buffer = (PBYTE)(IsDfsLinkRequest->Buffer[0]);

    RtlCopyMemory(Buffer,
              pShare->ShareName.Buffer,
              pShare->ShareName.Length);

    return Status;
}

VOID
UMRxCompleteUserModeIsDfsLink (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //this means that the request was cancelled
    if ((NULL == WorkItem) || (0 == WorkItemLength))
    {
        Status = pUMRxContext->Status;
        goto Exit;
    }

    Status = WorkItem->Header.IoStatus.Status;
    if(Status == STATUS_SUCCESS)
    {
        Status = STATUS_PATH_NOT_COVERED;
    }
    else
    {
        Status = STATUS_BAD_NETWORK_NAME;
    }

Exit:

    RxContext->Status = Status;
    pUMRxContext->Status = Status;
}

NTSTATUS
UMRxIsDfsLinkContinuation(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    Status = UMRxEngineSubmitRequest(
                         pUMRxContext,
                         RxContext,
                         UMRX_CTXTYPE_IFSDFSLINK,
                         UMRxFormatUserModeIsDfsLink,
                         UMRxCompleteUserModeIsDfsLink
                         );

    return(Status);
}



NTSTATUS 
DfsIsADfsLinkInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PRX_CONTEXT pRxContext = NULL;
    PREPLICA_DATA_INFO pRep = NULL;

    PAGED_CODE();

    //make sure we are all hooked up before flying into 
    //user mode
    if(GetUMRxEngineFromRxContext() == NULL)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto Exit;
    }

    //create a context structure
    pRxContext = RxCreateRxContext (Irp, 0);
    if(pRxContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    pRxContext->OutputBuffer = OutputBuffer;
    pRxContext->OutputBufferLength = OutputBufferLength;
    pRxContext->InputBuffer = InputBuffer;
    pRxContext->InputBufferLength = InputBufferLength;

    //make the request to user mode
    Status = UMRxEngineInitiateRequest(
                                       GetUMRxEngineFromRxContext(),
                                       pRxContext,
                                       UMRX_CTXTYPE_IFSDFSLINK,
                                       UMRxIsDfsLinkContinuation
                                      );

  
    //delete context
    RxDereferenceAndDeleteRxContext(pRxContext);

Exit:

    pIoStatusBlock->Status = Status;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsfastio.c ===
#include "ntifs.h"
#include "DfsInit.h"

//
//  Macro to test if FAST_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))

BOOLEAN
DfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

VOID
DfsFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice );

BOOLEAN
DfsFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject);





FAST_IO_DISPATCH DfsFastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),
    DfsFastIoCheckIfPossible,           //  CheckForFastIo
    DfsFastIoRead,                      //  FastIoRead
    DfsFastIoWrite,                     //  FastIoWrite
    DfsFastIoQueryBasicInfo,            //  FastIoQueryBasicInfo
    DfsFastIoQueryStandardInfo,         //  FastIoQueryStandardInfo
    DfsFastIoLock,                      //  FastIoLock
    DfsFastIoUnlockSingle,              //  FastIoUnlockSingle
    DfsFastIoUnlockAll,                 //  FastIoUnlockAll
    DfsFastIoUnlockAllByKey,            //  FastIoUnlockAllByKey
    DfsFastIoDeviceControl,             //  FastIoDeviceControl
    NULL,                               //  AcquireFileForNtCreateSection
    NULL,                               //  ReleaseFileForNtCreateSection
    DfsFastIoDetachDevice,              //  FastIoDetachDevice
    DfsFastIoQueryNetworkOpenInfo,      //  FastIoQueryNetworkOpenInfo
    NULL,                               //  AcquireForModWrite
    DfsFastIoMdlRead,                   //  MdlRead
    DfsFastIoMdlReadComplete,           //  MdlReadComplete
    DfsFastIoPrepareMdlWrite,           //  PrepareMdlWrite
    DfsFastIoMdlWriteComplete,          //  MdlWriteComplete
    DfsFastIoReadCompressed,            //  FastIoReadCompressed
    DfsFastIoWriteCompressed,           //  FastIoWriteCompressed
    DfsFastIoMdlReadCompleteCompressed, //  MdlReadCompleteCompressed
    DfsFastIoMdlWriteCompleteCompressed, //  MdlWriteCompleteCompressed
    DfsFastIoQueryOpen,                 //  FastIoQueryOpen
    NULL,                               //  ReleaseForModWrite
    NULL,                               //  AcquireForCcFlush
    NULL,                               //  ReleaseForCcFlush
};


extern
NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp );

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);


    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            return (fastIoDispatch->FastIoRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            return (fastIoDispatch->FastIoWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            return (fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            return (fastIoDispatch->FastIoLock)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            return (fastIoDispatch->FastIoUnlockSingle)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

                return (fastIoDispatch->FastIoUnlockAll)(
                            FileObject,
                            ProcessId,
                            IoStatus,
                            nextDeviceObject );
            }
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            return (fastIoDispatch->FastIoUnlockAllByKey)(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {

        DfsHandlePrivateFsControl (DeviceObject,
                                   IoControlCode,
                                   InputBuffer,
                                   InputBufferLength,
                                   OutputBuffer,
                                   OutputBufferLength,
                                   IoStatus,
                                   NULL);
        return TRUE;
    }

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

            return (fastIoDispatch->FastIoDeviceControl)(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

VOID
DfsFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice )
{

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    //
    //  Display name information
    //
    DbgPrint( "SFILTER: Detaching from volume\n");

    //
    //  Detach from the file system's volume device object.
    //

    DfsCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            return (fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            return (fastIoDispatch->MdlRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

BOOLEAN
DfsFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            return (fastIoDispatch->MdlReadComplete)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            return (fastIoDispatch->PrepareMdlWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/


BOOLEAN
DfsFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            return (fastIoDispatch->MdlWriteComplete)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast IO routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            return (fastIoDispatch->FastIoReadCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/


BOOLEAN
DfsFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            return (fastIoDispatch->FastIoWriteCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/


BOOLEAN
DfsFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information for it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
            return result;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\delegationcontrol.cxx ===
#include "DfsGeneric.hxx"
#include <netdfs.h>

#define DFS_IMPERSONATING 1
#define DFS_IMPERSONATION_DISABLED 2

__declspec(thread) int ImpersonationState = 0;
__declspec(thread) int ImpersonationDisableDepth = 0;



DFSSTATUS
DfsSetupRpcImpersonation()
{
    DFSSTATUS Status;

    if (ImpersonationState & DFS_IMPERSONATING)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = RpcImpersonateClient( NULL);     
    if (Status == ERROR_SUCCESS)
    {
        ImpersonationState |= DFS_IMPERSONATING;
    }

    return Status;
}




DFSSTATUS
DfsDisableRpcImpersonation(
    PBOOLEAN pImpersonationDisabled )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if (pImpersonationDisabled)
    {
        *pImpersonationDisabled = FALSE;
    }

    if (ImpersonationState & DFS_IMPERSONATING) 
    {
        if ((ImpersonationState & DFS_IMPERSONATION_DISABLED) == 0)
        { 
            Status = RpcRevertToSelf();
            if (Status == ERROR_SUCCESS)
            {
                ImpersonationDisableDepth = 0;
                ImpersonationState |= DFS_IMPERSONATION_DISABLED;
            }
        }
        if (Status == ERROR_SUCCESS)
        {
            ImpersonationDisableDepth++;
            if (pImpersonationDisabled)
            {
                *pImpersonationDisabled = TRUE;
            }
        }
    }
    return Status;
}

DFSSTATUS
DfsReEnableRpcImpersonation()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if ((ImpersonationState & DFS_IMPERSONATING) &&
        (ImpersonationState & DFS_IMPERSONATION_DISABLED))
    {
        if (--ImpersonationDisableDepth == 0)
        {
            Status = RpcImpersonateClient( NULL);     

            ImpersonationState &= ~DFS_IMPERSONATION_DISABLED;
        }
    }

    return Status;
}



DFSSTATUS
DfsTeardownRpcImpersonation()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if (ImpersonationState & DFS_IMPERSONATING) 
    {
        if ((ImpersonationState & DFS_IMPERSONATION_DISABLED) == 0)
        {
            Status = RpcRevertToSelf();
        }

        ImpersonationState = 0;
        ImpersonationDisableDepth = 0;
    }
    else
    {
        Status = ERROR_INVALID_PARAMETER;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilterapi\dfsfilterapi.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsFilterApi.cxx
//
//  Contents:   Contains APIs to communicate with the filter driver   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <ole2.h>
#include <activeds.h>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <dfswmi.h>

                  
#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) (pFilterAPiControl->Control.Logger),
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
  (pFilterAPiControl && (pFilterAPiControl->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)) && \
  (pFilterAPiControl->Control.Level >= lvl))
 
#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) (pFilterAPiControl->Control.Logger),
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((pFilterAPiControl && (!NT_SUCCESS(error) || (pFilterAPiControl->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)))) && \
  (pFilterAPiControl->Control.Level >= lvl))
 
#include "dfsfilterapi.tmh"

WPP_CB_TYPE *pFilterAPiControl = NULL;

BOOL g_ReflectShutdownFlag = FALSE;

#define MAX_DFS_REFLECTION_THREADS  4

HANDLE ThreadArray[MAX_DFS_REFLECTION_THREADS];

HANDLE gTerminationHandle = NULL;

extern
DFSSTATUS
DfsProcessGetReplicaData(HANDLE hDriver, PBYTE DataBuffer);

extern
DFSSTATUS 
IsADfsLink(PBYTE pRequest);

NTSTATUS
NtStatusFromLastError(DWORD StatusIn)
{
	NTSTATUS status = 0;

	switch(StatusIn)
	{
    case ERROR_SUCCESS:
        status = STATUS_SUCCESS;
        break;

	case ERROR_ACCESS_DENIED:
		status = STATUS_ACCESS_DENIED;
		break;

    case ERROR_MORE_DATA:
        status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_HOST_UNREACHABLE:
        status = STATUS_PATH_NOT_COVERED;
        break;

    case ERROR_BAD_NET_NAME:
        status = STATUS_BAD_NETWORK_NAME;
        break;

    case ERROR_SHARING_VIOLATION:
        status = STATUS_SHARING_VIOLATION;
        break;

    case ERROR_NO_MORE_ITEMS:
        status = STATUS_NO_MORE_ENTRIES;
        break;

	case ERROR_FILE_NOT_FOUND:
		status = STATUS_NO_SUCH_FILE;
		break;

	case ERROR_ALREADY_EXISTS:
		status = STATUS_OBJECT_NAME_COLLISION;
		break;

    case ERROR_INVALID_PARAMETER:
		status = STATUS_INVALID_PARAMETER;
		break;
		
	case ERROR_CALL_NOT_IMPLEMENTED:
		status = STATUS_NOT_IMPLEMENTED;
		break;

    case ERROR_NOT_FOUND:
        status = STATUS_NOT_FOUND;
        break;

    case ERROR_DUP_NAME:
        status = STATUS_DUPLICATE_NAME;
        break;
	case ERROR_INSUFFICIENT_BUFFER:
		status = STATUS_BUFFER_TOO_SMALL;
		break;
		
	case ERROR_INVALID_DATA:
		status = STATUS_DATA_ERROR;  
		break;

    case ERROR_INVALID_HANDLE:
        status = STATUS_INVALID_HANDLE;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_OPERATION_ABORTED:
        status = STATUS_REQUEST_ABORTED;
        break;

	case ERROR_BAD_COMMAND:
	default:
		status = STATUS_UNSUCCESSFUL;
        //ASSERT(FALSE);
		break;
	}
	return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsOpenFilterDriver 
//
//  Arguments:  DriverHandle - Pointer to receive driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Opens the DFS filter driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsOpenFilterDriver( HANDLE * DriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDevice = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DfsDeviceName;

    //
    // Attempt to open the driver.
    //
    RtlInitUnicodeString(&DfsDeviceName, DFS_FILTER_NAME);
    InitializeObjectAttributes(&ObjectAttributes,
                           &DfsDeviceName,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenFile(&hDevice,
                        SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (Status != STATUS_SUCCESS) 
    {
        Status = RtlNtStatusToDosError(Status);
    }

    *DriverHandle = hDevice;
    return Status;
}


DFSSTATUS
DfsOpenFilterTerminationHandle( HANDLE * DriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDevice = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DfsDeviceName;
    WCHAR NameBuf[600];

    //
    //

    RtlInitEmptyUnicodeString( &DfsDeviceName, NameBuf, sizeof(NameBuf));
    RtlAppendUnicodeToString(&DfsDeviceName, DFS_FILTER_NAME);
    RtlAppendUnicodeToString(&DfsDeviceName, DFSFILTER_PROCESS_TERMINATION_FILEPATH);

    InitializeObjectAttributes(&ObjectAttributes,
                           &DfsDeviceName,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenFile(&hDevice,
                        SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (Status != STATUS_SUCCESS) 
    {
        Status = RtlNtStatusToDosError(Status);
    }

    *DriverHandle = hDevice;
    return Status;
}



void
DfsCloseFilterTerminationHandle(void)
{
   if(gTerminationHandle != NULL)
   {
       CloseHandle(gTerminationHandle);
       gTerminationHandle = NULL;
   }
}
//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeStartUmrx 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeStartUmrx( HANDLE hDriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_START_UMRX,
        NULL,
        0,
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeStopUmrx 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Stops the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeStopUmrx( HANDLE hDriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_STOP_UMRX,
        NULL,
        0,
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeProcessPacket 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Sends a response to the driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeProcessPacket( IN HANDLE hDriverHandle, 
                     IN PVOID InputBuffer,
                     IN DWORD InputBufferLength,
                     IN PVOID OutputBuffer,
                     IN DWORD OutputBufferLength,
                     OUT DWORD * BytesReturned)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_PROCESS_UMRXPACKET,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    *BytesReturned = (DWORD)ioStatus.Information;

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeGetReplicaInfo 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets the replica information from filter driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeGetReplicaInfo( IN HANDLE hDriverHandle, 
                     IN PVOID InputBuffer,
                     IN DWORD InputBufferLength,
                     IN PVOID OutputBuffer,
                     IN DWORD OutputBufferLength)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_GETREPLICA_INFO,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUSerModeAttachToFilesystem 
//
//  Arguments:  DirectoryName - Directory on volume to attach to
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: attaches the filter driver to the volume
//
//--------------------------------------------------------------------------


#define DFS_SPECIAL_SHARE 1

DFSSTATUS
DfsUserModeAttachToFilesystem(PUNICODE_STRING pVolumeName, 
                              PUNICODE_STRING pShareName )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriverHandle = NULL;
    PDFS_ATTACH_PATH_BUFFER pBuffer = NULL;
    DWORD SizeToAllocate = 0;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;


    if((pVolumeName == NULL) || (pVolumeName->Buffer == NULL)
       || (pVolumeName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }


    if((pShareName == NULL) || (pShareName->Buffer == NULL)
       || (pShareName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    SizeToAllocate = pVolumeName->Length + pShareName->Length 
                     + sizeof(DFS_ATTACH_PATH_BUFFER);

    pBuffer = (PDFS_ATTACH_PATH_BUFFER) HeapAlloc(GetProcessHeap(), 
                                                  0, 
                                                  SizeToAllocate);
    if(pBuffer == NULL)
    {
        Status = GetLastError();
        goto Exit;
    }

	pBuffer->VolumeNameLength = pVolumeName->Length ;
	pBuffer->ShareNameLength = pShareName->Length ;
	pBuffer->Flags = 0;

        //
        // Hack to fix BVT Break.
        //
        if (pVolumeName == pShareName)
        {
            pBuffer->Flags |= DFS_SPECIAL_SHARE;
        }

	RtlCopyMemory(
		&pBuffer->PathNameBuffer[0],
		pVolumeName->Buffer,
		pBuffer->VolumeNameLength);

	RtlCopyMemory(
		&pBuffer->PathNameBuffer[pBuffer->VolumeNameLength / sizeof(WCHAR)],
		pShareName->Buffer,
		pBuffer->ShareNameLength);

    Status = DfsOpenFilterDriver(&hDriverHandle);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_ATTACH_FILESYSTEM,
        pBuffer,
        SizeToAllocate,
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

Exit:

    CloseHandle(hDriverHandle);


    if(pBuffer)
    {
        HeapFree(GetProcessHeap(), 0, pBuffer);
    }

    return Status;
}


DFSSTATUS
DfsUserModeDetachFromFilesystem(PUNICODE_STRING pVolumeName, 
                                PUNICODE_STRING pShareName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriverHandle = NULL;
    PDFS_ATTACH_PATH_BUFFER pBuffer = NULL;
    DWORD SizeToAllocate = 0;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    if((pVolumeName == NULL) || (pVolumeName->Buffer == NULL)
       || (pVolumeName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }


    if((pShareName == NULL) || (pShareName->Buffer == NULL)
       || (pShareName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    SizeToAllocate = pVolumeName->Length + pShareName->Length 
                     + sizeof(DFS_ATTACH_PATH_BUFFER);

    pBuffer = (PDFS_ATTACH_PATH_BUFFER) HeapAlloc(GetProcessHeap(), 
                                                  0, 
                                                  SizeToAllocate);
    if(pBuffer == NULL)
    {
        Status = GetLastError();
        goto Exit;
    }

	pBuffer->VolumeNameLength = pVolumeName->Length ;
	pBuffer->ShareNameLength = pShareName->Length ;
	pBuffer->Flags = 0;

	RtlCopyMemory(
		&pBuffer->PathNameBuffer[0],
		pVolumeName->Buffer,
		pBuffer->VolumeNameLength);

	RtlCopyMemory(
		&pBuffer->PathNameBuffer[pBuffer->VolumeNameLength / sizeof(WCHAR)],
		pShareName->Buffer,
		pBuffer->ShareNameLength);

    Status = DfsOpenFilterDriver(&hDriverHandle);


    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_DETACH_FILESYSTEM,
        pBuffer,
        SizeToAllocate,
        NULL,
        0);

    
    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

Exit:

    CloseHandle(hDriverHandle);

    if(pBuffer)
    {
        HeapFree(GetProcessHeap(), 0, pBuffer);
    }

    return Status;
}

NTSTATUS
DfsUSerModePurgeShareList(void) 
{
    NTSTATUS Status = STATUS_SUCCESS;

    return Status;
}
//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessWorkItemData 
//
//  Arguments:  Databuffer from kernel
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Decipher the input buffer and calls the right routines to 
//               process the data
//               
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsProcessWorkItemData(HANDLE DriverHandle, PBYTE DataBuffer)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    PUMRX_USERMODE_WORKITEM_HEADER pHeader = NULL;
    PUMRX_USERMODE_WORKITEM        pWorkItem = NULL;

    UNREFERENCED_PARAMETER(DriverHandle);

    pHeader = (PUMRX_USERMODE_WORKITEM_HEADER)DataBuffer;
    if( pHeader->ulHeaderVersion != UMR_VERSION )
    {
        goto Exit;
    }

    switch (pHeader->WorkItemType) 
    {
    case opUmrGetDfsReplicas:
        {
            Status = DfsProcessGetReplicaData(DriverHandle, DataBuffer);
            break;
        }
    case opUmrIsDfsLink:
        {
            Status = IsADfsLink(DataBuffer);
            break;
        }
    default:
        break;

    }

Exit:

    Status = NtStatusFromLastError(Status);

    pHeader->IoStatus.Status = Status;
    pHeader->IoStatus.Information = 0;
    pHeader->ulFlags = UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE;

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsReflectionThread 
//
//  Arguments:  None
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Handles requests from the filter driver
//               
//
//--------------------------------------------------------------------------
DWORD
DfsReflectionThread(LPVOID pData )
{
    NTSTATUS Status = 0;
    HRESULT hr = S_OK;
    DWORD BytesReturned = 0;
    HANDLE hDriverHandle    = INVALID_HANDLE_VALUE;
    HANDLE hClientHandle    = INVALID_HANDLE_VALUE;
    PBYTE pBuffer           = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER pHeader = NULL;
    PUMRX_USERMODE_WORKITEM        pWorkItem = NULL;
    PBYTE OutputBuffer = NULL;

    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);

    //get a handle to receive requests from
    DfsOpenFilterDriver(&hDriverHandle);

    //get a handle to send back data on
    DfsOpenFilterDriver(&hClientHandle);


    OutputBuffer = (PBYTE) pData;
    while (1)
    {

        ZeroMemory (OutputBuffer, MAX_USERMODE_REFLECTION_BUFFER);

        BytesReturned = 0;

        Status = DfsUserModeProcessPacket(hDriverHandle, 
                                          NULL,
                                          0,
                                          OutputBuffer,
                                          MAX_USERMODE_REFLECTION_BUFFER,
                                          &BytesReturned);
        //this means we are shutting down
        if(BytesReturned == 0)
        {
            break;
        }


        Status = DfsProcessWorkItemData(hClientHandle, OutputBuffer);

        if(Status != ERROR_SUCCESS)
        {
            Status = DfsUserModeProcessPacket(hClientHandle, 
                                              OutputBuffer,
                                              MAX_USERMODE_REFLECTION_BUFFER,
                                              NULL,
                                              0,
                                              &BytesReturned);
        }
    }

    if(hDriverHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hDriverHandle);
    }


    if(hClientHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hClientHandle);
    }

    HeapFree(GetProcessHeap(), 0, OutputBuffer);

    CoUninitialize();
    return 0;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeReflectionThreads 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection threads
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsInitializeReflectionThreads(void)
{
    DFSSTATUS Status = 0;
    DWORD Loop = 0;
    DWORD dwThreadId = 0;
    PBYTE Buffer = NULL;

    for (Loop = 0; Loop < MAX_DFS_REFLECTION_THREADS; Loop++) 
    {


        Buffer = (PBYTE) HeapAlloc(GetProcessHeap(), 0, MAX_USERMODE_REFLECTION_BUFFER);
        if(Buffer == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ThreadArray [Loop] = CreateThread(NULL,
                                           0,
                                           DfsReflectionThread,
                                           (LPVOID) Buffer,
                                           0,
                                           &dwThreadId);
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeReflectionEngine 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsInitializeReflectionEngine(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriver = NULL;

    Status = DfsOpenFilterTerminationHandle(&gTerminationHandle);
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsOpenFilterDriver(&hDriver);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = DfsUserModeStartUmrx(hDriver);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }


    Status = DfsInitializeReflectionThreads();

Exit:

    if(hDriver != NULL)
    {
        CloseHandle(hDriver);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsWaitForReflectionThreads
//
//  Arguments:  None
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Waits for all the relection threads to die
//               
//
//--------------------------------------------------------------------------
DFSSTATUS DfsWaitForReflectionThreads(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD Loop = 0;

    WaitForMultipleObjects(MAX_DFS_REFLECTION_THREADS, ThreadArray, TRUE, INFINITE);

    for (Loop = 0; Loop < MAX_DFS_REFLECTION_THREADS; Loop++) 
    {
        if(ThreadArray [Loop] = INVALID_HANDLE_VALUE)
        {
            CloseHandle(ThreadArray [Loop]);
            ThreadArray [Loop] = INVALID_HANDLE_VALUE;
        }
    }

    return Status;
}


DFSSTATUS 
DfsTerminateReflectionEngine(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DfsWaitForReflectionThreads();

    DfsCloseFilterTerminationHandle();
    return Status;
}


void SetFilterAPiShutdownFlag(void)
{
    g_ReflectShutdownFlag = TRUE;
}


void SetFilterAPiControl(WPP_CB_TYPE * Control)
{
    pFilterAPiControl = Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsumrrequests.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrRequests.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _DFSREQUESTS_H_
#define _DFSREQUESTS_H_


NTSTATUS 
DfsGetReplicaInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


NTSTATUS 
DfsIsADfsLinkInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsinit.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Driver initialization routine for the Dfs server.
//
//  Classes:    None
//
//  Functions:  DriverEntry -- Entry point for driver
//
//-----------------------------------------------------------------------------

     

#include <ntifs.h>
#include <windef.h>
#include <dfsprefix.h>
#include <..\..\lib\prefix\prefix.h>
#include <DfsReferralData.h>
#include "dfsheader.h"
#include "DfsInit.h"
#include "midatlax.h"
#include "rxcontx.h"
#include "dfsumr.h"
#include "umrx.h"
#include "DfsUmrCtrl.h"
#include "DfsUmrRequests.h"
#include <dfsfsctl.h>

#define _NTDDK_
#include "stdarg.h"
#include "wmikm.h"
#include <wmistr.h>
#include <evntrace.h>

#include <wmiumkm.h>
#include "dfswmi.h"     
              
#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)
  
#include "dfsinit.tmh"
      
                  
//prefix table
DFS_PREFIX_TABLE *pPrefixTable = NULL;
BOOL gfRundownPrefixCompleted = FALSE;

WCHAR gDummyData = 0;

extern POBJECT_TYPE *IoFileObjectType;

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif
                               
#define DFSFILTER_INIT_DEVICECREATED  0x00000001
#define DFSFILTER_INIT_REGCHANGE      0x00000002
#define DFSFILTER_INIT_SYMLINK        0x00000004

NTSTATUS
DfsCheckReparse( 
    PUNICODE_STRING pParent,
    PUNICODE_STRING pName );


NTSTATUS
DfsFilterCreateCheck(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

PDRIVER_OBJECT gpDfsFilterDriverObject = NULL;
PDEVICE_OBJECT gpDfsFilterControlDeviceObject = NULL;

#define IO_REPARSE_TAG_DFS 0x8000000A

//
//  Buffer size for local names on the stack
//

#define MAX_DEVNAME_LENGTH 128


DWORD DFSInitilizationStatus = 0;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING  RegistryPath);

VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject );


VOID
DfsInitUnwind(
    IN PDRIVER_OBJECT DriverObject);

VOID
DfsFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive );


NTSTATUS
DfsAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject );

VOID
DfsDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject );

NTSTATUS
DfsEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject );



NTSTATUS
DfsAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT DfsFilterDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject );

VOID
DfsGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name );


NTSTATUS
DfsMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
DfsLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

BOOLEAN
DfsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject, 
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL);

NTSTATUS
DfsPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp );

VOID
DfsCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject);


NTSTATUS
DfsFilterCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
DfsFilterCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp );

NTSTATUS
DfsFilterFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);


NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS 
DfsAttachToFileSystem (
    IN PWSTR UserDeviceName);

NTSTATUS
DfsDetachFromFileSystem (
    IN PWSTR UserDeviceName);

NTSTATUS
DfsHandleAttachToFs(PVOID InputBuffer, 
                    ULONG InputBufferSize);


NTSTATUS
DfsHandleDetachFromFs(PVOID InputBuffer, 
                      ULONG InputBufferLength);

NTSTATUS
DfsGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    );


NTSTATUS
DfsRunDownPrefixTable(void);

NTSTATUS 
DfsHandlePrivateCleanupClose(IN PIRP Irp);

void
DfsPrefixRundownFunction(PVOID pEntry);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry)
#pragma alloc_text( PAGE, DriverUnload)
#pragma alloc_text( PAGE, DfsInitUnwind)
#pragma alloc_text( PAGE, DfsFsNotification )
#pragma alloc_text( PAGE, DfsAttachToFileSystemDevice )
#pragma alloc_text( PAGE, DfsDetachFromFileSystemDevice )
#pragma alloc_text( PAGE, DfsEnumerateFileSystemVolumes )
#pragma alloc_text( PAGE, DfsAttachToMountedDevice )
#pragma alloc_text( PAGE, DfsGetObjectName )
#pragma alloc_text( PAGE, DfsMountCompletion )
#pragma alloc_text( PAGE, DfsLoadFsCompletion )
#pragma alloc_text( PAGE, DfsAttachedToDevice )
#pragma alloc_text( PAGE, DfsPassThrough )
#pragma alloc_text( PAGE, DfsCleanupMountedDevice )
#pragma alloc_text( PAGE, DfsFilterCreate )
#pragma alloc_text( PAGE, DfsFilterCleanupClose )
#pragma alloc_text( PAGE, DfsFilterFsControl )
#pragma alloc_text( PAGE, DfsHandlePrivateFsControl )
#pragma alloc_text( PAGE, DfsFsctrlIsShareInDfs )
#pragma alloc_text( PAGE, DfsGetDeviceObjectFromName)
#pragma alloc_text( PAGE, DfsAttachToFileSystem)
#pragma alloc_text( PAGE, DfsDetachFromFileSystem)
#pragma alloc_text( PAGE, DfsHandleAttachToFs)
#pragma alloc_text( PAGE, DfsHandleDetachFromFs)
#pragma alloc_text( PAGE, DfsHandlePrivateCleanupClose)
#pragma alloc_text( PAGE, DfsRunDownPrefixTable)
#pragma alloc_text( PAGE, DfsPrefixRundownFunction)
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DriverEntry, main entry point
//
//  Synopsis:   This is the initialization routine for the DFS file system
//      device driver.  This routine creates the device object for
//      the FileSystem device and performs all other driver
//      initialization.
//
//  Arguments:  [DriverObject] -- Pointer to driver object created by the
//          system.
//
//  Returns:    [NTSTATUS] - The function value is the final status from
//          the initialization operation.
//
//--------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG i = 0;

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    //
    // Create the filesystem device object.
    //

    RtlInitUnicodeString( &NameString, DFS_FILTER_NAME );
    Status = IoCreateDevice( DriverObject,
                             0,
                             &NameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &gpDfsFilterControlDeviceObject );

    if ( !NT_SUCCESS( Status ) ) {

        DbgPrint("Driverentry IoCreateDevice failed %X\n", Status);
        return Status;
    }

    gpDfsFilterDriverObject = DriverObject;
    DriverObject->DriverUnload = DriverUnload;

    try
    {

        //
        // Initialize the driver object with this driver's entry points.
        // Most are simply passed through to some other device driver.
        //

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = DfsPassThrough;
        }

        DriverObject->MajorFunction[IRP_MJ_CREATE] = DfsFilterCreate;
        DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = DfsFilterFsControl;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DfsFilterCleanupClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = DfsFilterCleanupClose;

        DriverObject->FastIoDispatch = &DfsFastIoDispatch;


      //  Status = IoRegisterFsRegistrationChange( DriverObject, 
                                                // DfsFsNotification );
       // if (!NT_SUCCESS (Status)) {
            //IoDeleteDevice ( gpDfsFilterControlDeviceObject );
            //try_return (Status);
       // }


        //DFSInitilizationStatus |= DFSFILTER_INIT_REGCHANGE;
        Status = DfsInitializeUmrResources();
        if (Status != STATUS_SUCCESS) 
        {
           DbgPrint("DfsDriverEntry DfsInitializeUmrResources failed: %08lx\n", Status );
           try_return(Status);
        }

try_exit: NOTHING;
    }
    finally
    {
        if (Status != STATUS_SUCCESS) 
        {

           DbgPrint("Driverentry status not success %X\n", Status);
           DfsInitUnwind(DriverObject);
        }
    }

    DbgPrint("New DFS.sys\n");
    ClearFlag( gpDfsFilterControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}


VOID
DfsInitUnwind(IN PDRIVER_OBJECT DriverObject)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING  UserModeDeviceName;

    PAGED_CODE();

   // if(DFSInitilizationStatus & DFSFILTER_INIT_REGCHANGE)
   // {
        //IoUnregisterFsRegistrationChange( DriverObject, DfsFsNotification );
    //}

    Status = DfsInitializeUmrResources();


    IoDeleteDevice ( gpDfsFilterControlDeviceObject );
}


/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject )
{
    PDFS_FILTER_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gpDfsFilterDriverObject);

    //
    //  Log we are unloading
    //

    DbgPrint( "SFILTER: Unloading driver (%p)\n",DriverObject);

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, DfsFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.
        //

        status = IoEnumerateDeviceObjectList(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a refrence count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reonsable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = -5 * (10 * 1000 * 1000);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that refrences it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                DfsCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gpDfsFilterControlDeviceObject);
                gpDfsFilterControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove refrence counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the refrence count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;


    DfsDeInitializeUmrResources();
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFsNotification
//
//  Arguments:
//       DeviceObject - Pointer to the file system's device object.
//
//       FsActive - Boolean indicating whether the file system has registered
//        (TRUE) or unregistered (FALSE) itself as an active file system.
//
//
//  Returns:    NONE
//
//  Description: 
//  This routine is invoked whenever a file system has either registered or
//  unregistered itself as an active file system.
//
//  For the former case, this routine creates a device object and attaches it
//  to the specified file system's device object.  This allows this driver
//  to filter all requests to that file system.  Specifically we are looking
//  for MOUNT requests so we can attach to newly mounted volumes.
//
//  For the latter case, this file system's device object is located,
//  detached, and deleted.  This removes this file system as a filter for
//  the specified file system.
//--------------------------------------------------------------------------


VOID
DfsFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive )

{

    PAGED_CODE();

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {
        
        DfsAttachToFileSystemDevice( DeviceObject );

    } else {

        DfsDetachFromFileSystemDevice( DeviceObject );
    }
}


/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new volumes are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    Status of the operation

--*/
NTSTATUS
DfsAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject )

{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PDFS_FILTER_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    WCHAR nameBuffer[MAX_DEVNAME_LENGTH];
    UNICODE_STRING Name;

    RtlInitEmptyUnicodeString( &Name, nameBuffer, sizeof(nameBuffer));

    PAGED_CODE();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if we should attach to recognizers or not
    //
#if 0
    if (!(DfsDebug & DFSDEBUG_ATTACH_TO_FSRECOGNIZER)) {

        //
        //  See if this is one of the standard Microsoft file system recognizer
        //  devices (see if this device is in the FS_REC driver).  If so skip it.
        //  We no longer attach to file system recognizer devices, we simply wait
        //  for the real file system driver to load.
        //

        RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
        DfsGetObjectName( DeviceObject->DriverObject, &Name );
        if (RtlCompareUnicodeString( &Name, &fsrecName, TRUE ) == 0) {

            return STATUS_SUCCESS;
        }
    }
#endif
    //
    //  We want to attach to this file system.  Create a new device object we
    //  can attach with.
    //

    status = IoCreateDevice( gpDfsFilterDriverObject,
                             sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( newDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = newDeviceObject->DeviceExtension;
    devExt->AttachedToDeviceObject = attachedToDevObj;

    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );


    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = DfsEnumerateFileSystemVolumes( DeviceObject );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( newDeviceObject );

    ErrorCleanupDevice:
        DfsCleanupMountedDevice( newDeviceObject );
        IoDeleteDevice( newDeviceObject );

    return status;
}


/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 

VOID
DfsDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT ourAttachedDevice;
    PDFS_FILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            DfsCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}



/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    The status of the operation

--*/
NTSTATUS
DfsEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject )
{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList(
                    FSDeviceObject->DriverObject,
                    NULL,
                    0,
                    &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         'FsfD');
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !DfsAttachedToDevice( devList[i], NULL)) {

                //
                //  Get the real (disk) device object associated with this
                //  file  system device object.  Only try to attach if we
                //  have a disk device object.
                //

                status = IoGetDiskDeviceObject( devList[i], &diskDeviceObject );

                if (NT_SUCCESS( status )) {

                    //
                    //  Allocate a new device object to attach with
                    //

                    status = IoCreateDevice( gpDfsFilterDriverObject,
                                             sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                                             NULL,
                                             devList[i]->DeviceType,
                                             0,
                                             FALSE,
                                             &newDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  attach to volume
                        //

                        DfsAttachToMountedDevice( devList[i], 
                                                  newDeviceObject, 
                                                  diskDeviceObject );
                    }

                    //
                    //  Remove reference added by IoGetDiskDeviceObject.
                    //  We only need to hold this reference until we are
                    //  successfully attached to the current volume.  Once
                    //  we are successfully attached to devList[i], the
                    //  IO Manager will make sure that the underlying
                    //  diskDeviceObject will not go away until the file
                    //  system stack is torn down.
                    //

                    ObDereferenceObject( diskDeviceObject );
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}


/*++

Routine Description:

    This will attach to a DeviceObject that represents a mounted volume.

Arguments:

    DeviceObject - The device to attach to

    SFilterDeviceObject - Our device object we are going to attach

    DiskDeviceObject - The real device object associated with DeviceObject

Return Value:

    Status of the operation

--*/

NTSTATUS
DfsAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT DfsFilterDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject )
{        
    PDFS_FILTER_DEVICE_EXTENSION newDevExt = DfsFilterDeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT(IS_MY_DEVICE_OBJECT( DfsFilterDeviceObject ));
    ASSERT(!DfsAttachedToDevice ( DeviceObject, NULL ));

    //
    //  Save our DiskDeviceObject in the extension
    //

    newDevExt->DiskDeviceObject = DiskDeviceObject;

    //
    //  Attach our device object to the given device object
    //

    newDevExt->AttachedToDeviceObject = IoAttachDeviceToDeviceStack( DfsFilterDeviceObject, DeviceObject );

    if (NULL == newDevExt->AttachedToDeviceObject) {

        //
        //  The attachment failed, delete the device object
        //

        DfsCleanupMountedDevice( DfsFilterDeviceObject );
        IoDeleteDevice( DfsFilterDeviceObject );
        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {


        //
        //  Finished all initialization of the new device object,  so clear the
        //  initializing flag now.

        ClearFlag( DfsFilterDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    }

    return status;
}

/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the object.

Return Value:

    None

--*/

VOID
DfsGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name )
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}







/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  This
    simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the event to syncwith

--*/
NTSTATUS
DfsMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )
{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*++

Routine Description:

    This routine is invoked for the completion of a LoadFileSystem request.
    This simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Pointer to the event to syncwith

Return Value:

    The function value for this routine is always success.

--*/

NTSTATUS
DfsLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )
{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.

Arguments:

    DeviceObject - The device chain we want to look through

Return Value:

    TRUE if we are attached, FALSE if not

--*/

BOOLEAN
DfsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL )
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) 
        {
            //
            //  We have found that we are already attached.  If we are
            //  returning the device object we are attached to then leave the
            //  refrence on it.  If not then remove the refrence.
            //

            if (AttachedDeviceObject != NULL) 
            {
                *AttachedDeviceObject = currentDevObj;
            } 
            else 
            {
                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}    


/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementers:  
        This routine actually "passes" through the request by taking this
        driver out of the IRP stack.  If the driver would like to pass the
        I/O request through, but then also see the result, then rather than
        taking itself out of the loop it could keep itself in by copying the
        caller's parameters to the next stack location and then set its own
        completion routine.  

        Hence, instead of calling:
    
            IoSkipCurrentIrpStackLocation( Irp );

        You could instead call:

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


        This example actually NULLs out the caller's I/O completion routine, but
        this driver could set its own completion routine so that it would be
        notified when the request was completed (see SfCreate for an example of
        this).

--*/


NTSTATUS
DfsPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
{
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object, fail the operation
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}

/*++

Routine Description:

    This cleans up any allocated memory in the device extension.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

--*/

VOID
DfsCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject)
{        
    PDFS_FILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If a name buffer is allocated, free it
    //

    if (NULL != devExt->Name.Buffer) {

        ExFreePool( devExt->Name.Buffer );
        RtlInitEmptyUnicodeString( &devExt->Name, NULL, 0 );
    }
}




/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

NTSTATUS
DfsFilterCreate (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION     pIrpSp = NULL;
    PIO_STACK_LOCATION     pNextIrpSp = NULL;
    KEVENT WaitEvent;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(pDeviceObject)) 
    {

        pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

        pIrpSp->FileObject->FileName;

        //DbgPrint("DfsFilterCreate - FileName =%wZ\n", &pIrpSp->FileObject->FileName);

        //
        //  Allow users to open the device that represents our driver.
        //

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( pDeviceObject ));

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Simply copy this driver stack location contents to the next driver's
    // stack.
    // Set a completion routine to check for the reparse point error return.
    //

    pNextIrpSp = IoGetNextIrpStackLocation( pIrp );

    RtlMoveMemory(pNextIrpSp, pIrpSp, sizeof( IO_STACK_LOCATION ));
    
    //
    // If the the file is not being opened with FILE_OPEN_REPARSE_POINT 
    // then set a completion routine
    //
    if (!(pIrpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT))
    {

       KeInitializeEvent(&WaitEvent, SynchronizationEvent, FALSE);

       IoSetCompletionRoutine (pIrp,
                               DfsFilterCreateCheck,
                               &WaitEvent,
                               TRUE,        // Call on success
                               TRUE,        // fail
                               TRUE) ;      // and on cancel

    
       Status = IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) pDeviceObject->DeviceExtension)->AttachedToDeviceObject, pIrp );
       //
       // We wait for the event to be set by the
       // completion routine.
       //
       KeWaitForSingleObject( &WaitEvent,
                              UserRequest,
                              KernelMode,
                              FALSE,
                              (PLARGE_INTEGER) NULL );

       Status = pIrp->IoStatus.Status;

       //
       // This IRP never completed. Complete it now
       //
       IoCompleteRequest(pIrp,
                         IO_NO_INCREMENT);
    } 
    else {

        //
        //  Don't put us on the stack then call the next driver
        //

        IoSkipCurrentIrpStackLocation( pIrp );

        Status = IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) pDeviceObject->DeviceExtension)->AttachedToDeviceObject, pIrp );
    }

    return Status;
}


/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. If the
   returned code is a reparse error and it is a DFS reparse point then
   we must set up for returning PATH_NOT_COVERED.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - 

Return Value:

   STATUS_SUCCESS           - Recall is complete
   STATUS_MORE_PROCESSING_REQUIRED  - Open request was sent back to file system
--*/

NTSTATUS
DfsFilterCreateCheck(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PREPARSE_DATA_BUFFER   pHdr;
    PKEVENT                pEvent = Context;


   if (Irp->IoStatus.Status == STATUS_REPARSE) {
       pHdr = (PREPARSE_DATA_BUFFER) Irp->Tail.Overlay.AuxiliaryBuffer;

       if (pHdr->ReparseTag == IO_REPARSE_TAG_DFS) {
           //DbgPrint("Reparse Tag is DFS: returning path not covered\n");
           Irp->IoStatus.Status = STATUS_PATH_NOT_COVERED; 
       }
   }

   //
   // Propogate the IRP pending flag.
   //

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);
   //
   // This packet would be completed by RsCreate
   //
   return(STATUS_MORE_PROCESSING_REQUIRED);
}

void 
DfsPrefixRundownFunction (PVOID pEntry)
{
    PWSTR VolumeName = (PWSTR) pEntry;

    if(VolumeName != NULL)
    {
       DfsDetachFromFileSystem(VolumeName);
       ExFreePool(pEntry);
    }

    return;
}

NTSTATUS
DfsRunDownPrefixTable(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(pPrefixTable == NULL)
    {
        return Status;
    }

    DfsDismantlePrefixTable(pPrefixTable, DfsPrefixRundownFunction);


    DfsDereferencePrefixTable(pPrefixTable); 

    pPrefixTable = NULL;

    gfRundownPrefixCompleted = TRUE;

    return Status;
}

NTSTATUS 
DfsHandlePrivateCleanupClose(IN PIRP Irp)
{
    NTSTATUS               Status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION     pIrpSp = NULL;
    LONG                   TheSame = 0; 
    UNICODE_STRING         TermPath;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    pIrpSp = IoGetCurrentIrpStackLocation( Irp );

    if(pIrpSp->FileObject->FileName.Length == 0)
    {
        return Status;
    }

    if(gfRundownPrefixCompleted)
    {
        return Status;
    }

    RtlInitUnicodeString( &TermPath, DFSFILTER_PROCESS_TERMINATION_FILEPATH);

    TheSame = RtlCompareUnicodeString( &pIrpSp->FileObject->FileName, &TermPath, TRUE );
    if(TheSame == 0)
    {
        DfsRunDownPrefixTable();
    }

    return Status;
}
/*++

Routine Description:

    This routine is invoked whenever a cleanup or a close request is to be
    processed.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    See notes for SfPassThrough for this routine.


--*/

NTSTATUS
DfsFilterCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    PAGED_CODE();
    VALIDATE_IRQL(Irp);


    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {
        DfsHandlePrivateCleanupClose(Irp);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    //  Now call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}



NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    PDFS_IS_SHARE_IN_DFS_ARG arg = (PDFS_IS_SHARE_IN_DFS_ARG) InputBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID pDummyData = NULL;  //not used
    BOOLEAN NotUsed = FALSE;  //not used
    UNICODE_STRING Suffix;    //not used
    UNICODE_STRING ShareName;    
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = ExGetPreviousMode();
    //
    // Verify the buffer is at least of size DFS_IS_SHARE_IN_DFS_ARG
    //
    
    if (InputBufferLength < sizeof(DFS_IS_SHARE_IN_DFS_ARG))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    //DbgPrint("DfsFsctrlIsShareInDfs - ShareName =%wZ\n", &arg->ShareName);

    //DbgPrint("DfsFsctrlIsShareInDfs - SharePath =%wZ\n", &arg->SharePath);

    if(pPrefixTable == NULL)
    {
        Status = STATUS_NO_SUCH_DEVICE;
        return Status;
    }


    try
    {
        ShareName = arg->ShareName;

        if(ShareName.Buffer != NULL)
        {

           if(PreviousMode != KernelMode)
           {

               ProbeForRead(ShareName.Buffer,
                 ShareName.Length,
                 1);

                ProbeForWrite(ShareName.Buffer,
                 ShareName.Length,
                 1);
           }

            // DbgPrint("Is share in DFS: %wZ\n", &ShareName);

            Status = DfsFindUnicodePrefix(pPrefixTable, 
                                          &ShareName,
                                          &Suffix,
                                          &pDummyData);
            if(Status == STATUS_SUCCESS)
            {
                arg->ShareType = DFS_SHARE_TYPE_DFS_VOLUME;

                arg->ShareType |= DFS_SHARE_TYPE_ROOT;
            }
            else
            {
                Status = STATUS_NO_SUCH_DEVICE;
            }
        }
        else
        {
            Status = STATUS_INVALID_USER_BUFFER;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    // DbgPrint("Is share in DFS: %wZ, Status\n", &ShareName, Status);

    return( Status );
}

#define UNICODE_PATH_SEP  L'\\'
#define UNICODE_PATH_SEP_STR L"\\"

BOOLEAN
DfsConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
) {
    PWSTR  OutBuf = (PWSTR)&(((PCHAR)Dest->Buffer)[Dest->Length]);

    if (Dest->Length > 0) {
        ASSERT(OutBuf[-1] != UNICODE_NULL);
    }

    if (Dest->Length > 0 && OutBuf[-1] != UNICODE_PATH_SEP) {
        *OutBuf++ = UNICODE_PATH_SEP;
        Dest->Length += sizeof (WCHAR);
    }

    if (Length > 0 && *RemainingPath == UNICODE_PATH_SEP) {
        RemainingPath++;
        Length -= sizeof (WCHAR);
    }

    ASSERT(Dest->MaximumLength >= (USHORT)(Dest->Length + Length));

    if (Length > 0) {
        RtlMoveMemory(OutBuf, RemainingPath, Length);
        Dest->Length += Length;
    }
    return TRUE;
}


void
RemoveLastComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix,
    BOOL StripTrailingSlahes
)
{
    PWCHAR      pwch;
    USHORT      i=0;

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch += (Prefix->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  
    {
        i += sizeof(WCHAR);
        pwch--;
    }

    newPrefix->Length = newPrefix->Length - i;

    if(StripTrailingSlahes)
    {
        while ((*pwch == UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  
        {
            newPrefix->Length -= sizeof(WCHAR);
            pwch--;
        }
    }
}

NTSTATUS
DfspFormPrefix(
    IN PUNICODE_STRING ParentPath,
    IN PUNICODE_STRING DfsPathName,
    IN OUT PUNICODE_STRING Prefix)
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SizeRequired = 0;

    SizeRequired = sizeof(UNICODE_PATH_SEP) +
                        ParentPath->Length +
                           sizeof(UNICODE_PATH_SEP) +
                               DfsPathName->Length;


    if (SizeRequired > MAXUSHORT) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;

    }

    if (SizeRequired > Prefix->MaximumLength) 
    {
        Prefix->MaximumLength = (USHORT)SizeRequired;

        Prefix->Buffer = ExAllocatePoolWithTag(NonPagedPool, SizeRequired, ' sfD');
    }


    if (Prefix->Buffer != NULL) 
    {
        RtlAppendUnicodeToString(
                Prefix,
                UNICODE_PATH_SEP_STR);

        if (ParentPath->Length > 0) 
          {

            DfsConcatenateFilePath(
                    Prefix,
                    ParentPath->Buffer,
                    (USHORT) (ParentPath->Length));

        } 

        DfsConcatenateFilePath(
            Prefix,
            DfsPathName->Buffer,
            DfsPathName->Length);

        Status = STATUS_SUCCESS;

    } 
    else 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
DfsGetPathComponents(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = STATUS_INVALID_PARAMETER;

   RtlInitUnicodeString(pServerName, NULL);
   if (pShareName)    RtlInitUnicodeString(pShareName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if (j != i) {
     pServerName->Buffer = &pName->Buffer[i];
     pServerName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pServerName->MaximumLength = pServerName->Length;
     
     Status = STATUS_SUCCESS;
   }
   
   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }
   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if ((pShareName) && (j != i)) {
     pShareName->Buffer = &pName->Buffer[i];
     pShareName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pShareName->MaximumLength = pShareName->Length;
   }


   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   j = pName->Length/sizeof(WCHAR);

   if (pRemaining)
   {
       pRemaining->Buffer = &pName->Buffer[i];
   }

   if ((pRemaining) && (j != i)) {

     pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}

NTSTATUS
DfsFsctrlTranslatePath(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_TRANSLATE_PATH_ARG arg = (PDFS_TRANSLATE_PATH_ARG) InputBuffer;
    WCHAR nameBuffer[MAX_PATH];
    UNICODE_STRING prefix;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    UNICODE_STRING LastComponent;
    KPROCESSOR_MODE PreviousMode;


    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    if(InputBufferLength < sizeof(DFS_TRANSLATE_PATH_ARG))
    {
        Status = STATUS_INVALID_USER_BUFFER; 
        return Status;
    }

    RtlZeroMemory( &prefix, sizeof(prefix) );

    prefix.Length = 0;
    prefix.MaximumLength = sizeof( nameBuffer );
    prefix.Buffer = nameBuffer;

    Status = DfspFormPrefix(
                &arg->ParentPathName,
                &arg->DfsPathName,
                &prefix);

    //DbgPrint("Translate path Is %wZ\n", &arg->DfsPathName);

    if (NT_SUCCESS(Status)) 
    {  
        //DbgPrint("Totalpath =%wZ\n", &prefix);

        if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) 
        {
          //  DbgPrint("STRIP_LAST on \n");

            LastComponent = prefix;

            RemoveLastComponent(&LastComponent, &prefix, FALSE);

            LastComponent.Length -= prefix.Length;
            LastComponent.MaximumLength -= prefix.Length;
            LastComponent.Buffer += (prefix.Length / sizeof(WCHAR));

           // DbgPrint("Last component =%wZ\n", &LastComponent);

           // DbgPrint("new prefix =%wZ\n", &prefix);
        }


        DfsGetPathComponents(&prefix, &ServerName, &ShareName, &RemainingName);            

        //DbgPrint("RemainingName =%wZ\n", &RemainingName);

        Status = DfsCheckReparse( &arg->SubDirectory,
                                  &RemainingName );


        if (arg->ParentPathName.Length == 0) 
        {
           // DbgPrint("Parent name is NULL\n");

            if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) 
            {            
                //
                // dfsdev: investigate. GetPathComp may return remname.buffer = NuLL
                //
                RemainingName.Length += LastComponent.Length;
            }
        }

        arg->DfsPathName.Length = RemainingName.Length;

        RtlMoveMemory(
                    arg->DfsPathName.Buffer,
                    RemainingName.Buffer,
                    RemainingName.Length);


        arg->DfsPathName.Buffer[
                    arg->DfsPathName.Length/sizeof(WCHAR)] = UNICODE_NULL;

        //DbgPrint("DfsPathName =%wZ\n", &arg->DfsPathName);
    }
    
    if (prefix.Buffer != NULL && prefix.Buffer != nameBuffer) 
    {
        ExFreePool( prefix.Buffer );
    }

    //DbgPrint("Translate path Is %wZ, Status %x\n", &arg->DfsPathName, Status);
    
    
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCheckParse - check if the path crosses a dfs link.
//
//  Arguments:  
//    PUNICODE_STRING pParent - the shared out directory.
//    PUNICODE_STRING pName - the directory hierarchy relative to parent.
//
//  Returns:    Status
//               ERROR_PATH_NOT_COVERED - if link
//               ERROR_SUCCESS - otherwise.
//
//  Description: This routine currently opens the passed in file, and
//               returns the open status if it is PATH_NOT_COVERED.
//               Otherwise it return STATUS_SUCCESS.
//
//
//               This should not have been necessary. When the server
//               gets a query path from the client, it calls DFS to
//               see if this is a link. however, in this new dfs, we
//               use reparse points, so this mechanism of the server
//               querying DFS should not be necessary. The server should
//               get STATUS_PATH_NOT_COVERED during the query path, and
//               return that to the client.
//
//               It turns out that the server (including an io manager api)
//               do a create file with FILE_OPEN_REPARSE_POINT when getting
//               the file attributes. This completely bypasses the DFS
//               mechanism of returning STATUS_PATH_NOT_COVERED, so the 
//               query path actually succeeds even for links!
//               This results in the client coming in with a findfirst
//               which fails, and for some reason that failure does not
//               result in the DFS on the  client attempting to get
//               referrals.
//
//               All of the above needs investigation and fixing.
//               This code will work in the meanwhile. Its not very
//               effective on performance to have this code.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsCheckReparse( 
    PUNICODE_STRING pParent,
    PUNICODE_STRING pName )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE              ParentHandle, Handle;
    IO_STATUS_BLOCK     IoStatus;


    InitializeObjectAttributes(
        &ObjectAttributes,
        pParent,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ZwCreateFile( &ParentHandle,
                           FILE_READ_ATTRIBUTES,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_OPEN,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0);
    
    if (Status == STATUS_SUCCESS)
    {
        InitializeObjectAttributes(
            &ObjectAttributes,
            pName,
            OBJ_CASE_INSENSITIVE,
            ParentHandle,
            NULL);


        Status = ZwCreateFile( &Handle,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0);
        ZwClose( ParentHandle );
    }

    //DbgPrint("DfsCheckreparse %wZ %wZ returning %d\n", pParent, pName, Status);
             
    if (Status == STATUS_SUCCESS)
    {
        ZwClose(Handle);
    }
    else if (Status != STATUS_PATH_NOT_COVERED)
    {
        Status = STATUS_SUCCESS;
    }

    return Status;
}

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered for the DFS device.
Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp )
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PAGED_CODE();

    //
    //  Need to disable Kernel APC delivery
    //
    FsRtlEnterFileSystem();

    //DbgPrint("DfsHandlePrivateFsControl: input and output buffer lengths are =%d %d \n",
        //     InputBufferLength, OutputBufferLength);

    IoStatus->Information = 0;

    switch(IoControlCode)
    {
    case DFSFILTER_START_UMRX:
              
        // DbgPrint("DfsHandlePrivateFsControl: DFSFILTER_START_UMRX\n");
        Status = DfsStartupUMRx();

        if(!pPrefixTable)
        {
           Status = DfsInitializePrefixTable(&pPrefixTable, FALSE, NULL);
           if (Status != STATUS_SUCCESS) 
           {
              DbgPrint("DfsDriverEntry prefix table failed: %08lx\n", Status );
           }

           gfRundownPrefixCompleted = FALSE;
        }
        break;

    case DFSFILTER_STOP_UMRX:

       // DbgPrint("DfsHandlePrivateFsControl: DFSFILTER_STOP_UMRX\n");
        Status = DfsTeardownUMRx();

        Status = DfsRunDownPrefixTable();

        break;

    case DFSFILTER_PROCESS_UMRXPACKET:


       // DbgPrint("DfsHandlePrivateFsControl: DFSFILTER_PROCESS_UMRXPACKET\n");
        Status = DfsProcessUMRxPacket(
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        IoStatus);
        break;

    case DFSFILTER_GETREPLICA_INFO:
#if 0

        //DbgPrint("DfsHandlePrivateFsControl: DFSFILTER_GETREPLICA_INFO\n");
        Status = DfsGetReplicaInformation(
                                          InputBuffer,
                                          InputBufferLength,
                                          OutputBuffer,
                                          OutputBufferLength,
                                          Irp,
                                          IoStatus);
#endif

        break;

    case FSCTL_DFS_GET_REFERRALS:

       // DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_GET_REFERRALS\n");
        Status = DfsFsctrlGetReferrals(
                                          InputBuffer,
                                          InputBufferLength,
                                          OutputBuffer,
                                          OutputBufferLength,
                                          Irp,
                                          IoStatus);
        break;

    case FSCTL_DFS_REPORT_INCONSISTENCY:

        DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_REPORT_INCONSISTENCY\n");
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_TRANSLATE_PATH:

       // DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_TRANSLATE_PATH\n");

        Status = DfsFsctrlTranslatePath(InputBuffer, InputBufferLength);
        break;

    case FSCTL_DFS_IS_ROOT:

       // DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_IS_ROOT\n");
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_IS_SHARE_IN_DFS:

      //  DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_IS_SHARE_IN_DFS\n");

        Status = DfsFsctrlIsShareInDfs(InputBuffer,InputBufferLength );
        break;

    case FSCTL_DFS_FIND_SHARE:

      //  DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_FIND_SHARE\n");
        Status = STATUS_SUCCESS;
        break;

    case DFSFILTER_ATTACH_FILESYSTEM:
        Status = DfsHandleAttachToFs(InputBuffer, InputBufferLength);
        break;

    case DFSFILTER_DETACH_FILESYSTEM:
        Status = DfsHandleDetachFromFs(InputBuffer, InputBufferLength);
        break;

    case FSCTL_DFS_START_DFS:

        DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_START_DFS\n");
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_STOP_DFS:

        DbgPrint("DfsHandlePrivateFsControl: FSCTL_DFS_STOP_DFS\n");
        Status = STATUS_SUCCESS;
        break;

    case  FSCTL_DFS_GET_VERSION:

        if (OutputBuffer != NULL &&
            OutputBufferLength >= sizeof(DFS_GET_VERSION_ARG)) 
        {
            PDFS_GET_VERSION_ARG parg =
                    (PDFS_GET_VERSION_ARG) OutputBuffer;
                    parg->Version = 1;
                    Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof(DFS_GET_VERSION_ARG);
        } 
        else 
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        break;
    case FSCTL_DISMOUNT_VOLUME:

        Status = STATUS_NOT_SUPPORTED;
        break;
    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case  FSCTL_DFS_READ_METERS:
    case  FSCTL_SRV_DFSSRV_IPADDR:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    case FSCTL_DFS_ISDC:

        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_ISNOTDC: 
               
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_GET_ENTRY_TYPE:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case  FSCTL_DFS_MODIFY_PREFIX:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case FSCTL_DFS_CREATE_EXIT_POINT:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case FSCTL_DFS_DELETE_EXIT_POINT:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case FSCTL_DFS_INIT_LOCAL_PARTITIONS:
        Status = STATUS_SUCCESS;
        break;


    case FSCTL_DFS_CREATE_SPECIAL_INFO:
        Status = STATUS_SUCCESS;
        break;


    case FSCTL_DFS_DELETE_SPECIAL_INFO:
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_RESET_PKT:
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_MARK_STALE_PKT_ENTRIES:
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES:
        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_CREATE_LOCAL_PARTITION:
        Status = STATUS_SUCCESS;
        break;


    case FSCTL_DFS_REREAD_REGISTRY:
        Status = STATUS_SUCCESS;

        break;
    default:

        //DbgPrint("DfsHandlePrivateFsControl: Unknown control %d \n",IoControlCode);
        break;
    }

    
    IoStatus->Status = Status;
    

    //DbgPrint("DfsHandlePrivateFsControl: returning status of %X\n", Status);


    if(Irp != NULL)
    {
       // DbgPrint("DfsHandlePrivateFsControl: IRP BASED CALL \n");
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    //
    // Re-enable Kernel APC delivery now.
    //
    FsRtlExitFileSystem();
    return Status;
}

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

NTSTATUS
DfsFilterFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Operation = 0;
    ULONG OutputBufferLength = 0;
    ULONG InputBufferLength = 0;
    PVOID InputBuffer = NULL;
    PVOID OutputBuffer = NULL;
    PDFS_FILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT newDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION newDevExt = NULL;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    KEVENT waitEvent;
    PVPB vpb;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {
        Operation = irpSp->Parameters.FileSystemControl.FsControlCode;
        InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;
        OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;        

        InputBuffer = Irp->AssociatedIrp.SystemBuffer;
        OutputBuffer = Irp->AssociatedIrp.SystemBuffer;

        status = DfsHandlePrivateFsControl (DeviceObject,
                                            Operation,
                                            InputBuffer,
                                            InputBufferLength,
                                            OutputBuffer,
                                            OutputBufferLength,
                                            &Irp->IoStatus,
                                            Irp );
        return status;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.  
        //
        //  Since the device object we are going to attach to has not yet been
        //  created (it is created by the base file system) we are going to use
        //  the type of the file system control device object.  We are assuming
        //  that the file system control device object will have the same type
        //  as the volume device objects associated with it.
        //

        ASSERT(IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType));

        status = IoCreateDevice(
                    gpDfsFilterDriverObject,
                    sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                    NULL,
                    DeviceObject->DeviceType,
                    0,
                    FALSE,
                    &newDeviceObject );

        if (NT_SUCCESS( status )) {

            //
            //  We need to save the RealDevice object pointed to by the vpb
            //  parameter because this vpb may be changed by the underlying
            //  file system.  Both FAT and CDFS may change the VPB address if
            //  the volume being mounted is one they recognize from a previous
            //  mount.
            //

            newDevExt = newDeviceObject->DeviceExtension;
            newDevExt->DiskDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

            //
            //  Initialize our completion routine
            //

            KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine(
                Irp,
                DfsMountCompletion,
                &waitEvent,          //context parameter
                TRUE,
                TRUE,
                TRUE );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

            //
            //  Wait for the completion routine to be called
            //
            if (STATUS_PENDING == status) {

                NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
                ASSERT(STATUS_SUCCESS == localStatus);
            }

            //
            //  Get the correct VPB from the real device object saved in our
            //  device extension.  We do this because the VPB in the IRP stack
            //  may not be the correct VPB when we get here.  The underlying
            //  file system may change VPBs if it detects a volume it has
            //  mounted previously.
            //

            vpb = newDevExt->DiskDeviceObject->Vpb;

            //
            //  Display a message when we detect that the VPB for the given
            //  device object has changed.
            //


            if (vpb != irpSp->Parameters.MountVolume.Vpb) {
                DbgPrint("DFSFILTER: VPB in IRP stack changed   DO=%p IRPVPB=%p VPB=%p\n",
                         newDeviceObject,
                         irpSp->Parameters.MountVolume.Vpb,
                         vpb);
            }

            //
            //  If the operation succeeded and we are not alreayd attached,
            //  attach to the device object.
            //

            if (NT_SUCCESS( Irp->IoStatus.Status ) && 
                !DfsAttachedToDevice( vpb->DeviceObject, NULL )) {

                //
                //  Attach to the new mounted volume.  The file system device object
                //  that was just mounted is pointed to by the VPB.
                //

                DfsAttachToMountedDevice( vpb->DeviceObject,
                                          newDeviceObject, 
                                          newDevExt->DiskDeviceObject );

            } else {

                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    DbgPrint( "DFSFILTER: Mount volume failure for status=%08x\n", 
                              Irp->IoStatus.Status );

                } else {

                    DbgPrint( "DFSFILTER: Mount volume failure for already attached\n");
                }

                //
                //  The mount request failed.  Cleanup and delete the device
                //  object we created
                //

                DfsCleanupMountedDevice( newDeviceObject );
                IoDeleteDevice( newDeviceObject );
            }

            //
            //  Continue processing the operation
            //

            status = Irp->IoStatus.Status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;

        } else {

#if DBG
            DbgPrint( "DFSFILTER: Error creating volume device object, status=%08x\n", status );
#endif

            //
            //  We got an error creating the device object so this volume
            //  cannot be filtered.  Do not return an error because we don't
            //  want to prevent the system from booting.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.
        //
        //  NOTE:  Since we no longer are attaching to the standard
        //         Microsoft file system recognizers (see 
        //         SfAttachToFileSystemDevice) we will normally never execute
        //         this code.  However, there might be 3rd party file systems
        //         which have their own recognizer which may still trigger this
        //         IRP.
        //


        DbgPrint( "DFSFILTER: Loading File System, Detaching\n");


        //
        //  Set a completion routine so we can delete the device object when
        //  the load is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine( Irp,
                                DfsLoadFsCompletion,
                                &waitEvent,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Detach from the file system recognizer device object.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

        if (STATUS_PENDING == status) {

            NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == localStatus);
        }


        DbgPrint( "DFSFILTER: Detaching from recognizer  status=%08x\n", 
                  Irp->IoStatus.Status );
        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            IoAttachDeviceToDeviceStack( DeviceObject, devExt->AttachedToDeviceObject );

        } else {

            //
            //  The load was successful, delete the Device object
            //

            DfsCleanupMountedDevice( DeviceObject );
            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else {

        //
        //  Simply pass this file system control request through.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    //  Any special processing has been completed, so simply pass the request
    //  along to the next driver.
    //

    return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
}



NTSTATUS
DfsGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    PFILE_OBJECT volumeFileObject = NULL;
    PDEVICE_OBJECT nextDeviceObject =NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;

    InitializeObjectAttributes( &objectAttributes,
								DeviceName,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    Status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if(!NT_SUCCESS( Status )) {

        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName ZwCreateFile failed  %x\n", Status);
        return Status;
    }

	//
    // get a pointer to the volumes file object
	//

    Status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( Status )) 
    {

        ZwClose( fileHandle );

        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName ObReferenceObjectByHandle failed  %x\n", Status);
        return Status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        Status = STATUS_NO_SUCH_DEVICE;
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName IoGetRelatedDeviceObject failed  %x\n", Status);
        return STATUS_NO_SUCH_DEVICE;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}


NTSTATUS 
DfsAttachToFileSystem (
    IN PWSTR UserDeviceName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_OBJECT NextDeviceObject = NULL;
    PDEVICE_OBJECT DiskDeviceObject = NULL;
    PDEVICE_OBJECT DfsDeviceObject = NULL;
    PDEVICE_OBJECT BaseFileSystemDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION Devext = NULL;
    UNICODE_STRING DeviceName;

    RtlInitUnicodeString( &DeviceName, UserDeviceName );

    Status = DfsGetDeviceObjectFromName (&DeviceName, &NextDeviceObject);
    if (!NT_SUCCESS( Status )) 
    {
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem DfsGetDeviceObjectFromName failed  %x\n", Status);
        return Status;
    }

    if(!DfsAttachedToDevice(NextDeviceObject, &DfsDeviceObject))
    {
        //
        //  We want to attach to this file system.  Create a new device object we
        //  can attach with.
        //

        Status = IoCreateDevice( gpDfsFilterDriverObject,
                             sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                             NULL,
                             NextDeviceObject->DeviceType,
                             0,
                             FALSE,
                             &DfsDeviceObject );

        if (!NT_SUCCESS( Status )) 
        {
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem IoCreateDevice failed  %x\n", Status);
            return Status;
        }

        //
        //  Get the disk device object associated with this file system
        //  device object.  Only try to attach if we have a disk device object.
        //  It may not have a disk device object for the following reasons:
        //  - It is a control device object for a driver
        //  - There is no media in the device.
        //

        //  We first have to get the base file system device object.  After
        //  using it we remove the refrence by the call.
        //

        BaseFileSystemDeviceObject = IoGetDeviceAttachmentBaseRef( NextDeviceObject );
        Status = IoGetDiskDeviceObject( BaseFileSystemDeviceObject, &DiskDeviceObject );
        ObDereferenceObject( BaseFileSystemDeviceObject );

        if (!NT_SUCCESS( Status )) 
        {
            IoDeleteDevice( DfsDeviceObject );
            ObDereferenceObject( NextDeviceObject );
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem ObDereferenceObject failed  %x\n", Status);
            return Status;
        }

        //
        //  Call the routine to attach to a mounted device.
        //

        Status = DfsAttachToMountedDevice( NextDeviceObject,
                                           DfsDeviceObject,
                                           DiskDeviceObject );

        //
        //  Remove reference added by IoGetDiskDeviceObject.
        //  We only need to hold this reference until we are
        //  successfully attached to the current volume.  Once
        //  we are successfully attached to devList[i], the
        //  IO Manager will make sure that the underlying
        //  diskDeviceObject will not go away until the file
        //  system stack is torn down.
        //

        ObDereferenceObject( DiskDeviceObject );

        if (!NT_SUCCESS( Status )) 
        {
            DfsCleanupMountedDevice( DfsDeviceObject );
            IoDeleteDevice( DfsDeviceObject );
            ObDereferenceObject( NextDeviceObject );
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem DfsAttachToMountedDevice failed  %x\n", Status);
            return Status;
        }

        Devext = DfsDeviceObject->DeviceExtension;
        Devext->DeviceInUse = TRUE;
        Devext->RefCount = 1;

        //
        //  We are done initializing this device object, so
        //  clear the DO_DEVICE_OBJECT_INITIALIZING flag.
        //

        ClearFlag( DfsDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    }
    else
    {
        Devext = DfsDeviceObject->DeviceExtension;
        Devext->DeviceInUse = TRUE;
        InterlockedIncrement(&Devext->RefCount);
    }

    ObDereferenceObject( NextDeviceObject );
    return Status;

}


NTSTATUS 
DfsDetachFromFileSystem (
    IN PWSTR UserDeviceName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    PDEVICE_OBJECT DfsDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION Devext = NULL;
    UNICODE_STRING DeviceName;

    RtlInitUnicodeString( &DeviceName, UserDeviceName );

    Status = DfsGetDeviceObjectFromName (&DeviceName, &DeviceObject);
    if (!NT_SUCCESS( Status )) 
    {
        return Status;
    }

    if(DfsAttachedToDevice(DeviceObject, &DfsDeviceObject))
    {
       Devext = DfsDeviceObject->DeviceExtension;

       if(InterlockedDecrement(&Devext->RefCount) == 0)
       {
           Devext->DeviceInUse = FALSE; 
       }

       ObDereferenceObject( DfsDeviceObject );

    }
    else
    {
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    ObDereferenceObject( DeviceObject );

    return Status;
}

NTSTATUS
DfsFindAndRemovePrefixEntry(PWSTR ShareString)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR VolumeName = NULL;
    PWSTR OldValue = NULL;
    UNICODE_STRING ShareName;
    UNICODE_STRING Suffix;

    RtlInitUnicodeString(&ShareName, ShareString);

    Status = DfsRemoveFromPrefixTableEx(pPrefixTable,
                                      &ShareName,
                                      (PVOID)VolumeName,
                                       &OldValue);
    if(OldValue)
    {
        ExFreePool(OldValue);
    }

    return Status;
}

#define DFS_SPECIAL_SHARE 1

NTSTATUS
DfsHandleAttachToFs(PVOID InputBuffer, ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS DummyStatus = STATUS_SUCCESS;
    PWSTR DeviceName = NULL;
    BOOL ShareInserted = FALSE;
    PDFS_ATTACH_PATH_BUFFER pAttachBuffer = (PDFS_ATTACH_PATH_BUFFER)InputBuffer;
    UNICODE_STRING ShareName ;
    UNICODE_STRING VolumeName;

    try
    {

        //see if the raw inputs are valid
        if( (InputBuffer == NULL) || 
            (InputBufferLength <= 0) ||
            (InputBufferLength < sizeof(DFS_ATTACH_PATH_BUFFER)))
        {
            Status = STATUS_INVALID_PARAMETER;
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs buffer length checks failed  %x\n", Status);
            goto Exit;
        }


        if(pPrefixTable == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs prefix table NULL  %x\n", Status);
            goto Exit;
        }

        //get the real inputs
        VolumeName.Buffer = pAttachBuffer->PathNameBuffer;
        VolumeName.Length = VolumeName.MaximumLength = (USHORT) pAttachBuffer->VolumeNameLength;


        ShareName.Buffer = VolumeName.Buffer + (pAttachBuffer->VolumeNameLength / sizeof(WCHAR));
        ShareName.Length= ShareName.MaximumLength = (USHORT) pAttachBuffer->ShareNameLength;

        // Now see if the embedded inputs are valid

        if ( (pAttachBuffer->VolumeNameLength > InputBufferLength) ||
              (pAttachBuffer->ShareNameLength > InputBufferLength) ||
              (pAttachBuffer->VolumeNameLength < sizeof(WCHAR)) ||
              (pAttachBuffer->ShareNameLength < sizeof(WCHAR)) ||
              ((FIELD_OFFSET(DFS_ATTACH_PATH_BUFFER,PathNameBuffer) +
                pAttachBuffer->VolumeNameLength +
                pAttachBuffer->ShareNameLength) > InputBufferLength))
        {
              Status = STATUS_INVALID_PARAMETER;
              DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs embedded inputs failed  %x\n", Status);
              goto Exit;
        }

        DeviceName = ExAllocatePool( NonPagedPool, VolumeName.Length + sizeof(WCHAR) );
        if (DeviceName == NULL) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs pool allocate failed  %x\n", Status);
            goto Exit;
        }

        RtlCopyMemory( DeviceName, VolumeName.Buffer, VolumeName.Length );
        DeviceName[VolumeName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        Status = DfsInsertInPrefixTable(pPrefixTable, 
                                        &ShareName,
                                        (PVOID)DeviceName);

        if(Status == STATUS_OBJECT_NAME_EXISTS)
        {
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs DfsInsertInPrefixTable returned error  %x\n", Status);
            Status = DfsFindAndRemovePrefixEntry(ShareName.Buffer);
            if(Status == STATUS_SUCCESS)
            {
                Status = DfsInsertInPrefixTable(pPrefixTable, 
                                                &ShareName,
                                                (PVOID)DeviceName);
            }
        }

        if(Status != STATUS_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs DfsInsertInPrefixTable2 returned error  %x\n", Status);
            goto Exit;
        }

        ShareInserted = TRUE;

        if ((pAttachBuffer->Flags & DFS_SPECIAL_SHARE) != DFS_SPECIAL_SHARE)
        {

            Status = DfsAttachToFileSystem (DeviceName);
            if(Status != STATUS_SUCCESS)
            {
                DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs DfsAttachToFileSystem returned error  %x\n", Status);
            }
        }
        else
        {
            //DbgPrint("Found special share %wZ on dc\n", &ShareName);
        }

Exit:

        if((Status != STATUS_SUCCESS) && ShareInserted)
        {
            DummyStatus = DfsRemoveFromPrefixTable(pPrefixTable, 
                                               &ShareName,
                                               (PVOID)DeviceName);
            if (DeviceName != NULL) 
            {
                ExFreePool( DeviceName );
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    return Status;
}



NTSTATUS
DfsHandleDetachFromFs(PVOID InputBuffer, ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS DummyStatus = STATUS_SUCCESS;
    PWSTR DeviceName = NULL;
    PWSTR OldValue = NULL;
    PDFS_ATTACH_PATH_BUFFER pAttachBuffer = (PDFS_ATTACH_PATH_BUFFER)InputBuffer;
    UNICODE_STRING ShareName ;
    UNICODE_STRING VolumeName;

    try
    {

        //see if the raw inputs are valid
        if( (InputBuffer == NULL) || 
            (InputBufferLength <= 0) ||
            (InputBufferLength < sizeof(DFS_ATTACH_PATH_BUFFER)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }


        if(pPrefixTable == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        //get the real inputs
        VolumeName.Buffer = pAttachBuffer->PathNameBuffer;
        VolumeName.Length = VolumeName.MaximumLength = (USHORT) pAttachBuffer->VolumeNameLength;


        ShareName.Buffer = VolumeName.Buffer + (pAttachBuffer->VolumeNameLength / sizeof(WCHAR));
        ShareName.Length= ShareName.MaximumLength = (USHORT) pAttachBuffer->ShareNameLength;

        // Now see if the embedded inputs are valid
        if ( (pAttachBuffer->VolumeNameLength > InputBufferLength) ||
              (pAttachBuffer->ShareNameLength > InputBufferLength) ||
              (pAttachBuffer->VolumeNameLength < sizeof(WCHAR)) ||
              (pAttachBuffer->ShareNameLength < sizeof(WCHAR)) ||
              ((FIELD_OFFSET(DFS_ATTACH_PATH_BUFFER,PathNameBuffer) +
                pAttachBuffer->VolumeNameLength +
                pAttachBuffer->ShareNameLength) > InputBufferLength))
        {
              Status = STATUS_INVALID_PARAMETER;
              goto Exit;
        }

        DeviceName = ExAllocatePool( NonPagedPool, VolumeName.Length + sizeof(WCHAR) );
        if (DeviceName == NULL) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        RtlCopyMemory( DeviceName, VolumeName.Buffer, VolumeName.Length );
        DeviceName[VolumeName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        VolumeName.Buffer = DeviceName;

        Status = DfsDetachFromFileSystem (VolumeName.Buffer);

        if(Status == STATUS_SUCCESS)
        {

            Status = DfsRemoveFromPrefixTableEx(pPrefixTable, 
                                              &ShareName,
                                              NULL,
                                              &OldValue);
            if(OldValue != NULL)
            {
                ExFreePool(OldValue);
            }

        }

Exit:

        if (DeviceName != NULL) 
        {
          ExFreePool( DeviceName );
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobcache.cxx ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobCache.cxx
//
//  Contents:   the ADBlob DFS Store class, this contains the 
//              old AD blob store specific functionality. 
//
//  Classes:    DfsADBlobCache.
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 9 2001  Rohanp - Added  AD specific code.
//
//-----------------------------------------------------------------------------
  
#include <DfsAdBlobCache.hxx>
#include <dfserror.hxx>
#include "dfsadsiapi.hxx"

#include "dfsAdBlobCache.tmh"


DfsADBlobCache::DfsADBlobCache(
    DFSSTATUS *pStatus, 
    PUNICODE_STRING pShareName) :  DfsGeneric(DFS_OBJECT_TYPE_ADBLOB_CACHE)
{
    SHASH_FUNCTABLE FunctionTable;
    LPWSTR DNBuffer;
    LPWSTR RemainingDN;

    m_pBlob = NULL;
    m_pRootBlob = NULL;
    m_pTable = NULL;

    m_pAdHandle = NULL;
    m_AdReferenceCount = 0;

    RtlInitUnicodeString(&m_LogicalShare, NULL);
    RtlInitUnicodeString(&m_ObjectDN, NULL);


    ZeroMemory(&FunctionTable, sizeof(FunctionTable));
    
    FunctionTable.AllocFunc = AllocateShashData;
    FunctionTable.FreeFunc = DeallocateShashData;

    ZeroMemory(&m_BlobAttributePktGuid, sizeof(GUID));
    
    InitializeCriticalSection( &m_Lock );

    
    *pStatus = DfsCreateUnicodeString(&m_LogicalShare, pShareName);

    if (*pStatus == ERROR_SUCCESS)
    {
        RemainingDN = DfsGetDfsAdNameContextString();
        ULONG DNSize = 3 + 
                 wcslen(m_LogicalShare.Buffer) + 
                 1 + 
                 wcslen(DFS_AD_CONFIG_DATA) +
                 1 +
                 wcslen(RemainingDN) + 1;

        DNBuffer = new WCHAR[DNSize];
        if (DNBuffer != NULL)
        {
            wcscpy(DNBuffer, L"CN=");
            wcscat(DNBuffer, m_LogicalShare.Buffer);
            wcscat(DNBuffer, L",");
            wcscat(DNBuffer, DFS_AD_CONFIG_DATA);
            wcscat(DNBuffer, L",");
            wcscat(DNBuffer, RemainingDN);

            RtlInitUnicodeString( &m_ObjectDN, DNBuffer );
        }
        else 
        {
            *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if (*pStatus == ERROR_SUCCESS)
    {
        *pStatus = ShashInitHashTable(&m_pTable, &FunctionTable);
    }

    if (*pStatus == ERROR_SUCCESS)
    {
        *pStatus = RtlNtStatusToDosError(*pStatus);
    }
}


DfsADBlobCache::~DfsADBlobCache() 
{

    if(m_pBlob)
    {
        DeallocateShashData(m_pBlob);
        m_pBlob = NULL;
    }

    if (m_pTable != NULL)
    {
        InvalidateCache();
        ShashTerminateHashTable(m_pTable);
        m_pTable = NULL;
    }

    if (m_LogicalShare.Buffer != NULL)
    {
        delete [] m_LogicalShare.Buffer;
    }
    if (m_ObjectDN.Buffer != NULL)
    {
        delete [] m_ObjectDN.Buffer;
    }

    DeleteCriticalSection(&m_Lock);

}    





#ifndef DFS_USE_LDAP


DFSSTATUS
DfsADBlobCache::UpdateCacheWithDSBlob(
    PVOID pHandle )
{
    HRESULT hr = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    VARIANT BinaryBlob;

    IADs *pADs  = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating cache with blob \n", this);
    VariantInit(&BinaryBlob);

    hr = pADs->Get(ADBlobAttribute, &BinaryBlob);
    if ( SUCCEEDED(hr) )
    {
        Status = GetBinaryFromVariant( &BinaryBlob, &pBuffer, &Length );
        if (Status == ERROR_SUCCESS)
        {
            Status = UnpackBlob( pBuffer, &Length, NULL );

            DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unpack blob done with status %x\n", Status);
            
            delete [] pBuffer;
        }
    }
    else
    {
        Status = DfsGetErrorFromHr(hr);
    }
    VariantClear(&BinaryBlob);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: Updated cache (length %x) status %x\n", 
                         this, Length, Status);

    return Status;
}

DFSSTATUS
DfsADBlobCache::GetObjectPktGuid( 
    PVOID pHandle,
    GUID *pGuid )
{
    HRESULT hr = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    VARIANT BinaryBlob;

    IADs *pADs = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: getting pkt guid\n", this);

    VariantInit(&BinaryBlob);

    hr = pADs->Get(ADBlobPktGuidAttribute, &BinaryBlob);
    if ( SUCCEEDED(hr) )
    {
        Status = GetBinaryFromVariant( &BinaryBlob, &pBuffer, &Length );
        if (Status == ERROR_SUCCESS)
        {
            if (Length > sizeof(GUID)) Length = sizeof(GUID);

            RtlCopyMemory( pGuid, pBuffer, Length);
            
            delete [] pBuffer;
        }
    }
    VariantClear(&BinaryBlob);

    Status = DfsGetErrorFromHr(hr);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: got pkt guid, Status %x\n", 
                         this, Status );


    return Status;
}


DFSSTATUS 
DfsADBlobCache::UpdateDSBlobFromCache(
    PVOID pHandle,
    GUID *pGuid )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length;
    ULONG UseLength;
    ULONG TotalBlobBytes = 0;
    VARIANT BinaryBlob;
    IADs *pObject = (IADs *)pHandle;

    VariantInit(&BinaryBlob);

    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating ds with cache \n", this);

    UseLength = ADBlobDefaultBlobPackSize;
retry:
    Length = UseLength;
    pBuffer =  (BYTE *) HeapAlloc(GetProcessHeap(), 0, 
                                  Length );
    if(pBuffer != NULL)
    {
        Status = PackBlob(pBuffer, &Length, &TotalBlobBytes); 
        if(Status == STATUS_SUCCESS)
        {
            Status = PutBinaryIntoVariant(&BinaryBlob, pBuffer, TotalBlobBytes);
            if(Status == STATUS_SUCCESS)
            {
                HResult = pObject->Put(ADBlobAttribute, BinaryBlob);
                if (SUCCEEDED(HResult) )
                {
                    HResult = pObject->SetInfo();
                }

                Status = DfsGetErrorFromHr(HResult);

                if (Status == ERROR_SUCCESS)
                {
                    Status = SetObjectPktGuid( pObject, pGuid );
                }
            }
        }
        DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: update ds (Buffer Len %x, Length %x) Status %x\n",
                            this, UseLength, Length, Status);

        HeapFree(GetProcessHeap(), 0, pBuffer);

        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            if (UseLength < ADBlobMaximumBlobPackSize)
            {
                UseLength *= 2;
            }
            goto retry;
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    VariantClear(&BinaryBlob);
    DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: update ds done (Buffer Length %x, Length %x) Status %x\n",
                        this, UseLength, Length, Status);

    return Status;
}


DFSSTATUS
DfsADBlobCache::SetObjectPktGuid( 
    IADs *pObject,
    GUID *pGuid )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    VARIANT BinaryBlob;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: setting pkt guid\n", this);
    VariantInit(&BinaryBlob);

    Status = PutBinaryIntoVariant( &BinaryBlob, (PBYTE)pGuid, sizeof(GUID));
    if (Status == ERROR_SUCCESS)
    {
        HResult = pObject->Put(ADBlobPktGuidAttribute, BinaryBlob);
        if (SUCCEEDED(HResult) )
        {
            HResult = pObject->SetInfo();
        }

        Status = DfsGetErrorFromHr(HResult);
    }

    VariantClear(&BinaryBlob);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: set pkt guid, Status %x\n", 
                         this, Status );


    return Status;
}

#else


DFSSTATUS
DfsADBlobCache::DfsLdapConnect(
    LPWSTR DCName,
    LDAP **ppLdap )
{
    LDAP *pLdap;
    DFSSTATUS Status;
    LPWSTR DCNameToUse;
    UNICODE_STRING GotDCName; 

    RtlInitUnicodeString( &GotDCName, NULL );

    DCNameToUse = DCName;
    if (IsEmptyString(DCNameToUse))
    {
        DfsGetBlobDCName( &GotDCName );
        DCNameToUse = GotDCName.Buffer;
    }

    pLdap = ldap_initW(DCNameToUse, LDAP_PORT);
    if (pLdap != NULL)
    {
        Status = ldap_set_option(pLdap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
        if (Status == LDAP_SUCCESS)
        {
            Status = ldap_bind_s(pLdap, NULL, NULL, LDAP_AUTH_SSPI);
        }
    }
    else
    {
        Status = LdapGetLastError();
    }


    if (Status == LDAP_SUCCESS)
    {
        *ppLdap = pLdap;
    }
    else
    {
        Status = LdapMapErrorToWin32(Status);
    }

    //
    // Since we initialized DCName with empty string, it is benign
    // to call this, even if we did not call GetBlobDCName above.
    //
    DfsReleaseBlobDCName( &GotDCName );

    return Status;

}



VOID
DfsADBlobCache::DfsLdapDisconnect(
    LDAP *pLdap )
{
    ldap_unbind(pLdap);
}


DFSSTATUS
DfsADBlobCache::DfsGetPktBlob(
    LDAP *pLdap,
    LPWSTR ObjectDN,
    PVOID *ppBlob,
    PULONG pBlobSize,
    PVOID *ppHandle,
    PVOID *ppHandle1 )
{

    LPWSTR Attributes[2];
    DFSSTATUS Status;
    DFSSTATUS LdapStatus;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject;
    PLDAP_BERVAL *pLdapPktAttr;


    Status = ERROR_NOT_ENOUGH_MEMORY; // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.

    Attributes[0] = ADBlobAttribute;
    Attributes[1] = NULL;

    LdapStatus = ldap_search_sW( pLdap,
                                 ObjectDN,                 // search DN
                                 LDAP_SCOPE_BASE,             // search base
                                 L"(objectClass=*)",           // Filter
                                 Attributes,                   // Attributes
                                 0,                           // Read Attributes and Value
                                 &pLdapSearchedObject);
    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapPktAttr = ldap_get_values_len( pLdap,
                                                pLdapObject,
                                                Attributes[0] );
            if (pLdapPktAttr != NULL)
            {
                *ppBlob = pLdapPktAttr[0]->bv_val;
                *pBlobSize = pLdapPktAttr[0]->bv_len;

                *ppHandle = (PVOID)pLdapPktAttr;
                *ppHandle1 = (PVOID)pLdapSearchedObject;
                pLdapSearchedObject = NULL;

                Status = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}

VOID
DfsADBlobCache::DfsReleasePktBlob(
    PVOID pHandle,
    PVOID pHandle1 )
{
    PLDAP_BERVAL *pLdapPktAttr = (PLDAP_BERVAL *)pHandle;
    PLDAPMessage pLdapSearchedObject = (PLDAPMessage)pHandle1;

    ldap_value_free_len( pLdapPktAttr );
    ldap_msgfree( pLdapSearchedObject );
}


DFSSTATUS
DfsADBlobCache::UpdateCacheWithDSBlob(
    PVOID pHandle )

{
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    PVOID pHandle1, pHandle2;

    LDAP *pLdap = (LDAP *)pHandle;
    LPWSTR ObjectDN = m_ObjectDN.Buffer;
    
    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating cache with blob \n", this);

    Status = DfsGetPktBlob( pLdap,
                            ObjectDN,
                            (PVOID *)&pBuffer,
                            &Length,
                            &pHandle1,
                            &pHandle2);
    if ( Status == ERROR_SUCCESS)
    {
        Status = UnpackBlob( pBuffer, &Length, NULL );

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unpack blob done with status %x\n", Status);

        DfsReleasePktBlob( pHandle1, pHandle2);
    }

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: Updated cache (length %x) status %x\n", 
                         this, Length, Status);

    return Status;
}




DFSSTATUS
DfsADBlobCache::GetObjectPktGuid(
    PVOID pHandle,
    GUID *pGuid )
{

    LPWSTR Attributes[2];
    DFSSTATUS Status;
    DFSSTATUS LdapStatus;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject;
    PLDAP_BERVAL *pLdapGuidAttr;
    ULONG CopySize;
    
    LDAP *pLdap = (LDAP *)pHandle;
    LPWSTR ObjectDN = m_ObjectDN.Buffer;

    Status = ERROR_NOT_ENOUGH_MEMORY; // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.


    Attributes[0] = ADBlobPktGuidAttribute;
    Attributes[1] = NULL;

    LdapStatus = ldap_search_sW( pLdap,
                                 ObjectDN,                 // search DN
                                 LDAP_SCOPE_BASE,             // search base
                                 L"(objectClass=*)",           // Filter
                                 Attributes,                   // Attributes
                                 0,                           // Read Attributes and Value
                                 &pLdapSearchedObject);
    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapGuidAttr = ldap_get_values_len( pLdap,
                                                 pLdapObject,
                                                 Attributes[0] );
            if (pLdapGuidAttr != NULL)
            {
                CopySize = min( pLdapGuidAttr[0]->bv_len, sizeof(GUID));
                RtlCopyMemory( pGuid, pLdapGuidAttr[0]->bv_val, CopySize );

                ldap_value_free_len( pLdapGuidAttr );
                Status = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}

DFSSTATUS
DfsADBlobCache::DfsSetPktBlobAndPktGuid ( 
    LDAP *pLdap,
    LPWSTR ObjectDN,
    PVOID pBlob,
    ULONG BlobSize,
    GUID *pGuid )
{
    LDAP_BERVAL  LdapPkt, LdapPktGuid;
    PLDAP_BERVAL  pLdapPktValues[2], pLdapPktGuidValues[2];
    LDAPModW LdapPktMod, LdapPktGuidMod;
    PLDAPModW pLdapDfsMod[3];
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus;

    LDAPControlW    LazyCommitControl =
                    {
                        LDAP_SERVER_LAZY_COMMIT_OID_W,  // the control
                        { 0, NULL},                     // no associated data
                        FALSE                           // control isn't mandatory
                    };

    PLDAPControlW   ServerControls[2] =
                    {
                        &LazyCommitControl,
                        NULL
                    };


    LdapPkt.bv_len = BlobSize;
    LdapPkt.bv_val = (PCHAR)pBlob;
    pLdapPktValues[0] = &LdapPkt;
    pLdapPktValues[1] = NULL;
    LdapPktMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    LdapPktMod.mod_type = ADBlobAttribute;
    LdapPktMod.mod_vals.modv_bvals = pLdapPktValues;

    LdapPktGuid.bv_len = sizeof(GUID);
    LdapPktGuid.bv_val = (PCHAR)pGuid;
    pLdapPktGuidValues[0] = &LdapPktGuid;
    pLdapPktGuidValues[1] = NULL;
    LdapPktGuidMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    LdapPktGuidMod.mod_type = ADBlobPktGuidAttribute;
    LdapPktGuidMod.mod_vals.modv_bvals = pLdapPktGuidValues;

    pLdapDfsMod[0] = &LdapPktMod;
    pLdapDfsMod[1] = &LdapPktGuidMod;
    pLdapDfsMod[2] = NULL;

    LdapStatus = ldap_modify_ext_sW( pLdap,
                                     ObjectDN,
                                     pLdapDfsMod,
                                     (PLDAPControlW *)&ServerControls,
                                     NULL );

    if (LdapStatus != LDAP_SUCCESS)
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }


    return Status;

}

DFSSTATUS 
DfsADBlobCache::UpdateDSBlobFromCache(
    PVOID pHandle,
    GUID *pGuid )
{
    LDAP *pLdap = (LDAP *)pHandle;
    LPWSTR ObjectDN = m_ObjectDN.Buffer;
    BYTE *pBuffer = NULL;
    ULONG Length;
    ULONG UseLength;
    ULONG TotalBlobBytes;
    DFSSTATUS Status;

    UseLength = ADBlobDefaultBlobPackSize;
retry:
    Length = UseLength;
    pBuffer =  (BYTE *) HeapAlloc(GetProcessHeap(), 0, Length );
    if(pBuffer != NULL)
    {
        Status = PackBlob(pBuffer, &Length, &TotalBlobBytes); 
        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            HeapFree(GetProcessHeap(), 0, pBuffer);
            if (UseLength < ADBlobMaximumBlobPackSize)
            {
                UseLength *= 2;
            }
            goto retry;
        }

        if(Status == STATUS_SUCCESS)
        {

            Status = DfsSetPktBlobAndPktGuid( pLdap,
                                              ObjectDN,
                                              pBuffer,
                                              TotalBlobBytes,
                                              pGuid );
            DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: update ds (Buffer Len %x, Length %x) Status %x\n",
                                this, UseLength, Length, Status);


            HeapFree(GetProcessHeap(), 0, pBuffer);
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return Status;
}
#endif



BOOLEAN
DfsADBlobCache::CacheRefresh()
{
    PVOID           pHandle = NULL;
    GUID             CurrentGuid;
    DFSSTATUS Status;

    BOOLEAN ReturnValue = FALSE;
    DFS_TRACE_LOW( ADBLOB, "Cache %p: cache refresh\n", this);

    Status = GetADObject( &pHandle );

    if (Status == ERROR_SUCCESS)
    {
        Status = GetObjectPktGuid( pHandle, &CurrentGuid );

        //
        // here we pass the 2 guids by reference...
        //
        if (IsEqualGUID( CurrentGuid, m_BlobAttributePktGuid) == FALSE)
        {
            Status = UpdateCacheWithDSBlob( pHandle );
            if (Status == ERROR_SUCCESS)
            {
                m_BlobAttributePktGuid = CurrentGuid;
                ReturnValue = TRUE;
            }
        }
        ReleaseADObject( pHandle );
    }
    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "Cache %p: cache was refreshed = %d\n", this, ReturnValue);
    return ReturnValue;
}



void 
DfsADBlobCache::InvalidateCache()
{
    PDFSBLOB_DATA pBlobData;
    DFSBOB_ITER Iter;
    DFS_TRACE_LOW( ADBLOB, "Cache %p: invalidate cache\n", this);
    pBlobData = FindFirstBlob(&Iter);
    while (pBlobData != NULL)
    {
        DFSSTATUS RemoveStatus;

        RemoveStatus = RemoveNamedBlob(&pBlobData->BlobName);
        DFS_TRACE_ERROR_LOW( RemoveStatus, REFERRAL_SERVER, "BlobCache %p, invalidate cache, remove blob status %x\n",
                             this, RemoveStatus);
        pBlobData = FindNextBlob(&Iter);
    }

    FindCloseBlob(&Iter);
    DFS_TRACE_LOW( ADBLOB, "Cache %p: invalidate cache done\n", this);
}

DFSSTATUS
DfsADBlobCache::PutBinaryIntoVariant(VARIANT * ovData, BYTE * pBuf,
                                     unsigned long cBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;
     VARIANT var;
     SAFEARRAYBOUND  rgsabound[1];

     VariantInit(&var);  //Initialize our variant

     var.vt = VT_ARRAY | VT_UI1;

     rgsabound[0].cElements = cBufLen;
     rgsabound[0].lLbound = 0;

     var.parray = SafeArrayCreate(VT_UI1,1,rgsabound);

     if(var.parray != NULL)
     {
        //Get a safe pointer to the array
        SafeArrayAccessData(var.parray,&pArrayData);

        //Copy bitmap to it
        memcpy(pArrayData, pBuf, cBufLen);

        //Unlock the variant data
        SafeArrayUnaccessData(var.parray);

        *ovData = var;  

        Status = STATUS_SUCCESS;
     }
     else
     {
         Status = ERROR_NOT_ENOUGH_MEMORY;
        DFS_TRACE_HIGH( REFERRAL_SERVER, "PutBinaryIntoVariant failed error %d\n", Status);
     }


     return Status;
}



DFSSTATUS
DfsADBlobCache::GetBinaryFromVariant(VARIANT *ovData, BYTE ** ppBuf,
                                     unsigned long * pcBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;

     //Binary data is stored in the variant as an array of unsigned char
     if(ovData->vt == (VT_ARRAY|VT_UI1))  
     {
        //Retrieve size of array
        *pcBufLen = ovData->parray->rgsabound[0].cElements;

        *ppBuf = new BYTE[*pcBufLen]; //Allocate a buffer to store the data
        if(*ppBuf != NULL)
        {
            //Obtain safe pointer to the array
            SafeArrayAccessData(ovData->parray,&pArrayData);

            //Copy the bitmap into our buffer
            memcpy(*ppBuf, pArrayData, *pcBufLen);

            //Unlock the variant data
            SafeArrayUnaccessData(ovData->parray);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
     }

     return Status;
}


DFSSTATUS 
DfsADBlobCache::CacheFlush(
    PVOID pHandle )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    GUID NewGuid;

    IADs *pObject  = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: cache flush\n", this);
    Status = UuidCreate(&NewGuid);
    if (Status == ERROR_SUCCESS)
    {
        m_BlobAttributePktGuid = NewGuid;

        Status = UpdateDSBlobFromCache( pObject,
                                        &NewGuid );

    }
    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "Cache %p: cache flush, Status %x\n", this, Status);
    return Status;
}


DFSSTATUS
DfsADBlobCache::UnpackBlob(
    BYTE *pBuffer,
    PULONG pLength,
    PDFSBLOB_DATA * pRetBlob )
{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pUseBuffer = NULL;
    ULONG BufferSize = 0;
    ULONG ObjNdx = 0;
    ULONG TotalObjects = 0;
    ULONG  BlobSize = 0;
    BYTE *BlobBuffer = NULL;
    PDFSBLOB_DATA pLocalBlob = NULL;
    UNICODE_STRING BlobName;
    UNICODE_STRING SiteRoot;
    UNICODE_STRING BlobRoot;
     
    pUseBuffer = pBuffer;
    BufferSize = *pLength;

    DFS_TRACE_LOW( ADBLOB, "BlobCache %p, UnPackBlob \n", this);
    UNREFERENCED_PARAMETER(pRetBlob);

    RtlInitUnicodeString( &SiteRoot, ADBlobSiteRoot );
    RtlInitUnicodeString( &BlobRoot, ADBlobMetaDataNamePrefix);


    //
    // dfsdev: we should not need an interlocked here: this code
    // is already mutex'd by the caller.
    //
    InterlockedIncrement( &m_CurrentSequenceNumber );
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are discarding it.
    //
    Status = PackGetULong( &Discard, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if(BufferSize == 0)
    {
        goto done;
    }

    Status = PackGetULong(&TotalObjects, (PVOID *) &pUseBuffer, &BufferSize);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }


    for (ObjNdx = 0; ObjNdx < TotalObjects; ObjNdx++)
    {
        BOOLEAN FoundSite = FALSE;
        BOOLEAN FoundRoot = FALSE;

        Status = GetSubBlob( &BlobName,
                             &BlobBuffer,
                             &BlobSize,
                             &pUseBuffer,
                             &BufferSize );

        if (Status == ERROR_SUCCESS)
        {
            if (!FoundSite &&
               (RtlCompareUnicodeString( &BlobName, &SiteRoot, TRUE ) == 0))
            {
               FoundSite = TRUE;
               Status = CreateBlob(&BlobName, 
                                   BlobBuffer, 
                                   BlobSize,
                                   &pLocalBlob
                                   );
               if(Status == STATUS_SUCCESS)
               {
                   DeallocateShashData(m_pBlob);
                   m_pBlob = pLocalBlob;
               }

                continue;
            }
            if (!FoundRoot &&
               (RtlCompareUnicodeString( &BlobName, &BlobRoot, TRUE ) == 0))
            {
               FoundRoot = TRUE;
               UNICODE_STRING RootName;
               RtlInitUnicodeString(&RootName, NULL);
               Status = CreateBlob(&RootName,
                                   BlobBuffer, 
                                   BlobSize,
                                   &pLocalBlob
                                   );
               if(Status == STATUS_SUCCESS)
               {
                   DeallocateShashData(m_pRootBlob);
                   m_pRootBlob = pLocalBlob;
               }

                continue;
            }

            Status = StoreBlobInCache( &BlobName, BlobBuffer, BlobSize);
            if (Status != ERROR_SUCCESS)
            {
                break;
            }
        }
    }


done:

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "BlobCache %p: UnPackBlob status %x\n", this, Status);
    return Status;
}


DFSSTATUS
DfsADBlobCache::CreateBlob(PUNICODE_STRING BlobName, 
                           PBYTE pBlobBuffer, 
                           ULONG BlobSize,
                           PDFSBLOB_DATA *pNewBlob )
{
    PDFSBLOB_DATA BlobStructure = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    PBYTE NextBufOffset;

    ULONG TotalSize = sizeof(DFSBLOB_DATA) + 
                      BlobName->Length + sizeof(WCHAR) +
                      BlobSize;

    BlobStructure = (PDFSBLOB_DATA) AllocateShashData( TotalSize );

    if (BlobStructure != NULL)
    {
        RtlZeroMemory(BlobStructure, sizeof(DFSBLOB_DATA));
        NextBufOffset = (PBYTE)(BlobStructure + 1);

        BlobStructure->Header.RefCount = 1;
        BlobStructure->Header.pvKey = &BlobStructure->BlobName;
        BlobStructure->Header.pData = (PVOID)BlobStructure;

        BlobStructure->SequenceNumber = m_CurrentSequenceNumber;        
        BlobStructure->BlobName.Length = BlobName->Length;
        BlobStructure->BlobName.MaximumLength = BlobName->Length + sizeof(WCHAR);
        BlobStructure->BlobName.Buffer = (WCHAR *) (NextBufOffset);

        NextBufOffset = (PBYTE)((ULONG_PTR)(NextBufOffset) + 
                                BlobName->Length + 
                                sizeof(WCHAR));

        if (BlobName->Length != 0)
        {
            RtlCopyMemory(BlobStructure->BlobName.Buffer, 
                          BlobName->Buffer, 
                          BlobName->Length);
        }
        BlobStructure->BlobName.Buffer[BlobName->Length/sizeof(WCHAR)] = UNICODE_NULL;


        BlobStructure->Size = BlobSize;    
        BlobStructure->pBlob = (PBYTE)(NextBufOffset);
        RtlCopyMemory(BlobStructure->pBlob, pBlobBuffer, BlobSize);
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    *pNewBlob = BlobStructure;

    return Status;
}

DFSSTATUS
DfsADBlobCache::StoreBlobInCache(PUNICODE_STRING BlobName, 
                                 PBYTE pBlobBuffer, 
                                 ULONG BlobSize)
{
    PDFSBLOB_DATA BlobStructure = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status;

    DFS_TRACE_LOW( ADBLOB, "cache %p: Storing Blob %wZ in cache, size %x\n",
                   this, BlobName, BlobSize );

    Status = CreateBlob( BlobName,
                         pBlobBuffer,
                         BlobSize,
                         &BlobStructure );

    if (Status == ERROR_SUCCESS)
    {
        if (IsEmptyString(BlobStructure->BlobName.Buffer))
        {
            ReleaseRootBlob();
            m_pRootBlob = BlobStructure;
        }
        else
        {
            NtStatus = SHashInsertKey(m_pTable, 
                                      BlobStructure, 
                                      &BlobStructure->BlobName, 
                                      SHASH_REPLACE_IFFOUND);
            if(NtStatus == STATUS_SUCCESS)
            {
                InterlockedDecrement(&BlobStructure->Header.RefCount);
            }
            else
            {
                DeallocateShashData( BlobStructure );
                Status = RtlNtStatusToDosError(NtStatus);
            }
        }
    }
    DFS_TRACE_LOW( ADBLOB, "cache %p: storing Blob %wZ done, status %x\n",
                   this, BlobName, Status);

    return Status;
}




DFSSTATUS
DfsADBlobCache::WriteBlobToAd()
{
    DFSSTATUS Status = STATUS_SUCCESS;
    PVOID pHandle = NULL;

    DFS_TRACE_LOW(ADBLOB, "cache %p: writing blob to ad\n", this);
    Status = GetADObject (&pHandle);

    if(Status == ERROR_SUCCESS)
    {
        Status = CacheFlush(pHandle);

        ReleaseADObject( pHandle );
    }
    DFS_TRACE_ERROR_LOW(Status, ADBLOB, "cache %p: writing blob to ad, status %x\n",
                        this, Status);

    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   GetSubBlob
//
//  Arguments:    
//
//   PUNICODE_STRING pBlobName (name of the sub blob)
//   BYTE **ppBlobBuffer - holds pointer to sub blob buffer
//   PULONG  pBlobSize -  holds the blob size
//   BYTE **ppBuffer -  holds the pointer to the main blob buffer 
//   PULONG pSize  - holds size of the main blob stream.
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the next stream in the main blob, and
//               returns all the information necessary to unravel the
//               sub blob held within the main blob,
//               It adjusts the main blob buffer and size appropriately
//               to point to the next stream or sub-blob within the main
//               blob.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobCache::GetSubBlob(
    PUNICODE_STRING pName,
    BYTE **ppBlobBuffer,
    PULONG  pBlobSize,
    BYTE **ppBuffer,
    PULONG pSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // ppbuffer is the main blob, and it is point to a stream at this
    // point
    // the first part is the name of the sub-blob.
    //
    Status = PackGetString( pName, (PVOID *) ppBuffer, pSize );
    if (Status == ERROR_SUCCESS)
    {
        //
        // now get the size of the sub blob.
        //
        Status = PackGetULong( pBlobSize, (PVOID *) ppBuffer, pSize );
        if (Status == ERROR_SUCCESS)
        {
            //
            // At this point the main blob is point to the sub-blob itself.
            // So copy the pointer of the main blob so we can return it
            // as the sub blob.
            //
            *ppBlobBuffer = *ppBuffer;

            //
            // update the main blob pointer to point to the next stream
            // in the blob.

            *ppBuffer = (BYTE *)*ppBuffer + *pBlobSize;
            *pSize -= *pBlobSize;
        }
    }

    return Status;
}


DFSSTATUS
DfsADBlobCache::GetNamedBlob(PUNICODE_STRING pBlobName,
                             PDFSBLOB_DATA *pBlobStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (IsEmptyString(pBlobName->Buffer))
    {
        *pBlobStructure = AcquireRootBlob();
        if (*pBlobStructure == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
    }
    else
    {
        NtStatus = SHashGetDataFromTable(m_pTable, 
                                         (void *)pBlobName,
                                         (void **) pBlobStructure);
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


DFSSTATUS
DfsADBlobCache::SetNamedBlob(PDFSBLOB_DATA pBlobStructure)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (IsEmptyString(pBlobStructure->BlobName.Buffer))
    {
        ReleaseRootBlob();
        m_pRootBlob = pBlobStructure;
        AcquireRootBlob();
    }
    else
    {
        NtStatus = SHashInsertKey(m_pTable, 
                                  pBlobStructure, 
                                  &pBlobStructure->BlobName, 
                                  SHASH_REPLACE_IFFOUND);

        Status = RtlNtStatusToDosError(NtStatus);
    }
    
    return Status;
}

DFSSTATUS
DfsADBlobCache::RemoveNamedBlob(PUNICODE_STRING pBlobName )
{
    NTSTATUS NtStatus;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (IsEmptyString(pBlobName->Buffer))
    {
        if (m_pRootBlob == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
        ReleaseRootBlob();
    }
    else
    {
        NtStatus = SHashRemoveKey(m_pTable, 
                                  pBlobName,
                                  NULL );

        Status = RtlNtStatusToDosError(NtStatus);
    }
    
    return Status;

}

DWORD 
PackBlobEnumerator( PSHASH_HEADER	pEntry,
                    void*  pContext ) 
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pBlobName = (PUNICODE_STRING) pEntry->pvKey;
    PDFSBLOB_DATA pBlobStructure = (PDFSBLOB_DATA) pEntry;
    PPACKBLOB_ENUMCTX pEnumCtx = (PPACKBLOB_ENUMCTX) pContext;

    Status = AddStreamToBlob( pBlobName,
                              pBlobStructure->pBlob,
                              pBlobStructure->Size,
                              &pEnumCtx->pBuffer,
                              &pEnumCtx->Size );

    
    pEnumCtx->NumItems++;
    pEnumCtx->CurrentSize += (pBlobName->Length + 
                              sizeof(USHORT) +
                              sizeof(ULONG) +
                              pBlobStructure->Size);



    return Status;

}
//
// skeleton of pack blob. 
// The buffer is passed in. The length is passed in.
// If the information does not fit the buffer, return required length.
// Required for API implementation.
//
//
DFSSTATUS
DfsADBlobCache::PackBlob(
    BYTE *pBuffer,
    PULONG pLength,
    PULONG TotalBlobBytes )

{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BYTE *pUseBuffer = NULL;
    BYTE *pSavedBuffer = NULL;
    ULONG SavedBufferSize = 0;
    ULONG BufferSize = 0;
    PACKBLOB_ENUMCTX EnumCtx;
     
    pUseBuffer = pBuffer;
    BufferSize = *pLength;

    DFS_TRACE_LOW(ADBLOB, "BlobCache %p: packing blob\n", this);
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are setting it to 0.
    //
    Status = PackSetULong( 0, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status == ERROR_SUCCESS)
    {

        //save the place where we should write back the number of objects
        pSavedBuffer = pUseBuffer;
        SavedBufferSize = BufferSize;
        //
        // the next argument is the number of objects in the blob.
        // set 0 until we find how many blobs there are
        //
        Status = PackSetULong(0, (PVOID *) &pUseBuffer, &BufferSize);
    }
    if (Status == ERROR_SUCCESS) 
    {

        EnumCtx.pBuffer = pUseBuffer;
        EnumCtx.Size = BufferSize;
        EnumCtx.NumItems = 0;
        EnumCtx.CurrentSize = sizeof(ULONG);
    }

    if (Status == ERROR_SUCCESS)
    {
        if (m_pRootBlob != NULL)
        {
            PDFSBLOB_DATA pRootBlob;
            UNICODE_STRING RootMetadataName;

            RtlInitUnicodeString(&RootMetadataName, ADBlobMetaDataNamePrefix);

            Status = CreateBlob( &RootMetadataName,
                                 m_pRootBlob->pBlob,
                                 m_pRootBlob->Size,
                                 &pRootBlob);

            if (Status == ERROR_SUCCESS)
            {
                Status = PackBlobEnumerator( (SHASH_HEADER *)pRootBlob, (PVOID) &EnumCtx);    

                DeallocateShashData(pRootBlob);
            }
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        if (m_pBlob != NULL)
        {
            Status = PackBlobEnumerator( (SHASH_HEADER *) m_pBlob, (PVOID) &EnumCtx);    
        }
    }

    
    if (Status == ERROR_SUCCESS)
    {
        NtStatus = ShashEnumerateItems(m_pTable, 
                                       PackBlobEnumerator, 
                                       &EnumCtx);

        //dfsdev: make sure that shash enumerate retuns NTSTATUS.
        // it does not appear to do so... I think it is the packblobenumerator
        // that is returning a non-ntstatus. Till we fix it dont convert err

        //    Status = RtlNtStatusToDosError(NtStatus);
        Status = NtStatus;
    }

    if (Status == ERROR_SUCCESS)
    {

        if (EnumCtx.NumItems > 0)
        {
            Status = PackSetULong(EnumCtx.NumItems, 
                                  (PVOID *) &pSavedBuffer, 
                                  &SavedBufferSize);

            EnumCtx.CurrentSize += sizeof(ULONG);
        }

        *TotalBlobBytes = EnumCtx.CurrentSize;
    }

    //*TotalBlobBytes =  (ULONG) (EnumCtx.pBuffer -  pBuffer);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "BlobCache %p, PackBlob status %x\n",
                         this, Status);
    return Status;
}


PDFSBLOB_DATA
DfsADBlobCache::FindFirstBlob(PDFSBLOB_ITER pIter)
{
    PDFSBLOB_DATA pBlob = NULL;

    pIter->Started = FALSE;
    pIter->RootReferenced = AcquireRootBlob();

    return pIter->RootReferenced;
}


PDFSBLOB_DATA
DfsADBlobCache::FindNextBlob(PDFSBLOB_ITER pIter)
{
    PDFSBLOB_DATA pBlob = NULL;

    if (pIter->Started == FALSE)
    {
        pIter->Started = TRUE;
        pBlob = (PDFSBLOB_DATA) SHashStartEnumerate(&pIter->Iter, m_pTable);
    }
    else
    {
        pBlob = (PDFSBLOB_DATA) SHashNextEnumerate(&pIter->Iter, m_pTable);
    }

    return pBlob;
}



void
DfsADBlobCache::FindCloseBlob(PDFSBLOB_ITER pIter)
{

    if (pIter->RootReferenced)
    {
        ReleaseBlobReference(pIter->RootReferenced);
        pIter->RootReferenced = NULL;
    }
    if (pIter->Started)
    {
        SHashFinishEnumerate(&pIter->Iter, m_pTable);    
        pIter->Started = FALSE;
    }
}


DFSSTATUS
AddStreamToBlob(PUNICODE_STRING BlobName,
                BYTE *pBlobBuffer,
                ULONG  BlobSize,
                BYTE ** pUseBuffer,
                ULONG *BufferSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = PackSetString(BlobName, (PVOID *) pUseBuffer, BufferSize);
    if(Status == ERROR_SUCCESS)
    {
         Status = PackSetULong(BlobSize, (PVOID *) pUseBuffer, BufferSize);
         if(Status == ERROR_SUCCESS)
         {
             if ( *BufferSize >= BlobSize )
             {
                 RtlCopyMemory((*pUseBuffer), pBlobBuffer, BlobSize);

                 *pUseBuffer = (BYTE *)((ULONG_PTR)*pUseBuffer + BlobSize);
                 *BufferSize -= BlobSize;
             }
             else
             {
                 Status = ERROR_BUFFER_OVERFLOW;
             }
         }

    }
    if (Status == ERROR_INVALID_DATA)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }

    return Status;
}

PVOID
AllocateShashData(ULONG Size )
{
    PVOID RetValue = NULL;

    if (Size)
    {
        RetValue = (PVOID) new BYTE[Size];
    }
    return RetValue;
}

VOID
DeallocateShashData(PVOID pPointer )
{
    if(pPointer)
    {
        delete [] (PBYTE)pPointer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobstore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobStore.cxx
//
//  Contents:   the AD Blob DFS Store class, this contains the registry
//              specific functionality.
//
//  Classes:    DfsADBlobStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 9 2001   Rohanp - Added ADSI specific code
//
//-----------------------------------------------------------------------------


#include "DfsADBlobStore.hxx"
#include "DfsADBlobRootFolder.hxx"
#include "DfsFilterApi.hxx"
#include "dfsmisc.h"
#include "lmdfs.h"
#include "shlwapi.h"
#include "align.h"
#include "dfserror.hxx"
#include "DomainControllerSupport.hxx"
#include "DelegationControl.hxx"
#include "dfsadsiapi.hxx"


#include "DfsAdBlobStore.tmh"

//+----------------------------------------------------------------------------
//
//  Class:      DfsADBlobStore.
//
//  Synopsis:   This class inherits the basic DfsStore, and extends it
//              to include the blob DS specific functionality.
//
//-----------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  Name - the namespace of interest.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a domain based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::StoreRecognizer(
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY ADBlobDfsKey;
    BOOLEAN MachineContacted = FALSE;

    DFSSTATUS NewDfsStatus = ERROR_SUCCESS;
    //
    // Make sure the namespace is the name of a machine. FT based
    // dfs exist only on domains.
    //

    if (IsEmptyString(Name) == FALSE) 
    {
        Status = DfsIsThisADomainName( Name );
    }


    DFS_TRACE_LOW(REFERRAL_SERVER, "DfsADBlob:StoreRecognizer, %ws Is domain Status %x\n", 
                  Name, Status);

    
    //
    // Now, open the registry key where we store all the DFS root
    // information.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = GetNewADBlobRegistryKey( Name,
                                          FALSE, // write permission not required
                                          &MachineContacted,
                                          &ADBlobDfsKey );

        if (Status == ERROR_SUCCESS)
        {
            Status = StoreRecognizeNewDfs( Name,
                                           ADBlobDfsKey );

            RegCloseKey( ADBlobDfsKey );
        }
    }

    //
    // Need to refine the return status further: success should mean
    // machine is not domain dfs or we have read the domain dfs data 
    // correctly.
    //
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "DfsADBlob:StoreRecognizer, Status %x\n",
                        Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateNewRootFolder -  creates a new root folder
//
//  Arguments:
//    LPWSTR DfsNameContextString - name context string
//    LPWSTR RootRegKeyName -  the registry holding the information about this root.
//    PUNICODE_STRING pLogicalShare - the logical share name.
//    PUNICODE_STRING pPhysicalShare - the physical share name.
//    DfsRootFolder **ppRoot - root to return.
//
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine creates a new root folder, and
//               adds it to the list of known roots.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::CreateNewRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pNewRoot;

    //
    // Create a new instance of the RegistryRootFolder class.
    // This gives us a reference RootFolder.
    //
    pNewRoot = new DfsADBlobRootFolder( DfsNameContextString,
                                        RootRegKeyName,
                                        pLogicalShare,
                                        pPhysicalShare,
                                        this,
                                        &Status );
    if ( NULL == pNewRoot )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 

    if ( ERROR_SUCCESS == Status )
    {
        //
        // AddRootFolder to the list of known roots. AddRootFolder
        // is responsible to acquire any reference on the root folder
        // if it is storing a reference to this root.

        if ( ERROR_SUCCESS == Status) 
        {
            Status = AddRootFolder( pNewRoot, NewRootList );
        }


        if ( ERROR_SUCCESS == Status )
        {
            //
            // We were successful, return the reference root. The reference
            // that we are returning is the create reference on the new root.
            //
            *ppRoot = pNewRoot;
        }
        else 
        {
            pNewRoot->ReleaseReference();
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "ADBlobStore::CreateNewRootFolder. New root %p, for share %wZ (%wZ) on machine %ws. Status %x\n", 
                        pNewRoot, pLogicalShare, pPhysicalShare, DfsNameContextString, Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetMetadataReplicaBlob - gets the replica blob
//
//  Arguments:  DfsMetadataHandle -  the handle to the root
//              MetadataName - name of the metadata
//              ppBlob - the replica blob
//              pBlobSize-size of blob
//              pLastModifiedTime - time the blob was last modified
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the replica blob and returns a copy
//
//--------------------------------------------------------------------------
DFSSTATUS      
DfsADBlobStore::GetMetadataReplicaBlob(
    IN DFS_METADATA_HANDLE DfsMetadataHandle,
    IN LPWSTR MetadataName,
    OUT PVOID *ppBlob,
    OUT PULONG pBlobSize,
    OUT PFILETIME pLastModifiedTime )
{

    UNREFERENCED_PARAMETER(pLastModifiedTime); // dfsdev: investigate.

    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pMetadata;
    ULONG MetadataSize;
    PVOID pUseBlob;
    ULONG UseBlobSize;
    PVOID pReplicaBlob = NULL;
    ULONG ReplicaBlobSize;

    PDFS_NAME_INFORMATION pNameInformation = NULL;

    Status = GetMetadata( (PVOID)DfsMetadataHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          NULL);

    if (Status == ERROR_SUCCESS)
    {
        pNameInformation = new DFS_NAME_INFORMATION;
        if(pNameInformation != NULL)
        {
            RtlZeroMemory (pNameInformation, sizeof(DFS_NAME_INFORMATION));
            pUseBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
            UseBlobSize = MetadataSize;
            Status = PackGetNameInformation( pNameInformation,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                PackGetULong( &ReplicaBlobSize,
                              &pUseBlob,
                              &UseBlobSize );

                pReplicaBlob = (PVOID) new unsigned char [ReplicaBlobSize];
                if(pReplicaBlob != NULL)
                {
                    RtlCopyMemory(pReplicaBlob, pUseBlob, ReplicaBlobSize);
                }
                else 
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            delete pNameInformation;
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        ReleaseMetadata( (PVOID)DfsMetadataHandle, pMetadata );
    }

    //
    // If we were successful, return the read in information. Otherwise free
    // up the allocate resources and return error.
    //
    if ( Status == STATUS_SUCCESS )
    {
        *ppBlob = pReplicaBlob;
        *pBlobSize = ReplicaBlobSize;
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMetadataNameBlob - gets the name blob
//
//  Arguments:  DfsMetadataHandle -  the handle to the root
//              MetadataName - name of the metadata
//              ppBlob - the name blob
//              pBlobSize-size of blob
//              pLastModifiedTime - time the blob was last modified
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the name blob and returns a copy.
//
//--------------------------------------------------------------------------

DFSSTATUS      
DfsADBlobStore::GetMetadataNameBlob(
    IN DFS_METADATA_HANDLE DfsMetadataHandle,
    IN LPWSTR MetadataName,
    OUT PVOID *ppBlob,
    OUT PULONG pBlobSize,
    OUT PFILETIME pLastModifiedTime )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pMetadata;
    ULONG MetadataSize;
    PVOID pBlob, pUseBlob;
    ULONG UseBlobSize, NameBlobSize;
    PVOID pNameBlob = NULL;

    PDFS_NAME_INFORMATION pNameInformation = NULL;

    Status = GetMetadata( (PVOID)DfsMetadataHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          pLastModifiedTime);

    if (Status == ERROR_SUCCESS)
    {
        pNameInformation = new DFS_NAME_INFORMATION;
        if(pNameInformation != NULL)
        {

            RtlZeroMemory (pNameInformation, sizeof(DFS_NAME_INFORMATION));
            pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
            pUseBlob = pBlob;
            UseBlobSize = MetadataSize;
            Status = PackGetNameInformation( pNameInformation,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                NameBlobSize = MetadataSize - UseBlobSize;
                pNameBlob = (PVOID) new unsigned char [NameBlobSize ];
                if(pNameBlob != NULL)
                {
                    RtlCopyMemory(pNameBlob, pBlob, NameBlobSize );
                }
                else 
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            delete pNameInformation;
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        ReleaseMetadata( (PVOID)DfsMetadataHandle, pMetadata );
    }

    //
    // If we were successful, return the read in information. Otherwise free
    // up the allocate resources and return error.
    //
    if ( Status == STATUS_SUCCESS )
    {
        *ppBlob = pNameBlob;
        *pBlobSize = NameBlobSize;
    }
    return Status;
}
        
DFSSTATUS
DfsADBlobStore::SetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pNameBlob,
    ULONG NameBlobSize )
{
    PVOID pReplicaBlob, pNewBlob;
    ULONG ReplicaBlobSize, NewBlobSize;
    FILETIME LastTime;
    DFSSTATUS Status;

    Status = GetMetadataReplicaBlob( RootHandle,
                                     MetadataName,
                                     &pReplicaBlob,
                                     &ReplicaBlobSize,
                                     &LastTime );
                                  
    if (Status == ERROR_SUCCESS)
    {
        NewBlobSize = NameBlobSize + ReplicaBlobSize;
        Status = AllocateMetadataBlob( &pNewBlob,
                                       NewBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            RtlCopyMemory(pNewBlob, pNameBlob, NameBlobSize);
            RtlCopyMemory((PVOID)((ULONG_PTR)pNewBlob + NameBlobSize),
                          pReplicaBlob, 
                          ReplicaBlobSize );
            
            Status = SetMetadata( (PVOID)RootHandle,
                                  MetadataName,
                                  NULL,
                                  pNewBlob,
                                  NewBlobSize );

            ReleaseMetadataBlob( pNewBlob );
        }

        ReleaseMetadataReplicaBlob(pReplicaBlob, ReplicaBlobSize );
    }

    return Status;
}


DFSSTATUS
DfsADBlobStore::SetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pReplicaBlob,
    ULONG ReplicaBlobSize )
{
    PVOID pNameBlob, pRemainingBlob;
    ULONG NameBlobSize,  RemainingBlobSize;
    PVOID pOldBlob, pNewBlob, pUseBlob;
    ULONG OldBlobSize, NewBlobSize, UseBlobSize;
    ULONG OldReplicaBlobSize;
    PVOID pMetadata;
    ULONG MetadataSize;

    DFSSTATUS Status;
    DFS_NAME_INFORMATION NameInformation;

    Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          NULL); // dfsdev: investigate

    if (Status == ERROR_SUCCESS)
    {
        pNameBlob = pOldBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
        OldBlobSize = MetadataSize;
        Status = PackGetNameInformation( &NameInformation,
                                         &pOldBlob,
                                         &OldBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            NameBlobSize = MetadataSize - OldBlobSize;

            Status = PackGetULong( &OldReplicaBlobSize,
                                   &pOldBlob,
                                   &OldBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                pRemainingBlob = (PVOID)((ULONG_PTR)pOldBlob + OldReplicaBlobSize);
                RemainingBlobSize = OldBlobSize - OldReplicaBlobSize;
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            NewBlobSize = NameBlobSize + sizeof(ULONG) + ReplicaBlobSize + RemainingBlobSize;
            Status =  AllocateMetadataBlob( &pNewBlob, NewBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                pUseBlob = pNewBlob;
                UseBlobSize = NewBlobSize;

                RtlCopyMemory(pUseBlob, pNameBlob, NameBlobSize);
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + NameBlobSize);
                UseBlobSize -= NameBlobSize;

                PackSetULong( ReplicaBlobSize,
                              &pUseBlob,
                              &UseBlobSize );

                RtlCopyMemory(pUseBlob, pReplicaBlob, ReplicaBlobSize );
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                UseBlobSize -= ReplicaBlobSize;

                RtlCopyMemory(pUseBlob, pRemainingBlob, RemainingBlobSize );

            
                Status = SetMetadata( (PVOID)RootHandle,
                                      MetadataName,
                                      NULL,
                                      pNewBlob,
                                      NewBlobSize );

                ReleaseMetadataBlob( pNewBlob );
            }
            else 
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        ReleaseMetadata((PVOID)RootHandle, pMetadata );
    }

    return Status;
}





INIT_ADBLOB_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiADBlobDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsADBlobStore::PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status = STATUS_SUCCESS;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_AD_BLOB;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetNameInformation - Packs the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to pack.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the name info
//               error status otherwise.
//
//
//  Description: This routine takes the passedin name information and
//               stores it in the binary stream passed in.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsADBlobStore::PackSetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    if ((pDfsNameInfo->Type & 0x80) == 0x80)
    {
        pDfsNameInfo->State &= ~DFS_VOLUME_FLAVORS;
    }

    //
    // Store the DfsNameInfo in the stream first.
    //
    Status = PackSetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );


    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeNameInformation - Gets the size of the name info.
//
//  Arguments:  pDfsNameInfo - info to size.
//
//  Returns:    Status
//               ULONG - size needed
//
//  Description: This routine gets us the size of the binary stream
//               required to pack the passed in name info.
//
//--------------------------------------------------------------------------
ULONG
DfsADBlobStore::PackSizeNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo )
{
    ULONG Size;

    Size = PackSizeInformation( (ULONG_PTR)pDfsNameInfo,
                                 &MiADBlobDfsIdProperty );

    return Size;
}

DFSSTATUS      
DfsADBlobStore::GetMetadata (
    IN  PVOID DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PVOID *ppData,
    OUT ULONG *pDataSize,
    OUT PFILETIME pLastModifiedTime)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pDataBuffer = NULL;
    DfsADBlobCache * pBlobCache = NULL;
    ULONG DataSize = 0;
    ULONG DataType = 0;
    PDFSBLOB_DATA BlobData;
    UNICODE_STRING BlobName;

    UNREFERENCED_PARAMETER (RegistryValueNameString);
    UNREFERENCED_PARAMETER (pLastModifiedTime);

    RtlInitUnicodeString( &BlobName, RelativeName );

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->GetNamedBlob(&BlobName, &BlobData);
    if(Status == STATUS_SUCCESS)
    {
       *ppData = (PVOID) BlobData;
       *pDataSize = BlobData->Size;
    }

    return Status;

}

DFSSTATUS
DfsADBlobStore::SetMetadata (
    IN PVOID DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    UNICODE_STRING BlobName;
    BOOLEAN ImpersonationDisabled = FALSE;

    UNREFERENCED_PARAMETER (RegistryValueNameString);


    //
    // check for return status and do something?
    //
    DfsDisableRpcImpersonation(&ImpersonationDisabled);

    RtlInitUnicodeString( &BlobName, RelativeName );

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->StoreBlobInCache(&BlobName, (PBYTE) pData, DataSize);

    if (Status == ERROR_SUCCESS)
    {
        Status = pBlobCache->WriteBlobToAd();
    }
    DFS_TRACE_LOW(REFERRAL_SERVER, "Done Setting metadata for %p %ws, Status %x\n", pBlobCache, RelativeName, Status);

    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }



    return Status;
}


DFSSTATUS
DfsADBlobStore::RemoveMetadata (
    IN PVOID DfsMetadataKey,
    IN LPWSTR RelativeName)

{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    UNICODE_STRING BlobName;
    BOOLEAN ImpersonationDisabled = FALSE;

    DfsDisableRpcImpersonation(&ImpersonationDisabled);


    RtlInitUnicodeString( &BlobName, RelativeName );

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->RemoveNamedBlob( &BlobName );

    if (Status == ERROR_SUCCESS)
    {
        Status = pBlobCache->WriteBlobToAd();
    }

    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }


    return Status;
}



DFSSTATUS
DfsADBlobStore::CreateADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DCName,
    LPWSTR PhysicalShare,
    LPWSTR LogicalShare,
    LPWSTR Comment,
    BOOLEAN NewRoot,
    PDFSM_ROOT_LIST *ppRootList )
{    
    DFSSTATUS Status= ERROR_SUCCESS;
    HKEY DfsKey = NULL;
    DfsRootFolder *pRootFolder = NULL;
    DfsRootFolder *pLookupRootFolder = NULL;
    BOOLEAN IsLastRootTarget = FALSE;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    UNICODE_STRING DfsPhysicalShare;
    BOOLEAN ImpersonationDisabled = FALSE;

    UNREFERENCED_PARAMETER (ppRootList); //dfsdev investigate.

    //
    // dfsdev: disallow differing logical/physical share names.
    // check for proper error returns.
    //

#if 0
    if (_wcsicmp(LogicalShare, PhysicalShare) != 0)
    {
        return ERROR_INVALID_NAME;
    }
#endif

    DFS_TRACE_LOW( REFERRAL_SERVER, "Dfs ad blob store, create root %ws\n", LogicalShare);

    RtlInitUnicodeString( &DfsShare, LogicalShare );
    RtlInitUnicodeString( &DfsPhysicalShare, PhysicalShare );
    RtlInitUnicodeString( &DfsMachine, MachineName );

    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pLookupRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "Dfs ad blob store, looup root %p, status %x\n", pRootFolder, Status);
    if (Status == ERROR_SUCCESS)
    {
        pLookupRootFolder->ReleaseReference();

        //
        // DO NOT CHANGE this error code. A change here will affect the client
        // The client will tear down the root if we return any other
        // error code here, so be very careful.
        //
        return ERROR_ALREADY_EXISTS;
    }


    Status = GetNewADBlobRegistryKey( MachineName,
                                      TRUE, // write permission required
                                      NULL,
                                      &DfsKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = SetupADBlobRootKeyInformation( DfsKey,
                                                LogicalShare,
                                                PhysicalShare );

        //RegCloseKey( DfsKey );
    }


    DfsDisableRpcImpersonation(&ImpersonationDisabled);
    if (Status == ERROR_SUCCESS)
    {
        Status = GetRootFolder( NULL,
                                LogicalShare,
                                &DfsShare,
                                &DfsPhysicalShare,
                                &pRootFolder );

        if (Status == ERROR_SUCCESS)
        {
            Status = AddRootToBlob( pRootFolder,
                                    NewRoot,    //NewRoot,
                                    LogicalShare,
                                    PhysicalShare,
                                    Comment );
            if ((Status == ERROR_FILE_EXISTS) ||
                (Status == ERROR_ALREADY_EXISTS))
            {
                Status = ERROR_SUCCESS;
            }


            if (Status == ERROR_SUCCESS)
            {
                Status = DfsUpdateRootRemoteServerName( LogicalShare,
                                                        DCName,
                                                        MachineName,
                                                        PhysicalShare,
                                                        TRUE );
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = pRootFolder->AcquireRootShareDirectory();

                if (Status != ERROR_SUCCESS)
                {
                    //
                    // make a best effort to remove ourselves
                    // dont care about status return, thoug
                    // we may want to log it. 
                    //dfsdev: add logging.
                    //
                    //RemoveRootFolder(pRootFolder, 
                                     //TRUE); // permanent removal
                }

                //
                // now mark the root folder as synchronized:
                // this is true since this root is empty.
                //
                if (Status == ERROR_SUCCESS)
                {
                    pRootFolder->SetRootFolderSynchronized();
                }
            }
            //pRootFolder->ReleaseReference();
        }

        DFSLOG("Add AD Blob Root, adding root folder status %x\n", Status);
    }


    if (Status != ERROR_SUCCESS)
    {
        DFSSTATUS LocalStatus = ERROR_SUCCESS;

        //
        // dfsdev: undo all the blob stuff, and finally remove our registry 
        // entry

        LocalStatus = RegDeleteKey( DfsKey,
                                    LogicalShare );


        LocalStatus = DfsUpdateRootRemoteServerName( LogicalShare,
                                                     DCName,
                                                     MachineName,
                                                     PhysicalShare,
                                                     FALSE );
           
        if(pRootFolder)
        {

            LocalStatus = RemoveRootFromBlob( pRootFolder,
                                              MachineName,
                                              PhysicalShare,
                                              &IsLastRootTarget );


            if(IsLastRootTarget)
            {
                DfsDeleteDfsRootObject( DCName,
                                        LogicalShare);
            }


            RemoveRootFolder(pRootFolder, TRUE);
        }
    }

    if(pRootFolder)
    {
        pRootFolder->ReleaseReference();
    }

    if(DfsKey != NULL)
    {
        RegCloseKey( DfsKey );
    }

    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }

    //
    // At this point we CANNOT return ERROR_ALREADY_EXISTS. The client
    // will use this code to mean that the DS object it creates is not
    // cleaned up.
    //
    // Does not mean that ERROR_NOT_SUPPORTED is a better error, but till
    // we find one, this should suffice.
    //
    if (Status == ERROR_ALREADY_EXISTS)
    {
        Status = ERROR_NOT_SUPPORTED;
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs ad blob store, create root %ws, status %x\n", LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsADBlobStore::DeleteADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DCName,
    LPWSTR PhysicalShare,
    LPWSTR LogicalShare,
    PDFSM_ROOT_LIST *ppRootList )
{
    UNREFERENCED_PARAMETER(ppRootList); //dfsdev: investigate.
    DFSSTATUS Status;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    DfsRootFolder *pRootFolder = NULL;
    BOOLEAN IsLastRootTarget = FALSE;

    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %ws\n", LogicalShare);

    RtlInitUnicodeString( &DfsMachine, MachineName );
    RtlInitUnicodeString( &DfsShare, LogicalShare );

    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );


    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %ws, Lookup root %p, Status %x\n", LogicalShare, pRootFolder, Status);

    if (Status == ERROR_SUCCESS)
    {
        Status = pRootFolder->AcquireRootLock();
        if (Status == ERROR_SUCCESS)
        {
            pRootFolder->SetRootFolderDeleteInProgress();
            pRootFolder->ReleaseRootLock();
        }
    }


    if (Status == ERROR_SUCCESS)
    {

        Status = pRootFolder->RootApiRequestPrologue(TRUE);

        if (Status == ERROR_SUCCESS)
        {

            HKEY FtDfsKey;
        
            Status = GetNewADBlobRegistryKey( MachineName,
                                              TRUE, // write permission required
                                              NULL,
                                              &FtDfsKey );

            if (Status == ERROR_SUCCESS) 
            {
                Status = RegDeleteKey( FtDfsKey,
                                       LogicalShare );
                RegCloseKey( FtDfsKey );
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            BOOLEAN ImpersonationDisabled = FALSE;
            
            DfsDisableRpcImpersonation(&ImpersonationDisabled);

            Status = DfsUpdateRootRemoteServerName( LogicalShare,
                                                    DCName,
                                                    MachineName,
                                                    PhysicalShare,
                                                    FALSE );


            //
            // Update blob and write it back.
            //


            if (Status == ERROR_SUCCESS)
            {
                Status = RemoveRootFromBlob( pRootFolder,
                                             MachineName,
                                             PhysicalShare,
                                             &IsLastRootTarget );

                if (Status == ERROR_SUCCESS)
                {
#if 0
                    if (IsLastRootTarget == TRUE)
                    {
                        DFSSTATUS DeleteObjectStatus;

                        DeleteObjectStatus = DfsDeleteDfsRootObject( DCName,
                                                                     LogicalShare);


                        DFS_TRACE_ERROR_LOW(DeleteObjectStatus, REFERRAL_SERVER,
                                            "Object %ws deleted from AD: status %x\n",
                                            LogicalShare, DeleteObjectStatus);
                    }
#endif
                }
            }

            pRootFolder->RootApiRequestEpilogue(TRUE,
                                                Status );
            if (ImpersonationDisabled)
            {
                DfsReEnableRpcImpersonation();
            }

        }

        NTSTATUS DeleteStatus;

        //
        // we are done with this folder. Release the root share directory
        // we had acquired earlier on: this will tell the driver we are 
        // no longer interested on the specified drive.
        //
        DeleteStatus = RemoveRootFolder( pRootFolder, TRUE );
        DFS_TRACE_ERROR_HIGH( DeleteStatus, REFERRAL_SERVER, "remove root folder status %x\n", DeleteStatus);

        DeleteStatus = pRootFolder->ReleaseRootShareDirectory();
        DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "release root dir status %x\n", DeleteStatus);

        pRootFolder->ReleaseReference();


        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_HIGH(REFERRAL_SERVER, "remove root folder failed. Trying to recreate root \n");

            CreateADBlobRoot(MachineName,
                                 DCName,
                                 PhysicalShare,
                                 LogicalShare,
                                 L"",
                                 TRUE,
                                 ppRootList );
        }
    }

    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %p (%ws), Status %x\n", 
                  pRootFolder, LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsADBlobStore::RemoveChild(
    DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName )
{

    return RemoveMetadata( (PVOID)DfsHandle, ChildName );
}




//+-------------------------------------------------------------------------
//
//  Function:   AddChild - Add a child to the metadata.
//
//  Arguments:  
//    DfsMetadataHandle - the Metadata key for the root.
//    PUNICODE_STRING pLinkLogicalName - the logical name of the child
//    LPWSTR ReplicaServer - the first target server for this link.
//    LPWSTR ReplicaPath - the target path for this link
//    LPWSTR Comment  - the comment to be associated with this link.
//    LPWSTR pMetadataName - the metadata name for the child, returned..
//
//
//  Returns:    Status: 
//
//  Description: This routine adds a child to the Root metadata. It packs
//               the link name into the name information. If the replica
//               information exists, it packs that into the replica info.
//               It then saves the name and replica streams under the
//               Childkey.
//               NOTE: this function does not require that the link
//               have atleast one replica. Any such requirements
//               should be enforced by the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::AddChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    IN PUNICODE_STRING pMetadataName )
{
    DFSSTATUS Status;
    PVOID pNameBlob, pReplicaBlob, pNewBlob, pUseBlob;
    ULONG NameBlobSize, ReplicaBlobSize, NewBlobSize, UseBlobSize;

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                                   &pReplicaBlob,
                                                   &ReplicaBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            NewBlobSize = NameBlobSize + sizeof(ULONG) + ReplicaBlobSize +
                            3 * sizeof(ULONG);


            Status = AllocateMetadataBlob( &pNewBlob,
                                           NewBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                pUseBlob = pNewBlob;
                UseBlobSize = NewBlobSize;

                RtlCopyMemory( pUseBlob, pNameBlob, NameBlobSize );
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + NameBlobSize);
                UseBlobSize -= NameBlobSize;

                PackSetULong( ReplicaBlobSize,
                              &pUseBlob,
                              &UseBlobSize );
                RtlCopyMemory(pUseBlob, pReplicaBlob, ReplicaBlobSize );
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                UseBlobSize -= ReplicaBlobSize;

                PackSetULong( 4,
                              &pUseBlob,
                              &UseBlobSize );
                PackSetULong( 0,
                              &pUseBlob,
                              &UseBlobSize );
                PackSetULong( pNameInfo->Timeout,
                              &pUseBlob,
                              &UseBlobSize );

                Status = SetMetadata( (PVOID)DfsHandle,
                                      pMetadataName->Buffer,
                                      NULL,
                                      pNewBlob,
                                      NewBlobSize );

                ReleaseMetadataBlob( pNewBlob );
            }

            ReleaseMetadataReplicaBlob( pReplicaBlob, ReplicaBlobSize );
        }
        ReleaseMetadataNameBlob( pNameBlob, NameBlobSize );
    }

    return Status;
}



DFSSTATUS
DfsADBlobStore::EnumerateApiLinks(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    LPDWORD pEntriesToRead,
    LPDWORD pResumeHandle,
    PLONG pSizeRequired )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN OverFlow;
    LONG HeaderSize;
    LONG EntriesRead = 0;
    LONG EntriesToRead = *pEntriesToRead;
    LONG SizeRequired = 0;
    LONG EntryCount = 0;
    ULONG ChildNum = 0;
    LPBYTE pLinkBuffer = NULL;
    LONG LinkBufferSize = 0;

    LPBYTE CurrentBuffer, NewBuffer;
    LONG SizeRemaining;

    ULONG_PTR SizeDiff;

    DfsADBlobCache * pBlobCache = NULL;
    PDFSBLOB_DATA pBlobData = NULL;
    DFSBOB_ITER Iter;

    LONG CurrentCount;

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsHandle );

    OverFlow = FALSE;
    HeaderSize = DfsApiSizeLevelHeader( Level );

    SizeRequired = ROUND_UP_COUNT(EntriesToRead * HeaderSize, ALIGN_QUAD);

    if (EntriesToRead * HeaderSize < BufferSize )
    {
        CurrentBuffer = (LPBYTE)((ULONG_PTR)pBuffer + EntriesToRead * HeaderSize);
        SizeRemaining = BufferSize - EntriesToRead * HeaderSize;
    }
    else 
    {
        CurrentBuffer = pBuffer;
        SizeRemaining = 0;
        OverFlow = TRUE;
    }

    EntryCount = *pResumeHandle;
    CurrentCount = 0;

    pBlobData = pBlobCache->FindFirstBlob(&Iter);
    while ((pBlobData != NULL) &&
           CurrentCount < EntryCount )
    {
        CurrentCount++;
        pBlobData = pBlobCache->FindNextBlob(&Iter);
    }


    if (pBlobData == NULL)
    {
        Status = ERROR_NO_MORE_ITEMS;
    }
    while ((pBlobData != NULL) &&
           (Status == ERROR_SUCCESS))
    {
        //
        // For each child, get the child name.
        //

        if (EntriesToRead && EntriesRead >= EntriesToRead)
        {
            break;
        }

        Status = GetStoreApiInformationBuffer( DfsHandle,
                                               pRootName,
                                               pBlobData->BlobName.Buffer,
                                               Level,
                                               &pLinkBuffer,
                                               &LinkBufferSize );

        if (Status == ERROR_SUCCESS)
        {
            SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);
                
            if (OverFlow == FALSE) 
            {
                DFSSTATUS PackStatus;
                PackStatus = PackageEnumerationInfo( Level,
                                                     EntriesRead,
                                                     pLinkBuffer,
                                                     pBuffer,
                                                     &CurrentBuffer,
                                                     &SizeRemaining );
                if (PackStatus == ERROR_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                }
                NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                SizeDiff = (NewBuffer - CurrentBuffer);
                if ((LONG)SizeDiff > SizeRemaining)
                {
                    SizeRemaining = 0;
                }
                else 
                {
                    SizeRemaining -= (LONG)SizeDiff;
                }
                CurrentBuffer = NewBuffer;
            }

            ReleaseStoreApiInformationBuffer( pLinkBuffer );
            EntryCount++;
            EntriesRead++;
        }
        pBlobData = pBlobCache->FindNextBlob(&Iter);
        if (pBlobData == NULL)
        {
            Status = ERROR_NO_MORE_ITEMS;
        }
    } while (Status == ERROR_SUCCESS);


    pBlobCache->FindCloseBlob(&Iter);

    *pSizeRequired = SizeRequired;

    if (Status == ERROR_NO_MORE_ITEMS) 
    {
        if (EntriesRead) 
        {
            if (OverFlow) 
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                Status = ERROR_SUCCESS;
            }
        }

    }
    else if (OverFlow)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        *pResumeHandle = EntryCount;
        *pEntriesToRead = EntriesRead;
    }

    return Status;
}

DFSSTATUS
DfsADBlobStore::AddRootToBlob( 
    DfsRootFolder *pRootFolder,
    BOOLEAN   NewRoot,
    LPWSTR    LogicalShare,
    LPWSTR    ShareName,
    LPWSTR    Comment )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status;

    UNICODE_STRING MachineName, DomainName;
    UNICODE_STRING LogicalName, RootMetadataName;

    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;
    UUID NewUid;
    LPWSTR RootMetadataNameString = NULL;

    RtlInitUnicodeString( &RootMetadataName, RootMetadataNameString);
    Status = UuidCreate(&NewUid);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }


    Status = DfsGetMachineName(&MachineName);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = pRootFolder->GetMetadataHandle( &RootHandle );

    if (Status == ERROR_SUCCESS)
    {
        if (NewRoot == FALSE) 
        {
            pRootFolder->Synchronize();        
            if ( RootEntryExists((PVOID)RootHandle) != ERROR_SUCCESS )
            {
                NewRoot = TRUE;
            }
        }
        
        if (NewRoot)
        {
            Status = DfsGetDomainName(&DomainName);
            if (Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodePathString( &LogicalName,
                                                     1, // 1 leading path seperator.
                                                     DomainName.Buffer,
                                                     LogicalShare);
                if (Status == ERROR_SUCCESS)
                {
                    StoreInitializeNameInformation( &NameInfo,
                                                    &LogicalName,
                                                    &NewUid,
                                                    Comment );

                    NameInfo.Type |= 0x80; // dfsdev: hack. mark it for root correctly.
                    StoreInitializeReplicaInformation( &ReplicaListInfo,
                                                       &ReplicaInfo,
                                                       MachineName.Buffer,
                                                       ShareName );

                    Status = AddChild( RootHandle,
                                       &NameInfo,
                                       &ReplicaListInfo,
                                       &RootMetadataName );
                    
                    DfsFreeUnicodeString( &LogicalName);
                }
                DfsFreeUnicodeString( &DomainName );
            }
        }
        else
        {
            Status = pRootFolder->Synchronize();
            if (Status == ERROR_SUCCESS)
            {
                Status = AddChildReplica( RootHandle,
                                          RootMetadataNameString,
                                          MachineName.Buffer,
                                          ShareName );
            }
        }
        pRootFolder->ReleaseMetadataHandle( RootHandle );
    }

    DfsFreeUnicodeString(&MachineName );
    return Status;
}


DFSSTATUS
DfsADBlobStore::RemoveRootFromBlob(
    DfsRootFolder *pRootFolder,
    LPWSTR    MachineName,
    LPWSTR    ShareName,
    PBOOLEAN  pLastRoot )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status;
    BOOLEAN LastRoot = FALSE;
    DfsADBlobCache *pBlobCache;
    LPWSTR RootMetadataNameString = NULL;

    Status = pRootFolder->GetMetadataHandle( &RootHandle );
    if (Status == ERROR_SUCCESS)
    {
        Status = RemoveChildReplica( RootHandle,
                                     RootMetadataNameString,
                                     MachineName,
                                     ShareName,
                                     &LastRoot );

        if (Status == ERROR_SUCCESS)
        {
            pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( RootHandle);
            pBlobCache->InvalidateCache();
            if (LastRoot)
            {
                pBlobCache->WriteBlobToAd();

            }
        }
        pRootFolder->ReleaseMetadataHandle( RootHandle );
    }

    if (Status == ERROR_SUCCESS)
    {
        *pLastRoot = LastRoot;
    }

    return Status;
}




DFSSTATUS
DfsADBlobStore::GetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_NAME_INFORMATION *ppInfo )
{
    PVOID pBlob, pUseBlob;
    ULONG UseBlobSize, ReplicaBlobSize, RecoveryBlobSize;
    FILETIME BlobModifiedTime;
    PVOID pMetadata;
    ULONG MetadataSize;
    PDFS_NAME_INFORMATION pNewInfo = NULL;
    DFSSTATUS Status;


    Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          &BlobModifiedTime);

    if (Status == ERROR_SUCCESS)
    {

        pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;

        pNewInfo = new DFS_NAME_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_NAME_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = MetadataSize;

            Status = PackGetNameInformation( pNewInfo,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &ReplicaBlobSize,
                                       &pUseBlob,
                                       &UseBlobSize );
                if (Status == ERROR_SUCCESS)
                {
                    pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                    UseBlobSize -= ReplicaBlobSize;
                }
            }
    
            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &RecoveryBlobSize,
                                       &pUseBlob,
                                       &UseBlobSize );
                if (Status == ERROR_SUCCESS)
                {
                    pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + RecoveryBlobSize);
                    UseBlobSize -= RecoveryBlobSize;
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &pNewInfo->Timeout,
                                       &pUseBlob,
                                       &UseBlobSize );
            }


            if (Status != ERROR_SUCCESS)
            {
                ReleaseMetadata( (PVOID)RootHandle, pMetadata );
                delete pNewInfo;
            }
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pMetadata;
        pNewInfo->DataSize = MetadataSize;
        *ppInfo = pNewInfo;
    }

    return Status;
}
        
VOID
DfsADBlobStore::ReleaseMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    ReleaseMetadata( (PVOID)RootHandle, pNameInfo->pData );
    delete [] pNameInfo;
}


DFSSTATUS
DfsADBlobStore::SetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    PVOID pBlob, pUseBlob, pNewBlob;
    ULONG UseBlobSize, NewBlobSize;
    ULONG ReplicaBlobSize, RecoveryBlobSize;
    DFSSTATUS Status;
    PVOID pNameBlob;
    ULONG NameBlobSize;
    FILETIME BlobModifiedTime;
    PVOID pMetadata;
    ULONG MetadataSize;

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );


    Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          &BlobModifiedTime);

    if (Status == ERROR_SUCCESS)
    {
        DFS_NAME_INFORMATION NameInformation;
        pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
        pUseBlob = pBlob;
        UseBlobSize = MetadataSize;
        Status = PackGetNameInformation( &NameInformation,
                                         &pUseBlob,
                                         &UseBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            NewBlobSize = NameBlobSize + UseBlobSize;
            Status = AllocateMetadataBlob( &pNewBlob,
                                           NewBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                RtlCopyMemory(pNewBlob, pNameBlob, NameBlobSize);
                RtlCopyMemory((PVOID)((ULONG_PTR)pNewBlob + NameBlobSize),
                              pUseBlob, 
                              UseBlobSize );



                pUseBlob = (PVOID)((ULONG_PTR)pNewBlob + NameBlobSize);

                if (Status == ERROR_SUCCESS)
                {
                    Status = PackGetULong( &ReplicaBlobSize,
                                           &pUseBlob,
                                           &UseBlobSize );
                    if (Status == ERROR_SUCCESS)
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                        UseBlobSize -= ReplicaBlobSize;
                    }
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = PackGetULong( &RecoveryBlobSize,
                                           &pUseBlob,
                                           &UseBlobSize );
                    if (Status == ERROR_SUCCESS)
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + RecoveryBlobSize);
                        UseBlobSize -= RecoveryBlobSize;
                    }
                }
                if (Status == ERROR_SUCCESS)
                {
                    Status = PackSetULong( pNameInfo->Timeout,
                                           &pUseBlob,
                                           &UseBlobSize );
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( (PVOID)RootHandle,
                                          MetadataName,
                                          NULL,
                                          pNewBlob,
                                          NewBlobSize );
                }
                ReleaseMetadataBlob( pNewBlob );
            }
        }
        ReleaseMetadata( (PVOID)RootHandle, pMetadata );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadsiapi.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsAdsiApi.cxx
//
//  Contents:   Contains APIs to communicate with the DS
//
//  Classes:    none.
//
//  History:    March. 13 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include "DfsAdsiAPi.hxx"
#include "DfsError.hxx"
#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "lm.h"
#include "lmdfs.h"
//
// dfsdev: comment this properly.
//
LPWSTR RootDseString=L"LDAP://RootDSE";

//
// dfscreatedn take a pathstring and fills it with the information
// necessary for the path to be used as a Distinguished Name.
// It starts the string with LDAP://, follows that with a DCName
// if supplied, and then adds the array of CNNames passed in
// one after the other , each one followed by a ,
// the final outcome is something like:
// LDAP://ntdev-dc-01/CN=Dfs-Configuration, CN=System, Dc=Ntdev, etc
//
//dfsdev: this function should take a path len and return overflow
// if we overrun the buffer!!!

VOID
DfsCreateDN(
    LPWSTR PathString,
    LPWSTR DCName,
    LPWSTR *CNNames )
{
    LPWSTR *InArray = CNNames;
    LPWSTR CNName;

    wcscpy(PathString, L"LDAP://");

    //
    // if the dc name is specified, we want to go to a specific dc
    // add that in.
    //
    if ((DCName != NULL) && (wcslen(DCName) > 0))
    {
        wcscat(PathString, DCName);
        wcscat(PathString, L"/");
    }
    //
    // Now treat the CNNames as an array of LPWSTR and add each one of
    // the lpwstr to our path.
    //
    if (CNNames != NULL)
    {
        while ((CNName = *InArray++) != NULL) 
        {
            wcscat(PathString, CNName);
            if (*InArray != NULL)
            {
                wcscat(PathString,L",");
            }
        }
    }

    return NOTHING;
}

DFSSTATUS
DfsGenerateDfsAdNameContext(
    PUNICODE_STRING pString )

{
    IADs *pRootDseObject;
    HRESULT HResult;
    VARIANT VarDSRoot;
    DFSSTATUS Status;

    HResult = ADsGetObject( RootDseString,
                            IID_IADs,
                            (void **)&pRootDseObject );
    if (SUCCEEDED(HResult))
    {
        VariantInit( &VarDSRoot );
        // Get the Directory Object on the root DSE, to get to the server configuration
        HResult = pRootDseObject->Get(L"defaultNamingContext",&VarDSRoot);

        if (SUCCEEDED(HResult))
        {
            DfsCreateUnicodeStringFromString( pString,
                                              (LPWSTR)V_BSTR(&VarDSRoot) );
        }

        VariantClear(&VarDSRoot);

        pRootDseObject->Release();
    }
    Status = DfsGetErrorFromHr(HResult);

    return Status;
}


#if 0
HRESULT
DfsGetADObject(
    LPWSTR DCName,
    REFIID Id,
    LPWSTR ObjectName,
    PVOID *ppObject )
{
    HRESULT HResult;
    LPOLESTR PathString;
    VARIANT VarDSRoot;
    LPWSTR CNNames[4];
    LPWSTR DCNameToUse;
    UNICODE_STRING GotDCName; 
    IADs *pRootDseObject;
    ULONG Index;
    PathString = new OLECHAR[MAX_PATH];
    if (PathString == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString( &GotDCName, NULL );

    DCNameToUse = DCName;
    if (IsEmptyString(DCNameToUse))
    {
        DfsGetBlobDCName( &GotDCName );
        DCNameToUse = GotDCName.Buffer;
    }

    CNNames[0] = RootDseString;
    CNNames[1] = NULL;

    DfsCreateDN( PathString,
                 DCNameToUse,
                 CNNames );

    //
    // contact the rootdse (local domain), and get the default
    // naming context. Use that to get to the dfs configuration
    // object.
    //
    HResult = ADsGetObject(PathString,
                           IID_IADs,
                           (void**)&pRootDseObject);

    if (SUCCEEDED(HResult))
    {
        VariantInit( &VarDSRoot );
        // Get the Directory Object on the root DSE, to get to the server configuration
        HResult = pRootDseObject->Get(L"defaultNamingContext",&VarDSRoot);
        if (SUCCEEDED(HResult))
        {
            Index = 0;
            if (ObjectName != NULL)
            {
                CNNames[Index++] = ObjectName;
            }
            CNNames[Index++] = DFS_AD_CONFIG_DATA;
            CNNames[Index++] = (LPWSTR)V_BSTR(&VarDSRoot);
            CNNames[Index++] = NULL;

            DfsCreateDN( PathString, DCNameToUse, CNNames);

            VariantClear(&VarDSRoot);
        }
        pRootDseObject->Release();
    }

    //
    // open dfs configuration container for enumeration.
    //
    if (SUCCEEDED(HResult))
    {
        HResult = ADsGetObject(PathString,
                               Id,
                               ppObject );
    }

    //
    // Since we initialized DCName with empty string, it is benign
    // to call this, even if we did not call GetBlobDCName above.
    //
    DfsReleaseBlobDCName( &GotDCName );
    
    delete [] PathString;
    return HResult;

}

#endif


HRESULT
DfsGetADObject(
    LPWSTR DCName,
    REFIID Id,
    LPWSTR ObjectName,
    PVOID *ppObject )
{
    HRESULT HResult;
    LPOLESTR PathString;
    LPWSTR CNNames[4];
    LPWSTR DCNameToUse;
    UNICODE_STRING GotDCName; 
    ULONG Index;
    PathString = new OLECHAR[MAX_PATH];
    if (PathString == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString( &GotDCName, NULL );

    DCNameToUse = DCName;
    if (IsEmptyString(DCNameToUse))
    {
        DfsGetBlobDCName( &GotDCName );
        DCNameToUse = GotDCName.Buffer;
    }

    Index = 0;
    if (ObjectName != NULL)
    {
        CNNames[Index++] = ObjectName;
    }
    CNNames[Index++] = DFS_AD_CONFIG_DATA;
    CNNames[Index++] = DfsGetDfsAdNameContextString();
    CNNames[Index++] = NULL;

    DfsCreateDN( PathString, DCNameToUse, CNNames);

    //
    // open dfs configuration container for enumeration.
    //


    HResult = ADsOpenObject(PathString,
                            NULL,
                            NULL,
                            ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND | ADS_SERVER_BIND,
                            Id,
                            ppObject );

    //
    // Since we initialized DCName with empty string, it is benign
    // to call this, even if we did not call GetBlobDCName above.
    //
    DfsReleaseBlobDCName( &GotDCName );
    
    delete [] PathString;
    return HResult;

}


//
//  Given the root share name, get the root object.
//

DFSSTATUS
DfsGetDfsRootADObject(
    LPWSTR DCName,
    LPWSTR RootName,
    IADs **ppRootObject )
{
    HRESULT HResult;
    LPWSTR RootCNName;
    DFSSTATUS Status = ERROR_SUCCESS;
    RootCNName = new WCHAR[MAX_PATH];
    if (RootCNName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(RootCNName, L"CN=");
    wcscat(RootCNName, RootName);

    HResult = DfsGetADObject( DCName,
                              IID_IADs,
                              RootCNName,
                              (PVOID *)ppRootObject );

    delete [] RootCNName;

    Status = DfsGetErrorFromHr(HResult);
    return Status;
}

DFSSTATUS
PackRootName(
    LPWSTR Name,
    PDFS_INFO_200 pDfsInfo200,
    PULONG pBufferSize,
    PULONG pTotalSize )
{
    ULONG BufferLen = (wcslen(Name) + 1) * sizeof(WCHAR);
    ULONG NeedSize = sizeof(DFS_INFO_200) + BufferLen;
    DFSSTATUS Status = ERROR_SUCCESS;

    *pTotalSize += NeedSize;
    if (*pBufferSize >= NeedSize)
    {
        ULONG_PTR pStringBuffer;

        pStringBuffer = (ULONG_PTR)(pDfsInfo200) + *pBufferSize - BufferLen;
        wcscpy( (LPWSTR)pStringBuffer, &Name[3] );
        pDfsInfo200->FtDfsName = (LPWSTR)pStringBuffer;
        *pBufferSize -= NeedSize;
    }
    else
    {
        Status = ERROR_BUFFER_OVERFLOW;
        *pBufferSize = 0;
    }

    return Status;
}



HRESULT
DfsGetDfsConfigurationObject(
    LPWSTR DCName,
    IADsContainer **ppDfsConfiguration )
{
    HRESULT HResult;

    HResult = DfsGetADObject( DCName,
                              IID_IADsContainer,
                              NULL,
                              (PVOID *)ppDfsConfiguration );

    return HResult;
}


DFSSTATUS
DfsDeleteDfsRootObject(
    LPWSTR DCName,
    LPWSTR RootName )
{
    BSTR ObjectName, ObjectClass;
    DFSSTATUS Status;
    HRESULT HResult;
    IADsContainer *pDfsConfiguration;
    IADs *pRootObject;

    Status = DfsGetDfsRootADObject( DCName,
                                    RootName,
                                    &pRootObject );

    if (Status == ERROR_SUCCESS)
    {
        HResult = DfsGetDfsConfigurationObject( DCName,
                                                &pDfsConfiguration );


        if (SUCCEEDED(HResult))
        {

            HResult = pRootObject->get_Name(&ObjectName);
            if (SUCCEEDED(HResult))
            {
                HResult = pRootObject->get_Class(&ObjectClass);

                if (SUCCEEDED(HResult))
                {
                    HResult = pDfsConfiguration->Delete( ObjectClass,
                                                         ObjectName );

                    SysFreeString(ObjectClass);
                }
                SysFreeString(ObjectName);
            }
            pDfsConfiguration->Release();
        }

        pRootObject->Release();
        Status = DfsGetErrorFromHr(HResult);
    }

    return Status;
}



DFSSTATUS
DfsEnumerateDfsADRoots(
    LPWSTR DCName,
    PULONG_PTR pBuffer,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{
    HRESULT HResult;
    IADsContainer *pDfsConfiguration;
    IEnumVARIANT *pEnum;

    ULONG TotalSize = 0;
    ULONG TotalEntries = 0;
    PDFS_INFO_200 pDfsInfo200;
    ULONG BufferSize = *pBufferSize;
    DFSSTATUS Status;

    //
    // point the dfsinfo200 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo200 = (PDFS_INFO_200)*pBuffer;


    HResult = DfsGetDfsConfigurationObject( DCName,
                                            &pDfsConfiguration );

    if (SUCCEEDED(HResult))
    {
        HResult = ADsBuildEnumerator( pDfsConfiguration,
                                          &pEnum );

        if (SUCCEEDED(HResult))
        {
            VARIANT Variant;
            ULONG Fetched;
            BSTR BString;
            IADs *pRootObject;

            VariantInit(&Variant);
            while ((HResult = ADsEnumerateNext(pEnum, 
                                               1,
                                               &Variant,
                                               &Fetched)) == S_OK)
            {
                IDispatch *pDisp;


                pDisp  = V_DISPATCH(&Variant);
                pDisp->QueryInterface(IID_IADs, (void **)&pRootObject);
                pDisp->Release();

                pRootObject->get_Name(&BString);

                Status = PackRootName( BString, pDfsInfo200, &BufferSize, &TotalSize );

                pRootObject->Release();

                // DfsDev: investigate. this causes an av.
                // VariantClear(&Variant);

                if (Status == ERROR_SUCCESS)
                {
                    TotalEntries++;
                    pDfsInfo200++;
                }
            }

            if (HResult == S_FALSE)
            {
                HResult = S_OK;
            }

            ADsFreeEnumerator( pEnum );
        }

        pDfsConfiguration->Release();
    }

    Status = DfsGetErrorFromHr(HResult);

    if (Status == ERROR_SUCCESS)
    {
        *pSizeRequired = TotalSize;
        if (TotalSize > *pBufferSize)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else
        {
            *pEntriesRead = TotalEntries;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfserror.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsError.cxx
//
//  Contents:   Converts HRESULT to DFSSTATUS   
//
//  Classes:    none.
//
//  History:    April. 09 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include <activeds.h>
#include <dfsheader.h>
#include <dfsError.hxx>
      
 
/////////////////////////////////////////////
//
// Error message specific to ADSI 
//
////////////////////////////////////////////

DFSSTATUS
DfsGetADSIError( HRESULT hr )
{
	DFSSTATUS status = ERROR_SUCCESS;

	switch(hr)
	{
    case S_OK:
        status = ERROR_SUCCESS;
        break;

    case E_ADS_BAD_PATHNAME:
    case E_ADS_INVALID_DOMAIN_OBJECT:
    case E_ADS_INVALID_USER_OBJECT:
    case E_ADS_INVALID_COMPUTER_OBJECT:
        status = ERROR_BAD_NET_NAME;
        break;

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_BAD_PARAMETER:
    case E_ADS_PROPERTY_NOT_SET:
		status = ERROR_INVALID_PARAMETER;
		break;
		
	case E_NOTIMPL:
		status = ERROR_CALL_NOT_IMPLEMENTED;
		break;

    case E_NOINTERFACE:
    case E_ADS_PROPERTY_NOT_FOUND:
        status = ERROR_NOT_FOUND;
        break;

    case E_ADS_PROPERTY_NOT_SUPPORTED:
        status = ERROR_NOT_SUPPORTED;
        break;
		
    case E_POINTER:
        status = ERROR_INVALID_HANDLE;
        break;

    case E_ADS_SCHEMA_VIOLATION:
        status = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case E_ABORT:
        status = ERROR_OPERATION_ABORTED;
        break;

    case E_FAIL:
    case E_UNEXPECTED:
	default:
		status = ERROR_BAD_COMMAND;
        //ASSERT(FALSE);
		break;
	}
	return status;
}


DFSSTATUS 
DfsGetErrorFromHr( HRESULT hr )
{
    DFSSTATUS Status = ERROR_SUCCESS;
  
    if(hr == S_OK)
    {
        Status = ERROR_SUCCESS;
    }
    else if ( hr & 0x00005000) // standard ADSI Errors 
    {
        Status = DfsGetADSIError(hr);
    }
    else if ( HRESULT_FACILITY(hr)==FACILITY_WIN32 )
    {
        Status = hr & 0x0000FFFF;
    }
    else 
    {
        Status = ERROR_BAD_COMMAND;
    }
 
     return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsdownlevel.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsDownLevel.cxx
//
//  Contents:   Contains APIs to communicate old DFS Servers   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <smbtypes.h>

#pragma warning(disable: 4200) //nonstandard extension used: zero-sized array in struct/union (line 1085
#include <smbtrans.h>
#pragma warning(default: 4200)

#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <dfsfilterapi.hxx>


#define PATH_DELIMITER L'\\'


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV1ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V1 referrals
//
//--------------------------------------------------------------------------
ULONG
DfspGetV1ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;

    size = sizeof( RESP_GET_DFS_REFERRAL );
    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
        size += sizeof(DFS_REFERRAL_V1) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );

    }

    return( size );

}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV2ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V2 referrals
//
//--------------------------------------------------------------------------

ULONG
DfspGetV2ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;
    UNICODE_STRING PrefixTail;

    size = sizeof( RESP_GET_DFS_REFERRAL );
    PrefixTail.Length = 0;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {

        size += sizeof(DFS_REFERRAL_V2) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );    
    }


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    return( size );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V3 referrals
//
//--------------------------------------------------------------------------

ULONG
DfspGetV3ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;
    UNICODE_STRING PrefixTail;

    size = sizeof( RESP_GET_DFS_REFERRAL );

    PrefixTail.Length = 0;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {

        size += sizeof(DFS_REFERRAL_V3) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    return( size );
}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV1Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V1 referrals to output buffer
//
//--------------------------------------------------------------------------

VOID
DfspGetV1Referral(
    IN PREFERRAL_HEADER pRefHeader,
    OUT PRESP_GET_DFS_REFERRAL Ref)
{
    PDFS_REFERRAL_V1 pv1 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;

    Ref->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    Ref->ReferralServers = 1;

    Ref->StorageServers = 1;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
    pv1 = &Ref->Referrals[0].v1;

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
         pv1->VersionNumber = 1;

         pv1->Size = (USHORT)( sizeof(DFS_REFERRAL_V1) +
                        pRep->ReplicaNameLength +
                            sizeof(UNICODE_NULL));

         pv1->ServerType = 1;

         RtlCopyMemory(
            pv1->ShareName,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

         pv1->ShareName[ pRep->ReplicaNameLength / sizeof(WCHAR) ] =
            UNICODE_NULL;

         pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
         pv1 = (PDFS_REFERRAL_V1) ( ((PCHAR) pv1) + pv1->Size );

    }

}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV2Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V2 referrals to output buffer
//
//--------------------------------------------------------------------------

NTSTATUS
DfspGetV2Referral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V2 pv2 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize =
        sizeof (RESP_GET_DFS_REFERRAL) +
          pRefHeader->LinkNameLength +
             sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) +
               pRefHeader->LinkNameLength +
                  sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    pRef->ReferralServers = 1;

    pRef->StorageServers = 1;

    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    pv2 = &pRef->Referrals[0].v2;

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv2[ pRef->NumberOfReferrals ];

    RtlCopyMemory(
       pNextAddress,
       pRefHeader->LinkName,
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

   *pNextAddress++ = UNICODE_NULL;

   //
   // Copy the 8.3 volume prefix into the response buffer after the
   // dfsPath
   //

   pAlternatePath = pNextAddress;

   RtlCopyMemory(
      pNextAddress,
      pRefHeader->LinkName,      
      pRefHeader->LinkNameLength);

   pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

   *pNextAddress++ = UNICODE_NULL;


   pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
   for (i = 0; i < pRef->NumberOfReferrals; i++) 
   {
       pv2->VersionNumber = 2;
       pv2->Size = sizeof(DFS_REFERRAL_V2);
       pv2->ServerType =    1;
       pv2->Proximity = 0;
       pv2->TimeToLive = pRefHeader->Timeout;
       pv2->DfsPathOffset = (USHORT) (((PCHAR) pDfsPath) - ((PCHAR) pv2));
       pv2->DfsAlternatePathOffset =
               (USHORT) (((PCHAR) pAlternatePath) - ((PCHAR) pv2));
       pv2->NetworkAddressOffset =
               (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv2));

       RtlCopyMemory(
               pNextAddress,
               pRep->ReplicaName,
               pRep->ReplicaNameLength);
       pNextAddress[ pRep->ReplicaNameLength/sizeof(WCHAR) ] = UNICODE_NULL;
       pNextAddress += pRep->ReplicaNameLength/sizeof(WCHAR) + 1;
       pv2++;
       pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
   }


   *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3DomainReferral 
//
//  Arguments:  dfsdev: fill this in.
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetV3DomainReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = sizeof (RESP_GET_DFS_REFERRAL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //
    pRef->StorageServers = 0;
    pRef->ReferralServers = 0;
    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;
    pRef->PathConsumed = 0;

    pv3 = &pRef->Referrals[0].v3;

    //
    // double unicode_null at end.
    //
    CumulativeSize += sizeof(UNICODE_NULL);

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) + sizeof(UNICODE_PATH_SEP) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {
        pv3->VersionNumber = 3;
        pv3->Size = sizeof(DFS_REFERRAL_V3);
        pv3->ServerType = 0;
        pv3->StripPath = 0;                        // for now
        pv3->NameListReferral = 1;
        pv3->TimeToLive = 3600 * 6; // 6 housr. dfsdev investigate.

        pv3->SpecialNameOffset =
            (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

        pv3->NumberOfExpandedNames = 0;
        pv3->ExpandedNameOffset = 0;

        //
        // dfsdev investigate.
        //
        *pNextAddress++ = UNICODE_PATH_SEP;
        RtlMoveMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pv3++;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetV3DCReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = sizeof (RESP_GET_DFS_REFERRAL) +
        pRefHeader->LinkNameLength + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //
    pRef->StorageServers = 0;
    pRef->ReferralServers = 0;
    pRef->NumberOfReferrals = 1;
    pRef->PathConsumed = 0;

    pv3 = &pRef->Referrals[0].v3;

    //
    // double unicode_null at end.
    //
    CumulativeSize += sizeof(UNICODE_NULL);

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
        CurrentSize = sizeof(UNICODE_PATH_SEP) +
                      pRep->ReplicaNameLength + 
                      sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    // Adjust the number of referrals accordingly.
    pv3->NumberOfExpandedNames = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pv3->NumberOfExpandedNames == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];
    pv3->SpecialNameOffset =
        (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

    *pNextAddress++ = UNICODE_PATH_SEP;
    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);
    *pNextAddress++ = UNICODE_NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);


    pv3->VersionNumber = 3;
    pv3->Size = sizeof(DFS_REFERRAL_V3);
    pv3->ServerType = 0;
    pv3->StripPath = 0;                        // for now
    pv3->NameListReferral = 1;
    pv3->TimeToLive = 3600 * 6; // 6 housr. dfsdev investigate.


    pv3->ExpandedNameOffset = 
        (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

    for (i = 0; i < pv3->NumberOfExpandedNames; i++) {

        //
        // dfsdev: this is very confusing.. 
        // investigate. Each of the referrals we call keep
        // adding a unicode path sep.
        //
#if 0
        *pNextAddress++ = UNICODE_PATH_SEP;
#endif
        RtlCopyMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength );

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



DFSSTATUS
DfsGetV3NormalReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize =
        sizeof (RESP_GET_DFS_REFERRAL) +
          pRefHeader->LinkNameLength +
             sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) +
               pRefHeader->LinkNameLength +
                  sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //
    pRef->StorageServers = 1;
    if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL)
    {
        pRef->ReferralServers = 1;
    }
    else
    {
        pRef->ReferralServers = 0;
    }

    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    pv3 = &pRef->Referrals[0].v3;

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];

    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

    *pNextAddress++ = UNICODE_NULL;

    //
    // Copy the 8.3 volume prefix into the response buffer after the
    // dfsPath
    //

    pAlternatePath = pNextAddress;

    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

    *pNextAddress++ = UNICODE_NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {
        pv3->VersionNumber = 3;
        pv3->Size = sizeof(DFS_REFERRAL_V3);

        //
        // The server type is important for the client. Set to 1 for
        // root referral, and 0 otherwise. It appears to keep the client
        // happy.
        // dfsdev: investigate further.
        //

        if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL)
        {
            pv3->ServerType = 1;
        }
        else {
            pv3->ServerType = 0;
        }

        pv3->StripPath = 0;                        // for now
        pv3->NameListReferral = 0;
        pv3->TimeToLive = pRefHeader->Timeout;
        pv3->DfsPathOffset = (USHORT) (((PCHAR) pDfsPath) - ((PCHAR) pv3));

        pv3->DfsAlternatePathOffset =
            (USHORT) (((PCHAR) pAlternatePath) - ((PCHAR) pv3));

        pv3->NetworkAddressOffset =
            (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

        RtlZeroMemory(
            &pv3->ServiceSiteGuid,
            sizeof (GUID));

        RtlMoveMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pv3++;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

NTSTATUS
DfspGetV3Referral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    
    //
    //The client could be asking for either the trusted domains referral
    // or for the list of DC for a domain or for a normal dfs referral
    // to a path.
    //
    if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_DOMAIN_REFERRAL)
    {
        Status = DfsGetV3DomainReferral( pRefHeader,
                                         BufferSize,
                                         pRef,
                                         ReferralSize );
    }
    else if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL)
    {
        Status = DfsGetV3DCReferral( pRefHeader,
                                     BufferSize,
                                     pRef,
                                     ReferralSize );

    }
    else 
    {
        Status = DfsGetV3NormalReferral( pRefHeader,
                                         BufferSize,
                                         pRef,
                                         ReferralSize );

    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   ProcessOldDfsServerRequest 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Converts new data to what the old DFS server expects
//
//--------------------------------------------------------------------------
DFSSTATUS ProcessOldDfsServerRequest(HANDLE hDriverHandle,
                                     PUMRX_USERMODE_WORKITEM ProtocolBuffer,
                                     PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest,
                                     REFERRAL_HEADER *pReferral, 
                                     ULONG *ReturnedDataSize)

{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Size = 0;
    ULONG SendSize = 0;
    ULONG MaxLevel = 0;
    DWORD BytesReturned = 0;
    PRESP_GET_DFS_REFERRAL pRef = NULL;
    PBYTE pSendBuffer = NULL;
    PUMRX_USERMODE_WORKITEM pSendWorkItem = NULL;

    //get the level
    MaxLevel = pGetReplicaRequest->RepInfo.MaxReferralLevel;

    //check if MaxLevel is legal
    switch (MaxLevel) 
    {
        case 1:
            Size = DfspGetV1ReferralSize(pReferral); 
            break;
        case 2:
            Size = DfspGetV2ReferralSize(pReferral); 
            break;
        case 3:    
            Size = DfspGetV3ReferralSize(pReferral); 
            break;
        default:
            ASSERT(FALSE && "Invalid MaxLevel");
            Status = ERROR_INVALID_PARAMETER;
            break;
    }


    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }    

    SendSize = UMR_ALIGN(pGetReplicaRequest->RepInfo.ClientBufferSize) + sizeof(UMRX_USERMODE_WORKITEM);
    pSendWorkItem = (PUMRX_USERMODE_WORKITEM) HeapAlloc(GetProcessHeap(), 0, SendSize);
    if(pSendWorkItem == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //get a pointer to the response buffer
    pSendBuffer = pSendWorkItem->WorkResponse.GetDfsReplicasResponse.Buffer;
    
    pRef = (PRESP_GET_DFS_REFERRAL) pSendBuffer;

    pRef->PathConsumed = (USHORT) pReferral->LinkNameLength;

    //
    // For level 1 referral, we fail if buffer is not big enough to
    // fit entire referral. For level 2 and 3, we try to fit as many
    // entries as possible into the refferal.
    if(MaxLevel == 1)
    {
        if(Size < pGetReplicaRequest->RepInfo.ClientBufferSize) 
        {
            DfspGetV1Referral(pReferral, pRef);
        }
        else
        {
            Status = ERROR_MORE_DATA;
        }
    }
    else if(MaxLevel == 2)
    {
        Status = DfspGetV2Referral(pReferral, pGetReplicaRequest->RepInfo.ClientBufferSize, pRef,&Size);
    }
    else
    {
        Status = DfspGetV3Referral(pReferral, pGetReplicaRequest->RepInfo.ClientBufferSize, pRef ,&Size);
    }

    if(Status == ERROR_SUCCESS)
    {

        //copy the original header
        pSendWorkItem->Header = ProtocolBuffer->Header;
        pSendWorkItem->Header.IoStatus.Status = Status;
        pSendWorkItem->Header.IoStatus.Information = 0;

        //return without waiting for a response
        pSendWorkItem->Header.ulFlags = UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE;

        //set the size of the data being returned
        pSendWorkItem->WorkResponse.GetDfsReplicasResponse.Length = Size;

        //finally send the data
        Status = DfsUserModeProcessPacket(hDriverHandle, 
                                          (PBYTE) pSendWorkItem,
                                          SendSize,
                                          NULL,
                                          0,
                                          &BytesReturned);
    }


    if(pSendWorkItem != NULL)
    {
        HeapFree (GetProcessHeap(), 0, (PVOID) pSendWorkItem);
    }

    *ReturnedDataSize = Size;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobRootFolder.cxx
//
//  Contents:   the Root DFS Folder class for ADBlob Store
//
//  Classes:    DfsADBlobRootFolder
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 14 2001  Rohanp - Modified to use ADSI code
//
//-----------------------------------------------------------------------------


#include "DfsADBlobRootFolder.hxx"
#include "DfsReplica.hxx"

#include "lmdfs.h"
#include "dfserror.hxx"
#include "dfsmisc.h"
#include "dfsadsiapi.hxx"
#include "domaincontrollersupport.hxx"
#include "DfsSynchronizeRoots.hxx"
#if !defined(DFS_STORAGE_STATE_MASTER)
#define DFS_STORAGE_STATE_MASTER   0x0010
#endif
#if !defined(DFS_STORAGE_STATE_STANDBY)
#define DFS_STORAGE_STATE_STANDBY  0x0020
#endif

//
// logging specific includes
//
#include "DfsADBlobRootFolder.tmh" 

//+----------------------------------------------------------------------------
//
//  Class:      DfsADBlobRootFolder
//
//  Synopsis:   This class implements The Dfs ADBlob root folder.
//
//-----------------------------------------------------------------------------




DFSSTATUS
GetBinaryFromVariant(VARIANT *ovData, BYTE ** ppBuf,
                     unsigned long * pcBufLen);

//+-------------------------------------------------------------------------
//
//  Function:   DfsADBlobRootFolder - constructor
//
//  Arguments:    NameContext -  the dfs name context
//                pLogicalShare -  the logical share
//                pParentStore -  the parent store for this root.
//                pStatus - the return status
//
//  Returns:    NONE
//
//  Description: This routine initializes a ADBlobRootFolder instance
//
//--------------------------------------------------------------------------

DfsADBlobRootFolder::DfsADBlobRootFolder(
    LPWSTR NameContext,
    LPWSTR pRootRegistryNameString,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsADBlobStore *pParentStore,
    DFSSTATUS *pStatus ) :  DfsRootFolder ( NameContext,
                                            pRootRegistryNameString,
                                            pLogicalShare,
                                            pPhysicalShare,
                                            DFS_OBJECT_TYPE_ADBLOB_ROOT_FOLDER,
                                            pStatus )
{

    _pStore = pParentStore;
    if (_pStore != NULL)
    {
        _pStore->AcquireReference();
    }

    *pStatus = ERROR_SUCCESS;

    //
    // If the namecontext that we are passed is an emptry string,
    // then we are dealing with the referral server running on the root
    // itself. We are required to ignore the name context for such
    // roots during lookups, so that aliasing works. (Aliasing is where
    // someone may access the root with an aliased machine name or ip
    // address)
    //
    if (IsEmptyString(NameContext) == TRUE)
    {
        SetIgnoreNameContext();
        _LocalCreate = TRUE;
    }


    _pBlobCache = new DfsADBlobCache(pStatus, GetLogicalShare());
    if ( _pBlobCache == NULL )
    {
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now we update our visible context, which is the dfs name context
    // seen by people when they do api calls.
    // For the ad blob root folder, this will be the domain name of this
    // machine.
    //

    if(*pStatus == STATUS_SUCCESS)
    {
        *pStatus = DfsGetDomainName( &_DfsVisibleContext );
    }

    DFS_TRACE_LOW(REFERRAL_SERVER, "Created new root folder,%p, cache %p, name %wZ\n",
                  this, _pBlobCache, GetLogicalShare());
}


//+-------------------------------------------------------------------------
//
//  Function:   Synchronize
//
//  Arguments:    None
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine synchronizes the children folders
//               of this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobRootFolder::Synchronize( )
{
    DFSSTATUS       Status = ERROR_SUCCESS;
    
    //
    // Read from the metadata store, and unravel the blob.
    // Update the ADBlobCache with the information of each individual
    // link, deleting old inof, adding new info, and/or modifying
    // existing information.
    //
    //
    // if we are in a standby mode, we dont synchronize, till we obtain 
    // ownership again.
    //

    DFS_TRACE_LOW(REFERRAL_SERVER, "Synchronize started on root %p (%wZ)\n", this, GetLogicalShare());

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (CheckRootFolderSkipSynchronize() == TRUE)
    {
        ReleaseRootLock();
        return ERROR_SUCCESS;
    }


    //
    // now acquire the root share directory. If this
    // fails, we continue our operation: we can continue
    // with synchonize and not create directories.
    // dfsdev:we need to post a eventlog or something when
    // we run into this.
    //
    DFSSTATUS RootStatus = AcquireRootShareDirectory();

    DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize Dfs: Root folder for %p, validate status %x\n",
                        this, RootStatus );


    if (GetMetadataBlobCache()->CacheRefresh())
    {
        Status = EnumerateBlobCacheAndCreateFolders( );

        if (Status == ERROR_SUCCESS)
        {
            SetRootFolderSynchronized();
        }
        else
        {
            ClearRootFolderSynchronized();
        }
    }

    ReleaseRootLock();

    DFS_TRACE_LOW(REFERRAL_SERVER, "Synchronize done on root %p, Status %x\n", this, Status);
    return Status;
}



DFSSTATUS
DfsADBlobRootFolder::EnumerateBlobCacheAndCreateFolders( )
{
    DFSSTATUS UpdateStatus;

    DFSSTATUS Status = STATUS_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    PDFSBLOB_DATA pBlobData = NULL;
    DFSBOB_ITER Iter;

    pBlobCache = GetMetadataBlobCache();

    pBlobData = pBlobCache->FindFirstBlob(&Iter);

    while (pBlobData) 
    {
        if (pBlobCache->IsStaleBlob(pBlobData))
        {
            DFSSTATUS RemoveStatus;

            RemoveStatus = RemoveLinkFolder( pBlobData->BlobName.Buffer );

            if (RemoveStatus == ERROR_SUCCESS)
            {
                RemoveStatus = pBlobCache->RemoveNamedBlob( &pBlobData->BlobName );
            }

            DFS_TRACE_ERROR_LOW(RemoveStatus, REFERRAL_SERVER, "Remove stale folder %ws, status %x\n",
                                pBlobData->BlobName.Buffer,
                                RemoveStatus );


        }
        else 
        {
            UpdateStatus = UpdateLinkInformation((DFS_METADATA_HANDLE) pBlobCache,
                                                 pBlobData->BlobName.Buffer);

            DFS_TRACE_ERROR_LOW(UpdateStatus, REFERRAL_SERVER,
                                "Root %p (%wZ) Ad Blob enumerate, update link returned %x for %wZ\n", 
                                this, GetLogicalShare(), UpdateStatus, &pBlobData->BlobName);

            if (UpdateStatus != ERROR_SUCCESS)
            {
                Status = UpdateStatus;
            }
        }

        pBlobData = pBlobCache->FindNextBlob(&Iter);

    }

    pBlobCache->FindCloseBlob(&Iter);

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER,
                        "Root %p (%wZ) Done with Enumerate blob and create folders, Status %x\n", 
                        this, GetLogicalShare(), Status);

    return Status;
}


DFSSTATUS
GetBinaryFromVariant(VARIANT *ovData, BYTE ** ppBuf,
                     unsigned long * pcBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;

     //Binary data is stored in the variant as an array of unsigned char
     if(ovData->vt == (VT_ARRAY|VT_UI1))  
     {
        //Retrieve size of array
        *pcBufLen = ovData->parray->rgsabound[0].cElements;

        *ppBuf = new BYTE[*pcBufLen]; //Allocate a buffer to store the data
        if(*ppBuf != NULL)
        {
            //Obtain safe pointer to the array
            SafeArrayAccessData(ovData->parray,&pArrayData);

            //Copy the bitmap into our buffer
            memcpy(*ppBuf, pArrayData, *pcBufLen);

            //Unlock the variant data
            SafeArrayUnaccessData(ovData->parray);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;

            DFS_TRACE_HIGH( REFERRAL_SERVER, "GetBinaryFromVariant failed error %d\n",Status);
        }
     }

     return Status;
}


VOID
DfsADBlobRootFolder::SynchronizeRoots( )
{
    DfsReferralData *pReferralData;
    DFS_INFO_101 DfsState;
    DFSSTATUS Status, SyncStatus;
    DfsReplica *pReplica;
    ULONG Target;
    UNICODE_STRING DfsName;

    PUNICODE_STRING pRootShare;
    ULONG SyncCount = 0, ReplicaCount = 0;
    BOOLEAN ImpersonationDisabled = FALSE;

    DfsDisableRpcImpersonation(&ImpersonationDisabled);


    DfsState.State = DFS_STORAGE_STATE_MASTER;



    pRootShare = GetLogicalShare();
    Status = DfsGenerateReferralDataFromRemoteServerNames( pRootShare->Buffer,
                                                           &pReferralData );

    if (Status == ERROR_SUCCESS)
    {
        ReplicaCount = pReferralData->ReplicaCount;

        for (Target = 0; Target < pReferralData->ReplicaCount; Target++)
        {
            PUNICODE_STRING pTargetServer, pTargetFolder;
            
            pReplica = &pReferralData->pReplicas[ Target ];
            
            pTargetServer = pReplica->GetTargetServer();
            pTargetFolder = pRootShare;
            
            if (DfsIsTargetCurrentMachine(pTargetServer))
            {
                continue;
            }

            Status = DfsCreateUnicodePathString( &DfsName, 
                                                 2,
                                                 pTargetServer->Buffer,
                                                 pTargetFolder->Buffer );

            if (Status == ERROR_SUCCESS)
            {
                SyncStatus = AddRootToSyncrhonize( &DfsName );
#if 0
                SyncStatus = NetDfsSetInfo( DfsName.Buffer,
                                            NULL,
                                            NULL,
                                            101,
                                            (LPBYTE)&DfsState);
#endif
                if (SyncStatus == ERROR_SUCCESS)
                {
                    SyncCount++;
                }
                DfsFreeUnicodeString( &DfsName );
            }
        }
        pReferralData->ReleaseReference();

    }

    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }

    DFS_TRACE_LOW( REFERRAL_SERVER, "Synchronize roots %wZ done: %x roots, %x succeeded\n",
                   pRootShare, ReplicaCount, SyncCount);

    return NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsapifrontend.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsApiFrontEnd.cxx
//
//  Contents:   Contains the support routines for the administering DFS
//              The DFS api server implementation uses this.
//              Also, any other admin tool that does not use the API
//              can use the facilities provided here to administer DFS.
//
//  Classes:    none.
//
//  History:    Feb. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------
#include "DfsRootFolder.hxx"
#include "DfsReferral.hxx"
#include "lm.h"
#include "lmdfs.h"
#include "DfsRegistryStore.hxx"
#include "DfsADBlobStore.hxx"
#include "DfsInit.hxx"
#include "netdfs.h"
#include "DomainControllerSupport.hxx"
//
// logging specific includes
//
#include "DfsApiFrontEnd.tmh" 

//
//dfsdev: validate input arguments.
//
#define API_VALIDATE_ARGUMENTS(_a, _b, _c, _d) ((_d) = ERROR_SUCCESS)


//+----------------------------------------------------------------------------
//
//  Function:   DfsAdd 
//
//  Arguments:  DfsPathName - the pathname that is being added or updated
//              ServerName  - Name of server being added as target
//              ShareName   - Name of share on ServerName backing the link
//              Comment     - Comment associated if this is a new link
//              Flags       - If DFS_ADD_VOLUME, fail this request if link exists
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAdd(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags )
{
    DFSSTATUS Status;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot;

    DFS_TRACE_NORM(API, "DfsAdd for path %ws, Server %ws Share %ws\n", 
                   DfsPathName, ServerName, ShareName);

    RtlInitUnicodeString( &DfsPath, DfsPathName );

    API_VALIDATE_ARGUMENTS( DfsPathName, ServerName, ShareName, Status);

    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    // Get a root folder for the passed in path name.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );

    if (Status == ERROR_SUCCESS)
    {
        //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        Status = pRoot->RootApiRequestPrologue( TRUE );

        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //
        if (Status == ERROR_SUCCESS) {
            //
            // Check if this is a valid link name. A valid link is one that
            // either is a perfect match of the LinkName, or the LinkName
            // does not encompass as existing link.
            //
            Status = pRoot->ValidateLinkName( &LinkName );
            DFSLOG("ValidateLink Name %wZ, status %x \n", &LinkName, Status );
        
            //
            // If validate link name succeeds, we can add the servername
            // and share name as a target to this link
            //
            if (Status == ERROR_SUCCESS)
            {
                //
                // If someone wanted to create this as a new link, we fail the request here.
                // the link already exists.
                //
                if (Flags & DFS_ADD_VOLUME)
                {
                    Status = ERROR_FILE_EXISTS;
                }
                else 
                {
                    //
                    // Add the target to this link.
                    //
                    Status = pRoot->AddMetadataLinkReplica( &LinkName,
                                                            ServerName,
                                                            ShareName );
                    DFSLOG("Add metadata Link replica %wZ, status %x\n", &DfsPath, Status);
                }
            }
            else if (Status == ERROR_NOT_FOUND)
            {
                //
                // If the link was not found, at this point we are assured that this link is
                // neither a prefix of an existing link not is any link a prefix of this link
                // name (validate prefix above provides that assurance)
                // We add a new link to this root.
                //
                Status = pRoot->AddMetadataLink( &DfsPath,
                                                 ServerName,
                                                 ShareName,
                                                 Comment );
                DFSLOG("Add metadata Link Name %wZ, status %x\n", &DfsPath, Status);
            }

            //
            // We are done with this request, so release our reference on the root folder.
            //
            pRoot->RootApiRequestEpilogue( TRUE, Status );
        }


        pRoot->ReleaseReference();
    }
done:
    DFS_TRACE_ERROR_NORM(Status, API, "DfsAdd for path %ws, Status %x\n", 
                         DfsPathName, Status );

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRemove
//
//  Arguments:  DfsPathName - the pathname that is being added or updated
//              ServerName  - Name of server being added as target
//              ShareName   - Name of share on ServerName backing the link
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsRemove(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName )

{
    DFSSTATUS Status;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot;
    BOOLEAN LastReplica = FALSE;

    DFS_TRACE_NORM(API, "DfsRemove for path %ws, Server Share \n", DfsPathName);

    RtlInitUnicodeString( &DfsPath, DfsPathName );

    API_VALIDATE_ARGUMENTS( DfsPathName, ServerName, ShareName, Status);

    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    //Get the root folder matching this name. We get a referenced root folder.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );


    if (Status == ERROR_SUCCESS)
    {
        //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        Status = pRoot->RootApiRequestPrologue( TRUE );

        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //
        if (Status == ERROR_SUCCESS) 
        {
            if ((ServerName != NULL) && (ShareName != NULL))
            {
                //
                // If the servername/sharename was provided, we just remove the matching target.
                // If the serername/sharename was not provided, we remove the link itself.
                //
                Status = pRoot->RemoveMetadataLinkReplica( &LinkName,
                                                           ServerName,
                                                           ShareName,
                                                           &LastReplica );
                //
                // DFSDEV: REMOVE THIS FROM THE API!!!
                //
                if ((Status == ERROR_SUCCESS) && (LastReplica == TRUE))
                {
                    Status = pRoot->RemoveMetadataLink( &LinkName );
                }
            }
            else 
            {
                Status = pRoot->RemoveMetadataLink( &LinkName );
            }
            //
            // We now release the reference that we have on the root.
            //
            pRoot->RootApiRequestEpilogue( TRUE, Status );
        }

        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "DfsRemove for path %ws, Status %x\n",
                         DfsPathName, Status);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsEnumerate
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is being added or updated
//    DWORD Level        - the level of information requested
//    DWORD PrefMaxLen   - a hint as to how many items to enumerate.
//    LPBYTE pBuffer     - the buffer to fill, passed in by the caller.
//    LONG BufferSize,   - the size of passed in buffer.
//    LPDWORD pEntriesRead - the number of entries read, set on return
//    LPDWORD pResumeHandle - the entry to start from, set to new value on return
//    PLONG pNextSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsEnumerate(
    LPWSTR DfsPathName,
    DWORD Level,
    DWORD PrefMaxLen,
    LPBYTE pBuffer,
    LONG BufferSize,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle,
    PLONG pNextSizeRequired )
{

    DFSSTATUS Status;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot;
    LONG LevelInfoSize;

    DFS_TRACE_NORM(API, "Dfs Enumerate for path Level %d ResumeHandle %d PrefMaxLen %d Size %d\n", 
                   Level, *pResumeHandle, PrefMaxLen, BufferSize);

    //
    // Get the unicode dfs path.
    //
    RtlInitUnicodeString( &DfsPath, DfsPathName );

    //
    // validate the input parameters.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);

    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // For legacy reasons, we need to support this call coming in with a null name.
    // This is where the server would host a single root, and we always knew which root
    // we wanted.
    // To workaround this situation, if we get a null pathname, we get the first root
    // folder and use that.
    //

    if (DfsPathName != NULL)
    {
        Status = DfsGetRootFolder( &DfsPath,
                                   &LinkName,
                                   &pRoot );
    }
    else
    {
        Status = DfsGetOnlyRootFolder( &pRoot );
    }

    if (Status == ERROR_SUCCESS)
    {
       //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        Status = pRoot->RootApiRequestPrologue( FALSE );


        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //

        if (Status == ERROR_SUCCESS)
        {
            //
            // If PrefMAxLen is 0xffffffff, we need to read all entries. OTherwise we need
            // to read a subset of the entries. Let PrefMaxLen decide the number in the array
            // of info parameters we pass back. (This is how we document our NEtDfsEnum api)
            //
        
            DWORD EntriesToRead;
            LevelInfoSize = DfsApiSizeLevelHeader(Level);
            EntriesToRead = PrefMaxLen / LevelInfoSize;
            if (EntriesToRead == 0) {
                EntriesToRead = 1;
            }

            if (EntriesToRead > pRoot->RootEnumerationCount())
            {
                EntriesToRead = pRoot->RootEnumerationCount();
            }
            *pEntriesRead = EntriesToRead;

            //
            // Now enumerate the entries in the root in the passed in buffer.
            //

            Status = pRoot->EnumerateApiLinks( DfsPathName,
                                               Level,
                                               pBuffer,
                                               BufferSize,
                                               pEntriesRead,
                                               pResumeHandle,
                                               pNextSizeRequired );

            //
            // Release the root reference, and return status back to the caller.
            //

            pRoot->RootApiRequestEpilogue( FALSE, Status );
        }
        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs Enumerate for path EntriesRead %d ResumeHandle %d Status %x Size %d\n",
                         *pEntriesRead, *pResumeHandle, Status, *pNextSizeRequired);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetInfo
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is of interest.
//    DWORD Level        - the level of information requested
//    LPBYTE pBuffer     - the buffer to fill, passed in by caller
//    LONG BufferSize,   - the size of passed in buffer.
//    PLONG pSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsGetInfo(
    LPWSTR DfsPathName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    PLONG pSizeRequired )
{

    DFSSTATUS Status;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot;

    DFS_TRACE_NORM(API, "Dfs get info for path %ws Level %d\n",
                   DfsPathName, Level );

    RtlInitUnicodeString( &DfsPath, DfsPathName );

    //
    // Validate the input parameters.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Get a referenced root folder for the passed in path.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );
    if (Status == ERROR_SUCCESS)
    {

        Status = pRoot->RootApiRequestPrologue( FALSE );

        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //

        if (Status == ERROR_SUCCESS) {
            //
            // If we got a root folder, get the requested information into the passed
            // in buffer.
            //
            Status = pRoot->GetApiInformation( &DfsPath,
                                               &LinkName,
                                               Level,
                                               pBuffer,
                                               BufferSize,
                                               pSizeRequired );
            //
            //WE are done: release our reference on the root.
            //
            pRoot->RootApiRequestEpilogue( FALSE, Status );
        }
        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs get info for path %ws Status %x\n",
                   DfsPathName, Status );

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsSetInfo
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is being  updated
//    LPWSTR Server      - the servername (optional) whose info is being set.
//    LPWSTR Share       - the share on the server.
//    DWORD Level        - the level of information being set
//    LPBYTE pBuffer     - the buffer holding the information to be set
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsSetInfo(
    LPWSTR DfsPathName,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE pBuffer )
{

    DFSSTATUS Status;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot;

    DFS_TRACE_NORM(API, "Dfs set info for path %ws Level %d\n",
                   DfsPathName, Level);

    RtlInitUnicodeString( &DfsPath, DfsPathName );

    //
    //validate the input arguments.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Get a referenced root folder for the passed in path.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );

    //
    // For cluster, checkpointing may add stuff to the registry which
    // we had not found when we started off. So, make an attempt
    // to look into the registry.
    // In future, this should work across all the roots, but for now
    // this is sort of a quick means of getting clusters going.
    //

    if (Status == ERROR_NOT_FOUND)
    {
        DfsRegistryStore *pRegStore;
        UNICODE_STRING DfsServer, DfsShare, NewDfsShare;

        Status = DfsGetRegistryStore( &pRegStore );

        if (Status == ERROR_SUCCESS)
        {
            Status = DfsGetPathComponents( &DfsPath,
                                           &DfsServer,
                                           &DfsShare,
                                           NULL );
            if (Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodeString( &NewDfsShare, 
                                                 &DfsShare );
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = pRegStore->LookupNewRootByName( NewDfsShare.Buffer,
                                                         &pRoot );

                DfsFreeUnicodeString( &NewDfsShare );
            }

            pRegStore->ReleaseReference();
        }
    }

    //
    // dfsdev: special case master and standby here.
    //
    // We call into the service with the appropriate bits to 
    // set the root in a standby mode or a master mode.
    //

    if (Status == ERROR_SUCCESS)
    {
        BOOLEAN Done = FALSE;
        if (Level == 101)
        {
            PDFS_INFO_101 pInfo101 = (PDFS_INFO_101)*((PULONG_PTR)pBuffer);

	    DFS_TRACE_NORM(API, "Dfs set info for path %ws Level %d State is %d\n",
			   DfsPathName, Level, pInfo101->State);

            if (pInfo101->State == DFS_VOLUME_STATE_RESYNCHRONIZE)
            {
		DFS_TRACE_NORM(API, "Root folder set to Master\n");
                pRoot->SetRootResynchronize();
                Done = TRUE;
            }
            else if (pInfo101->State == DFS_VOLUME_STATE_STANDBY)
            {
		DFS_TRACE_NORM(API, "Root folder set to standby\n");
                pRoot->SetRootStandby();
                Done = TRUE;
            }
        }
        if (Done)
        {
            goto done;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // Check if the root folder is available for api calls. If not,
        // we return an error back to the caller:
        // dfsdev: check if this error is a valid one to return.
        //
        Status = pRoot->RootApiRequestPrologue( TRUE );

        if (Status == ERROR_SUCCESS)
        {
            //
            // If we successfully got a root folder, set the specifed information
            // on the passed in path/server/share combination.
            //
            Status = pRoot->SetApiInformation( &LinkName,
                                               Server,
                                               Share,
                                               Level,
                                               pBuffer );
            //
            // release our reference on the root folder.
            //
            pRoot->RootApiRequestEpilogue( TRUE, Status );

        }
        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs set info for path %ws Status %x\n",
                         DfsPathName, Status );
    
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   DfsAddStandaloneRoot
//
//  Arguments:  
//    LPWSTR ShareName - the share name to use
//    LPWSTR Comment   - the comment for this root
//    DWORD Flags  -  the flags for this root
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAddStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags )
{

    DFS_TRACE_NORM(API, "Dfs add standalone root Machine Share %ws\n",
                   ShareName);

    //
    // dfsdev: use these parameters.
    //
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Flags);

    DfsRegistryStore *pRegStore;
    DFSSTATUS Status;

    //
    // This is a registry store specific function. So finf the registry store.
    // This gives us a referenced registry store pointer.
    //
    Status = DfsGetRegistryStore( &pRegStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Create the standalone root, and release our reference on the registry
        // store.
        //
        Status = pRegStore->CreateStandaloneRoot( MachineName,
                                                  ShareName,
                                                  Comment );
        pRegStore->ReleaseReference();
    }

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs add standalone root status %x Machine  Share %ws\n",
                         Status, ShareName);
    
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteStandaloneRoot
//
//  Arguments:  
//    LPWSTR ShareName - the root to delete
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsDeleteStandaloneRoot(
    LPWSTR ShareName )
{
    DfsRegistryStore *pRegStore;
    DFSSTATUS Status;

    DFS_TRACE_NORM(API, "Dfs delete standalone root Machine Share %ws\n",
                   ShareName);
    //
    // This is registry store specific function, so get the registry store.
    //
    Status = DfsGetRegistryStore( &pRegStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Delete the standalone root specified by the passed in sharename
        // and release our reference on the registry store.
        //
        Status = pRegStore->DeleteStandaloneRoot( NULL,
                                                  ShareName );
        pRegStore->ReleaseReference();
    }
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs delete standalone root status %x Machine  Share %ws\n",
                         Status, ShareName);

    return Status;
}



DFSSTATUS
DfsEnumerateLocalRoots( 
    LPWSTR MachineName,
    LPBYTE pBuffer,
    ULONG  BufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{

    UNREFERENCED_PARAMETER(MachineName);

    DFSSTATUS Status = ERROR_SUCCESS;    
    ULONG  TotalSize = 0;
    ULONG  EntriesRead = 0;
    ULONG_PTR CurrentBuffer = (ULONG_PTR)pBuffer;
    ULONG  CurrentSize = BufferSize;
    DfsStore *pStore;

    BOOLEAN OverFlow = FALSE;

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         (pStore != NULL) && (Status == ERROR_SUCCESS);
         pStore = pStore->pNextRegisteredStore) {

        Status = pStore->EnumerateRoots( &CurrentBuffer,
                                         &CurrentSize,
                                         &EntriesRead,
                                         &TotalSize );
        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            OverFlow = TRUE;
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if (OverFlow == TRUE)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        *pEntriesRead = EntriesRead;
        *pSizeRequired = TotalSize;
    }
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsEnumerateRoots
//
//  Arguments:  
//    LPBYTE pBuffer     - the buffer to fill, passed in by teh caller
//    LONG BufferSize,   - the size of passed in buffer.
//    LPDWORD pEntriesRead - the number of entries read, set on return
//    LPDWORD pResumeHandle - the entry to start from, set to new value on return
//    PLONG pSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsEnumerateRoots(
    LPWSTR DfsName,
    LPBYTE pBuffer,
    ULONG BufferSize,
    PULONG pEntriesRead,
    PULONG pResumeHandle,
    PULONG pSizeRequired )
{
    DFSSTATUS Status;

    
    DFS_TRACE_NORM(API, "Dfs enumerate roots: resume handle %d\n",
                   *pResumeHandle);
    //
    // dfsdev: use this parameter.
    //
    UNREFERENCED_PARAMETER(pResumeHandle);

    UNICODE_STRING DfsPath;
    UNICODE_STRING NameContext;
    UNICODE_STRING RemainingPart;

    RtlInitUnicodeString( &DfsPath, DfsName );

    Status = DfsGetFirstComponent( &DfsPath,
                                   &NameContext,
                                   &RemainingPart );

    if (Status == ERROR_SUCCESS)
    {
        if (RemainingPart.Length != 0)
        {
            //
            // return not found for now... dfsdev: fix on client.
            //
            Status = ERROR_PATH_NOT_FOUND;
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (DfsIsMachineDC() &&
            DfsIsNameContextDomainName(&NameContext))
        {
            Status = DfsDcEnumerateRoots( NULL,
                                          pBuffer,
                                          BufferSize,
                                          pEntriesRead,
                                          pSizeRequired);
        }
        else 
        {

            Status = DfsEnumerateLocalRoots( NULL,
                                             pBuffer,
                                             BufferSize,
                                             pEntriesRead,
                                             pSizeRequired );
        }
    }
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs enumerate roots, status %x\n",
                         Status );

    return Status;

}




//+----------------------------------------------------------------------------
//
//  Function:   DfsAddADBlobRoot
//
//  Arguments:  
//      LPWSTR MachineName,
//      LPWSTR DcName,
//      LPWSTR ShareName,
//      LPWSTR LogicalShare,
//      LPWSTR Comment,
//      DWORD Flags,
//     PDFSM_ROOT_LIST *ppRootList )
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAddADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DcName,
    LPWSTR ShareName,
    LPWSTR LogicalShare,
    LPWSTR Comment,
    BOOLEAN NewFtDfs,
    DWORD Flags,
    PVOID ppList )
{

    DFS_TRACE_NORM(API, "Dfs add ad blob root Machine Share %ws\n",
                   ShareName);

    PDFSM_ROOT_LIST *ppRootList = (PDFSM_ROOT_LIST *)ppList;
    //
    // dfsdev: use these parameters.
    //
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Flags);

    DfsADBlobStore *pADBlobStore;
    DFSSTATUS Status;

    //
    // This is a registry store specific function. So finf the registry store.
    // This gives us a referenced registry store pointer.
    //
    Status = DfsGetADBlobStore( &pADBlobStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Create the standalone root, and release our reference on the registry
        // store.
        //
        Status = pADBlobStore->CreateADBlobRoot( MachineName,
                                                 DcName,
                                                 ShareName,
                                                 LogicalShare,
                                                 Comment,
                                                 NewFtDfs,
                                                 ppRootList );
        pADBlobStore->ReleaseReference();
    }

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs add ad blob root status %x Machine  Share %ws\n",
                         Status, ShareName);
    
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteADBlobRoot
//
//  Arguments:  
//      LPWSTR MachineName,
//      LPWSTR DcName,
//      LPWSTR ShareName,
//      LPWSTR LogicalShare,
//      DWORD Flags,
//     PDFSM_ROOT_LIST *ppRootList )
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsDeleteADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DcName,
    LPWSTR ShareName,
    LPWSTR LogicalShare,
    DWORD Flags,
    PVOID ppList )
{

    DFS_TRACE_NORM(API, "Dfs delete ad blob root Machine Share %ws\n",
                   ShareName);


    PDFSM_ROOT_LIST *ppRootList = (PDFSM_ROOT_LIST *)ppList;

    //
    // dfsdev: use these parameters.
    //
    UNREFERENCED_PARAMETER(Flags);

    DfsADBlobStore *pADBlobStore;
    DFSSTATUS Status;

    //
    // This is a registry store specific function. So finf the registry store.
    // This gives us a referenced registry store pointer.
    //
    Status = DfsGetADBlobStore( &pADBlobStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Create the standalone root, and release our reference on the registry
        // store.
        //
        Status = pADBlobStore->DeleteADBlobRoot( MachineName,
                                                 DcName,
                                                 ShareName,
                                                 LogicalShare,
                                                 ppRootList );
        pADBlobStore->ReleaseReference();
    }

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs delete ad blob root status %x Machine  Share %ws\n",
                         Status, ShareName);
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsclustersupport.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsclustersupport.cxx
//
//  Contents:   DfsClusterSupport
//
//  Classes:
//
//-----------------------------------------------------------------------------



#include "DfsClusterSupport.hxx"

typedef struct _DFS_CLUSTER_CONTEXT {
    PUNICODE_STRING pShareName;
    PUNICODE_STRING pVSName ;
        
} DFS_CLUSTER_CONTEXT;

DWORD
ClusterCallBackFunction(
    HRESOURCE hSelf,
    HRESOURCE hResource,
    PVOID Context)
{

    UNREFERENCED_PARAMETER( hSelf );

    HKEY HKey = NULL;
    HKEY HParamKey = NULL;
    ULONG NameSize = MAX_PATH;
    WCHAR ClusterName[MAX_PATH];
    DFS_CLUSTER_CONTEXT *pContext = (DFS_CLUSTER_CONTEXT *)Context;


    DWORD Status;
    DWORD Value;

    HKey = GetClusterResourceKey(hResource, KEY_READ);

    if (HKey != NULL) {
        Status = ClusterRegOpenKey( HKey, 
                                    L"Parameters", 
                                    KEY_READ, 
                                    &HParamKey );

        ClusterRegCloseKey( HKey );

        if (ERROR_SUCCESS == Status)
        {
            LPWSTR ResShareName;
            UNICODE_STRING VsName;

            ResShareName = ResUtilGetSzValue( HParamKey,
                                              L"ShareName" );
            RtlInitUnicodeString(&VsName, ResShareName);
            if (pContext->pShareName->Length == VsName.Length)
            {
                Status = ResUtilGetDwordValue(HParamKey, L"IsDfsRoot", &Value, 0);

                if ((ERROR_SUCCESS == Status)  &&
                    (Value == 1))
                {

                    if (_wcsnicmp(pContext->pShareName->Buffer,
                                 VsName.Buffer,
                                 VsName.Length) == 0)
                    {
                        if ((GetClusterResourceNetworkName( hResource,
                                                            ClusterName,
                                                            &NameSize )) == TRUE)
                        {
                            Status = DfsCreateUnicodeStringFromString( pContext->pVSName,
                                                                       ClusterName );
                        }
                    }
                }
            }
            ClusterRegCloseKey( HParamKey );
        }
    }

    return Status;
}
#if 0

DoNotUse()
{

    DWORD  Status      = ERROR_SUCCESS;
    DWORD  BufSize     = ClusDocEx_DEFAULT_CB;
    LPVOID pOutBuffer   = NULL;
    DWORD  ControlCode = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES;

    pOutBuffer = new BYTE [ BufSize ];

    if( pOutBuffer == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = ClusterResourceControl( hResource,                                         // resource handle
                                           NULL,
                                           ControlCode,
                                           NULL,                                              // input buffer (not used)
                                           0,                                                 // input buffer size (not used)
                                           pOutBuffer,                                       // output buffer: property list
                                           OutBufferSize,                                   // allocated buffer size (bytes)
                                           pBytesReturned );     


    dwResult = ResUtilFindDwordProperty( lpPropList, 
                                         cbPropListSize, 
                                         lpszPropName, 
                                         lpdwPropValue );


    }
}
#endif


DWORD
GetRootClusterInformation(
    PUNICODE_STRING pShareName,
    PUNICODE_STRING pVSName )

{
    DWORD Status;
    DFS_CLUSTER_CONTEXT Context;

    Context.pShareName = pShareName;
    Context.pVSName = pVSName;

    Status = ResUtilEnumResources(NULL,
                                  L"File Share",
                                  ClusterCallBackFunction,
                                  (PVOID)&Context );
                                  
    return Status;


}

DFSSTATUS
DfsClusterInit(
    PBOOLEAN pIsCluster )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD ClusterState;

    *pIsCluster = FALSE;

    Status = GetNodeClusterState( NULL, // local node
                                  &ClusterState );

    if (Status == ERROR_SUCCESS)
    {
        if ( (ClusterStateRunning == ClusterState) ||
             (ClusterStateNotRunning == ClusterState) )
        {
            *pIsCluster = TRUE;

        }
    }
    printf("Is cluster %x\n", *pIsCluster);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfslogmacros.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsLogMacros.cxx
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    Marc 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------
       
#include <windows.h>
#include "dfswmi.h"
#include "dfsLogMacros.hxx"
#include "dfsLogMacros.tmh"

PVOID pReferralControl = NULL;

void SetReferralControl(WPP_CB_TYPE * Control)
{
    pReferralControl = (PVOID)Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsFolder.cxx
//
//  Contents:   implements the base DFS Folder class
//
//  Classes:    DfsFolder.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsFolder.hxx"
#include "DfsFolderReferralData.hxx"
#include "DfsInit.hxx"

//
// logging specific includes
//

#include "DfsFolder.tmh" 


//+-------------------------------------------------------------------------
//
//  Function:   GetReferralData - get the referral data
//
//  Arguments:  ppReferralData - the referral data for this folder
//              pCacheHit - did we find it already loaded?
//
//  Returns:    Status
//               ERROR_SUCCESS if we could get the referral data
//               error status otherwise.
//
//
//  Description: This routine returns a reference DfsFolderReferralDAta
//               for the folder. If one does not already exist in this
//               folder, we create a new one. If someone is in the process
//               of loading the referral, we wait on the event in 
//               the referral data which gets signalled when the thread
//               responsible for loading is done with the load.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsFolder::GetReferralData(
    OUT DfsFolderReferralData **ppReferralData,
    OUT BOOLEAN   *pCacheHit )
{
    DfsFolderReferralData *pRefData;
    DFSSTATUS Status = STATUS_SUCCESS;
    
    *pCacheHit = FALSE;

    Status = AcquireWriteLock();
    if ( Status != STATUS_SUCCESS )
    {
        return Status;
    }

    //
    // WE take difference action depending on the load state.
    //
    switch ( _LoadState )
    {
    case DfsFolderLoaded:

        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: Cache hit\n");
        //
        // we are dealing with a loaded folder. Just acquire a reference
        // and return the loaded referral data.
        //
        ASSERT (_pReferralData != NULL);

        pRefData = _pReferralData;

        pRefData->Timeout = _Timeout;
        pRefData->AcquireReference();
        
        ReleaseLock();
        
        *pCacheHit = TRUE;        
        *ppReferralData = pRefData;

        break;

    case DfsFolderNotLoaded:

        //
        // The folder is not loaded. Make sure that the referral data is
        // indeed empty. Create a new instance of the referral data
        // and set the state to load in progress.
        // The create reference of the folder referral data is inherited
        // by the folder. (we are holding a reference to the referral
        // data in _pReferralData). This reference is released when
        // we RemoveReferralData at a later point.
        //
        ASSERT(_pReferralData == NULL);
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: not loaded\n");

        _pReferralData = new DfsFolderReferralData( &Status,
                                                    this );
        if ( _pReferralData != NULL )
        {
            _LoadState = DfsFolderLoadInProgress;

            if (IsFolderRoot() == TRUE)
            {
                _pReferralData->SetRootReferral();
            }

            _pReferralData->Timeout = _Timeout;

            //
            // Acquire a reference on the new referral data, since we 
            // have to return a referenced referral data to the caller.
            //
            pRefData = _pReferralData;
            pRefData->AcquireReference();
        } else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // We no longer need the lock. We have allocate the referral
        // data and marked the state accordingly. No other thread can
        // interfere with our load now.
        //
        ReleaseLock();

        //
        // Now we load the referral data, and save the status of the
        // load in both our load status as well as the load status
        // in the referral data.
        // If the load was successful, we add this to the loaded list
        // of referral data that can be scavenged later. We set the load
        // state to loaded, and signal the event so that all waiting
        // threads can now be woken up.
        //

        if ( Status == ERROR_SUCCESS )
        {
            DFSLOG(" Load called on link %wZ (%wZ)\n",
                   GetFolderMetadataName(),
                   GetFolderLogicalName() );


            Status = LoadReferralData( _pReferralData );

            _LoadStatus = Status;
            _pReferralData->LoadStatus = Status;


            if ( Status == ERROR_SUCCESS )
            {
                _LoadState = DfsFolderLoaded;
                DfsAddReferralDataToLoadedList( _pReferralData );
                *ppReferralData = pRefData;
                pRefData->Signal();
            } else
            {
                _LoadState = DfsFolderLoadFailed;
                pRefData->Signal();
                pRefData->ReleaseReference();
            }
        }

        break;

    case DfsFolderLoadInProgress:

        //
        // The load is in progress. We acquire a reference on the
        // referral data being loaded and wait for the event in the
        // referral data to be signalled. The return status of the wait
        // indicates if we can return the referral data or we fail
        // this request with an error.
        //
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: load in progress\n");
        ASSERT(_pReferralData != NULL);
        pRefData = _pReferralData;
        pRefData->AcquireReference();

        ReleaseLock();

        DFSLOG("Thread: Waiting for referral load\n");

        Status = pRefData->Wait();

        if ( Status == ERROR_SUCCESS )
        {
            *ppReferralData = pRefData;
        } else
        {
            pRefData->ReleaseReference();
        }
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: load in progress done\n");
        break;

    case DfsFolderLoadFailed:
        //
        // The Load failed. REturn error. We need to setup a time
        // after which we need to reattempt the load.
        //
        Status = _LoadStatus;
        ReleaseLock();
        *ppReferralData = NULL;
        break;

    default:
        //
        // We should never get here. Its an invalid state.
        //
        ASSERT(TRUE);
        Status = ERROR_INVALID_STATE;
        ReleaseLock();

        break;
    }

    if ((Status == ERROR_SUCCESS) &&
        (*ppReferralData == NULL))
    {
        DbgBreakPoint();
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   RemoveReferralData - remove the referral data from folder
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS if we could remove  the referral data
//               error status otherwise.
//
//
//  Description: This routine removes the cached reference to the loaded
//               referral data in the folder, and releases its reference
//               on it.
//               This causes all future GetREferralDAta to be loaded
//               back from the store.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsFolder::RemoveReferralData( 
    DfsFolderReferralData *pRemoveReferralData,
    PBOOLEAN pRemoved )
{
    DFSSTATUS Status;
    DfsFolderReferralData *pRefData = NULL;

    //
    // Get tnhe exclusive lock on the folder
    //
    if (pRemoved != NULL)
    {
        *pRemoved = FALSE;
    }

    Status = AcquireWriteLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // make sure _LoadState indicates that it is loaded.
    // Set the referralData to null, and state to NotLoaded.
    //
    if (_LoadState == DfsFolderLoaded)
    {

        pRefData = _pReferralData;
        if ( (pRemoveReferralData == NULL) || 
             (pRemoveReferralData == pRefData) )
        {
            _pReferralData = NULL;
            _LoadState = DfsFolderNotLoaded;
        }
        else {
            pRefData = NULL;
        }
    }

    ReleaseLock();

    //
    // Release reference on the referral data. This is the reference
    // we had taken when we had cached the referral data in this folder.
    //
    if (pRefData != NULL)
    {
        pRefData->ReleaseReference();
        if (pRemoved != NULL)
        {
            *pRemoved = TRUE;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsmigrate.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsMigrate.cxx
//
//  Contents:   Contains the routines to migrate existing DFS root 
//              information in the registry to a different location,
//              to allow multiple roots per server.
//
//  Classes:    none.
//
//  History:    Feb. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

//
// dfsdev: need to add code to delete, on failure, any intermediate stuff 
// we create during migration
//

#include "DfsGeneric.hxx"
#include "DfsInit.hxx"
#include "shlwapi.h"
#include "DfsStore.hxx"
DFSSTATUS
MigrateFTDfs( 
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare );

DFSSTATUS
MigrateStdDfs(
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare);


//+----------------------------------------------------------------------------
//
//  Function:   MigrateDfs
//
//  Arguments:  MachineName - Name of the machine to target. 
//                            Can be NULL for local machine.
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine contacts the specified machine, and checks
//               if the registry information indicates the machine is
//               hosting a standalone or domain DFS. It moves this 
//               information appropriately under the new StandaloneRoot
//               or DomainRoots key, so that we can have multiple roots
//               on the machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateDfs(
    LPWSTR MachineName )
{
    LPWSTR DfsRootShare = NULL;
    LPWSTR FtDfsValue = NULL;

    ULONG DataSize, DataType, RootShareLength;
    ULONG FtDfsValueSize;

    DWORD Status;

    HKEY OldKey;

    PRINTF("Migrate DFS Called. This will migrate the DFS on %wS\n",
           (MachineName != NULL) ? MachineName : L"this machine");

    Status = DfsStore::GetOldDfsRegistryKey( MachineName,
                                             TRUE,
                                             NULL,
                                             &OldKey );

    //
    // If we opened the DFS hierarchy key properly, get the maximum
    // size of any of the values under this key. This is so that we
    // know how much memory to allocate, so that we can read any of
    // the values we desire.
    // 
    //
    if ( Status == ERROR_SUCCESS ) {
        Status = RegQueryInfoKey( OldKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  NULL );       // Last write time

        //
        // We want to read the value of the DfsRootShare. If the value
        // is still a string, this is indeed an old style DFS and needs
        // to be migrated. If the value is something else, this is
        // already a migrated machine, so do nothing.
        //

        if (Status == ERROR_SUCCESS) {
            RootShareLength = DataSize;
            DfsRootShare = (LPWSTR) new BYTE[DataSize];
            if (DfsRootShare == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                Status = RegQueryValueEx( OldKey,
                                          DfsRootShareValueName,
                                          NULL,
                                          &DataType,
                                          (LPBYTE)DfsRootShare,
                                          &RootShareLength);
            }
        }
        //
        // check if the value is a string.
        //
        if ((Status == ERROR_SUCCESS) &&
            (DataType == REG_SZ)) {
            FtDfsValueSize = DataSize;
            FtDfsValue = (LPWSTR) new BYTE[DataSize];
            if (FtDfsValue == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                //
                // Now check if this is a Domain Based root.
                //
                Status = RegQueryValueEx( OldKey,
                                          DfsFtDfsValueName,
                                          NULL,
                                          &DataType,
                                          (LPBYTE)FtDfsValue,
                                          &FtDfsValueSize);
            
                //
                // At this point we do know we have a machine that
                // needs to be migrated. If the machine was hosting
                // a standalone root, call MigrateFTDfs to take care
                // of the domain based dfs root migration. Else, this
                // is a standalone root, so call the standalone root
                // migration routine.
                //
                if (Status == ERROR_SUCCESS) {
                    Status = MigrateFTDfs( MachineName,
                                           OldKey,
                                           FtDfsValue,
                                           DfsRootShare );
                }
                else {
                    Status = MigrateStdDfs( MachineName,
                                            OldKey,
                                            DfsRootShare,
                                            DfsRootShare );
                }
            }
        } else {
            //
            // there is no root here: do whatever is necessary to block
            // dfsutil from creating an old fashioned root.
            //
            Status = ERROR_SUCCESS;
        }

        //
        // we are almost done. WE now convert the root share value name in
        // the top most DFS key from a string to a dword so that any other
        // migration attempt will realize the migration is complete.
        //
        if (Status == ERROR_SUCCESS) {
            ULONG RootShareValue = 1;

            //
            // ignore error returns: we dont care.
            //
            
            RegDeleteValue( OldKey,
                            DfsRootShareValueName );

            RegSetValueEx( OldKey,
                           DfsRootShareValueName,
                           0,
                           REG_DWORD,
                           (PBYTE)&RootShareValue,
                           sizeof(RootShareValue) );
        }


        //
        // We are done, close the key we opened.
        //
        RegCloseKey( OldKey );
    }


    //
    // dfsdev: if we fail, we need to cleanup any of the work we have
    // done so far!
    //
    //
    // release any of the resources we had allocated, since we are 
    // about to return back to the caller.
    //
    if ( DfsRootShare != NULL ) {
        delete [] DfsRootShare;
    }

    if ( FtDfsValue != NULL ) {
        delete [] FtDfsValue;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   MigratefFTDfs
//
//  Arguments:  
//    HKEY DfsKey -  The open key to the top of DFS registry hierarchy
//    LPWSTR DfsLogicalShare - the logical domain based share.
//    LPWSTR DfsRootShare - the share on this machine backing the name
//    LPWSTR FtDfsDN  - The distinguished name in the AD for the DFS.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine moves the domain based DFS root information
//               in the registry under a new key, so that we can support
//               multiple roots per machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateFTDfs( 
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare )
{
    DWORD Status;
    HKEY NewBlobKey;
    //
    // We open the ft parent, which holds all the ft roots.
    //
    DFSLOG("Migrating FT Dfs\n");

    Status = DfsStore::GetNewADBlobRegistryKey( MachineName,
                                                TRUE,
                                                NULL,
                                                &NewBlobKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsStore::SetupADBlobRootKeyInformation( NewBlobKey,
                                                          DfsLogicalShare,
                                                          DfsRootShare );

        RegCloseKey( NewBlobKey );
    }


    //
    // dfsdev: if we fail, we need to cleanup any of the work we have
    // done so far!
    //


    if (Status == ERROR_SUCCESS) {
        RegDeleteValue( DfsKey,
                        DfsFtDfsConfigDNValueName);
        RegDeleteValue( DfsKey,
                        DfsFtDfsValueName );
    }

    DFSLOG("Migrating FT Dfs: Status %x\n", Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   MigratefStdDfs
//
//  Arguments:  
//    HKEY DfsKey -  The open key to the top of DFS registry hierarchy
//    LPWSTR DfsLogicalShare - the logical dfs share.
//    LPWSTR DfsRootShare - the share on this machine backing the name
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine moves the registry based DFS root information
//               in the registry under a new key, so that we can support
//               multiple roots per machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateStdDfs(
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare)
{
    DWORD Status;
    HKEY StdDfsKey, StdDfsShareKey;
    ULONG RootShareValue = 1;

    DFSLOG("Migrating Std Dfs\n");
    //
    // Open the new standalone DFS parent, which holds all the
    // standalone roots and their metadata as its children.
    //
    Status = DfsStore::GetNewStandaloneRegistryKey( MachineName,
                                                    TRUE,
                                                    NULL,
                                                    &StdDfsKey );

    //
    // We now create an unique metadata name for our root, and add
    // it as a child to the parent key we created.
    //
    if (Status == ERROR_SUCCESS) {

        Status = RegCreateKeyEx( StdDfsKey,
                                 DfsLogicalShare,
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &StdDfsShareKey,
                                 NULL );
        //
        // We have successfully created the child root. Now, just copy
        // all the link information under the old root key to the new
        // root key. If we successfully copy, we can delete the old
        // standalone root and all its children.
        //
        if (Status == ERROR_SUCCESS) {
                
            Status = SHCopyKey( DfsKey,
                                DfsOldStandaloneChild,
                                StdDfsShareKey,
                                NULL );
            if (Status == ERROR_SUCCESS) {
                Status = SHDeleteKey( DfsKey,
                                      DfsOldStandaloneChild );
            }
            
            //
            // Now setup the values for the new root so that we know
            // the shares that are backing this new root.
            //
            if (Status == ERROR_SUCCESS) {
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsRootShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)DfsRootShare,
                                        wcslen(DfsRootShare) * sizeof(WCHAR) );
            }

            if (Status == ERROR_SUCCESS) {
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsLogicalShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)DfsLogicalShare,
                                        wcslen(DfsLogicalShare) * sizeof(WCHAR) );
            }


            RegCloseKey( StdDfsShareKey );
        }

        RegCloseKey( StdDfsKey );
    }

    DFSLOG("Migrating Std Dfs: Status %x\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfseventlog.cxx ===
/*++

   Copyright    (c)    2001        Microsoft Corporation

   Module Name:
        Dfseventlog.cxx

   Abstract:

        This module defines APIs for logging events.


   Author:

        Rohan Phillips    (Rohanp)    31-March-2001


--*/
              
              

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dfsheader.h>

       
#define DFS_EVENT_SOURCE_SYSTEM_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\System\\"
#define DFS_EVENT_SOURCE_APPLICATION_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\Application\\"


DFSSTATUS 
DfsAddEventSourceToRegistry(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD dwData = 0;
    HKEY hkEventSource = NULL;
    CHAR szBuf[100];

    // Add source name as a subkey under the Application 
    // key in the EventLog registry key. 
    if (RegCreateKeyA(HKEY_LOCAL_MACHINE, 
            "SYSTEM\\CurrentControlSet\\Services\\EventLog\\system\\DfsSvc", &hkEventSource))
    {
        Status = GetLastError();
        goto Exit;
    }
 
    // Set the name of the message file. 
    strcpy(szBuf, "%SystemRoot%\\System\\dfssvc.exe"); 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueExA(hkEventSource,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szBuf,           // pointer to value data 
            strlen(szBuf) + 1))       // length of value data 
    {
        Status = GetLastError();
        goto Exit;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueExA(hkEventSource,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)))    // length of value data
    {

        Status = GetLastError();
        goto Exit;
    }
 
Exit:

    if(hkEventSource)
    {
        RegCloseKey(hkEventSource); 
    }

    return Status;
}

//
// Unregister your event source in the registry.
//
// Parameters:
//   szEventSource - the name of the eventsource
//
DFSSTATUS 
DfsRemoveEventSourceFromRegistry(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    // delete the key and its values
    Status = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\system\\DfsSvc");

    return Status;
}

HANDLE 
DfsOpenEventLog(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE EventLogHandle = NULL;

    EventLogHandle = RegisterEventSource( NULL, L"DfsSvc");

    if (EventLogHandle == NULL ) 
    {
        Status = GetLastError();
    }

    return EventLogHandle;

} 


DFSSTATUS 
DfsCloseEventLog(HANDLE EventLogHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOL fSuccess = TRUE;


    if ( EventLogHandle != NULL) 
    {
        fSuccess = DeregisterEventSource(EventLogHandle);

        if ( !fSuccess) 
         {
           Status = GetLastError();
         }

    }

    return Status;
}



DFSSTATUS 
DfsLogEventEx(IN DWORD idMessage,
              IN WORD wEventType,
              IN WORD cSubstrings,
              IN LPCTSTR *rgszSubstrings,
              IN DWORD errCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE EventLogHandle = NULL;
    void *pRawData = NULL;
    DWORD cbRawData = 0;

    //
    // Also include errCode in raw data form
    // where people can view it from EventViewer
    // 
    if (errCode != 0) {
        cbRawData = sizeof(errCode);
        pRawData = &errCode;
    }


    EventLogHandle = DfsOpenEventLog();
    if(EventLogHandle != NULL)
    {
        //
        // log the event
        //
        if (!ReportEvent(EventLogHandle,
                         wEventType,
                         0,
                         idMessage,
                         NULL,
                         cSubstrings,
                         cbRawData,
                         rgszSubstrings,
                         pRawData))
        {
            Status = GetLastError();
        }


        DfsCloseEventLog(EventLogHandle);
    }


    return Status;
} 


DFSSTATUS 
DFsLogEvent(IN DWORD  idMessage,
            IN const TCHAR * ErrorString,
            IN DWORD  ErrCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    WORD wEventType = 0;                
    const TCHAR * apszSubStrings[2];
   
    apszSubStrings[0] = ErrorString;    

    if ( NT_INFORMATION( idMessage)) 
    {
        wEventType = EVENTLOG_INFORMATION_TYPE;
    } 
    else if ( NT_WARNING( idMessage)) 
    {
        wEventType = EVENTLOG_WARNING_TYPE;
    } 
    else 
    {
        wEventType = EVENTLOG_ERROR_TYPE;
    }


    Status = DfsLogEventEx(idMessage,
                           wEventType,
                           1,
                           apszSubStrings,
                           ErrCode);
    return Status;

}

//usage:
//  const TCHAR * apszSubStrings[4];
//  apszSubStrings[0] = L"Root1";
//  DfsLogDfsEvent(DFS_ERROR_ROOT_DELETION_FAILURE,
//  1,
//  apszSubStrings,
//  errorcode);
//
//
DFSSTATUS 
DfsLogDfsEvent(IN DWORD  idMessage,
               IN WORD   cSubStrings,
               IN const TCHAR * apszSubStrings[],
               IN DWORD  ErrCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    WORD wEventType = 0;                
   
    if ( NT_INFORMATION( idMessage)) 
    {
        wEventType = EVENTLOG_INFORMATION_TYPE;
    } 
    else if ( NT_WARNING( idMessage)) 
    {
        wEventType = EVENTLOG_WARNING_TYPE;
    } 
    else 
    {
        wEventType = EVENTLOG_ERROR_TYPE;
    }


    Status = DfsLogEventEx(idMessage,
                           wEventType,
                           cSubStrings,
                           apszSubStrings,
                           ErrCode);
    return Status;

} 

void 
DfsLogEventSimple(DWORD MessageId, DWORD ErrorCode=0)
{
    DfsLogDfsEvent(MessageId, 0, NULL, ErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsinit.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsInit.cxx
//
//  Contents:   Contains initialization of server
//
//  Classes:    none.
//
//  History:    Dec. 8 2000,   Author: udayh
//              Jan. 12 2001,  Rohanp - Added retrieval of replica data
//
//-----------------------------------------------------------------------------
                    

#include "DfsRegistryStore.hxx"
#include "DfsADBlobStore.hxx"
#include "DfsEnterpriseStore.hxx"
#include "DfsFolderReferralData.hxx"
#include "DfsInit.hxx"
#include "DfsServerSiteInfo.hxx"
#include "DfsSiteSupport.hxx"
#include "dfsfilterapi.hxx"
#include "DfsClusterSupport.hxx"
#include "DomainControllerSupport.hxx"
#include "DfsDomainInformation.hxx"
#include "dfsadsiapi.hxx"
#include "DfsSynchronizeRoots.hxx"
#include "dfsinit.tmh"

//
// DFS_REGISTER_STORE: A convenience define to be able to register a
// number of differnet store types.
//
#define DFS_REGISTER_STORE(_name, _sts)                          \
{                                                                \
    DfsServerGlobalData.pDfs ## _name ## Store = new Dfs ## _name ## Store(); \
                                                                 \
    if (DfsServerGlobalData.pDfs ## _name ## Store == NULL) {    \
        (_sts) = ERROR_NOT_ENOUGH_MEMORY;                        \
    }                                                            \
    else {                                                       \
        DfsServerGlobalData.pDfs ## _name ## Store->pNextRegisteredStore = DfsServerGlobalData.pRegisteredStores; \
        DfsServerGlobalData.pRegisteredStores = DfsServerGlobalData.pDfs ## _name ## Store;        \
        (_sts) = ERROR_SUCCESS;                                  \
    }                                                            \
}

//
// INITIALIZE_COMPUTER_INFO: A convenience define to initialize the
// different information about the computer (netbios, dns, domain etc)
//

#define INITIALIZE_COMPUTER_INFO( _NamedInfo, _pBuffer, _Sz, _Sts ) \
{                                                                   \
    ULONG NameSize = _Sz;                                           \
    if (_Sts == ERROR_SUCCESS) {                                    \
        DWORD dwRet = GetComputerNameEx( _NamedInfo,_pBuffer,&NameSize ); \
        if (dwRet == 0) _Sts = GetLastError();                      \
    }                                                               \
    if (_Sts == ERROR_SUCCESS) {                                    \
        LPWSTR NewName = new WCHAR [ NameSize + 1 ];                \
        if (NewName == NULL) _Sts = ERROR_NOT_ENOUGH_MEMORY;        \
        else wcscpy( NewName, _pBuffer );                           \
        DfsServerGlobalData.DfsMachineInfo.Static ## _NamedInfo ## = NewName;\
    }                                                               \
}                 


//
// The DfsServerGlobalData: the data structure that holds the registered
// stores and the registered names, among others.
//
DFS_SERVER_GLOBAL_DATA DfsServerGlobalData;

//
// Varios strings that represent the names in registry where some of
// DFS information is stored.
//
LPWSTR DfsParamPath = L"System\\CurrentControlSet\\Services\\Dfs\\Parameters";

LPWSTR DfsRegistryHostLocation = L"SOFTWARE\\Microsoft\\DfsHost";
LPWSTR DfsOldRegistryLocation = L"SOFTWARE\\Microsoft\\DfsHost\\volumes";
LPWSTR DfsVolumesLocation = L"volumes";
LPWSTR DfsOldStandaloneChild = L"domainroot";



LPWSTR DfsRegistryDfsLocation = L"SOFTWARE\\Microsoft\\Dfs";
LPWSTR DfsNewRegistryLocation = L"SOFTWARE\\Microsoft\\Dfs\\Roots";
LPWSTR DfsRootLocation=L"Roots";
LPWSTR DfsStandaloneChild = L"Standalone";
LPWSTR DfsADBlobChild = L"Domain";
LPWSTR DfsEnterpriseChild = L"Enterprise";



LPWSTR DfsRootShareValueName = L"RootShare";
LPWSTR DfsLogicalShareValueName = L"LogicalShare";
LPWSTR DfsFtDfsValueName = L"FTDfs";
LPWSTR DfsFtDfsConfigDNValueName = L"FTDfsObjectDN";
LPWSTR DfsWorkerThreadIntervalName = L"WorkerThreadInterval";


DFSSTATUS
DfsRegisterStores( VOID );

VOID
DfsRecognize( LPWSTR Name );

DFSSTATUS
DfsRegisterName(LPWSTR Name);

DWORD
DfsWorkerThread(LPVOID TData);


DFSSTATUS
DfsCreateRequiredDfsKeys(void);


BOOL 
DfsGetGlobalRegistrySettings(void);


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRegistryStore 
//
//  Arguments:  ppRegStore -  the registered registry store.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine searches through the registered stores, and
//  picks the one that is the registry store. This is required for
//  specific API requests that target the Registry based DFS 
//  For example: add standalone root, etc
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetRegistryStore(
    DfsRegistryStore **ppRegStore )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    *ppRegStore = DfsServerGlobalData.pDfsRegistryStore;

    if (*ppRegStore != NULL)
    {
        (*ppRegStore)->AcquireReference();
    }
    else
    {
        Status = ERROR_NOT_SUPPORTED;
    }


    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetADBlobStore 
//
//  Arguments:  ppRegStore -  the registered ADBlob store.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine searches through the registered stores, and
//  picks the one that is the registry store. This is required for
//  specific API requests that target the ADBlob based DFS 
//  For example: add  root, etc
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetADBlobStore(
    DfsADBlobStore **ppStore )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    *ppStore = DfsServerGlobalData.pDfsADBlobStore;

    if (*ppStore != NULL)
    {
        (*ppStore)->AcquireReference();
    }
    else
    {
        Status = ERROR_NOT_SUPPORTED;
    }


    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsServerInitialize
//
//  Arguments:  Flags - the server flags
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine initializes the DFS server. It registers
//               all the different stores we care about, and also
//               starts up a thread that is responsible for keeping the
//               DFS info upto date.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsServerInitialize(
    ULONG Flags ) 
{
    DFSSTATUS Status = ERROR_SUCCESS;

    ZeroMemory(&DfsServerGlobalData, sizeof(DfsServerGlobalData));
    DfsServerGlobalData.pRegisteredStores = NULL;
    DfsServerGlobalData.Flags = Flags;
    InitializeCriticalSection( &DfsServerGlobalData.DataLock );


    //
    // Initialize the prefix table library.
    //
    DfsPrefixTableInit();


    Status = DfsCreateRequiredDfsKeys();

    //
    // Create a site support class that lets us look up the server-site
    // information of servers that configured in our metadata.
    //
    DfsServerGlobalData.pSiteSupport = new DfsSiteSupport(&Status);
    DfsServerGlobalData.CacheFlushInterval = CACHE_FLUSH_INTERVAL;


    DfsGetGlobalRegistrySettings();

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsRootSynchronizeInit();
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Initialize root synchronization status %x\n", Status);
    }
    //
    // Now initialize the computer info, so that this server knows
    // the netbios name, domain name and dns name of this machine.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsInitializeComputerInfo();
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Initialize computer info status %x\n", Status);
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsClusterInit( &DfsServerGlobalData.IsCluster );
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Dfs Cluster Init Status %x IsCluster %d\n", 
                             Status, DfsServerGlobalData.IsCluster);

    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsDcInit( &DfsServerGlobalData.IsDc,
                            &DfsServerGlobalData.pDomainInfo );
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Dfs DC Init Status %x, IsDC %d\n", 
                             Status, DfsServerGlobalData.IsDc);
    }

    if (Status == ERROR_SUCCESS)
    {
        if(!DfsIsMachineWorkstation())
        {
            Status = DfsGenerateDfsAdNameContext(&DfsServerGlobalData.DfsAdNameContext);

            DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsGenerateDfsAdNameContext Status %x\n", Status);
        }

    }


    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsInitializePrefixTable( &DfsServerGlobalData.pDirectoryPrefixTable,
                                           FALSE, 
                                           NULL );
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Initialize directory prefix table Status %x\n", Status);
    }


    //
    // If the flags indicate that we are handling all known local 
    // namespace on this machine, add an empty string to the handled
    // namespace list.
    //
    if (Status == ERROR_SUCCESS) 
    {
        if (Flags & DFS_LOCAL_NAMESPACE)
        {
            BOOLEAN Migrate;

            Migrate = DfsServerGlobalData.IsCluster ? FALSE : TRUE;

            Status = DfsAddHandledNamespace(L"", Migrate);

            DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsAddHandledNamespace Status %x\n", Status);
        }
    }

    //
    // Now register all the stores.
    //
    if (Status == ERROR_SUCCESS) {
        Status = DfsRegisterStores();

        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsRegisterStores Status %x\n", Status);
    }


    //
    // Create our scavenge thread.
    //
    if (Status == ERROR_SUCCESS) {
        HANDLE THandle;
        DWORD Tid;
        
        THandle = CreateThread (
                     NULL,
                     0,
                     DfsWorkerThread,
                     0,
                     0,
                     &Tid);
        
        if (THandle != NULL) {
            CloseHandle(THandle);
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Created Scavenge Thread (%d) Tid\n", Tid);
        }
        else {
            Status = GetLastError();
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Failed Scavenge Thread creation, Status %x\n", Status);
        }
    }

    if(Status == ERROR_SUCCESS)
    {
        Status = DfsInitializeReflectionEngine();
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Initialize Reflection Engine, Status %x\n", Status);
    }

    if (Status == ERROR_SUCCESS)
    {
        if (DfsServerGlobalData.IsDc)
        {
            extern DFSSTATUS DfsInitializeSpecialDCShares();
            Status = DfsInitializeSpecialDCShares();
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsRegisterStores
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine registers the different stores 
//               that the referral library implements.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegisterStores(
    VOID )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if(!DfsIsMachineWorkstation())
    {
        if (Status == ERROR_SUCCESS) 
            DFS_REGISTER_STORE(Enterprise, Status);

        if (Status == ERROR_SUCCESS) 
            DFS_REGISTER_STORE(ADBlob, Status);
    }


    if (Status == ERROR_SUCCESS) 
        DFS_REGISTER_STORE(Registry, Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAddHandleNamespace
//
//  Arguments:  Name - namespace to add
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine registers the namespace, so that we handle
//               referrals to that namespace. We also migrate the DFS data
//               in the registry for the multiple root support. This 
//               happens only if the client wants to migrate DFS.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsAddHandledNamespace(
    LPWSTR Name,
    BOOLEAN Migrate )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NewName;
    
    //
    // allocate a new name, and copy the passed in string.
    //
    NewName = new WCHAR[wcslen(Name) + 1];
    if (NewName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS) {
        wcscpy( NewName, Name );


        //
        // always migrate the dfs to the new location.
        //
        if (Migrate == TRUE)
        {
            extern DFSSTATUS MigrateDfs(LPWSTR MachineName);

            Status = MigrateDfs(NewName);
        }

        //
        // Now register the passed in name.
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsRegisterName( NewName );
            if (Status == ERROR_DUP_NAME)
            {
                delete [] NewName;
                Status = ERROR_SUCCESS;
            }
        }
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsRegisterName
//
//  Arguments:  Name - name to register
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR_DUP_NAME if name is already registered.
//               ERROR status code otherwise
//
//
//  Description: This routine registers the namespace, if it is not already
//               registered.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegisterName( 
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG i;
                                                                 
    if (DfsServerGlobalData.NumberOfNamespaces > MAX_DFS_NAMESPACES) 
    { 
        Status = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        for (i = 0; i < DfsServerGlobalData.NumberOfNamespaces; i++) 
        {
            if (_wcsicmp( Name,
                          DfsServerGlobalData.HandledNamespace[i] ) == 0)
            {
                Status = ERROR_DUP_NAME;
                break;
            }
        }
        if (Status == ERROR_SUCCESS)
        {
            DfsServerGlobalData.HandledNamespace[DfsServerGlobalData.NumberOfNamespaces++] = Name;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsHandleNamespaces()
//
//  Arguments:  None
//
//  Returns:    None
//
//  Description: This routine runs through all the registered names, and
//               call the recognize method on each name.
//
//--------------------------------------------------------------------------

VOID
DfsHandleNamespaces()
{
    ULONG i;

    for (i = 0; i < DfsServerGlobalData.NumberOfNamespaces; i++) {
        DFSLOG("Calling recognize on %wS\n", 
               DfsServerGlobalData.HandledNamespace[ i ] );
        DfsRecognize( DfsServerGlobalData.HandledNamespace[ i ] );
    }
    return NOTHING;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsRecognize
//
//  Arguments:  Namespace
//
//  Returns:    None
//
//  Description: This routine passes the name to each registered store
//               by calling the StoreRecognize method. The store will
//               decide whether any roots exist on namespace, and add
//               the discovered roots to a list maintained by the store.
//
//--------------------------------------------------------------------------

VOID
DfsRecognize( LPWSTR Name )
{
    DfsStore *pStore;
    LPWSTR UseName = NULL;

    //
    // If the string is empty, we are dealing with the local case.
    // Pass a null pointer, since the underlying routines expect a
    // a valid machine, or a null pointer to represent the local case.
    //
    if (IsEmptyString(Name) == FALSE)
    {
        UseName = Name;
    }

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        DFSLOG("Calling StoreRecognizer on %wS for store %p\n", 
               Name, pStore );

        pStore->StoreRecognizer( UseName );
    }

    return NOTHING;
}

VOID
DfsSynchronize()
{
    DfsStore *pStore;

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        DFSLOG("Calling StoreSynchronizer for store %p\n", pStore );

        pStore->StoreSynchronizer();
    }

    return NOTHING;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsDumpStatistics
//
//  Arguments:  NONE
//
//  Returns:    None
//
//--------------------------------------------------------------------------

VOID
DfsDumpStatistics( )
{
    DfsStore *pStore;

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        pStore->DumpStatistics();
    }

    return NOTHING;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsWorkedThread
//
//  Arguments:  TData
//
//  Returns:    DWORD
//
//  Description: This is the scavenge thread. It sits in a loop forever,
//               waking up periodically to remove the aged referral data 
//               that had been cached during referral requests. 
//               Periodically, we call HAndleNamespaces so that the
//               namespace we know of is kept in sync with the actual
//               data in the respective metadata stores.
//
//--------------------------------------------------------------------------


DWORD ScavengeTime;

DWORD
DfsWorkerThread(LPVOID TData)
{
    DfsFolderReferralData *pRefData = NULL;
    HRESULT hr = S_OK;
    HANDLE UnusedHandle = NULL;

    static LoopCnt = 0;
    
    ScavengeTime = SCAVENGE_TIME;

    UNREFERENCED_PARAMETER(TData);

    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    UnusedHandle = CreateEvent( NULL,
                                FALSE,
                                FALSE,
                                NULL );


    DfsHandleNamespaces();

    while (TRUE) {

        DFS_TRACE_LOW( REFERRAL_SERVER, "Worker thread sleeping for %d\n", ScavengeTime);
        WaitForSingleObject(UnusedHandle, ScavengeTime);


        LoopCnt++;

        // DfsDev: need to define a better mechanism< as to how often
        // this gets to run.
        //
        DFS_TRACE_LOW( REFERRAL_SERVER, "Worker thread handling all namespaces\n");
        DfsSynchronize();
        DFS_TRACE_LOW(REFERRAL_SERVER, "Worker thread done syncing\n");

        DfsDumpStatistics();

        //
        // now run through the loaded list and pick up aged referrals.
        // and unload them.
        //
        do {
            pRefData = NULL;

            DfsRemoveReferralDataFromLoadedList( &pRefData );

            if (pRefData != NULL) {
                DfsFolder *pFolder = pRefData->GetOwningFolder();
                pFolder->RemoveReferralData( pRefData );
                pRefData->ReleaseReference();
            }
        } while ( pRefData != NULL );
        
    }

    CoUninitialize();
    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAddReferralDataToloadedList
//
//  Arguments:  pRefData
//
//  Returns:    Nothing
//
//  Description: Given the referral data that was laoded, we add it
//               to a loaded list, first acquiring a reference to 
//               it. This is effectively to keep track of the cached
//               referral data in the folders.
//
//               To scavenge the cache, we maintain this list, and we run
//               through this list periodically freeing up aged data.
//
//--------------------------------------------------------------------------
VOID
DfsAddReferralDataToLoadedList(
    DfsFolderReferralData *pRefData )
{
    //
    // we are going to save a pointer to the referral data. 
    // Acquire a reference on it
    //
    pRefData->AcquireReference();
    
    //
    // Now get a lock on the list, and add the ref data to the list
    //

    ACQUIRE_LOADED_LIST_LOCK();
    if (DfsServerGlobalData.LoadedList == NULL) {
        DfsServerGlobalData.LoadedList = pRefData;
        pRefData->pPrevLoaded = pRefData->pNextLoaded = pRefData;
    } else {
        pRefData->pNextLoaded = DfsServerGlobalData.LoadedList;
        pRefData->pPrevLoaded = DfsServerGlobalData.LoadedList->pPrevLoaded;
        DfsServerGlobalData.LoadedList->pPrevLoaded->pNextLoaded = pRefData;
        DfsServerGlobalData.LoadedList->pPrevLoaded = pRefData;
    }

    //
    // we are done, release the list lock.
    //
    RELEASE_LOADED_LIST_LOCK();
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsRemoveReferralDataFromloadedList
//
//  Arguments:  ppReferralData
//
//  Returns:    Nothing
//
//  Description: This routine picks the first entry on the loaded list
//               and removes it from the list and returns the referral
//               data. NOTE that since we are returning the pointer,
//               we do not release the reference we acquired when
//               the referral data was added to the list.
//
//               The caller is responsible for freeing up this reference.
//
//--------------------------------------------------------------------------
VOID
DfsRemoveReferralDataFromLoadedList(
    DfsFolderReferralData **ppReferralData )
{
    DfsFolderReferralData *pRefData = *ppReferralData;

    ACQUIRE_LOADED_LIST_LOCK();
    
    if (pRefData == NULL) {
        pRefData = DfsServerGlobalData.LoadedList;
    }
    if (pRefData != NULL) {
        if (pRefData->pNextLoaded == pRefData) {
            DfsServerGlobalData.LoadedList = NULL;
        } else {
            pRefData->pNextLoaded->pPrevLoaded = pRefData->pPrevLoaded;
            pRefData->pPrevLoaded->pNextLoaded = pRefData->pNextLoaded;
            if (DfsServerGlobalData.LoadedList == pRefData) {
                DfsServerGlobalData.LoadedList = pRefData->pNextLoaded;
            }
        }
    }
    *ppReferralData = pRefData;
    RELEASE_LOADED_LIST_LOCK();
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetServerInfo
//
//  Arguments:  pServer, ppInfo
//
//  Returns:    Status
//
//  Description: This routine takes a server name and returns the 
//               structure that holds the site information for that server
//
//               A referenced pointer is returned and the caller is
//               required to release the reference when done.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsGetServerInfo (
    PUNICODE_STRING pServer,
    DfsServerSiteInfo **ppInfo )
{
    return DfsServerGlobalData.pSiteSupport->GetServerSiteInfo(pServer, ppInfo );
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsReleaseServerInfo
//
//  Arguments:  pInfo
//
//  Returns:    Nothing
//
//  Description: This routine releases a server info that was earlier
//               got by calling GetServerInfo
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsReleaseServerInfo (
    DfsServerSiteInfo *pInfo)
{
    return DfsServerGlobalData.pSiteSupport->ReleaseServerSiteInfo(pInfo);
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeComputerInfo
//
//  Arguments:  NOTHING
//
//  Returns:    Status
//
//  Description: This routine initializes the computer info, which contains the domain name
//               of this computer, the netbios name and dns names of this computer.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsInitializeComputerInfo()
{
#define COMPUTER_NAME_BUFFER_SIZE 2048
    LONG BufferSize;
    LPWSTR NameBuffer;
    DFSSTATUS Status = ERROR_SUCCESS ;

    BufferSize = COMPUTER_NAME_BUFFER_SIZE;

    NameBuffer = new WCHAR [ BufferSize ];

    if (NameBuffer != NULL)
    {
        INITIALIZE_COMPUTER_INFO( ComputerNameNetBIOS, NameBuffer, BufferSize, Status );
        INITIALIZE_COMPUTER_INFO( ComputerNameDnsFullyQualified, NameBuffer, BufferSize, Status );
        INITIALIZE_COMPUTER_INFO( ComputerNameDnsDomain, NameBuffer, BufferSize, Status );

        delete [] NameBuffer;
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}


DFSSTATUS
DfsCreateRequiredOldDfsKeys(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY RootKey, DfsLocationKey, DfsVolumesKey;

    Status = RegConnectRegistry( NULL,
                                 HKEY_LOCAL_MACHINE,
                                 &RootKey );

    if(Status == ERROR_SUCCESS)
    {
        Status = RegCreateKeyEx( RootKey,     // the parent key
                                 DfsRegistryHostLocation, // the key we are creating.
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &DfsLocationKey,
                                 NULL );
        RegCloseKey(RootKey);
        
        if (Status == ERROR_SUCCESS)
        {
            Status = RegCreateKeyEx( DfsLocationKey,     // the parent key
                                     DfsVolumesLocation, // the key we are creating.
                                     0,
                                     L"",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &DfsVolumesKey,
                                     NULL );
            if (Status == ERROR_SUCCESS)
            {
                RegCloseKey(DfsVolumesKey);
            }

            RegCloseKey(DfsLocationKey);
        }
    }

    return Status;
}

DFSSTATUS
DfsCreateRequiredDfsKeys(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY RootKey, DfsLocationKey, DfsRootsKey, FlavorKey;


    Status = DfsCreateRequiredOldDfsKeys();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    Status = RegConnectRegistry( NULL,
                                 HKEY_LOCAL_MACHINE,
                                 &RootKey );

    if(Status == ERROR_SUCCESS)
    {
        Status = RegCreateKeyEx( RootKey,     // the parent key
                                 DfsRegistryDfsLocation, // the key we are creating.
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &DfsLocationKey,
                                 NULL );
        RegCloseKey(RootKey);
        
        if (Status == ERROR_SUCCESS)
        {
            Status = RegCreateKeyEx( DfsLocationKey,     // the parent key
                                     DfsRootLocation, // the key we are creating.
                                     0,
                                     L"",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &DfsRootsKey,
                                     NULL );

            RegCloseKey(DfsLocationKey);
            
            if (Status == ERROR_SUCCESS)
            {
                Status = RegCreateKeyEx( DfsRootsKey,     // the parent key
                                         DfsStandaloneChild,
                                         0,
                                         L"",
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_READ | KEY_WRITE,
                                         NULL,
                                         &FlavorKey,
                                         NULL );
                if (Status == ERROR_SUCCESS)
                {
                    RegCloseKey(FlavorKey);
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = RegCreateKeyEx( DfsRootsKey,     // the parent key
                                             DfsADBlobChild,
                                             0,
                                             L"",
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &FlavorKey,
                                             NULL );
                }

                if (Status == ERROR_SUCCESS)
                {
                    RegCloseKey(FlavorKey);
                }

                RegCloseKey( DfsRootsKey );
            }
        }
    }
    return Status;
}





DFSSTATUS
DfsGetMachineName(
    PUNICODE_STRING pName)
{
    DFSSTATUS Status;
    LPWSTR UseName;

    if (!IsEmptyString(DfsServerGlobalData.DfsMachineInfo.StaticComputerNameNetBIOS))
    {
        UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameNetBIOS;
    }
    else {
        UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsFullyQualified;
    }
    Status = DfsCreateUnicodeStringFromString( pName,
                                               UseName );

    return Status;
}

VOID
DfsReleaseMachineName( 
    PUNICODE_STRING pName )
{
    DfsFreeUnicodeString( pName );
}


DFSSTATUS
DfsGetDomainName(
    PUNICODE_STRING pName)
{
    DFSSTATUS Status;
    LPWSTR UseName;

    if (!IsEmptyString(DfsServerGlobalData.DomainNameFlat.Buffer))
    {
        UseName = DfsServerGlobalData.DomainNameFlat.Buffer;
    }
    else if (!IsEmptyString(DfsServerGlobalData.DomainNameDns.Buffer))
    {
        UseName = DfsServerGlobalData.DomainNameDns.Buffer;
    }
    else
    {
        UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsDomain;
    }
    Status = DfsCreateUnicodeStringFromString( pName,
                                               UseName );

    return Status;
}

VOID
DfsReleaseDomainName( 
    PUNICODE_STRING pName )
{
    DfsFreeUnicodeString( pName );
}



DFSSTATUS
DfsAddKnownDirectoryPath( 
    PUNICODE_STRING pDirectoryName,
    PUNICODE_STRING pLogicalShare )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    UNICODE_STRING RemainingName;
    PVOID pData;
    BOOLEAN SubStringMatch = FALSE;


    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pDirectoryPrefixTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                               pDirectoryName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );

#if 0

        //
        // Note that the following comment and the logic dont work.
        // we have an issue where someone could be adding the same share
        // once for ft and once for standalone.
        // blocking this at the api level may not be the right thing, since
        // things may be added to the registry dynamically (cluster 
        // checkpoint) and these may not come in via the API.
        //
        
        //
        // check if we have a matching name with the exact same share:
        // in that case return success.
        // In all other cases, return failure.
        // If nothing exists by this name, we try to insert in our table.
        //
        if ((NtStatus == STATUS_SUCCESS) &&
            (RemainingName.Length == 0))
        {
            PUNICODE_STRING pShare = (PUNICODE_STRING)pData;
            if (RtlCompareUnicodeString(pShare, pLogicalShare, TRUE) != 0)
            {
                NtStatus = STATUS_OBJECT_NAME_COLLISION;
            }
        }
        else 

#endif
        if ( (NtStatus == STATUS_SUCCESS) ||
             ((NtStatus != STATUS_SUCCESS) && (SubStringMatch)) )
        {
            NtStatus = STATUS_OBJECT_NAME_COLLISION;
        }
        else 
        {
            //
            // Insert the directory and share information in our
            // database.
            //
            NtStatus = DfsInsertInPrefixTableLocked(DfsServerGlobalData.pDirectoryPrefixTable,
                                                    pDirectoryName,
                                                    (PVOID)pLogicalShare);

        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pDirectoryPrefixTable );
    }
    if(NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


DFSSTATUS
DfsRemoveKnownDirectoryPath( 
    PUNICODE_STRING pDirectoryName,
    PUNICODE_STRING pLogicalShare)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    UNICODE_STRING RemainingName;
    PVOID pData;
    BOOLEAN SubStringMatch;

    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pDirectoryPrefixTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                               pDirectoryName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );
        //
        // if we found a perfect match, we can remove this
        // from the table.
        //
        if ( (NtStatus == STATUS_SUCCESS) &&
             (RemainingName.Length == 0) )
        {
            NtStatus = DfsRemoveFromPrefixTableLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                                       pDirectoryName,
                                                       (PVOID)pLogicalShare);
        }
        else
        {
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pDirectoryPrefixTable );
    }

    if (NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}



//
// Function AcquireLock: Acquires the lock on the folder
//
DFSSTATUS
DfsAcquireWriteLock(
    PCRITICAL_SECTION pLock)
{
    DFSSTATUS Status;

    __try 
    { 
        EnterCriticalSection(pLock);
        Status = ERROR_SUCCESS;
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    return Status;
}


DFSSTATUS
DfsAcquireReadLock(
    PCRITICAL_SECTION pLock)
{
    DFSSTATUS Status;

    __try 
    { 
        EnterCriticalSection(pLock);
        Status = ERROR_SUCCESS;
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    return Status;
}


DFSSTATUS
DfsAcquireDomainInfo (
    DfsDomainInformation **ppDomainInfo )
{
    DFSSTATUS Status;

    Status = DfsAcquireGlobalDataLock();
    if (Status == ERROR_SUCCESS)
    {
        *ppDomainInfo = DfsServerGlobalData.pDomainInfo;
        if (*ppDomainInfo == NULL)
        {
            Status = ERROR_NOT_READY;
        }
        else 
        {
            (*ppDomainInfo)->AcquireReference();
        }
        DfsReleaseGlobalDataLock();
    }
    
    return Status;
}

VOID
DfsReleaseDomainInfo (
    DfsDomainInformation *pDomainInfo )
{
    pDomainInfo->ReleaseReference();
    return NOTHING;
}



DFSSTATUS
DfsSetDomainNameFlat(LPWSTR DomainNameFlatString)
{

    UNICODE_STRING DomainNameFlat;

    RtlInitUnicodeString( &DomainNameFlat, DomainNameFlatString);
    return DfsCreateUnicodeString( &DfsServerGlobalData.DomainNameFlat,
                                   &DomainNameFlat );

}

DFSSTATUS
DfsSetDomainNameDns( LPWSTR DomainNameDnsString )
{
    
    UNICODE_STRING DomainNameDns;
    RtlInitUnicodeString( &DomainNameDns, DomainNameDnsString);

    return DfsCreateUnicodeString( &DfsServerGlobalData.DomainNameDns,
                                   &DomainNameDns);
}


BOOLEAN
DfsIsNameContextDomainName( PUNICODE_STRING pName )
{
    BOOLEAN ReturnValue = FALSE;

    if (pName->Length == DfsServerGlobalData.DomainNameFlat.Length)
    {
        if (_wcsnicmp(DfsServerGlobalData.DomainNameFlat.Buffer,
                      pName->Buffer, pName->Length/sizeof(WCHAR)) == 0)
        {
            ReturnValue = TRUE;
        }
    }
    else if (pName->Length == DfsServerGlobalData.DomainNameDns.Length)
    {
        if (_wcsnicmp(DfsServerGlobalData.DomainNameDns.Buffer,
                      pName->Buffer, pName->Length/sizeof(WCHAR)) == 0)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;

}

DWORD DfsReadRegistryDword( HKEY    hkey,
                            LPWSTR   pszValueName,
                            DWORD    dwDefaultValue )
{
    DWORD  dwerr = 0;
    DWORD  dwBuffer = 0;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType = 0;

    if( hkey != NULL )
    {
        dwerr = RegQueryValueEx( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( dwerr == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;
}   

BOOL DfsGetGlobalRegistrySettings(void)
{
    BOOL        fRet = TRUE;
    HKEY        hkeyDfs = NULL;
    DWORD       dwErr = 0;
    DWORD       dwDisp = 0;

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DfsParamPath, NULL, NULL,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDfs, &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        return FALSE;
    }

     DfsServerGlobalData.CacheFlushInterval = DfsReadRegistryDword(hkeyDfs, DfsWorkerThreadIntervalName, CACHE_FLUSH_INTERVAL);

    RegCloseKey(hkeyDfs);
    return fRet;
}


DFSSTATUS
DfsGetBlobDCName(
    PUNICODE_STRING pDCName )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DFSSTATUS Status;

    Status = DsGetDcName( NULL,    //computer name
                          NULL,    // domain name
                          NULL,    // domain guid
                          NULL,    // site name
                          DS_PDC_REQUIRED,
                          &pDomainControllerInfo );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCreateUnicodeStringFromString( pDCName,
                                                   &pDomainControllerInfo->DomainControllerName[2] );

        NetApiBufferFree(pDomainControllerInfo);
    }

    return Status;
}

VOID
DfsReleaseBlobDCName( 
    PUNICODE_STRING pDCName )
{
    DfsFreeUnicodeString( pDCName );
}


BOOLEAN
DfsIsTargetCurrentMachine (
    PUNICODE_STRING pServer )
{
    UNICODE_STRING MachineName;
    DFSSTATUS Status;
    BOOLEAN ReturnValue = FALSE;

    Status = DfsGetMachineName(&MachineName);

    if (Status == ERROR_SUCCESS)
    {
        if (RtlCompareUnicodeString( pServer, &MachineName, TRUE) == 0)
        {
            ReturnValue = TRUE;
        }
        DfsFreeUnicodeString( &MachineName );
    }

    return ReturnValue;
}



LPWSTR
DfsGetDfsAdNameContextString()
{
    return DfsServerGlobalData.DfsAdNameContext.Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsreferral.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsReferral.cxx
//
//  Contents:   This file contains the functionality to generate a referral
//
//
//  History:    Jan 16 2001,   Authors: RohanP/UdayH
//
//-----------------------------------------------------------------------------

#include "DfsReferral.hxx"
#include "Align.h"
#include "dfstrusteddomain.hxx"
#include "dfsadsiapi.hxx"
#include "DfsDomainInformation.hxx"
#include "DomainControllerSupport.hxx"


#include "dfsreferral.tmh" // logging

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder
//
//  Arguments:  pName - The logical name
//              pRemainingName - the name beyond the root
//              ppRoot       - the Dfs root found.
//
//  Returns:    ERROR_SUCCESS
//              Error code otherwise
//
//
//  Description: This routine runs through all the stores and looks up
//               a root with the matching name context and share name.
//               If multiple stores have the same share, the highest
//               priority store wins (the store registered first is the
//               highest priority store)
//               A referenced root is returned, and the caller is 
//               responsible for releasing the reference.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetRootFolder( 
    IN  PUNICODE_STRING pName,
    OUT PUNICODE_STRING pRemainingName,
    OUT DfsRootFolder **ppRoot )
{
    DfsStore *pStore;
    DFSSTATUS Status;
    UNICODE_STRING DfsNameContext, LogicalShare;

    // First we breakup the name into the name component, the logica
    // share and the rest of the name

    Status = DfsGetPathComponents(pName,
                                  &DfsNameContext,
                                  &LogicalShare,
                                  pRemainingName );

    // If either the name component or the logical share is empty, error.
    //
    if (Status == ERROR_SUCCESS) {
        if ((DfsNameContext.Length == 0) || (LogicalShare.Length == 0)) {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    // Assume we are not going to find a root.
    //
    Status = ERROR_NOT_FOUND;

    //
    // For each store registered, see if we find a matching root. The
    // first matching root wins.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {


        Status = pStore->LookupRoot( &DfsNameContext,
                                     &LogicalShare,
                                     ppRoot );
        if (Status == ERROR_SUCCESS) {
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder
//
//  Arguments:  pName - The logical name
//              pRemainingName - the name beyond the root
//              ppRoot       - the Dfs root found.
//
//  Returns:    ERROR_SUCCESS
//              Error code otherwise
//
//
//  Description: This routine runs through all the stores and looks up
//               a root with the matching name context and share name.
//               If multiple stores have the same share, the highest
//               priority store wins (the store registered first is the
//               highest priority store)
//               A referenced root is returned, and the caller is 
//               responsible for releasing the reference.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetOnlyRootFolder( 
    OUT DfsRootFolder **ppRoot )
{
    DfsStore *pStore;
    DFSSTATUS Status;
    DfsStore *pFoundStore = NULL;
    ULONG RootCount;
    // Assume we are not going to find a root.
    //
    Status = ERROR_NOT_FOUND;

    //
    // For each store registered, see if we find a matching root. The
    // first matching root wins.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        Status = pStore->GetRootCount(&RootCount);

        if (Status == ERROR_SUCCESS)
        {
            if ((RootCount > 1) ||
                (RootCount && pFoundStore))
            {
                Status = ERROR_DEVICE_NOT_AVAILABLE;
                break;
            }

            if (RootCount == 1)
            {
                pFoundStore = pStore;
            }
        }
        else
        {
            break;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if (pFoundStore == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        Status = pFoundStore->FindFirstRoot( ppRoot );
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupFolder
//
//  Arguments:  pName  - name to lookup
//              pRemainingName - the part of the name that was unmatched
//              ppFolder - the folder for the matching part of the name.
//
//  Returns:    ERROR_SUCCESS
//              ERROR code otherwise
//
//  Description: This routine finds the folder for the maximal path
//               that can be matched, and return the referenced folder
//               along with the remaining part of the name that had
//               no match.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsLookupFolder( 
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolder **ppFolder )
{
    DFSSTATUS Status;
    UNICODE_STRING LinkName, Remaining;
    DfsRootFolder *pRoot;
    DfsFolder *pFolder;
     
    //
    // Get a root folder
    //
    Status = DfsGetRootFolder( pName,
                               &LinkName,
                               &pRoot );
    if (Status == ERROR_SUCCESS)
    {
        //
        // we now check if the root folder is available for referral
        // requests. If not, return error.
        //
        if (pRoot->IsRootFolderAvailable() == FALSE)
        {
            Status = ERROR_DEVICE_NOT_AVAILABLE;
            pRoot->ReleaseReference();
        }
    }

    //
    // If we got a root folder, see if there is a link that matches
    // the rest of the name beyond the root.
    //
    if (Status == ERROR_SUCCESS) {
        if (LinkName.Length != 0) {
            Status = pRoot->LookupFolderByLogicalName( &LinkName,
                                                       &Remaining,
                                                       &pFolder );
        } 
        else {
            Status = ERROR_NOT_FOUND;
        }

        //
        // If no link was found beyond the root, we are interested
        // in the root folder itself. Return the root folder. 
        // If we did find a link, we have a referenced link folder.
        // Release the root and we are done.
        //
        if (Status == ERROR_NOT_FOUND) {
            pFolder = pRoot;
            Remaining = LinkName;
            Status = ERROR_SUCCESS;                
        }
        else {
            pRoot->ReleaseReference();
        }
    }

    if (Status == ERROR_SUCCESS) {
        *ppFolder = pFolder;
        *pRemainingName = Remaining;
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetReferralData
//
//  Arguments:  pName - name we are interested in.
//              pRemainingName - the name that was unmatched.
//              ppReferralData - the referral data for the matching portion.
//
//  Returns:    ERROR_SUCCESS
//              error code otherwise
//
//
//  Description: This routine looks up the folder for the passed in name,
//               and loads the referral data for the folder and returns
//               a referenced FolderReferralData to the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetReferralData( 
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit )
{
    DFSSTATUS Status;
    DfsFolder *pFolder;
    BOOLEAN CacheHit = FALSE;

    DFS_TRACE_LOW( REFERRAL_SERVER, "DfsGetReferralData Name %wZ\n", pName);

    Status = DfsLookupFolder( pName,
                              pRemainingName,
                              &pFolder );
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "get referral data, lookup folder %p, Status %x\n",
                         pFolder, Status);
    
    if (Status == ERROR_SUCCESS) {

        Status = pFolder->GetReferralData( ppReferralData,
                                           &CacheHit );

        DFS_TRACE_LOW(REFERRAL_SERVER, "Loaded %p Status %x\n",  *ppReferralData, Status );

        pFolder->ReleaseReference();
    }

    if (pCacheHit != NULL)
    {
        *pCacheHit = CacheHit;
    }
    
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "DfsGetReferralData Name %wZ Status %x\n",
                         pName, Status );

    return Status;
}


ULONG
DfsGetInterSiteCost(
    PUNICODE_STRING pSiteFrom,
    PUNICODE_STRING pSiteTo)
{
    ULONG Cost = 100;

    if ((IsEmptyString(pSiteFrom->Buffer) == FALSE) && 
        (IsEmptyString(pSiteTo->Buffer) == FALSE))
    {
        if (RtlEqualUnicodeString(pSiteFrom, pSiteTo, TRUE ))
        {
            Cost = 0;
        }
    }

    return Cost;
}



VOID
DfsShuffleReplicas(
    REPLICA_COST_INFORMATION * pReplicaCosts,
    ULONG       nStart,
    ULONG       nEnd)
{
    ULONG i = 0;
    ULONG j = 0;
    ULONG CostTemp = 0;
    DfsReplica * pTempReplica = NULL;
    LARGE_INTEGER Seed;

    NtQuerySystemTime( &Seed );

    for (i = nStart; i < nEnd; i++) 
    {

        j = (RtlRandom( &Seed.LowPart ) % (nEnd - nStart)) + nStart;

        CostTemp = (&pReplicaCosts[i])->ReplicaCost;
        pTempReplica = (&pReplicaCosts[i])->pReplica;

        (&pReplicaCosts[i])->pReplica = (&pReplicaCosts[j])->pReplica;
        (&pReplicaCosts[i])->ReplicaCost = (&pReplicaCosts[j])->ReplicaCost;

        (&pReplicaCosts[j])->pReplica = pTempReplica;
        (&pReplicaCosts[j])->ReplicaCost = CostTemp;

    }
}

VOID
DfsSortReplicas(
    REPLICA_COST_INFORMATION * pReplicaCosts, 
    ULONG NumReplicas)
{
    LONG LoopVar = 0;
    LONG InnerLoop = 0;
    ULONG CostTemp = 0;
    DfsReplica * pTempReplica = NULL;

    for (LoopVar = 1; LoopVar < (LONG) NumReplicas; LoopVar++)
    {		
        CostTemp = (&pReplicaCosts[LoopVar])->ReplicaCost;
        pTempReplica = (&pReplicaCosts[LoopVar])->pReplica;		

        for(InnerLoop = LoopVar - 1; InnerLoop >= 0; InnerLoop--)
        {
            if((&pReplicaCosts[InnerLoop])->ReplicaCost > CostTemp)
            {
                (&pReplicaCosts[InnerLoop + 1])->ReplicaCost = (&pReplicaCosts[InnerLoop])->ReplicaCost;
                (&pReplicaCosts[InnerLoop + 1])->pReplica = (&pReplicaCosts[InnerLoop])->pReplica;			
            }
            else
            {
                break;
            }
		
        }

        (&pReplicaCosts[InnerLoop + 1])->ReplicaCost = CostTemp;
        (&pReplicaCosts[InnerLoop + 1])->pReplica = pTempReplica;					
    }	
}


VOID
DfsShuffleAndSortReferralInformation(
    PREFERRAL_INFORMATION pReferralInformation )
{
    DfsShuffleReplicas( &pReferralInformation->ReplicaCosts[0], 0, pReferralInformation->NumberOfReplicas);
    DfsSortReplicas( &pReferralInformation->ReplicaCosts[0], pReferralInformation->NumberOfReplicas);
}
//+-------------------------------------------------------------------------
//
//  Function:   DfsCalculateReplicaStringLength 
//
//  Arguments:  pReferralData - the referral data
//              NumReplicasToReturn - Number of replicas to return
//              ppReplicaCosts - array of generated replica cost information
//              SiteName  - site we are currently in
//
//  Returns:    ERROR_SUCCESS
//              ERROR_NOT_ENOUGH_MEMORY
//
//
//  Description: This routine generates the cost of reaching each replica
//               
//               
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsGetReferralInformation(
    PUNICODE_STRING pUseTargetServer,
    PUNICODE_STRING pUseFolder,
    LPWSTR SiteName,
    DfsReferralData *pReferralData,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    PREFERRAL_INFORMATION *ppReferralInformation )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumReplicas = 0;
    ULONG TotalSize, SizeOfStrings;
    ULONG Cost;
    DfsReplica *pReplica = NULL;		
    PREFERRAL_INFORMATION pReferralInfo;
    UNICODE_STRING ReferralSiteName;

    //Initialize the sitename for comparisons
    RtlInitUnicodeString( &ReferralSiteName, SiteName);

    //allocate the buffer
    TotalSize = sizeof(REFERRAL_INFORMATION) + NumReplicasToReturn * sizeof(REPLICA_COST_INFORMATION);
    pReferralInfo = (PREFERRAL_INFORMATION) new BYTE[TotalSize];
    if(pReferralInfo != NULL) 
    {
        RtlZeroMemory(pReferralInfo, sizeof(REFERRAL_INFORMATION));
        pReferralInfo->pUseTargetServer = pUseTargetServer;
        pReferralInfo->pUseTargetFolder = pUseFolder;

        for (NumReplicas = 0; NumReplicas < pReferralData->ReplicaCount; NumReplicas++)
        {
            pReplica = &pReferralData->pReplicas[ NumReplicas ];
            if (pReplica->IsTargetAvailable() == TRUE)
            {
                Cost = DfsGetInterSiteCost( pReplica->GetSiteName(),
                                            &ReferralSiteName );
                if (Cost < CostLimit)
                {
                    PUNICODE_STRING pTargetServer = (pUseTargetServer == NULL)? pReplica->GetTargetServer() : pUseTargetServer;
                    PUNICODE_STRING pTargetFolder = (pUseFolder == NULL) ? pReplica->GetTargetFolder() : pUseFolder;

                    pReferralInfo->ReplicaCosts[pReferralInfo->NumberOfReplicas].ReplicaCost = Cost;
                    pReferralInfo->ReplicaCosts[pReferralInfo->NumberOfReplicas].pReplica = pReplica;

                    SizeOfStrings = (sizeof(UNICODE_PATH_SEP) +
                                     pTargetServer->Length +                                                               
                                     sizeof(UNICODE_PATH_SEP) +
                                     pTargetFolder->Length );

                    SizeOfStrings = ROUND_UP_COUNT(SizeOfStrings, ALIGN_LONG);

                    pReferralInfo->TotalReplicaStringLength += SizeOfStrings;
                    pReferralInfo->NumberOfReplicas++; 
                }
            }
        }

        DfsShuffleAndSortReferralInformation( pReferralInfo );
        if (pReferralInfo->NumberOfReplicas > NumReplicasToReturn)
        {
            pReferralInfo->NumberOfReplicas = NumReplicasToReturn;
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppReferralInformation = pReferralInfo;
    }

    return Status;
}

VOID
DfsReleaseReferralInformation(
    PREFERRAL_INFORMATION pReferralInfo )
{
    delete [] (PBYTE)(pReferralInfo);

    return NOTHING;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsExtractReplicaData -
//
//  Arguments:  pReferralData - the referral data
//              NumReplicasToReturn - Number of replicas to return
//              CostLimit - maximum cost caller is willing to accept
//              Name - link name
//              pReplicaCosts - array of replicas with cost info
//              ppReferralHeader - address of buffer to accept replica info
//
//  Returns:    Status
//               ERROR_SUCCESS 
//               ERROR_NOT_ENOUGH_MEMORY
//               others
//
//
//  Description: This routine formats the replicas into the format
//               the client expects. Which is a REFERRAL_HEADER followed
//               by an array of REPLICA_INFORMATIONs
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsExtractReferralData(
    PUNICODE_STRING pName,
    PREFERRAL_INFORMATION pReferralInformation,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumReplicas, TotalSize;
    ULONG HeaderBaseLength, BaseLength, LinkNameLength;
    PREFERRAL_HEADER pHeader = NULL;

    ULONG CurrentNameLength, CurrentEntryLength = 0;
    ULONG NextEntry = 0;


    DfsReplica *pReplica = NULL;
    PUNICODE_STRING pUseTargetFolder = pReferralInformation->pUseTargetFolder;
    PUNICODE_STRING pUseTargetServer = pReferralInformation->pUseTargetServer;
    PUCHAR ReferralBuffer = NULL;
    PUCHAR pReplicaBuffer = NULL;
    PWCHAR ReturnedName = NULL;
    PUNICODE_STRING pTargetServer, pTargetFolder;

	

    DFS_TRACE_HIGH(REFERRAL_SERVER, "Entering DfsExtractReferralData");

    //calculate size of header base structure
    HeaderBaseLength = FIELD_OFFSET( REFERRAL_HEADER, LinkName[0] );

    //calculate link name
    LinkNameLength = pName->Length;

    //calculate size of base replica structure
    BaseLength = FIELD_OFFSET( REPLICA_INFORMATION, ReplicaName[0] );

    //the total size of the data to be returned is the sum of all the
    //above calculated sizes
    TotalSize = ROUND_UP_COUNT((HeaderBaseLength + LinkNameLength), ALIGN_LONG) + 
                (pReferralInformation->NumberOfReplicas * ROUND_UP_COUNT(BaseLength, ALIGN_LONG)) + 
                pReferralInformation->TotalReplicaStringLength + 
                sizeof(DWORD);  // null termination at the end.

    //allocate the buffer
    ReferralBuffer = new BYTE[ TotalSize ];
    if (ReferralBuffer != NULL)
    {
        RtlZeroMemory( ReferralBuffer, TotalSize );

        pHeader = (PREFERRAL_HEADER) ReferralBuffer;
        pHeader->VersionNumber = CURRENT_DFS_REPLICA_HEADER_VERSION;
        pHeader->ReplicaCount = pReferralInformation->NumberOfReplicas;
        pHeader->OffsetToReplicas = ROUND_UP_COUNT((HeaderBaseLength + LinkNameLength), ALIGN_LONG);
        pHeader->LinkNameLength = LinkNameLength;
        pHeader->TotalSize = TotalSize;
        pHeader->ReferralFlags = 0;

        //copy the link name at the end of the header
        RtlCopyMemory(&ReferralBuffer[HeaderBaseLength], pName->Buffer, LinkNameLength);

        //place the replicas starting here
        pReplicaBuffer = ReferralBuffer + pHeader->OffsetToReplicas;
	
        //format the replicas in the output buffer
        for ( NumReplicas = 0; NumReplicas < pReferralInformation->NumberOfReplicas ; NumReplicas++ )
        {
            NextEntry += (ULONG)( CurrentEntryLength );
            pReplica = pReferralInformation->ReplicaCosts[NumReplicas].pReplica;

            pTargetServer = (pUseTargetServer == NULL) ? pReplica->GetTargetServer() : pUseTargetServer;

            pTargetFolder = (pUseTargetFolder == NULL) ? pReplica->GetTargetFolder() : pUseTargetFolder;

         
            CurrentNameLength = 0;
            ReturnedName = (PWCHAR) &pReplicaBuffer[NextEntry + BaseLength];

            //
            // Start with the leading path seperator
            //
            ReturnedName[ CurrentNameLength / sizeof(WCHAR) ] = UNICODE_PATH_SEP;
            CurrentNameLength += sizeof(UNICODE_PATH_SEP);

            //
            // next copy the server name.
            //
            RtlMoveMemory( &ReturnedName[ CurrentNameLength / sizeof(WCHAR) ],
                           pTargetServer->Buffer, 
                           pTargetServer->Length);
            CurrentNameLength += pTargetServer->Length;

            if (pTargetFolder->Length > 0)
            {
                //
                // insert the unicode path seperator.
                //

                ReturnedName[ CurrentNameLength / sizeof(WCHAR) ] = UNICODE_PATH_SEP;
                CurrentNameLength += sizeof(UNICODE_PATH_SEP);

                RtlMoveMemory( &ReturnedName[ CurrentNameLength / sizeof(WCHAR) ],
                               pTargetFolder->Buffer, 
                               pTargetFolder->Length);
                CurrentNameLength += pTargetFolder->Length;
            }
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaFlags = pReplica->GetReplicaFlags();
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaCost = pReferralInformation->ReplicaCosts[NumReplicas].ReplicaCost;
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaNameLength = CurrentNameLength;

            CurrentEntryLength = ROUND_UP_COUNT((CurrentNameLength + BaseLength), ALIGN_LONG);

				 
            //setup the offset to the next entry
            *((PULONG)(&pReplicaBuffer[NextEntry])) = pHeader->OffsetToReplicas + NextEntry + CurrentEntryLength;
        }
        *((PULONG)(&pReplicaBuffer[NextEntry])) = 0;
    }
    else 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppReferralHeader = pHeader;
    }


    DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "Leaving DfsExtractReferralData, Status %x",
                         Status);

    return Status;
}


#define DfsGetTimeStamp(_x) (*_x) = GetTickCount()
DFSSTATUS
DfsGenerateReferralFromData(
    PUNICODE_STRING pName,
    PUNICODE_STRING pUseTargetServer,
    PUNICODE_STRING pUseFolder,
    LPWSTR SiteName,
    DfsReferralData *pReferralData,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status;
    REFERRAL_INFORMATION *pReferralInformation;

    //make sure the user doesn't over step his bounds
    if( (NumReplicasToReturn > pReferralData->ReplicaCount) ||
        (NumReplicasToReturn == 0) )
    {
        NumReplicasToReturn = pReferralData->ReplicaCount;
    }

    Status = DfsGetReferralInformation( pUseTargetServer,
                                        pUseFolder,
                                        SiteName,
                                        pReferralData, 
                                        NumReplicasToReturn, 
                                        CostLimit,
                                        &pReferralInformation );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsExtractReferralData( pName, 
                                         pReferralInformation,
                                         ppReferralHeader);         

        if(Status == STATUS_SUCCESS)
        {
         (*ppReferralHeader)->Timeout = pReferralData->Timeout;
        }

        DfsReleaseReferralInformation( pReferralInformation );
    }

    return Status;
}



DFSSTATUS 
DfsGenerateADBlobReferral(
    PUNICODE_STRING pName,
    PUNICODE_STRING pShare,
    LPWSTR SiteName,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{

    DFSSTATUS Status;
    DfsReferralData *pReferralData;
    UNICODE_STRING ShareName;

    Status = DfsCreateUnicodeString( &ShareName, pShare );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateReferralDataFromRemoteServerNames( ShareName.Buffer,
                                                               &pReferralData );

        DfsFreeUnicodeString( &ShareName );
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsGenerateReferralFromData( pName,
                                                  NULL,
                                                  NULL,
                                                  SiteName,
                                                  pReferralData,
                                                  NumReplicasToReturn,
                                                  CostLimit,
                                                  ppReferralHeader );
            if (Status == ERROR_SUCCESS)
            {
                (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
            }
            pReferralData->ReleaseReference();
        }

    }

    return Status;
}


DFSSTATUS 
DfsGenerateDomainDCReferral(
    PUNICODE_STRING pDomainName,
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    BOOLEAN CacheHit;
    DfsDomainInformation *pDomainInfo;

    DFS_TRACE_HIGH( REFERRAL_SERVER, "DfsGenerateDomainDcReferral for Domain %wZ\n",
                    pDomainName);

	
    Status = DfsAcquireDomainInfo( &pDomainInfo );
    if (Status == ERROR_SUCCESS)
    {
        Status = pDomainInfo->GetDomainDcReferralInfo( pDomainName,
                                                       &pReferralData,
                                                       &CacheHit );

        DfsReleaseDomainInfo (pDomainInfo );
    }
                                             

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateReferralFromData( pDomainName,
                                              NULL,
                                              NULL,
                                              SiteName,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader );

        if (Status == ERROR_SUCCESS)
        {
            (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL;   
        }

        pReferralData->ReleaseReference();
    }
    return Status;
}




DFSSTATUS 
DfsGenerateNormalReferral(
    LPWSTR LinkName, 
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolderReferralData *pReferralData = NULL;
    BOOLEAN CacheHit;
    DFSSTATUS GetStatus;
    PUNICODE_STRING pUseTargetServer = NULL;
    UNICODE_STRING ServerComponent;
    DfsRootFolder *pRoot;
    UNICODE_STRING LinkRemains;
    UNICODE_STRING Name, Remaining;
    
    ULONG StartTime, EndTime;


    DFS_TRACE_HIGH( REFERRAL_SERVER, "DfsGenerateReferral for Link %ws\n",
                    LinkName);

    DfsGetTimeStamp( &StartTime );
	
    RtlInitUnicodeString(&Name, LinkName);
    Status = DfsGetReferralData( &Name,
                                 &Remaining,
                                 &pReferralData,
                                 &CacheHit );

    //
    // DFSDEV: this is necessary to support clusters: the api request will
    // neveer come to the dfs server when the VS name has failed.
    // The cluster service retries the api request with the machine name,
    // the dfs api still goes to the vs name due to the way we pack the
    // referral: this special cases clusters.
    // if the request comes in with a machine name, return the machine
    // name.
    //

    if ((Status == ERROR_SUCCESS) &&
        DfsIsMachineCluster())
    {
        Status = DfsGetFirstComponent( &Name,
                                       &ServerComponent,
                                       NULL );
        if (Status == ERROR_SUCCESS)
        {
            UNICODE_STRING MachineName;

            Status = DfsGetMachineName( &MachineName );
            if (Status == ERROR_SUCCESS) 
            {
                if ( (ServerComponent.Length == MachineName.Length) &&
                     (_wcsnicmp( ServerComponent.Buffer, 
                                 MachineName.Buffer, 
                                 MachineName.Length/sizeof(WCHAR)) == 0) )
                {
                    pUseTargetServer = &ServerComponent;
                }
                DfsReleaseMachineName( &MachineName);
            }
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Name.Length -= Remaining.Length;
        Status = DfsGenerateReferralFromData( &Name,
                                              pUseTargetServer,
                                              NULL,
                                              SiteName,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader);

        if (Status == ERROR_SUCCESS)
        {
            if (pReferralData->IsRootReferral())
            {
                (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
            }
        }

        pReferralData->ReleaseReference();         	
    }

    DfsGetTimeStamp( &EndTime );


    //
    // Get a root folder
    //
    GetStatus = DfsGetRootFolder( &Name,
                                  &LinkRemains,
                                  &pRoot );

    if (GetStatus == ERROR_SUCCESS)
    {

        pRoot->pStatistics->UpdateReferralStat( CacheHit,
                                                EndTime - StartTime,
                                                Status );
        pRoot->ReleaseReference();
    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "DfsGenerateReferral for Link %ws CacheHit %d Status %x\n",
                          LinkName, CacheHit, Status);

    return Status;	
}


DFSSTATUS 
DfsGenerateSpecialShareReferral(
    PUNICODE_STRING pName,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    BOOLEAN CacheHit;
    DfsDomainInformation *pDomainInfo;

    DFS_TRACE_HIGH( REFERRAL_SERVER, "DfsGenerateDomainDcReferral for Domain %wZ\n",
                    pDomainName);

	
    Status = DfsAcquireDomainInfo( &pDomainInfo );
    if (Status == ERROR_SUCCESS)
    {
        Status = pDomainInfo->GetDomainDcReferralInfo( pDomainName,
                                                       &pReferralData,
                                                       &CacheHit );

        DfsReleaseDomainInfo (pDomainInfo );
    }
                                             

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateReferralFromData( pName,
                                              NULL,
                                              pShareName,
                                              SiteName,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader );

        if (Status == ERROR_SUCCESS)
        {
            (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
        }

        pReferralData->ReleaseReference();
    }
    return Status;
}

DFSSTATUS 
DfsGenerateDcReferral(
    LPWSTR LinkNameString, 
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING NameContext;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    UNICODE_STRING LinkName;
    DfsDomainInformation *pDomainInfo;


    RtlInitUnicodeString( &LinkName, LinkNameString );
    RtlInitUnicodeString(&NameContext, NULL);

    if (LinkName.Length > 0)
    {
        Status = DfsGetPathComponents( &LinkName, 
                                       &NameContext,
                                       &ShareName,
                                       &RemainingName );
    }
    if (Status == ERROR_SUCCESS)
    {
        if (NameContext.Length == 0)
        {
            Status = DfsAcquireDomainInfo( &pDomainInfo );
            if (Status == ERROR_SUCCESS)
            {
                Status = pDomainInfo->GenerateDomainReferral( ppReferralHeader );
                DfsReleaseDomainInfo( pDomainInfo );
            }
        }
        else if (ShareName.Length == 0)
        {
            Status = DfsGenerateDomainDCReferral( &NameContext,
                                                  SiteName,
                                                  NumReplicasToReturn,
                                                  CostLimit,
                                                  ppReferralHeader );
        }
        else if ( (RemainingName.Length == 0) &&
                  (DfsIsNameContextDomainName(&NameContext)) )
        {
            if (DfsIsSpecialDomainShare(&ShareName))
            {
                Status = DfsGenerateSpecialShareReferral( &LinkName,
                                                          &NameContext,
                                                          &ShareName,
                                                          SiteName,
                                                          NumReplicasToReturn,
                                                          CostLimit,
                                                          ppReferralHeader );
            }
            else 
            {
                Status = DfsGenerateADBlobReferral( &LinkName,
                                                    &ShareName,
                                                    SiteName,
                                                    NumReplicasToReturn,
                                                    CostLimit,
                                                    ppReferralHeader );
            }
        }
        else 
        {
            Status = ERROR_NOT_FOUND;

        }
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetReplicaData - 
//
//  Arguments:  LinkName - pointer to link name
//              Sitename - pointer to site name.
//              NumReplicasToReturn - Number of replicas to return
//              CostLimit - maximum cost caller is willing to accept
//              ppReferralHeader - address of buffer to accept replica info
//
//  Returns:    Status
//               ERROR_SUCCESS 
//               ERROR_NOT_ENOUGH_MEMORY
//               others
//
//
//  Description: This routine extracts the replicas from the referral
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsGenerateReferral(
    LPWSTR LinkName, 
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status;

    if (DfsIsMachineDC())
    {
        Status = DfsGenerateDcReferral( LinkName,
                                        SiteName,
                                        NumReplicasToReturn,
                                        CostLimit,
                                        ppReferralHeader );

        if (Status != ERROR_NOT_FOUND)
        {
            return Status;
        }
    }

    Status = DfsGenerateNormalReferral( LinkName,
                                        SiteName,
                                        NumReplicasToReturn,
                                        CostLimit,
                                        ppReferralHeader );

    return Status;

}


VOID
DfsReleaseReferral(
    REFERRAL_HEADER *pReferralHeader)
{
    delete [] (PBYTE)pReferralHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsprocessreferral.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsProcessReferral.cxx
//
//  Contents:   Contains APIs to communicate with the filter driver   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <smbtypes.h>

#pragma warning(disable: 4200) //nonstandard extension used: zero-sized array in struct/union (line 1085
#include <smbtrans.h>
#pragma warning(default: 4200)

#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <DfsDownLevel.hxx>


//
// logging includes.
//

#include "dfsprocessreferral.tmh" 

#define _Dfs_LocalAddress 0x0100007f //localaddress (127.0.0.1)

//
// Flags used in DsGetDcName()
//

DWORD dwFlags[] = {
        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED,

        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_FORCE_REDISCOVERY
     };
       

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetSiteNameFromIpAddress 
//
//  Arguments:  DataBuffer - Buffer from the FilterDriver
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets a list of sites from the DC
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetSiteNameFromIpAddress(char * IpData, 
                            ULONG IpLength, 
                            USHORT IpFamily,
                            LPWSTR **SiteNames)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    PSOCKET_ADDRESS pSockAddr = NULL;
    PSOCKADDR_IN pSockAddrIn = NULL;
    DWORD cRetry = 0;
    SOCKET_ADDRESS SockAddr;
    SOCKADDR_IN SockAddrIn;


    //setup the socket structures in order to call DsAddressToSiteNames
    pSockAddr = &SockAddr;
    pSockAddr->iSockaddrLength = sizeof(SOCKADDR_IN);
    pSockAddr->lpSockaddr = (LPSOCKADDR)&SockAddrIn;
    pSockAddrIn = &SockAddrIn;
    pSockAddrIn->sin_family = IpFamily;
    pSockAddrIn->sin_port = 0;
    RtlCopyMemory(
                &pSockAddrIn->sin_addr,
                IpData,
                (IpLength & 0xff));


    //
    // Call DsGetDcName() with ever-increasing urgency, until either
    // we get a good DC or we just give up.
    //

    for (cRetry = 0; cRetry <= (sizeof(dwFlags) / sizeof(dwFlags[1])); cRetry++)
    {
        DFS_TRACE_HIGH(REFERRAL_SERVER, "Calling DsGetDc\n");


        Status = DsGetDcName(
                            NULL,             // Computer to remote to
                            NULL,             // Domain - use local domain
                            NULL,             // Domain Guid
                            NULL,             // Site Guid
                            dwFlags[cRetry],  // Flags
                            &pDCInfo);

        DFS_TRACE_HIGH(REFERRAL_SERVER, "Calling GetSiteName\n");

        if (Status == ERROR_SUCCESS) 
        {
            Status = DsAddressToSiteNames(
                                pDCInfo->DomainControllerAddress,
                                1,
                                pSockAddr,
                                SiteNames);

            NetApiBufferFree( pDCInfo );

            if (Status == ERROR_SUCCESS) 
            {
               goto Exit;
            }
        }
    }

    DFS_TRACE_HIGH(REFERRAL_SERVER, "Donewith Sites\n");

Exit:

    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetLocalReferrelInfo 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Calls DsGetSiteName to get the local site and then gets
//               the referrels for that site
//
//--------------------------------------------------------------------------

DFSSTATUS DfsGetLocalReferrelInfo(PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest, REFERRAL_HEADER **pReferral)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR SiteName = NULL;
    REFERRAL_HEADER *pLocalReferral = NULL;

    Status = DsGetSiteName( NULL,
                            &SiteName );

    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    //get the referral data
    Status = DfsGenerateReferral( pGetReplicaRequest->RepInfo.LinkName,
                                  SiteName,
                                  pGetReplicaRequest->RepInfo.NumReplicasToReturn,
                                  pGetReplicaRequest->RepInfo.CostLimit,
                                  &pLocalReferral );
Exit:
    
    if(SiteName != NULL)
    {
        NetApiBufferFree(SiteName);
    }

    *pReferral = pLocalReferral;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRemoteReferrelInfo 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Calls DsAddressToSiteNames to get the local site and then gets
//               the referrels for that site
//
//--------------------------------------------------------------------------
DFSSTATUS DfsGetRemoteReferrelInfo(PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest, REFERRAL_HEADER **pReferral)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    REFERRAL_HEADER *pLocalReferral = NULL;
    LPWSTR *SiteNamesArray = NULL;
    LPWSTR SiteName = NULL;

    unsigned char *IpAddr = (unsigned char *)pGetReplicaRequest->RepInfo.IpData;

    DFS_TRACE_HIGH(REFERRAL_SERVER, "Remote referral request from %d:%d:%d:%d\n", 
                   IpAddr[0],                  
                   IpAddr[1],
                   IpAddr[2],
                   IpAddr[3]);

    Status = DfsGetSiteNameFromIpAddress(pGetReplicaRequest->RepInfo.IpData,
                                         pGetReplicaRequest->RepInfo.IpLength, 
                                         pGetReplicaRequest->RepInfo.IpFamily,
                                         &SiteNamesArray);


    if ( (Status == ERROR_SUCCESS)  &&
         (SiteNamesArray != NULL) )
    {
        SiteName = SiteNamesArray[0];
    }


    //get the referral data
    Status = DfsGenerateReferral( pGetReplicaRequest->RepInfo.LinkName,
                                  SiteName,
                                  pGetReplicaRequest->RepInfo.NumReplicasToReturn,
                                  pGetReplicaRequest->RepInfo.CostLimit,
                                  &pLocalReferral );


    *pReferral = pLocalReferral;

    if (SiteNamesArray != NULL) 
    {
        NetApiBufferFree(SiteNamesArray);
    }

    return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessGetReplicaData 
//
//  Arguments:  DataBuffer - Buffer from the FilterDriver
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets the replica information from server
//               and places the results in the given buffer
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsProcessGetReplicaData(HANDLE hDriverHandle, PBYTE DataBuffer)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    ULONG IpAddress = 0;
    ULONG ReturnedDataSize = 0;
    REFERRAL_HEADER *pReferral = NULL;
    PUMRX_USERMODE_WORKITEM pProtocolWorkItem = NULL;
    PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest = NULL;
    struct sockaddr_in IncommingClient;

    pProtocolWorkItem = (PUMRX_USERMODE_WORKITEM) DataBuffer;

    //get the request
    pGetReplicaRequest = &((PUMRX_USERMODE_WORKITEM)(DataBuffer))->WorkRequest.GetDfsReplicasRequest;

    //get the site ip address in a CPU independant manner. First copy the
    //ipaddress into a winsock structure, then access the ip address from
    //a fields in that structure. Need to look into IPV6 structures.
    CopyMemory(&IncommingClient.sin_addr, pGetReplicaRequest->RepInfo.IpData,
               pGetReplicaRequest->RepInfo.IpLength);

    IpAddress = IncommingClient.sin_addr.s_addr;

    //get the referral using the local sitename or the remote sitename
    if((IpAddress == _Dfs_LocalAddress) && (pGetReplicaRequest->RepInfo.IpLength == 4))
    {
        //if this is the loopback address (127.0.0.1), handle it accordingly
        Status = DfsGetLocalReferrelInfo(pGetReplicaRequest, &pReferral);
    }
    else
    {
        Status = DfsGetRemoteReferrelInfo(pGetReplicaRequest, &pReferral);
    }

    //if we were successful in getting the referral list, then
    //we need to process the list.  
    if(Status == ERROR_SUCCESS)
    {
        //if this request came from an old DFS server, process
        //the request accordingly
        if(pGetReplicaRequest->RepInfo.Flags & DFS_OLDDFS_SERVER)
        {
            Status = ProcessOldDfsServerRequest(hDriverHandle, pProtocolWorkItem, pGetReplicaRequest, pReferral, &ReturnedDataSize);
        }
        else
        {
            //else this must be a new DFS server. Just return the info
            ReturnedDataSize = pReferral->TotalSize;

            //RtlCopyMemory(pBuffer, pReferral, ReturnedDataSize);
        }
    }

    //if we were successful, then setup the returned data
    //if(Status == ERROR_SUCCESS)
    //{
      //  ((PUMRX_USERMODE_WORKITEM)(DataBuffer))->WorkResponse.GetDfsReplicasResponse.Length = ReturnedDataSize;
    //}


    if(pReferral != NULL)
    {
        DfsReleaseReferral(pReferral);
        pReferral = NULL;
    }

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsADfsLink 
//
//  Arguments:  DataBuffer - Buffer from the FilterDriver
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This fuction tries to get the folder represented by the
//               passed in name. 
//
//--------------------------------------------------------------------------
DFSSTATUS IsADfsLink(PBYTE pRequest)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolder *pFolder = NULL;
    PUMR_ISDFSLINK_REQ pIsLinkReq = NULL;
    UNICODE_STRING Name;
    UNICODE_STRING RemainingName;

    //get the request
    pIsLinkReq = &((PUMRX_USERMODE_WORKITEM)(pRequest))->WorkRequest.IsDfsLinkRequest;
    Name.Length = Name.MaximumLength = (USHORT) pIsLinkReq->Length;
    Name.Buffer = (PWSTR) pIsLinkReq->Buffer;

    if((Name.Buffer == NULL) || (Name.Length == 0))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    Status = DfsLookupFolder( &Name,
                              &RemainingName,
                              &pFolder );

    if(Status == ERROR_SUCCESS)
    {
        pFolder->ReleaseReference();
    }

Exit:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsregistryrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRegistryRootFolder.cxx
//
//  Contents:   the Root DFS Folder class for Registry Store
//
//  Classes:    DfsRegistryRootFolder
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsRegistryRootFolder.hxx"
#include "DfsReplica.hxx"

#include "lmdfs.h"
#include "DfsClusterSupport.hxx"
//
// logging specific includes
//
#include "DfsRegistryRootFolder.tmh" 

//+----------------------------------------------------------------------------
//
//  Class:      DfsRegistryRootFolder
//
//  Synopsis:   This class implements The Dfs Registry root folder.
//
//-----------------------------------------------------------------------------




//+-------------------------------------------------------------------------
//
//  Function:   DfsRegistryRootFolder - constructor
//
//  Arguments:    NameContext -  the dfs name context
//                pLogicalShare -  the logical share
//                pParentStore -  the parent store for this root.
//                pStatus - the return status
//
//  Returns:    NONE
//
//  Description: This routine initializes a RegistryRootFolder instance
//
//--------------------------------------------------------------------------

DfsRegistryRootFolder::DfsRegistryRootFolder(
    LPWSTR NameContext,
    LPWSTR pRootRegKeyNameString,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRegistryStore *pParentStore,
    DFSSTATUS *pStatus ) :  DfsRootFolder ( NameContext,
                                            pRootRegKeyNameString,
                                            pLogicalShare,
                                            pPhysicalShare,
                                            DFS_OBJECT_TYPE_REGISTRY_ROOT_FOLDER,
                                            pStatus )
{
    DFSSTATUS Status = *pStatus;

    _pStore = pParentStore;
    if (_pStore != NULL)
    {
        _pStore->AcquireReference();
    }

    //
    // If the namecontext that we are passed is an emptry string,
    // then we are dealing with the referral server running on the root
    // itself. We are required to ignore the name context for such
    // roots during lookups, so that aliasing works. (Aliasing is where
    // someone may access the root with an aliased machine name or ip
    // address)
    //
    if (IsEmptyString(NameContext) == TRUE)
    {
        SetIgnoreNameContext();
        _LocalCreate = TRUE;
    }

    //
    // dfsdev: If this is cluster resource, we should set the visible name
    // to virtual server name of this resource.
    //
    // The constructor for DfsRootFolder will be called before we
    // get here, and pstatus will be initialized
    //
    if (Status == ERROR_SUCCESS) 
    {
        if (DfsIsMachineCluster())
        {
            GetRootClusterInformation( pLogicalShare, 
                                       &_DfsVisibleContext);
        }
        if (IsEmptyString(_DfsVisibleContext.Buffer))
        {
            Status = DfsGetMachineName( &_DfsVisibleContext );
        }
    }

    *pStatus = Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   Synchronize
//
//  Arguments:    None
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine synchronizes the children folders
//               of this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryRootFolder::Synchronize( )
{

    DFSSTATUS Status;
    HKEY RootKey;
    ULONG ChildNum = 0;
    FILETIME LastModifiedTime;

    DFS_TRACE_HIGH(REFERRAL_SERVER, "Synchronize for %p\n", this);


    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (CheckRootFolderSkipSynchronize() == TRUE)
    {
        ReleaseRootLock();
        return ERROR_SUCCESS;
    }


    //
    // now acquire the root share directory. If this
    // fails, we continue our operation: we can continue
    // with synchonize and not create directories.
    // dfsdev:we need to post a eventlog or something when
    // we run into this.
    //
    DFSSTATUS RootStatus = AcquireRootShareDirectory();

    DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize Dfs: Root folder for %p, validate status %x\n",
                        this, RootStatus );


    //
    // if we are in a standby mode, we dont synchronize, till we obtain 
    // ownership again.
    //

    Status = GetMetadataKey( &RootKey );

    if ( Status == ERROR_SUCCESS )
    {

        do
        {
            //
            // For each child, get the child name.
            //

            DWORD ChildNameLen = DFS_REGISTRY_CHILD_NAME_SIZE_MAX;
            WCHAR ChildName[DFS_REGISTRY_CHILD_NAME_SIZE_MAX];

            Status = RegEnumKeyEx( RootKey,
                                   ChildNum,
                                   ChildName,
                                   &ChildNameLen,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &LastModifiedTime );

            ChildNum++;

            //
            // Call update on the child. This either adds a new folder
            // or if it exists, ensure the child folder is upto date.
            //
            if ( Status == ERROR_SUCCESS )
            {
                DFS_METADATA_HANDLE DfsHandle;

                DfsHandle = CreateMetadataHandle(RootKey);

                Status = UpdateLinkInformation( DfsHandle,
                                                ChildName );

                DestroyMetadataHandle(DfsHandle );
            }
            //  
            // If the child is holding information we dont understand, just
            // skip that child.
            //
            if ( Status == ERROR_INVALID_DATA )
            {
                DFSLOG("DfsREgistryRootFolder: synchronize: skipping child %wS\n", ChildName );
                Status = ERROR_SUCCESS;
            }

        } while ( Status == ERROR_SUCCESS );

        if ( Status == ERROR_NO_MORE_ITEMS )
        {
            Status = ERROR_SUCCESS;
        }

        //
        // We are done with synchronize.
        // update the Root folder, so that this root folder may be made 
        // either available or unavailable, as the case may be.
        //
        if (Status == ERROR_SUCCESS)
        {
            SetRootFolderSynchronized();
        }
        else
        {
            ClearRootFolderSynchronized();
        }

        //
        // Now release the Root metadata key.
        //
        ReleaseMetadataKey( RootKey );
    }

    DFS_TRACE_HIGH(REFERRAL_SERVER, "Synchronize for %p, Status %x\n", this, Status);

    ReleaseRootLock();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRootFolder.cxx
//
//  Contents:   implements the base DFS Folder class
//
//  Classes:    DfsRootFolder.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsRootFolder.hxx"
#include "dfsfilterapi.hxx"
#include "rpc.h"
#include "rpcdce.h"
#include "DfsStore.hxx"
#include "DelegationControl.hxx"
//
// logging includes.
//

#include "DfsRootFolder.tmh" 

#define FILETIMETO64(_f) (*(UINT64 *)(&(_f)))
//+-------------------------------------------------------------------------
//
//  Function:   DfsRootFolder - Contstruct for the rootFolder class
//
//  Arguments:  NameContext -  the Dfs Name context
//              pLogicalShare - the Logical Share name
//              ObType - the object type. Set to the derived class type.
//              pStatus - status of this call.
//
//  Returns:    NONE
//
//  Description: This routine initializes the class variables of the
//               the root folder, and initialize the name context and 
//               logical share name to the passed in values.
//               It also allocated and initializes the lock for the root
//               folder, as well as all the locks that will be assigned
//               to the child folders.
//               We then create a metadata name table and a logical namespace
//               prefix table.
//
//--------------------------------------------------------------------------
DfsRootFolder::DfsRootFolder(
    IN LPWSTR NameContext,
    IN LPWSTR RootRegKeyNameString,
    IN PUNICODE_STRING pLogicalShare,
    IN PUNICODE_STRING pPhysicalShare,
    IN DfsObjectTypeEnumeration ObType,
    OUT DFSSTATUS *pStatus ) : DfsFolder (NULL, 
                                          NULL, 
                                          ObType )
{
    ULONG LockNum;
    DFSSTATUS Status = ERROR_SUCCESS;

    RtlInitUnicodeString( &_DfsNameContext, NULL );
    RtlInitUnicodeString( &_LogicalShareName, NULL );
    RtlInitUnicodeString( &_RootRegKeyName, NULL );
    RtlInitUnicodeString( &_PhysicalShareName, NULL );
    RtlInitUnicodeString( &_ShareFilePathName, NULL );
    RtlInitUnicodeString( &_DirectoryCreateRootPathName, NULL );
    RtlInitUnicodeString( &_DfsVisibleContext, NULL );


    _DirectoryCreateError = STATUS_SUCCESS;

    _pMetadataNameTable = NULL;
    _pLogicalPrefixTable = NULL;
    _IgnoreNameContext = FALSE;
    _CreateDirectories = FALSE;
    pStatistics = NULL;
    _pChildLocks = NULL;

    _ChildCount = 0;

    _CurrentErrors = 0;

    _RootFlags = 0;
    
    Status = DfsCreateUnicodeStringFromString( &_DfsNameContext, NameContext );

    if ( Status == ERROR_SUCCESS )
    {
        DfsGetNetbiosName( &_DfsNameContext, &_DfsNetbiosNameContext, NULL );

        Status = DfsCreateUnicodeString( &_LogicalShareName, pLogicalShare );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsCreateUnicodeStringFromString( &_RootRegKeyName,
                                                   RootRegKeyNameString );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsCreateUnicodeString( &_PhysicalShareName,
                                         pPhysicalShare );
    }


    if ( Status == ERROR_SUCCESS )
    {
        pStatistics = new DfsStatistics();

        if (pStatistics == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        _pRootLock = new CRITICAL_SECTION;
        if ( _pRootLock == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if ( Status == ERROR_SUCCESS )
    {
        InitializeCriticalSection( _pRootLock );
    }
    if ( Status == ERROR_SUCCESS )
    {
        _pLock = new CRITICAL_SECTION;
        if ( _pLock == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        InitializeCriticalSection( _pLock );

        _Flags = DFS_FOLDER_ROOT;

        //
        // Allocate the child locks, and initiailize them.
        //
        _pChildLocks = new CRITICAL_SECTION[ NUMBER_OF_SHARED_LINK_LOCKS ];
        if ( _pChildLocks != NULL )
        {
            for ( LockNum = 0; LockNum < NUMBER_OF_SHARED_LINK_LOCKS; LockNum++ )
            {
                InitializeCriticalSection( &_pChildLocks[LockNum] ); 
            }
        } else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;       
        }
    }

    //
    // Initialize the prefix and nametable for this root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsInitializePrefixTable( &_pLogicalPrefixTable,
                                           FALSE, 
                                           NULL );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsInitializeNameTable( 0, &_pMetadataNameTable );
    }


    //
    // We have not assigned any of the child locks: set the lock index 
    // to 0. This index provides us a mechanism of allocating locks
    // to the child folders in a round robin way.
    //
    _ChildLockIndex = 0;
    
    _LocalCreate = FALSE;

    pPrevRoot = pNextRoot = NULL; 

    *pStatus = Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateLinkFolder - Create a DfsFolder and initialize it.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              ppChildFolder -  the returned child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine Creates a link folder and adds it to the
//               parent Root's table.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::CreateLinkFolder(
    IN LPWSTR ChildName,
    IN PUNICODE_STRING pLinkName,
    OUT DfsFolder **ppChildFolder )
{
    DfsFolder *pChildFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    const TCHAR * apszSubStrings[4];

    DFS_TRACE_LOW( REFERRAL_SERVER, "Create Link Folder: MetaName %ws, Link %wZ\n",
                   ChildName, pLinkName );

    //
    // Create a new child folder. Allocate a lock for this child
    // and pass the lock along to the Folder constructor.
    //
    pChildFolder = new DfsFolder (this,
                                  GetChildLock() );

    if ( pChildFolder == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } else
    {
        //
        // We successfully created the folder. Now set the metadata
        // and logical name of the child folder.
        //
        Status = pChildFolder->InitializeMetadataName( ChildName );
        if ( Status == ERROR_SUCCESS )
        {
            Status = pChildFolder->InitializeLogicalName( pLinkName );
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        //
        // We now acquire the child folder's write lock, and insert
        // the child into the parent's metadata and logical namespace
        // tables.
        // When adding/removing the child in one of these tables,
        // it is necessary to acquire the child folder lock since 
        // we are setting state in the folder indicating whether the
        // child is in any of these tables.
        //

        Status = pChildFolder->AcquireWriteLock();

        if ( Status == ERROR_SUCCESS )
        {
            Status = InsertLinkFolderInMetadataTable( pChildFolder );

            if ( Status == ERROR_SUCCESS )
            {
                IncrementChildCount();
                Status = InsertLinkFolderInLogicalTable( pChildFolder );
            }

            pChildFolder->ReleaseLock();
        }
    }



    if (Status == ERROR_SUCCESS)
    {
        DFSSTATUS CreateStatus;

        CreateStatus = SetupLinkReparsePoint( pChildFolder->GetFolderLogicalNameString() );

        if(CreateStatus != STATUS_SUCCESS)
        {
            CreateStatus = RtlNtStatusToDosError(CreateStatus);
            apszSubStrings[0] = GetFolderLogicalNameString();
            apszSubStrings[1] = GetDirectoryCreatePathName()->Buffer;
            GenerateEventLog(DFS_ERROR_CREATE_REPARSEPOINT_FAILURE,
                             2,
                             apszSubStrings,
                             CreateStatus);
        }

        DFS_TRACE_ERROR_LOW(CreateStatus, REFERRAL_SERVER, "Setup link reparse point child %p, link %wZ, Status %x\n",
                            pChildFolder, pLinkName, Status);
    }

    //
    // If we are successful, return the newly created child folder.
    // We currently have a reference on the folder (the reference on 
    // the folder when the folder was created)
    //
    // If we encountered an error, and the childFolder has been created,
    // get rid of out reference on this folder. This will usually 
    // destroy the childFolder.
    //
    //
    if ( Status == ERROR_SUCCESS )
    {
        *ppChildFolder = pChildFolder;

        pStatistics->UpdateLinkAdded();
        
    } else
    {
        if ( pChildFolder != NULL )
        {
            pChildFolder->ReleaseReference();;
        }
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Create Link Folder: MetaName %ws, Child %p Status %x\n",
                   ChildName, pChildFolder, Status );

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   UpdateLinkFolder - Update a DfsFolder.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              pChildFolder -  the child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::UpdateLinkFolder(
    IN LPWSTR ChildName,
    IN PUNICODE_STRING pLinkName,
    IN DfsFolder *pChildFolder )
{
    BOOLEAN Removed;

    UNREFERENCED_PARAMETER(ChildName);
    UNREFERENCED_PARAMETER(pLinkName);


    pChildFolder->RemoveReferralData( NULL, &Removed );

    pStatistics->UpdateLinkModified();
    if (Removed == TRUE)
    {
        pStatistics->UpdateForcedCacheFlush();
    }
    //
    // Create directories too. Delete old directories.
    //
    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveAllLinkFolders - Remove all folders of this root
//
//  Arguments:  None
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveAllLinkFolders(
    BOOLEAN IsPermanent)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolder *pChildFolder;
    ULONG Count = 0;

    while (Status == ERROR_SUCCESS)
    {
        Status = LookupFolder(&pChildFolder);
        if (Status == ERROR_SUCCESS)
        {
            Status = RemoveLinkFolder(pChildFolder,
                                      IsPermanent);

            pChildFolder->ReleaseReference();
            Count++;
        }
    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Remove all link folders Count %d Status %x\n", 
                          Count, 
                          Status);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   RemoveLinkFolder - Update a DfsFolder.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              pChildFolder -  the child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveLinkFolder(
    IN DfsFolder *pChildFolder,
    BOOLEAN IsPermanent )
{

    DFSSTATUS Status = ERROR_SUCCESS;


    if (IsPermanent == TRUE)
    {
        //
        // try to tear down the link reparse point: return status ignored.
        //
        Status = TeardownLinkReparsePoint( pChildFolder->GetFolderLogicalNameString() );

        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Tear down reparse for %p, status %x \n", pChildFolder, Status );
    }

    Status = pChildFolder->AcquireWriteLock();

    if ( Status == ERROR_SUCCESS )
    {
        Status = RemoveLinkFolderFromMetadataTable( pChildFolder );

        if ( Status == ERROR_SUCCESS )
        {
            DecrementChildCount();
            Status = RemoveLinkFolderFromLogicalTable( pChildFolder );
        }

        pChildFolder->ReleaseLock();
    }


    if (Status == ERROR_SUCCESS)
    {
        pStatistics->UpdateLinkDeleted();
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Remove Link Folder %p, status %x \n", pChildFolder, Status );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   OpenLinkDirectory
//
//  Arguments:  DirectoryName - the full pathname to directory being created.
//              ShareMode     - the share mode (share all or share none)
//              pDirHandle    - pointer to return the opened handle
//              pIsNewlyCreated - was the directory created or existing.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes an NT pathname to the directory 
//               representing the DFS link, and opens it, creating it
//               if it was not already existing.
//               It returns the open handle to the directory, and also
//               returns an indication whether a new directory was 
//               created or an existing directory was opened.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::OpenLinkDirectory(
    LPWSTR DirectoryName,
    ULONG ShareMode,
    PHANDLE pDirHandle,
    PBOOLEAN pIsNewlyCreated )
{

    NTSTATUS                    NtStatus;
    // NtCreateFile
    OBJECT_ATTRIBUTES           ObjectAttributes;
    ACCESS_MASK                 DesiredAccess;
    PLARGE_INTEGER              AllocationSize;
    ULONG                       FileAttributes;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    PVOID                       EaBuffer;
    ULONG                       EaLength;
    UNICODE_STRING              ObjectName;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitUnicodeString(&ObjectName, DirectoryName );
    

    AllocationSize             = NULL;
    FileAttributes             = FILE_ATTRIBUTE_NORMAL;
    CreateDisposition          = FILE_OPEN_IF;
    CreateOptions              = FILE_DIRECTORY_FILE |
                                 FILE_OPEN_REPARSE_POINT;

    EaBuffer                   = NULL;
    EaLength                   = 0;


    DesiredAccess              = FILE_READ_DATA | 
                                 FILE_WRITE_DATA |
                                 FILE_READ_ATTRIBUTES | 
                                 FILE_WRITE_ATTRIBUTES;


    InitializeObjectAttributes (
        &ObjectAttributes,
        &ObjectName,
        0,
        NULL,
        NULL);

    NtStatus = NtCreateFile(pDirHandle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,
                            FileAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            EaBuffer,
                            EaLength);
    
    DFSLOG("Open on %wS: Status %x\n", DirectoryName, NtStatus);

    if (NtStatus == STATUS_SUCCESS)
    {
        *pIsNewlyCreated = (IoStatusBlock.Information == FILE_CREATED)? TRUE : FALSE;
    }

    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsDirectoryReparsePoint
//
//  Arguments:  DirHandle - handle to open directory.
//              pReparsePoint - returned boolean: true if this directory is
//              a reparse point
//              pDfsReparsePoint - returned boolean: true if this 
//              directory is a dfs reparse point
//                          
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               sets 2 booleans to indicate if this directory is a
//               reparse point, and if so, if this directory is a dfs
//               reparse point. The booleans are initialized if this
//               function returns success.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::IsDirectoryReparsePoint(
    IN  HANDLE DirHandle,
    OUT PBOOLEAN pReparsePoint,
    OUT PBOOLEAN pDfsReparsePoint )
{
    NTSTATUS NtStatus;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    //we assume these are not reparse points.
    //
    *pReparsePoint = FALSE;
    *pDfsReparsePoint = FALSE;

    //
    // Query for the basic information, which has the attributes.
    //
    NtStatus = NtQueryInformationFile( DirHandle,
                                     &IoStatusBlock,
                                     (PVOID)&BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (NtStatus == STATUS_SUCCESS)
    {
        //
        // If the attributes indicate reparse point, we have a reparse
        // point directory on our hands.
        //
        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) 
        {
            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            *pReparsePoint = TRUE;
            
            NtStatus = NtQueryInformationFile( DirHandle,
                                               &IoStatusBlock,
                                               (PVOID)&FileTagInformation,
                                               sizeof(FileTagInformation),
                                               FileAttributeTagInformation );

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Checkif the tag indicates its a DFS reparse point,
                // and setup the return accordingly.
                //
                if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_DFS)
                {
                    *pDfsReparsePoint = TRUE;
                }
            }
        }
    }

    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetDfsReparsePoint
//
//  Arguments:  DirHandle - handle on open directory
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               makes that directory a reparse point with the DFS tag
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::SetDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus;
    REPARSE_DATA_BUFFER         ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    

    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   ClearDfsReparsePoint
//
//  Arguments:  DirHandle - handle on open directory
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               makes that directory a reparse point with the DFS tag
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::ClearDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus;
    REPARSE_DATA_BUFFER         ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DELETE_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    
    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   MorphLinkCollision
//
//  Arguments:  DirectoryName - Name of directory to morph.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a NT pathname to a directory. It
//               renames that directory with a morphed name.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::MorphLinkCollision( 
    LPWSTR DirectoryName )
{
    UNREFERENCED_PARAMETER(DirectoryName);
    return STATUS_NOT_SUPPORTED;
}



DFSSTATUS
DfsRootFolder::TeardownLinkReparsePoint(
    LPWSTR LinkNameString )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE DirectoryHandle;
    UNICODE_STRING LinkName;
    BOOLEAN ImpersonationDisabled = FALSE;

    DfsDisableRpcImpersonation(&ImpersonationDisabled);
    if (IsRootFolderShareAcquired() == TRUE)
    {

        RtlInitUnicodeString( &LinkName, LinkNameString);

        NtStatus = OpenDirectory ( GetDirectoryCreatePathName(),
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                   NULL,
                                   &DirectoryHandle,
                                   NULL );

        if (NtStatus == STATUS_SUCCESS)
        {
            NtStatus = DeleteLinkReparsePoint( &LinkName,
                                               DirectoryHandle );

            CloseDirectory( DirectoryHandle );
        }
    }
    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }

    return NtStatus;
}



DFSSTATUS
DfsRootFolder::SetupLinkReparsePoint(
    LPWSTR LinkNameString )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    HANDLE DirectoryHandle;
    UNICODE_STRING LinkName;
    BOOLEAN ImpersonationDisabled = FALSE;

    DfsDisableRpcImpersonation(&ImpersonationDisabled);
    if (IsRootFolderShareAcquired() == TRUE)
    {

        RtlInitUnicodeString( &LinkName, LinkNameString);

        NtStatus = OpenDirectory ( GetDirectoryCreatePathName(),
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                   NULL,
                                   &DirectoryHandle,
                                   NULL );

        if (NtStatus == STATUS_SUCCESS)
        {
            NtStatus = CreateLinkReparsePoint( &LinkName,
                                               DirectoryHandle );

            CloseDirectory( DirectoryHandle );
        }

        if (NtStatus != STATUS_SUCCESS)
        {
            SetLastCreateDirectoryError(NtStatus);
        }
    }
    if (ImpersonationDisabled)
    {
        DfsReEnableRpcImpersonation();
    }

    return NtStatus;

}



NTSTATUS
DfsRootFolder::OpenDirectory(
    PUNICODE_STRING pDirectoryName,
    ULONG ShareMode,
    HANDLE RelativeHandle,
    PHANDLE pOpenedHandle,
    PBOOLEAN pIsNewlyCreated )
{

    NTSTATUS                    NtStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    ACCESS_MASK                 DesiredAccess;
    PLARGE_INTEGER              AllocationSize;
    ULONG                       FileAttributes;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    IO_STATUS_BLOCK IoStatusBlock;

    AllocationSize             = NULL;
    FileAttributes             = FILE_ATTRIBUTE_NORMAL;
    CreateDisposition          = FILE_OPEN_IF;
    CreateOptions              = FILE_DIRECTORY_FILE |
                                 FILE_OPEN_REPARSE_POINT |
                                 FILE_SYNCHRONOUS_IO_NONALERT;

    DesiredAccess              = FILE_READ_DATA | 
                                 FILE_WRITE_DATA |
                                 FILE_READ_ATTRIBUTES | 
                                 FILE_WRITE_ATTRIBUTES |
                                 SYNCHRONIZE;

    InitializeObjectAttributes (
        &ObjectAttributes, 
        pDirectoryName,              //Object Name
        0,                           //Attributes
        RelativeHandle,              //Root handle
        NULL);                       //Security descriptor.

    NtStatus = NtCreateFile(pOpenedHandle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,
                            FileAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,                // EaBuffer
                            0 );                 // EaLength

    
    DFSLOG("Open on %wZ: Status %x\n", pDirectoryName, NtStatus);

    if ( (NtStatus == STATUS_SUCCESS)  && (pIsNewlyCreated != NULL) )
    {
        *pIsNewlyCreated = (IoStatusBlock.Information == FILE_CREATED)? TRUE : FALSE;
    }

    return NtStatus;
}



NTSTATUS
DfsRootFolder::CreateLinkReparsePoint(
    PUNICODE_STRING pLinkName,
    HANDLE RelativeHandle )
{

    NTSTATUS NtStatus;
    ULONG    ShareMode = 0;
    HANDLE DirectoryHandle;
    BOOLEAN IsNewlyCreated;
    DFSSTATUS DosStatus;

    NtStatus = OpenDirectory( pLinkName,
                              ShareMode,
                              RelativeHandle,
                              &DirectoryHandle,
                              &IsNewlyCreated );

    if (NtStatus != STATUS_SUCCESS)
    {
        NtStatus = CreateLinkDirectories( pLinkName,
                                          RelativeHandle,
                                          &DirectoryHandle,
                                          &IsNewlyCreated );
    }
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = SetDfsReparsePoint( DirectoryHandle);
        
        NtClose( DirectoryHandle);
    }

    DosStatus = RtlNtStatusToDosError(NtStatus);

    DFS_TRACE_ERROR_HIGH(DosStatus, REFERRAL_SERVER, "DirectoryName of interest %wZ: Create Reparse point Status %x\n",
                         pLinkName, 
                         DosStatus);

    return DosStatus;
}


NTSTATUS
DfsRootFolder::DeleteLinkReparsePoint( 
    PUNICODE_STRING pDirectoryName,
    HANDLE ParentHandle )
{
    NTSTATUS NtStatus;
    HANDLE LinkDirectoryHandle;
    BOOLEAN IsReparsePoint, IsDfsReparsePoint;

    NtStatus = OpenDirectory( pDirectoryName,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              ParentHandle,
                              &LinkDirectoryHandle,
                              NULL );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = IsDirectoryReparsePoint( LinkDirectoryHandle,
                                            &IsReparsePoint,
                                            &IsDfsReparsePoint );

        if ((NtStatus == STATUS_SUCCESS) && 
            (IsDfsReparsePoint == TRUE) )
        {
            NtStatus = ClearDfsReparsePoint( LinkDirectoryHandle );

        }

        NtClose( LinkDirectoryHandle );
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DeleteLinkDirectories( pDirectoryName,
                                          ParentHandle );
    }

    return NtStatus;
}



NTSTATUS
DfsRootFolder::CreateLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle,
    PHANDLE           pDirectoryHandle,
    PBOOLEAN          pIsNewlyCreated )
{
    UNICODE_STRING DirectoryToCreate = *pLinkName;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ULONG ShareMode;
    HANDLE CurrentDirectory;

    ShareMode =  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
    DirectoryToCreate.MaximumLength = DirectoryToCreate.Length;

    StripLastPathComponent( &DirectoryToCreate );
    while ( (NtStatus == STATUS_SUCCESS) && (DirectoryToCreate.Length != 0) )
    {
        NtStatus = OpenDirectory( &DirectoryToCreate,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  NULL );
        if (NtStatus == ERROR_SUCCESS)
        {
            CloseDirectory( CurrentDirectory );
            break;
        }
        NtStatus = StripLastPathComponent( &DirectoryToCreate );
    }

    ShareMode = 0;

    while ( (NtStatus == STATUS_SUCCESS) && (DirectoryToCreate.Length != DirectoryToCreate.MaximumLength) )
    {
        AddNextPathComponent( &DirectoryToCreate );

        NtStatus = OpenDirectory( &DirectoryToCreate,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  pIsNewlyCreated );
        if ( (NtStatus == ERROR_SUCCESS) &&
             (DirectoryToCreate.Length != DirectoryToCreate.MaximumLength) )
        {
            CloseDirectory( CurrentDirectory );
        }
    } 

    if (NtStatus == STATUS_SUCCESS)
    {
        *pDirectoryHandle = CurrentDirectory;
    }

    return NtStatus;
}



BOOLEAN
DfsRootFolder::IsEmptyDirectory(
    HANDLE DirectoryHandle,
    PVOID pDirectoryBuffer,
    ULONG DirectoryBufferSize )
{
    NTSTATUS NtStatus;
    FILE_NAMES_INFORMATION *pFileInfo;
    ULONG NumberOfFiles = 1;
    BOOLEAN ReturnValue = FALSE;
    IO_STATUS_BLOCK     IoStatus;

    NtStatus = NtQueryDirectoryFile ( DirectoryHandle,
                                      NULL,   // no event
                                      NULL,   // no apc routine
                                      NULL,   // no apc context
                                      &IoStatus,
                                      pDirectoryBuffer,
                                      DirectoryBufferSize,
                                      FileNamesInformation,
                                      FALSE, // return single entry = false
                                      NULL,  // filename
                                      FALSE ); // restart scan = false
    if (NtStatus == ERROR_SUCCESS)
    {
        pFileInfo =  (FILE_NAMES_INFORMATION *)pDirectoryBuffer;

        while (pFileInfo->NextEntryOffset) {
            NumberOfFiles++;
            if (NumberOfFiles > 3) 
            {
                break;
            }
            pFileInfo = (FILE_NAMES_INFORMATION *)((ULONG_PTR)(pFileInfo) + 
                                                   pFileInfo->NextEntryOffset);
        }

        if (NumberOfFiles <= 2)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;
}

NTSTATUS
DfsRootFolder::DeleteLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle )
{
    UNICODE_STRING DirectoryToDelete = *pLinkName;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE CurrentDirectory = NULL;
    ULONG ShareMode = 0;
    const TCHAR * apszSubStrings[4];

    ShareMode =  FILE_SHARE_READ;
    //
    // dfsdev: fix this fixed size limit. it will hurt us in the future.
    //
    ULONG DirectoryBufferSize = 4096;
    PBYTE pDirectoryBuffer = new BYTE [DirectoryBufferSize];

    if (pDirectoryBuffer == NULL)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    while ( (NtStatus == STATUS_SUCCESS) && (DirectoryToDelete.Length != 0) )
    {
        NtStatus = OpenDirectory( &DirectoryToDelete,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  NULL );
        if (NtStatus == ERROR_SUCCESS)
        {
            if (IsEmptyDirectory(CurrentDirectory,
                                 pDirectoryBuffer,
                                 DirectoryBufferSize) == FALSE)
            {
                CloseDirectory( CurrentDirectory );

                apszSubStrings[0] = GetFolderLogicalNameString();
                apszSubStrings[1] = GetDirectoryCreatePathName()->Buffer;
                GenerateEventLog(DFS_ERROR_DIRECTORY_NOT_EMPTY,
                                 2,
                                 apszSubStrings,
                                 0);
                break;
            }

            CloseDirectory( CurrentDirectory );
            InitializeObjectAttributes (
                &ObjectAttributes,
                &DirectoryToDelete,
                0,
                RelativeHandle,
                NULL);

            NtStatus = NtDeleteFile( &ObjectAttributes );

            StripLastPathComponent( &DirectoryToDelete );
        }
    }

    if (pDirectoryBuffer != NULL)
    {
        delete [] pDirectoryBuffer;
    }
    return NtStatus;
}



VOID
DfsRootFolder::CloseDirectory(
    HANDLE DirHandle )
{
    NtClose( DirHandle );
}


//+-------------------------------------------------------------------------
//
//  Function:   AcquireRootShareDirectory 
//
//  Arguments:  none
//
//  Returns:    Status: success if we passed all checks.
//
//  Description: This routine checks to see if the share backing the
//               the dfs root actually exists. If it does, it confirms
//               that the filesystem hosting this directory supports
//               reparse points. Finally, it tells the driver to attach
//               to this directory.
//               If all of this works, we have acquired the root share.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::AcquireRootShareDirectory(void)
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    DFSSTATUS                   Status = ERROR_SUCCESS;
    HANDLE                      DirHandle = NULL;
    PUNICODE_STRING             pDirectoryName = NULL;
    PUNICODE_STRING             pUseShare = NULL;
    BOOLEAN                     SubStringMatch = FALSE;
    BOOL                        Inserted = FALSE;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    ULONG                       pAttribInfoSize;
    PFILE_FS_ATTRIBUTE_INFORMATION pAttribInfo = NULL;
    const TCHAR * apszSubStrings[4];


    pUseShare  = GetRootPhysicalShareName();

    DFS_TRACE_LOW(REFERRAL_SERVER, "AcquireRoot Share called for root %p, name %wZ\n", this, pUseShare);
    //
    // if either the root share is already acquired, or the library
    // was told that we are not interested in creating directories, we
    // are done.
    //
    if ( (IsRootFolderShareAcquired() == TRUE) ||
         (DfsCheckCreateDirectories() == FALSE) )
    {
        DFS_TRACE_LOW(REFERRAL_SERVER, "Root %p, Share Already acquired\n", this);
        return ERROR_SUCCESS;
    }
    //
    // first we get the logical share
    // Then we call into initialize directory information to setup the
    // physical share path etc.
    //

    Status = InitializeDirectoryCreateInformation();


    //
    // If the directory create path is invalid, we are done.
    //
    if (Status == ERROR_SUCCESS)
    {
        pDirectoryName = GetDirectoryCreatePathName();

        if ( (pDirectoryName == NULL) || 
             (pDirectoryName->Buffer == NULL) ||
             (pDirectoryName->Length == 0) )
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }


    if (Status == ERROR_SUCCESS)
    {
        //
        // Now allocate space to fill the attribute information we 
        // will query.
        // dfsdev: document why we allocate an additional max_path.
        //
        pAttribInfoSize = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH;
        pAttribInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)new BYTE [pAttribInfoSize];
        if (pAttribInfo != NULL)
        {
            InitializeObjectAttributes ( &ObjectAttributes, 
                                         pDirectoryName,
                                         0,                     //Attributes
                                         NULL,                  //Root handle
                                         NULL );                //Security descriptor.

            NtStatus = NtOpenFile( &DirHandle,
                                   (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                   &ObjectAttributes,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT );
    

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Query for the basic information, which has the attributes.
                //
                NtStatus = NtQueryVolumeInformationFile( DirHandle,
                                                         &IoStatusBlock,
                                                         pAttribInfo,
                                                         pAttribInfoSize,
                                                         FileFsAttributeInformation );

                if (NtStatus == STATUS_SUCCESS)
                {
                    //
                    // If the attributes indicate reparse point, we have a reparse
                    // point directory on our hands.
                    //
                    if ( (pAttribInfo->FileSystemAttributes & FILE_SUPPORTS_REPARSE_POINTS) == 0)
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                        apszSubStrings[0] = pUseShare->Buffer;
                        apszSubStrings[1] = pDirectoryName->Buffer;
                        GenerateEventLog(DFS_ERROR_UNSUPPORTED_FILESYSTEM,
                                         2,
                                         apszSubStrings,
                                         0);
                                         
                    }
                }
                CloseHandle (DirHandle);

                delete [] pAttribInfo;
            }
            if( NtStatus != STATUS_SUCCESS)
            {
                Status = RtlNtStatusToDosError(NtStatus);
            }
        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Root %p, Share check status %x\n", this, Status);
    //
    // Now check if we already know about parts of this path.
    // if there is overlap with other paths that we already know about,
    // we cannot handle this root, so reject it.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsAddKnownDirectoryPath( pDirectoryName,
                                           pUseShare );
        if (Status == ERROR_SUCCESS)
        {
            Inserted = TRUE;
        }
        else
        {
            apszSubStrings[0] = pUseShare->Buffer;
            apszSubStrings[1] = pDirectoryName->Buffer;
            GenerateEventLog(DFS_ERROR_OVERLAPPING_DIRECTORIES,
                             2,
                             apszSubStrings,
                             0);
        }
        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Root %p, Share add known directory status %x\n", this, Status);
    }


    //
    // if we are here: we know this is a reparse point, and we have
    // inserted in the user mode database. 
    // now call into the driver so it may attach to this filesystem.
    //

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsUserModeAttachToFilesystem( pDirectoryName,
                                                pUseShare);
        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Root %p, user mode attach status %x\n", this, Status);
    }


    //
    // if we are successful, we acquired the root share, now mark
    // our state accordingly.
    //

    if (Status == ERROR_SUCCESS)
    {
        SetRootFolderShareAcquired();
    }
    else 
    {
        //
        // otherwise, clear up some of the work we just did.
        //
        ClearRootFolderShareAcquired();
        if (Inserted == TRUE)
        {
            DfsRemoveKnownDirectoryPath( pDirectoryName,
                                         pUseShare);
        }
    }
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "AcquireRoot share for root %p, (%wZ) status %x\n",
                        this, pUseShare, Status);
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   ReleaseRootShareDirectory 
//
//  Arguments:  none
//
//  Returns:    Status: success if we are successful
//
//  Description: This routine checks to see if the share backing the
//               the dfs root was acquired by us earlier. If so, we
//               tell the driver to releast its reference on this 
//               share, and remove this information from our tables,
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::ReleaseRootShareDirectory(void)
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    DFSSTATUS                   Status = ERROR_SUCCESS;
    PUNICODE_STRING             pDirectoryName = NULL;
    PUNICODE_STRING             pUseShare = NULL;
    PVOID                       pData = NULL;
    BOOLEAN                     SubStringMatch = FALSE;

    DFS_TRACE_LOW(REFERRAL_SERVER, "ReleaseRoot share for root %p\n", this);
    if (IsRootFolderShareAcquired() == TRUE)
    {
        //
        // get the logical share, and the physical directory backing the
        // share.
        //
        pUseShare  = GetRootPhysicalShareName();
        pDirectoryName = GetDirectoryCreatePathName();

        if ( (pDirectoryName == NULL) || 
             (pDirectoryName->Buffer == NULL) ||
             (pDirectoryName->Length == 0) )
        {
            Status = ERROR_INVALID_PARAMETER;
        }


        //
        // now, signal the driver to detach itself from this share.
        //dfsdev: if this fails, we are in an inconsistent state, since
        // we just removed it from our table above!
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsUserModeDetachFromFilesystem( pDirectoryName,
                                                      pUseShare);
            DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "user mode detach path %wZ, %wZ: Status %x\n",
                                pDirectoryName, pUseShare, Status );

        }

        //
        // now, find the information in our database. if we did not find an
        // exact match, something went wrong and signal that.
        //
        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS RemoveStatus;

            RemoveStatus = DfsRemoveKnownDirectoryPath( pDirectoryName,
                                                        pUseShare );

            DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "RemoveKnownDirectory path %wZ, %wZ: Status %x\n",
                                 pDirectoryName, pUseShare, RemoveStatus );
        }


        if (Status == ERROR_SUCCESS)
        {
            ClearRootFolderShareAcquired();
        }
    }
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Release root share %p, Status %x\n",
                        this, Status );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddMetadataLink
//
//  Arguments:  
//        pLogicalName: the complete logical unc name of this link.
//        ReplicaServer: the target server for this link.
//        ReplicaPath: the target path on the server.
//        Comment : comment to be associated with this link.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine Adds a link to the metadata.
//               In future, ReplicaServer and ReplicaPath's
//               can be null, since we will allow links with
//               no targets. 
//               dfsdev: make sure we do the right thing for
//               compat.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//               The caller is also responsible for ensuring
//               this link does not already exist in the
//               the metadata.
//               The caller is also responsible to make sure that this
//               name does not overlap an existing link.
//               (for example if link a/b exisits, link a or a/b/c are
//               overlapping links and should be disallowed.)
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::AddMetadataLink(
    PUNICODE_STRING  pLogicalName,
    LPWSTR           ReplicaServer,
    LPWSTR           ReplicaPath,
    LPWSTR           Comment )
{
    DFS_METADATA_HANDLE RootHandle = NULL;
    DFSSTATUS Status;
    UNICODE_STRING LinkMetadataName;
    UNICODE_STRING VisibleNameContext, UseName;
    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;

    UUID NewUid;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = UuidCreate(&NewUid);
    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadataStore()->GenerateLinkMetadataName( &NewUid,
                                                               &LinkMetadataName);
    }


    if (Status == ERROR_SUCCESS)
    {
        //
        // First get a handle to the 
        // metadata. The handle has different meaning to different 
        // underlying stores: for example the registry store may
        // use the handle as a key, while the ad store may use the
        // handle as a pointer in some cache.
        //
        Status = GetMetadataHandle( &RootHandle );

        if (Status == ERROR_SUCCESS)
        {
            GetVisibleNameContext( NULL, &VisibleNameContext );

            Status = GetMetadataStore()->GenerateMetadataLogicalName( &VisibleNameContext,
                                                                      pLogicalName,
                                                                      &UseName );

            if (Status == ERROR_SUCCESS)
            {
                GetMetadataStore()->StoreInitializeNameInformation( &NameInfo,
                                                                    &UseName,
                                                                    &NewUid,
                                                                    Comment );

                GetMetadataStore()->StoreInitializeReplicaInformation( &ReplicaListInfo,
                                                                       &ReplicaInfo,
                                                                       ReplicaServer,
                                                                       ReplicaPath );

                Status = GetMetadataStore()->AddChild( RootHandle,
                                                       &NameInfo,
                                                       &ReplicaListInfo,
                                                       &LinkMetadataName );

                //
                // if we failed add child, we need to reset the
                // internal state to wipe out any work we did when
                // we were adding the child.
                //
                if (Status != ERROR_SUCCESS)
                {
                    ReSynchronize();
                }

                GetMetadataStore()->ReleaseMetadataLogicalName(&UseName );

                //
                // if we successfully added the link, update the link information
                // so that we can pass this out in referrals, and create the appropriate
                // directories.
                //  
                if (Status == ERROR_SUCCESS)
                {
                    DFSSTATUS LinkUpdateStatus;

                    LinkUpdateStatus = UpdateLinkInformation( RootHandle,
                                                              LinkMetadataName.Buffer );

                }
            }

            //
            // Finally, release the root handle we acquired earlier.
            //

            ReleaseMetadataHandle( RootHandle );
        }
        GetMetadataStore()->ReleaseLinkMetadataName( &LinkMetadataName );
    }

    ReleaseRootLock();
    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   RemoveMetadataLink
//
//  Arguments:  
//        pLogicalName: the link name relative to root share
//
//  Returns:   SUCCESS or error
//
//  Description: This routine removes a link from the the metadata.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::RemoveMetadataLink(
    PUNICODE_STRING pLinkName )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status;
    LPWSTR  LinkMetadataName;
    DfsFolder *pFolder;
    UNICODE_STRING Remaining;
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    // First, look this link up in our local data structures.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // if an EXACT match was not found, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;
    }

    //
    // we found the child folder. Now work on removing the metadata
    // and our local structures associated with this link.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get a handle to our metadata.
        //
        Status = GetMetadataHandle( &RootHandle );

        //
        //Now, look up the metadata name and remove it from the store.
        //
        if (Status == ERROR_SUCCESS)
        {
            LinkMetadataName = pFolder->GetFolderMetadataNameString();
        
            Status = GetMetadataStore()->RemoveChild( RootHandle,
                                                      LinkMetadataName );

            if (Status != ERROR_SUCCESS)
            {
                ReSynchronize();
            }

            ReleaseMetadataHandle( RootHandle );

            //
            // If we successfully removed the child from the metadata,
            // remove the link folder associated with this child. This will
            // get rid of our data structure and related directory for that child.
            //
            if (Status == ERROR_SUCCESS)
            {
                DFSSTATUS RemoveStatus;

                RemoveStatus = RemoveLinkFolder( pFolder,
                                                 TRUE ); // permanent removal
            }
        }
        pFolder->ReleaseReference();
    }

    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   AddMetadataLinkReplica
//
//  Arguments:  
//        pLinkName: the link name relative to root share
//        ReplicaServer : the target server to add
//        ReplicaPath : the target path on the server.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine adds a target to an existing link.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::AddMetadataLinkReplica(
    PUNICODE_STRING pLinkName,
    LPWSTR    ReplicaServer,
    LPWSTR    ReplicaPath )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolder *pFolder;
    UNICODE_STRING Remaining;
    LPWSTR LinkMetadataName;

    //
    // If either the target server or the path is null, reject the request.
    //
    if ((ReplicaServer == NULL) || (ReplicaPath == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    // Find the link folder associated with this logical name.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // If we did not find an EXACT match on the logical name, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;
    }
    
    //
    // if we are successful so far, call the store with a handle to
    // the metadata to add this target.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // get the metadata name for this link from the root folder.
        //
        LinkMetadataName = pFolder->GetFolderMetadataNameString();

        //
        // Get a handle to the root metadata this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );
        
        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->AddChildReplica( RootHandle,
                                                          LinkMetadataName,
                                                          ReplicaServer,
                                                          ReplicaPath );

            if (Status != ERROR_SUCCESS)
            {
                ReSynchronize();
            }
            //
            // Release the metadata handle we acquired earlier.
            //
            ReleaseMetadataHandle( RootHandle );
        }

        //
        // If we successfully added the target in the metadata, update the
        // link folder so that the next referral request will pick up the 
        // new target.
        //
        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS UpdateStatus;

            UpdateStatus = UpdateLinkFolder( LinkMetadataName,
                                             pLinkName,
                                             pFolder );
            //
            // dfsdev: log the update state.
            //
        }

        //
        // we are done with this link folder: release thre reference we got
        // when we looked it up.
        //
        pFolder->ReleaseReference();
    }

    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveMetadataLinkReplica
//
//  Arguments:  
//        pLinkName: the link name relative to root share
//        ReplicaServer : the target server to remove
//        ReplicaPath : the target path on the server.
//        pLastReplica: pointer to boolean, returns true if the last
//                      target on this link is being deleted.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine removes the target of an existing link.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveMetadataLinkReplica(
    PUNICODE_STRING pLinkName,
    LPWSTR  ReplicaServer,
    LPWSTR  ReplicaPath,
    PBOOLEAN pLastReplica )
{
    LPWSTR  LinkMetadataName;
    DFS_METADATA_HANDLE RootHandle;
    UNICODE_STRING Remaining;
    DFSSTATUS Status;
    
    DfsFolder *pFolder;

    //
    // if either the target server or target path is empty, return error.
    //
    if ((ReplicaServer == NULL) || (ReplicaPath == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //
    //find the link folder associated with this logical name.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // if we did not find an EXACT match on the logical name, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;
    }

    //
    // Call the store to remove the target from this child.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get the link metadata name from the folder.
        //
        LinkMetadataName = pFolder->GetFolderMetadataNameString();

        //
        // Get the handle to the root metadata for this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );
        
        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->RemoveChildReplica( RootHandle,
                                                             LinkMetadataName,
                                                             ReplicaServer,
                                                             ReplicaPath,
                                                             pLastReplica );

            if (Status != ERROR_SUCCESS)
            {
                ReSynchronize();
            }
            //
            // release the metadata handle we acquired a little bit earlier.
            //
            ReleaseMetadataHandle( RootHandle );
        }
        
        //
        // if we are successful in removing the target, update the link
        // folder so that future referrals will no longer see the target
        // we just deleted.
        //

        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS UpdateStatus;
            UpdateStatus = UpdateLinkFolder( LinkMetadataName,
                                             pLinkName,
                                             pFolder );

            DFSLOG("Remove link replica, update link folder status %x\n", UpdateStatus);
        }

        pFolder->ReleaseReference();
    }
    ReleaseRootLock();
    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   EnumerateApiLinks
//
//  Arguments:  
//    LPWSTR DfsPathName :  the dfs root to enumerate.
//    DWORD Level        :  the enumeration level
//    LPBYTE pBuffer     :  buffer to hold results.
//    LONG BufferSize,   :  buffer size
//    LPDWORD pEntriesRead : number of entries to read.
//    LPDWORD pResumeHandle : the starting child to read.
//    PLONG pNextSizeRequired : return value to hold size required in case of overflow.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine enumerates the dfs metadata information.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRootFolder::EnumerateApiLinks(
    LPWSTR DfsPathName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle,
    PLONG pNextSizeRequired )
{

    DFSSTATUS Status;
    DFS_METADATA_HANDLE RootHandle;
    UNICODE_STRING VisibleNameContext;
    UNICODE_STRING DfsPath;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    RtlInitUnicodeString( &DfsPath,
                          DfsPathName );

    //
    // Get the name context for this call.
    // do not use the user passed in name context within the path
    // for this call: if the user comes in with an ip address, we want
    // to return back the correct server/domain info to the caller
    // so the dfsapi results will not show the ip address etc.
    //
    GetVisibleNameContext( NULL,
                           &VisibleNameContext );
    //
    // Get the handle to the metadata for this root folder, and call
    // the store to enumerate the links.
    //
    Status = GetMetadataHandle( &RootHandle );

    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadataStore()->EnumerateApiLinks( RootHandle,
                                                        &VisibleNameContext,
                                                        Level,
                                                        pBuffer,
                                                        BufferSize,
                                                        pEntriesRead,
                                                        pResumeHandle,
                                                        pNextSizeRequired);

        //
        // Release the metadata handle.
        //
        ReleaseMetadataHandle( RootHandle );
    }

    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetApiInformation
//
//  Arguments:  
//    PUNICODE DfsPathName :  the dfs root name
//    PUNICODE pLinkName : the link within the root.
//    DWORD Level        :  the info level.
//    LPBYTE pBuffer     :  buffer to hold results.
//    LONG BufferSize,   :  buffer size
//    PLONG pSizeRequired : return value to hold size required in case of overflow.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine gets the required information for a given root or link
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::GetApiInformation(
    PUNICODE_STRING pDfsName,
    PUNICODE_STRING pLinkName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    PLONG pSizeRequired )
{
    UNREFERENCED_PARAMETER(pDfsName);

    DFSSTATUS Status;
    DFS_METADATA_HANDLE RootHandle;
    LPWSTR MetadataName;
    DfsFolder *pFolder;
    UNICODE_STRING VisibleNameContext;
    UNICODE_STRING Remaining;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    //
    // Do not base the context to use on the passed in dfsname:
    //  it is important to pass back our correct information 
    // in the api call.
    //
    //
    GetVisibleNameContext( NULL,
                           &VisibleNameContext );

    //
    // If  the link name is empty, we are dealing with the root.
    // so set the metadata name to null.
    //
    if (pLinkName->Length == 0)
    {
        MetadataName = NULL;
        Status = ERROR_SUCCESS;
    }
    //
    // otherwise, lookup the link folder and get the metadataname for that link.
    //
    else {
        Status = LookupFolderByLogicalName( pLinkName,
                                            &Remaining,
                                            &pFolder );
        //
        // if we did not find an EXACT match on the logical name, we are done.
        //
        if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
        {
            pFolder->ReleaseReference();
            Status = ERROR_NOT_FOUND;
        }

        //
        // we had an exact match, so lookup the metadata name and release the
        // the reference on the folder.
        //
        if (Status == ERROR_SUCCESS)
        {
            MetadataName = pFolder->GetFolderMetadataNameString();
            pFolder->ReleaseReference();
        }
    }

    //
    // we got the metadata name: now call into the store to get the
    // required information for the metadata name.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get the handle to the metadata for this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );

        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->GetStoreApiInformation( RootHandle,
                                                                 &VisibleNameContext,
                                                                 MetadataName,
                                                                 Level,
                                                                 pBuffer,
                                                                 BufferSize,
                                                                 pSizeRequired);

            ReleaseMetadataHandle( RootHandle );
        }
    }
    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetApiInformation
//
//  Arguments:  
//    PUNICODE pLinkName : the name of link relative to root share
//    LPWSTR Server,        : the target server.
//    LPWSTR Share,         : the target path within the server.
//    DWORD Level        :  the info level.
//    LPBYTE pBuffer     :  buffer that has the information to be set.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine sets the required information for a given root or link
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::SetApiInformation(
    PUNICODE_STRING pLinkName,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE pBuffer )
{
    DFSSTATUS Status;
    DFS_METADATA_HANDLE RootHandle;
    LPWSTR MetadataName;
    DfsFolder *pFolder;

    UNICODE_STRING Remaining;
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //

    // if the link name is empty we are dealing with 
    // the root itself.
    //  dfsdev: we need to set the root metadata appropriately!
    //
    if (pLinkName->Length == 0)
    {
        MetadataName = NULL;
        Status = ERROR_SUCCESS;
    }
    //
    // else get to the link folder, and get
    // the link metadata name.
    //
    else {
        Status = LookupFolderByLogicalName( pLinkName,
                                            &Remaining,
                                            &pFolder );
        //
        // if we did not find an EXACT match on the logical name, we are done.
        //
        if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
        {
            pFolder->ReleaseReference();
            Status = ERROR_NOT_FOUND;
        }

        if (Status == ERROR_SUCCESS)
        {
            MetadataName = pFolder->GetFolderMetadataNameString();

            //
            // if we got the metadataname, call the store with the
            // details so that it can associate the information
            // with this root or link.
            //
        
            //
            // Get the handle to the root of this metadata
            //
            Status = GetMetadataHandle( &RootHandle );

            if (Status == ERROR_SUCCESS)
            {
                Status = GetMetadataStore()->SetStoreApiInformation( RootHandle,
                                                                     MetadataName,
                                                                     Server,
                                                                     Share,
                                                                     Level,
                                                                     pBuffer );

                if (Status != ERROR_SUCCESS)
                {
                    ReSynchronize();
                }
                ReleaseMetadataHandle( RootHandle );

            }


            //
            // If we successfully updated the metadata, update the
            // link folder so that the next referral request will pick up the 
            // changes
            //
            if (Status == ERROR_SUCCESS)
            {
                DFSSTATUS UpdateStatus;

                UpdateStatus = UpdateLinkFolder( MetadataName,
                                                 pLinkName,
                                                 pFolder );
                //
                // dfsdev: log the update state.
                //
            }

            pFolder->ReleaseReference();
        }
    }
    ReleaseRootLock();
    return Status;
}






//+-------------------------------------------------------------------------
//
//  Function:  LoadReferralData -  Loads the referral data.
//
//  Arguments:    pReferralData -  the referral data to load
//
//  Returns:    Status: Success or error code
//
//  Description: This routine sets up the ReferralData instance to have
//               all the information necessary to create a referral.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::LoadReferralData(
    DfsFolderReferralData *pReferralData )
{
    DFS_METADATA_HANDLE RootMetadataHandle;
    DFSSTATUS Status;
    DfsFolder *pFolder;
    //
    // Get the Root key for this root folder.
    //

    DFS_TRACE_LOW( REFERRAL_SERVER, "LoadReferralData called, %p\n", pReferralData);
    
    Status = GetMetadataHandle( &RootMetadataHandle );

    if ( Status == ERROR_SUCCESS )
    {
        //
        // Now get the owning folder of the referralDAta. Note that
        // this does not give us a new reference on the Folder.
        // however, the folder is guaranteed to be around till
        // we return from this call, since the pReferralData that
        // was passed in to us cannot go away.
        //
        pFolder = pReferralData->GetOwningFolder();    

        DFS_TRACE_LOW( REFERRAL_SERVER, "Load referral data, Got Owning Folder %p\n", pFolder );

        //
        // Now load the replica referral data for the passed in folder.
        //
        Status = LoadReplicaReferralData( RootMetadataHandle,
                                          pFolder->GetFolderMetadataNameString(),
                                          pReferralData );
        DFS_TRACE_LOW( REFERRAL_SERVER, "LoadReferralData for %p replica data loaded %x\n",
                       pReferralData, Status );


        if ( Status == ERROR_SUCCESS )
        {
            //
            // Load the policy referrral data for the passedin folder.
            //
            Status = LoadPolicyReferralData( RootMetadataHandle );

        }
        ReleaseMetadataHandle( RootMetadataHandle );
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Done load referral data %p, Status %x\n", 
                        pReferralData, Status);
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnloadReferralData - Unload the referral data.
//
//  Arguments:  pReferralData - the ReferralData instance to unload.
//
//  Returns:    Status: Success or Error status code.
//
//  Description: This routine Unloads the referral data. It undoes what
//              the corresponding load routine did.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::UnloadReferralData(
    DfsFolderReferralData *pReferralData )

{
    DFSSTATUS Status;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Unload referral data %p\n", pReferralData);
    Status = UnloadReplicaReferralData( pReferralData );
    if ( Status == ERROR_SUCCESS )
    {
        Status = UnloadPolicyReferralData( pReferralData );
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unload referral data %p, Status %x\n", pReferralData, Status);
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   LoadReplicaReferralData - load the replica information.
//
//  Arguments:  RegKey -  the registry key of the root folder,
//              RegistryName - Name of the registry key relative to to Root Key
//              pReferralData - the referral data to load.
//
//  Returns:   Status - Success or error status code.
//
//  Description: This routine loads the replica referral data for the
//               the passed in ReferralData instance.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::LoadReplicaReferralData(
    DFS_METADATA_HANDLE RootMetadataHandle,
    LPWSTR MetadataName,
    DfsFolderReferralData *pReferralData )
{
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo;
    PDFS_REPLICA_INFORMATION pReplicaInfo;
    PUNICODE_STRING pServerName;
    DfsReplica *pReplica;
    DFSSTATUS Status;
    ULONG Replica;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Load Replica Referral Data %ws, for %p\n", MetadataName, pReferralData);
    pReferralData->pReplicas = NULL;

    //
    // Get the replica information.
    //
    Status = GetMetadataStore()->GetMetadataReplicaInformation(RootMetadataHandle,
                                                               MetadataName,
                                                               &pReplicaListInfo );

    if ( Status == ERROR_SUCCESS )
    {

        //
        // Set the appropriate count, and allocate the replicas
        // required.
        //
        pReferralData->ReplicaCount = pReplicaListInfo->ReplicaCount;
        if (pReferralData->ReplicaCount > 0)
        {
            pReferralData->pReplicas = new DfsReplica [ pReplicaListInfo->ReplicaCount ];
            if ( pReferralData->pReplicas == NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    //
    // Now, for each replica, set the replicas server name, the target
    // folder and the replica state.
    //
    if ( Status == ERROR_SUCCESS )
    {
        for ( Replica = 0; 
             (Replica < pReplicaListInfo->ReplicaCount) && (Status == ERROR_SUCCESS);
             Replica++ )
        {

            pReplicaInfo = &pReplicaListInfo->pReplicas[Replica];
            pReplica = &pReferralData->pReplicas[ Replica ];

            pServerName = &pReplicaInfo->ServerName;

            //
            // If the servername is a ., this is a special case where
            // the servername is the root itself. In this case,
            // set the server name to the name of this machine.
            //
            if (IsLocalName(pServerName))
            {
                GetVisibleNameContext( NULL,
                                       pServerName );
            }

            Status = pReplica->SetTargetServer( pServerName );
            if ( Status == ERROR_SUCCESS )
            {
                Status = pReplica->SetTargetFolder( &pReplicaInfo->ShareName );
            }
            if ( Status == ERROR_SUCCESS )
            {
                if ( pReplicaInfo->ReplicaState & REPLICA_STORAGE_STATE_OFFLINE )
                {
                    pReplica->SetTargetOffline();
                }
            }
        }

        //
        // Now release the replica information that was allocated
        // by the store.
        //
        GetMetadataStore()->ReleaseMetadataReplicaInformation( RootMetadataHandle,
                                                               pReplicaListInfo );
    }
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Done with Load Replica Referral Data %ws, for %p, Status %x\n", 
                         MetadataName, pReferralData, Status);
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   UnloadReplicaReferralData - Unload the replicas 
//
//  Arguments:    pReferralData - the DfsFolderReferralData to unload
//
//  Returns:    Status: Success always.
//
//  Description: This routine gets rid of the allocate replicas in the
//               folder's referral data.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::UnloadReplicaReferralData(
    DfsFolderReferralData *pReferralData )
{
    if (pReferralData->pReplicas != NULL) {
        delete [] pReferralData->pReplicas;
        pReferralData->pReplicas = NULL;
    }

    return ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRootStandby - set the root in a standby mode.
//
//  Arguments:  none
//
//  Returns:    Status: Success always for now.
//
//  Description: This routine checks if we are already in standby mode.
//               If not, it releases the root share directory, removes
//               all the link folders and set the root in a standby mode
//               DFSDEV: need to take into consideration synchronization
//               with other threads.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRootFolder::SetRootStandby()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    DFS_TRACE_LOW( REFERRAL_SERVER, "Root %p being set to standby\n", this);
    if (IsRootFolderStandby() == FALSE)
    {
        //
        // dfsdev:: ignore error returns from these calls?
        //
        DFSSTATUS ReleaseStatus;

        ReleaseStatus = ReleaseRootShareDirectory();
        DFS_TRACE_ERROR_LOW( ReleaseStatus, REFERRAL_SERVER, "Release root share status %x\n", ReleaseStatus);

        RemoveAllLinkFolders( FALSE ); // Not a permanent removal

        SetRootFolderStandby();
    }
    else
    {
        DFS_TRACE_LOW( REFERRAL_SERVER, "Root %p was already standby\n", this);
    }

    ReleaseRootLock();
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRootResynchronize - set the root in a ready mode.
//
//  Arguments:  none
//
//  Returns:    Status: Success always for now.
//
//  Description: This routine checks if we are already in ready mode.
//               If not, it acquires the root share directory, calls
//               synchronize to add all the links back
//               DFSDEV: need to take into consideration synchronization
//               with other threads.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::SetRootResynchronize()
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS RootStatus;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    DFS_TRACE_LOW( REFERRAL_SERVER, "Root %p being resynced\n", this);
    //
    // if the root folder is already marked available, we are done
    // otherwise, clear the standby mode, and try to bring this
    // root into a useable state.
    //
    if (!IsRootFolderAvailable())
    {
        ClearRootFolderStandby();

        //
        //need to take appropriate locks.
        //
        RootStatus = Synchronize();
        DFS_TRACE_ERROR_LOW( RootStatus, REFERRAL_SERVER, "Set root resync: Synchronize status for %p is %x\n", 
                             this, RootStatus);
    }
    else
    {
        ReSynchronize();
    }

    ReleaseRootLock();
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   UpdateLinkInformation
//
//  Arguments:    
//    DfsMetadataHandle - the parent handle
//    LPWSTR ChildName - the child name
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the metadata for the child and, updates
//               the child folder if necessary. This includes adding
//               the folder if it does not exist, or if the folder exists
//               but the metadata is newer, ensuring that all future
//               request use the most upto date data.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::UpdateLinkInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Timeout = 0;
    PDFS_NAME_INFORMATION pChild = NULL;
    DfsFolder *pChildFolder = NULL;
    FILETIME LastModifiedTime;

    UNICODE_STRING LinkName;

    //
    // Now that we have the child name, get the name information
    // for this child. This is the logical namespace information
    // for this child.
    //
    Status = GetMetadataStore()->GetMetadataNameInformation( DfsHandle,
                                                             ChildName,
                                                             &pChild);


    if ( Status == ERROR_SUCCESS )
    {

        Timeout = pChild->Timeout;

        // 
        // we want to ignore the root entry here. hardcode 81 till
        // we get the defines in the right place
        // dfsdev: fix this.
        //if(pChild->Type == (PKT_ENTRY_TYPE_REFERRAL_SVC | PKT_ENTRY_TYPE_CAIRO))
        if(pChild->Type == 0x81)
        {
            SetTimeout(Timeout);
            GetMetadataStore()->ReleaseMetadataNameInformation( DfsHandle, pChild );
            return Status;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        LastModifiedTime = pChild->LastModifiedTime;

        //
        // Now translate the metadata logical name to a relative
        // link name: each store has its own behavior, so
        // the getlinkname function is implemented by each store.
        //
        Status = GetMetadataLogicalToLinkName(&pChild->Prefix, 
                                              &LinkName);
        if ( Status == ERROR_SUCCESS )
        {
            Status = LookupFolderByMetadataName( ChildName,
                                                 &pChildFolder );

            if ( Status == ERROR_SUCCESS )
            {
                //
                // IF we already know this child, check if the child
                // has been updated since we last visited it.
                // If so, we need to update the child.
                //
                if ( pChildFolder->UpdateRequired( FILETIMETO64(LastModifiedTime) ) )
                {
                    DFSLOG("Updating child %p\n", pChildFolder );

                    Status = UpdateLinkFolder( ChildName,
                                               &LinkName,
                                               pChildFolder );
                }

                //
                // we now check if we need to create root directories for even
                // those folders that we already know about. This may be true
                // when we had one or more errors creating the
                // directory when we initially created this folder or it may
                // be true when we are going from standby to master.
                //

                if (IsRootDirectoriesCreated() == FALSE)
                {
                    DFSSTATUS CreateStatus;

                    CreateStatus = SetupLinkReparsePoint(pChildFolder->GetFolderLogicalNameString());

                    DFSLOG("CreateStatus is %x\n", CreateStatus);
                }
            } 
            else if ( Status == ERROR_NOT_FOUND )
            {
                //
                // We have not seen this child before: create 
                // a new one.
                //
                Status = CreateLinkFolder( ChildName,
                                           &LinkName,
                                           &pChildFolder );
                DFSLOG("Adding new child %wS, %p status %x",
                       ChildName, pChildFolder, Status );

            }

            ReleaseMetadataLogicalToLinkName( &LinkName );
        }
        //
        // Now release the name information of the child.
        //
        GetMetadataStore()->ReleaseMetadataNameInformation( DfsHandle, pChild );
    }

    //
    // We were successful. We have a child folder that is
    // returned to us with a valid reference. Set the Last
    // modified time in the folder, and release our reference
    // on the child folder.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pChildFolder->SetTimeout(Timeout);
        pChildFolder->SetUSN( FILETIMETO64(LastModifiedTime) );
        pChildFolder->ReleaseReference();
    }

    return Status;
}



void
DfsRootFolder::GenerateEventLog(DWORD EventMsg, 
                                WORD Substrings,
                                const TCHAR * apszSubStrings[],
                                DWORD Errorcode)
{
    if(InterlockedIncrement(&_CurrentErrors) < DFS_MAX_ROOT_ERRORS)
    {
        DfsLogDfsEvent(EventMsg, 
                       Substrings, 
                       apszSubStrings, 
                       Errorcode); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsstatistics.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsStatistics.cxx
//
//  Contents:   the DFS Statistics
//
//  Classes:    DfsStatistics
//
//  History:    Apr. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsStatistics.hxx"
#include "dfsinit.hxx"
//
// following are required for logging: dfsdev cleanup
//

#include "dfsstatistics.tmh" 

VOID
DfsStatistics::DumpStatistics(
    PUNICODE_STRING pLogicalShare )
{
    SYSTEMTIME CurrentTime;


    GetLocalTime( &CurrentTime );

    DFS_TRACE_HIGH( STATISTICS, "Root %wZ\n", pLogicalShare);
    DFS_TRACE_HIGH( STATISTICS, "Statisicts dump at %d\\%d\\%d, %d:%d:%d:%d\n",
                    CurrentTime.wMonth, CurrentTime.wDay, CurrentTime.wYear,
                    CurrentTime.wHour, CurrentTime.wMinute, CurrentTime.wSecond, 
                    CurrentTime.wMilliseconds );

    DFS_TRACE_HIGH( STATISTICS, "Total Referrals %d\n", TotalReferrals );
    DFS_TRACE_HIGH( STATISTICS, "Hits %d Misses %d\n", Hits, Misses );
    DFS_TRACE_HIGH( STATISTICS, "Min Referral Time %d ms\n", MinReferralTime );
    DFS_TRACE_HIGH( STATISTICS, "Max Referral Time %d ms\n", MaxReferralTime );
    DFS_TRACE_HIGH( STATISTICS, "%d Referrals took longer than %d secs\n",
                    LargeTimeReferrals, LARGE_TIME_REFERRAL/1000 );
    DFS_TRACE_HIGH( STATISTICS, "%d Referrals took less than %d ms\n",
                    SmallTimeReferrals, SMALL_TIME_REFERRAL);

    DFS_TRACE_HIGH( STATISTICS, "Links Added %d Deleted %d Modified %d\n",
                    LinksAdded, LinksDeleted, LinksModified);

    DFS_TRACE_HIGH( STATISTICS, "Cache Flush interval %d ms\n", DfsServerGlobalData.CacheFlushInterval );

    DFS_TRACE_HIGH( STATISTICS, "Forced Cache Flush %d\n", ForcedCacheFlush);
    DFS_TRACE_HIGH( STATISTICS, "Statistics Started on %d\\%d\\%d, %d:%d:%d:%d\n",
                    StartTime.wMonth, StartTime.wDay, StartTime.wYear,
                    StartTime.wHour, StartTime.wMinute, StartTime.wSecond, 
                    StartTime.wMilliseconds );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfssynchronizeroots.cxx ===
#include <DfsGeneric.hxx>
#include "DfsInit.hxx"
#include "lm.h"
#include "lmdfs.h"

#include "DfsSynchronizeRoots.tmh"

DWORD
DfsRootSyncThread(LPVOID TData);

typedef struct _DFS_ROOT_SYNCHRONIZE_HEADER
{
    HANDLE hTimer;
    HANDLE SyncEvent;
    CRITICAL_SECTION DataLock;
    LIST_ENTRY Entries;
} DFS_ROOT_SYNCHRONIZE_HEADER, *PDFS_ROOT_SYNCHRONIZE_HEADER;


typedef struct _DFS_ROOT_SYNCRHONIZE_INFO
{
    UNICODE_STRING Target;
    LIST_ENTRY ListEntry;
} DFS_ROOT_SYNCHRONIZE_INFO, *PDFS_ROOT_SYNCHRONIZE_INFO;

DFS_ROOT_SYNCHRONIZE_HEADER DfsRootSyncHeader;

DFSSTATUS
DfsRootSynchronizeInit()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    InitializeCriticalSection( &DfsRootSyncHeader.DataLock );
    InitializeListHead(&DfsRootSyncHeader.Entries);

    DfsRootSyncHeader.SyncEvent = CreateEvent( NULL,
                                               TRUE, // manual reset
                                               FALSE, // initially reset.
                                               NULL );
    if (DfsRootSyncHeader.SyncEvent == NULL)
    {
        Status = GetLastError();

    }


    if (Status == ERROR_SUCCESS)
    {
        // Create a waitable timer.
        DfsRootSyncHeader.hTimer = CreateWaitableTimer(NULL, 
                                                       FALSE, // not manual reset.
                                                       NULL );
        if (DfsRootSyncHeader.hTimer == NULL)
        {
            Status = GetLastError();
        }
    }

    if (Status == ERROR_SUCCESS) {
        HANDLE THandle;
        DWORD Tid;
        
        THandle = CreateThread (
                     NULL,
                     0,
                     DfsRootSyncThread,
                     0,
                     0,
                     &Tid);
        
        if (THandle != NULL) {
            CloseHandle(THandle);
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Created Scavenge Thread (%d) Tid\n", Tid);
        }
        else {
            Status = GetLastError();
            DFS_TRACE_HIGH(REFERRAL_SERVER, "Failed Scavenge Thread creation, Status %x\n", Status);
        }
    }

    return Status;
}



DFSSTATUS
AddToSyncList (
    PUNICODE_STRING pTarget)
{
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    ULONG TotalSize;
    DFSSTATUS Status = ERROR_SUCCESS;

    TotalSize = sizeof(DFS_ROOT_SYNCHRONIZE_INFO) + pTarget->Length + sizeof(WCHAR);
    pRootSync = (PDFS_ROOT_SYNCHRONIZE_INFO)new BYTE[TotalSize];
    if (pRootSync != NULL)
    {
        pRootSync->Target.Buffer = (LPWSTR)(pRootSync + 1);
        RtlCopyMemory( pRootSync->Target.Buffer, 
                       pTarget->Buffer,
                       pTarget->Length );
        pRootSync->Target.Length = pRootSync->Target.MaximumLength = pTarget->Length;
        pRootSync->Target.Buffer[pRootSync->Target.Length/sizeof(WCHAR)] = UNICODE_NULL;

        InsertTailList( &DfsRootSyncHeader.Entries, &pRootSync->ListEntry); 

        SetEvent(DfsRootSyncHeader.SyncEvent);
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    DFS_TRACE_HIGH(REFERRAL_SERVER, "Adding %wZ to sync list, Status %x\n",
                   pTarget, Status);
    return Status;
}

VOID
DeleteSyncRoot(
    PDFS_ROOT_SYNCHRONIZE_INFO pDeleteEntry )
{
    delete [] (PBYTE)pDeleteEntry;
}


DFSSTATUS
AddRootToSyncrhonize(
    PUNICODE_STRING pName )
{
    DFSSTATUS Status;
    PLIST_ENTRY pNext;
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    BOOLEAN Found = FALSE;

    Status = DfsAcquireWriteLock(&DfsRootSyncHeader.DataLock);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pNext = DfsRootSyncHeader.Entries.Flink;
    while (pNext != &DfsRootSyncHeader.Entries)
    {
        pRootSync = CONTAINING_RECORD( pNext, 
                                       DFS_ROOT_SYNCHRONIZE_INFO,
                                       ListEntry );
        if (RtlCompareUnicodeString(&pRootSync->Target,
                                    pName,
                                    TRUE) == 0)
        {
            Found = TRUE;
            break;
        }
        pNext = pNext->Flink;
    }

    if (!Found)
    {
        Status = AddToSyncList( pName );
    }
    
    DfsReleaseLock(&DfsRootSyncHeader.DataLock);

    DFS_TRACE_HIGH(REFERRAL_SERVER, "AddRootToSync %wZ, Found? %d,  Status %x\n",
                   pName, Found, Status);

    return Status;
}


DFSSTATUS
SynchronizeRoots()
{
    BOOLEAN RootSync = TRUE;
    PLIST_ENTRY pNext;
    PDFS_ROOT_SYNCHRONIZE_INFO pRootSync;
    BOOLEAN WorkToDo = TRUE;
    DFSSTATUS Status;

    while (WorkToDo)
    {
        Status = DfsAcquireWriteLock(&DfsRootSyncHeader.DataLock);
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        WorkToDo = FALSE;
        pRootSync = NULL;

        if (!IsListEmpty( &DfsRootSyncHeader.Entries ))
        {
            pNext = RemoveHeadList( &DfsRootSyncHeader.Entries );
            pRootSync = CONTAINING_RECORD( pNext, 
                                           DFS_ROOT_SYNCHRONIZE_INFO,
                                           ListEntry );
            WorkToDo = TRUE;
        }
        
        DfsReleaseLock(&DfsRootSyncHeader.DataLock);

        if (pRootSync != NULL)
        {
            DFS_INFO_101 DfsState;
            DFSSTATUS ApiStatus;

            DfsState.State = DFS_VOLUME_STATE_RESYNCHRONIZE;
            //
            // Ignore the api status.
            //

            ApiStatus = NetDfsSetInfo( pRootSync->Target.Buffer,
                                       NULL,
                                       NULL, 
                                       101,
                                       (LPBYTE)&DfsState);

            DFS_TRACE_HIGH(REFERRAL_SERVER, "Syncrhonized %wZ, Status %x\n",
                           &pRootSync->Target, ApiStatus);

            DeleteSyncRoot( pRootSync );
        }
    }

    return Status;
}


DWORD
DfsRootSyncThread(LPVOID TData)
{
    UNREFERENCED_PARAMETER(TData);

    HANDLE WaitHandles[2];
    LARGE_INTEGER liDueTime;
    DFSSTATUS Status;

    liDueTime.QuadPart=-1000000000;

    WaitHandles[0] = DfsRootSyncHeader.SyncEvent;
    WaitHandles[1] = DfsRootSyncHeader.hTimer;

    while (TRUE)
    {
        DFSSTATUS WaitStatus;

        if (!ResetEvent(DfsRootSyncHeader.SyncEvent))
        {
            // Log this error.
            Status = GetLastError();
        }
        if (!SetWaitableTimer( DfsRootSyncHeader.hTimer, 
                               &liDueTime, 
                               0, NULL, NULL, 0))
        {
            //
            // log this error.
            // 
            Status = GetLastError();
        }

        // dfsdev: use status here.

        WaitStatus = WaitForMultipleObjects( 2,
                                             WaitHandles,
                                             TRUE,
                                             INFINITE );

        DFS_TRACE_HIGH(REFERRAL_SERVER, "Sync thread, waking up %x\n", WaitStatus);

        SynchronizeRoots();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\domaincontrollersupport.cxx ===
#include "DfsGeneric.hxx"
#include "dsgetdc.h"
#include "dsrole.h"
#include "DfsDomainInformation.hxx"
#include "DfsTrustedDomain.hxx"
#include "DfsReferralData.hxx"
#include "DomainControllerSupport.hxx"
#include "DfsReplica.hxx"
#include "dfsadsiapi.hxx"
#include "lmdfs.h"
#include "dfserror.hxx"
#include "dfsfilterapi.hxx"
#define RemoteServerNameString L"remoteServerName"


extern 
DFS_SERVER_GLOBAL_DATA DfsServerGlobalData;

#define HRESULT_TO_DFSSTATUS(_x) (_x)
DFSSTATUS
DfsDcInit( 
    PBOOLEAN pIsDc,
    DfsDomainInformation **ppDomainInfo )
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DsRoleGetPrimaryDomainInformation( NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&pPrimaryDomainInfo);

    if (Status == ERROR_SUCCESS)
    {
        if(pPrimaryDomainInfo->MachineRole == DsRole_RoleStandaloneServer)
        {
            DfsServerGlobalData.IsWorkGroup = TRUE;
        }
        else
        {
            DfsServerGlobalData.IsWorkGroup = FALSE;
        }

#if defined(TESTING)
        pPrimaryDomainInfo->MachineRole = DsRole_RoleBackupDomainController;
#endif


        if ( (pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController) || 
             (pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController) )
        {
            *pIsDc = TRUE;

            DfsDomainInformation *pNewDomainInfo = new DfsDomainInformation( &Status );
            if (pNewDomainInfo == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else if (Status != ERROR_SUCCESS)
            {
                pNewDomainInfo->ReleaseReference();
            }
        
            if (Status == ERROR_SUCCESS)
            {
                *ppDomainInfo = pNewDomainInfo;
            }
        }

        DfsSetDomainNameFlat( pPrimaryDomainInfo->DomainNameFlat);
        DfsSetDomainNameDns( pPrimaryDomainInfo->DomainNameDns);

        DsRoleFreeMemory(pPrimaryDomainInfo);

    }

    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsGenerateReferralDataFromRemoteServerNames
//    IADs *pObject    - the object
//    DfsfolderReferralData *pReferralData - the referral data
//
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the remote server name 
//               attribute and creates a referral data structure
//               so that we can pass a referral based on these names.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGenerateReferralDataFromRemoteServerNames(
    LPWSTR RootName,
    DfsReferralData **ppReferralData )
{
    HRESULT HResult = S_OK;
    DfsReplica *pReplicas = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    IADs *pObject = NULL;
    VARIANT Variant;

    Status = DfsGetDfsRootADObject(NULL,
                                   RootName,
                                   &pObject );

    if (Status == ERROR_SUCCESS)
    {
        pReferralData = new DfsReferralData (&Status );
        if (pReferralData == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (Status != ERROR_SUCCESS)
        {
            pReferralData->ReleaseReference();
        }


        if (Status == ERROR_SUCCESS)
        {
            LONG StartNdx, LastNdx;
            SAFEARRAY *PropertyArray;

            VariantInit( &Variant );

            pReferralData->Timeout = DFS_DEFAULT_REFERRAL_TIMEOUT;

            HResult = pObject->GetEx( RemoteServerNameString, &Variant );
            if ( SUCCEEDED(HResult) )
            {
                PropertyArray = V_ARRAY( &Variant );
                HResult = SafeArrayGetLBound( PropertyArray, 1, &StartNdx );
                if ( SUCCEEDED(HResult) )
                {
                    HResult = SafeArrayGetUBound( PropertyArray, 1, &LastNdx );
                }
            }

            if ( SUCCEEDED(HResult) &&
                 (LastNdx > StartNdx) )
            {
                VARIANT VariantItem;
            
                pReplicas = new DfsReplica [ LastNdx - StartNdx ];

                if (pReplicas != NULL)
                {
                    VariantInit( &VariantItem );

                    for ( LONG Index = StartNdx; Index < LastNdx; Index++ )
                    {



                        HResult = SafeArrayGetElement( PropertyArray, 
                                                       &Index,
                                                       &VariantItem );

                        if ( SUCCEEDED(HResult) )
                        {
                            UNICODE_STRING ServerName, Remaining, Replica;
                            LPWSTR ReplicaString = V_BSTR( &VariantItem );

                            RtlInitUnicodeString( &Replica, ReplicaString );
                            DfsGetFirstComponent( &Replica,
                                                  &ServerName,
                                                  &Remaining );

                            Status = (&pReplicas[ Index - StartNdx])->SetTargetServer( &ServerName );
                            if (Status == ERROR_SUCCESS)
                            {
                                Status = (&pReplicas[ Index - StartNdx])->SetTargetFolder( &Remaining );
                            }
                        }
                        else {
                            Status = DfsGetErrorFromHr( HResult );
                        }

                        VariantClear( &VariantItem );

                        if (Status != ERROR_SUCCESS)
                        {
                            delete [] pReplicas;
                            pReplicas = NULL;
                            break;
                        }
                    }
                }
                else
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else
            {
                Status = DfsGetErrorFromHr( HResult );
            }

            VariantClear( &Variant );

            if (Status == ERROR_SUCCESS)
            {
                pReferralData->ReplicaCount = LastNdx - StartNdx;
                pReferralData->pReplicas = pReplicas;
                *ppReferralData = pReferralData;
            }

            if (Status != ERROR_SUCCESS)
            {
                pReferralData->ReleaseReference();
            }
        }
        pObject->Release();
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsUpdateRemoteServerName
//
//  Arguments:    
//    IADs *pObject        - the ds object of interest.
//    LPWSTR ServerName    - the server name to add or delete
//    LPWSTR RemainingName - the rest of the name
//    BOOLEAN Add          - true for add, false for delete.
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine updates the RemoteServerName attribute
//               in the DS object, either adding a \\servername\remaining
//               to the existing DS attribute or removing it, depending
//               on add/delete.
//               The caller must make sure this parameter does not 
//               already exist in the add case, or that the parameter
//               to be deleted does exist in the delete case.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsUpdateRemoteServerName(
    IADs *pObject,
    LPWSTR ServerName,
    LPWSTR RemainingName,
    BOOLEAN Add )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    VARIANT Variant;
    UNICODE_STRING UpdateName;
    LPWSTR pServers[1];

    //
    // create a unc path using the server and remaining name
    // to get a path of type \\servername\remainingname
    //
    Status = DfsCreateUnicodePathString( &UpdateName,
                                         2, // unc path: 2 leading seperators,
                                         ServerName,
                                         RemainingName);

    pServers[0] = UpdateName.Buffer;

    if (Status == ERROR_SUCCESS)
    {
        //
        // initialize the variant.
        //
        VariantInit( &Variant );

        //
        // Create the variant array with a single entry in it.
        //
        HResult = ADsBuildVarArrayStr( pServers,
                                       1,
                                       &Variant );

        if ( SUCCEEDED(HResult) )
        {
            //
            // either append or delete this string from the remote server 
            // name attribute
            //
            HResult = pObject->PutEx( (Add ? ADS_PROPERTY_APPEND : ADS_PROPERTY_DELETE),
                                      RemoteServerNameString,
                                      Variant );
            if ( SUCCEEDED(HResult) )
            {
                //
                // now update the object in the DS with this info.
                //
                HResult = pObject->SetInfo();
            }

            //
            // clear the variant
            //
            VariantClear( &Variant );
        }


        if ( SUCCEEDED(HResult) == FALSE)
        {
            Status = DfsGetErrorFromHr( HResult );
        }

        //
        // free the unicode string we created earlier on.
        //
        DfsFreeUnicodeString( &UpdateName );
    }

    return Status;
}

                                

DFSSTATUS
DfsDcEnumerateRoots(
    LPWSTR DfsName,
    LPBYTE pBuffer,
    ULONG BufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG_PTR CurrentBuffer = (ULONG_PTR)pBuffer;
    ULONG CurrentSize = BufferSize;

    UNREFERENCED_PARAMETER(DfsName);

    Status = DfsEnumerateDfsADRoots( NULL,
                                     &CurrentBuffer,
                                     &CurrentSize,
                                     pEntriesRead,
                                     pSizeRequired );

    return Status;
}

DFSSTATUS
DfsUpdateRootRemoteServerName(
    LPWSTR Root,
    LPWSTR DCName,
    LPWSTR ServerName,
    LPWSTR RemainingName,
    BOOLEAN Add )

{
    IADs *pRootObject = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsGetDfsRootADObject( DCName,
                                    Root,
                                    &pRootObject );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsUpdateRemoteServerName( pRootObject,
                                            ServerName,
                                            RemainingName,
                                            Add );
        pRootObject->Release();
    }
    return Status;
}

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING DfsSpecialDCShares[] = {
    UNICODE_STRING_STRUCT(L"SYSVOL"),
    UNICODE_STRING_STRUCT(L"NETLOGON"),
};


BOOLEAN
DfsIsSpecialDomainShare(
    PUNICODE_STRING pShareName )
{
    ULONG Index;
    ULONG TotalShares;
    BOOLEAN SpecialShare = FALSE;

    TotalShares = sizeof(DfsSpecialDCShares) / sizeof(DfsSpecialDCShares[0]);
    for (Index = 0; Index < TotalShares; Index++ )
    {
        if (DfsSpecialDCShares[Index].Length == pShareName->Length) {
            if (_wcsnicmp(DfsSpecialDCShares[Index].Buffer,
                          pShareName->Buffer,
                          pShareName->Length/sizeof(WCHAR)) == 0)
            {
                SpecialShare = TRUE;
                break;
            }
        }
    }

    return SpecialShare;
}




DFSSTATUS
DfsInitializeSpecialDCShares()
{
    ULONG Index;
    ULONG TotalShares;
    DFSSTATUS Status = ERROR_SUCCESS;
    TotalShares = sizeof(DfsSpecialDCShares) / sizeof(DfsSpecialDCShares[0]);
    for (Index = 0; Index < TotalShares; Index++ )
    {
        Status = DfsUserModeAttachToFilesystem( &DfsSpecialDCShares[Index],
                                                &DfsSpecialDCShares[Index] );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsregistrystore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRegistryStore.cxx
//
//  Contents:   the Registry DFS Store class, this contains the registry
//              specific functionality.
//
//  Classes:    DfsRegistryStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsRegistryStore.hxx"
#include "DfsRegistryRootFolder.hxx"
#include "DfsFilterApi.hxx"
#include "dfsmisc.h"

#include "shlwapi.h"
#include "align.h"

//
// logging specific includes
//
#include "DfsRegistryStore.tmh" 


//+----------------------------------------------------------------------------
//
//  Class:      DfsRegistryStore
//
//  Synopsis:   This class inherits the basic DfsStore, and extends it
//              to include the registry specific functionality.
//
//-----------------------------------------------------------------------------

LPWSTR DfsRegistryNameString = L"ID";
LPWSTR DfsRegistryRecoveryString = L"Recovery";
LPWSTR DfsRegistryReplicaString  = L"Svc";


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  Name - the namespace of interest.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a registry based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::StoreRecognizer(
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY OldStandaloneDfsKey;
    HKEY StandaloneDfsKey;
    BOOLEAN MachineContacted = FALSE;

    DFSSTATUS OldStandaloneDfsStatus = ERROR_SUCCESS;
    DFSSTATUS NewStandaloneDfsStatus = ERROR_SUCCESS;
    //
    // Make sure the namespace is the name of a machine. Registry based
    // dfs exist only on machines.
    //

    if (IsEmptyString(Name) == FALSE) 
    {
        Status = DfsIsThisAMachineName( Name );
    }


    DFS_TRACE_LOW(REFERRAL_SERVER, "DfsRegistryStore:StoreRecognizer, Name %ws Is Machine Status %x\n", Name, Status);

    //
    // we now find all the migrated multiple roots standalone DFS's as 
    // well as the old single root standalone DFS, and add them to our
    // in memory metadata.
    //
    if ( Status == ERROR_SUCCESS )
    {
        NewStandaloneDfsStatus = GetNewStandaloneRegistryKey( Name,
                                                              FALSE,
                                                              &MachineContacted,
                                                              &StandaloneDfsKey );
        if (NewStandaloneDfsStatus == ERROR_SUCCESS)
        {
            NewStandaloneDfsStatus = StoreRecognizeNewDfs( Name,
                                                           StandaloneDfsKey );

            RegCloseKey( StandaloneDfsKey );
        }

    }

    //
    // recognize old type dfs only on cluster configurations.
    // in all other cases, these should be migrated over.
    //
    if (( Status == ERROR_SUCCESS ) &&
        DfsIsMachineCluster())
    {

        OldStandaloneDfsStatus = GetOldStandaloneRegistryKey( Name,
                                                              FALSE,
                                                              &MachineContacted,
                                                              &OldStandaloneDfsKey );
        //
        // If we can open the DfsOldStandaloneChild registry key,
        // we are sure this machine has an old style dfs. Read it in.
        //
        if (OldStandaloneDfsStatus == ERROR_SUCCESS)
        {
            OldStandaloneDfsStatus = StoreRecognizeOldStandaloneDfs( Name, 
                                                                     OldStandaloneDfsKey );

            RegCloseKey( OldStandaloneDfsKey );
        }
    }


    //
    // The return status is success, unless we know there are roots
    // on this machine that could not be read in correctly.
    //
    if (NewStandaloneDfsStatus != ERROR_SUCCESS) {
        Status = NewStandaloneDfsStatus;
    }
    else if (OldStandaloneDfsStatus != ERROR_SUCCESS) {
        Status = OldStandaloneDfsStatus;
    }
    else {
        Status = ERROR_SUCCESS;
    }

    //
    // Need to refine the return status further: success should mean
    // machine is not std dfs or we have read the std dfs data correctly.
    //
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs registry store recognizser, status %x\n", Status);
    return Status;
}


DFSSTATUS
DfsRegistryStore::LookupNewRootByName(
    LPWSTR ShareName,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;
    HKEY DfsKey, DfsRootKey;
    UNICODE_STRING LogicalShare;

    Status = GetNewStandaloneRegistryKey( NULL,
                                          FALSE,
                                          NULL,
                                          &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = RegOpenKeyEx( DfsKey,
                               ShareName,
                               0,
                               KEY_READ,
                               &DfsRootKey );

        RegCloseKey(DfsKey );
    }

    if (Status != ERROR_SUCCESS)
    {
        Status = GetOldStandaloneRegistryKey( NULL,
                                              FALSE,
                                              NULL,
                                              &DfsRootKey );

        if (Status == ERROR_SUCCESS)
        {
            Status = GetRootLogicalShare( DfsKey,
                                          &LogicalShare);
            if (Status == ERROR_SUCCESS)
            {
                if (_wcsicmp(ShareName, LogicalShare.Buffer) != 0)
                {
                    Status = ERROR_NOT_FOUND;
                }
                ReleaseRootLogicalShare( &LogicalShare );
            }

            if (Status != ERROR_SUCCESS)
            {
                RegCloseKey( DfsRootKey );
            }
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = GetRootFolder( NULL,
                                ShareName,
                                DfsRootKey,
                                ppRootFolder );
        RegCloseKey(DfsRootKey);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizeOldStandaloneDfs -  recognizer for single root dfs
//
//  Arguments:  Name - the namespace of interest.
//              HKEY OldDfsKey.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine reads a single root from the old standalone
//               location, and loads it in if the root exists.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::StoreRecognizeOldStandaloneDfs(
    LPWSTR MachineName,
    HKEY   OldDfsKey )
{
    DfsRootFolder *pRootFolder;
    DFSSTATUS Status;

    //
    // Check if we have a root folder read from the old dfs location 
    // ("domainroot"). If we have not seen the root already, and one
    // exists, a new root folder gets created. 
    //
    Status = GetRootFolder( MachineName,
                            NULL,
                            OldDfsKey,
                            &pRootFolder );

    //
    // We got a root folder. call synchronize on it to update its contents.
    // The synchronize method fills the root with the most upto date
    // children data.
    //

    if (Status == ERROR_SUCCESS)
    {

        DFSSTATUS RootStatus;

        //
        // now acquire the root share directory. If this
        // fails, we continue our operation: we can continue
        // with synchonize and not create directories.
        // dfsdev:we need to post a eventlog or something when
        // we run into this.
        //
        RootStatus = pRootFolder->AcquireRootShareDirectory();

        DFSLOG("Root folder for %ws, validate status %x\n",
               RootStatus );

        //
        // Call the synchronize method on the root to
        // update it with the latest children.
        // Again, ignore the error since we need to move
        // on to the next root.
        // dfsdev: need eventlog to signal this.
        //
        RootStatus = pRootFolder->Synchronize();

        DFSLOG("Root folder for %ws, Synchronize status %x\n",
               RootStatus );

        // Release our reference on the root folder.

        pRootFolder->ReleaseReference();
    }
    
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   CreateNewRootFolder -  creates a new root folder
//
//  Arguments:  Name - the namespace of interest.
//              pPrefix - the logical share for this DFs.
//              ppRoot -  the newly created root.
//
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine creates a new registry root folder, and
//               adds it to the list of known roots.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::CreateNewRootFolder (
    LPWSTR MachineName,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pNewRoot;

    //
    // Create a new instance of the RegistryRootFolder class.
    // This gives us a reference RootFolder.
    //
    pNewRoot = new DfsRegistryRootFolder( MachineName,
                                          RootRegKeyName,
                                          pLogicalShare,
                                          pPhysicalShare,
                                          this,
                                          &Status );

    if ( pNewRoot == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 

    if ( ERROR_SUCCESS == Status )
    {
        //
        // AddRootFolder to the list of known roots. AddRootFolder
        // is responsible to acquire any reference on the root folder
        // if it is storing a reference to this root.

        Status = AddRootFolder( pNewRoot, NewRootList );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We were successful, return the reference root. The reference
            // that we are returning is the create reference on the new root.
            //
            *ppRoot = pNewRoot;
        }
        else 
        {
            pNewRoot->ReleaseReference();
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "RegistryStore::CreateNewRootFolder. New root %p, for root %wZ (%wZ) on machine %ws. Status %x\n",
                        *ppRoot, pLogicalShare, pPhysicalShare, MachineName, Status);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMetadata- Gets the DFS metadata information
//
//  Arguments:  DfsMetadataKey - The key under which the information exists
//              RelativeName   - the name of the subkey, having info of interest
//              RegistryValueNameString - The value name that holds the info.
//              ppData - the pointer that holds data buffer being returned
//              pDataSize - pointer to size of data being returned.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information,
//               error status otherwise.
//
//
//  Description: This routine reads the value of interest under the specified
//               key/subkey. The information is read in a buffer allocated
//               by this routine, and the buffer is returned to the caller.
//               It is the caller's responsibility to free this buffer when
//               done.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::GetMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PVOID *ppData,
    OUT ULONG *pDataSize,
    OUT PFILETIME pLastModifiedTime)
{

    HKEY NewKey = NULL;
    HKEY UseKey = NULL;
    PVOID pDataBuffer = NULL;
    ULONG DataSize, DataType;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    if ( RelativeName != NULL )
    {
        Status = RegOpenKeyEx( DfsMetadataKey, 
                               RelativeName, 
                               0,
                               KEY_READ,
                               &NewKey );
        if ( Status == ERROR_SUCCESS )
        {
            UseKey = NewKey;
        }
    } else
    {
        UseKey = DfsMetadataKey;
    }

    //
    // Get the largest size of any value under the key of interest, so we know
    // how much we need to allocate in the worst case.
    // (If a subkey has 3 values, this returns the maximum memory size required
    // to read any one of the values.)
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegQueryInfoKey( UseKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  pLastModifiedTime ); // Last write time
    }

    //
    // We have the required size now: allocate a buffer for that size and
    // read the value we are interested in.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pDataBuffer = new BYTE [DataSize];

        if ( pDataBuffer == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( UseKey,
                                      RegistryValueNameString,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)pDataBuffer,
                                      &DataSize );
            //
            // If the format of data is not a certain type (usually binary type for DFS)
            // we have bogus data.
            //
            if ( (Status == ERROR_SUCCESS) && (DataType != DFS_REGISTRY_DATA_TYPE) )
            {
                Status = ERROR_INVALID_DATA;
            }
        }
    }

    //
    // If we are successful in reading the value, pass the allcoated buffer and
    // size back to caller. Otherwise, free up the allocate buffer and return
    // error status to the caller.
    //
    if ( Status == ERROR_SUCCESS )
    {
        *ppData = pDataBuffer;
        *pDataSize = DataSize;
    } 
    else 
    {
        if ( pDataBuffer != NULL )
        {
            delete [] pDataBuffer;
        }
    }

    //
    // If we did open a new key, it is time to close it now.
    //
    if ( NewKey != NULL )
        RegCloseKey(NewKey);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   SetMetadata- Sets the DFS metadata information
//
//  Arguments:  DfsMetadataKey - The key under which the information exists
//              RelativeName   - the name of the subkey, to store info
//              RegistryValueNameString - The value name that holds the info.
//              pData - the pointer that holds data buffer
//              DataSize - Size of data
//
//  Returns:    Status
//               STATUS_SUCCESS if we could write the information,
//               error status otherwise.
//
//
//  Description: This routine writes the value of interest under the specified
//               key/subkey. 
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::SetMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize )
{

    HKEY NewKey = NULL;
    HKEY UseKey = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    if ( RelativeName != NULL )
    {
        Status = RegOpenKeyEx( DfsMetadataKey, 
                               RelativeName, 
                               0,
                               KEY_READ | KEY_WRITE,
                               &NewKey );
        if ( Status == ERROR_SUCCESS )
        {
            UseKey = NewKey;
        }
    } else
    {
        UseKey = DfsMetadataKey;
    }

    //
    // Store the value against the passed in value string
    //
    Status = RegSetValueEx( UseKey,
                            RegistryValueNameString,
                            NULL,
                            DFS_REGISTRY_DATA_TYPE,
                            (LPBYTE)pData,
                            DataSize );

    //
    // If we did open a new key, it is time to close it now.
    //
    if ( NewKey != NULL )
        RegCloseKey(NewKey);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   GetRootKey -  get the root key
//
//  Arguments:  Name - the namespace of interest.
//              pMachineContacted - did we contact the machine?
//              pDfsRootKey -  the returned key.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine connects to the appropriate machine, and
//               opens the DFS metadata information in the registry.
//               If it succeeds, the machine hosts a registry DFs, and
//               the opened key is returned.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRegistryStore::GetRootKey(
    LPWSTR MachineName,
    LPWSTR ChildName,
    BOOLEAN *pMachineContacted,
    OUT PHKEY pDfsRootKey )
{
    DFSSTATUS Status;
    HKEY DfsStdRegistryKey;
    LPWSTR UseChildName = NULL;

    if (IsEmptyString(ChildName) == FALSE) 
    {
        UseChildName = ChildName;
    }

    //
    // If there is no childname specified, we are dealing with the
    // old style dfs: a single root exists on the machine under "domainroot".
    // so open that key, and return it.
    // If a childname is specified, we are dealing with a migrated
    // dfs. Open the specified child in the new location.
    //

    if (UseChildName != NULL) 
    {
        Status = GetNewStandaloneRegistryKey( MachineName,
                                              FALSE,
                                              pMachineContacted,
                                              &DfsStdRegistryKey );

        if (Status == ERROR_SUCCESS) 
        {
            //
            // We then open the required child key, and close
            // the parents key.
            //
            Status = RegOpenKeyEx( DfsStdRegistryKey,
                                   ChildName,
                                   0,
                                   KEY_READ,
                                   pDfsRootKey );

            RegCloseKey( DfsStdRegistryKey );
        }
    }
    else 
    {
        //
        // no name was specified. This must be the old standalone
        // child.   (single root)
        //
        Status = GetOldStandaloneRegistryKey( MachineName,
                                              FALSE,
                                              pMachineContacted,
                                              pDfsRootKey );
    }

    DFSLOG("DfsRegistryStore::GetDfsRootKey %ws Machine, Contacted %d Status %x\n",
           MachineName, pMachineContacted ? *pMachineContacted : 2, Status );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDataRecoveryInformation -  Gets recovery info
//
//  Arguments:  DfsMetadataKey -  an open key to the registry.
//              RelativeName - Name of a subkey under the above key.
//              pRecoveryState - The recovery state we read.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the RECOVERY value for the Root or link of
//               a dfs tree and returns with the value.
//               A non-zero state means that some recovery is required.
//               Note that there is more information in the RECOVERY value than
//               the state. Currently, we ignore that information and just return
//               the state.
//               In the future, we dont plan to use this value.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::GetDataRecoveryState (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    OUT PULONG pRecoveryState )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID DataBuffer = NULL, CurrentBuffer;
    ULONG DataSize, CurrentSize;

    Status = GetMetadata (DfsMetadataKey,
                          RelativeName,
                          DfsRegistryRecoveryString,
                          &DataBuffer,
                          &DataSize,
                          NULL ); // we dont care about last mod time.

    //
    // We are currently interested in the first word in the data stream.
    // This holds the recovery state.
    //

    if ( Status == STATUS_SUCCESS )
    {
        CurrentBuffer = DataBuffer;
        CurrentSize = DataSize;
        Status = PackGetULong( pRecoveryState,
                               &CurrentBuffer,
                               &CurrentSize );
    }

    ReleaseMetadataBlob( DataBuffer );

    //
    // If we could not read the value, then we return success and
    // and indicate state of 0. This is so that we can support roots
    // or links that dont have this value.
    //
    if ( Status != ERROR_SUCCESS )
    {
        DFSLOG("DfsRegistryStore::DfsGetDataRecoveryState Status %x\n", 
               Status);

        *pRecoveryState = 0;
        Status = ERROR_SUCCESS;
    }

    return Status;
}





INIT_STANDALONE_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );

    //
    // Immediately following the name value is a timeout value. 
    // This is not in the MiDfsIdProperty because it appers that some
    // of the older DFS may not have the timeout value.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = PackGetULong(&pDfsNameInfo->Timeout,
                              ppBuffer,
                              pSizeRemaining);
        //
        // Use a default value if we cannot get the timeout value in
        // the stream.
        //
        if ( Status != ERROR_SUCCESS )
        {
            pDfsNameInfo->Timeout = 300;   // hard code this value.
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_STANDALONE;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetNameInformation - Packs the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to pack.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the name info
//               error status otherwise.
//
//
//  Description: This routine takes the passedin name information and
//               stores it in the binary stream passed in.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::PackSetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    pDfsNameInfo->State &= ~DFS_VOLUME_FLAVORS;
    //
    // Store the DfsNameInfo in the stream first.
    //
    Status = PackSetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );

    //
    // Follow that info with the timeout information.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = PackSetULong( pDfsNameInfo->Timeout,
                               ppBuffer,
                               pSizeRemaining);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeNameInformation - Gets the size of the name info.
//
//  Arguments:  pDfsNameInfo - info to size.
//
//  Returns:    Status
//               ULONG - size needed
//
//  Description: This routine gets us the size of the binary stream
//               required to pack the passed in name info.
//
//--------------------------------------------------------------------------
ULONG
DfsRegistryStore::PackSizeNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo )
{
    ULONG Size;

    Size = PackSizeInformation( (ULONG_PTR)pDfsNameInfo,
                                 &MiStdDfsIdProperty );

    Size += PackSizeULong();

    return Size;
}



//+-------------------------------------------------------------------------
//
//  Function:   AddChild - Add a child to the metadata.
//
//  Arguments:  
//    DfsMetadataHandle - the Metadata key for the root.
//    PUNICODE_STRING pLinkLogicalName - the logical name of the child
//    LPWSTR ReplicaServer - the first target server for this link.
//    LPWSTR ReplicaPath - the target path for this link
//    LPWSTR Comment  - the comment to be associated with this link.
//    LPWSTR pMetadataName - the metadata name for the child, returned..
//
//
//  Returns:    Status: 
//
//  Description: This routine adds a child to the Root metadata. It packs
//               the link name into the name information. If the replica
//               information exists, it packs that into the replica info.
//               It then saves the name and replica streams under the
//               Childkey.
//               NOTE: this function does not require that the link
//               have atleast one replica. Any such requirements
//               should be enforced by the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::AddChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    IN PUNICODE_STRING pMetadataName )
{
    DFSSTATUS Status;
    PVOID pNameBlob, pReplicaBlob;
    ULONG NameBlobSize, ReplicaBlobSize;

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                                   &pReplicaBlob,
                                                   &ReplicaBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            Status = CreateNewChild( DfsHandle,
                                     pNameBlob, 
                                     NameBlobSize,
                                     pReplicaBlob,
                                     ReplicaBlobSize,
                                     pMetadataName );

            ReleaseMetadataReplicaBlob( pReplicaBlob, ReplicaBlobSize );
        }
        ReleaseMetadataNameBlob( pNameBlob, NameBlobSize );
    }
    return Status;
}


DFSSTATUS
DfsRegistryStore::CreateNewChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PVOID pNameBlob,
    IN ULONG NameBlobSize,
    IN PVOID pReplicaBlob,
    IN ULONG ReplicaBlobSize,
    IN PUNICODE_STRING pMetadataName )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;
    HKEY ChildKey;
    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    //
    // Now create the child with this name
    //      
    Status = RegCreateKeyEx( DfsMetadataKey,
                             pMetadataName->Buffer,
                             0,
                             L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &ChildKey,
                             NULL );

    //
    // Now set the name and replica information on this newly created
    // key.
    //
    if (Status == ERROR_SUCCESS) 
    {
        Status = SetMetadata( ChildKey,
                              NULL,
                              DfsRegistryNameString,
                              pNameBlob,
                              NameBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            Status = SetMetadata( ChildKey,
                                  NULL,
                                  DfsRegistryReplicaString,
                                  pReplicaBlob,
                                  ReplicaBlobSize );
        }
        //
        // we are done with the child key: close it here.
        //
        RegCloseKey (ChildKey);

        //
        // if we were unsuccessful in adding the name and
        // replica details, get rid of the new child registry entry.
        //

        if (Status != ERROR_SUCCESS)
        {
            DFSSTATUS DeleteStatus;

            DeleteStatus = RegDeleteKey( DfsMetadataKey,
                                         pMetadataName->Buffer );

            DFSLOG("Created Key, but failed to add values %x. Delete Status %x\n",
                   Status, DeleteStatus );
        }
    }

    return Status;
}



DFSSTATUS
DfsRegistryStore::RemoveChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName )

{
    DFSSTATUS Status;
    HKEY DfsMetadataKey;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    Status = RegDeleteKey( DfsMetadataKey,
                           ChildName );

    return Status;
}



DFSSTATUS
DfsRegistryStore::CreateStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR LogicalShare,
    LPWSTR Comment )
{
    DFSSTATUS Status;
    HKEY StdDfsKey, StdDfsShareKey;

    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    DfsRootFolder *pRootFolder;

    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;

    PVOID pBlob;
    ULONG BlobSize;

    RtlInitUnicodeString( &DfsMachine, MachineName );
    RtlInitUnicodeString( &DfsShare, LogicalShare );
    RtlZeroMemory(&NameInfo, sizeof(DFS_NAME_INFORMATION));

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, create root %ws\n", LogicalShare);
    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, create root, lookup root %p, status %x\n", pRootFolder, Status);

    if (Status == ERROR_SUCCESS)
    {
        pRootFolder->ReleaseReference();

        return ERROR_FILE_EXISTS;
    }

    Status = GetNewStandaloneRegistryKey( MachineName,
                                          TRUE, // write permission required
                                          NULL,
                                          &StdDfsKey );
    if (Status == ERROR_SUCCESS)
    {
        UNICODE_STRING LogicalName;

        RtlInitUnicodeString( &LogicalName, LogicalShare );
        StoreInitializeNameInformation( &NameInfo,
                                        &LogicalName,
                                        NULL,
                                        Comment );
        NameInfo.Type |= 0x80;

        StoreInitializeReplicaInformation( &ReplicaListInfo,
                                           &ReplicaInfo,
                                           (MachineName == NULL) ? L"." : MachineName,
                                           LogicalShare );
    }
    
    if (Status == ERROR_SUCCESS) {
#if defined (DFS_FUTURES)
        //
        // Check if we need to store the root as a guid instead of
        // the root name itself.
        // It is probably not necessary, but for some reason if we need
        // to, we can scavenge this code.
        //
        //
        // get an unique metadata name for the root.
        //

        Status = DfsGenerateUuidString(&UuidString);
#endif

        Status = RegCreateKeyEx( StdDfsKey,
                                 LogicalShare,
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &StdDfsShareKey,
                                 NULL );
            
        if (Status == ERROR_SUCCESS) 
        {
            if (Status == ERROR_SUCCESS)
            {
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsRootShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)LogicalShare,
                                        wcslen(LogicalShare) * sizeof(WCHAR) );
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = RegSetValueEx( StdDfsShareKey,
                                        DfsLogicalShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)LogicalShare,
                                        wcslen(LogicalShare) * sizeof(WCHAR) );
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = CreateNameInformationBlob( &NameInfo,
                                                    &pBlob,
                                                    &BlobSize);
                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( StdDfsShareKey,
                                          NULL,
                                          DfsRegistryNameString,
                                          pBlob,
                                          BlobSize );
                    ReleaseMetadataNameBlob(pBlob, BlobSize );
                }
            }

            if (Status == ERROR_SUCCESS) 
            {
                Status = CreateReplicaListInformationBlob( &ReplicaListInfo,
                                                           &pBlob,
                                                           &BlobSize);
                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( StdDfsShareKey,
                                          NULL,
                                          DfsRegistryReplicaString,
                                          pBlob,
                                          BlobSize );
                    ReleaseMetadataNameBlob( pBlob, BlobSize );
                }
            }
                
            if (Status == ERROR_SUCCESS)
            {
                DfsRootFolder *pRootFolder;
                Status = GetRootFolder( MachineName,
                                        LogicalShare,
                                        &DfsShare,
                                        &DfsShare,
                                        &pRootFolder );
                                              
                if (Status == ERROR_SUCCESS)
                {
                    //
                    // Now, acquire the root share directory. If we fail
                    // this, we deny the creation of the root.
                    // acquire root share directory converts the root share
                    // to a physical path, checks if that supports
                    // reparse points, and if so tells the dfs driver
                    // to attach to the drive.
                    // if any of these fail, we cannot proceed.
                    //
                    Status = pRootFolder->AcquireRootShareDirectory();

                    if (Status != ERROR_SUCCESS)
                    {
                        //
                        // make a best effort to remove ourselves
                        // dont care about status return, thoug
                        // we may want to log it. 
                        //dfsdev: add logging.
                        //
                        RemoveRootFolder(pRootFolder,
                                         TRUE ); // permanent removal
                    }
                    
                    //
                    // now mark the root folder as synchronized:
                    // this is true since this root is empty.
                    //
                    if (Status == ERROR_SUCCESS)
                    {
                        pRootFolder->SetRootFolderSynchronized();
                    }

                    pRootFolder->ReleaseReference();
                }

                DFSLOG("Add Standalone Root, adding root folder status %x\n", Status);
            }

            RegCloseKey( StdDfsShareKey );
            if (Status != ERROR_SUCCESS)
            {
                RegDeleteKey( StdDfsKey,
                              LogicalShare );
            }
        }

#if defined (DFS_FUTURES)
        DfsReleaseUuidString(&UuidString);
#endif

        RegCloseKey( StdDfsKey );
    }
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "registry store, create root %ws, status %x\n", LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsRegistryStore::DeleteStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR LogicalShare )

{
    DFSSTATUS Status;
    HKEY DfsKey;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    DfsRootFolder *pRootFolder = NULL;
    LPWSTR RootRegistryName, UseChildName;

    RtlInitUnicodeString( &DfsMachine, MachineName );
    RtlInitUnicodeString( &DfsShare, LogicalShare );

    DFS_TRACE_LOW( REFERRAL_SERVER, "Delete Standalone root %ws\n", LogicalShare);
    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "Delete Standalone root, lookup root %p, status %x\n", pRootFolder, Status);

    if (Status == ERROR_SUCCESS)
    {
        Status = pRootFolder->AcquireRootLock();
        if (Status == ERROR_SUCCESS)
        {
            pRootFolder->SetRootFolderDeleteInProgress();
            pRootFolder->ReleaseRootLock();
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        RootRegistryName = pRootFolder->GetRootRegKeyNameString();

        UseChildName = (IsEmptyString(RootRegistryName) == TRUE) ? NULL : RootRegistryName;

        if (UseChildName == NULL)
        {
            Status = GetOldDfsRegistryKey( MachineName,
                                           TRUE,
                                           NULL,
                                           &DfsKey );
            if (Status == ERROR_SUCCESS)
            {
                Status = SHDeleteKey( DfsKey,
                                      DfsOldStandaloneChild);

                RegCloseKey( DfsKey );
            }
        }
        else
        {
            Status = GetNewStandaloneRegistryKey( MachineName,
                                                  TRUE,
                                                  NULL,
                                                  &DfsKey );
            if (Status == ERROR_SUCCESS)
            {
                Status = SHDeleteKey( DfsKey,
                                      UseChildName );
                                      
                RegCloseKey( DfsKey );
            }
        }
    }

    //
    // DfsDev: needs fixing.
    //
    if (Status == ERROR_SUCCESS)
    {
        NTSTATUS DeleteStatus;

        //
        // Release the root folder that we had acquired earlier for
        // this root.
        //

        DeleteStatus = RemoveRootFolder( pRootFolder,
                                         TRUE ); // permanent removal

        DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "remove root folder %p (%ws) status %x\n", pRootFolder, LogicalShare, DeleteStatus);

        
        DeleteStatus = pRootFolder->ReleaseRootShareDirectory();
        DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "release root share for %ws status %x\n", LogicalShare, DeleteStatus);

        pRootFolder->ReleaseReference();
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Delete Standalone root for %ws, done, status %x\n", LogicalShare, Status);
    return Status;
}



DFSSTATUS
DfsRegistryStore::EnumerateApiLinks(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    LPDWORD pEntriesToRead,
    LPDWORD pResumeHandle,
    PLONG pSizeRequired )
{
    HKEY DfsKey;
    ULONG ChildNum;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN OverFlow;
    LONG HeaderSize;
    LONG EntriesRead = 0;
    LONG EntriesToRead = *pEntriesToRead;
    LONG SizeRequired = 0;
    LONG EntryCount = 0;

    LPBYTE pLinkBuffer = NULL;
    LONG LinkBufferSize = 0;

    LPBYTE CurrentBuffer, NewBuffer;
    LONG SizeRemaining;
    DFSSTATUS PackStatus;
    
    ULONG_PTR SizeDiff;

    DfsKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    OverFlow = FALSE;
    HeaderSize = DfsApiSizeLevelHeader( Level );

    SizeRequired = ROUND_UP_COUNT(EntriesToRead * HeaderSize, ALIGN_QUAD);
    if (EntriesToRead * HeaderSize < BufferSize )
    {
        CurrentBuffer = (LPBYTE)((ULONG_PTR)pBuffer + EntriesToRead * HeaderSize);
        SizeRemaining = BufferSize - EntriesToRead * HeaderSize;
    }
    else 
    {
        CurrentBuffer = pBuffer;
        SizeRemaining = 0;
        OverFlow = TRUE;
    }


    EntryCount = *pResumeHandle;
    if (EntryCount == 0)
    {
        Status = GetStoreApiInformationBuffer ( DfsHandle,
                                                pRootName,
                                                NULL,
                                                Level,
                                                &pLinkBuffer,
                                                &LinkBufferSize );
        if (Status == ERROR_SUCCESS)
        {
            SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);

            if (OverFlow == FALSE)
            {
                PackStatus = PackageEnumerationInfo( Level,
                                                     EntriesRead,
                                                     pLinkBuffer,
                                                     pBuffer,
                                                     &CurrentBuffer,
                                                     &SizeRemaining );
                if (PackStatus == ERROR_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                }
                NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                SizeDiff = (NewBuffer - CurrentBuffer);
                if ((LONG)SizeDiff > SizeRemaining)
                {
                    SizeRemaining = 0;
                }
                else 
                {
                    SizeRemaining -= (LONG)SizeDiff;
                }
                CurrentBuffer = NewBuffer;
            }
            ReleaseStoreApiInformationBuffer( pLinkBuffer );
            EntryCount++;
            EntriesRead++;
        }
    }

    if (Status != ERROR_SUCCESS )
    {
        return Status;
    }
    ChildNum = EntryCount - 1;

    do
    {
        //
        // For each child, get the child name.
        //

        DWORD ChildNameLen = DFS_REGISTRY_CHILD_NAME_SIZE_MAX;
        WCHAR ChildName[DFS_REGISTRY_CHILD_NAME_SIZE_MAX];

        if (EntriesToRead && EntriesRead >= EntriesToRead)
        {
            break;
        }

        //
        // Now enumerate the children, starting from the first child.
        //
        Status = RegEnumKeyEx( DfsKey,
                               ChildNum,
                               ChildName,
                               &ChildNameLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        ChildNum++;

        if (Status == ERROR_SUCCESS)
        {
            Status = GetStoreApiInformationBuffer( DfsHandle,
                                                   pRootName,
                                                   ChildName,
                                                   Level,
                                                   &pLinkBuffer,
                                                   &LinkBufferSize );

            if (Status == ERROR_SUCCESS)
            {
                SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);
                
                if (OverFlow == FALSE) 
                {
                    DFSSTATUS PackStatus;
                    PackStatus = PackageEnumerationInfo( Level,
                                                         EntriesRead,
                                                         pLinkBuffer,
                                                         pBuffer,
                                                         &CurrentBuffer,
                                                         &SizeRemaining );
                    if (PackStatus == ERROR_BUFFER_OVERFLOW)
                    {
                        OverFlow = TRUE;
                    }
                    NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                    SizeDiff = (NewBuffer - CurrentBuffer);
                    if ((LONG)SizeDiff > SizeRemaining)
                    {
                        SizeRemaining = 0;
                    }
                    else 
                    {
                        SizeRemaining -= (LONG)SizeDiff;
                    }
                    CurrentBuffer = NewBuffer;
                }

                ReleaseStoreApiInformationBuffer( pLinkBuffer );
                EntryCount++;
                EntriesRead++;
            }
        }
    } while (Status == ERROR_SUCCESS);

    *pSizeRequired = SizeRequired;

    
    if (Status == ERROR_NO_MORE_ITEMS) 
    {
        if (EntriesRead) 
        {
            if (OverFlow) 
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                Status = ERROR_SUCCESS;
            }
        }

    }
    else if (OverFlow)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        *pResumeHandle = EntryCount;
        *pEntriesToRead = EntriesRead;
    }

    return Status;
}






DFSSTATUS
DfsRegistryStore::GetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID *ppData,
    PULONG pDataSize,
    PFILETIME pLastModifiedTime )
    {
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = GetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryNameString,
                          ppData,
                          pDataSize,
                          pLastModifiedTime );

    return Status;
}


DFSSTATUS
DfsRegistryStore::GetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID *ppData,
    PULONG pDataSize,
    PFILETIME pLastModifiedTime )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = GetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryReplicaString,
                          ppData,
                          pDataSize,
                          pLastModifiedTime );

    return Status;
}



DFSSTATUS
DfsRegistryStore::SetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pData,
    ULONG DataSize )

{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = SetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryNameString,
                          pData,
                          DataSize );
    return Status;
}


DFSSTATUS
DfsRegistryStore::SetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pData,
    ULONG DataSize )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( RootHandle );

    Status = SetMetadata( DfsMetadataKey,
                          MetadataName,
                          DfsRegistryReplicaString,
                          pData,
                          DataSize );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsstore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsStore.cxx
//
//  Contents:   the base DFS Store class, this contains the common
//              store functionality.
//
//  Classes:    DfsStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsStore.hxx"

//
// logging stuff
//

#include "dfsstore.tmh" 


// Initialize the common marshalling info for Registry and ADLegacy stores.
//
INIT_FILE_TIME_INFO();
INIT_DFS_REPLICA_INFO_MARSHAL_INFO();

//+-------------------------------------------------------------------------
//
//  Function:   PackGetInfo - unpacks information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              interpret the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
DfsStore::PackGetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackGetInformation(Info + typeInfo->_off,
                                           ppBuffer,
                                           pSizeRemaining,
                                           typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackGetULong( (PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackGetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackGetGuid( (GUID *)(Info + typeInfo->_off),
                                  ppBuffer,
                                  pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
DFSSTATUS
DfsStore::PackSetInformation(
    ULONG_PTR Info,
    PVOID *ppBuffer,
    PULONG pSizeRemaining,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    DFSSTATUS Status = ERROR_INVALID_DATA;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Status = PackSetInformation( Info + typeInfo->_off,
                                            ppBuffer,
                                            pSizeRemaining,
                                            typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Status = PackSetULong( *(PULONG)(Info + typeInfo->_off),
                                      ppBuffer,
                                      pSizeRemaining );
            break;

        case MTYPE_PWSTR:
            Status = PackSetString( (PUNICODE_STRING)(Info + typeInfo->_off),
                                       ppBuffer,
                                       pSizeRemaining );

            break;

        case MTYPE_GUID:

            Status = PackSetGuid( (GUID *)(Info + typeInfo->_off),
                                     ppBuffer,
                                     pSizeRemaining );
            break;

        default:
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeInformation - packs information based on MARSHAL_INFO struct
//
//  Arguments:  pInfo - pointer to the info buffer to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//              pMarshalInfo - pointer to information that describes how to
//              pack the info into the binary stream.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream can hold all the 
//               information that is necessary to pack the information
//               described by the MARSHAL_INFO structure.
//--------------------------------------------------------------------------
ULONG
DfsStore::PackSizeInformation(
    ULONG_PTR Info,
    PMARSHAL_INFO pMarshalInfo )
{
    PMARSHAL_TYPE_INFO typeInfo;
    ULONG Size = 0;

    for ( typeInfo = &pMarshalInfo->_typeInfo[0];
        typeInfo < &pMarshalInfo->_typeInfo[pMarshalInfo->_typecnt];
        typeInfo++ )
    {

        switch ( typeInfo->_type & MTYPE_BASE_TYPE )
        {
        case MTYPE_COMPOUND:
            Size += PackSizeInformation( Info + typeInfo->_off,
                                              typeInfo->_subinfo);
            break;

        case MTYPE_ULONG:
            Size += PackSizeULong();

            break;

        case MTYPE_PWSTR:
            Size += PackSizeString( (PUNICODE_STRING)(Info + typeInfo->_off) );
            
            break;

        case MTYPE_GUID:

            Size += PackSizeGuid();
            break;

        default:
            break;
        }
    }

    return Size;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackGetReplicaInformation - Unpacks the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete replica
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine expects to find "replicaCount" number of individual
//               binary streams in passed in buffer. Each stream starts with
//               the size of the stream, followed by that size of data.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::PackGetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackGetULong( &pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );


        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because UnpackUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this unpack returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackGetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );
            //
            // We now point the buffer to the next sub-stream, which is the previos
            // stream + the size of the stream. We also set the remaining size
            // appropriately.
            //
            *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
            *pSizeRemaining -= pReplicaInfo->DataSize;

        }
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetReplicaInformation - packs the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the replica info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to be able to
//               hold the information that will be copied from the
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine stores a "replicaCount" number of individual
//               binary streams as the first ulong, and then it packs each
//               stream.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::PackSetReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    PVOID *ppBuffer,
    PULONG pSizeRemaining)
{
    ULONG Count;

    ULONG ReplicaSizeRemaining;
    PVOID nextStream;
    DFSSTATUS Status = ERROR_SUCCESS;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        //
        // We now have a binary stream in ppBuffer, the first word of which
        // indicates the size of this stream.
        //
        Status = PackSetULong( pReplicaInfo->DataSize,
                               ppBuffer,
                               pSizeRemaining );

        //
        // ppBuffer is now pointing past the size (to the binary stream) 
        // because packUlong added size of ulong to it.
        // Unravel that stream into the next array element. 
        // Note that when this returns, the ppBuffer is not necessarily
        // pointing to the next binary stream within this blob. 
        //

        if ( Status == ERROR_SUCCESS )
        {
            nextStream = *ppBuffer;
            ReplicaSizeRemaining = pReplicaInfo->DataSize;

            Status = PackSetInformation( (ULONG_PTR)pReplicaInfo,
                                         ppBuffer,
                                         &ReplicaSizeRemaining,
                                         &MiDfsReplicaInfo );

            //
            // We now point the buffer to the next sub-stream, which is the previos
            // stream + the size of the stream. We also set the remaining size
            // appropriately.
            //  
            *ppBuffer = (PVOID)((ULONG_PTR)nextStream + pReplicaInfo->DataSize);
            *pSizeRemaining -= pReplicaInfo->DataSize;
        }

        if ( Status != ERROR_SUCCESS )
        {
            break;
        }
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeReplicaInformation - packs the replica info
//
//  Arguments:  pDfsReplicaInfo - pointer to the info to pack
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the replica info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to be able to
//               hold the information that will be copied from the
//               info structure (as defined by MiDfsReplicaInfo). If the stream 
//               does not have the sufficient info, ERROR_INVALID_DATA is 
//               returned back.
//               This routine stores a "replicaCount" number of individual
//               binary streams as the first ulong, and then it packs each
//               stream.
//
//--------------------------------------------------------------------------

ULONG
DfsStore::PackSizeReplicaInformation(
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    ULONG Count;
    ULONG Size = 0;

    for ( Count = 0; Count < pReplicaListInfo->ReplicaCount; Count++ )
    {
        PDFS_REPLICA_INFORMATION pReplicaInfo;

        pReplicaInfo = &pReplicaListInfo->pReplicas[Count];

        Size += PackSizeULong();

        pReplicaInfo->DataSize = PackSizeInformation( (ULONG_PTR)pReplicaInfo,
                                                      &MiDfsReplicaInfo );
        Size += pReplicaInfo->DataSize;
    }
    
    return Size;
}


//+-------------------------------------------------------------------------
//
//  Function:   LookupRoot - Find a root
//
//  Arguments:  pContextName - the Dfs Name Context
//              pLogicalShare - the Logical Share
//              ppRoot - the DfsRootFolder that was found
//
//  Returns:    Status
//               ERROR_SUCCESS if we found a matching root
//               error status otherwise.
//
//
//  Description: This routine takes a Dfs name context and logical share,
//               and returns a Root that matches the passed in name 
//               context and logical share, if one exists.
//               Note that the same DFS NC and logical share may exist 
//               in more than one store (though very unlikely). In this
//               case, the first registered store wins.
//               IF found, the reference root folder will be returned.
//               It is the callers responsibility to release this referencce
//               when the caller is done with this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::LookupRoot(
    PUNICODE_STRING pContextName,
    PUNICODE_STRING pLogicalShare,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;
    DfsRootFolder *pRoot;
    UNICODE_STRING DfsNetbiosNameContext;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Lookup root %wZ %wZ\n", pContextName, pLogicalShare);
    //
    // First, convert the context name to a netbios context name.
    //
    DfsGetNetbiosName( pContextName, &DfsNetbiosNameContext, NULL );

    //
    // Lock the store, so that we dont have new roots coming in while
    // we are taking a look.
    //
    Status = AcquireReadLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // The default return status is ERROR_NOT_FOUND;
    //
    Status = ERROR_NOT_FOUND;

    //
    // Run through our list of DFS roots, and see if any of them match
    // the passed in name context and logical share.
    //

    pRoot = _DfsRootList;

    if (pRoot != NULL)
    {
        do
        {
            DFS_TRACE_LOW( REFERRAL_SERVER, "Lookup root, checking root %wZ \n", pRoot->GetLogicalShare());
            //
            // If the Root indicates that the name context needs to be
            // ignored, just check for logical share name match (aliasing
            // support).
            // Otherwise, compare the namecontext in the cases where
            // the passed in name context is not empty.
            //
            if ( (pRoot->IsIgnoreNameContext() == TRUE) ||
                 (DfsNetbiosNameContext.Length != 0 &&
                  (RtlCompareUnicodeString(&DfsNetbiosNameContext,
                                           pRoot->GetNetbiosNameContext(),
                                           TRUE) == 0 )) )
            {
                if ( RtlCompareUnicodeString( pLogicalShare,
                                              pRoot->GetLogicalShare(),
                                              TRUE) == 0 )
                {
                    Status = ERROR_SUCCESS;
                    break;
                }
            }
            pRoot = pRoot->pNextRoot;
        } while ( pRoot != _DfsRootList );
    }

    //
    // IF we found a matching root, bump up its reference count, and
    // return the pointer to the root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pRoot->AcquireReference();
        *ppRootFolder = pRoot;

    }

    ReleaseLock();

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Done Lookup root for %wZ, root %p status %x\n",
                         pLogicalShare, pRoot, Status);
    return Status;
}



DFSSTATUS
DfsStore::GetRootPhysicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootPhysicalShare )
{
    DFSSTATUS Status;
    ULONG DataSize, DataType;
    LPWSTR DfsRootShare = NULL;

    Status = RegQueryInfoKey( RootKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        DfsRootShare = (LPWSTR) new BYTE [DataSize];
        if ( DfsRootShare == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( RootKey,
                                      DfsRootShareValueName,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)DfsRootShare,
                                      &DataSize );
        }
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (DataType == REG_SZ)
        {
            RtlInitUnicodeString( pRootPhysicalShare, DfsRootShare );
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        if (DfsRootShare != NULL)
        {
            delete [] DfsRootShare;
        }
    }
    return Status;
}

VOID
DfsStore::ReleaseRootPhysicalShare(
    PUNICODE_STRING pRootPhysicalShare )
{
    delete [] pRootPhysicalShare->Buffer;
}


DFSSTATUS
DfsStore::GetRootLogicalShare(
    HKEY RootKey,
    PUNICODE_STRING pRootLogicalShare )
{
    DFSSTATUS Status;
    ULONG DataSize, DataType;
    LPWSTR DfsRootShare = NULL;

    Status = RegQueryInfoKey( RootKey,       // Key
                              NULL,         // Class string
                              NULL,         // Size of class string
                              NULL,         // Reserved
                              NULL,         // # of subkeys
                              NULL,         // max size of subkey name
                              NULL,         // max size of class name
                              NULL,         // # of values
                              NULL,         // max size of value name
                              &DataSize,    // max size of value data,
                              NULL,         // security descriptor
                              NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        DfsRootShare = (LPWSTR) new BYTE [DataSize];
        if ( DfsRootShare == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( RootKey,
                                      DfsLogicalShareValueName,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)DfsRootShare,
                                      &DataSize );
        }
    }
    if (Status == ERROR_SUCCESS) 
    {
        if (DataType == REG_SZ)
        {
            RtlInitUnicodeString( pRootLogicalShare, DfsRootShare );
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        if (DfsRootShare != NULL)
        {
            delete [] DfsRootShare;
        }
    }
    return Status;
}

VOID
DfsStore::ReleaseRootLogicalShare(
    PUNICODE_STRING pRootLogicalShare )
{
    delete [] pRootLogicalShare->Buffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizeNewDfs -  the recognizer for new style dfs
//
//  Arguments:  Name - the namespace of interest.
//              DfsKey - the key for the DFS registry space.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine looks up all the standalone roots
//               hosted on this machine, and looks up the metadata for
//               the roots and either creates new roots or updates existing
//               ones to reflect the current children of the root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::StoreRecognizeNewDfs(
    LPWSTR MachineName,
    HKEY   DfsKey )
{
    DfsRootFolder *pRootFolder;
    HKEY DfsRootKey;
    DFSSTATUS Status;
    ULONG ChildNum = 0;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Attempting to recognize new DFS\n");
    do
    {
        //
        // For each child, get the child name.
        //

        DWORD ChildNameLen = DFS_REGISTRY_CHILD_NAME_SIZE_MAX;
        WCHAR ChildName[DFS_REGISTRY_CHILD_NAME_SIZE_MAX];

        //
        // Now enumerate the children, starting from the first child.
        //
        Status = RegEnumKeyEx( DfsKey,
                               ChildNum,
                               ChildName,
                               &ChildNameLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        ChildNum++;


        if ( Status == ERROR_SUCCESS )
        {
            DFS_TRACE_LOW(REFERRAL_SERVER, "Recognize New Dfs, found root (#%d) with metaname %ws\n", ChildNum, ChildName );
            //
            // We have the name of a child, so open the key to
            // that root.
            //
            Status = RegOpenKeyEx( DfsKey,
                                   ChildName,
                                   0,
                                   KEY_READ,
                                   &DfsRootKey );

            if (Status == ERROR_SUCCESS)
            {
                //
                // Now get either an existing root by this name,
                // or create a new one.
                //
                Status = GetRootFolder( MachineName,
                                        ChildName,
                                        DfsRootKey,
                                        &pRootFolder );

                if (Status == ERROR_SUCCESS)
                {

                    DFSSTATUS RootStatus;

                    //
                    // Call the synchronize method on the root to
                    // update it with the latest children.
                    // Again, ignore the error since we need to move
                    // on to the next root.
                    // dfsdev: need eventlog to signal this.
                    //
                    RootStatus = pRootFolder->Synchronize();

                    DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize DFS: Root folder for %ws, Synchronize status %x\n",
                           ChildName, RootStatus );
                    
                    // Release our reference on the root folder.

                    pRootFolder->ReleaseReference();
                }

                //
                // Close the root key, we are done with it.
                //
                RegCloseKey( DfsRootKey );
            }
        }

    } while (Status == ERROR_SUCCESS);

    //
    // If we ran out of children, then return success code.
    //
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Status = ERROR_SUCCESS;
    }
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Done with recognize new dfs, Status %x\n", Status);
    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder -  Get a root folder if the machine
//                                  hosts a registry based DFS.
//
//  Arguments:  Name - the namespace of interest.
//              Key - the root key
//              ppRootFolder - the created folder.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine reads in the information
//               about the root and creates and adds it to our
//               list of known roots, if this one does not already
//               exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsStore::GetRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    HKEY DfsRootKey,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;
    UNICODE_STRING LogicalShare;
    UNICODE_STRING PhysicalShare;

    //
    // Get the logical name information of this root.
    //

    Status = GetRootLogicalShare( DfsRootKey,
                                  &LogicalShare );


    //
    // we successfully got the logical share, now get the physical share
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = GetRootPhysicalShare( DfsRootKey,
                                       &PhysicalShare );
        if (Status != ERROR_SUCCESS)
        {
            PhysicalShare = LogicalShare;
            Status = ERROR_SUCCESS;
        }


        Status = GetRootFolder ( DfsNameContextString,
                                 RootRegKeyName,
                                 &LogicalShare,
                                 &PhysicalShare,
                                 ppRootFolder );

        //
        // Normally, we get the physical share from the registry. If that failed, 
        // we dont treat it as fatal, and just use the logical share as the physical one.
        // If we ever did that, detect the case and dont
        // release the physical server.
        //
        // Otherwise, free up the buffer we allocated earlier on
        // at this point.
        //

        if (PhysicalShare.Buffer != LogicalShare.Buffer)
        {
            ReleaseRootPhysicalShare( &PhysicalShare );
        }

        ReleaseRootLogicalShare( &LogicalShare );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;

    UNICODE_STRING DfsNameContext;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Get Root Folder for %wZ\n", pLogicalShare);
    //
    // we have bot the logical DFS share name, as well as the local machine 
    // physical share that is backing the DFS logical share.
    // now get a root folder for this dfs root.
    //

    RtlInitUnicodeString( &DfsNameContext, DfsNameContextString );

    //
    // Check if we already know about this root. If we do, this
    // routine gives us a referenced root folder which we can return.
    // If not, we create a brand new root folder.
    //

    Status = LookupRoot( &DfsNameContext,
                         pLogicalShare,
                         ppRootFolder );

    //
    // we did not find a root, so create a new one.
    //
    if ( Status != STATUS_SUCCESS )
    {
        Status = CreateNewRootFolder( DfsNameContextString,
                                      RootRegKeyName,
                                      pLogicalShare,
                                      pPhysicalShare,
                                      ppRootFolder );

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Created New Dfs Root %p, Share %wZ, Status %x\n", 
                             *ppRootFolder, pPhysicalShare, Status);
    } 
    else
    {
        //
        // There is an existing root with this name.
        // Validate that the root we looked up matches the 
        // metadata we are currently processing. If not, we
        // have 2 roots with the same logical share name in the
        // registry which is bogus.

        //
        // Dfs dev: rip out the following code.
        // just check for equality of the 2 roots.
        // they will not be null strings
        //
        if (RootRegKeyName != NULL)
        {
            if (_wcsicmp(RootRegKeyName,
                         (*ppRootFolder)->GetRootRegKeyNameString()) != 0)
            {
                (*ppRootFolder)->ReleaseReference();
                *ppRootFolder = NULL;
                Status = ERROR_DUP_NAME;
            }
        }
        else
        {
            if (IsEmptyString((*ppRootFolder)->GetRootRegKeyNameString()) == FALSE) 
            {
                (*ppRootFolder)->ReleaseReference();
                *ppRootFolder = NULL;
                Status = ERROR_DUP_NAME;
            }
        }

        //
        // If the above comparison matched, we found a root for the
        // logical volume, make sure that the physical share names
        // that is exported on the local machine to back the logical share
        // matches.
        //


        if (Status == ERROR_SUCCESS)
        {
            if (RtlCompareUnicodeString( pPhysicalShare,
                                         (*ppRootFolder)->GetRootPhysicalShareName(),
                                         TRUE ) != 0)
            {
                //
                // dfsdev: use appropriate status code.
                //

                Status = ERROR_INVALID_PARAMETER;
            }
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "GetRootFolder: Root %p, Status %x\n",
                        *ppRootFolder, Status);

    return Status;
}


DFSSTATUS
DfsStore::PackageEnumerationInfo( 
    DWORD Level,
    DWORD EntryCount,
    LPBYTE pLinkBuffer,
    LPBYTE pBuffer,
    LPBYTE *ppCurrentBuffer,
    PLONG  pSizeRemaining )
{
    PDFS_API_INFO pInfo;
    PDFS_API_INFO pCurrent = (PDFS_API_INFO)pLinkBuffer;
    LONG HeaderSize;
    ULONG_PTR NextFreeMemory;
    PDFS_STORAGE_INFO pNewStorage, pOldStorage;
    LONG TotalStores, i;
    DFSSTATUS Status = ERROR_SUCCESS;
    LONG NeedLen;

    NextFreeMemory = (ULONG_PTR)*ppCurrentBuffer;

    HeaderSize = DfsApiSizeLevelHeader( Level );
    pInfo = (PDFS_API_INFO)((ULONG_PTR)pBuffer + HeaderSize * EntryCount);
    
    RtlCopyMemory( pInfo, pLinkBuffer, HeaderSize );

    pNewStorage = NULL;

    switch (Level)
    {
    case 4:
        if (pNewStorage == NULL)
        {
            pNewStorage = pInfo->Info4.Storage = (PDFS_STORAGE_INFO)NextFreeMemory;
            pOldStorage = pCurrent->Info4.Storage;
            TotalStores = pInfo->Info4.NumberOfStorages;
        }

    case 3:
        if (pNewStorage == NULL)
        {
            pNewStorage = pInfo->Info3.Storage = (PDFS_STORAGE_INFO)NextFreeMemory;
            pOldStorage = pCurrent->Info3.Storage;
            TotalStores = pInfo->Info3.NumberOfStorages;
        }

        NeedLen = sizeof(DFS_STORAGE_INFO) * TotalStores;
        if (*pSizeRemaining >= NeedLen) {
            *pSizeRemaining -= NeedLen;
            NextFreeMemory += NeedLen;
        }
        else{
            return ERROR_BUFFER_OVERFLOW;
        }

        for (i = 0; i < TotalStores; i++)
        {
            pNewStorage[i] = pOldStorage[i];

            pNewStorage[i].ServerName = (LPWSTR)NextFreeMemory;
            NeedLen = (wcslen(pOldStorage[i].ServerName) + 1) * sizeof(WCHAR);
            if (*pSizeRemaining >= NeedLen) 
            {
                *pSizeRemaining -= NeedLen;
                wcscpy(pNewStorage[i].ServerName,
                       pOldStorage[i].ServerName);
                NextFreeMemory += NeedLen;
            }
            else {
                return ERROR_BUFFER_OVERFLOW;
            }

            pNewStorage[i].ShareName = (LPWSTR)NextFreeMemory;
            NeedLen = (wcslen(pOldStorage[i].ShareName) + 1) * sizeof(WCHAR);
            if (*pSizeRemaining >= NeedLen) 
            {
                *pSizeRemaining -= NeedLen;
                wcscpy(pNewStorage[i].ShareName, pOldStorage[i].ShareName);
                NextFreeMemory += NeedLen;
            }
            else {
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    
    case 2:
        pInfo->Info2.Comment = (LPWSTR)NextFreeMemory;
        NeedLen = (wcslen(pCurrent->Info2.Comment) + 1) * sizeof(WCHAR);
        if (*pSizeRemaining >= NeedLen) 
        {
            *pSizeRemaining -= NeedLen;
            wcscpy(pInfo->Info2.Comment, pCurrent->Info2.Comment);
            NextFreeMemory += NeedLen;
        }
        else {
            return ERROR_BUFFER_OVERFLOW;
        }
    case 1:

        pInfo->Info1.EntryPath = (LPWSTR)NextFreeMemory;

        NeedLen = (wcslen(pCurrent->Info1.EntryPath) + 1) * sizeof(WCHAR);
        if (*pSizeRemaining >= NeedLen)
        {
            *pSizeRemaining -= NeedLen;
            wcscpy(pInfo->Info1.EntryPath, pCurrent->Info1.EntryPath);
            NextFreeMemory += NeedLen;
        }
        else {
            return ERROR_BUFFER_OVERFLOW;
        }

        *ppCurrentBuffer = (LPBYTE)NextFreeMemory;
        break;

    default:
        Status = ERROR_INVALID_PARAMETER;
    }
    return Status;
}





#if defined (OLD_ENUM_CODE)

//+-------------------------------------------------------------------------
//
//  Function:   EnumerateRoots - enumerate all roots on the given machine
//
//  Arguments: 
//    LPWSTR MachineName  - name of the machine on which to enumerate.
//    LPBYTE pBuffer,  - the buffer to fill in
//    ULONG  BufferSize  - the size of tghe buffer.
//    PULONG pEntriesRead  - the cumulative count of entries read.
//    PULONG pSizeRequired - the total size required.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the enumeartion info.
//               ERROR_BUFFER_OVERFLOW if we ran out of space.
//               error status otherwise.
//
//
//  Description: This routine enumerates all the DFS roots on the
//               specified machine.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsStore::EnumerateRoots(
    LPWSTR MachineName,
    LPBYTE pBuffer,
    ULONG  BufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{

    //
    // Initialize the cumulative values we will be using.
    //
    ULONG  TotalSize = 0;
    ULONG  EntriesRead = 0;

    HKEY DfsKey, DfsFlavorKey;
    ULONG_PTR CurrentBuffer = (ULONG_PTR)pBuffer;
    ULONG  CurrentSize = BufferSize;
    BOOLEAN OverFlow = FALSE;

    DFSSTATUS Status;

    //
    // open the old style key to the machine of interest.
    //
    Status = GetOldStandaloneRegistryKey( MachineName,
                                          FALSE, // write permission not required
                                          NULL,
                                          &DfsKey );

    //
    // we now go to each flavor of dfs and enumerate that flavor.
    //
    if (Status == ERROR_SUCCESS)
    {
	Status = EnumerateOldFlavorRoot( DfsKey,
                                         &CurrentBuffer,
                                         &CurrentSize,
                                         &EntriesRead,
                                         &TotalSize );
        RegCloseKey(DfsKey);
    }


    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        OverFlow = TRUE;
        Status = ERROR_SUCCESS;
    }

    if (Status == ERROR_SUCCESS || 
        Status == ERROR_FILE_NOT_FOUND) {

        Status = GetNewStandaloneRegistryKey( MachineName,
                                              FALSE,
                                              NULL,
                                              &DfsFlavorKey );

        //
        // if we opened the standalone flavor key, enumerate it here.
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = EnumerateFlavorRoot( DfsFlavorKey,
                                          &CurrentBuffer,
                                          &CurrentSize,
                                          &EntriesRead,
                                          &TotalSize );
            //  
            // if we got buffer overflow, the TotalSize has been
            // set to the size required. We will mark that we had 
            // an overflow, and change the status to error_Success
            // so we can continue with enumeration of other flavors.
            // we will use the overflow flag later on to return
            // the appropriate error code.
            //

            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                OverFlow = TRUE;
                Status = ERROR_SUCCESS;
            }

            RegCloseKey( DfsFlavorKey );
        }
    }
    //
    // If we had no failures so far, move on to the ADBlob.
    //
    if (Status == ERROR_SUCCESS || 
        Status == ERROR_FILE_NOT_FOUND) 
    {
        Status = GetNewADBlobRegistryKey( MachineName,
                                          FALSE,
                                          NULL,
                                          &DfsFlavorKey );

        if (Status == ERROR_SUCCESS)
        {
            Status = EnumerateFlavorRoot( DfsFlavorKey,
                                          &CurrentBuffer,
                                          &CurrentSize,
                                          &EntriesRead,
                                          &TotalSize );
            //
            // if we got buffer overflow, the TotalSize has been
            // set to the size required. We will mark that we had 
            // an overflow, and change the status to error_Success
            // so we can continue with enumeration of other flavors.
            // we will use the overflow flag later on to return
            // the appropriate error code.
            //

            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                OverFlow = TRUE;
                Status = ERROR_SUCCESS;
            }
            RegCloseKey( DfsFlavorKey );
        }
    }

    if (Status == ERROR_FILE_NOT_FOUND) 
    {
        Status = ERROR_SUCCESS;
    }

    //
    // if we had no failures so far, we will return the cumulative values
    // we have got so far. If we did run into an overflow case, we
    // will also set the return code appropriately.
    //
    if (Status == ERROR_SUCCESS)
    {
        if (OverFlow == TRUE)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        *pEntriesRead = EntriesRead;
        *pSizeRequired = TotalSize;
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   EnumerateFlavorRoot - enumerate the roots for given flavor
//
//  Arguments: 
//    HKEY DfsFlavorKey    - the key to the flavor of interest
//    PULONG_PTR pBuffer,  - the buffer to fill in
//    PULONG  pBufferSize  - the size of tghe buffer.
//    PULONG pEntriesRead  - the cumulative count of entries read.
//    PULONG pSizeRequired - the total size required.
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the enumeartion info.
//               ERROR_BUFFER_OVERFLOW if we ran out of space.
//               error status otherwise.
//
//
//  Description: This routine enumerates the keys under the passed in
//               registry key, and reads the logical share info for each
//               child. It packs this logical share info in the buffer
//               passed in, if possible.
//               On entry it expects the *pEntriesRead and *pSizeRequired
//               to already hold previous enumeration values of other 
//               flavors, so these values are not initialized, but instead
//               we use the values as starting point during this enumeartion.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsStore::EnumerateFlavorRoot(
    HKEY DfsFlavorKey,
    PULONG_PTR pBuffer,
    PULONG  pBufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{

    ULONG ChildNum = 0;
    DFSSTATUS Status;
    PDFS_INFO_200 pDfsInfo200;
    
    ULONG TotalSize, EntriesRead;
    HKEY DfsRootKey;

    BOOLEAN OverFlow = FALSE;

    //
    // We start with total size and entries read with the passed in
    // values, since we expect them to be initialized correctly, and 
    // possibly hold values from enumerations of other dfs flavors.
    //
    TotalSize = *pSizeRequired;
    EntriesRead = *pEntriesRead;
    
    //
    // point the dfsinfo200 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo200 = (PDFS_INFO_200)*pBuffer;

    //
    // now enumerate each child, and read its logical share name.
    // update the total size required: if we have sufficient space 
    // in the passed in buffer, copy the information into the buffer.
    //
    do
    {
        //
        // For each child, get the child name.
        //

        DWORD ChildNameLen = DFS_REGISTRY_CHILD_NAME_SIZE_MAX;
        WCHAR ChildName[DFS_REGISTRY_CHILD_NAME_SIZE_MAX];
        //
        // Now enumerate the children, starting from the first child.
        //
        Status = RegEnumKeyEx( DfsFlavorKey,
                               ChildNum,
                               ChildName,
                               &ChildNameLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        ChildNum++;

        if ( Status == ERROR_SUCCESS )
        {
            DFS_TRACE_HIGH(REFERRAL_SERVER, "adding child %ws\n", ChildName);  
            // We have the name of a child, so open the key to
            // that root.
            //
            Status = RegOpenKeyEx( DfsFlavorKey,
                                   ChildName,
                                   0,
                                   KEY_READ,
                                   &DfsRootKey );


            if ( Status == ERROR_SUCCESS )
            {
                Status = AddRootEnumerationInfo( DfsRootKey,
                                                 &pDfsInfo200,
                                                 pBufferSize,
                                                 &EntriesRead,
                                                 &TotalSize );
                if (Status == STATUS_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                    Status = ERROR_SUCCESS;
                }

                RegCloseKey( DfsRootKey );
            }
            DFS_TRACE_HIGH(REFERRAL_SERVER, "adding child %ws, Status %x\n", ChildName, Status);
        }
    } while (Status == ERROR_SUCCESS);

    //
    // if we broked out of the loop due to lack of children,
    // update the return pointers correctly.
    // if we had detected an overflow condition above, return overflow
    // otherwise return success.
    //

    if (Status == ERROR_NO_MORE_ITEMS)
    {
        *pEntriesRead = EntriesRead;
        *pSizeRequired = TotalSize;        
        //
        // the buffer is now pointing to the next unused pDfsInfo200 array 
        // entry: this lets the next enumerated flavor continue where
        // we left off.
        //
        *pBuffer = (ULONG_PTR)pDfsInfo200;
        if (OverFlow)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }
    DFS_TRACE_HIGH(REFERRAL_SERVER, "done with flavor read %x, Status %x\n", 
                   *pEntriesRead, Status);
    return Status;
}
   


DFSSTATUS
DfsStore::EnumerateOldFlavorRoot(
    HKEY OldStandaloneDfsKey,
    PULONG_PTR pBuffer,
    PULONG  pBufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{
    DFSSTATUS Status;
    PDFS_INFO_200 pDfsInfo200;
    //
    // point the dfsinfo200 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo200 = (PDFS_INFO_200)*pBuffer;

    Status = AddRootEnumerationInfo( OldStandaloneDfsKey,
                                     &pDfsInfo200,
                                     pBufferSize,
                                     pEntriesRead,
                                     pSizeRequired );

    *pBuffer = (ULONG_PTR)pDfsInfo200;

    DFS_TRACE_HIGH(REFERRAL_SERVER, "enumeare old flavor: Read %d, Status %x\n", *pEntriesRead, Status);
    return Status;
}


DFSSTATUS
DfsStore::AddRootEnumerationInfo(
    HKEY RootKey,
    PDFS_INFO_200 *ppDfsInfo200,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    PULONG pTotalSize )
{
    ULONG NeedSize;
    DWORD  DataType;
    DFSSTATUS Status;
    WCHAR DataBuffer[MAX_PATH];
    DWORD DataSize = MAX_PATH;

    DFS_TRACE_HIGH(REFERRAL_SERVER, "add root enum: Read %d\n", *pEntriesRead);

    //
    // The size of pDataBuffer is always fixed: so
    // set the gotsize to the fixed size, and get the
    // information reqarding the logical share value name.
    //
    Status = RegQueryValueEx( RootKey,
                              DfsLogicalShareValueName,
                              NULL,
                              &DataType,
                              (LPBYTE)DataBuffer,
                              &DataSize );

    //
    // if we got a valid buffer ( which is a string, type REG_SZ)
    // we use that information.
    //

    if ((Status == ERROR_SUCCESS) && (DataType == REG_SZ))
    {
        //
        // calculate size of string buffer space needed
        //
        DataSize = (wcslen(DataBuffer) + 1) * sizeof(WCHAR);

        //
        // calculate amount of buffer space requirewd.
        //
        NeedSize = sizeof(DFS_INFO_200) + DataSize;

        //
        // if it fits in the amount of space we have, we
        // can copy the info into the passed in buffer.
        //
        if (NeedSize <= *pBufferSize)
        {
            ULONG_PTR pStringBuffer;
            //
            // position the string buffer to the end of the buffer,
            // leaving enough space to copy the string.
            // This strategy allows us to treat the pDfsInfo200
            // as an array, marching forward from the beginning
            // of the buffer, while the strings are allocated
            // starting from the end of the buffer, since we
            // dont know how many pDfsInfo200 buffers we will
            // be using.
            //
            pStringBuffer = (ULONG_PTR)(*ppDfsInfo200) + *pBufferSize - DataSize;
            wcscpy( (LPWSTR)pStringBuffer, DataBuffer);                        
            (*ppDfsInfo200)->FtDfsName = (LPWSTR)pStringBuffer;
            *pBufferSize -= NeedSize;
            (*pEntriesRead)++;
            (*ppDfsInfo200)++;
        }
        else 
        {
            //
            // if the size does not fit, we have overflowed.
            //
            Status = STATUS_BUFFER_OVERFLOW;
        }
        //
        // set the total size under all circumstances.
        //
        *pTotalSize += NeedSize;
    }
    //
    // we may not find the logical share, if someone is in the process
    // of writing registry:
    //
    if ((Status == ERROR_NOT_FOUND) ||
        (Status == ERROR_FILE_NOT_FOUND))
    {
        Status = ERROR_SUCCESS;
    }
    DFS_TRACE_HIGH(REFERRAL_SERVER, "add root enum: Read %d, Status %x\n", *pEntriesRead, Status);
    return Status;
}

#else

DFSSTATUS
DfsStore::EnumerateRoots(
    PULONG_PTR pBuffer,
    PULONG  pBufferSize,
    PULONG pEntriesRead,
    PULONG pSizeRequired )
{

    ULONG RootNum = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot;
    PDFS_INFO_200 pDfsInfo200;
    
    ULONG TotalSize, EntriesRead;
    BOOLEAN OverFlow = FALSE;

    //
    // We start with total size and entries read with the passed in
    // values, since we expect them to be initialized correctly, and 
    // possibly hold values from enumerations of other dfs flavors.
    //
    TotalSize = *pSizeRequired;
    EntriesRead = *pEntriesRead;
    
    //
    // point the dfsinfo200 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo200 = (PDFS_INFO_200)*pBuffer;

    //
    // now enumerate each child, and read its logical share name.
    // update the total size required: if we have sufficient space 
    // in the passed in buffer, copy the information into the buffer.
    //

    while (Status == ERROR_SUCCESS)
    {
        PUNICODE_STRING pRootName;

        Status = FindNextRoot(RootNum++, &pRoot);
        if (Status == ERROR_SUCCESS)
        {
            pRootName = pRoot->GetLogicalShare();
            Status = AddRootEnumerationInfo( pRootName,
                                             &pDfsInfo200,
                                             pBufferSize,
                                             &EntriesRead,
                                             &TotalSize );
            if (Status == STATUS_BUFFER_OVERFLOW)
            {
                OverFlow = TRUE;
                Status = ERROR_SUCCESS;
            }

            DFS_TRACE_HIGH(REFERRAL_SERVER, "adding child %wZ, Status %x\n", pRootName, Status);

            pRoot->ReleaseReference();
        }
    }


    //
    // if we broked out of the loop due to lack of children,
    // update the return pointers correctly.
    // if we had detected an overflow condition above, return overflow
    // otherwise return success.
    //

    if (Status == ERROR_NOT_FOUND)
    {
        *pEntriesRead = EntriesRead;
        *pSizeRequired = TotalSize;        
        //
        // the buffer is now pointing to the next unused pDfsInfo200 array 
        // entry: this lets the next enumerated flavor continue where
        // we left off.
        //
        *pBuffer = (ULONG_PTR)pDfsInfo200;
        if (OverFlow)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }
    DFS_TRACE_HIGH(REFERRAL_SERVER, "done with flavor read %x, Status %x\n", 
                   *pEntriesRead, Status);
    return Status;
}
   

DFSSTATUS
DfsStore::AddRootEnumerationInfo(
    PUNICODE_STRING pRootName,
    PDFS_INFO_200 *ppDfsInfo200,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    PULONG pTotalSize )
{
    ULONG NeedSize;
    DFSSTATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH(REFERRAL_SERVER, "add root enum: Read %d\n", *pEntriesRead);



    //
    // calculate amount of buffer space requirewd.
    //
    NeedSize = sizeof(DFS_INFO_200) + pRootName->MaximumLength;

    //
    // if it fits in the amount of space we have, we
    // can copy the info into the passed in buffer.
    //
    if (NeedSize <= *pBufferSize)
    {
        ULONG_PTR pStringBuffer;
        //
        // position the string buffer to the end of the buffer,
        // leaving enough space to copy the string.
        // This strategy allows us to treat the pDfsInfo200
        // as an array, marching forward from the beginning
        // of the buffer, while the strings are allocated
        // starting from the end of the buffer, since we
        // dont know how many pDfsInfo200 buffers we will
        // be using.
        //
        pStringBuffer = (ULONG_PTR)(*ppDfsInfo200) + *pBufferSize - pRootName->MaximumLength;
        wcscpy( (LPWSTR)pStringBuffer, pRootName->Buffer);
        (*ppDfsInfo200)->FtDfsName = (LPWSTR)pStringBuffer;
        *pBufferSize -= NeedSize;
        (*pEntriesRead)++;
        (*ppDfsInfo200)++;
    }
    else 
    {
        //
        // if the size does not fit, we have overflowed.
        //
        Status = STATUS_BUFFER_OVERFLOW;
    }
    //
    // set the total size under all circumstances.
    //
    *pTotalSize += NeedSize;


    DFS_TRACE_HIGH(REFERRAL_SERVER, "add root enum: Read %d, Status %x\n", *pEntriesRead, Status);
    return Status;
}


#endif


DFSSTATUS
DfsStore::SetupADBlobRootKeyInformation(
    HKEY  DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsPhysicalShare )
{

    DWORD Status;
    HKEY FtDfsShareKey;

    Status = RegCreateKeyEx( DfsKey,
                             DfsLogicalShare,
                             0,
                             L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &FtDfsShareKey,
                             NULL );

    //
    // Now set the values for this root key, so that we know 
    // the DN for the root, and the physical share on the machine
    // for the root, etc.
    //
    if (Status == ERROR_SUCCESS) {
        Status = RegSetValueEx( FtDfsShareKey,
                                DfsRootShareValueName,
                                0,
                                REG_SZ,
                                (PBYTE)DfsPhysicalShare,
                                wcslen(DfsPhysicalShare) * sizeof(WCHAR) );


        if (Status == ERROR_SUCCESS) {
            Status = RegSetValueEx( FtDfsShareKey,
                                    DfsLogicalShareValueName,
                                    0,
                                    REG_SZ,
                                    (PBYTE)DfsLogicalShare,
                                    wcslen(DfsLogicalShare) * sizeof(WCHAR) );

        }

        RegCloseKey( FtDfsShareKey );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_NAME_INFORMATION *ppInfo )
{
    PVOID pBlob, pUseBlob;
    ULONG BlobSize, UseBlobSize;
    FILETIME BlobModifiedTime;
    PDFS_NAME_INFORMATION pNewInfo = NULL;
    DFSSTATUS Status;

    Status = GetMetadataNameBlob( RootHandle,
                                  MetadataName,
                                  &pBlob,
                                  &BlobSize,
                                  &BlobModifiedTime );
    if (Status == ERROR_SUCCESS)
    {
        pNewInfo = new DFS_NAME_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_NAME_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = BlobSize;
            Status = PackGetNameInformation( pNewInfo,
                                             &pUseBlob,
                                             &UseBlobSize );
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pBlob;
        pNewInfo->DataSize = BlobSize;
        *ppInfo = pNewInfo;
    }


    return Status;
}
        
VOID
DfsStore::ReleaseMetadataNameInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    UNREFERENCED_PARAMETER(DfsHandle);

    ReleaseMetadataNameBlob( pNameInfo->pData,
                             pNameInfo->DataSize );

    delete [] pNameInfo;
}


DFSSTATUS
DfsStore::SetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    PVOID pBlob;
    ULONG BlobSize;
    DFSSTATUS Status;


    Status = CreateNameInformationBlob( pNameInfo,
                                        &pBlob,
                                        &BlobSize );
    if (Status == ERROR_SUCCESS)
    {
        Status = SetMetadataNameBlob( RootHandle,
                                      MetadataName,
                                      pBlob,
                                      BlobSize );

        ReleaseMetadataNameBlob( pBlob, BlobSize );
    }

    return Status;
}



DFSSTATUS
DfsStore::GetMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_REPLICA_LIST_INFORMATION *ppInfo )
{
    PVOID pBlob, pUseBlob;
    ULONG BlobSize, UseBlobSize;
    PDFS_REPLICA_LIST_INFORMATION pNewInfo;
    DFSSTATUS Status;


    Status = GetMetadataReplicaBlob( RootHandle,
                                     MetadataName,
                                     &pBlob,
                                     &BlobSize,
                                     NULL );

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo = new DFS_REPLICA_LIST_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_REPLICA_LIST_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = BlobSize;

            Status = PackGetULong( &pNewInfo->ReplicaCount,
                                   &pUseBlob,
                                   &UseBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                pNewInfo->pReplicas = new DFS_REPLICA_INFORMATION[ pNewInfo->ReplicaCount];
                if ( pNewInfo->pReplicas != NULL )
                {
                    Status = PackGetReplicaInformation(pNewInfo, 
                                                       &pUseBlob,
                                                       &UseBlobSize );
                }
                else
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                delete pNewInfo;
            }
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataReplicaBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pBlob;
        pNewInfo->DataSize = BlobSize;
        *ppInfo = pNewInfo;
    }

    return Status;
}

        
VOID
DfsStore::ReleaseMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    UNREFERENCED_PARAMETER(DfsHandle);
    ReleaseMetadataReplicaBlob( pReplicaListInfo->pData,
                                pReplicaListInfo->DataSize );

    delete [] pReplicaListInfo->pReplicas;
    delete [] pReplicaListInfo;

}

DFSSTATUS
DfsStore::SetMetadataReplicaInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo )
{
    PVOID pBlob;
    ULONG BlobSize;
    DFSSTATUS Status;

    Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                               &pBlob,
                                               &BlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = SetMetadataReplicaBlob( RootHandle,
                                         MetadataName,
                                         pBlob,
                                         BlobSize );

        ReleaseMetadataReplicaBlob( pBlob, BlobSize );
    }

    return Status;
}


DFSSTATUS
DfsStore::CreateNameInformationBlob(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    OUT PVOID *ppBlob,
    OUT PULONG pDataSize )
{
    PVOID pBlob, pUseBlob;
    ULONG BlobSize, UseBlobSize;
    DFSSTATUS Status;

    BlobSize = PackSizeNameInformation( pDfsNameInfo );
    
    Status = AllocateMetadataNameBlob( &pBlob,
                                       BlobSize );

    if ( Status == ERROR_SUCCESS )
    {
        pUseBlob = pBlob;
        UseBlobSize = BlobSize;

        // Pack the name information into the binary stream allocated.
        //
        Status = PackSetNameInformation( pDfsNameInfo,
                                         &pUseBlob,
                                         &UseBlobSize );
        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameBlob( pBlob, BlobSize );
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        *ppBlob = pBlob;
        *pDataSize = BlobSize - UseBlobSize;
    }

    return Status;
}


DFSSTATUS
DfsStore::CreateReplicaListInformationBlob(
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    OUT PVOID *ppBlob,
    OUT PULONG pDataSize )
{
    PVOID pBlob, pUseBlob;
    ULONG BlobSize, UseBlobSize;
    DFSSTATUS Status;

    BlobSize = PackSizeULong();
    BlobSize += PackSizeReplicaInformation( pReplicaListInfo );
    
    BlobSize += PackSizeULong();
    Status = AllocateMetadataReplicaBlob( &pBlob,
                                          BlobSize );

    if ( Status == ERROR_SUCCESS )
    {
        pUseBlob = pBlob;
        UseBlobSize = BlobSize;


        //
        // The first item in the stream is the number of replicas
        //
        Status = PackSetULong(pReplicaListInfo->ReplicaCount,
                              &pUseBlob,
                              &UseBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            //
            // We than pack the array of replicas into the binary stream
            //
            Status = PackSetReplicaInformation( pReplicaListInfo,
                                                &pUseBlob,
                                                &UseBlobSize );
        }

        if (Status == ERROR_SUCCESS)
        {
            //
            // We than pack the last word with a 0 so that all the
            // old crap still works.
            //
            Status = PackSetULong( 0,
                                   &pUseBlob,
                                   &UseBlobSize );

        }

        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataReplicaBlob( pBlob, BlobSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppBlob = pBlob;
        *pDataSize = BlobSize - UseBlobSize;
    }

    return Status;
}








DFSSTATUS
DfsStore::AddChildReplica (
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath )
{
    PDFS_REPLICA_LIST_INFORMATION pReplicaList = NULL;
    PDFS_REPLICA_INFORMATION pReplicaInfo;
    DFS_REPLICA_LIST_INFORMATION NewList;
    ULONG ReplicaIndex;
    DFSSTATUS Status;

    if ( (ServerName == NULL) || (SharePath == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = GetMetadataReplicaInformation( DfsHandle,
                                            LinkMetadataName,
                                            &pReplicaList );

    if (Status == ERROR_SUCCESS)
    {
        ReplicaIndex = FindReplicaInReplicaList( pReplicaList, 
                                                 ServerName,
                                                 SharePath );
        if (ReplicaIndex < pReplicaList->ReplicaCount)
        {
            Status = ERROR_FILE_EXISTS;
        }

        if (Status == ERROR_SUCCESS)
        {
            RtlZeroMemory( &NewList, sizeof(DFS_REPLICA_LIST_INFORMATION));
            NewList.ReplicaCount = pReplicaList->ReplicaCount + 1;
            NewList.pReplicas = new DFS_REPLICA_INFORMATION [ NewList.ReplicaCount ];
            if (NewList.pReplicas == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else 
            {
                if (pReplicaList->ReplicaCount)
                {
                    RtlCopyMemory( &NewList.pReplicas[0],
                                   &pReplicaList->pReplicas[0],
                                   pReplicaList->ReplicaCount * sizeof(DFS_REPLICA_INFORMATION) );
                }

                pReplicaInfo = &NewList.pReplicas[pReplicaList->ReplicaCount];
                RtlZeroMemory( pReplicaInfo,
                               sizeof(DFS_REPLICA_INFORMATION) );

                RtlInitUnicodeString(&pReplicaInfo->ServerName, ServerName);
                RtlInitUnicodeString(&pReplicaInfo->ShareName, SharePath);

                pReplicaInfo->ReplicaState = DFS_STORAGE_STATE_ONLINE;
                pReplicaInfo->ReplicaType = 2; // hack fro backwards compat.

                Status = SetMetadataReplicaInformation( DfsHandle,
                                                        LinkMetadataName,
                                                        &NewList );
                delete [] NewList.pReplicas;
            }
        }

        ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
    }

    return Status;
}



DFSSTATUS
DfsStore::RemoveChildReplica (
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath,
    PBOOLEAN pLastReplica)
{

    PDFS_REPLICA_LIST_INFORMATION pReplicaList;
    DFS_REPLICA_LIST_INFORMATION NewList;
    ULONG DeleteIndex;
    ULONG NextIndex;

    DFSSTATUS Status;

    *pLastReplica = FALSE;
    RtlZeroMemory( &NewList,
                   sizeof(DFS_REPLICA_LIST_INFORMATION));


    if ( (ServerName == NULL) || (SharePath == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = GetMetadataReplicaInformation( DfsHandle,
                                            LinkMetadataName,
                                            &pReplicaList );

    if (Status == ERROR_SUCCESS)
    {
        DeleteIndex = FindReplicaInReplicaList( pReplicaList, 
                                                ServerName,
                                                SharePath );
        if (DeleteIndex < pReplicaList->ReplicaCount)
        {
            NewList.ReplicaCount = pReplicaList->ReplicaCount - 1;

            if (NewList.ReplicaCount)
            {
                NewList.pReplicas = new DFS_REPLICA_INFORMATION [NewList.ReplicaCount];
                if (NewList.pReplicas != NULL)
                {
                    if (DeleteIndex)
                    {
                        RtlCopyMemory( &NewList.pReplicas[0],
                                       &pReplicaList->pReplicas[0],
                                       DeleteIndex * sizeof(DFS_REPLICA_INFORMATION) );
                    }

                    NextIndex = DeleteIndex + 1;

                    if ( NextIndex < pReplicaList->ReplicaCount)
                    {
                        RtlCopyMemory( &NewList.pReplicas[DeleteIndex],
                                       &pReplicaList->pReplicas[NextIndex],
                                       (pReplicaList->ReplicaCount - NextIndex) * sizeof(DFS_REPLICA_INFORMATION) );
                    }
                }
                else {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = SetMetadataReplicaInformation( DfsHandle,
                                                        LinkMetadataName,
                                                        &NewList );
                if (NewList.ReplicaCount == 0)
                {
                    *pLastReplica = TRUE;
                }

            }
            if (NewList.pReplicas != NULL)
            {
                delete [] NewList.pReplicas;
            }
        }
        else {
            Status = ERROR_FILE_NOT_FOUND;
        }

        ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
    }
    return Status;
}






DFSSTATUS
DfsStore::GetStoreApiInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    LPWSTR LinkMetadataName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    PLONG pSizeRequired )
{

    DFSSTATUS Status;
    PDFS_NAME_INFORMATION pNameInformation = NULL;
    PDFS_REPLICA_LIST_INFORMATION pReplicaList = NULL;
    PDFS_REPLICA_INFORMATION pReplica;

    PDFS_API_INFO pInfo = (PDFS_API_INFO)pBuffer;
    DFS_API_INFO LocalInfo;
    PDFS_STORAGE_INFO pStorage;
    LONG HeaderSize = 0;
    LONG AdditionalSize = 0;
    UNICODE_STRING UsePrefixName;

    ULONG i;

    ULONG_PTR NextFreeMemory = NULL;


    RtlZeroMemory(&LocalInfo, sizeof(DFS_API_INFO));


    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );

    if (Status == ERROR_SUCCESS)
    {
        Status = GenerateApiLogicalPath( pRootName, 
                                         &pNameInformation->Prefix,
                                         &UsePrefixName );
        if (Status != ERROR_SUCCESS)
        {
            ReleaseMetadataNameInformation( DfsHandle, pNameInformation );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadataReplicaInformation( DfsHandle,
                                                LinkMetadataName,
                                                &pReplicaList );

        if (Status == ERROR_SUCCESS)
        {
            switch (Level)
            {
            case 100:
                if (HeaderSize == 0)
                {
                    HeaderSize = sizeof(DFS_INFO_100);
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info100 + 1);
                }
                AdditionalSize += pNameInformation->Comment.Length + sizeof(WCHAR);
                break;

            case 4:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_4);
                    LocalInfo.Info4.Timeout = pNameInformation->Timeout;
                    LocalInfo.Info4.State = pNameInformation->State;
                    LocalInfo.Info4.NumberOfStorages = pReplicaList->ReplicaCount;
                    pStorage = LocalInfo.Info4.Storage = (PDFS_STORAGE_INFO)(&pInfo->Info4 + 1);
                    NextFreeMemory = (ULONG_PTR)(LocalInfo.Info4.Storage + LocalInfo.Info4.NumberOfStorages);
                }

            case 3:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_3);
                    LocalInfo.Info3.State = pNameInformation->State;
                    LocalInfo.Info3.NumberOfStorages = pReplicaList->ReplicaCount;
                    pStorage = LocalInfo.Info3.Storage = (PDFS_STORAGE_INFO)(&pInfo->Info3 + 1);
                    NextFreeMemory = (ULONG_PTR)(LocalInfo.Info3.Storage + LocalInfo.Info3.NumberOfStorages);
                }

                for (i = 0; i < pReplicaList->ReplicaCount; i++)
                {

                    UNICODE_STRING ServerName = pReplicaList->pReplicas[i].ServerName;

                    if (IsLocalName(&ServerName))
                    {
                        ServerName = *pRootName;
                    }
                    AdditionalSize += ( sizeof(DFS_STORAGE_INFO) + 
                                        ServerName.Length + sizeof(WCHAR) + 
                                        pReplicaList->pReplicas[i].ShareName.Length + sizeof(WCHAR) );

                }

            case 2:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_2);
                    LocalInfo.Info2.State = pNameInformation->State;
                    LocalInfo.Info2.NumberOfStorages = pReplicaList->ReplicaCount;
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info2 + 1);
                }

                AdditionalSize += pNameInformation->Comment.Length + sizeof(WCHAR);

            case 1:
                if (HeaderSize == 0) 
                {
                    HeaderSize = sizeof(DFS_INFO_1);
                    NextFreeMemory = (ULONG_PTR)(&pInfo->Info1 + 1);
                }
                AdditionalSize += UsePrefixName.Length + sizeof(WCHAR);
                break;

            default:
             
                Status = ERROR_INVALID_PARAMETER;
                break;
        
            }
            *pSizeRequired = HeaderSize + AdditionalSize;
            if (*pSizeRequired > BufferSize)
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }

            if (Status == ERROR_SUCCESS)
            {

                RtlZeroMemory( pBuffer, *pSizeRequired);
                RtlCopyMemory( &pInfo->Info4, &LocalInfo.Info4, HeaderSize );

                switch (Level)
                {
                case 100:

                    pInfo->Info100.Comment = (LPWSTR)NextFreeMemory;
                    NextFreeMemory += pNameInformation->Comment.Length + sizeof(WCHAR);
                    RtlCopyMemory( pInfo->Info100.Comment, 
                                   pNameInformation->Comment.Buffer,
                                   pNameInformation->Comment.Length );
                    break;

                case 4:
                case 3:
                    for (i = 0; i < pReplicaList->ReplicaCount; i++)
                    {
                        UNICODE_STRING ServerName = pReplicaList->pReplicas[i].ServerName;

                        if (IsLocalName(&ServerName))
                        {
                            ServerName = *pRootName;
                        }

                        pReplica = &pReplicaList->pReplicas[i];
                        pStorage[i].State = pReplica->ReplicaState;
                        pStorage[i].ServerName = (LPWSTR)NextFreeMemory;
                        NextFreeMemory += ServerName.Length + sizeof(WCHAR);
                        pStorage[i].ShareName = (LPWSTR)NextFreeMemory;
                        NextFreeMemory += pReplica->ShareName.Length + sizeof(WCHAR);

                        RtlCopyMemory( pStorage[i].ServerName, 
                                       ServerName.Buffer,
                                       ServerName.Length );

                        RtlCopyMemory( pStorage[i].ShareName, 
                                       pReplica->ShareName.Buffer,
                                       pReplica->ShareName.Length );
                    }

                case 2:

                    pInfo->Info2.Comment = (LPWSTR)NextFreeMemory;
                    NextFreeMemory += pNameInformation->Comment.Length + sizeof(WCHAR);
                    RtlCopyMemory( pInfo->Info2.Comment, 
                                   pNameInformation->Comment.Buffer,
                                   pNameInformation->Comment.Length );

                case 1:

                    pInfo->Info1.EntryPath = (LPWSTR)NextFreeMemory;

                    RtlCopyMemory(  pInfo->Info1.EntryPath,
                                    UsePrefixName.Buffer,
                                    UsePrefixName.Length );
                    pInfo->Info1.EntryPath[UsePrefixName.Length/sizeof(WCHAR)]  = UNICODE_NULL;

                    break;
                }
            }
            ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
        }
        ReleaseApiLogicalPath( &UsePrefixName );
        ReleaseMetadataNameInformation( DfsHandle, pNameInformation );
    }

    return Status;
}

   


DFSSTATUS
DfsStore::SetStoreApiInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR LinkMetadataName,
    LPWSTR ServerName,
    LPWSTR SharePath,
    DWORD Level,
    LPBYTE pBuffer )
{
    DFSSTATUS Status;
    PDFS_NAME_INFORMATION pNameInformation;

    //
    // The set is a little strange: the pBuffer is pointing to a pointer 
    // that we are interested in. Grab it directly.
    // dfsdev: this is confusing, fix it or document in detail.
    //
    PDFS_API_INFO pApiInfo = (PDFS_API_INFO)(*(PULONG_PTR)pBuffer);

    //
    // dfsdev: need to do some api work before enabling code
    // below.
    //
#if 0
    if ( (ServerName != NULL) || (SharePath != NULL) )
    {
        if (Level != 101)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
#endif

    Status = GetMetadataNameInformation( DfsHandle,
                                         LinkMetadataName,
                                         &pNameInformation );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }


    switch (Level)
    {
    case 100:
        RtlInitUnicodeString( &pNameInformation->Comment,
                              pApiInfo->Info100.Comment );

        Status = SetMetadataNameInformation( DfsHandle,
                                             LinkMetadataName,
                                             pNameInformation );
        break;

    case 102:
        pNameInformation->Timeout = pApiInfo->Info102.Timeout;

        Status = SetMetadataNameInformation( DfsHandle,
                                             LinkMetadataName,
                                             pNameInformation );

        break;

    case 101:

        if ((ServerName == NULL) && (SharePath == NULL))
        {
            pNameInformation->State = pApiInfo->Info101.State;

            Status = SetMetadataNameInformation( DfsHandle,
                                                 LinkMetadataName,
                                                 pNameInformation );
        }
        else {
            PDFS_REPLICA_LIST_INFORMATION pReplicaList;
            ULONG ReplicaIndex;

            Status = GetMetadataReplicaInformation (DfsHandle,
                                                    LinkMetadataName,
                                                    &pReplicaList );
            if (Status == ERROR_SUCCESS)
            {
                ReplicaIndex = FindReplicaInReplicaList( pReplicaList,
                                                         ServerName,
                                                         SharePath );

                if (ReplicaIndex >= pReplicaList->ReplicaCount)
                {
                    Status = ERROR_NOT_FOUND;
                }
                else {
                    DFS_REPLICA_LIST_INFORMATION NewList;

                    RtlZeroMemory( &NewList, sizeof( DFS_REPLICA_LIST_INFORMATION) );
                    NewList.ReplicaCount = pReplicaList->ReplicaCount;
                    NewList.pReplicas = new DFS_REPLICA_INFORMATION [ NewList.ReplicaCount ];
                    if (NewList.pReplicas != NULL)
                    {
                        RtlCopyMemory( &NewList.pReplicas[0],
                                       &pReplicaList->pReplicas[0],
                                       NewList.ReplicaCount * sizeof(DFS_REPLICA_INFORMATION) );
                        NewList.pReplicas[ReplicaIndex].ReplicaState = pApiInfo->Info101.State;
                        NewList.pReplicas[ReplicaIndex].ReplicaType = 2; // hack fro backwards compat.
                        Status = SetMetadataReplicaInformation (DfsHandle,
                                                                LinkMetadataName,
                                                                &NewList );

                        delete [] NewList.pReplicas;
                    }
                    else {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                ReleaseMetadataReplicaInformation( DfsHandle, pReplicaList );
            }
        }
        break;

    default:
        Status = ERROR_INVALID_PARAMETER;
        break;
    }

    ReleaseMetadataNameInformation( DfsHandle, pNameInformation );

    return Status;
}



DFSSTATUS
DfsStore::GetStoreApiInformationBuffer(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    LPWSTR LinkMetadataName,
    DWORD Level,
    LPBYTE *ppBuffer,
    PLONG  pBufferSize )
{
    DFSSTATUS Status;
    LONG RequiredSize;

    LONG BufferSize = 4096;
    LPBYTE pBuffer = new BYTE [ BufferSize ];

    if (pBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = GetStoreApiInformation( DfsHandle,
                                     pRootName,
                                     LinkMetadataName,
                                     Level,
                                     pBuffer,
                                     BufferSize,
                                     &RequiredSize );

    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        delete [] pBuffer;
        BufferSize = RequiredSize;
        pBuffer = new BYTE[ BufferSize ];
        if (pBuffer == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            Status = GetStoreApiInformation( DfsHandle,
                                             pRootName,
                                             LinkMetadataName,
                                             Level,
                                             pBuffer,
                                             BufferSize,
                                             &RequiredSize );
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppBuffer = pBuffer;
        *pBufferSize = RequiredSize;
    }
    return Status;
}


DFSSTATUS
DfsStore::FindNextRoot(
    ULONG RootNum,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status;
    DfsRootFolder *pRoot;
    ULONG Start;


    DFS_TRACE_LOW( REFERRAL_SERVER, "Store %p, Find next root %d\n",
                   this, RootNum );
    //
    // Lock the store, so that we dont have new roots coming in while
    // we are taking a look.
    //
    Status = AcquireReadLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // The default return status is ERROR_NOT_FOUND;
    //
    Status = ERROR_NOT_FOUND;

    //
    // Run through our list of DFS roots, and see if any of them match
    // the passed in name context and logical share.
    //

    pRoot = _DfsRootList;
    Start = 0;

    if (pRoot != NULL)
    {
        do
        {
            if (Start++ == RootNum)
            {
                Status = ERROR_SUCCESS;
                break;
            }
            pRoot = pRoot->pNextRoot;
        } while ( pRoot != _DfsRootList );
    }

    //
    // IF we found a matching root, bump up its reference count, and
    // return the pointer to the root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pRoot->AcquireReference();
        *ppRootFolder = pRoot;

    }

    ReleaseLock();

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Done find next %d, root %p status %x\n",
                         RootNum, pRoot, Status);
    return Status;
}

//
// the store syncrhonizer: syncrhonizes roots that we already know of.
// Note that we could be racing with a delete: in the worst case we will
// resync the same root more than once.
//

VOID
DfsStore::StoreSynchronizer()
{
    ULONG RootNum = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot;

    while (Status != ERROR_NOT_FOUND)
    {
        Status = FindNextRoot(RootNum++, &pRoot);
        if (Status == ERROR_SUCCESS)
        {
            Status = pRoot->Synchronize();

            DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Root %p Synchronize Status %x\n", this, Status);

            pRoot->ReleaseReference();
        }
    }
    return NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfstrusteddomain.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsTrustedDomain.cxx
//
//  Contents:   implements the trusted domain 
//
//  Classes:    DfsTrustedDomain
//
//  History:    Apr. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <ntdsapi.h>


#include "DfsReferralData.hxx"
#include "DfsTrustedDomain.hxx"
#include "DfsReplica.hxx"
//
// logging specific includes
//
#include "DfsTrustedDomain.tmh" 

//+-------------------------------------------------------------------------
//
//  Function:   GetDcReferralData - get the referral data
//
//  Arguments:  ppReferralData - the referral data for this instance
//              pCacheHit - did we find it already loaded?
//
//  Returns:    Status
//               ERROR_SUCCESS if we could get the referral data
//               error status otherwise.
//
//
//  Description: This routine returns a reference DfsReferralDAta
//               If one does not already exist in this class instance,
//               we create a new one. If someone is in the process
//               of loading the referral, we wait on the event in 
//               the referral data which gets signalled when the thread
//               responsible for loading is done with the load.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsTrustedDomain::GetDcReferralData(
    OUT DfsReferralData **ppReferralData,
    OUT BOOLEAN   *pCacheHit )
{
    DfsReferralData *pRefData;
    DFSSTATUS Status = STATUS_SUCCESS;
    

    if (_DomainName.Length == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pCacheHit = FALSE;

    Status = AcquireLock();
    if ( Status != STATUS_SUCCESS )
    {
        return Status;
    }

    //
    // WE take difference action depending on the load state.
    //
    switch ( _LoadState )
    {
    case DfsTrustedDomainDcLoaded:

        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: Cache hit\n");
        //
        // we are dealing with a loaded instance. Just acquire a reference
        // and return the loaded referral data.
        //
        ASSERT (_pDcReferralData != NULL);

        pRefData = _pDcReferralData;
        pRefData->AcquireReference();
        
        ReleaseLock();
        
        *pCacheHit = TRUE;        
        *ppReferralData = pRefData;

        break;

    case DfsTrustedDomainDcNotLoaded:

        //
        // The dc info is not loaded. Make sure that the referral data is
        // indeed empty. Create a new instance of the referral data
        // and set the state to load in progress.

        ASSERT(_pDcReferralData == NULL);
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: not loaded\n");

        _pDcReferralData = new DfsReferralData( &Status );

        if ( _pDcReferralData != NULL )
        {
            _LoadState = DfsTrustedDomainDcLoadInProgress;

            //
            // Acquire a reference on the new referral data, since we 
            // have to return a referenced referral data to the caller.
            //
            pRefData = _pDcReferralData;
            pRefData->AcquireReference();
        } else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // We no longer need the lock. We have allocate the referral
        // data and marked the state accordingly. No other thread can
        // interfere with our load now.
        //
        ReleaseLock();

        //
        // Now we load the referral data, and save the status of the
        // load in both our load status as well as the load status
        // in the referral data.
        // If the load was successful, we add this to the loaded list
        // of referral data that can be scavenged later. We set the load
        // state to loaded, and signal the event so that all waiting
        // threads can now be woken up.
        //

        if ( Status == ERROR_SUCCESS )
        {
            Status = LoadDcReferralData( _pDcReferralData );

            _LoadStatus = Status;
            _pDcReferralData->LoadStatus = Status;


            if ( Status == ERROR_SUCCESS )
            {
                _LoadState = DfsTrustedDomainDcLoaded;
                *ppReferralData = pRefData;
                pRefData->Signal();
            } else
            {
                _LoadState = DfsTrustedDomainDcLoadFailed;
                pRefData->Signal();
                pRefData->ReleaseReference();
            }
        }

        break;


    case DfsTrustedDomainDcLoadInProgress:

        //
        // The load is in progress. We acquire a reference on the
        // referral data being loaded and wait for the event in the
        // referral data to be signalled. The return status of the wait
        // indicates if we can return the referral data or we fail
        // this request with an error.
        //
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: load in progress\n");
        ASSERT(_pDcReferralData != NULL);
        pRefData = _pDcReferralData;
        pRefData->AcquireReference();

        ReleaseLock();

        DFSLOG("Thread: Waiting for referral load\n");

        Status = pRefData->Wait();

        if ( Status == ERROR_SUCCESS )
        {
            *ppReferralData = pRefData;
        } else
        {
            pRefData->ReleaseReference();
        }
        DFS_TRACE_HIGH(REFERRAL_SERVER, " Get Referral Data: load in progress done\n");
        break;

    case DfsTrustedDomainDcLoadFailed:
        //
        // The Load failed. REturn error. We need to setup a time
        // after which we need to reattempt the load.
        //
        Status = _LoadStatus;
        ReleaseLock();
        *ppReferralData = NULL;
        break;

    default:
        //
        // We should never get here. Its an invalid state.
        //
        ASSERT(TRUE);
        Status = ERROR_INVALID_STATE;
        ReleaseLock();

        break;
    }

    if ((Status == ERROR_SUCCESS) &&
        (*ppReferralData == NULL))
    {
        DbgBreakPoint();
    }

    return Status;
}




DFSSTATUS
DfsTrustedDomain::RemoveDcReferralData(
    DfsReferralData *pRemoveReferralData,
    PBOOLEAN pRemoved )
{
    DFSSTATUS Status;
    DfsReferralData *pRefData = NULL;

    //
    // Get tnhe exclusive lock on this instance
    //
    if (pRemoved != NULL)
    {
        *pRemoved = FALSE;
    }

    Status = AcquireLock();
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    //
    // make sure _LoadState indicates that it is loaded.
    // Set the referralData to null, and state to NotLoaded.
    //
    if (_LoadState == DfsTrustedDomainDcLoaded)
    {

        pRefData = _pDcReferralData;
        if ( (pRemoveReferralData == NULL) || 
             (pRemoveReferralData == pRefData) )
        {
            _pDcReferralData = NULL;
            _LoadState = DfsTrustedDomainDcNotLoaded;
        }
        else {
            pRefData = NULL;
        }
    }

    ReleaseLock();

    //
    // Release reference on the referral data. This is the reference
    // we had taken when we had cached the referral data here.
    //
    if (pRefData != NULL)
    {
        pRefData->ReleaseReference();
        if (pRemoved != NULL)
        {
            *pRemoved = TRUE;
        }
    }

    return Status;
}


DFSSTATUS
DfsTrustedDomain::LoadDcReferralData(
    IN DfsReferralData *pReferralData )
{

    DFSSTATUS Status;
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDomainControllerInfo1 = NULL;
    HANDLE HandleToDs = NULL;
    ULONG NameCount = 0, Index;
    ULONG DsDcCount = 0;
    ULONG UseIndex = 0;
    LPWSTR DomainController = NULL;

    Status = DsBind(DomainController, _DomainName.Buffer, &HandleToDs);

    if (Status == ERROR_SUCCESS)
    {
        Status = DsGetDomainControllerInfo( HandleToDs,
                                            _DomainName.Buffer,
                                            1,
                                            &NameCount,
                                            (PVOID *)(&pDsDomainControllerInfo1));

        DsUnBind( &HandleToDs);
    }

    if (Status == ERROR_SUCCESS)
    {
        for (Index = 0; Index < NameCount; Index++)
        {
            if (pDsDomainControllerInfo1[Index].fDsEnabled == TRUE) 
            {
                DsDcCount++;
            }
        }
        if (DsDcCount > 0)
        {
            pReferralData->pReplicas = new DfsReplica[ DsDcCount ];

            if (pReferralData->pReplicas == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else 
            {
                pReferralData->ReplicaCount = DsDcCount;
            }
        }

        for (Index = 0; ((Index < NameCount) && (Status == ERROR_SUCCESS)); Index++)
        {
            if (pDsDomainControllerInfo1[Index].fDsEnabled != TRUE) 
             {
                continue;
            }
            LPWSTR UseName = (_Netbios == TRUE) ? pDsDomainControllerInfo1[Index].NetbiosName : pDsDomainControllerInfo1[Index].DnsHostName;

            if (UseName != NULL)
            {
                UNICODE_STRING TargetName;
                RtlInitUnicodeString(&TargetName, UseName);
                Status = (&pReferralData->pReplicas[ UseIndex ])->SetTargetServer( &TargetName );

                UseIndex++;
            }
        }
        
        DsFreeDomainControllerInfo( 1,
                                    NameCount,
                                    pDsDomainControllerInfo1);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsadsi.h ===
typedef struct _DFS_LINKROOT_ENUM_INFO {
    LPWSTR GuidString;
    UNICODE_STRING Name;
} DFS_LINKROOT_ENUM_INFO, *PDFS_LINKROOT_ENUM_INFO;

typedef struct _DFS_LINK_ENUMERATION {
    int NumberOfLinks;
    DFS_LINKROOT_ENUM_INFO Info[];
} DFS_LINK_ENUMERATION, *PDFS_LINK_ENUMERATION;

typedef struct _DFS_ROOT_ENUMERATION {
    int NumberOfRoots;
    DFS_LINKROOT_ENUM_INFO Info[];
} DFS_ROOT_ENUMERATION, *PDFS_ROOT_ENUMERATION;




typedef struct _DFS_ADSI_REPLICA_LIST {
    PUNICODE_STRING pServerName;
    PUNICODE_STRING pShareName;
    struct _DFS_ADSI_REPLICA_LIST *pNext;
} DFS_ADSI_REPLICA_LIST, *PDFS_ADSI_REPLICA_LIST;


typedef struct _DFS_ADSI_ROOT {
    LPWSTR GuidString;
    PDFS_ADSI_REPLICA_LIST Replicas;
} DFS_ADSI_ROOT, *PDFS_ADSI_ROOT;

typedef struct _DFS_ADSI_LINK {
    LPWSTR GuidString;
    PDFS_ADSI_REPLICA_LIST Replicas;
} DFS_ADSI_LINK, *PDFS_ADSI_LINK;


DFSSTATUS
DfsAdsiGetRoot(
    LPWSTR Namespace, 
    PDFS_ADSI_ROOT *ppAdRootObject
    );

DFSSTATUS
DfsAdsiGetLink(
    LPWSTR Namespace, 
    PDFS_ADSI_LINK *ppAdLinkObject
    );


DFSSTATUS
DfsAdsiFreeRoot(
    PDFS_ADSI_ROOT pAdRootObject
    );

DFSSTATUS
DfsAdsiEnumerateLinks(
    LPWSTR Namespace,
    PDFS_LINK_ENUMERATION *ppLinks
    );

DFSSTATUS
DfsAdsiFreeLinkEnumeration(
    PDFS_LINK_ENUMERATION pLinks
    );

DFSSTATUS
DfsAdsiEnumerateRoots(
    LPWSTR Namespace,
    PDFS_ROOT_ENUMERATION *ppRoots
    );

DFSSTATUS
DfsAdsiFreeRootEnumeration(
    PDFS_ROOT_ENUMERATION pRoots
    );


//
// Macros for accessing ADSI structures
//

#define GET_GUID(Object) Object.DfsAdsiHeader.Guid

#define GET_REPLICAS(Object) Object.Replicas

#define GET_ROOT_NAME(Object) Object.RootName

#define GET_LINK_NAME(LinkObject) LinkObject.LinkName

#define GET_POLICY(Object) Object.Policy

#define NUMBER_OF_LINKS(pLinkEnumeration) pLinkEnumeration->NumberOfLinks

#define NUMBER_OF_ROOTS(pRootEnumeration) pRootEnumeration->NumberOfRoots

#define LINK_GUID_STRING(pLink, index) pLink->Info[index].GuidString

#define LINK_NAME(pLink, index) pLink->Info[index].Name

#define ROOT_NAME(pLink, index) pLink->Info[index].Name.Buffer

#define GET_ROOT_REPLICAS(pRoot) pRoot->Replicas

#define GET_LINK_REPLICAS(pLink) pLink->Replicas
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsmisc.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    header.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   11\10\1999
    
NOTES:

*/

#ifndef __DFS_MISC_H__
#define __DFS_MISC_H__

#ifdef __cplusplus
extern "C" {
#endif

VOID
DfsGetNetbiosName(
   PUNICODE_STRING pName,
   PUNICODE_STRING pNetbiosName,
   PUNICODE_STRING pRemaining );


DFSSTATUS
DfsGetPathComponents(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining);


DFSSTATUS
DfsGetFirstComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pFirstName,
   PUNICODE_STRING pRemaining);


DFSSTATUS
DfsIsThisAMachineName(LPWSTR MachineName);


DFSSTATUS
DfsIsThisADomainName(LPWSTR DomainName);

DFSSTATUS
DfsGenerateUuidString(LPWSTR *UuidString );

VOID
DfsReleaseUuidString(LPWSTR *UuidString );

DFSSTATUS
DfsCreateUnicodeString( 
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc );

DFSSTATUS
DfsCreateUnicodeStringFromString( 
    PUNICODE_STRING pDest,
    LPWSTR pSrcString );


DFSSTATUS
DfsCreateUnicodePathString(
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    LPWSTR pFirstComponent,
    LPWSTR pRemaining );

DFSSTATUS
DfsCreateUnicodePathStringFromUnicode(
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    PUNICODE_STRING pFirst,
    PUNICODE_STRING pRemaining );

VOID
DfsFreeUnicodeString( 
    PUNICODE_STRING pDfsString );

DFSSTATUS
DfsGetSharePath( 
    IN  LPWSTR ServerName,
    IN  LPWSTR ShareName,
    OUT PUNICODE_STRING pPathName );

ULONG
DfsSizeUncPath( 
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent );

VOID
DfsCopyUncPath( 
    LPWSTR NewPath,
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent );

ULONG
DfsApiSizeLevelHeader(
    ULONG Level );

NTSTATUS
AddNextPathComponent( 
    PUNICODE_STRING pPath );

NTSTATUS 
StripLastPathComponent( 
    PUNICODE_STRING pPath );



DFSSTATUS
PackGetULong(
        PULONG pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetULong(
        ULONG Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeULong();


DFSSTATUS
PackGetUShort(
        PUSHORT pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetUShort(
        USHORT Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeUShort();


DFSSTATUS
PackGetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeString(
        PUNICODE_STRING pString);


DFSSTATUS
PackGetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining );


DFSSTATUS
PackSetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining );


ULONG
PackSizeGuid();


#define UNICODE_PATH_SEP  L'\\'

#define IsEmptyString(_str) \
        ( ((_str) == NULL) || ((_str)[0] == UNICODE_NULL) )
        
#define IsLocalName(_pUnicode) \
        ( (((_pUnicode)->Length == sizeof(WCHAR)) && ((_pUnicode)->Buffer[0] == L'.')) ||    \
          (((_pUnicode)->Length == 2 * sizeof(WCHAR)) && ((_pUnicode)->Buffer[0] == L'.') && ((_pUnicode)->Buffer[1] == UNICODE_NULL)) )
          


#ifdef __cplusplus
}

#endif
#endif /* __DFS_MISC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsnetevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    netevent.h

Abstract:

    Definitions for network events.

Author:

    Portable Systems Group 6-May-1992

Revision History:

Notes:

    This file is generated by the MC tool from the netevent.mc file.

--*/

#ifndef _NETEVENT_
#define _NETEVENT_


/////////////////////////////////////////////////////////////////////////
//
// Lanman Server Events (2000 - 2999)
//     2000-2499 are generated by the server driver (kernel mode)
//     2500-2999 are generated by the server service (user mode)
//
/////////////////////////////////////////////////////////////////////////


// Server driver events, issued from kernel mode.  Don't use %1 for
// server-supplied insertion strings -- the I/O system provides the
// first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_SRV_SERVICE_FAILED
//
// MessageText:
//
//  The server's call to a system service failed unexpectedly.
//
#define EVENT_SRV_SERVICE_FAILED         0xC00007D0L

//
// MessageId: EVENT_SRV_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The server was unable to perform an operation due to a shortage of available resources.
//
#define EVENT_SRV_RESOURCE_SHORTAGE      0xC00007D1L

//
// MessageId: EVENT_SRV_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The server could not create its device.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_DEVICE     0xC00007D2L

//
// MessageId: EVENT_SRV_CANT_CREATE_PROCESS
//
// MessageText:
//
//  The server could not create a process.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_PROCESS    0xC00007D3L

//
// MessageId: EVENT_SRV_CANT_CREATE_THREAD
//
// MessageText:
//
//  The server could not create a startup thread.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_THREAD     0xC00007D4L

//
// MessageId: EVENT_SRV_UNEXPECTED_DISC
//
// MessageText:
//
//  The server received an unexpected disconnection from a client.
//
#define EVENT_SRV_UNEXPECTED_DISC        0xC00007D5L

//
// MessageId: EVENT_SRV_INVALID_REQUEST
//
// MessageText:
//
//  The server received an incorrectly formatted request from %2.
//
#define EVENT_SRV_INVALID_REQUEST        0xC00007D6L

//
// MessageId: EVENT_SRV_CANT_OPEN_NPFS
//
// MessageText:
//
//  The server could not open the named pipe file system.  Remote named pipes are disabled.
//
#define EVENT_SRV_CANT_OPEN_NPFS         0xC00007D7L

//
// MessageId: EVENT_SRV_CANT_GROW_TABLE
//
// MessageText:
//
//  The server could not expand a table because the table reached the maximum size.
//
#define EVENT_SRV_CANT_GROW_TABLE        0x800007D9L

//
// MessageId: EVENT_SRV_CANT_START_SCAVENGER
//
// MessageText:
//
//  The server could not start the scavenger thread.  The server could not be started.
//
#define EVENT_SRV_CANT_START_SCAVENGER   0xC00007DAL

//
// MessageId: EVENT_SRV_IRP_STACK_SIZE
//
// MessageText:
//
//  The server's configuration parameter "irpstacksize" is too small for the server to use a local device.  Please increase the value of this parameter.
//
#define EVENT_SRV_IRP_STACK_SIZE         0xC00007DBL

//
// MessageId: EVENT_SRV_NETWORK_ERROR
//
// MessageText:
//
//  While transmitting or receiving data, the server encountered a network error.
//  Occassional errors are expected, but large amounts of these indicate a possible
//  error in your network configuration.  The error status code is contained within
//  the returned data (formatted as Words) and may point you towards the problem.
//
#define EVENT_SRV_NETWORK_ERROR          0x800007DCL

//
// MessageId: EVENT_SRV_DISK_FULL
//
// MessageText:
//
//  The %2 disk is at or near capacity.  You may need to delete some files.
//
#define EVENT_SRV_DISK_FULL              0x800007DDL

//
// MessageId: EVENT_SRV_NO_VIRTUAL_MEMORY
//
// MessageText:
//
//  The server was unable to allocate virtual memory.
//
#define EVENT_SRV_NO_VIRTUAL_MEMORY      0xC00007E0L

//
// MessageId: EVENT_SRV_NONPAGED_POOL_LIMIT
//
// MessageText:
//
//  The server was unable to allocate from the system nonpaged pool because the server reached the configured limit for nonpaged pool allocations.
//
#define EVENT_SRV_NONPAGED_POOL_LIMIT    0xC00007E1L

//
// MessageId: EVENT_SRV_PAGED_POOL_LIMIT
//
// MessageText:
//
//  The server was unable to allocate from the system paged pool because the server reached the configured limit for paged pool allocations.
//
#define EVENT_SRV_PAGED_POOL_LIMIT       0xC00007E2L

//
// MessageId: EVENT_SRV_NO_NONPAGED_POOL
//
// MessageText:
//
//  The server was unable to allocate from the system nonpaged pool because the pool was empty.
//
#define EVENT_SRV_NO_NONPAGED_POOL       0xC00007E3L

//
// MessageId: EVENT_SRV_NO_PAGED_POOL
//
// MessageText:
//
//  The server was unable to allocate from the system paged pool because the pool was empty.
//
#define EVENT_SRV_NO_PAGED_POOL          0xC00007E4L

//
// MessageId: EVENT_SRV_NO_WORK_ITEM
//
// MessageText:
//
//  The server was unable to allocate a work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_WORK_ITEM           0x800007E5L

//
// MessageId: EVENT_SRV_NO_FREE_CONNECTIONS
//
// MessageText:
//
//  The server was unable to find a free connection %2 times in the last %3 seconds.  This indicates a spike in
//  network traffic.  If this is happening frequently, you should consider increasing the minimum number of free
//  connections to add headroom.  To do that, modify the MinFreeConnections and MaxFreeConnections for the LanmanServer
//  in the registry.
//
#define EVENT_SRV_NO_FREE_CONNECTIONS    0x800007E6L

//
// MessageId: EVENT_SRV_NO_FREE_RAW_WORK_ITEM
//
// MessageText:
//
//  The server was unable to find a free raw work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_FREE_RAW_WORK_ITEM  0x800007E7L

//
// MessageId: EVENT_SRV_NO_BLOCKING_IO
//
// MessageText:
//
//  The server was unable to allocate resources for blocking I/O %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_BLOCKING_IO         0x800007E8L

//
// MessageId: EVENT_SRV_DOS_ATTACK_DETECTED
//
// MessageText:
//
//  The server has detected an attempted Denial-Of-Service attack from client %2, and has disconnected the connection.
//
#define EVENT_SRV_DOS_ATTACK_DETECTED    0x800007E9L

//
// MessageId: EVENT_SRV_TOO_MANY_DOS
//
// MessageText:
//
//  The server has detected too many Denial-Of-Service attacks and will stop logging
//  events for any more of them.  Be advised it is likely someone is actively attacking
//  your machine.
//
#define EVENT_SRV_TOO_MANY_DOS           0x800007EAL

//
// MessageId: EVENT_SRV_OUT_OF_WORK_ITEM_DOS
//
// MessageText:
//
//  The server has detected a potential Denial-of-Service attack caused by consuming all the work-items.  Some connections
//  were disconnected to protect against this.  If this is not the case, please raise the MaxWorkItems for the server or
//  disable DoS detection.  This event will not be logged again for 24 hours.
//
#define EVENT_SRV_OUT_OF_WORK_ITEM_DOS   0x800007EBL


// Server service events, issued from user mode.  %1 is the first
// service-supplied insertion string.

//
// MessageId: EVENT_SRV_KEY_NOT_FOUND
//
// MessageText:
//
//  The server's Registry key %1 was not present.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_FOUND          0xC00009C5L

//
// MessageId: EVENT_SRV_KEY_NOT_CREATED
//
// MessageText:
//
//  The server's Registry key %1 was not present and could not be created.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_CREATED        0xC00009C6L

//
// MessageId: EVENT_SRV_NO_TRANSPORTS_BOUND
//
// MessageText:
//
//  The server did not bind to any transports.  The server could not start.
//
#define EVENT_SRV_NO_TRANSPORTS_BOUND    0xC00009C7L

//
// MessageId: EVENT_SRV_CANT_BIND_TO_TRANSPORT
//
// MessageText:
//
//  The server could not bind to the transport %1.
//
#define EVENT_SRV_CANT_BIND_TO_TRANSPORT 0x800009C8L

//
// MessageId: EVENT_SRV_CANT_BIND_DUP_NAME
//
// MessageText:
//
//  The server could not bind to the transport %1 because another computer on the network has the same name.  The server could not start.
//
#define EVENT_SRV_CANT_BIND_DUP_NAME     0xC00009C9L

//
// MessageId: EVENT_SRV_INVALID_REGISTRY_VALUE
//
// MessageText:
//
//  The value named %1 in the server's registry key %2 was not valid, and was ignored.
//  If you want to change the value, change it to one that is the correct type and is
//  within the acceptable range, or delete the value to use the default. This value
//  might have been set up by an older program that did not use the correct boundaries.
//
#define EVENT_SRV_INVALID_REGISTRY_VALUE 0x800009CAL

//
// MessageId: EVENT_SRV_INVALID_SD
//
// MessageText:
//
//  The security descriptor stored in the Registry for the share %1 was invalid.  The share was not automatically recreated.
//
#define EVENT_SRV_INVALID_SD             0x800009CBL

//
// MessageId: EVENT_SRV_CANT_LOAD_DRIVER
//
// MessageText:
//
//  The server service was unable to load the server driver.
//
#define EVENT_SRV_CANT_LOAD_DRIVER       0x800009CCL

//
// MessageId: EVENT_SRV_CANT_UNLOAD_DRIVER
//
// MessageText:
//
//  The server service was unable to unload the server driver.
//
#define EVENT_SRV_CANT_UNLOAD_DRIVER     0x800009CDL

//
// MessageId: EVENT_SRV_CANT_MAP_ERROR
//
// MessageText:
//
//  The server service was unable to map error code %1.
//
#define EVENT_SRV_CANT_MAP_ERROR         0x800009CEL

//
// MessageId: EVENT_SRV_CANT_RECREATE_SHARE
//
// MessageText:
//
//  The server service was unable to recreate the share %1 because the directory %2 no longer exists.  Please run "net share %1 /delete" to delete the share, or recreate the directory %2.
//
#define EVENT_SRV_CANT_RECREATE_SHARE    0x800009CFL

//
// MessageId: EVENT_SRV_CANT_CHANGE_DOMAIN_NAME
//
// MessageText:
//
//  The server service was unable to change the domain name from %1 to %2.
//
#define EVENT_SRV_CANT_CHANGE_DOMAIN_NAME 0x800009D0L


/////////////////////////////////////////////////////////////////////////
//
// Lanman Redirector Events
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RDR_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The redirector was unable to allocate memory.
//
#define EVENT_RDR_RESOURCE_SHORTAGE      0x80000BB9L

//
// MessageId: EVENT_RDR_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The redirector could not create its device.  The redirector could not be started.
//
#define EVENT_RDR_CANT_CREATE_DEVICE     0x80000BBAL

//
// MessageId: EVENT_RDR_CANT_CREATE_THREAD
//
// MessageText:
//
//  The redirector could not create a system thread.
//
#define EVENT_RDR_CANT_CREATE_THREAD     0x80000BBBL

//
// MessageId: EVENT_RDR_CANT_SET_THREAD
//
// MessageText:
//
//  The redirector could not set the priority for a system thread.
//
#define EVENT_RDR_CANT_SET_THREAD        0x80000BBCL

//
// MessageId: EVENT_RDR_INVALID_REPLY
//
// MessageText:
//
//  The redirector received an incorrectly formatted response from %2.
//
#define EVENT_RDR_INVALID_REPLY          0x80000BBDL

//
// MessageId: EVENT_RDR_INVALID_SMB
//
// MessageText:
//
//  The redirector received an SMB that was too short.
//
#define EVENT_RDR_INVALID_SMB            0x80000BBEL

//
// MessageId: EVENT_RDR_INVALID_LOCK_REPLY
//
// MessageText:
//
//  The redirector received an incorrect response from %2 to a lock request.
//
#define EVENT_RDR_INVALID_LOCK_REPLY     0x80000BBFL

//
// MessageId: EVENT_RDR_FAILED_UNLOCK
//
// MessageText:
//
//  The redirector failed to unlock part of a file on server %2.
//
#define EVENT_RDR_FAILED_UNLOCK          0x80000BC1L

//
// MessageId: EVENT_RDR_CLOSE_BEHIND
//
// MessageText:
//
//  The redirector failed to write data to server %2 after the file was closed.
//
#define EVENT_RDR_CLOSE_BEHIND           0x80000BC3L

//
// MessageId: EVENT_RDR_UNEXPECTED_ERROR
//
// MessageText:
//
//  An unexpected network error has occurred on the virtual circuit to %2.
//
#define EVENT_RDR_UNEXPECTED_ERROR       0x80000BC4L

//
// MessageId: EVENT_RDR_TIMEOUT
//
// MessageText:
//
//  The redirector has timed out a request to %2.
//
#define EVENT_RDR_TIMEOUT                0x80000BC5L

//
// MessageId: EVENT_RDR_INVALID_OPLOCK
//
// MessageText:
//
//  The redirector received an invalid oplock level from %2.
//
#define EVENT_RDR_INVALID_OPLOCK         0x80000BC6L

//
// MessageId: EVENT_RDR_CONNECTION_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced a connection through zero.
//
#define EVENT_RDR_CONNECTION_REFERENCE   0x80000BC7L

//
// MessageId: EVENT_RDR_SERVER_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced a server through zero.
//
#define EVENT_RDR_SERVER_REFERENCE       0x80000BC8L

//
// MessageId: EVENT_RDR_SMB_REFERENCE
//
// MessageText:
//
//  The redirector dereferenced the allocated SMB count through zero.
//
#define EVENT_RDR_SMB_REFERENCE          0x80000BC9L

//
// MessageId: EVENT_RDR_ENCRYPT
//
// MessageText:
//
//  The redirector accessed a share-level server that indicates it encrypts passwords.
//  This combination is not supported.
//
#define EVENT_RDR_ENCRYPT                0x80000BCAL

//
// MessageId: EVENT_RDR_CONNECTION
//
// MessageText:
//
//  The redirector failed to determine the connection type.
//
#define EVENT_RDR_CONNECTION             0x80000BCBL

//
// MessageId: EVENT_RDR_MAXCMDS
//
// MessageText:
//
//  The redirector failed to allocate a multiplex table entry.  This indicates that
//  the MAXCMDS parameter to the redirector is insufficient for the users needs.
//
#define EVENT_RDR_MAXCMDS                0x80000BCDL

//
// MessageId: EVENT_RDR_OPLOCK_SMB
//
// MessageText:
//
//  The redirector failed to allocate a buffer for an oplock break.
//
#define EVENT_RDR_OPLOCK_SMB             0x80000BCEL

//
// MessageId: EVENT_RDR_DISPOSITION
//
// MessageText:
//
//  The redirector failed to map the requested file disposition (for NtCreateFile).
//
#define EVENT_RDR_DISPOSITION            0x80000BCFL

//
// MessageId: EVENT_RDR_CONTEXTS
//
// MessageText:
//
//  The redirector is allocating additional resources for input/output request packet contexts.  This is
//  probably caused by a resource leak in the redirector.
//
#define EVENT_RDR_CONTEXTS               0x80000BD0L

//
// MessageId: EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED
//
// MessageText:
//
//  A write-behind operation has failed to the remote server %2.  The data contains the amount requested to write and the amount actually written.
//
#define EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED 0x80000BD1L

//
// MessageId: EVENT_RDR_AT_THREAD_MAX
//
// MessageText:
//
//  The redirector was unable to create a worker thread because it has already created the maximum number of configured work threads.
//
#define EVENT_RDR_AT_THREAD_MAX          0x80000BD2L

//
// MessageId: EVENT_RDR_CANT_READ_REGISTRY
//
// MessageText:
//
//  The redirector was unable to initialize variables from the Registry.
//
#define EVENT_RDR_CANT_READ_REGISTRY     0x80000BD3L

//
// MessageId: EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE
//
// MessageText:
//
//  The time zone bias calculated between %2 and the current workstation is too
//  large.  The data specifies the number of 100ns units between the workstation
//  and server.  Make sure that the time of day on the workstation and server are
//  correct.
//
#define EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE 0x80000BD4L

//
// MessageId: EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
//  The redirector has failed to connect to the server %2 on the primary transport.  The data contains the error.
//
#define EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED 0x80000BD5L

//
// MessageId: EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED
//
// MessageText:
//
//  The redirector was unable to update the file attributes on a file located on server %2.
//  The data contains the name of the file.
//
#define EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED 0x80000BD6L

//
// MessageId: EVENT_RDR_DELETEONCLOSE_FAILED
//
// MessageText:
//
//  The redirector was unable to delete the file specified on server %2 when it was closed by the application.
//  The data contains the name of the file.
//
#define EVENT_RDR_DELETEONCLOSE_FAILED   0x80000BD7L

//
// MessageId: EVENT_RDR_CANT_BIND_TRANSPORT
//
// MessageText:
//
//  The redirector was unable to register the domain %2 on to transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_BIND_TRANSPORT    0x80000BD8L

//
// MessageId: EVENT_RDR_CANT_REGISTER_ADDRESS
//
// MessageText:
//
//  The redirector was unable to register the address for transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_REGISTER_ADDRESS  0x80000BD9L

//
// MessageId: EVENT_RDR_CANT_GET_SECURITY_CONTEXT
//
// MessageText:
//
//  The redirector was unable to initialize security context or query context attributes.
//
#define EVENT_RDR_CANT_GET_SECURITY_CONTEXT 0x80000BDAL

//
// MessageId: EVENT_RDR_CANT_BUILD_SMB_HEADER
//
// MessageText:
//
//  The redirector was unable to build SMB header.
//
#define EVENT_RDR_CANT_BUILD_SMB_HEADER  0x80000BDBL

//
// MessageId: EVENT_RDR_SECURITY_SIGNATURE_MISMATCH
//
// MessageText:
//
//  The redirector detected a security signature mismatch. The connection has been disconnected.
//
#define EVENT_RDR_SECURITY_SIGNATURE_MISMATCH 0x80000BDCL



/////////////////////////////////////////////////////////////////////////
//
// IPv6 Events
//
// Codes 3100 - 3199
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TCPIP6_STARTED
//
// MessageText:
//
//  The Microsoft IPv6 Developer Edition driver was started.
//
#define EVENT_TCPIP6_STARTED             0x40000C1CL



/////////////////////////////////////////////////////////////////////////
//
// STREAMS Environment Events
//
// Codes 4000 - 4099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_STREAMS_STRLOG
//
// MessageText:
//
//  %2.
//
#define EVENT_STREAMS_STRLOG             0xC0000FA0L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE
//
// MessageText:
//
//  Unable to allocate a %2 byte message.
//
#define EVENT_STREAMS_ALLOCB_FAILURE     0x80000FA1L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE_CNT
//
// MessageText:
//
//  %2 message allocations have failed since initialization.
//
#define EVENT_STREAMS_ALLOCB_FAILURE_CNT 0x80000FA2L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE
//
// MessageText:
//
//  Unable to allocate a %2 byte external message.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE   0x80000FA3L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE_CNT
//
// MessageText:
//
//  %2 external message allocations have failed since initialization.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE_CNT 0x80000FA4L



/////////////////////////////////////////////////////////////////////////
//
// TCP/IP Events
//
// Codes 4100 - 4299
//
/////////////////////////////////////////////////////////////////////////


//
// Common TCP/IP messages
//
// Codes 4100 - 4149
//
//

//
// MessageId: EVENT_TCPIP_CREATE_DEVICE_FAILED
//
// MessageText:
//
//  Unable to create device object %2. Initialization failed.
//
#define EVENT_TCPIP_CREATE_DEVICE_FAILED 0xC0001004L

//
// MessageId: EVENT_TCPIP_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  Unable to allocate required resources. Initialization failed.
//
#define EVENT_TCPIP_NO_RESOURCES_FOR_INIT 0xC0001005L


//
// ARP messages
//
// Codes 4150-4174


//
// IP Loopback messages
//
// Codes 4175-4184
//


//
// IP/ICMP messages
//
// Codes 4185 - 4224

//
// MessageId: EVENT_TCPIP_TOO_MANY_NETS
//
// MessageText:
//
//  IP has been bound to more than the maximum number of supported interfaces.
//  Some interfaces on adapter %2 will not be initialized.
//
#define EVENT_TCPIP_TOO_MANY_NETS        0xC0001059L

//
// MessageId: EVENT_TCPIP_NO_MASK
//
// MessageText:
//
//  No subnet mask was specified for interface %2. This interface and
//  all subsequent interfaces on adapter %3 cannot be initialized.
//
#define EVENT_TCPIP_NO_MASK              0xC000105AL

//
// MessageId: EVENT_TCPIP_INVALID_ADDRESS
//
// MessageText:
//
//  Invalid address %2 was specified for adapter %3. This interface
//  cannot be initialized.
//
#define EVENT_TCPIP_INVALID_ADDRESS      0xC000105BL

//
// MessageId: EVENT_TCPIP_INVALID_MASK
//
// MessageText:
//
//  Invalid subnet mask %2 was specified for address %3 on adapter %4.
//  This interface cannot be initialized.
//
#define EVENT_TCPIP_INVALID_MASK         0xC000105CL

//
// MessageId: EVENT_TCPIP_NO_ADAPTER_RESOURCES
//
// MessageText:
//
//  IP could not allocate some resources required to configure adapter %2.
//  Some interfaces on this adapter will not be initialized.
//
#define EVENT_TCPIP_NO_ADAPTER_RESOURCES 0xC000105DL

//
// MessageId: EVENT_TCPIP_DHCP_INIT_FAILED
//
// MessageText:
//
//  IP was unable to initialize adapter %2 for configuration by DHCP.
//  If DHCP is enabled on this adapter, the primary interface may not be
//  configured properly. Interfaces on this adapter not configured by
//  DHCP will be unaffected.
//
#define EVENT_TCPIP_DHCP_INIT_FAILED     0x8000105EL

//
// MessageId: EVENT_TCPIP_ADAPTER_REG_FAILURE
//
// MessageText:
//
//  IP could not open the registry key for adapter %2.
//  Interfaces on this adapter will not be initialized.
//
#define EVENT_TCPIP_ADAPTER_REG_FAILURE  0xC000105FL

//
// MessageId: EVENT_TCPIP_INVALID_DEFAULT_GATEWAY
//
// MessageText:
//
//  Invalid default gateway address %2 was specified for adapter %3.
//  Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_INVALID_DEFAULT_GATEWAY 0x80001060L

//
// MessageId: EVENT_TCPIP_NO_ADDRESS_LIST
//
// MessageText:
//
//  Unable to read the configured IP addresses for adapter %2.
//  IP interfaces will not be initialized on this adapter.
//
#define EVENT_TCPIP_NO_ADDRESS_LIST      0xC0001061L

//
// MessageId: EVENT_TCPIP_NO_MASK_LIST
//
// MessageText:
//
//  Unable to read the configured subnet masks for adapter %2.
//  IP interfaces will not be initialized on this adapter.
//
#define EVENT_TCPIP_NO_MASK_LIST         0xC0001062L

//
// MessageId: EVENT_TCPIP_NO_BINDINGS
//
// MessageText:
//
//  IP was unable to read its bindings from the registry. No network interfaces
//  were configured.
//
#define EVENT_TCPIP_NO_BINDINGS          0xC0001063L

//
// MessageId: EVENT_TCPIP_IP_INIT_FAILED
//
// MessageText:
//
//  Initialization of IP failed.
//
#define EVENT_TCPIP_IP_INIT_FAILED       0xC0001064L

//
// MessageId: EVENT_TCPIP_TOO_MANY_GATEWAYS
//
// MessageText:
//
//  More than the maximum number of default gateways were specified for
//  adapter %2. Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_TOO_MANY_GATEWAYS    0x80001065L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT1
//
// MessageText:
//
//  The system detected an address conflict for IP address %2 with the system
//  having network hardware address %3. The local interface has been disabled.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT1    0xC0001066L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT2
//
// MessageText:
//
//  The system detected an address conflict for IP address %2 with the system
//  having network hardware address %3. Network operations on this system may
//  be disrupted as a result.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT2    0xC0001067L

//
// MessageId: EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE
//
// MessageText:
//
//  Unable to read or write the NTE Context list for adapter %2.
//  IP interfaces on this adapter may not be initialized completely.
//
#define EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE 0xC0001068L

//
// MessageId: EVENT_TCPIP_MEDIA_CONNECT
//
// MessageText:
//
//  The system detected that network adapter %2 was connected to the network,
//  and has initiated normal operation over the network adapter.
//
#define EVENT_TCPIP_MEDIA_CONNECT        0x40001069L

//
// MessageId: EVENT_TCPIP_MEDIA_DISCONNECT
//
// MessageText:
//
//  The system detected that network adapter %2 was disconnected from the network,
//  and the adapter's network configuration has been released. If the network
//  adapter was not disconnected, this may indicate that it has malfunctioned.
//  Please contact your vendor for updated drivers.
//
#define EVENT_TCPIP_MEDIA_DISCONNECT     0x4000106AL


//
// TCP messages
//
// Codes 4225 - 4264
//

//
// MessageId: EVENT_TCPIP_TCP_INIT_FAILED
//
// MessageText:
//
//  Initialization of TCP/UDP failed.
//
#define EVENT_TCPIP_TCP_INIT_FAILED      0xC0001081L


//
// UDP messages
//
// Codes 4265 - 4280
//

//
// MessageId: EVENT_TCPIP_UDP_LIMIT_REACHED
//
// MessageText:
//
//  Backlog of pending datagram sends reached. Please increase the value of Tcpip\Parameters\DGMaxSendFree in the registry.
//
#define EVENT_TCPIP_UDP_LIMIT_REACHED    0x800010A9L

//
// IPSEC messages
//
// Codes 4281 - 4299
//

//
// MessageId: EVENT_IPSEC_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  Unable to allocate required resources. Initialization failed.
//
#define EVENT_IPSEC_NO_RESOURCES_FOR_INIT 0xC00010B9L

//
// MessageId: EVENT_IPSEC_CREATE_DEVICE_FAILED
//
// MessageText:
//
//  Unable to create device object %2. Initialization failed.
//
#define EVENT_IPSEC_CREATE_DEVICE_FAILED 0xC00010BAL

//
// MessageId: EVENT_IPSEC_BAD_SPI_RECEIVED
//
// MessageText:
//
//  Received %2 packet(s) with a bad Security Parameters Index from %3.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_SPI_RECEIVED     0xC00010BBL

//
// MessageId: EVENT_IPSEC_UNEXPECTED_CLEARTEXT
//
// MessageText:
//
//  Received %2 packet(s) in the clear from %3 which should have been secured.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_UNEXPECTED_CLEARTEXT 0xC00010BCL

//
// MessageId: EVENT_IPSEC_AUTH_FAILURE
//
// MessageText:
//
//  Failed to authenticate the hash for %2 packet(s) received from %3.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_AUTH_FAILURE         0xC00010BDL

//
// MessageId: EVENT_IPSEC_BAD_PACKET_SYNTAX
//
// MessageText:
//
//  Received %2 packet(s) from %3 with invalid packet syntax.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_PACKET_SYNTAX    0xC00010BEL

//
// MessageId: EVENT_IPSEC_BAD_PROTOCOL_RECEIVED
//
// MessageText:
//
//  Received %2 packet(s) from %3 with inproper protocol identifier.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine.
//
#define EVENT_IPSEC_BAD_PROTOCOL_RECEIVED 0xC00010BFL

//
// MessageId: EVENT_IPSEC_GENERIC_FAILURE
//
// MessageText:
//
//  Received %2 packet(s) from %3 that failed the IPSec processing for an unknown reason.
//  This could be a temporary glitch; if it persists please stop and restart the IPSec Policy Agent service on this machine..
//
#define EVENT_IPSEC_GENERIC_FAILURE      0xC00010C0L

//
// MessageId: EVENT_IPSEC_NEG_FAILURE
//
// MessageText:
//
//  The IPSec driver failed the oakley negotiation with %2 since no filter
//  exists to protect packets to that destination.
//  Please check the configuration on this machine to ensure at least one
//  filter matches the destination.
//
#define EVENT_IPSEC_NEG_FAILURE          0xC00010C1L

//
// MessageId: EVENT_IPSEC_DROP_PACKET_INBOUND
//
// MessageText:
//
//  The IPSec driver has dropped the following inbound packet:
//  %nSource IP Address: %2
//  %nDestination IP Address: %3
//  %nProtocol: %4
//  %nSource Port:  %5
//  %nDestination Port: %6
//  %nOffset for IPSec status code:                  0x14
//  %nOffset for Offload status code:                0x10
//  %nOffset for Offload flags(0=no offload):        0x20
//  %nOffset for packet start:                       0x28
//
#define EVENT_IPSEC_DROP_PACKET_INBOUND  0x400010C2L

//
// MessageId: EVENT_IPSEC_DROP_PACKET_OUTBOUND
//
// MessageText:
//
//  The IPSec driver has dropped the following outbound packet:
//  %nSource IP Address: %2
//  %nDestination IP Address: %3
//  %nProtocol: %4
//  %nSource Port:  %5
//  %nDestination Port: %6
//  %nOffset for IPSec status code:    0x14
//  %nOffset for Offload status code:  0x10
//  %nOffset for Offload flags:        0x20
//  %nOffset for packet start:         0x28
//
#define EVENT_IPSEC_DROP_PACKET_OUTBOUND 0x400010C3L



/////////////////////////////////////////////////////////////////////////
//
// NBT Events
//
// Codes 4300 - 4399
//
/////////////////////////////////////////////////////////////////////////



// Don't use %1 for driver supplied insertion strings.  The IO subsystem
// supplies the first string!!

//
// MessageId: EVENT_NBT_CREATE_DRIVER
//
// MessageText:
//
//  The driver could not be created.
//
#define EVENT_NBT_CREATE_DRIVER          0xC00010CCL

//
// MessageId: EVENT_NBT_OPEN_REG_PARAMS
//
// MessageText:
//
//  Unable to open the Registry Parameters to read configuration information.
//
#define EVENT_NBT_OPEN_REG_PARAMS        0xC00010CDL

//
// MessageId: EVENT_NBT_NO_BACKUP_WINS
//
// MessageText:
//
//  The backup WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_BACKUP_WINS         0x800010CEL

//
// MessageId: EVENT_NBT_NO_WINS
//
// MessageText:
//
//  The primary WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_WINS                0x800010CFL

//
// MessageId: EVENT_NBT_BAD_BACKUP_WINS_ADDR
//
// MessageText:
//
//  The backup WINS server address is not formated correctly in the registry.
//
#define EVENT_NBT_BAD_BACKUP_WINS_ADDR   0x800010D0L

//
// MessageId: EVENT_NBT_BAD_PRIMARY_WINS_ADDR
//
// MessageText:
//
//  The primary WINS server address is not formated correctly in the registry.
//
#define EVENT_NBT_BAD_PRIMARY_WINS_ADDR  0x800010D1L

//
// MessageId: EVENT_NBT_NAME_SERVER_ADDRS
//
// MessageText:
//
//  Unable to configure the addresses of the WINS servers.
//
#define EVENT_NBT_NAME_SERVER_ADDRS      0xC00010D2L

//
// MessageId: EVENT_NBT_CREATE_ADDRESS
//
// MessageText:
//
//  Initialization failed because the transport refused to open initial Addresses.
//
#define EVENT_NBT_CREATE_ADDRESS         0xC00010D3L

//
// MessageId: EVENT_NBT_CREATE_CONNECTION
//
// MessageText:
//
//  Initialization failed because the transport refused to open initial Connections.
//
#define EVENT_NBT_CREATE_CONNECTION      0xC00010D4L

//
// MessageId: EVENT_NBT_NON_OS_INIT
//
// MessageText:
//
//  Data structure initialization failed.
//
#define EVENT_NBT_NON_OS_INIT            0xC00010D5L

//
// MessageId: EVENT_NBT_TIMERS
//
// MessageText:
//
//  Initialization failed because the timers could not be started.
//
#define EVENT_NBT_TIMERS                 0xC00010D6L

//
// MessageId: EVENT_NBT_CREATE_DEVICE
//
// MessageText:
//
//  Initialization failed because the driver device could not be created.
//
#define EVENT_NBT_CREATE_DEVICE          0xC00010D7L

//
// MessageId: EVENT_NBT_NO_DEVICES
//
// MessageText:
//
//  There are no adapters configured for this protocol stack.
//
#define EVENT_NBT_NO_DEVICES             0x800010D8L

//
// MessageId: EVENT_NBT_OPEN_REG_LINKAGE
//
// MessageText:
//
//  Unable to open the Registry Linkage to read configuration information.
//
#define EVENT_NBT_OPEN_REG_LINKAGE       0xC00010D9L

//
// MessageId: EVENT_NBT_READ_BIND
//
// MessageText:
//
//  Unable to read the driver's bindings to the transport from the registry.
//
#define EVENT_NBT_READ_BIND              0xC00010DAL

//
// MessageId: EVENT_NBT_READ_EXPORT
//
// MessageText:
//
//  Unable to read the driver's exported linkage configuration information.
//
#define EVENT_NBT_READ_EXPORT            0xC00010DBL

//
// MessageId: EVENT_NBT_OPEN_REG_NAMESERVER
//
// MessageText:
//
//  Unable to open the Registry to read the WINS server addresses.
//
#define EVENT_NBT_OPEN_REG_NAMESERVER    0x800010DCL

//
// MessageId: EVENT_SCOPE_LABEL_TOO_LONG
//
// MessageText:
//
//  The Netbios Name Scope has a component longer than 63 characters. Each label
//  in the Scope cannot be longer than 63 bytes.  Use the Control Panel, Network
//  applet to change the scope.
//
#define EVENT_SCOPE_LABEL_TOO_LONG       0x800010DDL

//
// MessageId: EVENT_SCOPE_TOO_LONG
//
// MessageText:
//
//  The Netbios Name Scope is too long. The scope cannot be longer than
//  255 bytes. Use the Control Panel, Network applet to change the scope.
//
#define EVENT_SCOPE_TOO_LONG             0x800010DEL

//
// MessageId: EVENT_NBT_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name has been detected on the TCP network.  The IP address of
//  the machine that sent the message is in the data. Use nbtstat -n in a
//  command window to see which name is in the Conflict state.
//
#define EVENT_NBT_DUPLICATE_NAME         0xC00010DFL

//
// MessageId: EVENT_NBT_NAME_RELEASE
//
// MessageText:
//
//  Another machine has sent a name release message to this machine probably
//  because a duplicate name has been detected on the TCP network.  The IP address
//  of the node that sent the message is in the data. Use nbtstat -n in a
//  command window to see which name is in the Conflict state.
//
#define EVENT_NBT_NAME_RELEASE           0xC00010E0L

//
// MessageId: EVENT_NBT_DUPLICATE_NAME_ERROR
//
// MessageText:
//
//  The name "%2" could not be registered on the Interface with IP address %3.
//  The machine with the IP address %4 did not allow the name to be claimed by
//  this machine.
//
#define EVENT_NBT_DUPLICATE_NAME_ERROR   0xC00010E1L

//
// MessageId: EVENT_NBT_NO_RESOURCES
//
// MessageText:
//
//  NetBT failed to process a request because it encountered OutOfResources
//  exception(s) in the last 1 hour.
//
#define EVENT_NBT_NO_RESOURCES           0xC00010E2L


/////////////////////////////////////////////////////////////////////////
//
// NDIS Environment Events
//
// Codes 5000 - 5099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
//  %2 : Has encountered a conflict in resources and could not load.
//
#define EVENT_NDIS_RESOURCE_CONFLICT     0xC0001388L

//
// MessageId: EVENT_NDIS_OUT_OF_RESOURCE
//
// MessageText:
//
//  %2 : Could not allocate the resources necessary for operation.
//
#define EVENT_NDIS_OUT_OF_RESOURCE       0xC0001389L

//
// MessageId: EVENT_NDIS_HARDWARE_FAILURE
//
// MessageText:
//
//  %2 : Has determined that the adapter is not functioning properly.
//
#define EVENT_NDIS_HARDWARE_FAILURE      0xC000138AL

//
// MessageId: EVENT_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  %2 : Could not find an adapter.
//
#define EVENT_NDIS_ADAPTER_NOT_FOUND     0xC000138BL

//
// MessageId: EVENT_NDIS_INTERRUPT_CONNECT
//
// MessageText:
//
//  %2 : Could not connect to the interrupt number supplied.
//
#define EVENT_NDIS_INTERRUPT_CONNECT     0xC000138CL

//
// MessageId: EVENT_NDIS_DRIVER_FAILURE
//
// MessageText:
//
//  %2 : Has encountered an internal error and has failed.
//
#define EVENT_NDIS_DRIVER_FAILURE        0xC000138DL

//
// MessageId: EVENT_NDIS_BAD_VERSION
//
// MessageText:
//
//  %2 : The version number is incorrect for this driver.
//
#define EVENT_NDIS_BAD_VERSION           0xC000138EL

//
// MessageId: EVENT_NDIS_TIMEOUT
//
// MessageText:
//
//  %2 : Timed out during an operation.
//
#define EVENT_NDIS_TIMEOUT               0x8000138FL

//
// MessageId: EVENT_NDIS_NETWORK_ADDRESS
//
// MessageText:
//
//  %2 : Has encountered an invalid network address.
//
#define EVENT_NDIS_NETWORK_ADDRESS       0xC0001390L

//
// MessageId: EVENT_NDIS_UNSUPPORTED_CONFIGURATION
//
// MessageText:
//
//  %2 : Does not support the configuration supplied.
//
#define EVENT_NDIS_UNSUPPORTED_CONFIGURATION 0xC0001391L

//
// MessageId: EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
//
// MessageText:
//
//  %2 : The adapter has returned an invalid value to the driver.
//
#define EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER 0xC0001392L

//
// MessageId: EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
//
// MessageText:
//
//  %2 : A required parameter is missing from the Registry.
//
#define EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER 0xC0001393L

//
// MessageId: EVENT_NDIS_BAD_IO_BASE_ADDRESS
//
// MessageText:
//
//  %2 : The I/O base address supplied does not match the jumpers on the adapter.
//
#define EVENT_NDIS_BAD_IO_BASE_ADDRESS   0xC0001394L

//
// MessageId: EVENT_NDIS_RECEIVE_SPACE_SMALL
//
// MessageText:
//
//  %2 : The adapter is configured such that the receive space is smaller than
//  the maximum packet size.  Some packets may be lost.
//
#define EVENT_NDIS_RECEIVE_SPACE_SMALL   0x40001395L

//
// MessageId: EVENT_NDIS_ADAPTER_DISABLED
//
// MessageText:
//
//  %2 : The adapter is disabled.  The driver cannot open the adapter.
//
#define EVENT_NDIS_ADAPTER_DISABLED      0x80001396L

//
// MessageId: EVENT_NDIS_IO_PORT_CONFLICT
//
// MessageText:
//
//  %2 : There is an I/O port conflict.
//
#define EVENT_NDIS_IO_PORT_CONFLICT      0x80001397L

//
// MessageId: EVENT_NDIS_PORT_OR_DMA_CONFLICT
//
// MessageText:
//
//  %2 : There is an I/O port or DMA channel conflict.
//
#define EVENT_NDIS_PORT_OR_DMA_CONFLICT  0x80001398L

//
// MessageId: EVENT_NDIS_MEMORY_CONFLICT
//
// MessageText:
//
//  %2 : There is a memory conflict at address 0x%3.
//
#define EVENT_NDIS_MEMORY_CONFLICT       0x80001399L

//
// MessageId: EVENT_NDIS_INTERRUPT_CONFLICT
//
// MessageText:
//
//  %2 : There is a interrupt conflict at interrupt number %3.
//
#define EVENT_NDIS_INTERRUPT_CONFLICT    0x8000139AL

//
// MessageId: EVENT_NDIS_DMA_CONFLICT
//
// MessageText:
//
//  %2 : There is a resource conflict at DMA channel %3.
//
#define EVENT_NDIS_DMA_CONFLICT          0x8000139BL

//
// MessageId: EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR
//
// MessageText:
//
//  %2 : The download file is invalid.  The driver is unable to load.
//
#define EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR 0xC000139CL

//
// MessageId: EVENT_NDIS_MAXRECEIVES_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxReceives is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXRECEIVES_ERROR     0x8000139DL

//
// MessageId: EVENT_NDIS_MAXTRANSMITS_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxTransmits is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXTRANSMITS_ERROR    0x8000139EL

//
// MessageId: EVENT_NDIS_MAXFRAMESIZE_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxFrameSize is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXFRAMESIZE_ERROR    0x8000139FL

//
// MessageId: EVENT_NDIS_MAXINTERNALBUFS_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxInternalBufs is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXINTERNALBUFS_ERROR 0x800013A0L

//
// MessageId: EVENT_NDIS_MAXMULTICAST_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry MaxMulticast is out of range.  Using
//  default value.
//
#define EVENT_NDIS_MAXMULTICAST_ERROR    0x800013A1L

//
// MessageId: EVENT_NDIS_PRODUCTID_ERROR
//
// MessageText:
//
//  %2 : The specified Registry entry ProductId is out of range.  Using
//  default value.
//
#define EVENT_NDIS_PRODUCTID_ERROR       0x800013A2L

//
// MessageId: EVENT_NDIS_LOBE_FAILUE_ERROR
//
// MessageText:
//
//  %2 : A Token Ring Lobe Wire Fault has occurred.  Verify cable
//  connections.  The adapter will continue to try to reinsert back
//  into the ring.
//
#define EVENT_NDIS_LOBE_FAILUE_ERROR     0x800013A3L

//
// MessageId: EVENT_NDIS_SIGNAL_LOSS_ERROR
//
// MessageText:
//
//  %2 : The adapter had detected a loss of signal on the ring.  The adapter
//  will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_SIGNAL_LOSS_ERROR     0x800013A4L

//
// MessageId: EVENT_NDIS_REMOVE_RECEIVED_ERROR
//
// MessageText:
//
//  %2 : The adapter has received a request to deinsert from the
//  ring.  The adapter will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_REMOVE_RECEIVED_ERROR 0x800013A5L

//
// MessageId: EVENT_NDIS_TOKEN_RING_CORRECTION
//
// MessageText:
//
//  %2 : The adapter has successfully reinserted back into the ring.
//
#define EVENT_NDIS_TOKEN_RING_CORRECTION 0x400013A6L

//
// MessageId: EVENT_NDIS_ADAPTER_CHECK_ERROR
//
// MessageText:
//
//  %2 : The adapter has detected an Adapter Check as a result of some
//  unrecoverable hardware of software error.  Please contact your service provider.
//
#define EVENT_NDIS_ADAPTER_CHECK_ERROR   0xC00013A7L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_ERROR
//
// MessageText:
//
//  %2 : The adapter failed to reset within a specified time.  The adapter will
//  continue to try to reset.  This could be the result of a hardware failure.
//
#define EVENT_NDIS_RESET_FAILURE_ERROR   0x800013A8L

//
// MessageId: EVENT_NDIS_CABLE_DISCONNECTED_ERROR
//
// MessageText:
//
//  %2 : The adapter has detected that the Token Ring cable is disconnected from
//  the adapter.  Please reconnect the Token Ring cable.  The adapter will continue
//  to try to reset until the connection is repaired.
//
#define EVENT_NDIS_CABLE_DISCONNECTED_ERROR 0x800013A9L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_CORRECTION
//
// MessageText:
//
//  %2 : The adapter has successfully completed a previously failed reset.
//
#define EVENT_NDIS_RESET_FAILURE_CORRECTION 0x800013AAL


/////////////////////////////////////////////////////////////////////////
//
// General NT System Events
//
/////////////////////////////////////////////////////////////////////////

//
// Eventlog Events 6000 - 6099
//
//
// MessageId: EVENT_LOG_FULL
//
// MessageText:
//
//  The %1 log file is full.
//
#define EVENT_LOG_FULL                   0x80001770L

//
// MessageId: EVENT_LogFileNotOpened
//
// MessageText:
//
//  The %1 log file cannot be opened.
//
#define EVENT_LogFileNotOpened           0x80001771L

//
// MessageId: EVENT_LogFileCorrupt
//
// MessageText:
//
//  The %1 log file is corrupted and will be cleared.
//
#define EVENT_LogFileCorrupt             0x80001772L

//
// MessageId: EVENT_DefaultLogCorrupt
//
// MessageText:
//
//  The Application log file could not be opened.  %1 will be used as the default
//  log file.
//
#define EVENT_DefaultLogCorrupt          0x80001773L

//
// MessageId: EVENT_BadDriverPacket
//
// MessageText:
//
//  A driver packet received from the I/O subsystem was invalid.  The data is the
//  packet.
//
#define EVENT_BadDriverPacket            0x80001774L

//
// MessageId: EVENT_EventlogStarted
//
// MessageText:
//
//  The Event log service was started.
//
#define EVENT_EventlogStarted            0x80001775L

//
// MessageId: EVENT_EventlogStopped
//
// MessageText:
//
//  The Event log service was stopped.
//
#define EVENT_EventlogStopped            0x80001776L

//
// MessageId: TITLE_EventlogMessageBox
//
// MessageText:
//
//  Eventlog Service %0
//
#define TITLE_EventlogMessageBox         0x80001777L

//
// MessageId: EVENT_EventlogAbnormalShutdown
//
// MessageText:
//
//  The previous system shutdown at %1 on %2 was unexpected.
//
#define EVENT_EventlogAbnormalShutdown   0x80001778L

//
// MessageId: EVENT_EventLogProductInfo
//
// MessageText:
//
//  Microsoft (R) Windows (R) %1 %2 %3 %4.
//
#define EVENT_EventLogProductInfo        0x80001779L

//
// MessageId: EVENT_ServiceNoEventLog
//
// MessageText:
//
//  The %1 service was unable to set up an event source.
//
#define EVENT_ServiceNoEventLog          0xC000177AL

//
// MessageId: EVENT_ComputerNameChange
//
// MessageText:
//
//  The NetBIOS name and DNS host name of this machine have been changed from %1 to %2.
//
#define EVENT_ComputerNameChange         0xC000177BL

//
// MessageId: EVENT_DNSDomainNameChange
//
// MessageText:
//
//  The DNS domain assigned to this computer has been changed from %1 to %2.
//
#define EVENT_DNSDomainNameChange        0xC000177CL

//
// System Events 6100 - 6199
//
//
// MessageId: EVENT_UP_DRIVER_ON_MP
//
// MessageText:
//
//  A uniprocessor-specific driver was loaded on a multiprocessor system.  The driver could not load.
//
#define EVENT_UP_DRIVER_ON_MP            0xC00017D4L

//
// Service Controller Events 7000 - 7899
//
//
// MessageId: EVENT_SERVICE_START_FAILED
//
// MessageText:
//
//  The %1 service failed to start due to the following error: %n%2
//
#define EVENT_SERVICE_START_FAILED       0xC0001B58L

//
// MessageId: EVENT_SERVICE_START_FAILED_II
//
// MessageText:
//
//  The %1 service depends on the %2 service which failed to start because of the following error: %n%3
//
#define EVENT_SERVICE_START_FAILED_II    0xC0001B59L

//
// MessageId: EVENT_SERVICE_START_FAILED_GROUP
//
// MessageText:
//
//  The %1 service depends on the %2 group and no member of this group started.
//
#define EVENT_SERVICE_START_FAILED_GROUP 0xC0001B5AL

//
// MessageId: EVENT_SERVICE_START_FAILED_NONE
//
// MessageText:
//
//  The %1 service depends on the following nonexistent service: %2
//
#define EVENT_SERVICE_START_FAILED_NONE  0xC0001B5BL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED
//
// MessageText:
//
//  The %1 call failed with the following error: %n%2
//
#define EVENT_CALL_TO_FUNCTION_FAILED    0xC0001B5DL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED_II
//
// MessageText:
//
//  The %1 call failed for %2 with the following error: %n%3
//
#define EVENT_CALL_TO_FUNCTION_FAILED_II 0xC0001B5EL

//
// MessageId: EVENT_REVERTED_TO_LASTKNOWNGOOD
//
// MessageText:
//
//  The system reverted to its last known good configuration.  The system is restarting....
//
#define EVENT_REVERTED_TO_LASTKNOWNGOOD  0xC0001B5FL

//
// MessageId: EVENT_BAD_ACCOUNT_NAME
//
// MessageText:
//
//  No backslash is in the account name.
//
#define EVENT_BAD_ACCOUNT_NAME           0xC0001B60L

//
// MessageId: EVENT_CONNECTION_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for the %2 service to connect.
//
#define EVENT_CONNECTION_TIMEOUT         0xC0001B61L

//
// MessageId: EVENT_READFILE_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for ReadFile.
//
#define EVENT_READFILE_TIMEOUT           0xC0001B62L

//
// MessageId: EVENT_TRANSACT_TIMEOUT
//
// MessageText:
//
//  Timeout (%1 milliseconds) waiting for a transaction response from the %2 service.
//
#define EVENT_TRANSACT_TIMEOUT           0xC0001B63L

//
// MessageId: EVENT_TRANSACT_INVALID
//
// MessageText:
//
//  Message returned in transaction has incorrect size.
//
#define EVENT_TRANSACT_INVALID           0xC0001B64L

//
// MessageId: EVENT_FIRST_LOGON_FAILED
//
// MessageText:
//
//  Logon attempt with current password failed with the following error: %n%1
//
#define EVENT_FIRST_LOGON_FAILED         0xC0001B65L

//
// MessageId: EVENT_SECOND_LOGON_FAILED
//
// MessageText:
//
//  Second logon attempt with old password also failed with the following error: %n%1
//
#define EVENT_SECOND_LOGON_FAILED        0xC0001B66L

//
// MessageId: EVENT_INVALID_DRIVER_DEPENDENCY
//
// MessageText:
//
//  Boot-start or system-start driver (%1) must not depend on a service.
//
#define EVENT_INVALID_DRIVER_DEPENDENCY  0xC0001B67L

//
// MessageId: EVENT_BAD_SERVICE_STATE
//
// MessageText:
//
//  The %1 service has reported an invalid current state %2.
//
#define EVENT_BAD_SERVICE_STATE          0xC0001B68L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_DEMAND
//
// MessageText:
//
//  Detected circular dependencies demand starting %1.
//
#define EVENT_CIRCULAR_DEPENDENCY_DEMAND 0xC0001B69L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_AUTO
//
// MessageText:
//
//  Detected circular dependencies auto-starting services.
//
#define EVENT_CIRCULAR_DEPENDENCY_AUTO   0xC0001B6AL

//
// MessageId: EVENT_DEPEND_ON_LATER_SERVICE
//
// MessageText:
//
//  Circular dependency: The %1 service depends on a service in a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_SERVICE    0xC0001B6BL

//
// MessageId: EVENT_DEPEND_ON_LATER_GROUP
//
// MessageText:
//
//  Circular dependency: The %1 service depends on a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_GROUP      0xC0001B6CL

//
// MessageId: EVENT_SEVERE_SERVICE_FAILED
//
// MessageText:
//
//  About to revert to the last known good configuration because the %1 service failed to start.
//
#define EVENT_SEVERE_SERVICE_FAILED      0xC0001B6DL

//
// MessageId: EVENT_SERVICE_START_HUNG
//
// MessageText:
//
//  The %1 service hung on starting.
//
#define EVENT_SERVICE_START_HUNG         0xC0001B6EL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED
//
// MessageText:
//
//  The %1 service terminated with the following error: %n%2
//
#define EVENT_SERVICE_EXIT_FAILED        0xC0001B6FL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED_SPECIFIC
//
// MessageText:
//
//  The %1 service terminated with service-specific error %2.
//
#define EVENT_SERVICE_EXIT_FAILED_SPECIFIC 0xC0001B70L

//
// MessageId: EVENT_SERVICE_START_AT_BOOT_FAILED
//
// MessageText:
//
//  At least one service or driver failed during system startup.  Use Event Viewer to examine the event log for details.
//
#define EVENT_SERVICE_START_AT_BOOT_FAILED 0xC0001B71L

//
// MessageId: EVENT_BOOT_SYSTEM_DRIVERS_FAILED
//
// MessageText:
//
//  The following boot-start or system-start driver(s) failed to load: %1
//
#define EVENT_BOOT_SYSTEM_DRIVERS_FAILED 0xC0001B72L

//
// MessageId: EVENT_RUNNING_LASTKNOWNGOOD
//
// MessageText:
//
//  Windows 2000 could not be started as configured.  A previous working configuration was used instead.
//
#define EVENT_RUNNING_LASTKNOWNGOOD      0xC0001B73L

//
// MessageId: EVENT_TAKE_OWNERSHIP
//
// MessageText:
//
//  The %1 Registry key denied access to SYSTEM account programs so the Service Control Manager took ownership of the Registry key.
//
#define EVENT_TAKE_OWNERSHIP             0xC0001B74L

//
// This Text is used as a title for the message box used to display
// MessageId 7027.  It is not an event or error message.
//
//
// MessageId: TITLE_SC_MESSAGE_BOX
//
// MessageText:
//
//  Service Control Manager %0
//
#define TITLE_SC_MESSAGE_BOX             0xC0001B75L

//
// MessageId: EVENT_SERVICE_NOT_INTERACTIVE
//
// MessageText:
//
//  The %1 service is marked as an interactive service.  However, the system is configured to not allow interactive services.  This service may not function properly.
//
#define EVENT_SERVICE_NOT_INTERACTIVE    0xC0001B76L

//
// Parameter %4 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %5.
//
//
// MessageId: EVENT_SERVICE_CRASH
//
// MessageText:
//
//  The %1 service terminated unexpectedly.  It has done this %2 time(s).  The following corrective action will be taken in %3 milliseconds: %5.
//
#define EVENT_SERVICE_CRASH              0xC0001B77L

//
// Parameter %1 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %2.
//
//
// MessageId: EVENT_SERVICE_RECOVERY_FAILED
//
// MessageText:
//
//  The Service Control Manager tried to take a corrective action (%2) after the unexpected termination of the %3 service, but this action failed with the following error: %n%4
//
#define EVENT_SERVICE_RECOVERY_FAILED    0xC0001B78L

//
// MessageId: EVENT_SERVICE_SCESRV_FAILED
//
// MessageText:
//
//  The Service Control Manager did not initialize successfully. The security
//  configuration server (scesrv.dll) failed to initialize with error %1.  The
//  system is restarting...
//
#define EVENT_SERVICE_SCESRV_FAILED      0xC0001B79L

//
// MessageId: EVENT_SERVICE_CRASH_NO_ACTION
//
// MessageText:
//
//  The %1 service terminated unexpectedly.  It has done this %2 time(s).
//
#define EVENT_SERVICE_CRASH_NO_ACTION    0xC0001B7AL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_CONTROL_SUCCESS
//
// MessageText:
//
//  The %1 service was successfully sent a %2 control.
//
#define EVENT_SERVICE_CONTROL_SUCCESS    0x40001B7BL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_STATUS_SUCCESS
//
// MessageText:
//
//  The %1 service entered the %2 state.
//
#define EVENT_SERVICE_STATUS_SUCCESS     0x40001B7CL

//
// MessageId: EVENT_SERVICE_CONFIG_BACKOUT_FAILED
//
// MessageText:
//
//  The Service Control Manager encountered an error undoing a configuration change
//  to the %1 service.  The service's %2 is currently in an unpredictable state.
//  
//  If you do not correct this configuration, you may not be able to restart the %1
//  service or may encounter other errors.  To ensure that the service is configured
//  properly, use the Services snap-in in Microsoft Management Console (MMC).
//
#define EVENT_SERVICE_CONFIG_BACKOUT_FAILED 0xC0001B7DL

//
// MessageId: EVENT_FIRST_LOGON_FAILED_II
//
// MessageText:
//
//  The %1 service was unable to log on as %2 with the currently configured
//  password due to the following error: %n%3%n%nTo ensure that the service is
//  configured properly, use the Services snap-in in Microsoft Management
//  Console (MMC).
//
#define EVENT_FIRST_LOGON_FAILED_II      0xC0001B7EL

//
// Schedule (AT command) Service Events 7900 - 7999
//
//
// MessageId: EVENT_COMMAND_NOT_INTERACTIVE
//
// MessageText:
//
//  The %1 command is marked as an interactive command.  However, the system is
//  configured to not allow interactive command execution.  This command may not
//  function properly.
//
#define EVENT_COMMAND_NOT_INTERACTIVE    0xC0001EDCL

//
// MessageId: EVENT_COMMAND_START_FAILED
//
// MessageText:
//
//  The %1 command failed to start due to the following error: %n%2
//
#define EVENT_COMMAND_START_FAILED       0xC0001EDDL


/////////////////////////////////////////////////////////////////////////
//
// Lanman Bowser/Browser Events (8000-8499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_BOWSER_OTHER_MASTER_ON_NET
//
// MessageText:
//
//  The master browser has received a server announcement from the computer %2
//  that believes that it is the master browser for the domain on transport %3.
//  The master browser is stopping or an election is being forced.
//
#define EVENT_BOWSER_OTHER_MASTER_ON_NET 0xC0001F43L

//
// MessageId: EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER
//
// MessageText:
//
//  A request has been submitted to promote the computer to backup when it is already a
//  master browser.
//
#define EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER 0x80001F44L

//
// MessageId: EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE
//
// MessageText:
//
//  The browser has received a server announcement indicating that the computer %2
//  is a master browser, but this computer is not a master browser.
//
#define EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE 0x80001F45L

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM
//
// MessageText:
//
//  The browser has received an illegal datagram from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM    0x80001F46L

//
// MessageId: EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED
//
// MessageText:
//
//  The browser was unable to update the service status bits.  The data is the error.
//
#define EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED 0xC0001F47L

//
// MessageId: EVENT_BROWSER_ROLE_CHANGE_FAILED
//
// MessageText:
//
//  The browser was unable to update its role.  The data is the error.
//
#define EVENT_BROWSER_ROLE_CHANGE_FAILED 0xC0001F48L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The computer that currently
//  believes it is the master browser is %1.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED 0xC0001F49L

//
// MessageId: EVENT_BOWSER_NAME_CONVERSION_FAILED
//
// MessageText:
//
//  The browser driver was unable to convert a character string to a unicode string.
//
#define EVENT_BOWSER_NAME_CONVERSION_FAILED 0xC0001F4AL

//
// MessageId: EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED
//
// MessageText:
//
//  The browser was unable to add the configuration parameter %1.
//
#define EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED 0xC0001F4BL

//
// MessageId: EVENT_BOWSER_ELECTION_RECEIVED
//
// MessageText:
//
//  The browser driver has received an election packet from computer %2 on network %3.  The data is the packet received.
//
#define EVENT_BOWSER_ELECTION_RECEIVED   0x00001F4CL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED
//
// MessageText:
//
//  The browser driver has forced an election on network %2 because it was unable to find a master browser to retrieve a backup list on that network.
//
#define EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED 0x40001F4DL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED
//
// MessageText:
//
//  The browser driver has forced an election on network %2 because it was unable to find a master browser for that network.
//
#define EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED 0x40001F4EL

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED
//
// MessageText:
//
//  The browser has forced an election on network %1 because a Windows 2000 Server (or domain master) browser is started.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED 0x40001F4FL

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD
//
// MessageText:
//
//  The browser driver has received too many illegal datagrams from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
//  No more events will be generated until the reset frequency has expired.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD 0xC0001F50L

//
// MessageId: EVENT_BROWSER_DEPENDANT_SERVICE_FAILED
//
// MessageText:
//
//  The browser has failed to start because the dependent service %1 had invalid service status %2.
//  Status             Meaning
//    1              Service Stopped%n
//    2              Start Pending%n
//    3              Stop Pending%n
//    4              Running%n
//    5              Continue Pending%n
//    6              Pause Pending%n
//    7              Paused%n
//
#define EVENT_BROWSER_DEPENDANT_SERVICE_FAILED 0xC0001F51L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The browser will continue
//  to attempt to promote itself to the master browser, but will no longer log any events in the event log in Event Viewer.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING 0xC0001F53L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER
//
// MessageText:
//
//  The browser was unable to promote itself to master browser.  The computer that currently
//  believes it is the master browser is unknown.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER 0xC0001F54L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_FAILED
//
// MessageText:
//
//  The browser was unable to retrieve a list of servers from the browser master %1 on the network %2.
//  The data is the error code.
//
#define EVENT_BROWSER_SERVER_LIST_FAILED 0x80001F55L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_FAILED
//
// MessageText:
//
//  The browser was unable to retrieve a list of domains from the browser master %1 on the network %2.
//  The data is the error code.
//
#define EVENT_BROWSER_DOMAIN_LIST_FAILED 0x80001F56L

//
// MessageId: EVENT_BROWSER_ILLEGAL_CONFIG
//
// MessageText:
//
//  The value for the parameter %1 to the browser service was illegal.
//
#define EVENT_BROWSER_ILLEGAL_CONFIG     0x80001F57L

//
// MessageId: EVENT_BOWSER_OLD_BACKUP_FOUND
//
// MessageText:
//
//  The backup browser server %2 is out-of-date.  Consider upgrading this computer.
//
#define EVENT_BOWSER_OLD_BACKUP_FOUND    0x40001F58L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_RETRIEVED
//
// MessageText:
//
//  The browser has retrieved a list of servers from remote computer %1 on transport %2.%n
//  There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_SERVER_LIST_RETRIEVED 0x00001F59L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_RETRIEVED
//
// MessageText:
//
//  The browser has retrieved a list of domains from remote computer %1 on transport %2.%n
//  There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_DOMAIN_LIST_RETRIEVED 0x00001F5AL

//
// MessageId: EVENT_BOWSER_PDC_LOST_ELECTION
//
// MessageText:
//
//  The browser running on the Domain Controller has lost an election.  The computer that won the election is %2, on the transport %3.%n
//  The data contains the election version, election criteria, and remote computer time up, and the same information for
//  the current computer.
//
#define EVENT_BOWSER_PDC_LOST_ELECTION   0x40001F5BL

//
// MessageId: EVENT_BOWSER_NON_PDC_WON_ELECTION
//
// MessageText:
//
//  The browser running on this computer has won a browser election on network %2.
//  This computer is a member of a domain, so the Domain Controller should become the master
//  browser.
//
#define EVENT_BOWSER_NON_PDC_WON_ELECTION 0x40001F5CL

//
// MessageId: EVENT_BOWSER_CANT_READ_REGISTRY
//
// MessageText:
//
//  The browser driver was unable to initialize variables from the Registry.
//
#define EVENT_BOWSER_CANT_READ_REGISTRY  0x40001F5DL

//
// MessageId: EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED
//
// MessageText:
//
//  The browser driver has discarded too many mailslot messages.
//
#define EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED 0x40001F5EL

//
// MessageId: EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED
//
// MessageText:
//
//  The browser driver has discarded too many GetBrowserServerList requests.
//
#define EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED 0x40001F5FL

//
// MessageId: EVENT_BROWSER_BACKUP_STOPPED
//
// MessageText:
//
//  The browser service has failed to retrieve the backup list too many times on transport %1.
//  The backup browser is stopping.
//
#define EVENT_BROWSER_BACKUP_STOPPED     0xC0001F60L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED
//
// MessageText:
//
//  The browser has forced an election on network %1 because a master browser was stopped.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED 0x40001F61L

//
// MessageId: EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER
//
// MessageText:
//
//  The browser has received a GetBrowserServerList request when it is not the master browser.
//
#define EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER 0xC0001F62L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED
//
// MessageText:
//
//  The browser has forced an election on network %1 because the Domain Controller (or Server) has changed its role.
//
#define EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED 0x40001F63L

//
// MessageId: EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH
//
// MessageText:
//
//  The browser has failed to start because of an error in the DirectHostBinding parameter to the browser.
//
#define EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH 0xC0001F64L


/////////////////////////////////////////////////////////////////////////
//
// Sap Agent Events (8500-8999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: NWSAP_EVENT_KEY_NOT_FOUND
//
// MessageText:
//
//  The Registry Key %1 was not present.  The Sap Agent could not start.
//
#define NWSAP_EVENT_KEY_NOT_FOUND        0xC0002134L

//
// MessageId: NWSAP_EVENT_WSASTARTUP_FAILED
//
// MessageText:
//
//  Winsock startup routine failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WSASTARTUP_FAILED    0xC0002135L

//
// MessageId: NWSAP_EVENT_SOCKET_FAILED
//
// MessageText:
//
//  Socket create call failed for main socket. The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SOCKET_FAILED        0xC0002136L

//
// MessageId: NWSAP_EVENT_SETOPTBCAST_FAILED
//
// MessageText:
//
//  Setting broadcast option on socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SETOPTBCAST_FAILED   0xC0002137L

//
// MessageId: NWSAP_EVENT_BIND_FAILED
//
// MessageText:
//
//  Binding to SAP Socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BIND_FAILED          0xC0002138L

//
// MessageId: NWSAP_EVENT_GETSOCKNAME_FAILED
//
// MessageText:
//
//  Getting bound address of socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_GETSOCKNAME_FAILED   0xC0002139L

//
// MessageId: NWSAP_EVENT_OPTEXTENDEDADDR_FAILED
//
// MessageText:
//
//  Setting option EXTENDED_ADDRESS failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTEXTENDEDADDR_FAILED 0xC000213AL

//
// MessageId: NWSAP_EVENT_OPTBCASTINADDR_FAILED
//
// MessageText:
//
//  Setting NWLink option BCASTINTADDR failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTBCASTINADDR_FAILED 0xC000213BL

//
// MessageId: NWSAP_EVENT_CARDMALLOC_FAILED
//
// MessageText:
//
//  Error allocating memory to hold a card structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDMALLOC_FAILED    0xC000213CL

//
// MessageId: NWSAP_EVENT_NOCARDS
//
// MessageText:
//
//  Enumeration of cards returned 0 cards.
//
#define NWSAP_EVENT_NOCARDS              0xC000213DL

//
// MessageId: NWSAP_EVENT_THREADEVENT_FAIL
//
// MessageText:
//
//  Error creating thread counting event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_THREADEVENT_FAIL     0xC000213EL

//
// MessageId: NWSAP_EVENT_RECVSEM_FAIL
//
// MessageText:
//
//  Error creating receive semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_RECVSEM_FAIL         0xC000213FL

//
// MessageId: NWSAP_EVENT_SENDEVENT_FAIL
//
// MessageText:
//
//  Error creating send event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SENDEVENT_FAIL       0xC0002140L

//
// MessageId: NWSAP_EVENT_STARTRECEIVE_ERROR
//
// MessageText:
//
//  Error starting receive thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTRECEIVE_ERROR   0xC0002141L

//
// MessageId: NWSAP_EVENT_STARTWORKER_ERROR
//
// MessageText:
//
//  Error starting worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWORKER_ERROR    0xC0002142L

//
// MessageId: NWSAP_EVENT_TABLE_MALLOC_FAILED
//
// MessageText:
//
//  Error allocating database array.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_TABLE_MALLOC_FAILED  0xC0002143L

//
// MessageId: NWSAP_EVENT_HASHTABLE_MALLOC_FAILED
//
// MessageText:
//
//  Error allocating hash table.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_HASHTABLE_MALLOC_FAILED 0xC0002144L

//
// MessageId: NWSAP_EVENT_STARTLPCWORKER_ERROR
//
// MessageText:
//
//  Error starting LPC worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTLPCWORKER_ERROR 0xC0002145L

//
// MessageId: NWSAP_EVENT_CREATELPCPORT_ERROR
//
// MessageText:
//
//  Error creating the LPC port.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCPORT_ERROR  0xC0002146L

//
// MessageId: NWSAP_EVENT_CREATELPCEVENT_ERROR
//
// MessageText:
//
//  Error creating the LPC thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCEVENT_ERROR 0xC0002147L

//
// MessageId: NWSAP_EVENT_LPCLISTENMEMORY_ERROR
//
// MessageText:
//
//  Error allocating memory for an LPC Client structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCLISTENMEMORY_ERROR 0xC0002148L

//
// MessageId: NWSAP_EVENT_LPCHANDLEMEMORY_ERROR
//
// MessageText:
//
//  Error allocating buffer to hold LPC worker thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCHANDLEMEMORY_ERROR 0xC0002149L

//
// MessageId: NWSAP_EVENT_BADWANFILTER_VALUE
//
// MessageText:
//
//  The value for WANFilter in the registry must be 0-2.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BADWANFILTER_VALUE   0xC000214AL

//
// MessageId: NWSAP_EVENT_CARDLISTEVENT_FAIL
//
// MessageText:
//
//  Error creating event for card list access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDLISTEVENT_FAIL   0xC000214BL

//
// MessageId: NWSAP_EVENT_SDMDEVENT_FAIL
//
// MessageText:
//
//  Error creating event for database access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SDMDEVENT_FAIL       0xC000214CL

//
// MessageId: NWSAP_EVENT_INVALID_FILTERNAME
//
// MessageText:
//
//  Name too long in key %1: Name = %s.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_INVALID_FILTERNAME   0x8000214DL

//
// MessageId: NWSAP_EVENT_WANSEM_FAIL
//
// MessageText:
//
//  Error creating WAN control semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSEM_FAIL          0xC000214EL

//
// MessageId: NWSAP_EVENT_WANSOCKET_FAILED
//
// MessageText:
//
//  Socket create call failed for WAN socket.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSOCKET_FAILED     0xC000214FL

//
// MessageId: NWSAP_EVENT_WANBIND_FAILED
//
// MessageText:
//
//  Binding to WAN socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANBIND_FAILED       0xC0002150L

//
// MessageId: NWSAP_EVENT_STARTWANWORKER_ERROR
//
// MessageText:
//
//  Error starting WAN worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANWORKER_ERROR 0xC0002151L

//
// MessageId: NWSAP_EVENT_STARTWANCHECK_ERROR
//
// MessageText:
//
//  Error starting WAN check thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANCHECK_ERROR  0xC0002152L

//
// MessageId: NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR
//
// MessageText:
//
//  Error on getsockopt IPX_MAX_ADAPTER_NUM.  Data is the error code.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR 0xC0002153L

//
// MessageId: NWSAP_EVENT_WANHANDLEMEMORY_ERROR
//
// MessageText:
//
//  Error allocating buffer to hold WAN notify thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANHANDLEMEMORY_ERROR 0xC0002154L

//
// MessageId: NWSAP_EVENT_WANEVENT_ERROR
//
// MessageText:
//
//  Error creating the WAN thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANEVENT_ERROR       0xC0002155L


/////////////////////////////////////////////////////////////////////////
//
// Transport Events (9000-9499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TRANSPORT_RESOURCE_POOL
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to system resource problems.
//
#define EVENT_TRANSPORT_RESOURCE_POOL    0x80002329L

//
// MessageId: EVENT_TRANSPORT_RESOURCE_LIMIT
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to its configured size of %4.
//
#define EVENT_TRANSPORT_RESOURCE_LIMIT   0x8000232AL

//
// MessageId: EVENT_TRANSPORT_RESOURCE_SPECIFIC
//
// MessageText:
//
//  %2 could not allocate a resource of type %3 due to a specifically configured limit of %4.
//
#define EVENT_TRANSPORT_RESOURCE_SPECIFIC 0x8000232BL

//
// MessageId: EVENT_TRANSPORT_REGISTER_FAILED
//
// MessageText:
//
//  %2 failed to register itself with the NDIS wrapper.
//
#define EVENT_TRANSPORT_REGISTER_FAILED  0xC000232CL

//
// MessageId: EVENT_TRANSPORT_BINDING_FAILED
//
// MessageText:
//
//  %2 failed to bind to adapter %3.
//
#define EVENT_TRANSPORT_BINDING_FAILED   0xC000232DL

//
// MessageId: EVENT_TRANSPORT_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  %2 could not find adapter %3.
//
#define EVENT_TRANSPORT_ADAPTER_NOT_FOUND 0xC000232EL

//
// MessageId: EVENT_TRANSPORT_SET_OID_FAILED
//
// MessageText:
//
//  %2 failed while setting OID %3 on adapter %4.
//
#define EVENT_TRANSPORT_SET_OID_FAILED   0xC000232FL

//
// MessageId: EVENT_TRANSPORT_QUERY_OID_FAILED
//
// MessageText:
//
//  %2 failed while querying OID %3 on adapter %4.
//
#define EVENT_TRANSPORT_QUERY_OID_FAILED 0xC0002330L

//
// MessageId: EVENT_TRANSPORT_TRANSFER_DATA
//
// MessageText:
//
//  %2 could not transfer a packet from the adapter.  The packet was dropped.
//
#define EVENT_TRANSPORT_TRANSFER_DATA    0x40002331L

//
// MessageId: EVENT_TRANSPORT_TOO_MANY_LINKS
//
// MessageText:
//
//  %2 could not create a link to a remote computer.  Your computer has exceeded the number of connections it can make to that remote computer.
//
#define EVENT_TRANSPORT_TOO_MANY_LINKS   0x40002332L

//
// MessageId: EVENT_TRANSPORT_BAD_PROTOCOL
//
// MessageText:
//
//  %2 received an unexpected %3 packet from a remote computer.
//
#define EVENT_TRANSPORT_BAD_PROTOCOL     0x40002333L


/////////////////////////////////////////////////////////////////////////
//
// IPX/SPX Events (9500-9999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_IPX_NEW_DEFAULT_TYPE
//
// MessageText:
//
//  The default frame type for auto-detection on %2 was changed to %3.
//  This type is now the default if no frame type can be detected.
//
#define EVENT_IPX_NEW_DEFAULT_TYPE       0x4000251DL

//
// MessageId: EVENT_IPX_SAP_ANNOUNCE
//
// MessageText:
//
//  A SAP announcement was sent over %2 which is configured for multiple
//  networks, but no internal network is configured. This may prevent
//  machines on some networks from locating the advertised service.
//
#define EVENT_IPX_SAP_ANNOUNCE           0x8000251EL

//
// MessageId: EVENT_IPX_ILLEGAL_CONFIG
//
// MessageText:
//
//  The value for the %2 parameter %3 was illegal.
//
#define EVENT_IPX_ILLEGAL_CONFIG         0x8000251FL

//
// MessageId: EVENT_IPX_INTERNAL_NET_INVALID
//
// MessageText:
//
//  %2 was configured with an internal network number of %3. This network
//  number conflicts with one of the attached networks. The configured
//  internal network number will be ignored.
//
#define EVENT_IPX_INTERNAL_NET_INVALID   0xC0002520L

//
// MessageId: EVENT_IPX_NO_FRAME_TYPES
//
// MessageText:
//
//  %2 had no frame types configured for the binding to adapter %3.
//
#define EVENT_IPX_NO_FRAME_TYPES         0xC0002521L

//
// MessageId: EVENT_IPX_CREATE_DEVICE
//
// MessageText:
//
//  %2 failed to initialize because the driver device could not be created.
//
#define EVENT_IPX_CREATE_DEVICE          0xC0002522L

//
// MessageId: EVENT_IPX_NO_ADAPTERS
//
// MessageText:
//
//  %2 could not bind to any adapters. The transport could not start.
//
#define EVENT_IPX_NO_ADAPTERS            0xC0002523L


/////////////////////////////////////////////////////////////////////////
//
// DCOM Events (10000-10999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RPCSS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  Unable to start a DCOM Server: %3.
//  The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_CREATEPROCESS_FAILURE 0xC0002710L

//
// MessageId: EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  Unable to start a DCOM Server: %3 as %4/%5.
//  The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE 0xC0002711L

//
// MessageId: EVENT_RPCSS_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
//  Access denied attempting to launch a DCOM Server.
//  The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_LAUNCH_ACCESS_DENIED 0xC0002712L

//
// MessageId: EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
//  Access denied attempting to launch a DCOM Server using DefaultLaunchPermssion.
//  The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED 0xC0002713L

//
// MessageId: EVENT_RPCSS_RUNAS_CANT_LOGIN
//
// MessageText:
//
//  DCOM got error "%%%1" and was unable to logon %2\%3
//  in order to run the server:%n%4
//
#define EVENT_RPCSS_RUNAS_CANT_LOGIN     0xC0002714L

//
// MessageId: EVENT_RPCSS_START_SERVICE_FAILURE
//
// MessageText:
//
//  DCOM got error "%%%1" attempting to start the service %2 with arguments "%3"
//  in order to run the server:%n%4
//
#define EVENT_RPCSS_START_SERVICE_FAILURE 0xC0002715L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR
//
// MessageText:
//
//  DCOM got error "%%%1" from the computer %2 when attempting to
//  activate the server:%n%3
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR    0xC0002716L

//
// MessageId: EVENT_RPCSS_ACTIVATION_ERROR
//
// MessageText:
//
//  DCOM got error "%%%1" when attempting to
//  activate the server:%n%2
//
#define EVENT_RPCSS_ACTIVATION_ERROR     0xC0002717L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE
//
// MessageText:
//
//  DCOM got error "%%%1" from the computer %2 when attempting to
//  the server:%n%3 with file %4.
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE 0xC0002718L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE
//
// MessageText:
//
//  DCOM was unable to communicate with the computer %1 using any of the configured
//  protocols.
//
#define EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE 0xC0002719L

//
// MessageId: EVENT_RPCSS_SERVER_START_TIMEOUT
//
// MessageText:
//
//  The server %1 did not register with DCOM within the required timeout.
//
#define EVENT_RPCSS_SERVER_START_TIMEOUT 0xC000271AL

//
// MessageId: EVENT_RPCSS_SERVER_NOT_RESPONDING
//
// MessageText:
//
//  The server %1 could not be contacted to establish the connection to the client
//
#define EVENT_RPCSS_SERVER_NOT_RESPONDING 0xC000271BL

//
// MessageId: EVENT_DCOM_ASSERTION_FAILURE
//
// MessageText:
//
//  There is an assertion failure in DCOM.  Context follows:
//  %1
//  %2
//  %3
//
#define EVENT_DCOM_ASSERTION_FAILURE     0xC000271CL

//
// MessageId: EVENT_DCOM_INVALID_ENDPOINT_DATA
//
// MessageText:
//
//  DCOM server attempted to listen on an invalid endpoint.
//  Protseq:  %1
//  Endpoint: %2
//  Flags:    %3
//
#define EVENT_DCOM_INVALID_ENDPOINT_DATA 0xC000271DL


/////////////////////////////////////////////////////////////////////////
//
// DNS Caching Resolvers Service and DNS API Events (11000-11999)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DLL
//
// MessageText:
//
//  Unable to start DNS Client Service.
//  Failed to load DLL %2, Error: %1.
//  Please reinstall this DLL from installation CD.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DLL 0xC0002AF8L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY
//
// MessageText:
//
//  Unable to start DNS Client service. Can not find entry %3 in DLL %2.
//  Please reinstall this DLL from installation CD. For specific error
//  code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY 0xC0002AF9L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL
//
// MessageText:
//
//  Unable to start the DNS Client service. The system could not register a
//  service control handler and could be out of resources. Close any
//  applications not in use or reboot the computer. For specific error
//  code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL 0xC0002AFAL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT
//
// MessageText:
//
//  Unable to start DNS Client service. The system could
//  not create a termination event for this service and
//  could be out of resources. Close any applications not
//  in use or reboot the computer. For specific error code,
//  see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT 0xC0002AFBL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_RPC
//
// MessageText:
//
//  Unable to start DNS Client service. Could not start the
//  Remote Procedure Call (RPC) interface for this service.
//  To correct the problem, you may restart the RPC and DNS
//  Client services. To do so, use the following commands at a command
//  prompt: (1) type "net start rpc" to start the RPC service, and (2)
//  type "net start dnscache" to start the DNS Client service. For
//  specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_RPC 0xC0002AFCL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY
//
// MessageText:
//
//  Unable to start DNS Client service. The system could not register
//  shutdown notification for this service and could be out of resources.
//  Try closing any applications not in use or reboot the computer.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY 0xC0002AFDL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE
//
// MessageText:
//
//  Unable to start DNS Client service. Could not update status with
//  Service Control Manager. To correct the problem, you may restart
//  the RPC and DNS Client services. To do so, use the following commands
//  at a command prompt: (1) type "net start rpc" to start the RPC service,
//  and (2) type "net start dnscache" to start the DNS Client service. For
//  specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE 0xC0002AFEL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY
//
// MessageText:
//
//  Unable to start DNS Client service because the system failed to allocate
//  memory and may be out of available memory. Try closing any applications not
//  in use or reboot the computer. For specific error code, see the record data
//  displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY 0xC0002AFFL


//
// Warnings
//

//
// MessageId: EVENT_DNS_CACHE_NETWORK_PERF_WARNING
//
// MessageText:
//
//  The DNS Client service could not contact any DNS servers for
//  a repeated number of attempts. For the next %3 seconds the
//  DNS Client service will not use the network to avoid further
//  network performance problems. It will resume its normal behavior
//  after that. If this problem persists, verify your TCP/IP
//  configuration, specifically check that you have a preferred
//  (and possibly an alternate) DNS server configured. If the problem
//  continues, verify network conditions to these DNS servers or contact
//  your network administrator.
//
#define EVENT_DNS_CACHE_NETWORK_PERF_WARNING 0x80002B2AL

//
// MessageId: EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING
//
// MessageText:
//
//  The DNS Client service failed to reach DNS server at address %1. It will
//  not use this DNS server for %2 seconds.
//
#define EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING 0x80002B2BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS Server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The cause of this DNS registration failure was because the DNS update
//  request timed out after being sent to the specified DNS Server. This is
//  probably because the authoritative DNS server for the name being updated
//  is not running.%n%n You can manually retry registration of the network
//  adapter and its settings by typing "ipconfig /registerdns" at the command
//  prompt. If problems still  persist, contact your network systems
//  administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT 0x80002B8EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The cause of this DNS registration failure was because of DNS server failure.
//  This may be due to a zone transfer that has locked the DNS server for the
//  applicable zone that your computer needs to register itself with.%n%n
//  (The applicable zone should typically correspond to the Adapter-specific
//  Domain Suffix that was indicated above.) You can manually retry registration
//  of the network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your network
//  systems administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL 0x80002B8FL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason it could not register was because either: (a) the DNS server
//  does not support the DNS dynamic update protocol, or (b) the primary zone
//  authoritative for the registering names does not currently accept dynamic
//  updates.%n%n To add or register a DNS host (A) resource record using the
//  specific DNS name for this adapter, contact your DNS server or network
//  systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP 0x80002B90L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason it could not register was because the DNS server refused the
//  dynamic update request. This could happen for the following reasons:
//  (a) current DNS update policies do not allow this computer to update
//  the DNS domain name configured for this adapter, or (b) the authoritative
//  DNS server for this DNS domain name does not support the DNS dynamic update
//  protocol.%n%n
//  To register a DNS host (A) resource record using the specific DNS domain
//  name for this adapter, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED 0x80002B91L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not register the DNS update request because of a
//  security related problem. This could happen for the following reasons:
//  (a) the DNS domain name that your computer is trying to register could
//  not be updated because your computer does not have the right permissions,
//  or (b) there might have been a problem negotiating valid credentials
//  with the DNS server to update.%n%n
//  You can manually retry DNS registration of the network adapter and its
//  settings by typing "ipconfig /registerdns" at the command prompt. If
//  problems still persist, contact your DNS server or network systems
//  administrator. For specific error code information, see the record data
//  displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY 0x80002B92L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to register network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the DNS update request could not be completed was because
//  of a system problem. You can manually retry DNS registration of the
//  network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your DNS
//  server or network systems administrator. For specific error code
//  information, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER 0x80002B93L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because the
//  update request that was sent to the specified DNS server timed out. This
//  is probably because the authoritative DNS server for the name being
//  registered is not running.%n%n You can manually retry DNS registration
//  of the network adapter and its settings by typing "ipconfig /registerdns"
//  at the command prompt. If problems still persist, contact your DNS
//  server or network systems administrator. For specific error code
//  information, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT 0x80002B94L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  of DNS server failure. This may be due to a zone transfer lock on
//  the DNS server for the zone that your computer needs to update.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator. For specific error code information, see the record data
//  displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL 0x80002B95L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  (a) either the DNS server does not support the DNS dynamic update
//  protocol, or (b) the authoritative zone where these records are to
//  be registered does not allow dynamic updates.%n%n
//  To register DNS pointer (PTR) resource records using the specific
//  DNS domain name and IP addresses for this adapter, contact your
//  DNS server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP 0x80002B96L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  the DNS server refused the update request. The cause of this could
//  be (a) your computer is not allowed to update the adapter-specified DNS
//  domain name, or (b) because the DNS server authoritative for the specified
//  name does not support the DNS dynamic update protocol.%n%n
//  To register the DNS pointer (PTR) resource records using the specific
//  DNS domain name and IP addresses for this adapter, contact your DNS
//  server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED 0x80002B97L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason that the system could not register these RRs was because
//  of a security related problem. The cause of this could be (a) your
//  computer does not have permissions to register and update the specific
//  DNS domain name set for this adapter, or (b) there might have been a
//  problem negotiating valid credentials with the DNS server during the
//  processing of the update request.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY 0x80002B98L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to register pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The reason the system could not register these RRs during the
//  update request was because of a system problem. You can manually
//  retry DNS registration of the network adapter and its settings by
//  typing "ipconfig /registerdns" at the command prompt. If problems
//  still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER 0x80002B99L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  update request it sent to the DNS server timed out. The most likely
//  cause of this is that the DNS server authoritative for the name it
//  was attempting to register or update is not running at this time.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002B9AL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  DNS server failed the update request. The most likely cause of this
//  is that the authoritative DNS server required to process this update
//  request has a lock in place on the zone, probably because a zone
//  transfer is in progress.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002B9BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because either
//  (a) the DNS server does not support the DNS dynamic update protocol, or
//  (b) the authoritative zone for the specified DNS domain name does not
//  accept dynamic updates.%n%n
//  To register the DNS host (A) resource records using the specific DNS
//  domain name and IP addresses for this adapter, contact your DNS server
//  or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002B9CL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because the
//  DNS server contacted refused the update request. The reasons for this
//  might be (a) you are not allowed to update the specified DNS domain name,
//  or (b) because the DNS server authoritative for this name does not support
//  the DNS dynamic update protocol.%n%n
//  To register the DNS host (A) resource records using the specific DNS
//  domain name and IP addresses for this adapter, contact your DNS server
//  or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002B9DL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs was because of a
//  security related problem. The cause of this could be (a) your computer
//  does not have permissions to register and update the specific DNS domain
//  name set for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request.%n%n
//  You can manually retry DNS registration of the network adapter and
//  its settings by typing "ipconfig /registerdns" at the command prompt.
//  If problems still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002B9EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
//  The system failed to register host (A) resource records (RRs) for
//  network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not register these RRs during the
//  update request was because of a system problem. You can manually
//  retry DNS registration of the network adapter and its settings by
//  typing "ipconfig /registerdns" at the command prompt. If problems
//  still persist, contact your DNS server or network systems
//  administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002B9FL


//
// Deregistration update errors
//

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to update and remove registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server it sent the update
//  request to timed out. The most likely cause of this failure is that the
//  DNS server authoritative for the zone where the registration was originally
//  made is either not running or unreachable through the network at this time.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT 0x80002BACL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to update and remove registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server it sent the update
//  to failed the update request. A possible cause of this failure is that
//  the DNS server required to process this update request has a lock in place
//  on the zone, probably because a zone transfer is in progress.%n%n
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BADL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server sent the update
//  either (a) does not support the DNS dynamic update protocol, or (b) the
//  authoritative zone for the specified DNS domain name does not currently
//  accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP 0x80002BAEL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not perform the update request was the
//  DNS server contacted refused update request. The cause of this is
//  (a) this computer is not allowed to update the specified DNS domain
//  name, or (b) because the DNS server authoritative for the zone that
//  requires updating does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED 0x80002BAFL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to update and remove registration for the network
//  adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the system could not perform the update request was because
//  of a security related problem. The cause of this could be (a) your computer
//  does not have permissions to register and update the specific DNS domain
//  name set for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request.%n%n
//  For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY 0x80002BB0L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to update and remove the DNS registration for the
//  network adapter with settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not update to remove this DNS registration because of
//  a system problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER 0x80002BB1L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the update request
//  timed out while awaiting a response from the DNS server. This is probably
//  because the DNS server authoritative for the zone that requires update
//  is not running.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT 0x80002BB2L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the DNS server failed the
//  update request. A possible cause is that a zone transfer is in progress,
//  causing a lock for the zone at the DNS server authorized to perform the
//  updates for these RRs.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BB3L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because either the DNS server
//  does not support the DNS dynamic update protocol or the authoritative zone
//  that contains these RRs does not accept dynamic updates.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP 0x80002BB4L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because the DNS server refused the
//  update request. The cause of this might be (a) this computer is not allowed
//  to update the specified DNS domain name specified by these settings, or
//  (b) because the DNS server authorized to perform updates for the zone that
//  contains these RRs does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED 0x80002BB5L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because of a security related
//  problem. The cause of this could be that (a) your computer does not have
//  permissions to remove and update the specific DNS domain name or IP addresses
//  configured for this adapter, or (b) there might have been a problem negotiating
//  valid credentials with the DNS server during the processing of the update
//  request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY 0x80002BB6L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
//  The system failed to update and remove pointer (PTR) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address : %6%n%n
//  The system could not remove these PTR RRs because because of a system
//  problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER 0x80002BB7L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not remove these A RRs because the update request timed
//  out while awaiting a response from the DNS server. This is probably because
//  the DNS server authoritative for the zone where these RRs need to be updated
//  is either not currently running or reachable on the network.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002BB8L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The system could not remove these A RRs because the DNS server failed the
//  update request. A possible cause is that a zone transfer is in progress,
//  causing a lock for the zone at the DNS server authorized to perform the
//  updates for these RRs.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002BB9L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure is because the DNS server sent the update
//  either (a) does not support the DNS dynamic update protocol, or (b) the
//  authoritative zone for the DNS domain name specified in these A RRs does
//  not currently accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002BBAL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The request to remove these records failed because the DNS server refused
//  the update request. The cause of this might be that either (a) this
//  computer is not allowed to update the DNS domain name specified by these
//  settings, or (b) because the DNS server authorized to perform updates for
//  the zone that contains these RRs does not support the DNS dynamic update
//  protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002BBBL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason for this failure was because of a security related problem.
//  The cause of this could be that (a) your computer does not have permissions
//  to remove and update the specific DNS domain name or IP addresses
//  configured for this adapter, or (b) there might have been a problem
//  negotiating valid credentials with the DNS server during the processing of
//  the update request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002BBCL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
//  The system failed to update and remove host (A) resource records (RRs)
//  for network adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6%n%n
//  The reason the update request failed was because of a system problem.
//  For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002BBDL


//
// Information
//

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER
//
// MessageText:
//
//  The system registered network adapter with settings :%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER  0x40002BC0L

//
// MessageId: EVENT_DNSAPI_REGISTERED_PTR
//
// MessageText:
//
//  The system registered pointer (PTR) resource records (RRs) for network
//  adapter%nwith settings:%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Adapter-specific Domain Suffix : %3%n
//    Primary Domain Suffix : %4%n
//    DNS server list :%n
//      %5%n
//    Sent update to server : %6%n
//    IP Address : %7
//
#define EVENT_DNSAPI_REGISTERED_PTR      0x40002BC1L

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN
//
// MessageText:
//
//  The system registered host (A) resource records (RRs) for network
//  adapter%nwith settings :%n%n
//    Adapter Name : %1%n
//    Host Name : %2%n
//    Primary Domain Suffix : %3%n
//    DNS server list :%n
//      %4%n
//    Sent update to server : %5%n
//    IP Address(es) :%n
//      %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN 0x40002BC2L


/////////////////////////////////////////////////////////////////////////
//
// WMI Service Events (12000-12499)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_WMI_CANT_OPEN_DEVICE
//
// MessageText:
//
//  The WMI service was unable to open the WMI service device. The status code is in the additional data.
//
#define EVENT_WMI_CANT_OPEN_DEVICE       0xC0002EE0L


//
// Warnings
//

//
// MessageId: EVENT_WMI_INVALID_MOF
//
// MessageText:
//
//  The binary MOF in the resource named %1 in the image file %2 is not valid.
//
#define EVENT_WMI_INVALID_MOF            0x80002F44L

//
// MessageId: EVENT_WMI_MOF_LOAD_FAILURE
//
// MessageText:
//
//  The binary MOF in the resource named %1 in the image file %2 could not be loaded.
//
#define EVENT_WMI_MOF_LOAD_FAILURE       0x80002F45L

//
// MessageId: EVENT_WMI_INVALID_REGINFO
//
// MessageText:
//
//  The registration information for the image file %1 is not valid.
//
#define EVENT_WMI_INVALID_REGINFO        0x80002F46L

//
// MessageId: EVENT_WMI_INVALID_REGPATH
//
// MessageText:
//
//  The registry path (%1) passed by a kernel mode driver is invalid. The driver device object is in the additional data.
//
#define EVENT_WMI_INVALID_REGPATH        0x80002F47L

//
// MessageId: EVENT_WMI_CANT_RESOLVE_INSTANCE
//
// MessageText:
//
//  An event was fired specifying a static instance name that could not be resolved.
//
#define EVENT_WMI_CANT_RESOLVE_INSTANCE  0x80002F48L

//
// MessageId: EVENT_WMI_CANT_GET_EVENT_DATA
//
// MessageText:
//
//  An error occured while attempting to query for the event data referenced by a fired event.
//
#define EVENT_WMI_CANT_GET_EVENT_DATA    0x80002F49L


/////////////////////////////////////////////////////////////////////////
//
// Trk Services Events (12500-12999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_TRK_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occured in Distributed Link Tracking.  The error code was %1.
//
#define EVENT_TRK_INTERNAL_ERROR         0xC00030D4L

//
// MessageId: EVENT_TRK_SERVICE_START_SUCCESS
//
// MessageText:
//
//  Service started successfully
//
#define EVENT_TRK_SERVICE_START_SUCCESS  0x400030D5L

//
// MessageId: EVENT_TRK_SERVICE_START_FAILURE
//
// MessageText:
//
//  Service failed to start.  Error = %1
//
#define EVENT_TRK_SERVICE_START_FAILURE  0xC00030D6L

//
// MessageId: EVENT_TRK_SERVICE_CORRUPT_LOG
//
// MessageText:
//
//  The Distributed Link Tracking log was corrupt on volume %1: and has been re-created.  This log is used to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_CORRUPT_LOG    0xC00030D7L

//
// MessageId: EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED
//
// MessageText:
//
//  The Distributed Link Tracking volume ID quota on this machine has been exceeded.  As a result, it is not possible to create new volume IDs.  Distributed Link Tracking normally uses these volume IDs to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED 0x800030D8L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CREATE
//
// MessageText:
//
//  A new volume ID has been assigned for %1:%n%2%n%n
//  This ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  If there previously were links to files on this volume that are broken, they might not be automatically repairable.
//
#define EVENT_TRK_SERVICE_VOLUME_CREATE  0x400030D9L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CLAIM
//
// MessageText:
//
//  Ownership of the volume ID for %1: has been successfully claimed.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOLUME_CLAIM   0x400030DAL

//
// MessageId: EVENT_TRK_SERVICE_DUPLICATE_VOLIDS
//
// MessageText:
//
//  The volume ID for %1: has been reset, since it was a duplicate of that on %2:.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_DUPLICATE_VOLIDS 0x400030DBL

//
// MessageId: EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The move table quota for Distributed Link Tracking in this domain has been exceeded.  This table is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  While this quota is exceeded, it may not be possible to automatically repair some such broken links.
//
#define EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED 0x800030DCL


/////////////////////////////////////////////////////////////////////////
//
// ATM Protocol Events (13000-13499)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service does not support the version (1.0) supported by this LAN Emulation Client.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP 0xC000332CL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service does not support the version (1.0) supported by this LAN Emulation Client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP 0xC000332DL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The configuration parameters are incompatible with the desired Emulated LAN.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL 0xC000332EL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The join parameters are incompatible with the desired Emulated LAN.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL 0xC000332FL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. This LAN Emulation client attempted to register a MAC address (%3) that is already in use by another client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST 0xC0003330L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. This LAN Emulation client attempted to register an ATM address (%3) that is already in use by another client.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR 0xC0003331L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service does not have sufficient resources to process the request.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES 0xC0003332L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service does not have sufficient resources to process the request.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES 0xC0003333L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation Service disallowed this request for security reasons.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS 0xC0003334L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The LAN Emulation Service disallowed this request for security reasons.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS 0xC0003335L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied LAN Emulation Client ID is invalid.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL 0xC0003336L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied LAN Emulation Client ID is invalid.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL 0xC0003337L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied MAC Address (%3) cannot be a multicast address or, on an Ethernet/802.3 Emulated LAN, a Route Descriptor.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL 0xC0003338L

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied MAC Address (%3) cannot be a multicast address or, on an Ethernet/802.3 Emulated LAN, a Route Descriptor.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL 0xC0003339L

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The supplied ATM Address (%3) is not in a recognizable format.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL 0xC000333AL

//
// MessageId: EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Join Request failed. The supplied ATM Address (%3) is not in a recognizable format.
//
#define EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL 0xC000333BL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_NOCONF
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation client is not recognized.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_NOCONF 0xC000333CL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. No other information is available.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR 0xC000333DL

//
// MessageId: EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO
//
// MessageText:
//
//  Emulated LAN (%2) - LAN Emulation Configure Request failed. The LAN Emulation client has not provided sufficient information to allow assignment to an Emulated LAN.
//
#define EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO 0xC000333EL

//
// MessageId: EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
//  The Local ATM address (%2) can not be used because it is already registered by another node in the network.
//
#define EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS 0xC0003390L


/////////////////////////////////////////////////////////////////////////
//
// File Replication Service (NtFrs) Events (13500-13999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_FRS_ERROR
//
// MessageText:
//
//  File Replication Service
//
#define EVENT_FRS_ERROR                  0xC00034BCL

//
// MessageId: EVENT_FRS_STARTING
//
// MessageText:
//
//  The File Replication Service is starting.
//
#define EVENT_FRS_STARTING               0x400034BDL

//
// MessageId: EVENT_FRS_STOPPING
//
// MessageText:
//
//  The File Replication Service is stopping.
//
#define EVENT_FRS_STOPPING               0x400034BEL

//
// MessageId: EVENT_FRS_STOPPED
//
// MessageText:
//
//  The File Replication Service has stopped.
//
#define EVENT_FRS_STOPPED                0x400034BFL

//
// MessageId: EVENT_FRS_STOPPED_FORCE
//
// MessageText:
//
//  The File Replication Service stopped without cleaning up.
//
#define EVENT_FRS_STOPPED_FORCE          0xC00034C0L

//
// MessageId: EVENT_FRS_STOPPED_ASSERT
//
// MessageText:
//
//  The File Replication Service has stopped after taking an assertion failure.
//
#define EVENT_FRS_STOPPED_ASSERT         0xC00034C1L

//
// MessageId: EVENT_FRS_ASSERT
//
// MessageText:
//
//  The File Replication Service failed a consistency check
//  %n  (%3)
//  %nin "%1" at line %2.
//  %n
//  %nThe File Replication Service will restart automatically at a later time.
//  If this problem persists a subsequent entry in this event log describes the
//  recovery procedure.
//  %n
//  For more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services,
//  File Replication Service, and Recovery.
//
#define EVENT_FRS_ASSERT                 0xC00034C2L

//
// MessageId: EVENT_FRS_VOLUME_NOT_SUPPORTED
//
// MessageText:
//
//  The File Replication Service cannot start replica set %1 on computer %2
//  for directory %3 because the type of volume %4 is not NTFS 5.0 or later.
//  %n
//  %nThe volume's type can be found by typing "chkdsk %4".
//  %n
//  %nThe volume can be upgraded to NTFS 5.0 or later by typing "chkntfs /E %4".
//
#define EVENT_FRS_VOLUME_NOT_SUPPORTED   0xC00034C3L

//
// MessageId: EVENT_FRS_LONG_JOIN
//
// MessageText:
//
//  The File Replication Service is having trouble enabling replication
//  from %1 to %2 for %3 using the DNS name %4. FRS will keep retrying.
//  %n Following are some of the reasons you would see this warning.
//  %n
//  %n [1] FRS can not correctly resolve the DNS name %4 from this computer.
//  %n [2] FRS is not running on %4.
//  %n [3] The topology information in the Active Directory for this replica has not
//  yet replicated to all the Domain Controllers.
//  %n
//  %n This event log message will appear once per connection, After the problem
//  is fixed you will see another event log message indicating that the connection
//  has been established.
//
#define EVENT_FRS_LONG_JOIN              0x800034C4L

//
// MessageId: EVENT_FRS_LONG_JOIN_DONE
//
// MessageText:
//
//  The File Replication Service has enabled replication from %1 to %2 for %3
//  after repeated retries.
//
#define EVENT_FRS_LONG_JOIN_DONE         0x800034C5L

//
// MessageId: EVENT_FRS_CANNOT_COMMUNICATE
//
// MessageText:
//
//  The File Replication Service on the computer %1 cannot communicate with
//  the File Replication Service on the computer %2.
//  %n
//  %nVerify that the computer %2 is up and running.
//  %n
//  %nVerify that the File Replication Service is running on %2 by
//  typing "net start ntfrs" on %2.
//  %n
//  %nVerify that the network is functioning between %1 and %2 by
//  typing "ping %1" on %2 and "ping %2" on %1.
//  If the pings succeed then retry the failed operation.
//  If the pings fail then there may be problems with the DNS server.
//  %n
//  %nThe DNS server is responsible for mapping computer names to IP addresses.
//  The commands "ipconfig" and "nslookup" help diagnose problems with the
//  DNS server.
//  %n
//  %nTyping "ipconfig /all" will list the computer's IP address and the IP
//  address of the computer's DNS servers. Type "ping <DNS server's IP address>"
//  to verify that a DNS server is available. The DNS mapping for %2 or %1
//  can be verified by typing "nslookup" and then typing "%2" and then "%1"
//  on %1 and %2. Be sure to check out the DNS server on both %1 and %2;
//  a DNS problem on either computer will prevent proper communication.
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by flushing
//  the DNS Resolver Cache. Type "ipconfig /flushdns".
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by renewing
//  the IP address. Type "ipconfig /release" followed by "ipconfig /renew".
//  %n
//  %nSome network problems between %1 and %2 can be cleared up by resetting
//  the computer's DNS entry. Type "net stop NetLogon" followed by
//  "net start NetLogon".
//  %n
//  %nSome problems between %1 and %2 can be cleared up by restarting
//  the File Replication Service. Type "net stop ntfrs" followed by
//  "net start ntfrs".
//  %n
//  %nSome problems between %1 and %2 can be cleared up by restarting
//  the computers %1 and %2 AFTER CLOSING RUNNING APPLIATIONS,
//  especially dcpromo. Click on Start, Shutdown, select Restart, and
//  click on OK.
//  %n
//  %nOther network and computer problems are beyond the scope of
//  this event log message.
//
#define EVENT_FRS_CANNOT_COMMUNICATE     0xC00034C6L

//
// MessageId: EVENT_FRS_DATABASE_SPACE
//
// MessageText:
//
//  The File Replication Service is stopping on computer %1 because there is no free
//  space on the volume containing %2.
//  %n
//  %nThe available space on the volume can be found by typing
//  "dir %2".
//  %n
//  %nOnce free space is made available on the volume containing %2,
//  the File Replication Service can be restarted immediately by typing
//  "net start ntfrs". Otherwise, the File Replication Service will
//  restart automatically at a later time.
//  %n
//  %nFor more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services, File
//  Replication Service, and Recovery.
//  %n
//  %nFor more information about managing space on a volume type "copy /?",
//  "rename /?", "del /?", "rmdir /?", and "dir /?".
//
#define EVENT_FRS_DATABASE_SPACE         0xC00034C7L

//
// MessageId: EVENT_FRS_DISK_WRITE_CACHE_ENABLED
//
// MessageText:
//
//  The File Replication Service has detected an enabled disk write cache
//  on the drive containing the directory %2 on the computer %1.
//  The File Replication Service might not recover when power to the
//  drive is interrupted and critical updates are lost.
//
#define EVENT_FRS_DISK_WRITE_CACHE_ENABLED 0x800034C8L

//
// MessageId: EVENT_FRS_JET_1414
//
// MessageText:
//
//  The File Replication Service on computer %1 is stopping because the
//  database %2 is corrupted.
//  %n
//  %nThe database can be recovered by typing "esentutl /d %2 /l%3 /s%4".
//  %n
//  %nOnce the database has been successfully recovered the
//  File Replication Service can be restarted by typing "net start ntfrs".
//
#define EVENT_FRS_JET_1414               0xC00034C9L

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY
//
// MessageText:
//
//  The File Replication Service may be preventing the computer %1 from becoming a
//  domain controller while the system volume is being initialized with data
//  from another domain controller and then shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share. The File Replication
//  Service has stopped preventing the computer from becoming a domain
//  controller once the SYSVOL share appears.
//  %n
//  %nThe initialization of the system volume can take some time.
//  The time is dependent on the amount of data in the system volume,
//  the availability of other domain controllers, and the replication
//  interval between domain controllers.
//
#define EVENT_FRS_SYSVOL_NOT_READY       0x800034CAL

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY_PRIMARY
//
// MessageText:
//
//  The File Replication Service may be preventing the computer %1 from becoming a
//  domain controller while the system volume is being initialized and then
//  shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share. The File Replication
//  Service has stopped preventing the computer from becoming a domain
//  controller once the SYSVOL share appears.
//  %n
//  %nThe initialization of the system volume can take some time.
//  The time is dependent on the amount of data in the system volume.
//  %n
//  %nThe initialization of the system volume can be bypassed by first typing
//  regedt32 and setting the value of SysvolReady to 1 and then restarting
//  the Netlogon service.
//  %n
//  %nWARNING - BYPASSING THE SYSTEM VOLUME INITIALIZATION IS NOT RECOMMENDED.
//  Applications may fail in unexpected ways.
//  %n
//  %nThe value SysvolReady is located by clicking on HKEY_LOCAL_MACHINE
//  and then clicking on System, CurrentControlSet, Services, Netlogon,
//  and Parameters.
//  %n
//  %nThe Netlogon service can be restarted by typing "net stop netlogon"
//  followed by "net start netlogon".
//
#define EVENT_FRS_SYSVOL_NOT_READY_PRIMARY 0x800034CBL

//
// MessageId: EVENT_FRS_SYSVOL_READY
//
// MessageText:
//
//  The File Replication Service is no longer preventing the computer %1 from
//  becoming a domain controller. The system volume has been successfully
//  initialized and the Netlogon service has been notified that the system
//  volume is now ready to be shared as SYSVOL.
//  %n
//  %nType "net share" to check for the SYSVOL share.
//
#define EVENT_FRS_SYSVOL_READY           0x400034CCL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_DISABLED
//
// MessageText:
//
//  The File Replication Service will not check access to the API "%1".
//  %n
//  %nAccess checks can be enabled for "%1" by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
//  Change the string to Enabled.
//  %n
//  %nPermissions can be changed by highlighting "%1" and then clicking on the
//  toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_DISABLED 0x800034CDL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_USER
//
// MessageText:
//
//  The File Replication Service did not grant the user "%3" access to the
//  API "%1".
//  %n
//  %nPermissions for "%1" can be changed by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, and highlight "%1".
//  Click on the toolbar option Security and then Permissions...
//  %n
//  %nAccess checks can be disabled for "%1". Double click on "%2" and
//  change the string to Disabled.
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_USER 0x800034CEL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN
//
// MessageText:
//
//  The File Replication Service could not grant an unknown user access to the
//  API "%1".
//  %n
//  %nAccess checks can be disabled for "%1" by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
//  Change the string to Disabled.
//  %n
//  %nPermissions can be changed by highlighting "%1" and then clicking on the
//  toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN 0xC00034CFL

//
// MessageId: EVENT_FRS_MOVED_PREEXISTING
//
// MessageText:
//
//  The File Replication Service moved the preexisting files in %1 to %2.
//  %n
//  %nThe File Replication Service may delete the files in %2 at any time.
//  Files can be saved from deletion by copying them out of %2. Copying
//  the files into %1 may lead to name conflicts if the files already exist
//  on some other replicating partner.
//  %n
//  %nIn some cases, the File Replication Service may copy a file
//  from %2 into %1 instead of replicating the file from some other
//  replicating partner.
//  %n
//  %nSpace can be recovered at any time by deleting the files in %2.
//
#define EVENT_FRS_MOVED_PREEXISTING      0x800034D0L

//
// MessageId: EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS
//
// MessageText:
//
//  The File Replication Service cannot enable replication on the comptuer %1
//  until a backup/restore application completes.
//  %n
//  %nA backup/restore application has set a registry key that
//  prevents the File Replication Service from starting until the registry
//  key is deleted or the system is rebooted.
//  %n
//  %nThe backup/restore application may still be running. Check with your
//  local administrator before proceeding further.
//  %n
//  %nThe computer can be rebooted by clicking on Start, Shutdown, and
//  selecting Restart.
//  %n
//  %nWARNING - DELETING THE REGISTRY KEY IS NOT RECOMMENDED!
//  Applications may fail in unexpected ways.
//  %n
//  %nThe registry key can be deleted by running regedt32.
//  %n
//  %nClick on Start, Run, and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, Backup/Restore,
//  "Stop NtFrs from Starting". On the toolbar, click on Edit and select
//  Delete. Be careful! Deleting a key other than "Stop NtFrs From Starting"
//  can have unexpected sideeffects.
//
#define EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS 0xC00034D1L

//
// MessageId: EVENT_FRS_STAGING_AREA_FULL
//
// MessageText:
//
//  The File Replication Service paused because the staging area is full.
//  Replication will resume if staging space becomes available or if the
//  staging space limit is increased.
//  %n
//  %nThe current value of the staging space limit is %1 KB.
//  %n
//  %nTo change the staging space limit, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, and the value
//  "Staging Space Limit in KB".
//
#define EVENT_FRS_STAGING_AREA_FULL      0x800034D2L

//
// MessageId: EVENT_FRS_HUGE_FILE
//
// MessageText:
//
//  The File Replication Service paused because the size of a file exceeds the
//  staging space limit. Replication will resume only if the staging space limit
//  is increased.
//  %n
//  %nThe staging space limit is %1 KB and the file size is %2 KB.
//  %n
//  %nTo change the staging space limit, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
//  CurrentControlSet, Services, NtFrs, Parameters, and the value
//  "Staging Space Limit in KB".
//
#define EVENT_FRS_HUGE_FILE              0x800034D3L

//
// MessageId: EVENT_FRS_CANNOT_CREATE_UUID
//
// MessageText:
//
//  The File Replication Service is stopping on the computer %1 because
//  a universally unique ID (UUID) cannot be created.
//  %n
//  %nThe SDK function UuidCreate() returned the error "%2".
//  %n
//  %nThe problem may be the lack of an Ethernet address,
//  token ring address, or network address. The lack of a network
//  address implies an unsupported netcard.
//  %n
//  %nThe File Replication Service will restart automatically at a later time.
//  For more information about the automatic restart right click on
//  My Computer and then click on Manage, System Tools, Services,
//  File Replication Service, and Recovery.
//
#define EVENT_FRS_CANNOT_CREATE_UUID     0xC00034D4L

//
// MessageId: EVENT_FRS_NO_DNS_ATTRIBUTE
//
// MessageText:
//
//  The File Replication Service cannot find the DNS name for the computer %1
//  because the "%2" attribute could not be read from the distinguished
//  name "%3".
//  %n
//  %nThe File Replication Service will try using the name "%1" until the
//  computer's DNS name appears.
//
#define EVENT_FRS_NO_DNS_ATTRIBUTE       0x800034D5L

//
// MessageId: EVENT_FRS_NO_SID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 with the computer
//  %2 because the computer's SID cannot be determined from the distinguished
//  name "%3".
//  %n
//  %nThe File Replication Service will retry later.
//
#define EVENT_FRS_NO_SID                 0xC00034D6L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET
//
// MessageText:
//
//  The RPC binding failed in the Open function of the FileReplicaSet Object. The
//  counter data for this object will not be available. The FileReplicaSet object
//  contains the performance counters of the Replica sets whose files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET 0xC00034D7L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
//  The RPC binding failed in the Open function of the FileReplicaConn Object. The
//  counter data for this object will not be available. The FileReplicaConn object
//  contains the performance counters of the connections over which files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN 0xC00034D8L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_SET
//
// MessageText:
//
//  The RPC call failed in the Open function of the FileReplicaSet Object. The
//  counter data for this object will not be available. The FileReplicaSet object
//  contains the performance counters of the Replica sets whose files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_SET 0xC00034D9L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN
//
// MessageText:
//
//  The RPC call failed in the Open function of the FileReplicaConn Object. The
//  counter data for this object will not be available. The FileReplicaConn object
//  contains the performance counters of the connections over which files are being
//  replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN 0xC00034DAL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET
//
// MessageText:
//
//  The RPC binding failed in the Collect function of the FileReplicaSet Object. The
//  counter data for this object will not be available till the binding succeeds.
//  The FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET 0xC00034DBL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
//  The RPC binding failed in the Collect function of the FileReplicaConn Object.
//  The counter data for this object will not be available till the binding
//  succeeds. The FileReplicaConn object contains the performance counters of the
//  connections over which files are being replicated by the File Replication
//  Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN 0xC00034DCL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET
//
// MessageText:
//
//  The RPC call failed in the Collect function of the FileReplicaSet Object. The
//  counter data for this object will not be available till the call succeeds. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET 0xC00034DDL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN
//
// MessageText:
//
//  The RPC call failed in the Collect function of the FileReplicaConn Object. The
//  counter data for this object will not be available till the call succeeds. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN 0xC00034DEL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_SET
//
// MessageText:
//
//  The call to VirtualAlloc failed in the Open function of the FileReplicaSet
//  Object. The counter data for this object will not be available. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_SET  0xC00034DFL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_CONN
//
// MessageText:
//
//  The call to VirtualAlloc failed in the Open function of the FileReplicaConn
//  Object. The counter data for this object will not be available. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_CONN 0xC00034E0L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_SET
//
// MessageText:
//
//  The call to the Registry failed in the Open function of the FileReplicaSet
//  Object. The counter data for this object will not be available. The
//  FileReplicaSet object contains the performance counters of the Replica sets
//  whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_SET      0xC00034E1L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_CONN
//
// MessageText:
//
//  The call to the Registry failed in the Open function of the FileReplicaConn
//  Object. The counter data for this object will not be available. The
//  FileReplicaConn object contains the performance counters of the connections over
//  which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_CONN     0xC00034E2L

//
// MessageId: EVENT_FRS_ROOT_NOT_VALID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because the
//  pathname of the replicated directory is not the fully qualified
//  pathname of an existing, accessible local directory.
//
#define EVENT_FRS_ROOT_NOT_VALID         0xC00034E3L

//
// MessageId: EVENT_FRS_STAGE_NOT_VALID
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because the pathname
//  of the customer designated staging directory:
//  %n    %2
//  %n is not the fully qualified pathname of an existing, accessible local directory.
//
#define EVENT_FRS_STAGE_NOT_VALID        0xC00034E4L

//
// MessageId: EVENT_FRS_OVERLAPS_LOGGING
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the File Replication Service's logging pathname %2.
//
#define EVENT_FRS_OVERLAPS_LOGGING       0xC00034E5L

//
// MessageId: EVENT_FRS_OVERLAPS_WORKING
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the File Replication Service's working directory %2.
//
#define EVENT_FRS_OVERLAPS_WORKING       0xC00034E6L

//
// MessageId: EVENT_FRS_OVERLAPS_STAGE
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the staging directory %2.
//
#define EVENT_FRS_OVERLAPS_STAGE         0xC00034E7L

//
// MessageId: EVENT_FRS_OVERLAPS_ROOT
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the replicating directory %2.
//
#define EVENT_FRS_OVERLAPS_ROOT          0xC00034E8L

//
// MessageId: EVENT_FRS_OVERLAPS_OTHER_STAGE
//
// MessageText:
//
//  The File Replication Service cannot replicate %1 because it overlaps
//  the staging directory %2 of the replicating directory %3.
//
#define EVENT_FRS_OVERLAPS_OTHER_STAGE   0xC00034E9L

//
// MessageId: EVENT_FRS_PREPARE_ROOT_FAILED
//
// MessageText:
//
//  The File Replication Service could not prepare the root directory
//  %1 for replication.  This is likely due to a problem creating the
//  root directory or a problem removing preexisting files in the root
//  directory.
//  %n
//  %nCheck that the path leading up to the root directory exists and is
//  accessible.
//
#define EVENT_FRS_PREPARE_ROOT_FAILED    0xC00034EAL

//
// MessageId: EVENT_FRS_BAD_REG_DATA
//
// MessageText:
//
//  The File Replication Service detected an invalid parameter value in the
//  registry.  %1.
//  %n
//  %nThe expected registry key name is "%2".
//  %nThe expected value name is "%3".
//  %nThe expected registry data type is %4.
//  %nThe allowed range for this parameter is %5
//  %nThe data units for this parameter value are %6.
//  %nThe File Replication Service is using a default value of "%7".
//  %n
//  %nTo change this parameter, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE.
//  %nClick down the key path: "%8"
//  %nDouble click on the value name -
//  %n    "%9"
//  %nand update the value.
//  %nIf the value name is not present you may add it with the Add Value function
//  under the Edit Menu item. Type the value name exactly as shown above using the
//  above registry data type.  Make sure you observe the data units and allowed range
//  when entering the value.
//
#define EVENT_FRS_BAD_REG_DATA           0x800034EBL

//
// MessageId: EVENT_FRS_JOIN_FAIL_TIME_SKEW
//
// MessageText:
//
//  The File Replication Service is unable to replicate with its partner computer
//  because the difference in clock times is outside the range of plus or minus
//  %1 minutes.
//  %n
//  %nThe connection to the partner computer is:
//  %n  "%2"
//  %nThe detected time difference is:  %3 minutes.
//  %n
//  %nNote: If this time difference is close to a multiple of 60 minutes then it
//  is likely that either this computer or its partner computer was set to the
//  incorrect time zone when the computer time was initially set.  Check that
//  the time zone and the system time are correctly set on both computers.
//  %n
//  %nIf necessary, the default value used to test for computer time consistency
//  may be changed in the registry on this computer.  (Note: This is not recommended.)
//  %n
//  %nTo change this parameter, run regedt32.
//  %n
//  %nClick on Start, Run and type regedt32.
//  %n
//  %nClick on the window entitled HKEY_LOCAL_MACHINE.
//  %nClick down the key path:
//  %n   "System\CurrentControlSet\Services\NtFrs\Parameters"
//  %nDouble click on the value name
//  %n   "Partner Clock Skew In Minutes"
//  %nand update the value.
//  %n
//  %nIf the value name is not present you may add it with the Add Value function
//  under the Edit Menu item. Type the value name exactly as shown above using the
//  the registry data type REG_DWORD.
//
#define EVENT_FRS_JOIN_FAIL_TIME_SKEW    0xC00034ECL

//
// MessageId: EVENT_FRS_RMTCO_TIME_SKEW
//
// MessageText:
//
//  The File Replication Service is unable to replicate from a partner computer
//  because the event time associated with the file to be replicated is too far
//  into the future.  It is %1 minutes greater than the current time.  This can
//  happen if the system time on the partner computer was set incorrectly when
//  the file was created or updated.  To preserve the integrity of the replica
//  set this file update will not be performed or propagated further.
//  %n
//  %nThe file name is: "%2"
//  %nThe connection to the partner computer is:
//  %n  "%3"
//  %n
//  %nNote: If this time difference is close to a multiple of 60 minutes then it
//  is likely that this file may have been created or updated on the partner
//  computer while the computer was set to the incorrect time zone when its
//  computer time was initially set.  Check that the timezone and time are
//  correctly set on the partner computer.
//
#define EVENT_FRS_RMTCO_TIME_SKEW        0xC00034EDL

//
// MessageId: EVENT_FRS_CANT_OPEN_STAGE
//
// MessageText:
//
//  The File Replication Service is unable to open the customer designated
//  staging directory for replica set %1.  The path used for the staging
//  directory is,
//  %n    "%2"
//  %nThe customer designated root path for this replica set is:
//  %n    "%3"
//  %n
//  The service is unable to start replication on this replica set.  Among the
//  possible errors to check are:
//  %n  --  an invalid staging path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support ACLs,
//  %n  --  a sharing conflict on the staging directory with some other application.
//  %n
//  %nCorrect the problem and the service will attempt to restart replication
//  automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_STAGE        0xC00034EEL

//
// MessageId: EVENT_FRS_CANT_OPEN_PREINSTALL
//
// MessageText:
//
//  The File Replication Service is unable to open (or create) the pre-install
//  directory under the customer designated replica tree directory for
//  replica set %1.  The path used for the pre-install
//  directory is,
//  %n    "%2"
//  %nThe customer designated root path for this replica set is:
//  %n    "%3"
//  %n
//  The service is unable to start replication on this replica set.  Among the
//  possible errors to check are:
//  %n  --  an invalid root path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support NTFS 5.0
//  %n  --  a sharing conflict on the pre-install directory with some other application.
//  %n
//  %nCorrect the problem and the service will attempt to restart replication
//  automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_PREINSTALL   0xC00034EFL

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_FAIL
//
// MessageText:
//
//  The File Replication Service is unable to add this computer to the following
//  replica set:
//  %n    "%1"
//  %n
//  %nThis could be caused by a number of problems such as:
//  %n  --  an invalid root path,
//  %n  --  a missing directory,
//  %n  --  a missing disk volume,
//  %n  --  a file system on the volume that does not support NTFS 5.0
//  %n
//  %nThe information below may help to resolve the problem:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nReplica set root path is "%4"
//  %nReplica staging directory path is "%5"
//  %nReplica working directory path is "%6"
//  %nWindows error status code is %7
//  %nFRS error status code is %8
//  %n
//  %nOther event log messages may also help determine the problem.  Correct the
//  problem and the service will attempt to restart replication automatically at
//  a later time.
//
#define EVENT_FRS_REPLICA_SET_CREATE_FAIL 0xC00034F0L

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_OK
//
// MessageText:
//
//  The File Replication Service successfully added this computer to the following
//  replica set:
//  %n    "%1"
//  %n
//  %nInformation related to this event is shown below:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nReplica set root path is "%4"
//  %nReplica staging directory path is "%5"
//  %nReplica working directory path is "%6"
//
#define EVENT_FRS_REPLICA_SET_CREATE_OK  0x400034F1L

//
// MessageId: EVENT_FRS_REPLICA_SET_CXTIONS
//
// MessageText:
//
//  The File Replication Service successfully added the connections shown below
//  to the replica set:
//  %n    "%1"
//  %n
//  %n    %2
//  %n    %3
//  %n    %4
//  %n    %5
//  %n    %6
//  %n    %7
//  %n    %8
//  %n    %9
//  %n
//  %nMore information may appear in subsequent event log messages.
//
#define EVENT_FRS_REPLICA_SET_CXTIONS    0x400034F2L

//
// MessageId: EVENT_FRS_IN_ERROR_STATE
//
// MessageText:
//
//  The File Replication Service is in an error state. Files will not replicate
//  to or from one or all of the replica sets on his computer until the
//  following recovery steps are performed:
//  %n
//  %n Recovery Steps:
//  %n
//  %n [1] The error state may clear itself if you stop and restart the FRS service.
//  This can be done by performing the following in a command window:
//  %n
//  %n    net stop ntfrs
//  %n    net start ntfrs
//  %n
//  %nIf this fails to clear up the problem then proceed as follows.
//  %n
//  %n [2] For Active Directory Domain Controllers that DO NOT host any DFS
//  alternates or other replica sets with replication enabled:
//  %n
//  %nIf there is at least one other Domain Controller in this domain then
//  restore the "system state" of this DC from backup (using ntbackup or other
//  backup-restore utility) and make it non-authoritative.
//  %n
//  %nIf there are NO other Domain Controllers in this domain then restore
//  the "system state" of this DC from backup (using ntbackup or other
//  backup-restore utility) and choose the Advanced option which marks
//  the sysvols as primary.
//  %n
//  %nIf there are other Domain Controllers in this domain but ALL of
//  them have this event log message then restore one of them as primary
//  (data files from primary will replicate everywhere) and the others as
//  non-authoritative.
//  %n
//  %n
//  %n [3] For Active Directory Domain Controllers that host DFS alternates
//  or other replica sets with replication enabled:
//  %n
//  %n (3-a) If the Dfs alternates on this DC do not have any other replication
//  partners then copy the data under that Dfs share to a safe location.
//  %n (3-b) If this server is the only Active Directory Domain Controller for this
//  domain then, before going to (3-c),  make sure this server does not have any
//  inbound or outbound connections to other servers that were formerly Domain
//  Controllers for this domain but are now off the net (and will never be
//  coming back online) or have been fresh installed without being demoted.
//  To delete connections use the Sites and Services snapin and look for
//  %nSites->NAME_OF_SITE->Servers->NAME_OF_SERVER->NTDS Settings->CONNECTIONS.
//  %n (3-c) Restore the "system state" of this DC from backup (using ntbackup
//  or other backup-restore utility) and make it non-authoritative.
//  %n (3-d) Copy the data from step (3-a) above to the original location
//  after the sysvol share is published.
//  %n
//  %n
//  %n [4] For other Windows 2000 servers:
//  %n
//  %n (4-a)  If any of the DFS alternates or other replica sets hosted by
//  this server do not have any other replication partners then copy the
//  data under its share or replica tree root to a safe location.
//  %n (4-b)  net stop ntfrs
//  %n (4-c)  rd /s /q  %1
//  %n (4-d)  net start ntfrs
//  %n (4-e)  Copy the data from step (4-a) above to the original location after
//  the service has initialized (5 minutes is a safe waiting time).
//  %n
//  %nNote: If this error message is in the eventlog of all the members of a
//  particular replica set then perform steps (4-a) and (4-e) above on only
//  one of the members.
//
#define EVENT_FRS_IN_ERROR_STATE         0xC00034F3L

//
// MessageId: EVENT_FRS_REPLICA_NO_ROOT_CHANGE
//
// MessageText:
//
//  The File Replication Service has detected what appears to be an attempt
//  to change the root path for the following replica set:
//  %n    "%1"
//  %n
//  %nThis is not allowed.  To perform this operation you must remove this member
//  from the replica set and add the member back with the new root path.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must delete and re-add this member to the replica set.
//  %n
//  %nInformation related to this event is shown below:
//  %nComputer DNS name is "%2"
//  %nReplica set member name is "%3"
//  %nThe current Replica set root path is "%4"
//  %nThe desired new Replica set root path is "%5"
//  %nReplica staging directory path is "%6"
//
#define EVENT_FRS_REPLICA_NO_ROOT_CHANGE 0xC00034F4L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL
//
// MessageText:
//
//  The File Replication Service has detected a duplicate connection object between
//  this computer "%6" and a computer named "%1".
//  %nThis was detected for the following replica set:
//  %n    "%2"
//  %n
//  %nThis is not allowed and replication will not occur between these two
//  computers until the duplicate connection objects are removed.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must manually delete the duplicate connection objects by
//  following the steps below:
//  %n
//  %n [1] Start the Active Directory Sites and Services Snapin.
//  %n [2] Click on "%3, %4, %5, %6, %7".
//  %n [3] Look for duplicate connections from "%1" in site "%8".
//  %n [4] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL 0xC00034F5L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION
//
// MessageText:
//
//  The File Replication Service has detected a duplicate connection object between
//  this computer "%7" and a computer named "%1".
//  %nThis was detected for the following replica set:
//  %n    "%2"
//  %n
//  %nThis is not allowed and replication will not occur between these two
//  computers until the duplicate connection objects are removed.
//  %n
//  %nIt is possible that this is a transient error due to Active Directory
//  replication delays associated with updating FRS configuration objects.  If
//  file replication does not take place after an appropriate waiting time,
//  which could be several hours if cross site Active Directory replication
//  is required, you must manually delete the duplicate connection objects by
//  following the steps below:
//  %n
//  %n [1] Start the Active Directory Users and Computers Snapin.
//  %n [2] Click the view button and advanced features to display the system node.
//  %n [3] Click on "%3, %4, %5".
//  %n [4] Under "%5" you will see one or more DFS related replica set objects.
//  Look for the FRS member object "%6" under the subtree for replica set "%2".
//  %n [5] Under "%6" look for duplicate connections from "%1".
//  %n [6] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION    0xC00034F6L

//
// MessageId: EVENT_FRS_ROOT_HAS_MOVED
//
// MessageText:
//
//  The File Replication Service has detected that the replica root path has changed
//  from "%2" to "%3". If this is an intentional move then a file with the name
//  NTFRS_CMD_FILE_MOVE_ROOT needs to be created under the new root path.
//  %nThis was detected for the following replica set:
//  %n    "%1"
//  %n
//  %nChanging the replica root path is a two step process which is triggered by
//  the creation of the NTFRS_CMD_FILE_MOVE_ROOT file.
//  %n
//  %n [1] At the first poll which will occur in %4 minutes this computer will be
//  deleted from the replica set.
//  %n [2] At the poll following the deletion this computer will be re-added to the
//  replica set with the new root path. This re-addition will trigger a full tree
//  sync for the replica set. At the end of the sync all the files will be at the new
//  location. The files may or may not be deleted from the old location depending on whether
//  they are needed or not.
//
#define EVENT_FRS_ROOT_HAS_MOVED         0xC00034F7L

//
// MessageId: EVENT_FRS_ERROR_REPLICA_SET_DELETED
//
// MessageText:
//
//  The File Replication Service is deleting this computer from the replica set "%1" as an attempt to
//  recover from the error state,
//  %n Error status = %2
//  %n At the next poll, which will occur in %3 minutes, this computer will be re-added to the
//  replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_ERROR_REPLICA_SET_DELETED 0x800034F8L

//
// MessageId: EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR
//
// MessageText:
//
//  The File Replication Service has detected that the replica set "%1" is in JRNL_WRAP_ERROR.
//  %n
//  %n Replica set name is    : "%1"
//  %n Replica root path is   : "%2"
//  %n Replica root volume is : "%3"
//  %n
//  
//  A Replica set hits JRNL_WRAP_ERROR when the record that it is trying to read from the NTFS USN journal is not found.
//  This can occur because of one of the following reasons.
//  %n
//  %n [1] Volume "%3" has been formatted.
//  %n [2] The NTFS USN journal on volume "%3" has been deleted.
//  %n [3] The NTFS USN journal on volume "%3" has been truncated. Chkdsk can truncate
//  the journal if it finds corrupt entries at the end of the journal.
//  %n [4] File Replication Service was not running on this computer for a long time.
//  %n [5] File Replication Service could not keep up with the rate of Disk IO activity on "%3".
//  %n
//  %n Following recovery steps will be taken to automatically recover from this error state.
//  %n [1] At the first poll which will occur in %4 minutes this computer will be
//  deleted from the replica set.
//  %n [2] At the poll following the deletion this computer will be re-added to the
//  replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR 0xC00034F9L

//
// MessageId: EVENT_FRS_DS_POLL_ERROR_SUMMARY
//
// MessageText:
//
//  Following is the summary of warnings and errors encountered by File Replication Service
//  while polling the Domain Controller %1 for FRS replica set configuration information.
//  %n
//  %n %2
//  %n
//
#define EVENT_FRS_DS_POLL_ERROR_SUMMARY  0x800034FAL

/////////////////////////////////////////////////////////////////////////
//
// PSCHED Events
//
// Codes 14000 - 14299
//
/////////////////////////////////////////////////////////////////////////
//
// Driver wide events (14000 - 14099)
//
//
// MessageId: EVENT_PS_GPC_REGISTER_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register with the Generic Packet Classifier (msgpc.sys).
//
#define EVENT_PS_GPC_REGISTER_FAILED     0xC00036B0L

//
// MessageId: EVENT_PS_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
//  QoS: The Packet Scheduler was unable to allocate required resources for initialization.
//
#define EVENT_PS_NO_RESOURCES_FOR_INIT   0xC00036B1L

//
// MessageId: EVENT_PS_REGISTER_PROTOCOL_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register as a protocol with NDIS.
//
#define EVENT_PS_REGISTER_PROTOCOL_FAILED 0xC00036B2L

//
// MessageId: EVENT_PS_REGISTER_MINIPORT_FAILED
//
// MessageText:
//
//  QoS: The Packet Scheduler failed to register as a miniport with NDIS.
//
#define EVENT_PS_REGISTER_MINIPORT_FAILED 0xC00036B3L

//
// Adapter events (14100 - 14199)
//
//
// MessageId: EVENT_PS_BAD_BESTEFFORT_LIMIT
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe BestEffortLimit value set in the registry exceeds the LinkSpeed. Defaulting to Unlimited BestEffort.
//
#define EVENT_PS_BAD_BESTEFFORT_LIMIT    0x80003714L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_MAXIMUM_FRAME_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE 0xC0003715L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_MAXIMUM_TOTAL_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE 0xC0003716L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_LINK_SPEED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe netcard driver failed the query for OID_GEN_LINK_SPEED.
//
#define EVENT_PS_QUERY_OID_GEN_LINK_SPEED 0xC0003717L

//
// MessageId: EVENT_PS_BINDING_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler failed to bind to the netcard's miniport driver.
//
#define EVENT_PS_BINDING_FAILED          0xC0003718L

//
// MessageId: EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe UpperBindings key is missing from the registry.
//
#define EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA 0xC0003719L

//
// MessageId: EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler was unable to register with the NDISWAN Call Manager.
//
#define EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED 0xC000371AL

//
// MessageId: EVENT_PS_INIT_DEVICE_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler could not initialize the virtual miniport with NDIS.
//
#define EVENT_PS_INIT_DEVICE_FAILED      0xC000371BL

//
// MessageId: EVENT_PS_WMI_INSTANCE_NAME_FAILED
//
// MessageText:
//
//  QoS [Adapter %2]:%nThe Packet Scheduler could not obtain the adapter's friendly name from NDIS.
//
#define EVENT_PS_WMI_INSTANCE_NAME_FAILED 0xC000371CL

//
// MessageId: EVENT_PS_WAN_LIMITED_BESTEFFORT
//
// MessageText:
//
//  Qos [Adapter %2]:%nThe registry entry for BestEffortLimit is not supported over WAN links. Defaulting to Unlimited BestEffort mode.
//
#define EVENT_PS_WAN_LIMITED_BESTEFFORT  0x8000371DL

//
// MessageId: EVENT_PS_RESOURCE_POOL
//
// MessageText:
//
//  QoS [Adapter %2]:%nCould not initialize due to insufficient nonpaged pool memory.
//
#define EVENT_PS_RESOURCE_POOL           0xC000371EL

//
// MessageId: EVENT_PS_ADMISSIONCONTROL_OVERFLOW
//
// MessageText:
//
//  QoS [Adapter %2]:%nTotal bandwidth allocated to flows exceeds the NonBestEffortLimit. This is because of a reduction in the LinkSpeed or because of a change to the NonBestEffortLimit registry key.
//
#define EVENT_PS_ADMISSIONCONTROL_OVERFLOW 0x8000371FL

//
// MessageId: EVENT_PS_NETWORK_ADDRESS_FAIL
//
// MessageText:
//
//  QoS [Adapter %2]:%nCould not allocate non paged pool memory for storing Network Addresses.
//
#define EVENT_PS_NETWORK_ADDRESS_FAIL    0xC0003720L


/////////////////////////////////////////////////////////////////////////
//
// Distributed File System (Dfs) Events (14300-14599)
//
/////////////////////////////////////////////////////////////////////////

//
// Server-side (dfs.sys) errors (14300-14399)
//
//
// MessageId: EXTRA_EXIT_POINT
//
// MessageText:
//
//  An extra ExitPoint %2 was found at server %3
//
#define EXTRA_EXIT_POINT                 0xC00037DCL

//
// MessageId: MISSING_EXIT_POINT
//
// MessageText:
//
//  The ExitPoint %2 was missing at server %3
//
#define MISSING_EXIT_POINT               0xC00037DDL

//
// MessageId: MISSING_VOLUME
//
// MessageText:
//
//  The Volume %2 was missing at server %3
//
#define MISSING_VOLUME                   0xC00037DEL

//
// MessageId: EXTRA_VOLUME
//
// MessageText:
//
//  The extra Volume %2 was found at server %3
//
#define EXTRA_VOLUME                     0xC00037DFL

//
// MessageId: EXTRA_EXIT_POINT_DELETED
//
// MessageText:
//
//  The extra ExitPoint %2 was deleted successfully from the server %3
//
#define EXTRA_EXIT_POINT_DELETED         0xC00037E0L

//
// MessageId: EXTRA_EXIT_POINT_NOT_DELETED
//
// MessageText:
//
//  Unable to delete the extra ExitPoint %2 at the server %3
//
#define EXTRA_EXIT_POINT_NOT_DELETED     0xC00037E1L

//
// MessageId: MISSING_EXIT_POINT_CREATED
//
// MessageText:
//
//  The missing ExitPoint %2 was created at the server %3 successfully
//
#define MISSING_EXIT_POINT_CREATED       0xC00037E2L

//
// MessageId: MISSING_EXIT_POINT_NOT_CREATED
//
// MessageText:
//
//  Unable to create the missing Exit Point %2 at the server %3
//
#define MISSING_EXIT_POINT_NOT_CREATED   0xC00037E3L

//
// MessageId: MISSING_VOLUME_CREATED
//
// MessageText:
//
//  Successfully created the missing volume %2 knowledge at the server %3
//
#define MISSING_VOLUME_CREATED           0xC00037E4L

//
// MessageId: MISSING_VOLUME_NOT_CREATED
//
// MessageText:
//
//  Unable to create the missing Volume %2 info at server %3
//
#define MISSING_VOLUME_NOT_CREATED       0xC00037E5L

//
// MessageId: EXTRA_VOLUME_DELETED
//
// MessageText:
//
//  The extra Volume %2 info was deleted at server %3
//
#define EXTRA_VOLUME_DELETED             0xC00037E6L

//
// MessageId: EXTRA_VOLUME_NOT_DELETED
//
// MessageText:
//
//  The extra Volume %2 info was not deleted at server %3
//
#define EXTRA_VOLUME_NOT_DELETED         0xC00037E7L

//
// MessageId: COULD_NOT_VERIFY_VOLUMES
//
// MessageText:
//
//  Since the DC %2 was unavailable could not verify volumes knowledge.
//
#define COULD_NOT_VERIFY_VOLUMES         0xC00037E8L

//
// MessageId: KNOWLEDGE_INCONSISTENCY_DETECTED
//
// MessageText:
//
//  Detected Knowledge inconsistency with the volume %2 at server %3
//
#define KNOWLEDGE_INCONSISTENCY_DETECTED 0xC00037E9L

//
// MessageId: PREFIX_MISMATCH
//
// MessageText:
//
//  The local Prefix %2 was represented as %3 at remote server %4
//
#define PREFIX_MISMATCH                  0xC00037EAL

//
// MessageId: PREFIX_MISMATCH_FIXED
//
// MessageText:
//
//  The remote Prefix %3 was corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_FIXED            0xC00037EBL

//
// MessageId: PREFIX_MISMATCH_NOT_FIXED
//
// MessageText:
//
//  The remote Prefix %3 was NOT corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_NOT_FIXED        0xC00037ECL

//
// MessageId: MACHINE_UNJOINED
//
// MessageText:
//
//  The machine %2 has become unlinked from the domain. Re-join the machine the machine to this domain.
//
#define MACHINE_UNJOINED                 0xC00037EDL

//
// MessageId: DFS_REFERRAL_REQUEST
//
// MessageText:
//
//  Dfs received a referral request for "%2".  The return code is in the data.
//
#define DFS_REFERRAL_REQUEST             0x400037EEL

//
// Client-side Dfs (mup.sys) errors (14400-14499)
//
//
// MessageId: NOT_A_DFS_PATH
//
// MessageText:
//
//  The path "%2" is not a dfs path
//
#define NOT_A_DFS_PATH                   0x40003840L

//
// MessageId: LM_REDIR_FAILURE
//
// MessageText:
//
//  Dfs was unable to open the Lan Redir
//
#define LM_REDIR_FAILURE                 0x40003841L

//
// MessageId: DFS_CONNECTION_FAILURE
//
// MessageText:
//
//  Dfs was unable to open a connection to server %2.  The error returned is in the record data.
//
#define DFS_CONNECTION_FAILURE           0x40003842L

//
// MessageId: DFS_REFERRAL_FAILURE
//
// MessageText:
//
//  Dfs was unable to obtain a referral for "%2" from %3.  The error returned is in the record data.
//
#define DFS_REFERRAL_FAILURE             0x40003843L

//
// MessageId: DFS_REFERRAL_SUCCESS
//
// MessageText:
//
//  Dfs obtained a referral for "%2" from %3
//
#define DFS_REFERRAL_SUCCESS             0x40003844L

//
// MessageId: DFS_MAX_DNR_ATTEMPTS
//
// MessageText:
//
//  Dfs reached its limit of attempts of resolution of "%2".
//
#define DFS_MAX_DNR_ATTEMPTS             0x40003845L

//
// MessageId: DFS_SPECIAL_REFERRAL_FAILURE
//
// MessageText:
//
//  Dfs was unable to obtain the special referral table from %2.  The error returned is in the record data.
//
#define DFS_SPECIAL_REFERRAL_FAILURE     0x40003846L

//
// MessageId: DFS_OPEN_FAILURE
//
// MessageText:
//
//  Dfs failed on open of %2 directed to %3.  The error returned is in the record data.
//
#define DFS_OPEN_FAILURE                 0x40003847L

//
// Dfs service (dfssvc) errors (14500-14599)
//
//
// MessageId: NET_DFS_ENUM
//
// MessageText:
//
//  NetrDfsEnum received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUM                     0x400038A4L

//
// MessageId: NET_DFS_ENUMEX
//
// MessageText:
//
//  NetrDfsEnumEx received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUMEX                   0x400038A5L

//
// MessageId: DFS_ERROR_CREATE_DIRECTORY_FAILURE
//
// MessageText:
//
//  Dfs could not create directory %1.  The return code is in the record data.
//
#define DFS_ERROR_CREATE_DIRECTORY_FAILURE 0xC00038A6L

//
// MessageId: DFS_ERROR_CREATE_REPARSEPOINT_FAILURE
//
// MessageText:
//
//  Dfs could not create reparse point for share %1 mapped to directory %2. The return code is in the record data.
//
#define DFS_ERROR_CREATE_REPARSEPOINT_FAILURE 0xC00038A7L

//
// MessageId: DFS_ERROR_UNSUPPORTED_FILESYSTEM
//
// MessageText:
//
//  Share %1 mapped to %2 does not support reparse points. Upgrade Filesystem and retry.
//
#define DFS_ERROR_UNSUPPORTED_FILESYSTEM 0xC00038A8L

//
// MessageId: DFS_ERROR_OVERLAPPING_DIRECTORIES
//
// MessageText:
//
//  Share %1 mapped to %2 directory overlaps an existing root. The DFS Root will not be created. The return code is in the record data.
//
#define DFS_ERROR_OVERLAPPING_DIRECTORIES 0xC00038A9L

//
// MessageId: DFS_ERROR_AD_WRITE_ERROR
//
// MessageText:
//
//  DFS could not write to the Active Directory on Root %1. The return code is in the record data.
//
#define DFS_ERROR_AD_WRITE_ERROR         0xC00038AAL

//
// MessageId: DFS_ERROR_AD_READ_ERROR
//
// MessageText:
//
//  DFS could not read from the Active Directory on Root %1. The return code is in the record data.
//
#define DFS_ERROR_AD_READ_ERROR          0xC00038ABL

//
// MessageId: DFS_ERROR_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
//  Directory %1 mapped to %2 is not empty. The directory will not be removed.
//
#define DFS_ERROR_DIRECTORY_NOT_EMPTY    0xC00038ACL

//
// MessageId: DFS_ERROR_TOO_MANY_ERRORS
//
// MessageText:
//
//  Root %1 has too many errors. No further eventlogs will be logged on this root.
//
#define DFS_ERROR_TOO_MANY_ERRORS        0xC00038ADL

/////////////////////////////////////////////////////////////////////////
//
// BRIDGE Events
//
// Codes 14600 - 14899
//
/////////////////////////////////////////////////////////////////////////
//
// Driver-wide events (14600 - 14699)
//
//
// MessageId: EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to register as a protocol with NDIS.
//
#define EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED 0xC0003908L

//
// MessageId: EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge's miniport device name is missing from the registry.
//
#define EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING 0xC0003909L

//
// MessageId: EVENT_BRIDGE_MINIPORT_REGISTER_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to register as a miniport with NDIS.
//
#define EVENT_BRIDGE_MINIPORT_REGISTER_FAILED 0xC000390AL

//
// MessageId: EVENT_BRIDGE_DEVICE_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to create a device object.
//
#define EVENT_BRIDGE_DEVICE_CREATION_FAILED 0xC000390BL

//
// MessageId: EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR
//
// MessageText:
//
//  Bridge: The bridge could not be initialized because the bridge failed to determine a MAC address for itself.
//
#define EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR  0xC000390CL

//
// MessageId: EVENT_BRIDGE_MINIPORT_INIT_FAILED
//
// MessageText:
//
//  Bridge: The bridge's attempt to create its virtual miniport failed.
//
#define EVENT_BRIDGE_MINIPORT_INIT_FAILED 0xC000390DL

//
// MessageId: EVENT_BRIDGE_ETHERNET_NOT_OFFERED
//
// MessageText:
//
//  Bridge: The bridge could not initialize its miniport because Ethernet was not offered as a supported medium.
//
#define EVENT_BRIDGE_ETHERNET_NOT_OFFERED 0xC000390EL

//
// MessageId: EVENT_BRIDGE_THREAD_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a system thread.
//
#define EVENT_BRIDGE_THREAD_CREATION_FAILED 0xC000390FL

//
// MessageId: EVENT_BRIDGE_THREAD_REF_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to reference its system thread.
//
#define EVENT_BRIDGE_THREAD_REF_FAILED   0xC0003910L

//
// MessageId: EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a packet pool.
//
#define EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED 0xC0003911L

//
// MessageId: EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to create a buffer pool.
//
#define EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED 0xC0003912L

//
// MessageId: EVENT_BRIDGE_INIT_MALLOC_FAILED
//
// MessageText:
//
//  Bridge: The bridge could not initialize because it failed to allocate memory.
//
#define EVENT_BRIDGE_INIT_MALLOC_FAILED  0xC0003913L

//
// Adapter-specific events (14700 - 14799)
//
//
// MessageId: EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not determine the adapter's link speed. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED 0xC000396CL

//
// MessageId: EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not determine the adapter's MAC address. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED 0xC000396DL

//
// MessageId: EVENT_BRIDGE_ADAPTER_FILTER_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not modify the adapter's packet filter. The adapter will not function correctly.
//
#define EVENT_BRIDGE_ADAPTER_FILTER_FAILED 0xC000396EL

//
// MessageId: EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not retrieve the adapter's description string. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED 0xC000396FL

//
// MessageId: EVENT_BRIDGE_ADAPTER_BIND_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge's attempt to bind to the adapter failed. The adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_BIND_FAILED 0xC0003970L

//
// DAV Redir Events (14800 - 14899)
//
//
// MessageId: EVENT_DAV_REDIR_DELAYED_WRITE_FAILED
//
// MessageText:
//
//  Windows was unable to save data for file %2. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define EVENT_DAV_REDIR_DELAYED_WRITE_FAILED 0x800039D0L

//
// WebClient Service Events (14900 - 14999)
//
//
// MessageId: EVENT_WEBCLIENT_CLOSE_PUT_FAILED
//
// MessageText:
//
//  PUT failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PUT_FAILED 0x80003A35L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_DELETE_FAILED
//
// MessageText:
//
//  DELETE failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_DELETE_FAILED 0x80003A36L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED
//
// MessageText:
//
//  PROPPATCH failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED 0x80003A37L

//
// MessageId: EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED
//
// MessageText:
//
//  PROPPATCH failed for file %1 on SetFileInfo. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED 0x80003A38L


#endif // _NETEVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsassert.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DfsAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:

    Rohan Phillips     [Rohanp]    18-Jan-2001

Revision History:


Notes:


--*/

#ifndef _DFSASSERT_INCLUDED_
#define _DFSASSERT_INCLUDED_

VOID DfsDbgBreakPoint(PCHAR FileName, ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef DFS_ASSERTS

#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        DfsDbgBreakPoint(__FILE__,__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        DfsDbgBreakPoint(__FILE__,__LINE__)

#endif //!DBG


//this will make asserts go to our routine

#define RtlAssert DfsAssert
VOID
DfsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef DFS_ASSERTS


#if DBG
ULONG DfsDebugVector = 0;
#define DFS_TRACE_ERROR      0x00000001
#define DFS_TRACE_DEBUG      0x00000002
#define DFS_TRACE_CONTEXT    0x00000004
#define DFS_TRACE_DETAIL     0x00000008
#define DFS_TRACE_ENTRYEXIT  0x00000010
#define DFS_TRACE_WARNING    0x00000020
#define DFS_TRACE_ALL        0xffffffff
#define DfsDbgTrace(_x_, _y_) {         \
        if (_x_ & DfsDebugVector) {     \
            DbgPrint _y_;                \
        }                                \
}
#else
#define DfsDbgTrace(_x_, _y_)
#endif

#define DfsTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        DfsDbgTrace(DFS_TRACE_ENTRYEXIT,("Entering %s\n",__pszFunction));
        
#define DfsTraceLeave(status)                                                \
        DfsDbgTrace(DFS_TRACE_ENTRYEXIT,("Leaving %s Status -> %08lx\n",__pszFunction,status))
        


#define RxDbgTrace(x, y, z)
#define CHECK_STATUS( status )  if( (status) == g_CheckStatus) \
                                   { DbgBreakPoint() ; }

#endif // _DFSASSERT_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsheader.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    header.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   11\10\1999
    
NOTES:

*/

#ifndef __DFS_HEADER_H
#define __DFS_HEADER_H

#define DFS_OBJECT_MAJOR 0x81

typedef enum _DFS_OBJECT_TYPES {
    DFS_OT_UNDEFINED = 0x8100,
    DFS_OT_PREFIX_TABLE,
    DFS_OT_NAME_TABLE,
    DFS_OT_SERVER_INFO,
    DFS_OT_ROOT_OBJECT,
    DFS_OT_LINK_OBJECT,
    DFS_OT_REPLICA_OBJECT,
    DFS_OT_METADATA_STORAGE,
    DFS_OT_REGISTRY_MACHINE,
    DFS_OT_REFERRAL_STRUCT,
    DFS_OT_REGISTRY_STORE,
    DFS_OT_AD_STORE,
    DFS_OT_POLICY_OBJECT,
    DFS_OT_REFERRAL_LOAD_CONTEXT,
    DFS_OT_AD_DOMAIN,
    DFS_OT_ENTERPRISE_STORE
} DFS_OBJECT_TYPES;


typedef struct _DFS_OBJECT_HEADER {
    union {
        struct {
            UCHAR   ObjectType;          
            UCHAR   ObjectMajor;        // Only used for debugging.
        }Ob;
        USHORT NodeType;                // Mainly for debugging.
    }Node;
    SHORT  NodeSize;
    LONG    ReferenceCount;             // count of people referencing this.
} DFS_OBJECT_HEADER, *PDFS_OBJECT_HEADER;

#define DfsInitializeHeader(_hdr, _type, _size) \
        (_hdr)->Node.NodeType    = (USHORT)(_type),   \
        (_hdr)->NodeSize    = (USHORT)(_size),  \
        (_hdr)->ReferenceCount = 1

#define DfsIncrementReference(_hdr)   \
        InterlockedIncrement(&((PDFS_OBJECT_HEADER)(_hdr))->ReferenceCount)
#define DfsDecrementReference(_hdr)   \
        InterlockedDecrement(&((PDFS_OBJECT_HEADER)(_hdr))->ReferenceCount)


#define DfsGetHeaderType(_x)  (((PDFS_OBJECT_HEADER)(_x))->Node.NodeType)
#define DfsGetHeaderSize(_x)  (((PDFS_OBJECT_HEADER)(_x))->NodeSize)
#define DfsGetHeaderCount(_x)  (((PDFS_OBJECT_HEADER)(_x))->ReferenceCount)


#define DFS_FILTER_NAME               L"\\DfsServer"


typedef DWORD DFSSTATUS;


#endif /* __DFS_HEADER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsnametable.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.h
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------


#ifndef __DFSNAMETABLE_H__
#define __DFSNAMETABLE_H__

#include <dfsheader.h>

#ifdef __cplusplus
extern "C" {
#endif

struct _DFS_NAME_TABLE;

NTSTATUS
DfsInitializeNameTable(
    IN ULONG NumBuckets,
    OUT struct _DFS_NAME_TABLE **ppNameTable);


NTSTATUS
DfsInsertInNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pName,
    IN PVOID pData );


NTSTATUS
DfsLookupNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName, 
    OUT PVOID *ppData );

NTSTATUS
DfsGetEntryNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    OUT PVOID *ppData );

NTSTATUS
DfsRemoveFromNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN PVOID pData );


NTSTATUS
DfsReplaceInNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN OUT PVOID *ppData );


NTSTATUS
DfsDereferenceNameTable(
    IN struct _DFS_NAME_TABLE *pNameTable );


NTSTATUS
DfsReferenceNameTable(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableAcquireReadLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableAcquireWriteLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

NTSTATUS
DfsNameTableReleaseLock(
    IN struct _DFS_NAME_TABLE *pNameTable );

#ifdef __cplusplus
}
#endif


#endif // __DFSNAMETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsumr.h ===
/*=========================================================================*\

    Module:      Dfsumr.h

    Copyright Microsoft Corporation 2001, All Rights Reserved.

    Author:      Rohan Phillips - Rohanp

    Description: User mode reflector header file

\*=========================================================================*/

#ifndef __DFSUMRSTRCT_H__
#define __DFSUMRSTRCT_H__

// This should be bumped whenever there are changes made to these structures
//
#define UMR_VERSION 1


#define MAX_USERMODE_REFLECTION_BUFFER 16384

#define UMRX_USERMODE_WORKITEM_CORRELATOR_SIZE 4

#define UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE  0x00000001
#define UMR_WORKITEM_HEADER_ASYNC_COMPLETE         0x00000002

#define DFSUMRSIGNATURE       'DFSU'    

//
//  enum definitions.
//
typedef enum _USERMODE_WORKITEMS_TYPES {
    opUmrIsDfsLink = 1,    // 0 is an invalid type
    opUmrGetDfsReplicas,
    opUmrMax
} USERMODE_WORKITEMS_TYPES;


//
// DFSFILTER_ATTACH/DETACH support
// VOlume and share file names are passed in the PathNameBuffer.
// Both strings are not null terminated, with the source name starting at
// the beginning of FileNameBuffer, and the destination name immediately
// following.
//

typedef struct _DFS_ATTACH_PATH_BUFFER_ {
    ULONG VolumeNameLength;
    ULONG ShareNameLength;
    ULONG Flags;
    WCHAR PathNameBuffer[1];
} DFS_ATTACH_PATH_BUFFER, *PDFS_ATTACH_PATH_BUFFER;


#define UMRX_STATIC_REQUEST_LENGTH(__requesttypefield,__lastfieldofrequest) \
    (FIELD_OFFSET(UMRX_USERMODE_WORKITEM,__requesttypefield.__lastfieldofrequest) \
    + sizeof(((PUMRX_USERMODE_WORKITEM)NULL)->__requesttypefield.__lastfieldofrequest))

#define UMR_ALIGN(x) ( ((x) % sizeof(double) == 0) ? \
                     ( (x) ) : \
                     ( (x) + sizeof(double) - (x) % sizeof(double) ) )

typedef struct _VarData
{
    ULONG cbData;
    ULONG cbOffset;     // offset from location of this structure
} VAR_DATA, *PVAR_DATA;

// opUmrIsDfsLink
//
typedef struct _UmrIsDfsLinkReq_
{
    ULONG       Length;
    BYTE        Buffer[1];  // start of vardata   
} UMR_ISDFSLINK_REQ, *PUMR_ISDFSLINK_REQ;

typedef struct _UmrIsDfsLinkResp_
{    
    BOOL        IsADfsLink;
} UMR_ISDFSLINK_RESP, *PUMR_ISDFSLINK_RESP;


// opUmrGetDfsreplicas
//
typedef struct _UmrGetDfsReplicasReq_
{
    REPLICA_DATA_INFO RepInfo;
} UMR_GETDFSREPLICAS_REQ, *PUMR_GETDFSREPLICAS_REQ;

typedef struct _UmrGetDfsReplicasResp
{
    ULONG      Length;
    BYTE       Buffer[1];  // start of vardata
} UMR_GETDFSREPLICAS_RESP, *PUMR_GETDFSREPLICAS_RESP;


// union for all request structs
//
typedef union _UMRX_USERMODE_WORK_REQUEST
{
    UMR_ISDFSLINK_REQ           IsDfsLinkRequest;
    UMR_GETDFSREPLICAS_REQ      GetDfsReplicasRequest;
} UMRX_USERMODE_WORK_REQUEST, *PUMRX_USERMODE_WORK_REQUEST;


// union for all response structs
//
typedef union _UMRX_USERMODE_WORK_RESPONSE
{
    UMR_ISDFSLINK_RESP           IsDfsLinkResponse;
    UMR_GETDFSREPLICAS_RESP      GetDfsReplicasResponse;
} UMRX_USERMODE_WORK_RESPONSE, *PUMRX_USERMODE_WORK_RESPONSE;


// header that's common to all requests and responses
//
typedef struct _UMRX_USERMODE_WORKITEM_HEADER {
    union {
        ULONG_PTR CorrelatorAsUInt[UMRX_USERMODE_WORKITEM_CORRELATOR_SIZE];
        double forcealignment;
    };
    IO_STATUS_BLOCK IoStatus;
    USERMODE_WORKITEMS_TYPES WorkItemType;
    DWORD       dwDebugSig;
    ULONG       ulHeaderVersion;
    ULONG       ulFlags;
} UMRX_USERMODE_WORKITEM_HEADER, *PUMRX_USERMODE_WORKITEM_HEADER;

// The top level structure.
//
typedef struct _UMRX_USERMODE_WORKITEM {
    UMRX_USERMODE_WORKITEM_HEADER Header;
    union {
        UMRX_USERMODE_WORK_REQUEST WorkRequest;
        UMRX_USERMODE_WORK_RESPONSE WorkResponse;
    };
    CHAR Pad[1];
} UMRX_USERMODE_WORKITEM, *PUMRX_USERMODE_WORKITEM;


#define DFSFILTER_PROCESS_TERMINATION_FILEPATH L"\\ProcessTermination\\FilePath"

#define DFSFILTER_W32_DEVICE_NAME   L"\\\\.\\DfsFilter"
#define DFSFILTER_DEVICE_TYPE       0x1235

#define DFSFILTER_START_UMRX          (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 100, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_STOP_UMRX           (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 101, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_PROCESS_UMRXPACKET  (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 102, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_GETREPLICA_INFO     (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 103, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_ATTACH_FILESYSTEM   (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 104, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_DETACH_FILESYSTEM   (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 105, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define DFSFILTER_PURGE_SHARELIST     (ULONG) CTL_CODE( DFSFILTER_DEVICE_TYPE, 106, METHOD_BUFFERED, FILE_ANY_ACCESS )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\midatlsp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the private data structures used in mapping MIDS
    to the corresponding requests/contexts associated with them. it's
    separated from the .c portion so the debugger extension can see it.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/


#ifndef _MIDATLAS_PRIVATE_H_
#define _MIDATLAS_PRIVATE_H_

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;

#endif //_MIDATLAX_PRIVATE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsprefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//--------------------------------------------------------------------------

#ifndef __PREFIX_HXX__
#define __PREFIX_HXX__
#ifdef __cplusplus
extern "C" {
#endif


//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE API.
//
// History:
//
// Notes:   The following API's are provided for manipulating the
//          DFS_PREFIX_TABLE.
//
//----------------------------------------------------------------------
struct _DFS_PREFIX_TABLE;

extern
NTSTATUS DfsInitializePrefixTable(struct _DFS_PREFIX_TABLE **ppTable,
                                  BOOLEAN           fCaseSensitive,
                                  PVOID Lock);
                            

extern
NTSTATUS DfsInsertInPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                PUNICODE_STRING   pPath,
                                PVOID             pData);

extern
NTSTATUS DfsRemoveFromPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                  PUNICODE_STRING pPath,
                                  PVOID pMatchingData );


extern
NTSTATUS DfsReplaceInPrefixTableLocked(struct _DFS_PREFIX_TABLE *pTable,
                                 PUNICODE_STRING pPath,
                                 PVOID pReplaceData,
                                 PVOID pMatchingData );

extern 
NTSTATUS DfsFreePrefixTable(struct _DFS_PREFIX_TABLE *pTable);

extern
NTSTATUS DfsFindUnicodePrefixLocked(
    IN  struct _DFS_PREFIX_TABLE *pTable,
    IN  PUNICODE_STRING     pPath,
    OUT PUNICODE_STRING     pSuffix,
    OUT PVOID *ppData,
    OUT PBOOLEAN pSubStringMatch );


extern
NTSTATUS
DfsPrefixTableAcquireWriteLock(
    struct _DFS_PREFIX_TABLE *pTable );

extern
NTSTATUS
DfsPrefixTableAcquireReadLock(
    struct _DFS_PREFIX_TABLE *pTable );


extern
NTSTATUS
DfsPrefixTableReleaseLock(
    struct _DFS_PREFIX_TABLE *pTable );

extern NTSTATUS
DfsPrefixTableInit(VOID);

extern
void
DfsPrefixTableShutdown(void);

VOID
DfsDumpPrefixTable(
   struct _DFS_PREFIX_TABLE *pPrefixTable,
   IN VOID (*DumpFunction)(PVOID pEntry));

VOID
DfsProcessPrefixTable(
   struct _DFS_PREFIX_TABLE *pPrefixTable,
   IN VOID (*DumpFunction)(PVOID pEntry));


NTSTATUS
DfsDismantlePrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN VOID (*ProcessFunction)(PVOID pEntry));

NTSTATUS
DfsDeletePrefixTable(
    struct _DFS_PREFIX_TABLE *pTable);

NTSTATUS
DfsInsertInPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData);

NTSTATUS
DfsFindUnicodePrefix(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PUNICODE_STRING pSuffix,
    IN PVOID *ppData);

NTSTATUS 
DfsRemoveFromPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData);

NTSTATUS
DfsReplaceInPrefixTable(
    IN struct _DFS_PREFIX_TABLE *pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID pMatchingData);


NTSTATUS 
DfsRemoveFromPrefixTableEx(
    IN struct _DFS_PREFIX_TABLE * pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData);


NTSTATUS DfsRemoveFromPrefixTableLockedEx(
    IN struct _DFS_PREFIX_TABLE * pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData);


#ifdef WPP_CB_TYPE
// only define this if we are doing tracing
VOID
PrefixSetTraceControl(WPP_CB_TYPE *Control);

#endif

#define DfsReferencePrefixTable(_pTable) \
         DfsIncrementReference((PDFS_OBJECT_HEADER)(_pTable))
         
NTSTATUS
DfsDereferencePrefixTable(struct _DFS_PREFIX_TABLE *pTable );

#ifdef __cplusplus
}
#endif

#endif // __PREFIX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsreferraldata.h ===
/*++

Copyright (c) 1989 Microsoft Corporation.

Module Name:
   
    DfsReferalData.h
    
Abstract:
   
    This module contains the main infrastructure for mup data structures.
    
Revision History:

    Uday Hegde (udayh)   01\16\2001
    Copied from structures setup by RohanP.
    
NOTES:

*/


#ifndef __DFS_REFERRAL_DATA_H__
#define __DFS_REFERRAL_DATA_H__

#ifdef __cplusplus
extern "C" {
#endif


#define CURRENT_DFS_REPLICA_HEADER_VERSION 1

#define DFS_REFERRAL_DATA_ROOT_REFERRAL        0x0001

#define DFS_REFERRAL_DATA_DOMAIN_REFERRAL      0x0010
#define DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL   0x0020

#define DFS_DEFAULT_REFERRAL_TIMEOUT           300


typedef struct _REFFERAL_HEADER_
{
	ULONG VersionNumber;
    ULONG ReferralFlags;
    ULONG TotalSize;
	ULONG ReplicaCount;
    ULONG Timeout;
	ULONG OffsetToReplicas;
	ULONG LinkNameLength;
	WCHAR LinkName[1];	
}REFERRAL_HEADER, *PREFERRAL_HEADER;



typedef struct _REPLICA_INFORMATION_
{
	ULONG NextEntryOffset;
	ULONG ReplicaFlags;
	ULONG ReplicaCost;
	ULONG ReplicaNameLength;
	WCHAR ReplicaName[1];
}REPLICA_INFORMATION, *PREPLICA_INFORMATION;


#define DFS_OLDDFS_SERVER      0x00000001 //for flags field below
typedef struct _REPLICA_DATA_INFO_
{
    ULONG  Flags;
    ULONG  ClientBufferSize;
    ULONG  MaxReferralLevel;
    ULONG  CostLimit;
    ULONG  NumReplicasToReturn;
    ULONG  IpLength;
    ULONG  LinkNameLength;
    USHORT IpFamily;
    char   IpData[14];
    WCHAR  LinkName[1];
}REPLICA_DATA_INFO, *PREPLICA_DATA_INFO;

#ifdef __cplusplus
}
#endif


#endif // __DFS_REFERRAL_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfswarnings.h ===
#ifndef __DFS_WARNING_H__
#define __DFS_WARNING_H__

#include "warning.h"

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4702)   // Unreachable code
#pragma warning(error:4705)   // Statement has no effect
#pragma warning(error:4706)   // assignment w/i conditional expression
#pragma warning(error:4709)   // command operator w/o index expression
#pragma warning(error:4101)   // Unreferenced local variable
#pragma warning(error:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(error:4242)   // convertion possible loss of data
#pragma warning(error:4532)   // jump out of __finally block

#endif // defined __DFS_WARNING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfswpp.inc ===
# Define functions used for logging
#   TraceLog(,,ID,GRP,MSG,ARG)
#     ID - indicates where we should look for ID (required)
#     GRP - indicates what group this message belongs to (optional. Default 1)
#     MSG - what message needs to be used (optional. Default="ID(args)")
#     ARG - list of arguments (optional. Default = "no args")

DFS_TRACE_HIGH(,MSG,ARG);
DFS_TRACE_NORM(,MSG,ARG);
DFS_TRACE_LOW(,MSG,ARG);
DFS_TRACE_ERROR_HIGH(,,MSG,ARG);
DFS_TRACE_ERROR_NORM(,,MSG,ARG);
DFS_TRACE_ERROR_LOW(,,MSG,ARG);


DEFINE_CPLX_TYPE(WSTR_CHK, LOGWSTR_CHK, LPCWSTR, ItemWString,  "s", s, 0);
DEFINE_CPLX_TYPE(ASTR_CHK, LOGASTR_CHK, LPCSTR, ItemAString,  "s", s, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfsumrctrl.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrCtrl.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/
     
#ifndef _DFSUMRCTRL_H_
#define _DFSUMRCTRL_H_

LONG 
AddUmrRef(void);

LONG 
ReleaseUmrRef(void);

BOOL 
IsUmrEnabled(void);

BOOLEAN 

LockUmrShared(void);

void 
UnLockUmrShared(void);

NTSTATUS 
DfsInitializeUmrResources(void);


void 
DfsDeInitializeUmrResources(void);


NTSTATUS
DfsStartupUMRx(void);


NTSTATUS
DfsTeardownUMRx(void);



NTSTATUS
DfsProcessUMRxPacket(
        IN PVOID InputBuffer,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer,
        IN ULONG OutputBufferLength,
        IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


PUMRX_ENGINE 
GetUMRxEngineFromRxContext(void);


NTSTATUS
DfsWaitForPendingClients(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\dfswmi.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    dfswmi.h

Abstract:

    DFS specific wmi tracing declarations

Authors:

    Rohanp     28-Feb-2001

Environment:

    User/Kernel

Notes:

Revision History:


--*/

//
// this will let us use null strings in the wmi macros.
//
#define	WPP_CHECK_FOR_NULL_STRING 1

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(DfsFilter,(27246e9d,b4df,4f20,b969,736fa49ff6ff), \
      WPP_DEFINE_BIT(KUMR_EVENT)     \
      WPP_DEFINE_BIT(KUMR_ERROR)     \
      WPP_DEFINE_BIT(KUMR_DETAIL)    \
                                      \
      WPP_DEFINE_BIT(PREFIX) \
      WPP_DEFINE_BIT(USER_AGENT)\
                                      \
      WPP_DEFINE_BIT(REFERRAL_SERVER)\
                                      \
      WPP_DEFINE_BIT(API)\
      WPP_DEFINE_BIT(REFERRAL)\
      WPP_DEFINE_BIT(STATISTICS) \
                                      \
      WPP_DEFINE_BIT(ADBLOB) \
      WPP_DEFINE_BIT(STANDALONE) \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\midatlax.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAX_H_
#define _MIDATLAX_H_

typedef struct _RX_MID_ATLAS {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      NumberOfMidsDiscarded;
   USHORT      MaximumMidFieldWidth;
   USHORT      Reserved;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} RX_MID_ATLAS, *PRX_MID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

typedef
VOID (*PCONTEXT_ITERATOR)(
	PVOID pContext);

#define RxGetMaximumNumberOfMids(pMidAtlas) \
        ((pMidAtlas)->MaximumNumberOfMids)

#define RxGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

PRX_MID_ATLAS
RxCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

VOID
RxDestroyMidAtlas(
         PRX_MID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

void
RxIterateMidAtlasAndRemove(
		PRX_MID_ATLAS pMidAtlas,
		PCONTEXT_ITERATOR pContextIterator);

PVOID
RxMapMidToContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid);

NTSTATUS
RxAssociateContextWithMid(
         PRX_MID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

NTSTATUS
RxMapAndDissociateMidFromContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

NTSTATUS
RxReassociateMid(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\rxcontx.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rxcontx.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _DFSRXCONTX_H_
#define _DFSRXCONTX_H_

typedef
NTSTATUS
(NTAPI *DFS_CALLDOWN_ROUTINE) (
    IN OUT PVOID pCalldownParameter);

#define MRX_CONTEXT_FIELD_COUNT    4

typedef struct _RX_CONTEXT {

    ULONG                   Signature;

    ULONG                   ReferenceCount;

    ULONG                   Flags;

    NTSTATUS                Status;

    ULONG                   OutputBufferLength;

    ULONG                   InputBufferLength;

    ULONG                   ReturnedLength;

    PDEVICE_OBJECT          RealDevice;

    PVOID                   OutputBuffer;

    PVOID                   InputBuffer;

    DFS_CALLDOWN_ROUTINE    CancelRoutine;

    PVOID                   UMRScratchSpace[MRX_CONTEXT_FIELD_COUNT] ;

    // The original thread in which the request was initiated and the last
    // thread in which some processing associated with the context was done

    PETHREAD                 OriginalThread;
    PETHREAD                 LastExecutionThread;

    //  ptr to the originating Irp
    PIRP                    CurrentIrp;

    //event
    KEVENT                  SyncEvent;


    // the list entry to wire the context to the list of active contexts

    LIST_ENTRY              ContextListEntry;
}RX_CONTEXT, *PRX_CONTEXT;

#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        }
        
#define DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS 0x00000001
#define DFS_CONTEXT_FLAG_CANCELLED          0x00000002
#define DFS_CONTEXT_FLAG_ASYNC_OPERATION    0x00000004
#define DFS_CONTEXT_FLAG_FILTER_INITIATED   0x00000008

#define  RxWaitSync(RxContext)                                                   \
         (RxContext)->Flags |= DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             

#define  RxWaitSyncWithTimeout(RxContext,pliTimeout)                             \
         (RxContext)->Flags |= DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         Status = KeWaitForSingleObject( &(RxContext)->SyncEvent,                \
                               Executive, KernelMode, FALSE, pliTimeout );       
                               

#define RxSignalSynchronousWaiter(RxContext)                       \
        (RxContext)->Flags &= ~DFS_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )
        

NTSTATUS 
DfsInitializeContextResources(void);

NTSTATUS 
DfsDeInitializeContextResources(void);

VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
RxInitializeContext(
    IN PIRP            Irp,
    IN OUT PRX_CONTEXT RxContext);


PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

NTSTATUS
RxSetMinirdrCancelRoutine(
    IN  OUT PRX_CONTEXT   RxContext,    
    IN      DFS_CALLDOWN_ROUTINE MRxCancelRoutine);

#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
                                                   }
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\shash.h ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shash.h
//
//  Contents:   Generic hashtable
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifndef __SHASHTABLE_H__
#define __SHASHTABLE_H__
#ifdef __cplusplus
extern "C" {
#endif

//forward declaration
struct _SHASH_TABLE;

struct _SHASH_HEADER;

// This function computes the has value
//
typedef ULONG (*PFNHASH)( void*      pvKey ) ;

//
// This function compares the keys
//
typedef int (*PFNMATCHKEY)( void*  key1, void*     key2 ) ;


//
// This function gets called when the keys get removed
//
typedef int (*PFNREMOVEKEY)(struct _SHASH_HEADER * pHeader) ;


//
// This function gets called when the keys get removed
//
typedef DWORD (*PFNENUMERATEKEY)(struct _SHASH_HEADER * pHeader, void * pContext ) ;


// memory allocations function
typedef void*   (*PFNALLOC)(    ULONG   cb ) ;


// memory free function
typedef void    (*PFNFREE)(     void*   lpv ) ;

//
//      This function allocs memory the tables lock
//
typedef void *      (*PFNALLOCLOCK)( void ) ;

//
//      This function releases the lock  memory
//
typedef void        (*PFNFREELOCK)( void * ) ;


typedef BOOLEAN            (*PFNAQUIREWRITELOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNAQUIREREADLOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNRELEASEWRITELOCK)( struct _SHASH_TABLE * pTable ) ;
typedef BOOLEAN            (*PFNRELEASEREADLOCK)( struct _SHASH_TABLE * pTable ) ;


#define SHASH_DEFAULT_HASH_SIZE 625

//
// There are flags that are not used by shash, they can be used by
// the caller.
//
#define SHASH_USER_FLAGS        0xFFFF0000

typedef struct _SHASH_HEADER
{
    ULONG Signature;
    ULONG Flags;
    PVOID pvKey;
    PVOID pData;
    LONG  RefCount;
    ULONG dwHash;
    FILETIME Time;
    LIST_ENTRY ListEntry;
}SHASH_HEADER, *PSHASH_HEADER;

#define SHASH_FLAG_DELETE_PENDING    0x00000001

typedef struct _SHASHFUNCTABLE 
{
    PFNHASH HashFunc;
    PFNMATCHKEY CompareFunc;
    PFNALLOC AllocFunc;
    PFNFREE  FreeFunc;
    PFNALLOCLOCK AllocLockFunc;
    PFNFREELOCK  FreeLockFunc;
    PFNAQUIREWRITELOCK WriteLockFunc;
    PFNAQUIREREADLOCK ReadLockFunc;
    PFNRELEASEWRITELOCK ReleaseWriteLockFunc;
    PFNRELEASEREADLOCK ReleaseReadLockFunc;
    ULONG   Flags;
    ULONG   NumBuckets;
} SHASH_FUNCTABLE, *PSHASH_FUNCTABLE;

typedef struct _SHASH_BUCKET 
{
    ULONG Count;
    LIST_ENTRY ListHead;
} SHASH_BUCKET, *PHASH_SBUCKET;

typedef struct _SHASH_ENTRY 
{
    PVOID pvKey;
    LONG  RefCount;
    ULONG Flags;
    PVOID pData;
    LARGE_INTEGER EntryTime;
    LARGE_INTEGER ExpireTime;
    LIST_ENTRY ListEntry;
} SHASH_ENTRY, *PSHASH_ENTRY;

typedef struct _SHASH_TABLE 
{
    PFNHASH HashFunc;
    PFNMATCHKEY CompareFunc;
    PFNALLOC AllocFunc;
    PFNFREE  FreeFunc;
    PFNALLOCLOCK AllocLockFunc;
    PFNFREELOCK  FreeLockFunc;
    PFNAQUIREWRITELOCK WriteLockFunc;
    PFNAQUIREREADLOCK ReadLockFunc;
    PFNRELEASEWRITELOCK ReleaseWriteLockFunc;
    PFNRELEASEREADLOCK ReleaseReadLockFunc;
    LONG    Version;
    ULONG   Flags;
    ULONG   NumBuckets;
    ULONG   TotalItems;
    PVOID   pLock;
    SHASH_BUCKET HashBuckets[0];
} SHASH_TABLE, *PSHASH_TABLE;

#define SHASH_CAP_POWER_OF2         0x000001
#define SHASH_CAP_TABLE_LOCKED      0x000002
#define SHASH_CAP_NOSEARCH_INSERT   0x000004

#define SHASH_DEFAULT_HASHTIMEOUT   (15 * 60) //timeout entries in 15 minutes

#define SHASH_REPLACE_IFFOUND   1

#ifdef KERNEL_MODE
#define SHASH_GET_TIME(Time) KeQuerySystemTime(Time)
#else
#define SHASH_GET_TIME(Time) NtQuerySystemTime(Time)
#endif


typedef struct _SHASH_ITERATOR {
    //
    //  index
    //
    ULONG           index;

    LIST_ENTRY*     pListHead;

    //
    //
    LIST_ENTRY*     ple;

    PSHASH_HEADER	pEntry;

} SHASH_ITERATOR,*PSHASH_ITERATOR;

NTSTATUS 
ShashInitHashTable(
    PSHASH_TABLE *ppHashTable,
    PSHASH_FUNCTABLE pFuncTable);


void 
ShashTerminateHashTable(
    PSHASH_TABLE pHashTable
    );


NTSTATUS
SHashInsertKey(IN	PSHASH_TABLE	pTable, 
			   IN	void *	pData,
			   IN	void *	pvKeyIn,
               IN   DWORD   InsertFlag
			   );



NTSTATUS	
SHashRemoveKey(	IN	PSHASH_TABLE	pTable, 
				IN	void *		pvKeyIn,
                IN  PFNREMOVEKEY pRemoveFunc
				);


PSHASH_HEADER	
SHashLookupKeyEx(	IN	PSHASH_TABLE pTable, 
				IN	void*		pvKeyIn
				);


NTSTATUS	
SHashIsKeyInTable(	IN	PSHASH_TABLE pTable, 
				    IN	void*		pvKeyIn
                 );


NTSTATUS	
SHashGetDataFromTable(	IN	PSHASH_TABLE pTable, 
				        IN	void*		pvKeyIn,
                        IN  void ** ppData
                     );

NTSTATUS
ShashEnumerateItems(IN	PSHASH_TABLE pTable, 
					IN	PFNENUMERATEKEY	    pfnCallback, 
					IN	LPVOID				lpvClientContext
					);	


NTSTATUS	
SHashReleaseReference(	IN	PSHASH_TABLE pTable, 
                        IN  PSHASH_HEADER pData
                     );


PSHASH_HEADER
SHashStartEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        );

PSHASH_HEADER
SHashNextEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable);


VOID
SHashFinishEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\inc\umrx.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    umrx.h

Abstract:

    This header defines the UMRxEngine object and associated functions.
    The UMRxEngine provides a set of services for dispatch function
    writers so they can reflect requests to user-mode components.

Notes:

    Code / Ideas have been adopted from Joe Linn's user-mode reflector

Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _UMRX_H_
#define _UMRX_H_

//
//  defines and tags
//
#define UMRX_ENGINE_TAG                  (ULONG) 'xrmU'
#define UMRX_CONTEXT_TAG                 (ULONG) 'xtcU'

#define REASSIGN_MID        1
#define DONT_REASSIGN_MID   0

#define TICKS_PER_SECOND (10 * 1000 * 1000)

typedef USHORT          NODE_TYPE_CODE;
typedef CSHORT          NODE_BYTE_SIZE;

typedef struct _MRX_NORMAL_NODE_HEADER {
   NODE_TYPE_CODE           NodeTypeCode;
   NODE_BYTE_SIZE           NodeByteSize;
   ULONG                    NodeReferenceCount;
} MRX_NORMAL_NODE_HEADER;


enum {
    UMRX_ENGINE_STATE_STOPPED = 0,
    UMRX_ENGINE_STATE_STARTING,
    UMRX_ENGINE_STATE_STARTED,
    UMRX_ENGINE_STATE_STOPPING
};

//
//  Define the UMRxEngine object. There is one such object for
//  every NET_ROOT. This object contains all the data str needed
//  for routing kernel-mode requests to user-mode.
//
typedef struct _UMRX_ENGINE {
    // MID to UMRxContext mapping table
    struct {
        PRX_MID_ATLAS MidAtlas;
        FAST_MUTEX MidManagementMutex;
        LIST_ENTRY WaitingForMidListhead;
    };
    struct {
        KQUEUE Queue;
        LARGE_INTEGER TimeOut;
        LIST_ENTRY PoisonEntry;
        ULONG NumberOfWorkerThreads;
        ULONG NumberOfWorkItems;
        ERESOURCE Lock;
        ULONG State;
        ULONG ThreadAborted;
    } Q;    
    ULONG NextSerialNumber;
    ULONG cUserModeReflectionsInProgress;
    LIST_ENTRY ActiveLinkHead;
} UMRX_ENGINE, *PUMRX_ENGINE;


void
UMRxAbortPendingRequests(IN PUMRX_ENGINE pUMRxEngine);

//
//  Forwards
//
struct _UMRX_CONTEXT;
typedef struct _UMRX_CONTEXT    *PUMRX_CONTEXT;

//
//  Signatures for function pointers
//

//
//  Continue routine is called by InitiateRequest -
//  This turns around and submits the request to the
//  UMR engine with callbacks for FORMAT and COMPLETION.
//
typedef
NTSTATUS
(*PUMRX_CONTINUE_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext
    );

//
//  Format routine - called before user-mode worker thread completes.
//  Each dispatch routine will interpret the WORK_ITEM union based on opcode.
//  eg: for Create, WorkItem is a CREATE_REQUEST.
//
typedef
NTSTATUS
(*PUMRX_USERMODE_FORMAT_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength,
    PULONG ReturnedLength
    );

//
//  Completion routine - called when user-mode response is received.
//  Each dispatch routine will interpret the WORK_ITEM union based on opcode.
//  eg: for Create, WorkItem is a CREATE_RESPONSE.
//
typedef
VOID
(*PUMRX_USERMODE_COMPLETION_ROUTINE) (
    PUMRX_CONTEXT pUMRxContext,
    PRX_CONTEXT   pRxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength
    );

//
//  Type of operation reflected to user-mode
//
typedef enum _UMRX_CONTEXT_TYPE {
    UMRX_CTXTYPE_IFSDFSLINK = 0,
    UMRX_CTXTYPE_GETDFSREPLICAS,
    UMRX_CTXTYPE_MAXIMUM
} UMRX_CONTEXT_TYPE;

//
//  Define the UMRxContext. This context is sent as part of
//  the REQUEST to user-mode. The user-mode handler will
//  send the context back in a RESPONSE. The context will be
//  used to do the rendezvous with blocked requests.
//

#define UMRX_NTC_CONTEXT    ((USHORT)0xedd0)

typedef struct _UMRX_CONTEXT{
    MRX_NORMAL_NODE_HEADER;
    PUMRX_ENGINE pUMRxEngine;   // owning engine object
    PRX_CONTEXT RxContext;
    PVOID SavedMinirdrContextPtr;
    union {
        IO_STATUS_BLOCK;
        IO_STATUS_BLOCK IoStatusBlock;
    };
    UMRX_CONTEXT_TYPE CTXType;
    PUMRX_CONTINUE_ROUTINE Continuation;
    struct {
        LIST_ENTRY WorkQueueLinks;
        PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine;
        PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine;
        KEVENT WaitForMidEvent;
        ULONG CallUpSerialNumber;
        USHORT CallUpMid;
    } UserMode;
    LIST_ENTRY ActiveLink;
} UMRX_CONTEXT, *PUMRX_CONTEXT;

#define UMRxReferenceContext(pUMRxContext) {\
        ULONG result = InterlockedIncrement(&(pUMRxContext)->NodeReferenceCount); \
        RxDbgTrace(0, (DEBUG_TRACE_UMRX), \
                    ("ReferenceContext result=%08lx\n", result )); \
        }
    
typedef struct _UMRX_WORKITEM_HEADER_PRIVATE {
    PUMRX_CONTEXT pUMRxContext;
    ULONG SerialNumber;
    USHORT Mid;
} UMRX_WORKITEM_HEADER_PRIVATE, *PUMRX_WORKITEM_HEADER_PRIVATE;

//
//  Create a UMRX_ENGINE object
//
PUMRX_ENGINE
CreateUMRxEngine();

//
//  Close a UMRX_ENGINE object -
//  Owner of object ensures that all usage of this object
//  is within the Create/Finalize span.
//
VOID
FinalizeUMRxEngine(
    IN PUMRX_ENGINE pUMRxEngine
    );

//
//  Complete queued requests and optional cleanup when the store has exited
//
NTSTATUS
UMRxEngineCompleteQueuedRequests(
                  IN PUMRX_ENGINE pUMRxEngine,
                  IN NTSTATUS     CompletionStatus,
                  IN BOOLEAN      fCleanup
                 );
//
//  Used to allow an engine to be used again after it's been shutdown.
//
//
NTSTATUS
UMRxEngineRestart(
                  IN PUMRX_ENGINE pUMRxEngine
                 );

//
//  Initiate a request to the UMR engine -
//  This creates a UMRxContext that is used for response rendezvous.
//  All IFS dispatch routines will start a user-mode reflection by
//  calling this routine. Steps in routine:
//
//  1. Allocate a UMRxContext and set RxContext
//     (NOTE: need to have ASSERTs that validate this linkage)
//  2. Set Continue routine ptr and call Continue routine
//  3. If Continue routine is done ie not PENDING, Finalize UMRxContext
//
NTSTATUS
UMRxEngineInitiateRequest (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_CONTINUE_ROUTINE Continuation
    );

//
//  Create/Finalize UMRX_CONTEXTs
//  These are pool allocs/frees
//
PUMRX_CONTEXT
UMRxCreateAndReferenceContext (
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType
    );


BOOLEAN
UMRxDereferenceAndFinalizeContext (
    IN OUT PUMRX_CONTEXT pUMRxContext
    );

//
//  Submit a request to the UMR engine -
//  This adds the request to the engine KQUEUE for processing by
//  a user-mode thread. Steps:
//  
//  1. set the FORMAT and COMPLETION callbacks in the UMRxContext
//  2. initialize the RxContext sync event
//  3. insert the UMRxContext into the engine KQUEUE
//  4. block on RxContext sync event (for SYNC operations)
//  5. after unblock (ie umode response is back), call Resume routine
//



NTSTATUS
UMRxEngineSubmitRequest(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   pRxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine
    );

//
//  Resume is called after I/O thread is unblocked by umode RESPONSE.
//  This routine calls any Finish callbacks and then Finalizes the 
//  UMRxContext.
//
NTSTATUS
UMRxResumeEngineContext(
    IN OUT PRX_CONTEXT RxContext
    );

//
//  The following functions run in the context of user-mode
//  worker threads that issue WORK IOCTLs. The IOCTL calls the
//  following functions in order:
//  1. UMRxCompleteUserModeRequest() - process a response if needed
//  2. UMRxEngineProcessRequest()  - process a request if one is
//     available on the UMRxEngine KQUEUE. Since these IOCTLs are
//     made on a NET_ROOT, the corresponding UMRxEngine is readily
//     available in the NET_ROOT extension.
//

//
//  Every IOCTL pended is potentially a Response. If so, process it.
//  The first IOCTL pended is usually a NULL Response or 'listen'.
//  Steps:
//  1. Get MID from response buffer. Map MID to UMRxContext.
//  2. Call UMRxContext COMPLETION routine.
//  3. Unblock the I/O thread waiting in UMRxEngineSubmitRequest()
//
NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    IN BOOLEAN fReleaseUmrRef,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT BOOLEAN * pfReturnImmediately
    );

//
//  NOTE: if no requests are available, the user-mode thread will
//  block till a request is available (It is trivial to make this
//  a more async model).
//  
//  If a request is available, get the corresponding UMRxContext and
//  call ProcessRequest.
//  Steps:
//  1. Call KeRemoveQueue() to remove a request from the UMRxEngine KQUEUE.
//  2. Get a MID for this UMRxContext and fill it in the WORK_ITEM header.
//  3. Call the UMRxContext FORMAT routine - this fills in the Request params.
//  4. return STATUS_SUCCESS - this causes the IOCTL to complete which
//     triggers the user-mode completion and processing of the REQUEST.
//
NTSTATUS
UMRxEngineProcessRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    OUT PULONG FormattedWorkItemLength
    );

//
//  This is called in response to a WORK_CLEANUP IOCTL.
//  This routine will insert a dummy item in the engine KQUEUE.
//  Each such dummy item inserted will release one thread.
//
NTSTATUS
UMRxEngineReleaseThreads(
    IN PUMRX_ENGINE pUMRxEngine
    );

//
//  Cancel I/O infrastructure
//
typedef
NTSTATUS
(NTAPI *PUMRX_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

// The RX_CONTEXT instance has four fields ( ULONG's ) provided by the wrapper
// which can be used by the mini rdr to store its context. This is used by
// the reflector to identify the parameters for request cancellation

typedef struct _UMRX_RX_CONTEXT {
    PUMRX_CANCEL_ROUTINE      pCancelRoutine;
    PVOID                     pCancelContext;
    union {
        struct {
            PUMRX_CONTEXT     pUMRxContext;
            ULONG             RxSyncTimeout;
        };
        IO_STATUS_BLOCK SyncCallDownIoStatus;
    };
} UMRX_RX_CONTEXT, *PUMRX_RX_CONTEXT;

#define UMRxGetMinirdrContext(pRxContext)     \
        ((PUMRX_RX_CONTEXT)(&(pRxContext)->UMRScratchSpace[0]))

#endif // _UMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\misc\dominfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Registry_Store.c
//
//  Contents:   methods to read information from the registry.
//
//  History:    udayh: created.
//
//  Notes:
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>

DFSSTATUS
DfsIsThisAMachineName(
    LPWSTR MachineName )
{
    DFSSTATUS Status;

    Status = DfsIsThisADomainName(MachineName);

    if (Status != NO_ERROR) {
        Status = ERROR_SUCCESS;
    }
    else {
        Status = ERROR_NO_MATCH;
    }

    return Status;
}


DFSSTATUS
DfsIsThisADomainName(
    LPWSTR DomainName )
{
    ULONG               Flags = 0;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo;
    DFSSTATUS Status;

    Status = DsGetDcName(
                 NULL,   // Computername
                 DomainName,   // DomainName
                 NULL,   // DomainGuid
                 NULL,   // SiteGuid
                 Flags,
                 &pDomainControllerInfo);


    if (Status == NO_ERROR) {
        NetApiBufferFree(pDomainControllerInfo);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\misc\dfsmisc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <malloc.h>
#include "rpc.h"
#include "rpcdce.h"
#include <dfsheader.h>
#include <dfsmisc.h>
#include "lm.h"
#include "lmdfs.h"

DFSSTATUS
DfsGenerateUuidString(
    LPWSTR *UuidString )
{
    UUID NewUid;
    RPC_STATUS RpcStatus;
    DFSSTATUS Status = ERROR_GEN_FAILURE;

    RpcStatus = UuidCreate(&NewUid);
    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = UuidToString( &NewUid,
                                  UuidString );
        if (RpcStatus == RPC_S_OK)
        {
            Status = ERROR_SUCCESS;
        }
    }

    return Status;
}

VOID
DfsReleaseUuidString(
    LPWSTR *UuidString )
{
    RpcStringFree(UuidString);
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodeString
//
//  Arguments:    pDest - the destination unicode string
//                pSrc - the source unicode string
//
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a new unicode string that is a copy
//               of the original. The copied unicode string has a buffer
//               that is null terminated, so the buffer can be used as a
//               normal string if necessary.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodeString( 
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc ) 
{
    LPWSTR NewString;

    NewString = malloc(pSrc->Length + sizeof(WCHAR));
    if ( NewString == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory( NewString, pSrc->Buffer, pSrc->Length);
    NewString[ pSrc->Length / sizeof(WCHAR)] = UNICODE_NULL;

    RtlInitUnicodeString( pDest, NewString );

    return ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodeStringFromString
//
//  Arguments:    pDest - the destination unicode string
//                pSrcString - the source string
//
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a new unicode string that has a copy
//               of the passed in source string. The unicode string has
//               a buffer that is null terminated, so the buffer can be
//               used as a normal string if necessary.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodeStringFromString( 
    PUNICODE_STRING pDest,
    LPWSTR pSrcString ) 
{
    UNICODE_STRING Source;

    RtlInitUnicodeString( &Source, pSrcString );

    return DfsCreateUnicodeString( pDest, &Source );
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodePathString
//
//  Arguments:  pDest - the destination unicode string
//              Number of leading seperators.
//              pFirstComponent - the first componet of the name.
//              pRemaining - the rest of the name.
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a pathname given two components.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//               it just creates a name that is formed by
//               combining the first component, followed by a \ followed
//               by the rest of the name.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodePathStringFromUnicode( 
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    PUNICODE_STRING pFirst,
    PUNICODE_STRING pRemaining )
{
    ULONG NameLen = 0;
    LPWSTR NewString;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NewOffset, Index;
    
    if (NumberOfLeadingSeperators > 2)
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (Index = 0; (Index < pFirst->Length) && (NumberOfLeadingSeperators != 0); Index++)
    {
        if (pFirst->Buffer[Index] != UNICODE_PATH_SEP)
        {
            break;
        }
        NumberOfLeadingSeperators--;
    }

    NameLen += NumberOfLeadingSeperators * sizeof(WCHAR);

    NameLen += pFirst->Length;

    if (IsEmptyString(pRemaining->Buffer) == FALSE)
    {
        NameLen += sizeof(UNICODE_PATH_SEP);
        NameLen += pRemaining->Length;
    }
        
    NameLen += sizeof(UNICODE_NULL);

    if (NameLen > MAXUSHORT)
    {
        return ERROR_INVALID_PARAMETER;
    }
    NewString = malloc( NameLen );

    if (NewString != NULL)
    {
        RtlZeroMemory( NewString, NameLen );
        for (NewOffset = 0; NewOffset < NumberOfLeadingSeperators; NewOffset++)
        {
            NewString[NewOffset] = UNICODE_PATH_SEP;
        }
        RtlCopyMemory( &NewString[NewOffset], pFirst->Buffer, pFirst->Length);
        NewOffset += (pFirst->Length / sizeof(WCHAR));
        if (pRemaining)
        {
            NewString[NewOffset++] = UNICODE_PATH_SEP;
            RtlCopyMemory( &NewString[NewOffset], pRemaining->Buffer, pRemaining->Length);
            NewOffset += (pRemaining->Length / sizeof(WCHAR));
        }

        NewString[NewOffset] = UNICODE_NULL;

        RtlInitUnicodeString(pDest, NewString);
    }
    else 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateUnicodePathString
//
//  Arguments:  pDest - the destination unicode string
//              DosUncName - Do we want to create a unc path name?
//              pFirstComponent - the first componet of the name.
//              pRemaining - the rest of the name.
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine creates a pathname given two components.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//               it just creates a name that is formed by
//               combining the first component, followed by a \ followed
//               by the rest of the name.
//               If it is DOS unc name, it creates a name prefixed with 
//               \\.
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateUnicodePathString( 
    PUNICODE_STRING pDest,
    ULONG NumberOfLeadingSeperators,
    LPWSTR pFirstComponent,
    LPWSTR pRemaining )
{
    ULONG NameLen = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING FirstComponent;
    UNICODE_STRING Remaining;

    RtlInitUnicodeString( &FirstComponent, pFirstComponent);
    RtlInitUnicodeString( &Remaining, pRemaining);

    Status = DfsCreateUnicodePathStringFromUnicode( pDest,
                                                    NumberOfLeadingSeperators,
                                                    &FirstComponent,
                                                    &Remaining );
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFreeUnicodeString
//
//  Arguments:  pString - the unicode string,
//              
//  Returns:   SUCCESS or error
//
//  Description: This routine frees up a unicode string that was 
//               previously created by calling one of the above 
//               routines.
//               Only the unicode strings created by the above functions
//               are valid arguments. Passing any other unicode string
//               will result in fatal component errors.
//--------------------------------------------------------------------------
VOID
DfsFreeUnicodeString( 
    PUNICODE_STRING pDfsString )
{
    if (pDfsString->Buffer != NULL)
    {
        free (pDfsString->Buffer);
    }
}


ULONG
DfsApiSizeLevelHeader(
    ULONG Level )
{
    ULONG ReturnSize = 0;
    switch (Level)
    {

    case 4: 
        ReturnSize = sizeof(DFS_INFO_4);
        break;

    case 3:
        ReturnSize = sizeof(DFS_INFO_3);
        break;

    case 2:
        ReturnSize = sizeof(DFS_INFO_2);
        break;

    case 1:
        ReturnSize = sizeof(DFS_INFO_1);
        break;

    default:
        break;

    }

    return ReturnSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\misc\packmisc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "dfsheader.h"
#include "dfsmisc.h"

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

    //+-------------------------------------------------------------------------
    //
    //  Function PackGetULong
    //
    //  Arguments:  pValue - pointer to return info
    //              ppBuffer - pointer to buffer that holds the binary 
    //              stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one ulong value from the binary
    //               stream, and returns that value. It adjusts the buffer
    //               pointer and remaining size appropriately to point
    //               to the next value in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackGetULong(
        PULONG pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(ULONG);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            *pValue = (ULONG) ( pBinaryStream[0]       |
                                pBinaryStream[1] << 8  |
                                pBinaryStream[2] << 16 |
                                pBinaryStream[3] );

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //  
    //  Function:   PackSetULong - store one Ulong in the binary stream
    //
    //  Arguments:  Value - Ulong to add
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size remaining in buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine stores one ulong value in the binary stream,
    //               It adjusts the buffer pointer and remaining size 
    //               appropriately to point to the next value
    //               in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetULong(
        ULONG Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS  Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(ULONG);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pBinaryStream[0] = BYTE_0( Value );
            pBinaryStream[1] = BYTE_1( Value );
            pBinaryStream[2] = BYTE_2( Value );
            pBinaryStream[3] = BYTE_3( Value );
        
            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //
    // Function: PackSizeULong, return size of ulong
    //
    ULONG
    PackSizeULong()
    {
        return sizeof(ULONG);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetUShort - get one UShort from the binary stream
    //
    //  Arguments:  pValue - pointer to return info
    //              ppBuffer - pointer to buffer that holds the binary 
    //              stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one uShort value from the binary 
    //               stream, and returns that value. It adjusts the 
    //               buffer pointer and remaining size appropriately to 
    //               point to the next value in the binary stream.
    //
    //--------------------------------------------------------------------------    
    DFSSTATUS
    PackGetUShort(
        PUSHORT pValue,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(USHORT);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            *pValue = (USHORT)( pBinaryStream[0] |
                                pBinaryStream[1] << 8 );

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);


            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetUShort - puts one UShort in the binary stream
    //
    //  Arguments:  Value - Ushort value
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack 
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine puts one uShort value in the binary stream,
    //               It adjusts the buffer pointer and
    //               remaining size appropriately to point to the next value
    //               in the binary stream.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetUShort(
        USHORT Value,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS  Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(USHORT);
        PUCHAR pBinaryStream = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pBinaryStream[0] = BYTE_0(Value);
            pBinaryStream[1] = BYTE_1(Value);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);

            *pSizeRemaining -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }
        return Status;
    }

    //
    // Function: PackSizeUShort, return size of ushort
    //
    ULONG
    PackSizeUShort()
    {
        return sizeof(USHORT);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetString - gets a string from a binary stream.
    //
    //  Arguments:  pString - pointer to returned unicode string
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the name info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine reads one ulong value from the binary stream,
    //               and determines that to be the length of the string.
    //               It then sets up a unicode string, whose buffer points
    //               to the appropriate place within the binary stream, and 
    //               whose length is set to the ulong value that was read.
    //               It returns the buffer and size remaining adjusted appropriately.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackGetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS ReturnStatus = ERROR_INVALID_DATA;
        DFSSTATUS Status;

        //
        // We first get the length of the string.
        //
        Status = PackGetUShort(&pString->Length,
                                  ppBuffer,
                                  pSizeRemaining );

        if ( Status == ERROR_SUCCESS )
        {
            //
            // If the length exceeds the remaining binary stream or the length
            // is odd, we dont have a valid string.
            // Otherwise, set the pointer in the unicode string to the binary
            // stream representing the string, and update the buffer to point
            // to beyond the string.
            //
            if ( *pSizeRemaining >= pString->Length &&
                 (pString->Length & 0x1) == 0 )
            {

                pString->Buffer = (LPWSTR)(*ppBuffer);
                *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + pString->Length);
                *pSizeRemaining -= pString->Length;
                pString->MaximumLength = pString->Length;

                ReturnStatus = ERROR_SUCCESS;
            }
        }

        return ReturnStatus;
    }



    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetString - puts a string in the binary stream.
    //
    //  Arguments:  pString - pointer to unicode string to pack
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine puts one ulong value in the binary stream
    //               to represent length of string. It then copies the string
    //               itself into the buffer.
    //
    //--------------------------------------------------------------------------
    DFSSTATUS
    PackSetString(
        PUNICODE_STRING pString,
        PVOID *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS ReturnStatus = ERROR_INVALID_DATA;
        DFSSTATUS Status;

        //
        // We first set the length of the string.
        //

        Status = PackSetUShort( pString->Length,
                                   ppBuffer,
                                   pSizeRemaining );

        if ( Status == ERROR_SUCCESS )
        {
            //
            // If the length exceeds the remaining binary stream 
            // we dont have a valid string.
            // Otherwise, we copy the unicode string to the binary
            // stream representing the string, and update the buffer to point
            // to beyond the string.
            //
            if ( *pSizeRemaining >= pString->Length )
            {
                memcpy((LPWSTR)(*ppBuffer), pString->Buffer, pString->Length);

                *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + pString->Length);
                *pSizeRemaining -= pString->Length;

                ReturnStatus = ERROR_SUCCESS;
            }
        }

        return ReturnStatus;
    }

    //
    // Function: PackSizeString - return size of string
    //
    ULONG
    PackSizeString(
        PUNICODE_STRING pString)
    {
        return (ULONG)(sizeof(USHORT) + pString->Length);
    }

    //+-------------------------------------------------------------------------
    //
    //  Function:   PackGetGuid - Unpacks the guid from a binary stream
    //
    //  Arguments:  pGuid - pointer to a guid structure
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could unpack the info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine expects the binary stream to hold a guid.
    //               It reads the guid information into the guid structure in
    //               the format prescribed for guids.
    //               The ppbuffer and size are adjusted to point to the next
    //               information in the binary stream.
    //
    //--------------------------------------------------------------------------

    DFSSTATUS
    PackGetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(GUID);
        PUCHAR pGuidInfo = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pGuid->Data1 = (ULONG) (pGuidInfo[0]       | 
                                    pGuidInfo[1] << 8  |
                                    pGuidInfo[2] << 16 |
                                    pGuidInfo[3] << 24  );

            pGuid->Data2 = (USHORT) (pGuidInfo[4]       | 
                                     pGuidInfo[5] << 8   );

            pGuid->Data3 = (USHORT) (pGuidInfo[6]       | 
                                     pGuidInfo[7] << 8   );

            memcpy(pGuid->Data4, &pGuidInfo[8], 8);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining   -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }

        return Status;
    }


    //+-------------------------------------------------------------------------
    //
    //  Function:   PackSetGuid - Packs the guid from a binary stream
    //
    //  Arguments:  pGuid - pointer to a guid structure
    //              ppBuffer - pointer to buffer that holds the binary stream.
    //              pSizeRemaining - pointer to size of above buffer
    //
    //  Returns:    Status
    //               ERROR_SUCCESS if we could pack the info
    //               ERROR_INVALID_DATA otherwise
    //
    //
    //  Description: This routine stores the guid into the binary stream.
    //               The ppbuffer and size are adjusted to point to the next
    //               information in the binary stream.
    //
    //--------------------------------------------------------------------------

    DFSSTATUS
    PackSetGuid(
        GUID *pGuid,
        PVOID  *ppBuffer,
        PULONG  pSizeRemaining )
    {
        DFSSTATUS Status = ERROR_INVALID_DATA;
        ULONG SizeNeeded = sizeof(GUID);
        PUCHAR pGuidInfo = (PUCHAR)(*ppBuffer);

        if ( *pSizeRemaining >= SizeNeeded )
        {
            pGuidInfo[0] = BYTE_0(pGuid->Data1);
            pGuidInfo[1] = BYTE_1(pGuid->Data1);
            pGuidInfo[2] = BYTE_2(pGuid->Data1);
            pGuidInfo[3] = BYTE_3(pGuid->Data1);

            pGuidInfo[4] = BYTE_0(pGuid->Data2);
            pGuidInfo[5] = BYTE_1(pGuid->Data2);
            
            pGuidInfo[6] = BYTE_0(pGuid->Data3);
            pGuidInfo[7] = BYTE_1(pGuid->Data3);

            memcpy(&pGuidInfo[8], pGuid->Data4, 8);

            *ppBuffer = (PVOID)((ULONG_PTR)*ppBuffer + SizeNeeded);
            *pSizeRemaining   -= SizeNeeded;

            Status = ERROR_SUCCESS;
        }
        return Status;
    }


    //
    // Function: PackSizeGuid - return size of Guid
    //
    ULONG
    PackSizeGuid()
    {
        return sizeof(GUID);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\prefix\name_table.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.c
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------
#define NAME_TABLE_C
#ifdef KERNEL_MODE

#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <wmlkm.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#include "name_table.h"




//+-------------------------------------------------------------------------
//
//  Function:   DfsInitNameTable - Creates and initializes the DFS Name table.
//
//  Synopsis:   DfsInitNameTable allocates space for the space table. It then 
//              initializes the lock and the hash buckets in the table and 
//              returns the allocated name table.
//
//  Arguments:  NumBuckets - Number of Buckets in the name table hash.
//              ppNameTable - Pointer to name table pointer.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could allocate the table.
//               STATUS_INSUFFICIENT_RESOURCES otherwise.
//
//
//  Description: The DFS NameTable is the starting point for all DFS namespace
//               lookups. The NameTable hash buckets hold the root objects of
//               all DFS's known to this server. The hash is based on the
//               netbios DFS Naming context (which is the netbios 
//               domain/forest/machine name and the DFS Share name of the form
//              \NetbiosName\\Sharename.)
//
//--------------------------------------------------------------------------


NTSTATUS
DfsInitializeNameTable(
                IN ULONG NumBuckets,
                OUT PDFS_NAME_TABLE *ppNameTable)
{
    PDFS_NAME_TABLE pNameTable;
    PDFS_NAME_TABLE_BUCKET pBucket;
    ULONG HashTableSize;
    PCRITICAL_SECTION pLock;
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;


    if ( NumBuckets == 0 ) {
        NumBuckets = DEFAULT_NAME_TABLE_SIZE;
    }

    HashTableSize = sizeof(DFS_NAME_TABLE) + 
                    NumBuckets * sizeof(DFS_NAME_TABLE_BUCKET);

    pNameTable = ALLOCATE_MEMORY(HashTableSize + sizeof(CRITICAL_SECTION));

    if ( pNameTable != NULL ) {

        RtlZeroMemory(pNameTable, HashTableSize + sizeof(CRITICAL_SECTION));

        DfsInitializeHeader( &(pNameTable->DfsHeader),
                             DFS_OT_NAME_TABLE,
                             HashTableSize + sizeof(CRITICAL_SECTION));

        pLock = (PCRITICAL_SECTION)((ULONG_PTR)pNameTable + HashTableSize);
        InitializeCriticalSection(pLock);

        pNameTable->NumBuckets = NumBuckets;
        pNameTable->pLock = (PVOID)pLock;
        pNameTable->Flags = 0;
        for ( i = 0; i < NumBuckets; i++ ) {
            pBucket = &(pNameTable->HashBuckets[i]);

            InitializeListHead(&pBucket->ListHead);
            pBucket->Count = 0;

        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Status == STATUS_SUCCESS ) {
        *ppNameTable = pNameTable;
    }


    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsInsertInNameTable - Inserts the passed in Entry into table
//
//  Synopsis:   DfsInsertInNameTable checks and makes sure that another entry
//              with matching name does not already exist in the table.
//              It Inserts the passed in Entry in the appropriate hash bucket,
//              The callers needs to take a reference on the object and this
//              reference is passed on to the name table. The name table does
//              not explicitly take a reference on the Entry object.
//
//
//  Arguments:  pEntry - The Entry to be inserted
//
//  Returns:    Status
//               STATUS_OBJECT_NAME_COLLISION if name already exists in table
//               STATUS_SUCCESS otherwise
//
//
//  Description: The object representing the entry is assumed to be completely
//               setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               find the entry.
//               This call checks the name table to see if the Named Entry in 
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appro<priate
//               bucket, and we are done.
//               A reference is held on the Entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               Entry or destro<y it.)
//               This reference is released when the Entry is removed from the
//                name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInsertInNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pName,
    IN PVOID pData )
{
    ULONG BucketNum;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_NAME_TABLE_ENTRY  pEntry;
    PDFS_NAME_TABLE_ENTRY  pMatchingEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;

    GET_NAME_TABLE_BUCKET(pName, pNameTable, BucketNum);

    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];


    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access it
    // after the bucket lock is released)

    Status = DfsCheckNameTable( pName,
                                pBucket,
                                &pMatchingEntry);

    // If the name already exists, then we fail the request. For all other
    // error conditions except OBJECT_NOT_FOUND, return failure status intact.
    // In case the object is not found, it is safe to insert this in the bucket,
    // and return success.
    if ( Status == STATUS_SUCCESS ) {
        Status = STATUS_OBJECT_NAME_COLLISION;
    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        pEntry = ALLOCATE_MEMORY(sizeof(DFS_NAME_TABLE_ENTRY));
        if (pEntry != NULL) {
            pEntry->pName = pName;
            pEntry->pData = pData;
            InsertHeadList(&pBucket->ListHead, &pEntry->NameTableLink);
            pBucket->Count++;
            Status = STATUS_SUCCESS;
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupNameTable - Looks for a name in the name table
//
//  Arguments:  lookupName - Unicode string of Entry
//              lookupNC   - The Naming Context of interest
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: The Entry is assumed to be completely setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               lookup the entry.
//               This call checks the name table to see if the Named entry in the
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appropriate
//               bucket, and we are done.
//               A reference is held on the entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               entry or destroy it.)
//               This reference is released when the entry is removed from the
//               name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsLookupNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pLookupName, 
    OUT PVOID *ppData )
{

    ULONG BucketNum;
    NTSTATUS Status;
    PDFS_NAME_TABLE_BUCKET pBucket;
    PDFS_NAME_TABLE_ENTRY pMatchEntry;
    
    GET_NAME_TABLE_BUCKET( pLookupName, pNameTable, BucketNum );

    pBucket = &pNameTable->HashBuckets[BucketNum];

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pMatchEntry );
    if (Status == STATUS_SUCCESS) {
        *ppData = pMatchEntry->pData;
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsGetEntryNameTableLocked - Looks for a name in the name table
//
//  Arguments:  lookupName - Unicode string of Entry
//              lookupNC   - The Naming Context of interest
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: The Entry is assumed to be completely setup at the point it is
//               inserted in the name table. Future lookup requests will 
//               lookup the entry.
//               This call checks the name table to see if the Named entry in the
//               specified Naming Context already exists. If it does, we cannot
//               insert this entry, and return STATUS_OBJECT_NAME_COLLISION.
//               In all other cases, the entry is inserted in the appropriate
//               bucket, and we are done.
//               A reference is held on the entry that is added to the name table.
//               This reference needs to be taken by the caller of this function.
//               The caller passes on that reference to the name table if this 
//               function returns STATUS_SUCCESS. (In all other cases, the 
//               caller needs to take appropriate action: either dereference the
//               entry or destroy it.)
//               This reference is released when the entry is removed from the
//               name table. 
//
//--------------------------------------------------------------------------

NTSTATUS
DfsGetEntryNameTableLocked(
    IN PDFS_NAME_TABLE pNameTable,
    OUT PVOID *ppData )
{

    ULONG BucketNum;
    NTSTATUS Status = STATUS_NOT_FOUND;

    PDFS_NAME_TABLE_BUCKET pBucket;
    PDFS_NAME_TABLE_ENTRY pEntry;
    PLIST_ENTRY pListHead, pLink;

    for (BucketNum = 0; BucketNum < pNameTable->NumBuckets; BucketNum++)
    {
        pBucket = &pNameTable->HashBuckets[BucketNum];
        if (pBucket->Count == 0)
        {
            continue;
        }
        pListHead = &pBucket->ListHead;
        pLink = pListHead->Flink;
        if (pLink == pListHead)
        {
            continue;
        }

        pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

        *ppData = pEntry->pData;
        Status = STATUS_SUCCESS;
        break;
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCheckNameTable - Check for a name in the name table
//
//  Arguments:  lookupName - Unicode string of name
//              lookupNC   - The DFS Naming Context of interest
//              pBucket    - The bucket of interest.
//              ppMatchEntry - The matching entry to return if found.
//
//  Returns:    Status
//               STATUS_OBJECT_NOT_FOUND  if the matching name and NC is not
//                       found in the name table.
//               STATUS_SUCCESS Otherwise.
//             
//
//  Description: It is assumed that appropriate locks are taken to traverse
//               the links in the bucket.
//               If an entry is found, it is returned without taking any
//               references on the found object.
//--------------------------------------------------------------------------


NTSTATUS
DfsCheckNameTable(
    IN PUNICODE_STRING pLookupName, 
    IN PDFS_NAME_TABLE_BUCKET pBucket,
    OUT PDFS_NAME_TABLE_ENTRY *ppMatchEntry )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PLIST_ENTRY pListHead, pLink;
    PDFS_NAME_TABLE_ENTRY pEntry;

    pListHead = &pBucket->ListHead;

    for ( pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink ) {

        pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

        // If we find a matching Name, check if we are interested in a 
        // specific Naming context. If no naming context is specified, or the 
        // specified naming context matches, we have found our entry. Get a 
        // reference on the entry while the bucket is locked so the entry does 
        // not go away, and we can return avalid pointer to the caller.
        // The caller is responsible for releasing this reference.
        if (RtlCompareUnicodeString(pEntry->pName, pLookupName, TRUE) == 0) {
            Status = STATUS_SUCCESS;
            break;
        }

    }

    // If we did find an entry, return it
    if ( Status == STATUS_SUCCESS ) {
        *ppMatchEntry = pEntry;
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromNameTable - Removes the specified entry
//                                       from the name table
//
//  Arguments:  pEntry - The entry to be removed.
//
//  Returns:    Status
//               STATUS_SUCCESS if the specified entry was successfully removed.
//               STATUS_NOT_FOUND if the specifed entry is not the entry in the 
//                       table for that entry name.
//               STATUS_OBJECT_NAME_NOT_FOUND  if the entry name does not exist 
//                       in the table
//
//  Description: The passed in entry is expected to a valid pointer that will 
//               not be freed up while we are referencing it.
//               We check for an object in the name table for a matching name.
//               If the object in the name table matches the passed in object,
//               we can safely remove it from the name table. When we do so,
//               we also release the reference on the object that was held
//               when the object was inserted into the table.
//               If the object is not found or the object does not match the
//               one in the table, error status is returned.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRemoveFromNameTableLocked(
    IN struct _DFS_NAME_TABLE *pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN PVOID pData )

{
    NTSTATUS Status;
    PDFS_NAME_TABLE_ENTRY pMatchingEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;
    ULONG BucketNum;


    GET_NAME_TABLE_BUCKET(pLookupName, pNameTable, BucketNum );
    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];

    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access 
    // it after the bucket lock is released)

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pMatchingEntry);


    // If we found an entry for the specified Name and NC, and the entry
    //  matches the pointer passed in, we remove the entry from the bucket. 
    // If the object does not match, we set the status to STATUS_NOT_FOUND,
    //  to indicate that the name of the object exists in the table, but 
    // the object in the table is different.

    if ( Status == STATUS_SUCCESS ) {
        if ( (pData == NULL) || (pMatchingEntry->pData == pData) ) {
            RemoveEntryList(&pMatchingEntry->NameTableLink);
            FREE_MEMORY( pMatchingEntry );
            pBucket->Count--;
        } else {
            Status = STATUS_NOT_FOUND;
        }
    }

    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsReplaceInNameTable - Removes an entry by the specified name, 
//                                      if one exists. The passed in entry is 
//                                      inserted into the table.
//
//  Arguments:  pNewEntry - The entry to be inserted in the table
//
//  Returns:    Status
//               STATUS_SUCCESS if the passed in entry was inserted in the table
//
//  Description: The caller needs to hold a reference to the passed in entry, 
//               and this reference is transferred to the name table.
//               If the name exists in the name table, the object is removed
//               from the nametable and its reference is discarded.
//               The passed in object is inserted in the same bucket.
//               This call allows an atomic replace of the entry object, 
//               avoiding a window during which a valid name may not be found
//               in the name table.
//
//               Note that the newentry being passed in may already be
//               in the table (due to multiple threads doing this work) so
//               that special situation should work.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsReplaceInNameTableLocked (
    IN PDFS_NAME_TABLE pNameTable,
    IN PUNICODE_STRING pLookupName,
    IN OUT PVOID *ppData )
{
    PDFS_NAME_TABLE_ENTRY pEntry;
    PDFS_NAME_TABLE_BUCKET pBucket;
    ULONG BucketNum;
    PVOID pOldData = NULL;
    NTSTATUS Status;

    GET_NAME_TABLE_BUCKET(pLookupName, pNameTable, BucketNum );
    // No lock necessary to get the list head. The nametable is static.
    pBucket = &pNameTable->HashBuckets[BucketNum];

    // Check Name table will check the specified name in the given bucket.
    // and returns the status of the check. This call does not hold a reference
    // on the matching entry, if one exists. So handle with care. (Dont access
    // it after the bucket lock is released)

    Status = DfsCheckNameTable( pLookupName,
                                pBucket,
                                &pEntry );

    // If we found a matching name, we remove it from the name table.
    if ( Status == STATUS_SUCCESS ) {
        pOldData = pEntry->pData;
        pEntry->pName = pLookupName;
        pEntry->pData = *ppData;
    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        pEntry = ALLOCATE_MEMORY(sizeof(DFS_NAME_TABLE_ENTRY));
        if (pEntry != NULL) {
            pEntry->pName = pLookupName;
            pEntry->pData = *ppData;
            InsertHeadList(&pBucket->ListHead, &pEntry->NameTableLink);
            pBucket->Count++;

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        *ppData = pOldData;
    }

    return Status;
}



VOID
DumpNameTable(
    PDFS_NAME_TABLE pNameTable )
{
    PDFS_NAME_TABLE_BUCKET pBucket;
    PLIST_ENTRY pListHead, pLink;
    PDFS_NAME_TABLE_ENTRY pEntry;
    ULONG i;

    printf("Table %p type %x size %d RefCnt %d\n",
           pNameTable, 
           DfsGetHeaderType(&pNameTable->DfsHeader),
           DfsGetHeaderSize(&pNameTable->DfsHeader),
           DfsGetHeaderCount(&pNameTable->DfsHeader));

    printf("Number of buckets %d\n", pNameTable->NumBuckets);

    for ( i = 0; i < pNameTable->NumBuckets; i++ ) {
        pBucket = &pNameTable->HashBuckets[i];
        if ( pBucket->Count == 0 )
            continue;

        printf("Bucket %d Count in bucket %d\n",
               i,
               pBucket->Count);

        pListHead = &pBucket->ListHead;
        for ( pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink ) {
            pEntry = CONTAINING_RECORD(pLink, DFS_NAME_TABLE_ENTRY, NameTableLink);

            printf("Found entry %p Name %wZ\n",
                   pEntry, pEntry->pName);
        }
    }
    return;
}



NTSTATUS
DfsDismantleNameTable(
    PDFS_NAME_TABLE pNameTable )

{
    PDFS_NAME_TABLE_BUCKET pBucket;
    PLIST_ENTRY pListHead, pLink, pCurrent;
    PDFS_NAME_TABLE_ENTRY pEntry;
    ULONG i;

    for ( i = 0; i < pNameTable->NumBuckets; i++ ) {
        pBucket = &pNameTable->HashBuckets[i];

        pListHead = &pBucket->ListHead;
        for ( pLink = pListHead->Flink; pLink != pListHead; ) {
            pCurrent = pLink;
            pLink = pLink->Flink;
            pEntry = CONTAINING_RECORD(pCurrent, DFS_NAME_TABLE_ENTRY, NameTableLink);
            RemoveEntryList( pCurrent );
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DfsReferenceNameTable(
    IN PDFS_NAME_TABLE pNameTable)
{

    PDFS_OBJECT_HEADER pHeader = &pNameTable->DfsHeader;
    USHORT headerType = DfsGetHeaderType( pHeader );

    if ( headerType != DFS_OT_NAME_TABLE ) {
        return STATUS_UNSUCCESSFUL;
    }

    DfsIncrementReference( pHeader );

    return STATUS_SUCCESS;

}

NTSTATUS
DfsDereferenceNameTable(
    IN PDFS_NAME_TABLE pNameTable)

{

    PDFS_OBJECT_HEADER pHeader = &pNameTable->DfsHeader;
    USHORT headerType = DfsGetHeaderType( pHeader );
    LONG Ref;

    if ( headerType != DFS_OT_NAME_TABLE ) {
        return STATUS_UNSUCCESSFUL;
    }

    Ref = DfsDecrementReference( pHeader );
    if (Ref == 0) {
        DeleteCriticalSection(pNameTable->pLock);

        FREE_MEMORY(pNameTable);
    }

    return STATUS_SUCCESS;


}


NTSTATUS
DfsNameTableAcquireWriteLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DFS_LOCK_NAME_TABLE(pNameTable, Status);

    return Status;

}


NTSTATUS
DfsNameTableAcquireReadLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    DFS_LOCK_NAME_TABLE(pNameTable, Status);

    return Status;

}

NTSTATUS
DfsNameTableReleaseLock(
    IN PDFS_NAME_TABLE pNameTable )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DFS_UNLOCK_NAME_TABLE(pNameTable);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\misc\pathmisc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Registry_Store.c
//
//  Contents:   methods to read information from the registry.
//
//  History:    udayh: created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <lm.h>
#include <dfsheader.h>
#include <dfsmisc.h>


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetNetbiosName - Gets the netbios name of a machine
//
//  Synopsis:   DfsGetNetbiosName takes the name and returns 2 components
//              of the name: the first is the name without the leading \\
//              and upto the next "." or "\". The rest of the path (if any)
//              is returned in the pRemaining argument.
//
//  Arguments:  pName - Input name
//              pNetbiosName -  the netbios name for the passed in name
//              pRemaining   - The rest of the name beyond the netbios name
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

VOID
DfsGetNetbiosName(
    PUNICODE_STRING pName,
    PUNICODE_STRING pNetbiosName,
    PUNICODE_STRING pRemaining )
{

    USHORT i = 0, j;

    RtlInitUnicodeString(pNetbiosName, NULL);
    if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

    for (; i < pName->Length/sizeof(WCHAR); i++) {
        if (pName->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
        if ((pName->Buffer[j] == UNICODE_PATH_SEP) ||
            (pName->Buffer[j] == L'.')) {
            break;
        }
    }
   
    if (j != i) {
        pNetbiosName->Buffer = &pName->Buffer[i];
        pNetbiosName->Length = (USHORT)((j - i) * sizeof(WCHAR));
        pNetbiosName->MaximumLength = pNetbiosName->Length;
    }
   

    for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
        if ((pName->Buffer[i] != UNICODE_PATH_SEP) &&
            (pName->Buffer[i] != L'.')) {
            break;
        }
    }
    
    j = pName->Length/sizeof(WCHAR);

    if ((pRemaining) && (j != i)) {
        pRemaining->Buffer = &pName->Buffer[i];
        pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
        pRemaining->MaximumLength = pRemaining->Length;
    }

    return NOTHING;

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsGetPathComponents - Breaks pathname into server, share,rest
//
//  Synopsis:   DfsGetPathComponents takes the name and returns 3 components
//              of the name: the first (ServerName), the next (ShareName) and the//              last (Remaining Name)
//
//  Arguments:  pName - Input name
//              pServerName - The first path component
//              pShareName - The second path component
//              pRemaining   - The rest of the path component
//
//  Returns:    STATUS: STATUS_INVALID_PARAMETER or Success
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsGetPathComponents(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = STATUS_INVALID_PARAMETER;

   RtlInitUnicodeString(pServerName, NULL);
   if (pShareName)    RtlInitUnicodeString(pShareName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if (j != i) {
     pServerName->Buffer = &pName->Buffer[i];
     pServerName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pServerName->MaximumLength = pServerName->Length;
     
     Status = ERROR_SUCCESS;
   }
   
   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }
   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if ((pShareName) && (j != i)) {
     pShareName->Buffer = &pName->Buffer[i];
     pShareName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pShareName->MaximumLength = pShareName->Length;
   }


   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   j = pName->Length/sizeof(WCHAR);

   if ((pRemaining) && (j != i)) {
     pRemaining->Buffer = &pName->Buffer[i];
     pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetFirstComponent - Gets the first part of the pathname
//
//  Synopsis:   DfsGetFirstComponent takes the name and returns 2 components
//              of the name: the first is the first part of the pathname.
//              The rest of the path is returned in the pRemaining argument.
//
//  Arguments:  pName - Input name
//              pFirstName -  First part of the name
//              pRemaining   - The rest of the name beyond the netbios name
//
//  Returns:    STATUS_INVALID_PARAMETER or SUCCESS
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetFirstComponent(
   PUNICODE_STRING pName,
   PUNICODE_STRING pFirstName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = STATUS_INVALID_PARAMETER;

   RtlInitUnicodeString(pFirstName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if (j != i) {
     pFirstName->Buffer = &pName->Buffer[i];
     pFirstName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pFirstName->MaximumLength = pFirstName->Length;
     
     Status = ERROR_SUCCESS;
   }


   i = (j + 1);

   j = pName->Length/sizeof(WCHAR);

   if ((pRemaining) && (j > i)) {
     if (pName->Buffer[i] == UNICODE_PATH_SEP)
     {
         Status = ERROR_INVALID_PARAMETER;
     }
     else {
         pRemaining->Buffer = &pName->Buffer[i];
         pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
         pRemaining->MaximumLength = pRemaining->Length;
     }
   }

   return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetSharePath
//
//  Arguments:  ServerName - the name of the server
//              ShareName - the name of the share
//              pPathName - the unicode string representing the NT name
//                          of the local path representing the share
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a servername and a sharename, and
//               returns an NT pathname to the physical resource that is
//               backing the share name.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetSharePath( 
    IN  LPWSTR ServerName,
    IN  LPWSTR ShareName,
    OUT PUNICODE_STRING pPathName )
{
    LPWSTR UseServerName = NULL;
    ULONG InfoLevel = 2;
    PSHARE_INFO_2 pShareInfo;
    NET_API_STATUS NetStatus;
    DFSSTATUS Status;
    UNICODE_STRING NtSharePath;

    if (IsEmptyString(ServerName) == FALSE)
    {
        UseServerName = ServerName;
    }

    NetStatus = NetShareGetInfo( UseServerName,
                                 ShareName,
                                 InfoLevel,
                                 (LPBYTE *)&pShareInfo );
    if (NetStatus != ERROR_SUCCESS)
    {
        Status = (DFSSTATUS)NetStatus;
        return Status;
    }

    if( RtlDosPathNameToNtPathName_U(pShareInfo->shi2_path,
                                     &NtSharePath,
                                     NULL,
                                     NULL ) == TRUE )
    {
        Status = DfsCreateUnicodeString( pPathName,
                                         &NtSharePath );

        RtlFreeUnicodeString( &NtSharePath );
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    NetApiBufferFree( pShareInfo );
    
    return Status;
}


ULONG
DfsSizeUncPath( 
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent )
{
    ULONG SizeRequired = 0;

    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += FirstComponent->Length;
    SizeRequired += sizeof(UNICODE_PATH_SEP);
    SizeRequired += SecondComponent->Length;
    SizeRequired += sizeof(UNICODE_NULL);

    return SizeRequired;
}

VOID
DfsCopyUncPath( 
    LPWSTR NewPath,
    PUNICODE_STRING FirstComponent,
    PUNICODE_STRING SecondComponent )
{
    ULONG CurrentIndex = 0;

    NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    RtlCopyMemory(&NewPath[CurrentIndex],
                  FirstComponent->Buffer,
                  FirstComponent->Length );
    CurrentIndex += (FirstComponent->Length / sizeof(WCHAR));

    if (NewPath[CurrentIndex] != UNICODE_PATH_SEP &&
        SecondComponent->Buffer[0] != UNICODE_PATH_SEP )
    {
        NewPath[CurrentIndex++] = UNICODE_PATH_SEP;
    }
    RtlCopyMemory(&NewPath[CurrentIndex],
                  SecondComponent->Buffer,
                  SecondComponent->Length );
    CurrentIndex += (SecondComponent->Length / sizeof(WCHAR));

    NewPath[CurrentIndex] = UNICODE_NULL;
}


//
// dfsdev: validate the next two functions. They appear to work,
// but we need to look into the boundary cases.
//

NTSTATUS
StripLastPathComponent( 
    PUNICODE_STRING pPath )
{
    USHORT i = 0, j;
    NTSTATUS Status = STATUS_SUCCESS;

    
    if (pPath->Length == 0)
    {
        return Status;
    }
    for( i = (pPath->Length - 1)/ sizeof(WCHAR); i != 0; i--) {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j != 0; j--){
        if (pPath->Buffer[j] == UNICODE_PATH_SEP) {
            break;
        }
    }

    pPath->Length = (j) * sizeof(WCHAR);
    return Status;
}

NTSTATUS
AddNextPathComponent( 
    PUNICODE_STRING pPath )
{
    USHORT i = 0, j;
    NTSTATUS Status = STATUS_SUCCESS;


    for( i = pPath->Length / sizeof(WCHAR); i < pPath->MaximumLength/sizeof(WCHAR); i++) {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP) {
            break;
        }
    }

    for (j = i; j < pPath->MaximumLength/sizeof(WCHAR); j++) {
        if (pPath->Buffer[j] == UNICODE_PATH_SEP) {
            break;
        }
    }

    pPath->Length = j * sizeof(WCHAR);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\prefix\name_table.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  File:       name_table.h
//
//  Contents:   The DFS Name Table
//
//--------------------------------------------------------------------------


#ifndef __NAME_TABLE_H__
#define __NAME_TABLE_H__

#include <dfsheader.h>
#include <dfsnametable.h>

typedef struct _DFS_NAME_TABLE_BUCKET {
    ULONG Count;
    LIST_ENTRY ListHead;
} DFS_NAME_TABLE_BUCKET, *PDFS_NAME_TABLE_BUCKET;

typedef struct _DFS_NAME_TABLE_ENTRY {
    PUNICODE_STRING pName;
    LIST_ENTRY NameTableLink;
    PVOID pData;
} DFS_NAME_TABLE_ENTRY, *PDFS_NAME_TABLE_ENTRY;

typedef struct _DFS_NAME_TABLE {
    DFS_OBJECT_HEADER DfsHeader;
    ULONG Flags;
    ULONG NumBuckets;
    PVOID pLock;
    DFS_NAME_TABLE_BUCKET HashBuckets[0];
} DFS_NAME_TABLE, *PDFS_NAME_TABLE;

#define NAME_TABLE_LOCKED 1

NTSTATUS
DfsCheckNameTable(
    IN PUNICODE_STRING lookupName, 
    IN PDFS_NAME_TABLE_BUCKET pBucket,
    OUT PVOID *ppData );

#define DEFAULT_NAME_TABLE_SIZE  47

#define DFS_LOCK_NAME_TABLE(_pTable, _sts)\
        __try { EnterCriticalSection((_pTable)->pLock); (_pTable)->Flags |= NAME_TABLE_LOCKED; (_sts) = STATUS_SUCCESS; } \
        __except(EXCEPTION_EXECUTE_HANDLER){(_sts) = STATUS_UNSUCCESSFUL;}         

#define DFS_UNLOCK_NAME_TABLE(_pTable)\
        {(_pTable)->Flags &= ~NAME_TABLE_LOCKED; LeaveCriticalSection((_pTable)->pLock); }


#define GET_NAME_TABLE_BUCKET(_name, _table, BucketNo) \
{                                                                            \
    WCHAR *pPathBuffer   = (_name)->Buffer;                                  \
    WCHAR pCurrent;                                                          \
    WCHAR *pPathBufferEnd = &(pPathBuffer[(_name)->Length / sizeof(WCHAR)]); \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer)  &&                               \
          (*pPathBuffer))                                                    \
    {                                                                        \
        pCurrent = *pPathBuffer++;                                           \
        pCurrent = (pCurrent < L'a')                                         \
                       ? pCurrent                                            \
                       : ((pCurrent < L'z')                                  \
                          ? (pCurrent - L'a' + L'A')                         \
                          : RtlUpcaseUnicodeChar(pCurrent));                 \
        BucketNo *= 131;                                                     \
        BucketNo += pCurrent;                                                \
    }                                                                        \
    BucketNo = BucketNo % ((_table)->NumBuckets);                            \
}

#if defined (PREFIX_TABLE_HEAP_MEMORY)

extern HANDLE PrefixTableHeapHandle;

#define ALLOCATE_MEMORY(_sz) \
        HeapAlloc(PrefixTableHeapHandle, 0, _sz)

#define FREE_MEMORY(_addr) \
        HeapFree(PrefixTableHeapHandle, 0, _addr)

#else

#define ALLOCATE_MEMORY(_sz)\
        malloc(_sz)


#define FREE_MEMORY(_addr) \
        free(_addr)

#endif
        
#endif // __NAME_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\prefix\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIX_H__
#define __PREFIX_H__

#include <dfsheader.h>

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_ENTRY
//
// History:
//
// Notes:   Each DFS_PREFIX_TABLE entry is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DFS_PREFIX_TABLE_ENTRY_
{
   struct _DFS_PREFIX_TABLE_ENTRY_  *pParentEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pNextEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DFS_PREFIX_TABLE_ENTRY_  *pFirstChildEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pSiblingEntry;

   ULONG                             NoOfChildren;

   UNICODE_STRING                    PathSegment;
   PVOID                             pData;
} DFS_PREFIX_TABLE_ENTRY, *PDFS_PREFIX_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_BUCKET
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE_BUCKET is a doubly linked list of
//          DFS_PREFIX_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _PREFIX_TABLE_BUCKET_
{
   ULONG                  NoOfEntries;   // High water mark for entries hashing to the bkt.
   DFS_PREFIX_TABLE_ENTRY SentinelEntry;
} PREFIX_TABLE_BUCKET, *PPREFIX_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE is a hashed collection of DFS_PREFIX_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two pathnames \foo\bar and \bar\foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 57

typedef struct _DFS_PREFIX_TABLE
{
   DFS_OBJECT_HEADER   DfsHeader;
   ULONG               Flags;
   LONG                OwnerCount;
   PVOID               pPrefixTableLock;
   //
   // NextEntry is used purely for enumeration
   //
   PDFS_PREFIX_TABLE_ENTRY NextEntry;
   DFS_PREFIX_TABLE_ENTRY RootEntry;
   PREFIX_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];
} DFS_PREFIX_TABLE, *PDFS_PREFIX_TABLE;

#define PREFIX_TABLE_CASE_SENSITIVE  0x1
#define PREFIX_TABLE_TABLE_ALLOCATED  0x2
#define PREFIX_TABLE_LOCK_ALLOCATED   0x4
#define PREFIX_TABLE_LOCKED           0x8

//--------------------------------------------------------------------------
//
// PREFIX TABLE UTILITIES
//
// A Path is a sequence of one or more name segments alternated with a
// distinguished concatenation character ( typically \ in FAT,NTFS,HPFS and
// / in UNIX file systems). These utilities are used to split a given path
// into the first path segment followed by the remainder of the path.
//
// SPLIT_PATH("foo\bar\bar1",Name,RemainingPath) binds Name to foo and
// RemainingPath to bar\bar1
//
// Similarly PROCESS_CASE_SENSITIVE_NAME and PROCESS_CASE_INSENSITIVE_NAME
// compute the hash signatures ( bucket no. ) for a given string.
//
//--------------------------------------------------------------------------


//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER L'\\'

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_INSENSITIVE_PATH
//
//  Synopsis:   Split the path name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are
//               modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_INSENSITIVE_PATH(pPath,pName,BucketNo)                    \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        *pNameBuffer = (*pNameBuffer < L'a')                                 \
                       ? *pNameBuffer                                        \
                       : ((*pNameBuffer < L'z')                              \
                          ? (*pNameBuffer - L'a' + L'A')                     \
                          : RtlUpcaseUnicodeChar(*pNameBuffer));             \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_SENSITIVE_PATH
//
//  Synopsis:   Split the patah name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_SENSITIVE_PATH(pPath,pName,BucketNo)                      \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
}                                                                            \


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_BUCKET(Bucket)                                           \
{                                                                           \
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;             \
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;             \
   (Bucket).NoOfEntries = 0;                                                \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   LOOKUP_BUCKET
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  [Bucket] -- the bucket to be used (DFS_PREFIX_TABLE_BUCKET)
//
//              [Name]   -- the name to be looked up (UNICODE_STRING)
//
//              [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              [pEntry] -- placeholder for the desired entry.
//
//              [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo\bar and foo1\bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------

#define LOOKUP_BUCKET(Bucket,Name,pParentEntry,pEntry,fNameFound)           \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = Bucket.SentinelEntry.pNextEntry;    \
                                                                            \
    fNameFound = FALSE;                                                     \
    pEntry = NULL;                                                          \
                                                                            \
    while (pCurEntry != &Bucket.SentinelEntry)                              \
    {                                                                       \
        if (pCurEntry->PathSegment.Length == Name.Length)                   \
        {                                                                   \
            if (fNameFound &&                                               \
               (pCurEntry->PathSegment.Buffer == Name.Buffer))              \
            {                                                               \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else if (!memcmp(pCurEntry->PathSegment.Buffer,                 \
                             Name.Buffer,                                   \
                             Name.Length))                                  \
            {                                                               \
                fNameFound = TRUE;                                          \
                Name.Buffer = pCurEntry->PathSegment.Buffer;                \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
        pCurEntry = pCurEntry->pNextEntry;                                  \
    }                                                                       \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_BUCKET(Bucket,pEntry)                                     \
{                                                                           \
    (Bucket).NoOfEntries++;                                                 \
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;               \
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);                       \
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);             \
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);                           \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define REMOVE_FROM_BUCKET(pEntry)                                          \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;              \
    PDFS_PREFIX_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;              \
                                                                            \
    pPrevEntry->pNextEntry = pNextEntry;                                    \
    pNextEntry->pPrevEntry = pPrevEntry;                                    \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_CHILD_LIST(pEntry, pParentEntry)                           \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pLastChild;                                      \
                                                                             \
    if (pParentEntry->pFirstChildEntry == NULL) {                            \
        pParentEntry->pFirstChildEntry = pEntry;                             \
    } else {                                                                 \
        for (pLastChild = pParentEntry->pFirstChildEntry;                    \
                pLastChild->pSiblingEntry != NULL;                           \
                    pLastChild = pLastChild->pSiblingEntry) {                \
             NOTHING;                                                        \
        }                                                                    \
        pLastChild->pSiblingEntry = pEntry;                                  \
    }                                                                        \
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      Defined as a macro for inlining.
//
//              This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

#define REMOVE_FROM_CHILD_LIST(pEntry)                                       \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;             \
    PDFS_PREFIX_TABLE_ENTRY pPrevSibling;                                    \
                                                                             \
    if (pParentEntry->pFirstChildEntry == pEntry) {                          \
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;              \
    } else {                                                                 \
        for (pPrevSibling = pParentEntry->pFirstChildEntry;                  \
                pPrevSibling->pSiblingEntry != pEntry;                       \
                    pPrevSibling = pPrevSibling->pSiblingEntry) {            \
             ASSERT(pPrevSibling->pSiblingEntry != NULL);                    \
        }                                                                    \
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;                 \
    }                                                                        \
}


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_PREFIX_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_PREFIX_TABLE_ENTRY(pEntry)                                \
{                                                                            \
    RtlZeroMemory( pEntry, sizeof( DFS_PREFIX_TABLE_ENTRY ) );               \
    (pEntry)->NoOfChildren = 1;                                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   private fns. extern declarations
//
//----------------------------------------------------------------------------

extern
NTSTATUS _LookupPrefixTable( 
    IN PDFS_PREFIX_TABLE        pTable,
    IN UNICODE_STRING           *pPath,
    OUT UNICODE_STRING           *pSuffix,
    OUT PDFS_PREFIX_TABLE_ENTRY  *ppEntry,
    OUT PBOOLEAN                 pSubStringMatch );


VOID
DfsRemovePrefixTableEntry(
    PDFS_PREFIX_TABLE pTable,
    PDFS_PREFIX_TABLE_ENTRY pEntry );





//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   all the allocation routines are defined to be used in the KERNEL as
//              well as user mode. The KERNEL mode is turned on by defining KERNEL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------


#define IS_PREFIX_TABLE_LOCKED(_pTable) \
        ((_pTable)->Flags & PREFIX_TABLE_LOCKED)
        
#define ALLOCATE_PREFIX_TABLE() \
        PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(DFS_PREFIX_TABLE))

#define FREE_PREFIX_TABLE(_ptable)  \
        PREFIX_TABLE_FREE_MEMORY(_ptable)


#ifdef KERNEL_MODE

#define ALLOCATE_NAME_BUFFER(cLength)                           \
    ExAllocatePoolWithTag(PagedPool, cLength * sizeof(WCHAR), 'PsfD');       \

#define FREE_NAME_BUFFER(pName) ExFreePool(pName);

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                             \
 (PDFS_PREFIX_TABLE_ENTRY) ExAllocatePoolWithTag(PagedPool,sizeof(DFS_PREFIX_TABLE_ENTRY), 'PsfD')


#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry) ExFreePool(pEntry);

#define COMPARE_MEMORY(s,d,l)   (!RtlEqualMemory(s,d,l))

#define PREFIX_TABLE_ALLOCATE_MEMORY(size) ExAllocatePoolWithTag(PagedPool, size, 'PsfD')
#define PREFIX_TABLE_ALLOCATE_NONPAGED_MEMORY(size) ExAllocatePoolWithTag(NonPagedPool, size, 'PsfD')

#define PREFIX_TABLE_FREE_MEMORY(_p) ExFreePool(_p)

#define ALLOCATE_PREFIX_TABLE_LOCK() \
        PREFIX_TABLE_ALLOCATE_NONPAGED_MEMORY(sizeof(ERESOURCE))
        

#define FREE_PREFIX_TABLE_LOCK(_plock) {ExDeleteResourceLite(_plock); PREFIX_TABLE_FREE_MEMORY(_plock);}
        
#define UNLOCK_PREFIX_TABLE(_ptable) {(_ptable)->Flags &= ~PREFIX_TABLE_LOCKED; ExReleaseResourceLite((_ptable)->pPrefixTableLock);}                 

#define WRITE_LOCK_PREFIX_TABLE(_ptable,_sts) {(_sts) = STATUS_UNSUCCESSFUL;if((ExAcquireResourceExclusiveLite((_ptable)->pPrefixTableLock, TRUE) == TRUE)){(_ptable)->Flags |= PREFIX_TABLE_LOCKED;(_sts) = STATUS_SUCCESS;}}


#define READ_LOCK_PREFIX_TABLE(_ptable,_sts) {(_sts) = STATUS_UNSUCCESSFUL;if((ExAcquireResourceSharedLite((_ptable)->pPrefixTableLock, TRUE) == TRUE)){(_ptable)->Flags |= PREFIX_TABLE_LOCKED;(_sts) = STATUS_SUCCESS;}}
#define INITIALIZE_PREFIX_TABLE_LOCK(_plock)  \
   	ExInitializeResourceLite(_plock)

#else


#define ALLOCATE_PREFIX_TABLE_LOCK() \
        PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(CRITICAL_SECTION))
        
#define FREE_PREFIX_TABLE_LOCK(_plock) \
        { DeleteCriticalSection(_plock); PREFIX_TABLE_FREE_MEMORY(_plock);}
        
#define INITIALIZE_PREFIX_TABLE_LOCK(_plock) 	InitializeCriticalSection(_plock)
#define UNLOCK_PREFIX_TABLE(_pTable) {(_pTable)->Flags &= ~PREFIX_TABLE_LOCKED; LeaveCriticalSection((_pTable)->pPrefixTableLock); }

#define READ_LOCK_PREFIX_TABLE(_ptable, _sts)   \
        WRITE_LOCK_PREFIX_TABLE(_ptable, _sts)
        
#define WRITE_LOCK_PREFIX_TABLE(_pTable, _sts ) \
        __try { EnterCriticalSection((_pTable)->pPrefixTableLock); (_pTable)->Flags |= PREFIX_TABLE_LOCKED; (_sts) = STATUS_SUCCESS; } \
        __except(EXCEPTION_EXECUTE_HANDLER){(_sts) = STATUS_UNSUCCESSFUL;} 


#define ALLOCATE_NAME_BUFFER(cLength) \
        PREFIX_TABLE_ALLOCATE_MEMORY(cLength * sizeof(WCHAR))
#define FREE_NAME_BUFFER(_pName)  \
        PREFIX_TABLE_FREE_MEMORY(_pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(_pTable) \
    (PDFS_PREFIX_TABLE_ENTRY)PREFIX_TABLE_ALLOCATE_MEMORY(sizeof(DFS_PREFIX_TABLE_ENTRY))
#define FREE_DFS_PREFIX_TABLE_ENTRY(_pTable,_pEntry) \
    PREFIX_TABLE_FREE_MEMORY(_pEntry)

#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)


#if defined (PREFIX_TABLE_HEAP_MEMORY)

#define PREFIX_TABLE_ALLOCATE_MEMORY(_sz) \
        HeapAlloc(PrefixTableHeapHandle, 0, _sz)

#define PREFIX_TABLE_FREE_MEMORY(_addr) \
        HeapFree(PrefixTableHeapHandle, 0, _addr)

#else

#define PREFIX_TABLE_ALLOCATE_MEMORY(_sz) malloc(_sz)
#define PREFIX_TABLE_FREE_MEMORY(_addr) free(_addr)
#endif


#endif /*!Kernel mode */

#endif // __PREFIX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\prefix\prefix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE


#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#include <prefix.h>
#include <dfsprefix.h>

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
                         IN PDFS_PREFIX_TABLE_ENTRY pEntry);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFreePrefixTable )
#pragma alloc_text( PAGE, DfsInitializePrefixTable )
#pragma alloc_text( PAGE, DfsInsertInPrefixTable )
#pragma alloc_text( PAGE, DfsFindUnicodePrefix )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTable )
#pragma alloc_text( PAGE, _LookupPrefixTable )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTableEx )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTableLockedEx )
#endif  // ALLOC_PRAGMA

#if defined (PREFIX_TABLE_HEAP_MEMORY)
HANDLE PrefixTableHeapHandle = NULL;
#endif

NTSTATUS
DfsPrefixTableInit()
{

#if defined (PREFIX_TABLE_HEAP_MEMORY)

    PrefixTableHeapHandle = HeapCreate(0, 0, 0);
    if ( PrefixTableHeapHandle == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    printf("Prefix table using memory heap\n");
#endif
    return STATUS_SUCCESS;
}


void
DfsPrefixTableShutdown(void)
{

#if defined (PREFIX_TABLE_HEAP_MEMORY)
    if ( PrefixTableHeapHandle != NULL ) 
    {
        HeapDestroy(PrefixTableHeapHandle);
        PrefixTableHeapHandle = NULL;
    }
    printf("Prefix table using memory heap\n");
#endif
}
//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsInitializePrefixTable(
    IN OUT PDFS_PREFIX_TABLE *ppTable, 
    IN BOOLEAN fCaseSensitive,
    IN PVOID Lock)

{
    PDFS_PREFIX_TABLE pTable = *ppTable;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Flags = fCaseSensitive ? PREFIX_TABLE_CASE_SENSITIVE : 0;
    int i;

    if ( pTable == NULL ) {
        Flags |= PREFIX_TABLE_TABLE_ALLOCATED;
        pTable = ALLOCATE_PREFIX_TABLE();
        if ( pTable == NULL )
            Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( NT_SUCCESS(Status) ) {
        RtlZeroMemory(pTable, sizeof(DFS_PREFIX_TABLE));

        DfsInitializeHeader(&pTable->DfsHeader, 
                            DFS_OT_PREFIX_TABLE,
                            sizeof(DFS_PREFIX_TABLE));

        pTable->Flags = Flags;
        pTable->OwnerCount = 1;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for ( i = 0;i < NO_OF_HASH_BUCKETS;i++ ) {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        pTable->pPrefixTableLock = Lock;

        if ( pTable->pPrefixTableLock == NULL ) {
            pTable->pPrefixTableLock = ALLOCATE_PREFIX_TABLE_LOCK();
            if ( pTable->pPrefixTableLock != NULL ) {

                INITIALIZE_PREFIX_TABLE_LOCK(pTable->pPrefixTableLock);
                pTable->Flags |= PREFIX_TABLE_LOCK_ALLOCATED;
            } else {
                if ( pTable->Flags & PREFIX_TABLE_TABLE_ALLOCATED ) {
                    FREE_PREFIX_TABLE(pTable);
                    pTable = NULL;
                }
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    *ppTable = pTable;

    return  Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTableLocked
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInsertInPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    ULONG                   BucketNo = 0;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;
    BOOLEAN                 fInserted = TRUE;
    UNICODE_STRING          Path,Name;

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the >processing upfront.

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];
    pParentEntry = &pTable->RootEntry;

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            pTable->RootEntry.pData = pData;
            return STATUS_SUCCESS;
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    if ( Path.Length > MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = PREFIX_TABLE_ALLOCATE_MEMORY(Path.Length + sizeof(WCHAR));
        if ( NameBuffer == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while ( Path.Length > 0 ) {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if ( pTable->Flags & PREFIX_TABLE_CASE_SENSITIVE ) {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        } else {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if ( Name.Length > 0 ) {
            // Lookup the table to see if the name segment already exists.

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);


            if ( pEntry == NULL ) {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if ( pEntry != NULL ) {
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_BUFFER((Name.Length/sizeof(WCHAR)));

                        if ( pBuffer != NULL ) {
                            RtlZeroMemory(pBuffer,Name.Length);
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        } else {
                            FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pEntry);
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                    }

                    // thread the entry to point to the parent.
                    pEntry->pParentEntry = pParentEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            } else {
                // Increment the no. of children associated with  this entry

                pEntry->NoOfChildren++;   

                fInserted = FALSE;
            }

            pParentEntry = pEntry;
        } else {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if ( NT_SUCCESS(status) ) {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        pEntry->pData = pData;
    } else {
        while ( pParentEntry != NULL ) {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if ( --pMaybeTempEntry->NoOfChildren == 0 ) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if ( pParentEntry != NULL ) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
                    FREE_NAME_BUFFER( pMaybeTempEntry->PathSegment.Buffer );
                    FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pMaybeTempEntry);
                }
            }
        }
    }

    if ( NameBuffer != Buffer ) {
        PREFIX_TABLE_FREE_MEMORY( NameBuffer );
    }

    return status;
}


//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefixLocked
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsFindUnicodePrefixLocked(
    IN PDFS_PREFIX_TABLE   pTable,
    IN PUNICODE_STRING     pPath,
    IN PUNICODE_STRING     pSuffix,
    IN PVOID *ppData,
    OUT PBOOLEAN pSubStringMatch)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    *ppData = NULL;


    if ( pPath->Length == 0 ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry, pSubStringMatch);

        // Update the BLOB placeholder with the results of the lookup.
        if ( status == STATUS_SUCCESS ) {
            *ppData = pEntry->pData;
        }

    }
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsRemoveFromPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) {
        if ( (pMatchingData == NULL) || (pMatchingData == pEntry->pData) ) {
            DfsRemovePrefixTableEntry(pTable, pEntry);
        } else {
            status = STATUS_NOT_FOUND;
        }
    }

    return status;
}


NTSTATUS DfsReplaceInPrefixTableLocked(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID *ppMatchingData)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }


    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) {
        if ( (*ppMatchingData == NULL) || (*ppMatchingData == pEntry->pData) ) {
            *ppMatchingData = pEntry->pData;
            pEntry->pData = pReplaceData;
        } else {
            status = STATUS_NOT_FOUND;
        }
    }

    if ( (status != STATUS_SUCCESS) && (*ppMatchingData == NULL) ) {
        status = DfsInsertInPrefixTableLocked( pTable,
                                               pPath,
                                               pReplaceData );
    }

    return status;
}

VOID
DfsRemovePrefixTableEntry(
    IN PDFS_PREFIX_TABLE pTable,
    IN PDFS_PREFIX_TABLE_ENTRY pEntry )
{
    UNREFERENCED_PARAMETER(pTable);

    // Destroy the association between the data associated with
    // this prefix.
    pEntry->pData = NULL;

    // found an exact match for the given path name in the table.
    // traverse the list of parent pointers and delete them if
    // required.

    while ( pEntry != NULL ) {
        if ( (--pEntry->NoOfChildren) == 0 ) {
            PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
            pEntry = pEntry->pParentEntry;

            //
            // pEntry == NULL means pTempEntry is pTable->RootEntry.
            // Do not try to remove it.
            //
            if ( pEntry != NULL ) {
                REMOVE_FROM_CHILD_LIST(pTempEntry);
                REMOVE_FROM_BUCKET(pTempEntry);
                FREE_NAME_BUFFER( pTempEntry->PathSegment.Buffer );
                FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pTempEntry);
            }
        } else
            break;
    }
    return;
}



//+---------------------------------------------------------------------------
//
//  Function:   DfsFreePrefixTable
//
//  Synopsis:   API for freeing a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    08-01-99 JHarper Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsDismantlePrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN VOID (*ProcessFunction)(PVOID pEntry))

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pSentinelEntry = NULL;
    ULONG i = 0;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    for ( i = 0; i < NO_OF_HASH_BUCKETS; i++ ) {
        pSentinelEntry = &pTable->Buckets[i].SentinelEntry;
        while ( pSentinelEntry->pNextEntry != pSentinelEntry ) {
            pEntry = pSentinelEntry->pNextEntry;
            REMOVE_FROM_BUCKET(pEntry);
            if ( (ProcessFunction) && (pEntry->pData) ) {
                ProcessFunction(pEntry->pData);
            }
            FREE_NAME_BUFFER( pEntry->PathSegment.Buffer );
            FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pEntry);
        }
        pTable->Buckets[i].NoOfEntries = 0;
    }
    if ( pTable->RootEntry.PathSegment.Buffer != NULL )
        FREE_NAME_BUFFER(pTable->RootEntry.PathSegment.Buffer);

    UNLOCK_PREFIX_TABLE(pTable);

done:
    return Status;
}
    
NTSTATUS
DfsDereferencePrefixTable( 
    IN PDFS_PREFIX_TABLE pTable)
{
    PDFS_OBJECT_HEADER pHeader = NULL;
    USHORT headerType = 0;
    LONG Ref = 0;

    if(pTable == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pHeader = &pTable->DfsHeader;

    headerType = DfsGetHeaderType( pHeader );

    if (headerType != DFS_OT_PREFIX_TABLE) {
        return STATUS_UNSUCCESSFUL;
    }

    Ref = DfsDecrementReference( pHeader );
    if (Ref == 0) {

        if(pTable->Flags & PREFIX_TABLE_LOCK_ALLOCATED)
        {
            FREE_PREFIX_TABLE_LOCK(pTable->pPrefixTableLock);
        }

        if ( pTable->Flags & PREFIX_TABLE_TABLE_ALLOCATED ) {
            FREE_PREFIX_TABLE(pTable);
        }

    }
    return  STATUS_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppEntry] -- placeholder for the matching entry for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _LookupPrefixTable(
    PDFS_PREFIX_TABLE        pTable,
    UNICODE_STRING           *pPath,
    UNICODE_STRING           *pSuffix,
    PDFS_PREFIX_TABLE_ENTRY  *ppEntry,
    OUT PBOOLEAN             pSubStringMatch )
{
    NTSTATUS                status = STATUS_SUCCESS;
    UNICODE_STRING          Path = *pPath;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Name;
    ULONG                   BucketNo;
    BOOLEAN                 fPrefixFound = FALSE;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = &pTable->RootEntry;
    BOOLEAN                 fNameFound = FALSE;
    BOOLEAN SubStringMatch = TRUE;



    // The \ is treated as a special case. The test for all names starting with
    // a delimiter is done before we initiate the complete search process.

    if ( Path.Buffer[0] == PATH_DELIMITER ) {
        Path.Length = Path.Length - sizeof(WCHAR);
        Path.Buffer += 1; // Skip the path delimiter at the beginning.

        if ( pTable->RootEntry.pData != NULL ) {
            fPrefixFound = TRUE;
            *pSuffix     = Path;
            *ppEntry     = &pTable->RootEntry;
        }
    }

    if ( Path.Length > MAX_PATH_SEGMENT_SIZE ) {
        NameBuffer = PREFIX_TABLE_ALLOCATE_MEMORY(Path.Length + sizeof(WCHAR));
        if ( NameBuffer == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while ( Path.Length > 0 ) {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        if ( pTable->Flags & PREFIX_TABLE_CASE_SENSITIVE ) {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        } else {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if ( Name.Length > 0 ) {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);


            if ( pEntry != NULL ) {
                // Cache the data available for this prefix if any.
                if ( pEntry->pData != NULL ) {
                    *pSuffix      = Path;
                    *ppEntry      = pEntry;
                    fPrefixFound  = TRUE;
                }
            } else {
                SubStringMatch = FALSE;
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    if ( !fPrefixFound ) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    if ( NameBuffer != Buffer ) {
        PREFIX_TABLE_FREE_MEMORY( NameBuffer );
    }

    if (pSubStringMatch != NULL)
    {
        *pSubStringMatch = SubStringMatch;
    }
    return status;
}


NTSTATUS
DfsInsertInPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING   pPath,
    IN PVOID             pData)
{
    NTSTATUS status;

    WRITE_LOCK_PREFIX_TABLE(pTable, status);
    if ( status != STATUS_SUCCESS )
        goto done;

    status  = DfsInsertInPrefixTableLocked(pTable, pPath, pData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return status;
}


NTSTATUS
DfsFindUnicodePrefix(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PUNICODE_STRING pSuffix,
    IN PVOID *ppData)
{
    NTSTATUS  Status;

    READ_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsFindUnicodePrefixLocked(pTable, pPath, pSuffix, ppData,NULL);

    UNLOCK_PREFIX_TABLE(pTable);
done:
    return Status;
}

NTSTATUS 
DfsRemoveFromPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData)
{
    NTSTATUS  Status;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsRemoveFromPrefixTableLocked(pTable, pPath, pMatchingData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return Status;
}



NTSTATUS 
DfsRemoveFromPrefixTableLockedEx(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData)
{


    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    
    UNREFERENCED_PARAMETER(pMatchingData);

    if (IS_PREFIX_TABLE_LOCKED(pTable) == FALSE) {
        return STATUS_INVALID_PARAMETER;
    }

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = &pPath->Buffer[0];

    if ( pPath->Length == 0 ) {
        return STATUS_SUCCESS;
    } else if ( pPath->Buffer[0] == PATH_DELIMITER ) {
        if ( pPath->Length == sizeof(WCHAR) ) {
            if ( pTable->RootEntry.pData == NULL ) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                return status;
            } else {
                pTable->RootEntry.pData = NULL;
                return  STATUS_SUCCESS;
            }
        } else {
            Path.Length -= sizeof(WCHAR);
            Path.Buffer++;
        }
    }

    status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry,NULL);

    if ( NT_SUCCESS(status)&& (Suffix.Length == 0) ) 
    {
        *pReturnedData = pEntry->pData;
         DfsRemovePrefixTableEntry(pTable, pEntry);
    }

    return status;
}

NTSTATUS 
DfsRemoveFromPrefixTableEx(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pMatchingData,
    IN PVOID *pReturnedData)
{
    NTSTATUS  Status;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsRemoveFromPrefixTableLockedEx(pTable, pPath, pMatchingData, pReturnedData);

    UNLOCK_PREFIX_TABLE(pTable);

    done:
    return Status;
}

NTSTATUS
DfsReplaceInPrefixTable(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    IN PVOID pReplaceData,
    IN PVOID pMatchingData)
{
    NTSTATUS  Status;
    IN PVOID pGotData = pMatchingData;

    WRITE_LOCK_PREFIX_TABLE(pTable, Status);
    if ( Status != STATUS_SUCCESS )
        goto done;

    Status = DfsReplaceInPrefixTableLocked(pTable, 
                                           pPath, 
                                           pReplaceData, 
                                           &pGotData);

    UNLOCK_PREFIX_TABLE(pTable);

done:
    return Status;
}

#if !defined (KERNEL_MODE)
VOID
DumpParentName(
              IN PDFS_PREFIX_TABLE_ENTRY pEntry)
{

    if ( pEntry->pParentEntry != NULL ) {
        DumpParentName(pEntry->pParentEntry);
        if ( pEntry->pParentEntry->PathSegment.Buffer != NULL )
            printf("\\%wZ", &pEntry->pParentEntry->PathSegment);
    }

    return;
}

VOID
DfsDumpPrefixTable(
                  PDFS_PREFIX_TABLE pPrefixTable,
                  IN VOID (*DumpFunction)(PVOID pEntry))
{
    PPREFIX_TABLE_BUCKET pBucket;
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = NULL;
    ULONG i, NumEntries;
    NTSTATUS Status;

    printf("Prefix table  %p\n", pPrefixTable);
    printf("Prefix table flags %x\n", pPrefixTable->Flags);
    printf("Prefix table Lock  %p\n", pPrefixTable->pPrefixTableLock);

    READ_LOCK_PREFIX_TABLE(pPrefixTable, Status);
    if (Status != STATUS_SUCCESS) 
        return NOTHING;

    for ( i = 0; i < NO_OF_HASH_BUCKETS; i++ ) {
        pBucket = &pPrefixTable->Buckets[i];

        pCurEntry = pBucket->SentinelEntry.pNextEntry;
        NumEntries = 0;
        while ( pCurEntry != &pBucket->SentinelEntry ) {
            NumEntries++;
            if ( pCurEntry->pData != NULL ) {
                printf("Found Prefix data %p in Bucket %d\n", pCurEntry->pData, i);
                DumpParentName(pCurEntry);
                printf("\\%wZ\n", &pCurEntry->PathSegment);
                if ( DumpFunction ) {
                    DumpFunction(pCurEntry->pData);
                }
            }
            pCurEntry = pCurEntry->pNextEntry;
        }

        printf("Number of entries in Bucket %d is %d\n", i, NumEntries);
    }
    UNLOCK_PREFIX_TABLE(pPrefixTable);
}


#endif

NTSTATUS
DfsPrefixTableAcquireWriteLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    NTSTATUS Status;

    WRITE_LOCK_PREFIX_TABLE(pPrefixTable, Status);

    return Status;

}

NTSTATUS
DfsPrefixTableAcquireReadLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    NTSTATUS Status;

    READ_LOCK_PREFIX_TABLE(pPrefixTable, Status);

    return Status;

}

NTSTATUS
DfsPrefixTableReleaseLock(
    PDFS_PREFIX_TABLE pPrefixTable )
{
    UNLOCK_PREFIX_TABLE(pPrefixTable);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_MSGTITLE                    2
#define IDC_NEWSHARE                    3
#define IDC_BROWSE                      3
#define IDS_DFSHOSTING                  3
#define IDD_CONFIGDFS                   101
#define IDD_DFSSHARE                    101
#define IDD_NEWSHARE                    102
#define IDD_CREATEDFS                   104
#define IDC_HOSTDFS                     1000
#define IDC_DFSROOT                     1001
#define IDC_DIRECTORY_TEXT              1003
#define IDC_CREATESHARE                 1006
#define IDC_DIRECTORY                   1007
#define IDC_MAKEFTDFS                   1008
#define IDC_FTDFS                       1009
#define IDC_CREATE_FTDFS                1010
#define IDC_JOIN_FTDFS                  1011
#define IDC_CREATE_DFS                  1012
#define IDC_CREATE_FTDFS_TX             1013
#define IDC_JOIN_FTDFS_CB               1014
#define IDC_CREATE_DOMAIN_TX            1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\shash\shash.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shash.c
//
//  Contents:   Generic hashtable
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifdef KERNEL_MODE


#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
    
#include <windows.h>
#include <shash.h>

extern
ULONG
SHashComputeHashValue(
    IN  void*   lpv 
    );

extern
int
SHashMatchNameKeysCaseInsensitive(	void*   pvKey1, 
									void*   pvKey2
									);

extern
void*
SHashAllocate(   ULONG   cbAlloc  );

extern
void
SHashFree( void*   lpv );

extern
BOOLEAN 
SHashReadLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashWriteLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashReadUnLockTable(PSHASH_TABLE pTable);

extern
BOOLEAN 
SHashWriteUnLockTable(PSHASH_TABLE pTable);

void * 
SHashAllocLock(void);

void 
SHashFreeLock(void * pMem);

DWORD g_ExpireSeconds = SHASH_DEFAULT_HASHTIMEOUT;

DWORD
ShashInitializeFunctionTable(PSHASH_TABLE pHashTable,
                             PSHASH_FUNCTABLE pFuncTable)
{

    pHashTable->HashFunc = SHashComputeHashValue;
    pHashTable->CompareFunc = SHashMatchNameKeysCaseInsensitive;

    pHashTable->AllocFunc = SHashAllocate;
    pHashTable->FreeFunc = SHashFree;

    pHashTable->AllocLockFunc = SHashAllocLock;    
    pHashTable->FreeLockFunc = SHashFreeLock;


    pHashTable->WriteLockFunc = SHashWriteLockTable;
    pHashTable->ReadLockFunc = SHashReadLockTable;
    pHashTable->ReleaseWriteLockFunc = SHashWriteUnLockTable;
    pHashTable->ReleaseReadLockFunc = SHashReadUnLockTable;


    if(pFuncTable->HashFunc)
    {
        pHashTable->HashFunc = pFuncTable->HashFunc;
    }


    if(pFuncTable->CompareFunc)
    {
        pHashTable->CompareFunc = pFuncTable->CompareFunc;
    }


    if ((pFuncTable->AllocFunc) || (pFuncTable->FreeFunc))
    {
        if ((pFuncTable->AllocFunc == NULL) ||
            (pFuncTable->FreeFunc == NULL))
        {
            return ERROR_INVALID_PARAMETER;
        }
        pHashTable->AllocFunc = pFuncTable->AllocFunc;
        pHashTable->FreeFunc = pFuncTable->FreeFunc;
    }

    if ((pFuncTable->AllocLockFunc) || (pFuncTable->FreeLockFunc))
    {
        if ((pFuncTable->AllocLockFunc == NULL) || 
            (pFuncTable->FreeLockFunc == NULL))
        {
            return ERROR_INVALID_PARAMETER;
        }
        pHashTable->AllocLockFunc = pFuncTable->AllocLockFunc;    
        pHashTable->FreeLockFunc = pFuncTable->FreeLockFunc;
    }

    if ((pFuncTable->WriteLockFunc) || (pFuncTable->ReadLockFunc) ||
        (pFuncTable->ReleaseWriteLockFunc) || (pFuncTable->ReleaseReadLockFunc))
    {
        pHashTable->WriteLockFunc = pFuncTable->WriteLockFunc;
        pHashTable->ReadLockFunc = pFuncTable->ReadLockFunc;
        pHashTable->ReleaseWriteLockFunc = pFuncTable->ReleaseWriteLockFunc;
        pHashTable->ReleaseReadLockFunc = pFuncTable->ReleaseReadLockFunc;
    }

    if(pFuncTable->NumBuckets)
    {
        pHashTable->NumBuckets = pFuncTable->NumBuckets;
    }
    else
    {
        pHashTable->NumBuckets = SHASH_DEFAULT_HASH_SIZE;

        pHashTable->Flags = SHASH_CAP_POWER_OF2;
    }

    pHashTable->Flags |= pFuncTable->Flags;

    return ERROR_SUCCESS;
}

NTSTATUS 
ShashInitHashTable(
    PSHASH_TABLE *ppHashTable,
    PSHASH_FUNCTABLE pFuncTable)
{
    PSHASH_TABLE pHashTable = NULL;
    ULONG cbHashTable = 0;
    DWORD LoopVar = 0;
    ULONG NumBuckets = SHASH_DEFAULT_HASH_SIZE;
    NTSTATUS Status = STATUS_SUCCESS;
    PFNALLOC lAllocFunc = SHashAllocate;
    PFNFREE  lFreeFunc = SHashFree;

    if(pFuncTable && pFuncTable->NumBuckets)
    {
      NumBuckets = pFuncTable->NumBuckets;
    }


    if(pFuncTable)
    {
        if ((pFuncTable->AllocFunc != NULL) &&
            (pFuncTable->FreeFunc != NULL))
        {
            lAllocFunc = pFuncTable->AllocFunc;
            lFreeFunc =  pFuncTable->FreeFunc;
        }
    }

    cbHashTable = sizeof(SHASH_TABLE) + NumBuckets * sizeof(SHASH_ENTRY);
    pHashTable = lAllocFunc (cbHashTable);
    if (pHashTable == NULL) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }


    Status = ShashInitializeFunctionTable(pHashTable,
                                          pFuncTable);
    if (Status != ERROR_SUCCESS)
    {
        lFreeFunc(pHashTable);
        goto Exit;
    }

    pHashTable->pLock = pHashTable->AllocLockFunc();
    if(pHashTable->pLock == NULL)
    {
      lFreeFunc (pHashTable);
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
    }

    RtlZeroMemory(&pHashTable->HashBuckets[0], NumBuckets * sizeof(SHASH_ENTRY));

    *ppHashTable = pHashTable; 
        
    for(LoopVar = 0; LoopVar < NumBuckets; LoopVar++)
    {
        InitializeListHead(&pHashTable->HashBuckets[LoopVar].ListHead);
    }

Exit:

    return Status;
}

void 
ShashTerminateHashTable(
    PSHASH_TABLE pHashTable
    )
{
    PFNFREE  FreeFunc = NULL;
    if(pHashTable != NULL)
    {
        pHashTable->FreeLockFunc( pHashTable->pLock);
        FreeFunc = pHashTable->FreeFunc;

        FreeFunc (pHashTable);
    }
}

NTSTATUS
SHashInsertKey(IN	PSHASH_TABLE	pTable, 
               IN	void *	pData,
               IN	void *	pvKeyIn,
               IN   DWORD   InsertFlag)
{
    ULONG dwHash = 0;    
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY	ple = NULL;
    PLIST_ENTRY	pleRemove = NULL;
    PLIST_ENTRY	pleStart = NULL;
    PSHASH_HEADER pEntry = NULL;
    PSHASH_HEADER pHeader = NULL;
    int	iSign = 0;
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;

    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
        dwHash= dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
        dwHash = dwHash % pTable->NumBuckets;
    }

    LockAquired = pTable->WriteLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    pHeader = (PSHASH_HEADER) pData;
    pHeader->dwHash = dwHash;

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart )
    {
        pEntry = CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc(pEntry->pvKey, pvKeyIn ) ;
        if( iSign > 0 )
        {
            break ;
        }
        else if((InsertFlag == SHASH_REPLACE_IFFOUND) && (iSign == 0))
        {
            pEntry->Flags |= SHASH_FLAG_DELETE_PENDING;
            if(InterlockedDecrement(&pEntry->RefCount) == 0)
            {
                pleRemove = ple;
                ple = ple->Flink;
                RemoveEntryList( pleRemove ) ;
                
                InterlockedDecrement(&pTable->HashBuckets[dwHash].Count);
                InterlockedDecrement(&pTable->TotalItems);
                pTable->FreeFunc(pEntry);
            }
            break;
        }

        ple = ple->Flink ;
    }


    InterlockedIncrement(&pHeader->RefCount);
               
    InsertTailList( ple, &pHeader->ListEntry ) ;
    InterlockedIncrement(&pTable->HashBuckets[dwHash].Count);
    InterlockedIncrement(&pTable->TotalItems);


Exit:

    if(LockAquired)
    {
        pTable->ReleaseWriteLockFunc(pTable);
    }

    return	Status;
}


//
//	Remove an item from the hash table 
//
NTSTATUS	
SHashRemoveKey(	IN	PSHASH_TABLE	pTable, 
                IN	void *		pvKeyIn,
                IN  PFNREMOVEKEY pRemoveFunc
				)	
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY	pleStart = NULL ;
    PLIST_ENTRY	ple= NULL ;
    PSHASH_HEADER pEntry = NULL;
    int	iSign = 0; 
    DWORD	dwHash = 0;	
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;

    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
         dwHash= dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
         dwHash = dwHash % pTable->NumBuckets;
    }

    LockAquired = pTable->WriteLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart ) 
    {
        pEntry = (PSHASH_HEADER) CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc( pEntry->pvKey, pvKeyIn ) ;
        if( iSign == 0 ) 
         {
            if(pRemoveFunc)
            {
                pRemoveFunc(pEntry);
            }

            pEntry->Flags |= SHASH_FLAG_DELETE_PENDING;

            if(InterlockedDecrement(&pEntry->RefCount) == 0)
            {
                RemoveEntryList( ple ) ;

                InterlockedDecrement(&pTable->HashBuckets[dwHash].Count);
                InterlockedDecrement(&pTable->TotalItems);
                pTable->FreeFunc(pEntry);
            }

            break;
        }
        else if( iSign > 0 ) 
        {
            break ;
        }

        ple = ple->Flink ;
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseWriteLockFunc(pTable);
    }

    return	Status;
}

PSHASH_HEADER	
SHashLookupKeyEx(	IN	PSHASH_TABLE pTable, 
                    IN	void*		pvKeyIn
				)	
{
    PSHASH_HEADER pEntry = NULL;
    PLIST_ENTRY	pleStart = NULL ;
    PLIST_ENTRY	ple= NULL ;
    int	iSign = 0; 
    DWORD	dwHash = 0;	
    BOOLEAN LockAquired = TRUE;

    dwHash = pTable->HashFunc(pvKeyIn) ;

    if(pTable->Flags & SHASH_CAP_POWER_OF2)
    {
         dwHash= dwHash & (pTable->NumBuckets - 1);
    }
    else
    {
         dwHash = dwHash % pTable->NumBuckets;
    }


    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        goto Exit;
    }

    pleStart = &pTable->HashBuckets[dwHash].ListHead ;
    ple = pleStart->Flink ;
    while( ple != pleStart ) 
    {
        pEntry = (PSHASH_HEADER)CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
        iSign = pTable->CompareFunc( pEntry->pvKey, pvKeyIn ) ;
        if( iSign == 0 ) 
        {
            InterlockedIncrement(&pEntry->RefCount);
            pTable->ReleaseReadLockFunc(pTable);
            return pEntry;
        }
        else if( iSign > 0 ) 
        {
            break ;
        }

        ple = ple->Flink ;
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseReadLockFunc(pTable);
    }

    return	NULL;
}


NTSTATUS	
SHashIsKeyInTable(	IN	PSHASH_TABLE pTable, 
                    IN	void*		pvKeyIn
                 )
{
    NTSTATUS Status = STATUS_OBJECT_PATH_NOT_FOUND;	
    PSHASH_HEADER pEntry = NULL;

    pEntry = SHashLookupKeyEx(pTable, pvKeyIn);
    if(pEntry != NULL)
    {

        SHashReleaseReference(pTable, pEntry); 
        Status = STATUS_SUCCESS;
    }


    return Status;
}


NTSTATUS	
SHashGetDataFromTable(	IN	PSHASH_TABLE pTable, 
                        IN	void*		pvKeyIn,
                        IN  void        ** ppData
                     )
{
    NTSTATUS Status = STATUS_OBJECT_PATH_NOT_FOUND;
    PSHASH_HEADER pEntry = NULL;
	
    pEntry = SHashLookupKeyEx(pTable, pvKeyIn);
    if(pEntry != NULL)
    {
        *ppData = (void *)pEntry;
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS	
SHashReleaseReference(	IN	PSHASH_TABLE pTable, 
                        IN  PSHASH_HEADER pData
                     )
{
    if(InterlockedDecrement(&pData->RefCount) == 0)
    {
        InterlockedDecrement(&pTable->TotalItems);
        pTable->WriteLockFunc(pTable);
        RemoveEntryList( &pData->ListEntry ) ;
        pTable->ReleaseWriteLockFunc(pTable);
        InterlockedDecrement(&pTable->HashBuckets[pData->dwHash].Count);
        pTable->FreeFunc(pData);
    }

    return STATUS_SUCCESS;
}

#if 0
NTSTATUS	
SHashReplaceInTable(IN	PSHASH_TABLE pTable, 
				    IN	void*		pvKeyIn,
                    IN OUT PVOID *ppData
                 )
{

    NTSTATUS Status = STATUS_SUCCESS;

    Status = STATUS_OBJECT_PATH_NOT_FOUND;

    return Status;
}
#endif

NTSTATUS
ShashEnumerateItems(IN	PSHASH_TABLE pTable, 
					IN	PFNENUMERATEKEY	    pfnCallback, 
					IN	LPVOID				lpvClientContext
					)	
{

    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY	pCur = NULL ;
    PLIST_ENTRY	pNext = NULL;
    PLIST_ENTRY	ListHead = NULL;
    PSHASH_HEADER	pEntry = NULL;
    DWORD	i = 0;
    BOOLEAN LockAquired = TRUE;

    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        Status = STATUS_LOCK_NOT_GRANTED;
        goto Exit;
    }

    for( i = 0; i < pTable->NumBuckets && Status == STATUS_SUCCESS; i++ ) 
    {
        ListHead = &pTable->HashBuckets[i].ListHead ;
        pCur = ListHead->Flink ;
        while( pCur != ListHead && Status == STATUS_SUCCESS ) 
        {
            //
            //	save the next pointer now, 			
            //
            pNext = pCur->Flink ;
            pEntry = CONTAINING_RECORD(	pCur, SHASH_HEADER, ListEntry ) ;
	
            if ((pEntry->Flags & SHASH_FLAG_DELETE_PENDING) == 0)
            {
                Status = pfnCallback( pEntry,
                                      lpvClientContext );
            }
            //
            //	move to the next item
            //
            pCur = pNext ;
        }
    }

Exit:

    if(LockAquired)
    {
        pTable->ReleaseReadLockFunc(pTable);
    }

    return	Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\prefix\wpp.h ===
//0c2c06fa Generated File. Do not edit.
// File created by WPP compiler version 0.01-Sat Apr  1 17:27:32 2000
// on 07/22/2000 at 04:41:51 UTC
//   
//   Source files: name_table.c prefix.c.

#ifndef _WPP_H_
#define _WPP_H_

#define _DFS_ENABLE_USER_AGENT        0x0001
#define _DFS_ENABLE_ERRORS            0x0002
#define _DFS_ENABLE_PREFIX            0x0004
#define _DFS_ENABLE_RPC               0x0008
#define _DFS_ENABLE_REFERRAL_SERVER   0x0010
#define _DFS_ENABLE_UNUSED11          0x0020
#define _DFS_ENABLE_UNUSED10          0x0040
#define _DFS_ENABLE_UNUSED9           0x0080
#define _DFS_ENABLE_UNUSED8           0x0100
#define _DFS_ENABLE_UNUSED7           0x0200
#define _DFS_ENABLE_UNUSED6           0x0400
#define _DFS_ENABLE_UNUSED5           0x0800
#define _DFS_ENABLE_UNUSED4           0x1000
#define _DFS_ENABLE_UNUSED3           0x2000
#define _DFS_ENABLE_UNUSED2           0x4000
#define _DFS_ENABLE_UNUSED1           0x8000


#define _LEVEL_HIGH                    0x1
#define _LEVEL_NORM                    0x2
#define _LEVEL_LOW                     0x4
#define LOG_FLAGS(_flag)      _DFS_ENABLE_ ## _flag


#define LOG_ENABLED( _level, _flags) \
            (( DfsRtlWmiReg.EnableLevel >= (_level) ) &&   \
             ( DfsRtlWmiReg.EnableFlags & _flags ))
            
#define DFS_LOG_ENABLED(_ArrayPrefix_, _Id_, _level, _flags) \
	((_ArrayPrefix_ ## ControlGuids[0].EnableFlags & _flags ) && \
        (_ArrayPrefix_ ## ControlGuids[0].EnableLevel >= (_level)))
            
#define DFS_LOG(_level, _flags, _id, _arg) \
    { \
        if ( DFS_LOG_ENABLED(PrefixLib_, _id, _level, _flags) ) { \
            WmlData.Trace( WPP_MSG_NO(_id), \
                     &WPP_TRACE_GUID(PrefixLib_,_id) , \
                     PrefixLib_ ## ControlGuids[0].LoggerHandle, _arg 0); \
        } \
    }            

#define SET_LIB_TRACE(_prefix) \
                _prefix ## ControlGuids = PrefixLib_ ## ControlGuids;

#define DFS_TRACE_NORM(_flags, _msg, _args) \
                DFS_LOG(_LEVEL_NORM, LOG_FLAGS(_flags), MSG_ID_WPP_AUTO_ID, _args)
#define DFS_TRACE_LOW(_flags, _msg, _args) \
                DFS_LOG(_LEVEL_LOW, LOG_FLAGS(_flags), MSG_ID_WPP_AUTO_ID, _args)
#define DFS_TRACE_HIGH( _flag, _msg, _arg)    \
                DFS_LOG(_LEVEL_HIGH, LOG_FLAGS(_flag), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_NORM(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_NORM, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_HIGH(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_HIGH, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

#define DFS_TRACE_ERROR_LOW(_status, _flag, _msg, _arg)    \
            DFS_LOG(_LEVEL_LOW, (LOG_FLAGS(_flag) | (NT_ERROR(_status) ? LOG_FLAGS(ERRORS) : 0)), MSG_ID_WPP_AUTO_ID, _arg)

            


enum WPP_FILES {WPP_FILE_name_table_c,WPP_FILE_prefix_c,};

//
// Unless disabled, WPP selects one of the source
// files as a "guid store". That file will have definitions
// of trace and control arrays
//
#if defined(NAME_TABLE_C)
#define WPP_DEFINE_ARRAYS
#endif
 

#  define WPP_CONTROL_GUID_ARRAY PrefixLib_ControlGuids

//
// Define default flavors of the trace macro
//

#if defined(WMLUM_H) 
extern WML_DATA WmlData;
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) (*WmlData.Trace)(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#elif defined(WMLKM_H)
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WmlTrace(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#else
#  define WPP_PTRLEN
#  define WPP_USE_WmiTraceMessage
#  if defined(WPP_KERNEL_MODE)
#     define WPP_WMI_TRACE_MESSAGE WmiTraceMessage
#  else
#     define WPP_WMI_TRACE_MESSAGE TraceMessage
#  endif
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WPP_WMI_TRACE_MESSAGE(_lh,_fl,_guid,_id,_arg)
#endif


#if defined(WPP_DEFINE_ARRAYS)
#  define WPP_DEFINE_TRACE_GUIDS
#  define WPP_DEFINE_CONTROL_GUIDS
#endif


#define NOARGS // Yep. No args, alright.
#define LOGNOTHING 0,

#  define WPP_DEFINE_GRP_ID(_a,_b) ( ((_a) << 16) | ( _b) )
#  define WPP_CTRL_FLAGS(_id)      (1 << ((_id) & 0xFFFF) )
#  define WPP_CTRL_GUID_NO(_id)    ((_id) >> 16)


#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )
#  define WPP_MSG_NO(_id)            ((_id) & 0xFFFF)
#  define WPP_TRACE_GUID_NO(_id)     ((_id) >> 16)


#define WPP_TRACE_GUID(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## TraceGuids[ WPP_TRACE_GUID_NO(_Id_) ] )

#define WPP_LOGGER_HANDLE(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].LoggerHandle )
#define WPP_ENABLED(_ArrayPrefix_,_Id_) \
	(_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].EnableFlags & WPP_CTRL_FLAGS(_Id_) )

#define LOGARSTR(_Value_)	WPP_LOGASTR( _Value_ )
#define LOGBOOLEAN(_Value_)	WPP_LOGTYPEVAL(signed char, _Value_ )
#define LOGPTR(_Value_)	WPP_LOGTYPEVAL(void*, _Value_ )
#define LOGSTATUS(_Value_)	WPP_LOGTYPEVAL(signed int, _Value_ )
 
#  define MSG_ID_prefix_c114	WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_prefix_c163	WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_prefix_c69	WPP_DEFINE_MSG_ID(0,10)
 
extern GUID                         PrefixLib_TraceGuids[]; 
#define PrefixLib_TraceGuids_len    1      // I don't think we need this [BUGBUG]

#if defined(WPP_DECLARE_CONTROL_GUIDS)
extern WML_CONTROL_GUID_REG         WPP_CONTROL_GUID_ARRAY[]; 
#endif


#ifdef WPP_DEFINE_TRACE_GUIDS
#if 1  // if # traceguids > 0 
GUID PrefixLib_TraceGuids[] = {
 // 0da06be7-a84a-4d9b-be44-70a2e7917f35 prefix.c
 {0x0da06be7,0xa84a,0x4d9b,{0xbe,0x44,0x70,0xa2,0xe7,0x91,0x7f,0x35}}, // prefix.c
};
#endif
#endif // WPP_DEFINE_TRACE_GUIDS

#if defined(WMLUM_H)
# define WPP_INIT_TRACING_SIMPLE_EX(AppName, PrintFunc) \
    do { \
        DWORD status; \
	LOADWML(status, WmlData); \
        SetupReg( \
            AppName, \
            L"%SystemRoot%\\PrefixLib_.log",\
            ); \
	if (status == ERROR_SUCCESS) { \
		status = (*WmlData.Initialize)( \
			   AppName, \
			   PrintFunc, \
                           &WPP_CONTROL_GUID_ARRAY[0]); \
	} \
    } while(0)
# define WPP_INIT_TRACING_SIMPLE(AppName) WPP_INIT_TRACING_SIMPLE_EX(AppName, NULL)
#endif

#ifdef WPP_DEFINE_CONTROL_GUIDS
  #if defined(WMLUM_H) 
     WML_DATA WmlData;
  #endif

# if 0 == 0  // if # CtrlGuids == 0
    WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[1];
# else
WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[] = {
};
#endif
#endif // WPP_DEFINE_CONTROL_GUIDS


#define WPP_DEFAULT_GROUP_ID WPP_DEFINE_GRP_ID(0,0)

#if !defined(DFS_TRACE_ERROR_HIGH)
#define DFS_TRACE_ERROR_HIGH(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_ERROR_LOW)
#define DFS_TRACE_ERROR_LOW(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_ERROR_NORM)
#define DFS_TRACE_ERROR_NORM(_unknown1, _unknown2, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_HIGH)
#define DFS_TRACE_HIGH(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_LOW)
#define DFS_TRACE_LOW(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(DFS_TRACE_NORM)
#define DFS_TRACE_NORM(_unknown1, MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTrace)
#define SimpleTrace(MSG, ARG) WPP_LOG(PrefixLib_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTraceEx)
#define SimpleTraceEx(GRP, MSG, ARG) WPP_LOG(PrefixLib_, GRP, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if 0 // Real check is done in elif
#elif defined(NAME_TABLE_C) // name_table.c
#	define WPP_THIS_FILE name_table_c
#elif defined(PREFIX_C) // prefix.c
#	define WPP_THIS_FILE prefix_c
#endif 

#define WPP_EVAL(_value_) _value_
#define MSG_ID_WPP_AUTO_ID WPP_EVAL(MSG_ID_) ## WPP_EVAL(WPP_THIS_FILE) ## WPP_EVAL(__LINE__)

//
// WPP_CHECKED_ZERO will be expanded to 0, if 
// expression _value has the same size as the type _Type,
// or to division by 0, if the sizes are different
//
// This is poor man compile time argument checking. So don't be surprised
// if a compiler will tell you suddenly that you have a division by 0
// in line such and such
//

#define WPP_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WPP_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WPP_CHECKED_ZERO( _Value, _Type) )


#if defined(WPP_PTRLEN)
#  define WPP_LOGPAIR(_Size, _Addr) (_Addr),(_Size),
#else
#  define WPP_LOGPAIR(_Size, _Addr) (_Size),(_Addr),
#endif

# define WPP_LOGTYPEVAL(_Type, _Value) \
    WPP_LOGPAIR(WPP_CHECKED_SIZEOF(_Value, _Type), &(_Value))

# define WPP_LOGASTR(_value) \
    WPP_LOGPAIR( strlen(_value) + WPP_CHECKED_SIZEOF((_value)[0],CHAR), _value )

# define WPP_LOGWSTR(_value) \
    WPP_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WPP_CHECKED_SIZEOF((_value)[0],WCHAR), _value)

# define WPP_LOGCSTR(_x) \
    WPP_LOGPAIR( sizeof((_x).Length) + WPP_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

# define WPP_LOGUSTR(_x)                                                            \
    WPP_LOGPAIR( WPP_CHECKED_SIZEOF((_x).Length, short)                        \
                    + WPP_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

#  define WPP_LOG(_ArrayPrefix_, _Group_, _Id_, _Msg_, _Args_) \
       if (!WPP_ENABLED(_ArrayPrefix_, _Group_)) {;} else \
           WPP_TRACE_MESSAGE(WPP_LOGGER_HANDLE(_ArrayPrefix_, _Group_), \
                             WPP_TRACE_FLAGS, \
                             WPP_TRACE_GUID(_ArrayPrefix_,_Id_), \
                             WPP_MSG_NO(_Id_), _Msg_, _Args_)


#endif // _WPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\shash\shashiter.c ===
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       shashiter.c
//
//  Contents:   Generic hashtable iterator
//  Classes:    
//
//  History:    April. 9 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#ifdef KERNEL_MODE


#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <windef.h>
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
    
#include <windows.h>
#include <shash.h>



PSHASH_HEADER
SHashNextEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable)
{
    DWORD dwHashVar = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    void * pData = NULL;
    LIST_ENTRY * ple = NULL;
    LIST_ENTRY * pListHead = NULL;
    PSHASH_HEADER	pEntry = NULL;
    PSHASH_HEADER	pOldEntry = NULL;
    BOOLEAN  LockAquired = TRUE;
    BOOLEAN  Found = FALSE;

    LockAquired = pTable->ReadLockFunc(pTable);
    if(!LockAquired)
    {
        // dfsdev: why are we not returning status??
        Status = STATUS_LOCK_NOT_GRANTED;
        return NULL;
    }

    pOldEntry = pIterator->pEntry;

    ple = pIterator->ple->Flink;

    for (dwHashVar = pIterator->index; (dwHashVar < pTable->NumBuckets) && (!Found); dwHashVar++) 
    {
        pListHead = &pTable->HashBuckets[dwHashVar].ListHead;

        ple = (dwHashVar == pIterator->index) ? pIterator->ple->Flink : pListHead->Flink;

        while (ple != pListHead) 
        {
            pEntry = CONTAINING_RECORD(ple, SHASH_HEADER, ListEntry);
            if((pEntry->Flags & SHASH_FLAG_DELETE_PENDING) == 0)
            {
                InterlockedIncrement(&pEntry->RefCount);

                pIterator->index = dwHashVar;
                pIterator->ple = ple;
                pIterator->pEntry = pEntry;
                pIterator->pListHead = pListHead;
                Found = TRUE;
                break;
            }
            pEntry = NULL;
            ple = ple->Flink;
        }
    }

    if(pOldEntry)
    {
        Status = SHashReleaseReference(	pTable, pOldEntry); 
    }

    if(pEntry == NULL)
    {
        pIterator->index = 0;
        pIterator->ple = NULL;
        pIterator->pListHead = NULL;
        pIterator->pEntry = NULL;
    }

    pTable->ReleaseReadLockFunc(pTable);

    return pEntry;
}


PSHASH_HEADER
SHashStartEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        )
{
    PSHASH_HEADER	pEntry = NULL;

    pIterator->index = 0;
    pIterator->pListHead = &pTable->HashBuckets[0].ListHead;
    pIterator->ple = pIterator->pListHead;
    pIterator->pEntry = NULL;

    pEntry = SHashNextEnumerate( pIterator, pTable);

    return pEntry;
}

VOID
SHashFinishEnumerate(
        IN  PSHASH_ITERATOR pIterator,
        IN  PSHASH_TABLE pTable
        )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(pIterator->pEntry)
    {
        Status = SHashReleaseReference(	pTable, pIterator->pEntry); 
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\setup\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//  Notes:      see notes in registry.hxx
//
//----------------------------------------------------------------------------

#include    <stdlib.h>
#include    <windows.h>
#include    <registry.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pwszPath,
                     samDesiredAccess,
                     pwszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pwszPath,
                      samDesiredAccess,
                      pwszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        const LPWSTR  pwszPath,
        REGSAM  samDesiredAccess,
        const LPWSTR  pwszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           pwszPath,           //  path to key
                           0,                  //  title index
                           pwszClass,          //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        const  LPWSTR  pwszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pwszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}
//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPWSTR)_cwszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPWSTR)_cwszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


DWORD CRegKey::DeleteChildren()
{
    //  figure out how many keys are currently stored in this key

    ULONG   cSubKeys, cbMaxSubKeyLen;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     NULL,
                     NULL,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL);

    if ( dwRc != ERROR_SUCCESS )
    {
         //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(wszKeyName);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                wszKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                NULL,       //  class
                                NULL,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, wszKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            pRegKey->DeleteChildren();
            delete pRegKey;
            dwRc = RegDeleteKey(_hkThis, wszKeyName);
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) && 
        (dwRc != ERROR_NO_MORE_ITEMS && dwRc != ERROR_SUCCESS))
    {
        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\setup\dfssetup.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfssetup.cxx
//
//  Contents:   Code to setup Dfs on a machine.
//
//              Note that this code can be built as an exe or as a DLL. To
//              switch between the two, simply edit the following fields in
//              the sources file:
//                      TARGETTYPE=[PROGRAM | DYNLINK]
//                      UMTYPE=[console | windows]
//              Delete the following two lines from sources to build an exe.
//                      DLLDEF=obj\*\dfssetup.def
//                      DLLENTRY=_DllMainCRTStartup
//                      DLLBASE=@$(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt,dfssetup
//
//  Classes:    None
//
//  Functions:
//
//  History:    12-28-95        Milans  Created
//
//-----------------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
}

#include <windows.h>
#include <rpc.h>                                 // For UuidCreate

#include <winldap.h>
#include <dsgetdc.h>

#include <lm.h>

#include "registry.hxx"                          // Helper functions...
#include "setupsvc.hxx"

#include "config.hxx"                            // Config UI functions

//
// Until we get the schema right in the DS, we have to set our own SD on
// certain objects
//

#include <aclapi.h>
#include <permit.h>

HINSTANCE g_hInstance;

extern "C" BOOL
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hDll;
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;

}


#define dprintf(x)

#define MAX_NETBIOS_NAME_LEN    16+1

extern DWORD
RemoveDfs(void);

BOOLEAN
DfsCheckForOldDfsService();


DWORD
GetSharePath(
    IN LPWSTR wszShareName,
    OUT LPWSTR wszSharePath);


//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point in case you want to build this as an exe.
//              Configures all Dfs components on a machine.
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void _cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRootLen;
    BOOL fRootSetup = FALSE;
    BOOLEAN OldDfsService = FALSE;
    WCHAR wszDfsRootShare[ MAX_PATH ];


    //
    // Figure out the type of machine we are installing on - client or root
    //


    if (argc != 1) {
        return;
    }

    //
    // Configure the Dfs Driver
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = ConfigDfs();

        if (dwErr == ERROR_SUCCESS) {

            dwErr = ConfigDfsService();

            if (dwErr != ERROR_SUCCESS) {

                dprintf((
                    DEB_ERROR, "Win32 error configuring Dfs Service %d\n",
                    dwErr));

                (void)RemoveDfs();

            } else {

                dprintf((DEB_ERROR,"Successfully configured Dfs...\n") );

            }

        } else {

            dprintf((DEB_ERROR,"Error %d configuring Dfs driver!\n", dwErr));

        }
    }
}
//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupDfs
//
//  Synopsis:   Entry point in case you want to build this as a DLL. This
//              function is suitable for being called from a setup .inf
//              file.
//
//  Arguments:  [cArgs] -- Count of args
//              [lpszArgs] -- Array of args
//              [lpszTextOut] -- On return, points to a global buffer
//                      containing the null string. This is required by the
//                      .inf file
//
//  Returns:    TRUE.
//
//-----------------------------------------------------------------------------

LPSTR szReturn = "";

extern "C" BOOL
DfsSetupDfs(
    DWORD cArgs,
    LPSTR lpszArgs[],
    LPSTR *lpszTextOut)
{
    int argc;
    LPSTR *argv;

    argv = (LPSTR *) malloc( (cArgs+1) * sizeof(LPSTR) );

    if (argv == NULL) {
        return( FALSE );
    }

    argv[0] = "DfsSetup";
    for (argc = 1; argc <= (int) cArgs; argc++) {
        argv[ argc ] = lpszArgs[ argc-1 ];
    }

    main( argc, argv );

    free( argv );

    *lpszTextOut = szReturn;

    return( TRUE );

}



//+------------------------------------------------------------------
//
// Function: CheckForOldDfsService
//
// Synopsis:
//
// Effects: -none-
//
// Arguments: -none-
//
// Returns: TRUE if the old (pre -ds build) dfs service is installed
//
//
// History: 10-09-96        JimMcN       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


BOOLEAN DfsCheckForOldDfsService( )
{
    DWORD dwErr = 0;
    DWORD DfsVersion;

    // Open Service Controller
    CService cSvc;

    if (!(dwErr = cSvc.Init()))
    {

        dwErr = cSvc._OpenService(L"Dfs", SERVICE_QUERY_STATUS);
        cSvc._CloseService();

        if (dwErr != 0) {
            return(FALSE);
        }

        CRegKey cregDfsService( HKEY_LOCAL_MACHINE,
                                &dwErr,
                                L"System\\CurrentControlSet\\Services\\Dfs"
                               );

        if (dwErr == ERROR_SUCCESS) {
            CRegDWORD DfsNewService((const CRegKey &)cregDfsService,
                                     L"DfsVersion", &DfsVersion);

            dwErr = DfsNewService.QueryErrorStatus();

            if (dwErr != 0) {
                dprintf((DEB_ERROR,"CheckForOldDfsService Failed Newserv\n"));
                return(TRUE);
            }

            if (DfsVersion < DFS_VERSION_NUMBER) {
                return(TRUE);
            }

            return(FALSE);

        }

        return(FALSE);
    }
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\lib\shash\shashdata.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "shash.h"
         

//
//  The following table is generated from this code : 
//  
//  #define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */
//    INT i, j;
//    DWORD sum;
//
//    for (i = 0; i < 128; ++i) {
//        sum = 0;
//        for (j = 7 - 1; j >= 0; --j) {
//            if (i & (1 << j)) {
//                sum ^= POLY >> j;
//            }
//        }
//        CrcTable[i] = sum;
//
//  These values are used when computing hash values, 
//  and the result is a very good hash function with good distribution !
//
static  long CrcTable[128] = 
{
    0,         1207959552, 603979776,  1811939328,
    301989888, 1509949440, 905969664,  2113929216,
    150994944, 1090519040, 754974720,  1694498816,
    452984832, 1392508928, 1056964608, 1996488704,
    75497472,  1283457024, 545259520,  1753219072,
    377487360, 1585446912, 847249408,  2055208960,
    226492416, 1166016512, 696254464,  1635778560,
    528482304, 1468006400, 998244352,  1937768448,
    37748736,  1245708288, 641728512,  1849688064,
    272629760, 1480589312, 876609536,  2084569088,
    188743680, 1128267776, 792723456,  1732247552,
    423624704, 1363148800, 1027604480, 1967128576,
    113246208, 1321205760, 583008256,  1790967808,
    348127232, 1556086784, 817889280,  2025848832,
    264241152, 1203765248, 734003200,  1673527296,
    499122176, 1438646272, 968884224,  1908408320,
    18874368,  1226833920, 622854144,  1830813696,
    320864256, 1528823808, 924844032,  2132803584,
    136314880, 1075838976, 740294656,  1679818752,
    438304768, 1377828864, 1042284544, 1981808640,
    94371840,  1302331392, 564133888,  1772093440,
    396361728, 1604321280, 866123776,  2074083328,
    211812352, 1151336448, 681574400,  1621098496,
    513802240, 1453326336, 983564288,  1923088384,
    56623104,  1264582656, 660602880,  1868562432,
    291504128, 1499463680, 895483904,  2103443456,
    174063616, 1113587712, 778043392,  1717567488,
    408944640, 1348468736, 1012924416, 1952448512,
    132120576, 1340080128, 601882624,  1809842176,
    367001600, 1574961152, 836763648,  2044723200,
    249561088, 1189085184, 719323136,  1658847232,
    484442112, 1423966208, 954204160,  1893728256,
} ;

ULONG
SHashComputeHashValue(
    IN  void*   lpv 
    )   
{
    PUNICODE_STRING  Name = (PUNICODE_STRING) lpv ;
    DWORD sum = 0;
    LONG Length = 0; 
    PWCHAR  Key = NULL;
    WCHAR  ch ;
	
    Length = Name->Length/sizeof(WCHAR);
    Key = Name->Buffer;

    while ( Length-- ) 
    {
        ch = RtlUpcaseUnicodeChar(*Key++) ;
        sum = (sum >> 7) ^ CrcTable[(sum ^ (ch)) & 0x7f];
    }

    return(sum);
}



/*++

Routine Description : 

	This function is provided to the hash tables to compare two keys.

	NOTE : we compare in a case insensitive fashion !

Arguments : 

	pvKey1, pvKey2 - two keys,

Return Value : 

	-1 iff pvKey1 < pvKey2
	0 iff pvKey1 == pvKey2
	1 iff pvKey1 > pvKey2 

--*/
int
SHashMatchNameKeysCaseInsensitive(	void*   pvKey1, 
									void*   pvKey2
									)   
{
	PUNICODE_STRING	pKey1 = (PUNICODE_STRING)pvKey1 ;
	PUNICODE_STRING	pKey2 = (PUNICODE_STRING)pvKey2 ;

	if( pKey1->Length == pKey2->Length )	
    {
		return  RtlCompareUnicodeString(
						 pKey1,
						 pKey2,
						 TRUE
						 ) ;
	}	
    else	
    {
	    return  (signed)pKey1->Length - (signed)pKey2->Length ;
	}
}


void*
SHashAllocate(   ULONG   cbAlloc  )   
{
    void * pMem = NULL;


    pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbAlloc);
    return pMem;
}

void
SHashFree( void*   lpv ) 
{

    HeapFree( GetProcessHeap(), 0, lpv );
}

BOOLEAN SHashReadLockTable(PSHASH_TABLE pTable)
{
    BOOLEAN fRet = TRUE;

    __try 
    { 
        EnterCriticalSection(pTable->pLock); 
        pTable->Flags |= SHASH_CAP_TABLE_LOCKED;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    } 


    return fRet;
}


BOOLEAN SHashWriteLockTable(PSHASH_TABLE pTable)
{
    BOOLEAN fRet = TRUE;

    __try 
    { 
        EnterCriticalSection(pTable->pLock); 
        pTable->Flags |= SHASH_CAP_TABLE_LOCKED;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    } 


    return fRet;
}


BOOLEAN SHashReadUnLockTable(PSHASH_TABLE pTable)
{
    pTable->Flags &= ~SHASH_CAP_TABLE_LOCKED; 
    LeaveCriticalSection(pTable->pLock); 

    return TRUE;
}


BOOLEAN SHashWriteUnLockTable(PSHASH_TABLE pTable)
{
    pTable->Flags &= ~SHASH_CAP_TABLE_LOCKED; 
    LeaveCriticalSection(pTable->pLock); 

    return TRUE;
}


void * SHashAllocLock(void)
{  
    void * pMem = NULL;

    pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(CRITICAL_SECTION));
    if(pMem)
    {
        InitializeCriticalSection(pMem);
    }

    return pMem;
}


void SHashFreeLock(void * pMem)
{
    DeleteCriticalSection(pMem);
    HeapFree( GetProcessHeap(), 0, pMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\setup\setupsvc.cxx ===
//+------------------------------------------------------------------
//
// File:        SETUPSVC.CXX
//
// Contents:
//
// Synoposis:
//
// Classes:     CService
//
// Functions:
//
// History:     May 19, 1993        AlokS       Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <windowsx.h>
#include <shlobj.h>
#include <registry.hxx>
#include <setupsvc.hxx>

#include "resource.h"

#include "messages.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
extern HINSTANCE g_hInstance;

//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}

VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}
//+------------------------------------------------------------------
//
// Class: CService
//
// Purpose: Helper class for dealing with Service Controller
//
// Interface: CService::CService()          = Constructor
//            CService::~CService()         = Destructor
//            CService::Init()              = Initializes the class
//            CService::_CreateService()    = Install a Win32 Service
//            CService::_OpenService()      = Open an existing service
//            CService::_QueryServiceStatus() = Query servcie status.
//            CService::_CloseService()     = Close all resources associated with
//                       the service
//            CService::_DeleteService()    = Remove a Win32 Service
//            CService::_DisableService()   = Disables a Win32 Service
//            CService::_StartService()     = Start an existing service
//            CService::_StopService()      = Stop an existing, running service
//            CService::_ConfigService()    = Combo operation. Create if
//                                         not present else reconfigure it
//
// History: May 20, 1993         AlokS       Created
//
// Notes: This is a smart wrapper class for Service APIs. But it is not
//        multi-thread safe.
//
//-------------------------------------------------------------------

//+------------------------------------------------------------------
//
// Member: CService::CService
//
// Synopsis: Create an instance
//
// Effects: Instantiates the class
//
// Arguments: -none-
//
// Returns  : None.
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------

CService::CService():
       _schSCManager(NULL),
       _scHandle(NULL)
{
    ;
}
//+------------------------------------------------------------------
//
// Member: CService::Init
//
// Synopsis: Open handle to Service Controller
//
// Effects: -do-
//
// Arguments: -none-
//
// Returns  : 0 on success else error from opening SC.
//
// History: Nov 4, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------
DWORD   CService::Init()
{
    DWORD dwStatus = 0;
    // Open the local SC database
    _schSCManager =  OpenSCManager(NULL, // Machine Name
                                   NULL, // Database Name
                                   SC_MANAGER_CREATE_SERVICE|
                                   SC_MANAGER_LOCK
                                  );
    if (_schSCManager == NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR, "Error: %lx in opening SCManager", dwStatus));
    }
    return(dwStatus);
}
//+------------------------------------------------------------------
//
// Member: CService::~CService
//
// Synopsis: Release all resources
//
// Effects: Closes SC database handle as well as any  service handle
//
// Arguments: none
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Remember that we have only 1 service handle per instance.
//
//-------------------------------------------------------------------

CService::~CService()
{

    if (_schSCManager != NULL)
        CloseServiceHandle (_schSCManager);

    if (_scHandle != NULL)
        CloseServiceHandle (_scHandle);
}
//+------------------------------------------------------------------
//
// Member: CService::_CreateService
//
// Synopsis: This method is used to install a new Win32 Service or driver
//
// Effects: Creates a service.
//
// Arguments: all [in] parameters. See CreateService() API documentation
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of newly created service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_CreateService(const LPWSTR  lpwszServiceName,
                            const LPWSTR  lpwszDisplayName,
                                  DWORD   fdwDesiredAccess,
                                  DWORD   fdwServiceType,
                                  DWORD   fdwStartType,
                                  DWORD   fdwErrorControl,
                            const LPWSTR  lpwszBinaryPathName,
                            const LPWSTR  lpwszLoadOrderGroup,
                            const LPDWORD lpdwTagID,
                            const LPWSTR  lpwszDependencies,
                            const LPWSTR  lpwszServiceStartName,
                            const LPWSTR  lpwszPassword)
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;

    _scHandle  = CreateService(_schSCManager,
                                lpwszServiceName,
                                lpwszDisplayName,
                                fdwDesiredAccess,
                                fdwServiceType,
                                fdwStartType,
                                fdwErrorControl,
                                lpwszBinaryPathName,
                                lpwszLoadOrderGroup,
                                lpdwTagID,
                                lpwszDependencies,
                                lpwszServiceStartName,
                                lpwszPassword
                               );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                   "Error: %lx in CreateService: %ws\n",
                   dwStatus,
                   lpwszServiceName));
    }

    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_OpenService
//
// Synopsis: Opens the service if caller has specified proper access
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service
//            [in] fdwDesiredAccess = Open Access mode bits
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_OpenService( const LPWSTR lpwszServiceName,
                                 DWORD fdwDesiredAccess
                        )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              fdwDesiredAccess
                            );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in OpeningService: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    return dwStatus;

}

//+------------------------------------------------------------------
//
// Member: CService::_StartService
//
// Synopsis: Start the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to start
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StartService( const LPWSTR lpwszServiceName
                          )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_START|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!StartService(_scHandle, NULL, NULL))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Starting Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;

}
//+------------------------------------------------------------------
//
// Member: CService::_StopService
//
// Synopsis: Stop the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to stop
//
// Returns: 0 on success
//
// History: May 9, 1994         DaveStr       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StopService( const LPWSTR lpwszServiceName
                          )
{
    SERVICE_STATUS ss;

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_STOP|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!ControlService(_scHandle, SERVICE_CONTROL_STOP, &ss))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Controlling (stopping) Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_DeleteService
//
// Synopsis: Remove the named service
//
// Effects: Deletes a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to remove
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DeleteService( const LPWSTR lpwszServiceName )

{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG|
                             DELETE
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!DeleteService ( _scHandle))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in DeleteService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Member: CService::_DisableService
//
// Synopsis: Disable the named service
//
// Effects: Disables a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to disable
//
// Returns: 0 on success
//
// History: Dec 8, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DisableService( const LPWSTR lpwszServiceName )
{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!ChangeServiceConfig ( _scHandle,           // Handle
                                   SERVICE_NO_CHANGE,   // Type
                                   SERVICE_DISABLED,    // Start
                                   SERVICE_NO_CHANGE,   // Error
                                   NULL,                // Path
                                   NULL,                // Load order
                                   NULL,                // Tag
                                   NULL,                // Depend
                                   NULL,                // Start name
                                   NULL,                // Password
                                   NULL                 // Display Name
                                  ))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in ChangeService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_CloseService
//
// Synopsis:  Close a service for which we have an open handle
//
// Effects: Close service handle, if opened previously
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
void CService::_CloseService( )
{
    if (_scHandle != NULL)
        CloseServiceHandle ( _scHandle);
    _scHandle = NULL;
}

//+------------------------------------------------------------------
//
// Member: CService::_QueryServiceStatus
//
// Synopsis:  query current service status
//
// Effects: none
//
// Arguments: service_status - service status structure.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_QueryServiceStatus(LPSERVICE_STATUS ss)
{
    if (_scHandle != NULL) {

        if (!QueryServiceStatus(_scHandle, ss))
            return(GetLastError());

        return(0);
    }

    return(ERROR_INVALID_HANDLE);
}

//+------------------------------------------------------------------
//
// Member: CService::ConfigService
//
// Synopsis: Create else Open/Change the named Service
//
// Effects: It first tries to create a service. If one exists already,
//          it changes the configuration to new configuration.
//
// Arguments: Lots of them. See documentation on CreateService() API.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Most people should use this method only for setting up services
//
// MAJOR NOTE: It is essential that all the keys being asked to change
//             be actually present before they can be changed
//
//
//
//-------------------------------------------------------------------
WCHAR MsgBuf[0x1000];

DWORD CService::_ConfigService(   DWORD fdwServiceType,
                                  DWORD fdwStartType,
                                  DWORD fdwErrorControl,
                            const LPWSTR lpwszBinaryPathName,
                            const LPWSTR lpwszLoadOrderGroup,
                            const LPWSTR lpwszDependencies,
                            const LPWSTR lpwszServiceStartName,
                            const LPWSTR lpwszPassword,
                            const LPWSTR lpwszDisplayName,
                            const LPWSTR lpwszServiceName
                          )
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }

    DWORD dwStatus = ERROR_SERVICE_DATABASE_LOCKED;
    SC_LOCK scLock;

    //
    // Let us lock the database.  There could be a problem here
    // because the service controller also locks the database when
    // starting a service so it reads the startup parameters properly.
    // If this is the case, and the database is locked, we just try
    // up to 5 times to lock it ourselves before we fail. 
    //
    for ( ULONG tries = 0;
          (tries < 5) && (dwStatus == ERROR_SERVICE_DATABASE_LOCKED);
          tries++ )
    {
        scLock = LockServiceDatabase (_schSCManager);

        if ( scLock == NULL )
        {
            dwStatus = GetLastError();

            DSSCDebugOut((DEB_ERROR, "LockServiceDatabase(try %d) == %#0x\n",
                         tries, dwStatus));

            if ( dwStatus == ERROR_SERVICE_DATABASE_LOCKED )
            {
                Sleep ( 2 * 1000 );
            }
        }
        else
        {
            dwStatus = 0;
        }
    }

    if ( dwStatus != 0 )
    {
        return dwStatus;
    }

    // First, we try to create the service.
    dwStatus   =  _CreateService(
                                  lpwszServiceName,
                                  lpwszDisplayName,
                                  GENERIC_WRITE,         // Access
                                  fdwServiceType,
                                  fdwStartType,
                                  fdwErrorControl,
                                  lpwszBinaryPathName,
                                  lpwszLoadOrderGroup,
                                  NULL,                  // Tag ID
                                  lpwszDependencies,
                                  lpwszServiceStartName,
                                  lpwszPassword
                                 );
    // It is possible that service exists
    if ((dwStatus == ERROR_SERVICE_EXISTS) ||
        (dwStatus == ERROR_DUP_NAME))
    {
        // Open the service
        dwStatus =  _OpenService(lpwszServiceName,
                                 SERVICE_CHANGE_CONFIG|DELETE);

        if (!dwStatus) {

            if (!ChangeServiceConfig(_scHandle,
                                 fdwServiceType,
                                 fdwStartType,
                                 fdwErrorControl,
                                 lpwszBinaryPathName,
                                 lpwszLoadOrderGroup,
                                 NULL,
                                 lpwszDependencies,
                                 lpwszServiceStartName,
                                 lpwszPassword,
                                 lpwszDisplayName
                                 )) {

                //
                // Change didn't work, lets try to delete and recreate this
                // service.
                //

                dwStatus = 0;

                if (!DeleteService ( _scHandle)) {
                    // This is hopeless. Let us give up now
                    dwStatus = GetLastError();
                    DSSCDebugOut(( DEB_IERROR,
                                   "Error: %lx in DeleteService: %ws\n",
                                   dwStatus,
                                   lpwszServiceName));

                }

                _CloseService();

                if (!dwStatus) {
                    // last attempt to create
                    dwStatus   =  _CreateService(
                                                 lpwszServiceName,
                                                 lpwszDisplayName,
                                                 GENERIC_WRITE,         // Access
                                                 fdwServiceType,
                                                 fdwStartType,
                                                 fdwErrorControl,
                                                 lpwszBinaryPathName,
                                                 lpwszLoadOrderGroup,
                                                 NULL,                  // Tag ID
                                                 lpwszDependencies,
                                                 lpwszServiceStartName,
                                                 lpwszPassword
                                                );
                    DSSCDebugOut(( DEB_IERROR,
                                   "This is hopeless. Recreating failed!!\n"));

                }

            }

        } // OpenService

    } // CreateService

    //
    // Set description
    //

    if (dwStatus == ERROR_SUCCESS) {

        SERVICE_DESCRIPTION ServiceDescription;

        // Open the service if the above did not
        if (_scHandle == NULL) {
            dwStatus =  _OpenService(
                                lpwszServiceName,
                                SERVICE_CHANGE_CONFIG);
        }

        if (dwStatus == ERROR_SUCCESS) {
            ULONG i;
            MyFormatMessage(MSG_DFS_DESCRIPTION, MsgBuf, sizeof(MsgBuf));
            for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
                if (MsgBuf[i] == L'\r')
                    MsgBuf[i] = UNICODE_NULL;
                else if (MsgBuf[i] == L'\n')
                    MsgBuf[i] = UNICODE_NULL;
            }
            ServiceDescription.lpDescription = MsgBuf;

            dwStatus = ChangeServiceConfig2(
                           _scHandle,
                           SERVICE_CONFIG_DESCRIPTION, // InfoLevel
                           &ServiceDescription);

            dwStatus = (dwStatus != 0) ? ERROR_SUCCESS : GetLastError();

        }

   }

    _CloseService();
    UnlockServiceDatabase ( scLock);
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Function: _StartService
//
// Synopsis:
//
// Effects: Starts the Service and any other
//          service dependent on it. It also ensures that the
//          service has started befor returning.
//
// Arguments: [pwsz] -- name of the service to be started
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:   This code was borrowed from the original StartDfs code
//          written by Aloks and parameterized  to allow other
//          services to be started. An interesting question is
//          whether this should be made a method of CDSSvc class.
//          (TBD by AlokS)
//
//-------------------------------------------------------------------
DWORD _SynchStartService(WCHAR *pwszServiceName)
{
    DWORD dwRc;
    // Open Service Controller
    CService cSvc;
    if ((dwRc = cSvc.Init())== ERROR_SUCCESS)
    {
        // Start the Service
        dwRc = cSvc._StartService(pwszServiceName);
        if (dwRc == ERROR_SERVICE_ALREADY_RUNNING)
        {
            // We are done!
            return ( ERROR_SUCCESS );
        }
    }
    if (dwRc)
    {
        DSSCDebugOut((DEB_IERROR, "Error starting:  %ws\n",pwszServiceName));
        return(dwRc);
    }

    // Wait for the service to start running
    SERVICE_STATUS scStatus;
    DWORD          MaxTries = 0;
    do
    {
        if (!QueryServiceStatus(cSvc.QueryService(),
                                &scStatus
                               ))
        {
            dwRc = GetLastError();
            DSSCDebugOut((DEB_IERROR, "Error Querying service\n"));
            break;
        }
        else if (scStatus.dwCurrentState != SERVICE_RUNNING)
        {
            Sleep(SERVICE_WAIT_TIME);
            MaxTries++;
        }

    } while ( scStatus.dwCurrentState != SERVICE_RUNNING && MaxTries < MAX_SERVICE_WAIT_RETRIES);
    if (MaxTries == MAX_SERVICE_WAIT_RETRIES)
    {
        dwRc = ERROR_SERVICE_REQUEST_TIMEOUT;
    }
    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: ConfigDfs
//
// Synopsis:
//
// Effects: Configures DFS File System Driver
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------

DWORD ConfigDfs()
{
    DWORD    dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    // Create DFS (Driver)
    dwErr = cSvc._ConfigService(
                    SERVICE_FILE_SYSTEM_DRIVER, // Service Type
                    SERVICE_BOOT_START,         // Start Type
                    SERVICE_ERROR_NORMAL,       // Error Control
                                                // service file
                    L"\\SystemRoot\\system32\\drivers\\Dfs.sys",
                    L"filter",                  // Load order group
                    NULL,                       // Dependency
                    NULL,                       // Service start name
                    NULL,                       // password
                    L"DfsDriver",               // display name
                    L"DfsDriver"                // Service Name
                    );

    if (dwErr)
        return dwErr;

    //
    // Registry Changes
    //

    //
    // Fix up the NetworkProvider order level - delete the Dfs provider
    // if one has been inserted there
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                PWCHAR pwszDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its not already there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");

                    if (pwszDfs != NULL) {
                        *pwszDfs = UNICODE_NULL;
                        wcscat( pwszProviders, pwszDfs + 4);
                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }
            }
        }
    }

    return dwErr;
}

//+------------------------------------------------------------------
//
// Function: StartDfs
//
// Synopsis:
//
// Effects: Starts out the DFS Service.
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------
DWORD StartDfs (
    GUID *pguidDomain,
    PWSTR pwszDomain
    )
{
    DWORD dwRc;

    //
    // We load the dfs driver and then call FindDomainController. This
    // call to FindDomainController is expected to seed the Dfs driver
    // with domain info.
    //

    dwRc = _SynchStartService(L"Dfs");

    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: RemoveDfs
//
// Synopsis:
//
// Effects: Remove DFS driver
//
//-------------------------------------------------------------------

DWORD
RemoveDfs(void)
{
    //DbgCommonApiTrace(RemoveDfs);

    DWORD dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Disable DFS driver
        dwErr = cSvc._DisableService(L"Dfs");
    }
    if (dwErr)
    {
        return(dwErr);
    }
    /*
     * Registry Changes
     */
    // Now, we remove entries under DFS entry in registry

    //
    // Remove Dfs from the NetworkProvider list
    //
    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                WCHAR *pwszDfs, *pwszAfterDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");
                    if (pwszDfs != NULL) {

                        pwszAfterDfs = pwszDfs + wcslen(L"Dfs,");

                        memmove(
                            (PVOID) pwszDfs,
                            (PVOID) pwszAfterDfs,
                            (wcslen( pwszAfterDfs ) + 1) * sizeof(WCHAR));

                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }

            }

        }

    }

    return dwErr ;
}

//+------------------------------------------------------------------
//
// Function: ConfigDfsService
//
// Synopsis:
//
// Effects: Configures Dfs Service
//
//-------------------------------------------------------------------

DWORD
ConfigDfsService()
{
    DWORD dwErr = 0;
    ULONG i;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    //
    // Get localizable name of service
    //
    MyFormatMessage(MSG_DFS_COMPONENT_NAME, MsgBuf, sizeof(MsgBuf));
    for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
        if (MsgBuf[i] == L'\r')
            MsgBuf[i] = UNICODE_NULL;
        else if (MsgBuf[i] == L'\n')
            MsgBuf[i] = UNICODE_NULL;
    }

    // Create entry for Dfs Manager
    dwErr = cSvc._ConfigService(

               SERVICE_WIN32_OWN_PROCESS,  // Service Type
               SERVICE_AUTO_START,         // Start Type
               SERVICE_ERROR_NORMAL,       // Error Control
               L"%SystemRoot%\\system32\\Dfssvc.exe",  // service binary
               L"Dfs",                     // Load order group
               L"LanmanWorkstation\0LanmanServer\0DfsDriver\0Mup\0",   // Dependency
               NULL,                       // Logon Name
               NULL,                       // Logon Password
               MsgBuf,                     // display name
               L"Dfs"                      // Service Name
               );

    if (dwErr == ERROR_SUCCESS) {
        CRegKey cregDfs( HKEY_LOCAL_MACHINE,
                          &dwErr,
                          L"System\\CurrentControlSet\\Services\\Dfs"
                       );

        if (dwErr == ERROR_SUCCESS)  {

            CRegDWORD DfsVer ((const CRegKey &)cregDfs, L"DfsVersion",
                               DFS_VERSION_NUMBER);

            dwErr = DfsVer.QueryErrorStatus();

        }
    }
    return dwErr ;
}


//+------------------------------------------------------------------
//
// Function: RemoveDfsService
//
// Synopsis:
//
// Effects: Remove Dfs Service
//
// Arguments: -none-
//
// Returns: 0 on success
//
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


DWORD RemoveDfsService( )
{
    DWORD dwErr = 0;

        // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Delete  DFSManager Service
        dwErr = cSvc._DeleteService(L"DfsService");
    }

    return dwErr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tests\apitest\apitest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       Main.CXX
//
//  Contents:   Main file for DfsApi
//
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "DfsReferralData.h"
#include <DfsServerLibrary.hxx>
#include <time.h>
#include "lm.h"
#include "lmdfs.h"
#include "tchar.h"

#define RETURN return
#undef ASSERT
#define ASSERT(x)

#define APINetDfsAdd    DfsAdd
#define APINetDfsRemove DfsRemove

DWORD
APINetDfsAddStdRoot(
    LPWSTR machine,
    LPWSTR Share,
    LPWSTR comment,
    DWORD Options)
{
    UNREFERENCED_PARAMETER(machine);

    return DfsAddStandaloneRoot(machine, Share, comment, Options);
}

DWORD
APINetDfsRemoveStdRoot(
    LPWSTR machine,
    LPWSTR Share,
    DWORD Options)
{
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(machine);
    return DfsDeleteStandaloneRoot(Share);
}

DWORD
APINetDfsEnum(
    LPWSTR DfsPath,
    DWORD Level,
    DWORD PrefMaxLen,
    LPBYTE *pBuffer,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle )
{
    LONG SizeRequired = 0;
    ULONG StartingLen = PrefMaxLen;
    LPBYTE Buffer;
    DFSSTATUS Status;

    if (StartingLen == ~0)
    {
        StartingLen = 4096;
    }

    Status = NetApiBufferAllocate(StartingLen, (LPVOID *)&Buffer );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsEnumerate( DfsPath,
                           Level,
                           PrefMaxLen,
                           Buffer,
                           StartingLen,
                           pEntriesRead,
                           pResumeHandle,
                           &SizeRequired );
    
    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        NetApiBufferFree(Buffer);
        Status = NetApiBufferAllocate( SizeRequired, (LPVOID *)&Buffer);
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
            
        Status = DfsEnumerate( DfsPath,
                               Level,
                               PrefMaxLen,
                               Buffer,
                               SizeRequired,
                               pEntriesRead,
                               pResumeHandle,
                               &SizeRequired );
    }
    if (Status != ERROR_SUCCESS)
    {
        NetApiBufferFree( Buffer );
    }
    else {
        *pBuffer = Buffer;
    }
    return Status;
}

DWORD
APINetDfsGetInfo(
    LPWSTR DfsPath,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE *pBuffer )
{
    LONG SizeRequired = 0;
    ULONG StartingLen = 4096;
    LPBYTE Buffer;
    DFSSTATUS Status;

    UNREFERENCED_PARAMETER(Share);
    UNREFERENCED_PARAMETER(Server);

    Status = NetApiBufferAllocate(StartingLen, (LPVOID *)&Buffer );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    Status = DfsGetInfo( DfsPath,
                         Level,
                         Buffer,
                         StartingLen,
                         &SizeRequired );
    if (Status == ERROR_BUFFER_OVERFLOW)
    {
        NetApiBufferFree(Buffer);
        Status = NetApiBufferAllocate(SizeRequired, (LPVOID *)&Buffer );
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
        Status = DfsGetInfo( DfsPath,
                             Level,
                             Buffer,
                             SizeRequired,
                             &SizeRequired );
    }
    if (Status != ERROR_SUCCESS)
    {
        NetApiBufferFree( Buffer );
    }
    else {
        *pBuffer = Buffer;
    }
    return Status;
}


DFSSTATUS
APINetDfsSetInfo(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD Level,
    LPBYTE pBuffer )
{

    return DfsSetInfo( DfsPathName,
                         ServerName,
                         ShareName,
                         Level,
                         pBuffer );

}


#if !defined(UNICODE) || !defined(_UNICODE)
#error For UNICODE only
#endif

#define	NOREBOOT		1
#define CHECK_ERR(x)
#define	ASSERT(x)

BOOL	bDebug = FALSE;
FILE*	fDebug = NULL;
#define	MSG	\
		if (bDebug) fprintf(fDebug, "File %s, %lu\n", __FILE__, __LINE__); \
		if (bDebug) fprintf

ULONG	Usage(LPSTR ptszAppNane);
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
#if 0
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv);

ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg);
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider);
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv);
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv);
#endif
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer);
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer);
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer);
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer);
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer);
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer);
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pStorage);
LPTSTR	GetStringParam(LPTSTR ptszParam);

DFSSTATUS
DfsAddHandledNamespace(
    LPWSTR Name, 
    BOOLEAN Migrate );


DFSSTATUS
DfsServerInitialize(ULONG Flags);

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Core function for the application.
//
//  Arguments:  [argc]    			--      The number of arguments
//				[argv]				--		The arguments
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG __cdecl main(int argc, char* argv[])
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwArgc = 0;
	LPTSTR*	pptszArgv = NULL;
	INT		i = 0;
	INT		nArgNdx = 0;
        DWORD Status;


        Status = DfsServerInitialize(0);
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server init error %d\n", Status);
            exit(-1);
        }

        Status = DfsAddHandledNamespace(L".", TRUE);
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server add namespace error %d\n", Status);
            exit(-1);
        }

        Sleep(2000);

        printf("\n\nContinuing\n");

	if (argc < 2 ||
		argv[1][1]=='?' && (
		argv[1][0]=='-' ||
		argv[1][0]=='/'))
	{
		ulErr = Usage(argv[0]);
		RETURN(ulErr);
	}

	if (NULL == (pptszArgv =
		(LPTSTR*)malloc(sizeof(LPTSTR)*max(argc,32))))
	{
		_ftprintf(stderr,
				  _T("Not enough memory\n"));

		ulErr = ERROR_NOT_ENOUGH_MEMORY;

        CHECK_ERR(ulErr);
		goto Error;
	}
	memset(pptszArgv, 0, sizeof(LPTSTR)*max(argc,32));

	for (i=0; i<argc; i++)
	{
#ifdef UNICODE
		if (NULL == (pptszArgv[i] = (LPTSTR)malloc(
			sizeof(_TCHAR)*(1+strlen(argv[i])))))
		{
			_ftprintf(stderr,
					  _T("Not enough memory\n"));
	
			ulErr = ERROR_NOT_ENOUGH_MEMORY;

            CHECK_ERR(ulErr);
			goto Error;
		}

		memset(pptszArgv[i],
			   0,
			   sizeof(TCHAR)*(1+strlen(argv[i])));
		mbstowcs(pptszArgv[i], argv[i], strlen(argv[i]));
#else
		pptszArgv[i]=argv[i];
#endif
		++dwArgc;
	} //for i

	if (pptszArgv[1] == _tcsstr(pptszArgv[1], _T("/debug")))
	{
		bDebug = TRUE;
		if (_T(':') == pptszArgv[1][strlen("/debug")])
		{
			if (NULL == (fDebug =
				_tfopen(pptszArgv[1]+strlen("/debug")+1, _T("wt+"))))
			{
				fprintf(stderr, "Opening %ws failed with %lu",
						pptszArgv[1]+strlen("/debug")+1,
						errno);
			}
		} //if

		if (NULL == fDebug)
		{
			fDebug = stderr;
		} //if

		MSG(fDebug,
			"\n\nDebug report for %ws\n",
			pptszArgv[0]);
		nArgNdx++;
	} //if

    for (i=0; i<argc; i++)
    {
        MSG(fDebug,
            "\tpptszArgv[%d]==\"%ws\"\n",
            i,
            pptszArgv[i]);
    }
    MSG(fDebug,
        "\tnArgNdx==%d\n",
        nArgNdx);

	if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("add")))
	{
		ulErr = Add(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("remove")))
	{
		ulErr = Remove(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("enum")))
	{
		ulErr = Enum(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getinfo")))
	{
		ulErr = GetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdroot")))
	{
		ulErr = AddStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removestdroot")))
	{
		ulErr = RemoveStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}


	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setinfo")))
	{
		ulErr = SetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
#if 0
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getclientinfo")))
	{
		ulErr = GetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setclientinfo")))
	{
		ulErr = SetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addftroot")))
	{
		ulErr = AddFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftroot")))
	{
		ulErr = RemoveFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftrootforced")))
	{
		ulErr = RemoveFtRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdrootforced")))
	{
		ulErr = AddStdRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getdcaddress")))
	{
		ulErr = GetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setdcaddress")))
	{
		ulErr = SetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetaddconnection")))
	{
		ulErr = AddConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetcancelconnection")))
	{
		ulErr = CancelConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addresstosite")))
	{
		ulErr = AddressToSite(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else
	{
		ulErr = ERROR_INVALID_PARAMETER;

        CHECK_ERR(ulErr);
		goto Error;
	}

	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	fprintf(stdout, "%ws completed successfully\n", pptszArgv[0]);
	goto Cleanup;

Error:;
	fprintf(stderr, "%ws failed: %lu\n", pptszArgv[0], ulErr);
	goto Cleanup;

Cleanup:;
	if (NULL != pptszArgv)
	{
		DWORD	dwI = 0;

		for (dwI=0; dwI < dwArgc; dwI++)
		{
#ifdef UNICODE
			if (NULL != pptszArgv[dwI])
			{
				free(pptszArgv[dwI]);
				pptszArgv[dwI] = NULL;
			} //if
#endif
		} //for

		free(pptszArgv);
		pptszArgv = NULL;
	} //if

	if (fDebug != NULL && fDebug != stderr)
	{
		fclose(fDebug);
	}

	RETURN(ulErr);
}; //main



	
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   This function prints a help message to stderr
//
//  Arguments:  None.
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Usage(LPSTR ptszAppName)
{
	fprintf(stderr,
			"Usage: %s [/debug:[<filename>]] <command> <options>\n\n"
			"commands:\n"
			"\tadd <dfsentrypath> <server> <share> [<comment> [<options>]]\n"
			"\t    [/range:<lo>-<hi>]\n"
			"\t\toptions=add|restore\n"
			"\t\t/range works with options=add only. When /range is present\n"
			"\t\tthe command adds multiple links\n"
			"\tremove <dfsentrypath> [<server> <share>]\n"
			"\tenum <dfsname> <level> [<prefmaxlen>]\n"
			"\t\tprefmaxlen=integer greater than 0 (resume only)\n"
			"\t\tlevel=1,2,3,4,200\n"
			"\tgetinfo <dfsentrypath> <server> <share> <level>\n"
			"\t\tlevel=1,2,3,4,100\n"
			"\tsetinfo <dfsentrypath> <server> <share> <level> <options>\n"
			"\t\tlevel=100, options=<comment>, no <server>, <share>\n"
			"\t\tlevel=101, options=[active] [offline] [online] when <server> is not null\n"
			"\t\tlevel=101, options=ok|inconsistent|offline|online when <server> is null\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
			"\tgetclientinfo <dfsentrypath> [<server> <share>] <level>\n"
			"\t\tlevel=1,2,3,4\n"
			"\tsetclientinfo <dfsentrypath> [<server> <share>] <level> <options>\n"
			"\t\tlevel=101, options=[active] [offline] [online]\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
                        "\taddstdroot <servername> <rootshare> [<comment> [<options>]]\n"
                        "\tremovestdroot <servername> <rootshare> [<options>]\n"
#if 0
			"\taddftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftrootforced <domainname> <servername> <rootshare> "
			"<ftdfsname> [<options>]\n"
			"\taddstdrootforced <servername> <rootshare> [<comment>] <store>\n"
			"\tgetdcaddress <servername>\n"
			"\tsetdcaddress <servername> <dcipaddress> <timeout> [<flags>]\n"
                        "\twnetaddconnection <level> <remotename> <password> [<localname>] [<level2params>]\n"
#endif
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, *, LPT1, etc.\n"
			"\t\tlevel2params=<type> [<provider>] [<username>] [<flags>]\n"
			"\t\ttype=disk|print|any\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\twnetcancelconnection <level> <localname> [<flags>] [force]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, etc\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\t\tforce=if present, the deletion of the connection is forced\n"
			"\n"
			"\taddresstosite <dcname> <ipaddress>\n\n"
			"To specify a NULL string in the middle of the command, use "
			"\"\".\n"
			"Example: setinfo \\\\myserver\\myentrypath \"\" \"\" "
			"100 \"My comment\".\n",
			ptszAppName);
	RETURN(ERROR_INVALID_PARAMETER);
};//Usage



	
//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   This function performs NetDfsAdd.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	ULONG	ulLo = 0;
	ULONG	ulHi = 0;
	LPTSTR	ptszVolName = NULL;
	LPTSTR	ptszRange = NULL;
	LPTSTR	ptszMinus = NULL;

	MSG(fDebug, "Entering Add(%lu,...)\n", dwArgc);
	if (dwArgc < 3 || NULL == pptszArgv || dwArgc > 6)
	{
		MSG(fDebug, "%lu < 3 || NULL == pptszArgv || %lu > 6",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (4 < dwArgc)
	{
		if (0 == _tcsicmp(pptszArgv[4], _T("add")))
		{
			dwFlags = DFS_ADD_VOLUME;
		}
		else if (0 == _tcsicmp(pptszArgv[4], _T("restore")))
		{
			dwFlags = DFS_RESTORE_VOLUME;
		}
		else
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	if (5 < dwArgc)
	{
		if (0 != _tcsnicmp(pptszArgv[5],
						   _T("/range:"),
						   _tcslen(_T("/range:"))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		ptszRange = pptszArgv[5]+_tcslen(_T("/range:"));
		if (NULL == (ptszMinus = _tcschr(ptszRange, _T('-'))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		*ptszMinus = _T('\0');
		ulLo = _ttol(ptszRange);

		*ptszMinus = _T('-');
		ulHi = _ttol(ptszMinus+1);

		if (ulLo > ulHi)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	MSG(fDebug,
		"Calling NetDfsAdd(%ws, %ws, %ws, %ws, %lu)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]), 
		GetStringParam(pptszArgv[3]),
		dwFlags);
	if (0 == ulLo && 0 == ulHi)
	{
		ulErr = APINetDfsAdd(GetStringParam(pptszArgv[0]),
						  GetStringParam(pptszArgv[1]),
						  GetStringParam(pptszArgv[2]),
						  GetStringParam(pptszArgv[3]),
						  dwFlags);
	}
	else
	{
		ULONG	ulLen = 0;

		if (NULL != GetStringParam(pptszArgv[0]))
		{
			ulLen += _tcslen(GetStringParam(pptszArgv[0]));
		}

		ptszVolName = new TCHAR[ulLen+11];
		if (NULL != ptszVolName)
		{
			memset(ptszVolName, 0, (11+ulLen) * sizeof(TCHAR));
			if (NULL != GetStringParam(pptszArgv[0]))
			{
				_tcscpy(ptszVolName, GetStringParam(pptszArgv[0]));
			}

			for (ULONG i=ulLo;
				 i <= ulHi && ERROR_SUCCESS == ulErr;
				 i++)
			{
				memset(ptszVolName+ulLen, 0, sizeof(TCHAR)*11);
				_ltot(i, ptszVolName+ulLen, 10);

				ulErr = APINetDfsAdd(ptszVolName,
								  GetStringParam(pptszArgv[1]),
								  GetStringParam(pptszArgv[2]),
								  GetStringParam(pptszArgv[3]),
								  dwFlags);
				MSG(fDebug,
					"NetDfsAdd(%ws, %ws, %ws, %ws, %lu) %s\n",
					ptszVolName,
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					GetStringParam(pptszArgv[3]),
					dwFlags,
					((ERROR_SUCCESS == ulErr) ? "succeded" : "failed"));
			} //for

			delete ptszVolName;
		}
		else
		{
			MSG(fDebug,
				"Error %lu: not enough memory\n",
				ulErr = ERROR_NOT_ENOUGH_MEMORY);
		} //else
	} //else

	MSG(fDebug, "Exiting Add(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Add



	
//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   This function performs NetDfsRemove.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug, "Entering Remove(%lu,..)\n", dwArgc);
	if (dwArgc < 1 || dwArgc > 3 || NULL == pptszArgv ||
		dwArgc > 1 && NULL == pptszArgv[1] ||
		dwArgc > 2 && NULL == pptszArgv[2] ||
		2 == dwArgc)
	{
		MSG(fDebug,
			"%lu < 1 || %lu > 3 || NULL == pptszArgv ||"
			" %lu > 1 && NULL == %ws ||"
			" %lu > 2 && NULL == %ws ||"
			" 2 == %lu",
			dwArgc, dwArgc, dwArgc, pptszArgv[1], dwArgc,
			pptszArgv[2], dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug, "Calling NetDfsRemove(%ws, %ws, %ws)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]));
	ulErr = APINetDfsRemove(GetStringParam(pptszArgv[0]),
						 GetStringParam(pptszArgv[1]),
						 GetStringParam(pptszArgv[2]));

	MSG(fDebug, "Exiting Remove(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Remove



	
//+---------------------------------------------------------------------------
//
//  Function:   Enum
//
//  Synopsis:   This function performs NetDfsEnum.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	DWORD	dwPrefMaxLen = (DWORD)-1;
	LPBYTE	pBuffer = NULL;
	DWORD	dwEntriesRead = 0;
	DWORD	dwResumeHandle = 0;

	MSG(fDebug, "Entering Enum(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 ||
		NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[1], _T("1")))
	{
		dwLevel = 1;
		dwPrefMaxLen = sizeof(DFS_INFO_1);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("2")))
	{
		dwLevel = 2;
		dwPrefMaxLen = sizeof(DFS_INFO_2);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("3")))
	{
		dwLevel = 3;
		dwPrefMaxLen = sizeof(DFS_INFO_3);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("4")))
	{
		dwLevel = 4;
		dwPrefMaxLen = sizeof(DFS_INFO_4);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("200")))
	{
		dwLevel = 200;
		dwPrefMaxLen = sizeof(DFS_INFO_200);
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc)
	{
		dwPrefMaxLen = (DWORD)-1;
	}
	else
	{
		if (3 != dwArgc || NULL == pptszArgv[2] ||
			0 >= _ttoi(pptszArgv[2]))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		dwPrefMaxLen *= _ttoi(pptszArgv[2]);
	}

	MSG(fDebug, "Calling NetDfsEnum(%ws,%lu,%lu,..,..,%lu)\n",
		pptszArgv[0], dwLevel, dwPrefMaxLen, dwResumeHandle);
	ulErr = APINetDfsEnum(GetStringParam(pptszArgv[0]),
                       dwLevel,
					   dwPrefMaxLen,
					   &pBuffer,
					   &dwEntriesRead,
					   &dwResumeHandle);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	if ((DWORD)-1 == dwPrefMaxLen)
	{
		LPBYTE	pCurBuffer = pBuffer;
		for (DWORD i=0; i<dwEntriesRead; i++)
		{
			ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}

			switch (dwLevel)
			{
				case 1:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
					break;
				case 2:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
					break;
				case 3:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
					break;
				case 4:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
					break;
				case 200:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
					break;
				default:
					ulErr = ERROR_INVALID_PARAMETER;
					goto Error;
			} //switch
		} //for
	}
	else
	{
		do
		{
			LPBYTE	pCurBuffer = pBuffer;
			for (DWORD i=0; i<dwEntriesRead; i++)
			{
				ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
				if (ERROR_SUCCESS != ulErr)
				{
					goto Error;
				}
	
				switch (dwLevel)
				{
					case 1:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
						break;
					case 2:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
						break;
					case 3:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
						break;
					case 4:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
						break;
					case 200:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
						break;
					default:
						ulErr = ERROR_INVALID_PARAMETER;
						goto Error;
				} //switch
			} //for

			if (NULL != pBuffer)
			{
				NetApiBufferFree(pBuffer);
				pBuffer = NULL;
			}

			MSG(fDebug,
				"Calling NetDfsEnum(%ws, %lu, %lu,..,..,%lu)\n",
				GetStringParam(pptszArgv[0]),
				dwLevel,
				dwPrefMaxLen,
				dwResumeHandle);
			ulErr = APINetDfsEnum(
						GetStringParam(pptszArgv[0]),
						dwLevel,
						dwPrefMaxLen,
						&pBuffer,
						&dwEntriesRead,
						&dwResumeHandle);
			if (ERROR_NO_MORE_ITEMS == ulErr)
			{
				if (0 != dwEntriesRead)
				{
					continue;
				}
				else
				{
					ulErr = ERROR_SUCCESS;
					break;
				}
			} //if

			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}
		}
		while(TRUE);
	} //else

Error:;
	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug,
		"Exiting Enum with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //Enum




	
//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   This function performs NetDfsGetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug, "4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		dwLevel = 100;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Calling NetDfsGetInfo(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = APINetDfsGetInfo(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[2]),
				dwLevel,
				&pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetInfo





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRoot
//
//  Synopsis:   This function performs NetDfsAddStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	MSG(fDebug,
		"Calling NetDfsAddStdRoot(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = APINetDfsAddStdRoot(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
                GetStringParam(pptszArgv[2]),
				dwOptions);

	MSG(fDebug, "Exiting AddStdRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   RemoveStdRoot
//
//  Synopsis:   This function performs NetDfsRemoveStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 3 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || %lu > 3 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (3 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[2]);
	}

	MSG(fDebug,
		"Calling NetDfsRemoveStdRoot"
		"(%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		dwOptions);
	ulErr = APINetDfsRemoveStdRoot(
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            dwOptions);

	MSG(fDebug,
		"Exiting RemoveStdRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   This function performs NetDfsSetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug,
		"Calling SetInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		DFS_INFO_100 info;

		if (4 < dwArgc)
		{
			if (5 != dwArgc)
			{
				MSG(fDebug,
					"%ws == \"100\" && 5 != %dwArgc\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			}

			info.Comment = pptszArgv[4];
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            GetStringParam(pptszArgv[2]),
			100);
		ulErr = APINetDfsSetInfo(
					GetStringParam(pptszArgv[0]),
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					100,
					(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws==\"101\" && "
					"4 < %lu && "
					"8 < %lu",
					pptszArgv[3], dwArgc, dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			if (NULL != GetStringParam(pptszArgv[1]))
			{
				if (NULL == GetStringParam(pptszArgv[2]))
				{
					MSG(fDebug,
						"4 < %lu && "
						"NULL != %ws && "
						"NULL == %ws\n",
						dwArgc, GetStringParam(pptszArgv[1]),
						GetStringParam(pptszArgv[2]));
					RETURN(ERROR_INVALID_PARAMETER);
				}

				for (i = 4; i<dwArgc; i++)
				{
					if (0 == _tcsicmp(pptszArgv[i], _T("active")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ACTIVE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_OFFLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ONLINE;
					}
					else
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
				} //for i
			}
			else
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("ok")))
				{
					info.State = DFS_VOLUME_STATE_OK;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("inconsistent")))
				{
					info.State = DFS_VOLUME_STATE_INCONSISTENT;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					info.State = DFS_VOLUME_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					info.State = DFS_VOLUME_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //else
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = APINetDfsSetInfo(GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  101,
							  (LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[4],
					dwTimeout);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = APINetDfsSetInfo(
							  GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  102,
							  (LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Exiting SetInfo(..) with %lu", ulErr);
	RETURN(ulErr);
}; //SetInfo



#if 0
	
//+---------------------------------------------------------------------------
//
//  Function:   GetClientInfo
//
//  Synopsis:   This function performs NetDfsGetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetClientInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Calling NetDfsGetClientInfo"
		"(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetClientInfo(
			  GetStringParam(pptszArgv[0]),
			  GetStringParam(pptszArgv[1]),
			  GetStringParam(pptszArgv[2]),
			  dwLevel,
			  &pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetClientInfo





//+---------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Synopsis:   This function performs NetDfsSetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug, "Entering SetClientInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws == \"101\" && "
					"4 < %lu && "
					"8 < %lu\n",
					pptszArgv[3],
					dwArgc,
					dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			for (i = 4; i<dwArgc; i++)
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("active")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ACTIVE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //for i
		} //if

		MSG(fDebug,
			"Calling NetDfsSetClientInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									101,
									(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		}

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;


		MSG(fDebug,
			"Calling NetDfsSetClientInfo"
			"(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									102,
									(LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Exiting SetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //SetClientInfo






//+---------------------------------------------------------------------------
//
//  Function:   AddFtRoot
//
//  Synopsis:   This function performs NetDfsAddFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[4]);
	}

	MSG(fDebug,
		"Calling NetDfsAddFtRoot(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
        GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsAddFtRoot(GetStringParam(pptszArgv[0]),
							GetStringParam(pptszArgv[1]),
							GetStringParam(pptszArgv[2]),
							GetStringParam(pptszArgv[3]),
							dwOptions);

	MSG(fDebug, "Exiting AddFtRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRoot
//
//  Synopsis:   This function performs NetDfsRemoveFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || %lu > 4 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRoot"
		"(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsRemoveFtRoot(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[2]),
							   dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRootForced
//
//  Synopsis:   This function performs NetDfsRemoveFtRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || %lu > 5 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRootForced"
		"(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsRemoveFtRootForced(GetStringParam(pptszArgv[0]),
									 GetStringParam(pptszArgv[1]),
									 GetStringParam(pptszArgv[2]),
									 GetStringParam(pptszArgv[3]),
									 dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRootForced(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRootForced





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRootForced
//
//  Synopsis:   This function performs NetDfsAddStdRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsAddStdRootForced(%ws,%ws,%ws,%ws)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]));
	ulErr = NetDfsAddStdRootForced(GetStringParam(pptszArgv[0]),
								   GetStringParam(pptszArgv[1]),
								   GetStringParam(pptszArgv[2]),
								   GetStringParam(pptszArgv[3]));

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot





//+---------------------------------------------------------------------------
//
//  Function:   GetDcAddress
//
//  Synopsis:   This function performs NetDfsGetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;
	LPTSTR	ptszIpAddress = NULL;
	BOOLEAN	bIsRoot = FALSE;
	ULONG	ulTimeout = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (1 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu != 1 || NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsGetDcAddress(%ws,...)\n",
		GetStringParam(pptszArgv[0]));
	ulErr = NetDfsGetDcAddress(GetStringParam(pptszArgv[0]),
							   &ptszIpAddress,
							   &bIsRoot,
							   &ulTimeout);

	if (ERROR_SUCCESS == ulErr)
	{
		LPTSTR	ptszIs = bIsRoot?_T("is"):_T("is not");

		fprintf(stdout,
				"%ws %ws a Dfs server and it will be "
				"sticking to the DC having the %ws "
				"address for %lu seconds\n",
				GetStringParam(pptszArgv[0]),
				ptszIs,
				ptszIpAddress,
				ulTimeout);
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve DC address "
				"for %ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]));
	}

	if (NULL != ptszIpAddress)
	{
		NetApiBufferFree(ptszIpAddress);
	}

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetDcAddress





//+---------------------------------------------------------------------------
//
//  Function:   SetDcAddress
//
//  Synopsis:   This function performs NetDfsSetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	ULONG	ulTimeout = 0;
	ULONG	ulFlags = 0;

	MSG(fDebug,
		"Entering SetDcAddress(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	ulTimeout = (ULONG)_ttol(GetStringParam(pptszArgv[2]));
	ulFlags = 0;

	MSG(fDebug,
		"Calling NetDfsSetDcAddress(%ws,%ws,%lu,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		ulTimeout,
		ulFlags);
	ulErr = NetDfsSetDcAddress(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   ulTimeout,
							   ulFlags);

	MSG(fDebug, "Exiting NetDfsSetDcAddress(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot







//+---------------------------------------------------------------------------
//
//  Function:   AddConnection
//
//  Synopsis:   This function performs WNetAddConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = AddConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = AddConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //AddConnection





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection1
//
//  Synopsis:   This function performs WNetAddConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //AddConnection1





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection2
//
//  Synopsis:   This function performs WNetAddConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG		ulErr = ERROR_SUCCESS;
	NETRESOURCE	NetResource;
	DWORD		dwFlags = 0;
	TCHAR		tszLocalName[128+1];
	ULONG		ulLocalNameLen = 128;

	MSG(fDebug,
		 "Entering AddConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 5)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}
	
	memset(tszLocalName, 0, sizeof(tszLocalName));
	ulErr = GetLocalName(tszLocalName,
						 ulLocalNameLen,
						 GetStringParam(pptszArgv[2]));
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	ulErr = GetNetResource(&NetResource,
						   GetStringParam(pptszArgv[3]),	// type
						   tszLocalName,					// localname
						   GetStringParam(pptszArgv[0]),	// remotename
						   GetStringParam(pptszArgv[4]));	// provider
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-6,
								   pptszArgv+6);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		 "Calling WNetAddConnection2(.., %ws, %ws, %lu)\n",
		 GetStringParam(pptszArgv[1]),
		 GetStringParam(pptszArgv[5]),
		 dwFlags);
	ulErr = WNetAddConnection2(&NetResource,
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[5]),
							   dwFlags);
Error:;	
	
	MSG(fDebug,
		 "Exiting AddConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //AddConnection2





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection
//
//  Synopsis:   This function performs WNetCancelConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = CancelConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = CancelConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //CancelConnection





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection1
//
//  Synopsis:   This function performs WNetCancelConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //CancelConnection1





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection2
//
//  Synopsis:   This function performs WNetCancelConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	BOOL	bForce = FALSE;

	MSG(fDebug,
		 "Entering CancelConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 0)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc	&&
		0 == _tcsicmp(_T("force"), pptszArgv[dwArgc-1]))
	{
		bForce = TRUE;
		--dwArgc;
	}
	
	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-1,
								   pptszArgv+1);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		"Calling WNetCancelConnection2(%ws, %lu, %ws)\n",
		GetStringParam(pptszArgv[0]),
		dwFlags,
		bForce ? _T("TRUE") : _T("FALSE"));
	ulErr = WNetCancelConnection2(GetStringParam(pptszArgv[0]),
								  dwFlags,
								  bForce);
	
Error:;	
	
	MSG(fDebug,
		 "Exiting CancelConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //CancelConnection2





//+---------------------------------------------------------------------------
//
//  Function:   GetLocalName
//
//  Synopsis:   This function returns the first available letter for net 
//				use
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg)
{
	ULONG	ulErr = ERROR_SUCCESS;
	CHAR	szDrive[4];
	BOOL	bFound = FALSE;

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws)\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg);
	if (NULL != ptszArg	&&
		0 != _tcsicmp(ptszArg, _T("available")) &&
		0 != _tcsicmp(ptszArg, _T("*")))
	{
		if (ulLocalNameLen < _tcslen(ptszArg))
		{
			RETURN(ERROR_NO_SYSTEM_RESOURCES);
		}

		_tcscpy(ptszLocalName, ptszArg);
	}
	else
	{
		if (ulLocalNameLen < 2)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	szDrive[1] = ':';
	szDrive[2] = '\\';
	szDrive[3] = '\0';
	for (CHAR C='C'; !bFound && C<='Z'; C++)
	{
		ULONG	ulType = 0;

		szDrive[0] = C;
		switch (ulType = GetDriveTypeA(szDrive))
		{
			case	0:
			case	DRIVE_REMOVABLE:
			case	DRIVE_FIXED:
			case	DRIVE_REMOTE:
			case	DRIVE_CDROM:
			case	DRIVE_RAMDISK:
				MSG(fDebug,
					"%s is of type %lu\n",
					szDrive,
					ulType);
				continue;

			case	1:
				bFound = TRUE;
				break;

			default:
				ASSERT(FALSE);
		}// switch
	} //for

	if (!bFound)
	{
		ulErr = ERROR_NO_SYSTEM_RESOURCES;
	}
	else
	{
		szDrive[2] = '\0';
#ifdef	UNICODE
		mbstowcs(ptszLocalName, szDrive, ulLocalNameLen);
#else
		_strcpy(ptszLocalName, szDrive);
#endif
	}

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws) with %lu\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg,
		ulErr);
	RETURN(ulErr);
}; //GetLocalName




//+---------------------------------------------------------------------------
//
//  Function:   GetNetResource
//
//  Synopsis:   This function fils a NETRESOURCE structure out
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwType = 0;
	
	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws)\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider);
	if (NULL == pNetResource	||
		NULL == ptszType)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	memset(pNetResource, 0, sizeof(NETRESOURCE));
	if (0 == _tcsicmp(ptszType, _T("disk")))
	{
		dwType = RESOURCETYPE_DISK;
	}
	else if (0 == _tcsicmp(ptszType, _T("print")))
	{
		dwType = RESOURCETYPE_PRINT;
	}
	else if (0 == _tcsicmp(ptszType, _T("any")))
	{
		dwType = RESOURCETYPE_ANY;
	}
	else
	{
		MSG(fDebug,
			 "%ws is an invalid type\n",
			 ptszType);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	pNetResource->dwType = dwType;
	pNetResource->lpLocalName = ptszLocalName;
	pNetResource->lpRemoteName = ptszRemoteName;
	pNetResource->lpProvider = ptszProvider;

	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws) with %lu\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider,
		 ulErr);
	RETURN(ulErr);
}; //GetNetResource





//+---------------------------------------------------------------------------
//
//  Function:   GetWNetConnectionFlags
//
//  Synopsis:   This function returns flags for WNetAddConnection2
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug,
		 "Entering CWNetAddConnection2Flags(.., %lu, ..)\n",
		 dwArgc);
	if (NULL == pdwFlags	||
		NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	*pdwFlags = 0;
	for (ULONG i=0; i<dwArgc; i++)
	{
		if (0 == _tcsicmp(_T("update_profile"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_PROFILE;
		}
		else if (0 == _tcsicmp(_T("update_recent"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_RECENT;
		}
		else if (0 == _tcsicmp(_T("temporary"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_TEMPORARY;
		}
		else if (0 == _tcsicmp(_T("interactive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_INTERACTIVE;
		}
		else if (0 == _tcsicmp(_T("prompt"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_PROMPT;
		}
		else if (0 == _tcsicmp(_T("need_drive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_NEED_DRIVE;
		}
		else if (0 == _tcsicmp(_T("refcount"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REFCOUNT;
		}
		else if (0 == _tcsicmp(_T("redirect"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REDIRECT;
		}
		else if (0 == _tcsicmp(_T("localdrive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_LOCALDRIVE;
		}
		else if (0 == _tcsicmp(_T("current_media"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_CURRENT_MEDIA;
		}
		else if (0 == _tcsicmp(_T("deferred"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_DEFERRED;
		}
		else
		{
			MSG(fDebug,
				 "Error %lu: %ws is an invalid flag\n",
				 ulErr = ERROR_INVALID_PARAMETER,
				 pptszArgv[i]);
		}
	} //for

	MSG(fDebug,
		 "Exiting CWNetAddConnection2Flags(.., %lu, ..) with %lu\n",
		 dwArgc,
		 ulErr);
	RETURN(ulErr);
}; //GetWNetAddconnection2Flags




//+---------------------------------------------------------------------------
//
//  Function:   AddressToSite
//
//  Synopsis:   This function performs DsAddressToSiteNames
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv)
{
	ULONG			ulErr = ERROR_SUCCESS;
	CString			sIp;
	CStringA		sIpA;
	ULONG			ulIP = 0;
	WSADATA			wsaData;
	PHOSTENT		pHost = NULL;
	SOCKET_ADDRESS	SocketAddress;
	SOCKADDR_IN		SockAddrIn;
	LPTSTR*			pptszSites = NULL;

	MSG(fDebug,
		"Entering AddressToSite(%lu, ...)\n",
		dwArgc);

	if (2 != dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (NULL == GetStringParam(pptszArgv[1]))
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	ulErr = sIp.Set(GetStringParam(pptszArgv[1]));
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}

	ulErr = sIpA.Set(sIp);
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}
	
	ulIP = inet_addr(sIpA.GetStringA());
	if (INADDR_NONE == ulIP)
	{
		fprintf(stderr,
				"Error %lu: invalid address %s\n",
				ulErr = ERROR_INVALID_PARAMETER,
				sIpA.GetStringA());
		RETURN(ulErr);
	}

	ulErr = WSAStartup(MAKEWORD(2,2),
					   &wsaData);
	if (ERROR_SUCCESS != ulErr)
	{
		fprintf(stderr,
				"Error %lu: cannot startup sockets",
				ulErr);
		RETURN(ulErr);
	}

	pHost = gethostbyaddr((LPCSTR)&ulIP,
						  sizeof(ulIP),
						  AF_INET);
	if (NULL == pHost)
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve host address "
				"for %ws",
				ulErr = WSAGetLastError(),
				GetStringParam(pptszArgv[1]));

		WSACleanup();
		RETURN(ulErr);
	}

	
	SockAddrIn.sin_family = pHost->h_addrtype;
	SockAddrIn.sin_port = 0;
	memcpy(&SockAddrIn.sin_addr,
		   pHost->h_addr,
		   pHost->h_length);

	SocketAddress.iSockaddrLength = sizeof(SockAddrIn);
	SocketAddress.lpSockaddr = (LPSOCKADDR)&SockAddrIn;

	ulErr = DsAddressToSiteNames(GetStringParam(pptszArgv[0]),
								 1,
								 &SocketAddress,
								 &pptszSites);
	if (ERROR_SUCCESS == ulErr && NULL != pptszSites[0])
	{
		fprintf(stdout,
				"The site of %ws on DC \\\\%ws is %ws\n",
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[0]),
				pptszSites[0]);
		NetApiBufferFree(pptszSites);
	}
	else if (ERROR_SUCCESS == ulErr && NULL == pptszSites[0])
	{
		fprintf(stdout,
				"Error %lu: address %ws is not associated "
				"to a site or it has an invalid format\n",
				ulErr = ERROR_INVALID_PARAMETER,
				GetStringParam(pptszArgv[1]));
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve site of "
				"%ws from DC \\\\%ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]));
	}

	WSACleanup();

	MSG(fDebug,
		"Exiting AddressToSite(%lu, ...) with %lu\n",
		dwArgc,
		ulErr);
	RETURN(ulErr);
};	// AddressToSite




#endif

//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo
//
//  Synopsis:   This function prints a DFS_INFO_XXX buffer out.
//
//  Arguments:  [dwLevel]	the info level
//				[pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo(%lu,..)\n",
		dwLevel);
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	switch (dwLevel)
	{
		case 1:
			ulErr = PrintDfsInfo1((PDFS_INFO_1)pBuffer);
			break;
		case 2:
			ulErr = PrintDfsInfo2((PDFS_INFO_2)pBuffer);
			break;
		case 3:
			ulErr = PrintDfsInfo3((PDFS_INFO_3)pBuffer);
			break;
		case 4:
			ulErr = PrintDfsInfo4((PDFS_INFO_4)pBuffer);
			break;
		case 200:
			ulErr = PrintDfsInfo200((PDFS_INFO_200)pBuffer);
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);		
	} //switch

	MSG(fDebug,
		"Exiting PrintDfsInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo1
//
//  Synopsis:   This function prints a DFS_INFO_1 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo1(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->EntryPath);

	MSG(fDebug,
		"Exiting PrintDfsInfo1(..) witb %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo1





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo2
//
//  Synopsis:   This function prints a DFS_INFO_2 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo2(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);

	MSG(fDebug,
		"Exiting PrintDfsInfo2(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo2





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo3
//
//  Synopsis:   This function prints a DFS_INFO_3 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo3(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);
	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo3(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo3





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo4
//
//  Synopsis:   This function prints a DFS_INFO_4 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo4(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	fprintf(stdout, "%lus   ", pBuffer->Timeout);
	fprintf(stdout, "%lu storage(s)\n", pBuffer->NumberOfStorages);

	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo4(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo200
//
//  Synopsis:   This function prints a DFS_INFO_200 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo200(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->FtDfsName);

	MSG(fDebug,
		"Exiting PrintDfsInfo200(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintStgInfo
//
//  Synopsis:   This function prints a DFS_STORAGE_INFO buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintStgInfo(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "\t\\\\%ws\\%ws\t",
			pBuffer->ServerName, pBuffer->ShareName);

	if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
	{
		fprintf(stdout, "online  ");

		if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
	{
		fprintf(stdout, "offline ");

		if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_ACTIVE)
	{
		fprintf(stdout, "active  ");
	}

	fprintf(stdout, "\n");

	MSG(fDebug,
		"Exiting PrintStgInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintStgInfo





//+---------------------------------------------------------------------------
//
//  Function:   GetStringParam
//
//  Synopsis:   This function receives a string and it returns the 
//				string itself if it is a "good" one (not null, not 
//				empty, etc).
//
//  Arguments:  [ptszParam]	the string to evaluate
//
//  Returns:    the string itself or NULL.
//
//	Notes:
//
//----------------------------------------------------------------------------
LPTSTR	GetStringParam(LPTSTR ptszParam)
{
	if (NULL == ptszParam ||
		_T('\0') == ptszParam[0] ||
		0 == _tcscmp(_T("\"\""), ptszParam))
	{
		return(NULL);
	}

	return(ptszParam);
}; //GetStringParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\debug\debug.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

//////////////////////////////////////////////////////////////////////////////
// global variables. These could be local, but we want debuggers to be able
// to get at them. Use extern "C" to make them easier to find.

extern "C"
{
unsigned long DebugInfoLevel = DEF_INFOLEVEL;
unsigned long DebugInfoMask = 0xffffffff;
unsigned long DebugAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
}

//////////////////////////////////////////////////////////////////////////////
// local variables

static BOOL s_fCritSecInit = FALSE;
static BOOL s_fInfoLevelInit = FALSE;
static CRITICAL_SECTION s_csDebugPrint;
static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[2000];        // this is the message buffer

//////////////////////////////////////////////////////////////////////////////
// local functions

static int DebugInternalvprintf(const char *format, va_list arglist);
static int DebugInternalprintf(const char *format, ...);
static void DebugAssertInternalprintf(char const *pszfmt, ...);
static int PopUpError(char const* pszMsg, int iLine, char const* pszFile);

//////////////////////////////////////////////////////////////////////////////

static int DebugInternalvprintf(const char* format, va_list arglist)
{
    int ret;
    EnterCriticalSection(&s_csMessageBuf);
    ret = vsprintf(g_szMessageBuf, format, arglist);
    OutputDebugStringA(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return ret;
}

static int DebugInternalprintf(const char* format, ...)
{
    int ret;
    va_list va;
    va_start(va, format);
    ret = DebugInternalvprintf(format, va);
    va_end(va);
    return ret;
}

static void DebugAssertInternalprintf(char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    Debugvprintf(DEB_FORCE, "Assert", pszfmt, va);
    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void DEBUGAPI
DebugAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (DebugAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();
        DebugAssertInternalprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (DebugAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);
        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (DebugAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    DebugSetInfoLevel
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugInfoLevel;
    DebugInfoLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetInfoMask
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul = DebugInfoMask;
    DebugInfoMask = ulNewMask;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetAssertLevel
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugAssertLevel;
    DebugAssertLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

static int PopUpError(char const* szMsg, int iLine, char const* szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char* pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
                                | MB_SERVICE_NOTIFICATION
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    Debugvprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *  pszComp,
    char const *  ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | DebugInfoLevel) & DebugInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((DebugInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                DebugInternalprintf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            DebugInternalvprintf(ppszfmt, pargs);
        }

        if (DebugInfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                printf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define DEBUGKEY "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Debug"

//+----------------------------------------------------------------------------
// Function:    DebugCheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void DEBUGAPI
DebugCheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    if (s_fInfoLevelInit) return;
    if (!s_fCritSecInit) DebugInitialize();
    HKEY hKey;
    LONG lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
    s_fInfoLevelInit = TRUE;
}

//+----------------------------------------------------------------------------
// Function:    DebugInitialize
//
// Synopsis:    Performs debugging library initialization
//
//-----------------------------------------------------------------------------

void DebugInitialize(void)
{
    if (s_fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    s_fCritSecInit = TRUE;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\debug\debug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//  NOTE: you must call the DebugInitialize() API before calling any other
//  APIs!
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>      // for vsprintf
#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)
#define UNREFERENCED_PARM(x)    (x)

#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#ifndef DEBUGAPI
    #define DEBUGAPI __stdcall
#endif

//
// The following APIs are public and may be called
//

void DEBUGAPI
DebugInitialize(
    void);

unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel);

unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask);

unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel);

//
// The following APIs should never be called directly. They will be called
// via macros defined herein.
//

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list ArgList);

void DEBUGAPI
DebugAssertEx(
    char const *pszFile,
    int iLine,
    char const *pszMsg);

void DEBUGAPI
DebugCheckInit(
    char* pInfoLevelString,
    unsigned long* InfoLevel);

//
// Public assertion macros
//

#define DebugAssert(x) (void)((x) || (DebugAssertEx(__FILE__, __LINE__, #x),0))
#define DebugVerify(x) DebugAssert(x)

//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
    #define DEF_INFOLEVEL 0
#endif

#ifdef __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern "C" unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern "C" char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern "C" unsigned long comp##InfoLevel;\
        extern "C" char* comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }\
        class comp##CDbgTrace\
        {\
        private:\
            unsigned long _ulFlags;\
            char const * const _pszName;\
        public:\
            comp##CDbgTrace(unsigned long ulFlags, char const * const pszName)\
            : _ulFlags(ulFlags), _pszName(pszName)\
            {\
                comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
            }\
            ~comp##CDbgTrace()\
            {\
                comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
            }\
        };

#else  // ! __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern unsigned long comp##InfoLevel;\
        extern char *comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }

#endif // ! __cplusplus

#else // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define DebugInitialize()

#define DebugAssert(x)  NULL
#define DebugVerify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tests\referral\referraltest.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "ReferralTest.hxx"
#include "DfsReferralData.h"
#include <DfsServerLibrary.hxx>

DWORD
RpcInit();

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

VOID
ReferralServerUsage();


VOID
TestLinks();

DWORD
DfsTestThread(LPVOID TData );

#define UNICODE_PATH_SEP L'\\'

ULONG MaxLinks = sizeof(DfsTestLinks) /sizeof(struct _DFS_TEST_LINK);



INT64 TotalRef = 0;

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;


//
// The arguments we accept at commandline.
//
MAKEARG(Name);
SWITCH(L);
SWITCH(D);
SWITCH(M);
SWITCH(Trace);

ULONG Flags;

_cdecl
main(int argc, char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status;
    int argcw,i;
    
    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            printf("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    
    if (Status == ERROR_SUCCESS)
    {
        //
        // Initialize the server.
        //  
        Status = DfsServerInitialize( Flags );
        if (Status != ERROR_SUCCESS) {
            printf("Cannot continue: dfs server init error %d\n", Status);
            exit(-1);
        }
    }

    Sleep(200);

    for (i = 0; i < 10; i++) {
        if (Status == ERROR_SUCCESS) {
            HANDLE THandle;
            DWORD Tid;

            THandle = CreateThread (
                        NULL,
                        0,
                        DfsTestThread,
                        0,
                        0,
                        &Tid);

            if (THandle != NULL) {
                CloseHandle(THandle);
                printf("Created Test thread tid %d\n", Tid);
            }
            else {
                printf("Unable to create test thread\n");
                Status = GetLastError();
            }
        }
    }
    while (1) {
        Sleep(300000000);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NameSpace;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            }
            else {
                Status = DfsAddHandledNamespace( NameSpace, TRUE );
            }
        }
        else if (_wcsicmp(Arg, SwitchTrace) == 0)
        {
            fSwitchTrace = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchL) == 0)
        {
            fSwitchL = TRUE;
            Flags |= DFS_LOCAL_NAMESPACE;
        }
        else if (_wcsicmp(Arg, SwitchD) == 0)
        {
            Flags |= DFS_CREATE_DIRECTORIES;
        }
        else if (_wcsicmp(Arg, SwitchM) == 0)
        {
            Flags |= DFS_MIGRATE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ReferralServerUsage()
{
    printf("Usage:\n");
    printf("/D - Create directories\n");
    printf("/L - Run on the local root server\n");
    printf("/M - Migrate existing DFS to allow multiple roots\n");
    printf("/Name:<Namespace> - Handle referrals to the specified namespace\n");

    return;
}


DWORD
DfsTestThread(LPVOID TData )
{
    srand( (unsigned)GetCurrentThreadId());
    INT64 TotalThreadRef = 0;
    INT64 y;
    
    UNREFERENCED_PARAMETER(TData);

    while (1) {
        TestLinks();
        Sleep(20);
        TotalThreadRef += 5;
        TotalRef += 5;
        y = TotalRef;
        if ((TotalThreadRef % 1000)  == 0) {
            printf("Thread %d, Ref %I64d\n", GetCurrentThreadId(), TotalThreadRef);
        }
        if ((y % 10000) == 0) {
            printf("Total Referals %I64d\n", TotalRef);

        }
    }
    return 0;
}






DFSSTATUS 
DfsGenerateReferral(
    LPWSTR LinkName, 
    LPWSTR SiteName, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader);

VOID
DfsReleaseReferral(
    REFERRAL_HEADER *pReferralHeader);


LPWSTR MySite=L"Red-Bldg40";
VOID
TestLinks()
{

    UNICODE_STRING Name, Remaining;
    UNICODE_STRING LinkName, LinkRemains;
    REFERRAL_HEADER *pReferral;
    ULONG i,j;
    DFSSTATUS Status;
    BOOLEAN LinkMatches, RemainsMatches, ReplicaMatches;

    for (j = 0; j < 5; j++) {

        i = (unsigned)(GetCurrentThreadId());
        i += rand();
        i = i % MaxLinks;


        Status = DfsGenerateReferral( DfsTestLinks[i].Name,
                                      MySite,
                                      1000,
                                      1000,
                                      &pReferral );

        if (Status == ERROR_SUCCESS) {
            if (pReferral == NULL)
            {
                DbgBreakPoint();
            }

            RtlInitUnicodeString(&Name, &DfsTestLinks[i].Name[0]);
            RtlInitUnicodeString(&Remaining, &DfsTestLinks[i].RemainingName[0]);
            RtlInitUnicodeString(&LinkRemains, NULL);

            LinkName.Buffer = pReferral->LinkName;
            LinkName.Length = LinkName.MaximumLength = (USHORT)pReferral->LinkNameLength;

            LinkMatches = FALSE;
            RemainsMatches = FALSE;
            ReplicaMatches = FALSE;

            if (RtlPrefixUnicodeString(&LinkName, &Name, TRUE) == TRUE)
            {
                LinkMatches = TRUE;
                LinkRemains.Buffer = &Name.Buffer[(LinkName.Length / sizeof(WCHAR))];
                LinkRemains.MaximumLength = LinkRemains.Length = Name.Length - LinkName.Length;
                if (LinkRemains.Length && LinkRemains.Buffer[0] == UNICODE_PATH_SEP)
                {
                    LinkRemains.Buffer++;
                    LinkRemains.Length -= sizeof(WCHAR);
                }
                if (RtlCompareUnicodeString(&Remaining, &LinkRemains, TRUE) == 0)
                {
                        RemainsMatches = TRUE;
                }
                if (DfsTestLinks[i].NumberReplicas == pReferral->ReplicaCount)
                {
                    ReplicaMatches = TRUE;
                }

            }

            if (!LinkMatches || !RemainsMatches || !ReplicaMatches)
            {
                printf("Link Matches %x Rem %x Rep %x\n",
                       LinkMatches, RemainsMatches, ReplicaMatches );

                printf("Number of replicas %d, number got %d\n",
                       DfsTestLinks[i].NumberReplicas, pReferral->ReplicaCount);
                printf("LinkRem buffer %p. Name buf %p Linkn len %x name len %x Linkrem len %x remain len %x\n",
                       LinkRemains.Buffer, Name.Buffer, LinkName.Length, Name.Length, LinkRemains.Length, Remaining.Length);

                printf("Name %wZ Link %wZ Remains %wZ LinkRemains %wZ\n",
                       &Name, &LinkName, &Remaining, &LinkRemains);
            
            }

            DfsReleaseReferral(pReferral);
        }
        else{
            printf("Load for %wS Failde with %x\n", DfsTestLinks[i].Name, Status);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs